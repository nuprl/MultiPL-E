name: HumanEval_83_starts_one_ends
language: lua
prompt: "-- Given a positive integer n, return the count of the numbers of n-digit\n\
  -- positive integers that start or end with 1.\nlocal function starts_one_ends(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = starts_one_ends\n\
  \    lu.assertEquals(candidate(1), 1)\n    lu.assertEquals(candidate(2), 18)\n \
  \   lu.assertEquals(candidate(3), 180)\n    lu.assertEquals(candidate(4), 1800)\n\
  \    lu.assertEquals(candidate(5), 18000)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if n < 10 then\n    return 1\n  end\n  if n < 100 then\n    return\
    \ 2\n  end\n  if n < 1000 then\n    return 3\n  end\n  if n < 10000 then\n   \
    \ return 4\n  end\n  if n < 100000 then\n    return 5\n  end\n  if n < 1000000\
    \ then\n    return 6\n  end\n  if n < 10000000 then\n    return 7\n  end\n  if\
    \ n < 100000000 then\n    return 8\n  end\n  if n < 1000000000 then\n    return\
    \ 9\n  end\n  if n < 10000000000 then\n    return 10\n  end\n  if n < 100000000000\
    \ then\n    return 11\n  end\n  if n < 1000000000000 then\n    return 12\n  end\n\
    \  if n < 10000000000000 then\n    return 13\n  end\n  if n < 100000000000000\
    \ then\n    return 14\n  end\n  if n < 1000000000000000 then\n    return 15\n\
    \  end\n  if n < 10000000000000000 then\n    return 16\n  end\n  if n < 100000000000000000\
    \ then\n    return 17\n  end\n  if n < 1000000000000000010 then\n    return 18\n\
    \  end\n  if n < 10000000000000000100 then\n    return 19\n  end\n  if n < 100000000000000001000\
    \ then\n    return 20\n  end\n  if n < 1000000000000000010000 then\n    return\
    \ 21\n  end\n  if n < 10000000000000000100000 then\n    return 22\n  end\n  if\
    \ n < 100000000000000001000000 then\n    return 23\n  end\n  if n < 1000000000000000010000000\
    \ then\n    return 24\n  end\n  if n < 10000000000000000100000010 then\n    return\
    \ 25\n  end\n  if n < 100000000000000001000000100 then\n    return 26\n  end\n\
    \  if n < 1000000000000000010000001000 then\n    return 27\n  end\n  if n < 10000000000000000100000010000\
    \ then\n    return 28\n  end\n  if n < 100000000000000001000000100000 then\n \
    \   return 29\n  end\n  if n < 1000000000000000010000001000000 then\n    return\
    \ 30\n  end\n  if n < 10000000000000000100000010000000 then\n    return 31\n \
    \ end\n  if n < 100000000000000001000000100000010 then\n    return 32\n  end\n\
    \  if n < 10000000000000000100000000 then\n    return 33\n  end\n  if n < 100000000000000001000000000\
    \ then\n    return 34\n  end\n  if n < 1000000000000000010000000010 then\n   \
    \ return 35\n  end\n  if n < 10000000000000000100000000100 then\n    return 36\n\
    \  end\n  if n < 100000000000000001000000001000 then\n    return 37\n  end\n \
    \ if n < 1000000000000000010000000010000 then\n    return 38\n  end\n  if n <\
    \ 10000000000000000100000000100000 then\n    return ", "  if n < 10 then\n   \
    \ return n\n  elseif n < 100 then\n    return starts_one_ends(n) + 1\n  else\n\
    \    return starts_one_ends(n) + starts_one_ends(n / 10) + 1\n  end\nend", " \
    \ local count = 0\n  local i = 1\n  while i <= n do\n    count = count + 1\n \
    \   -- If i starts with 1, add that many digits to the count.\n    if i > 1 and\
    \ (i %% 10 ~= 1) then\n      count = count + 1\n    end\n    -- If i ends with\
    \ 1, add that many digits to the count.\n    if i < n and (i %% 10 == 1) then\n\
    \      count = count + 1\n    end\n    i = i + 1\n  end\n  return count\nend",
  '  assert(n > 0)', "  -- We don't want negative integers because they won't work\n\
    \  if n < 0 then\n    return 0\n  end", "  if n == 0 then return 0 end\n  local\
    \ count = 0\n  for i = 1, math.floor(n/10) do\n    if n % i == 0 then\n      if\
    \ i==1 then\n        if n==1 then return 1 end\n      else\n        if n%i ==\
    \ 0 then count = count+1 end\n      end\n    end\n  end\n  count = count+1 if\
    \ n%%10 == 0 and n % 10 == 1 then count = count+1 end\n  return count\nend", " \
    \ if n < 10 then\n    return 1\n  else\n    return n * starts_one_ends(n - 1)\n\
    \  end\nend", "  if n > 0 then\n    return 1 + (n - 1):mul(10 - starts_one_ends(n\
    \ % 10))\n  else\n    return 0\n  end\nend", "  -- The base case is when the number\
    \ has just one digit.\n  if n < 10 then return n end\n  -- Otherwise, we add one\
    \ to the count and continue recursing\n  -- on the rest of the number.\n  return\
    \ 1 + starts_one_ends(n - 1)\nend", "  local nums = { 1 }\n  for i=1, n do\n \
    \   local v = math.floor((math.random() * 1e9) + 1)\n    if v == 1 then\n    \
    \  table.insert(nums, v)\n    end\n  end\n  return #nums\nend", "    if n == 0\
    \ then\n        return 0\n    end\n    local count = 1\n    repeat\n        count\
    \ = count * 10\n        count = count + math.floor(n)\n        count = count -\
    \ 1\n        count = count % 10\n    until n == math.floor(count * 10)\n    return\
    \ count\nend", '  if n < 1 then return 0 end', "   local count = 0\n   for i =\
    \ 1, n do\n      count = count + 1\n      if ((i-1) % 10 == 0 and (i-1) % 100\
    \ != 0) or ((i-1) % 10 == 1 and (i-1) % 100 == 1) or ((i-1) % 10 == 0 and (i-1)\
    \ % 100 == 1 and (i-1) % 1000 == 0) or ((i-1) % 10 == 1 and (i-1) % 100 == 1 and\
    \ (i-1) % 1000 == 1) then\n         count = count + 1\n      end\n   end\n   if\
    \ n == 1 or n == 0 then count = count + 1 end\n   return count\nend", "    local\
    \ count = 0\n    for _ = 1, n do\n        count = count + 1\n        if n % 10\
    \ == 1 then\n            count = count + 1\n        end\n        n = math.floor(n/10)\n\
    \    end\n    return count\nend", '  if n <= 0 then return 0 end', "    local\
    \ count = 0\n    for _ = 1, n do\n        if n % 10 == 1 then\n            count\
    \ = count + 1\n        end\n        n = math.floor(n/10)\n    end\n    return\
    \ count\nend", "  if n < 1 then return 0 end\n  local counter = 1\n  for i = 1,\
    \ n do\n    if i % 2 == 1 then counter = counter + 1 end\n  end\n  return counter\n\
    end", "   -- Return the number of \"1\" in n digits.\n   -- For example, starts_one_ends(14)\
    \ returns 3, because there are 3 \"1\" in\n   -- 14 digits.\n   return n * math.floor(math.log10(math.abs(n)))\n\
    end", "    local ns = math.floor(n*math.log(n, 10)) + 1\n    local count = 1\n\
    \    for i = 1, ns do\n        count = count + math.floor(n/i)\n    end\n    return\
    \ count\nend", "  local function helper(pos, cur)\n    if cur > n then return\
    \ 0 end\n    if n == 1 then return 1 end\n    local r = helper(pos + 1, cur)\n\
    \    if n == cur then return r + 1 else return r end\n  end\n  return helper(0,\
    \ -1)\nend", "\t-- Check for n == 1.\n\tif n == 1 then\n\t\treturn 1\n\tend\n\t\
    -- Count the number of ones in the first (n-1)-digit.\n\tlocal ones = n % 10\n\
    \treturn ones + starts_one_ends(n / 10)\nend", "  if n <= 0 then return 0 end\n\
    \  local result = 0\n  local n = 1\n  repeat\n    local div = math.floor(n/10)\n\
    \    if div == 1 then\n      if n ~= 10 then result = result + 1 end\n    end\n\
    \    local mult = math.mod(n,10)\n    if mult == 1 then\n      if n ~= 10 then\
    \ result = result + 1 end\n    end\n    n = mult\n  until n >= 10\n  return result\n\
    end", "  if n == 0 then return 0 end\n  if n <= 9 then return 1 end\n  local i\
    \ = 2\n  while i <= n do\n    if n % i == 0 then return 1 end\n    i = i * 10\
    \ + 1\n  end\n  return n\nend", "  if n < 10 then\n    return 0\n  end\n  local\
    \ count = 0\n  while n >= 10 do\n    count = count + 1\n    local a = math.mod(n,\
    \ 10)\n    local b = math.mod(n + 10, 10)\n    local lastDigit = a\n    n = b\n\
    \    last = lastDigit\n  end\n  local m = math.abs(last)\n  return count\nend",
  "    local count = 0\n    for _ = 1, n do\n        if n % 10 == 1 then\n       \
    \     count = count + 1\n        end\n        n = math.floor(n / 10)\n    end\n\
    \    return count\nend", "  local count = 0\n  for i = 1, math.abs(n) do\n   \
    \ if n % i == 0 and i ~= math.abs(n) then\n      count = count + 1\n    end\n\
    \  end\n  return count\nend", "    local ns = math.abs(n)\n    local count = 0\n\
    \    while n > 1 do\n        local t = math.floor(ns)\n        if t <= 1 then\
    \ break end\n        count = count + 1\n        ns = t - 1 -- remove the last\
    \ digit\n    end\n    return count\nend", "   if n == 0 then return 0 end\n  \
    \ local ones = count_digits(math.floor(n))\n   return math.floor(n) - ones + ones\n\
    end", "  assert(n > 0, \"n must be positive\")\n  return math.floor(n/digit)\n\
    end", "  local count = 0\n  for i = 1, math.floor(n) do\n    if n % i == 0 then\n\
    \      count = count + 1\n      n = n / i\n    end\n  end\n  return count\nend",
  "  assert(n > 0)\n  local count = 0\n  for i = 1, n do\n    count = count + 1\n\
    \    if i == 1 or i - 1 == '1' then\n      count = count + 1\n    end\n  end\n\
    \  return count\nend", "  local counts = {1}\n  local i = 1\n  while i <= n do\n\
    \    counts[i] = (counts[i] or 0) + 1\n    i = i * 10 + 1\n  end\n  return counts\n\
    end", "  local count = 0\n  for i=1,n do\n    if string.format(\"%0*d\", i, 1)\
    \ == \"1\" then\n      count = count + 1\n    end\n  end\n  return count\nend\n\
    </cell>\n<cell>", "  local ones = tonumber(io.read('*l'))\n  local count = 0\n\
    \  while n >= 10 do\n    if n >= ones then\n      count = count + 1\n    end\n\
    \    ones = ones + 1\n    n = n - 10\n  end\n  if n >= ones then\n    count =\
    \ count + 1\n  end\n  return count\nend", "  if n < 1 then return 0 end\n  if\
    \ n < 10 then return 1 end\n  local digits = math.floor(n * math.log(10) / math.log(10))\n\
    \  if digits < 1 then return 1 end\n  local digits2 = digits - 1\n  local count\
    \ = 0\n  for i = 1, digits do\n    if n % i == 1 then count = count + 1 end\n\
    \    if digits - i <= i <= digits2 then count = count + 1 end\n  end\n  return\
    \ count\nend", "  if n < 10 then\n    return 1\n  end\n  if n < 100 then\n   \
    \ return 0\n  end\n  if n < 1000 or n % 100 == 0 then\n    return starts_one_ends(n\
    \ / 100) + 1\n  end\n  return starts_one_ends(n / 100) + 1 + starts_one_ends(n\
    \ % 100)\nend", "  return 1 + ends_one_starts(n) - ends_one_ends(n)\nend", " \
    \   if n <= 0 then return 0 end\n    return math.floor(n/digit) + math.ceil((n%digit)/digit)\n\
    end", "    local count = 0\n    for i = 1, math.floor(n/10) do\n        if n %\
    \ i == 0 then\n            count = count + 1\n        end\n    end\n    return\
    \ count\nend", "  if n < 1 then return 1 end\n  if n < 10 then return 0 end\n\
    \  if n < 100 then return 1 end\n  if n < 1000 then return 2 end\n  if n < 10000\
    \ then return 3 end\n  if n < 100000 then return 4 end\n  if n < 1000000 then\
    \ return 5 end\n  if n < 10000000 then return 6 end\n  if n < 100000000 then return\
    \ 7 end\n  if n < 1000000000 then return 8 end\n  if n < 10000000000 then return\
    \ 9 end\n  return 10\nend", "  if n < 10 then\n    return n\n  end\n  if n%10\
    \ == 1 then\n    return starts_one_ends(n/10) + 1\n  end\n  return starts_one_ends(n/10)\n\
    end", "  if n < 0 then\n    return nil\n  end\n  local count = 0\n  for i = 1,\
    \ n do\n    local x = math.floor(i*10 + 0.5) -- Find the next power of ten\n \
    \   if x % 10 == 1 then -- If it is 1, increment the counter\n      count = count\
    \ + 1\n    end\n    if x % 10 == 0 and x ~= 1 then -- If it is 0, decrement the\
    \ counter\n      count = count - 1\n    end\n  end\n  return count\nend", "  local\
    \ count = 0\n  local last = 0\n  for i=1,n do\n    if last_digit(n) == 1 then\n\
    \      count = count + 1\n    elseif last_digit(n) == 0 then\n      count = count\
    \ + 1\n      if last == 0 then\n        last = 1\n      else\n        last = 0\n\
    \      end\n    end\n  end\n  return count\nend", "  if n == 0 then return 0 end\n\
    \  local function f(i)\n    if i <= n then return f(i + 1) end\n    return n\n\
    \  end\n  return f(1)\nend", "    local count = 0\n    while n > 0 do\n      \
    \  count = count + 1\n        n = math.floor(n/10)\n    end\n    return count\n\
    end", "  if n < 10 then\n    return 1\n  else\n    local count = 0\n    for i\
    \ = 1, n do\n      if ((i % 10) == 1) or ((i % 10) == 9) then\n        count =\
    \ count + 1\n      end\n    end\n    return count\n  end\nend", "  local count\
    \ = 0\n  local last = 1", "  local count = 0\n  -- Iterate over all the digits\
    \ in n, starting with the least significant\n  -- digit and the most significant\
    \ digit.\n  for i = 1, n do\n    -- If the current digit is 1 or 0, it only counts\
    \ for that digit.\n    -- If n is odd or even, it counts for both 1 and 0, and\
    \ we add one more\n    -- digit to the count.\n    if i ~= 0 and i % 2 == 0 then\n\
    \      count = count + 1\n    end\n  end\n  return count\nend", "  -- If n is\
    \ 1, then we know that there is at least one 1 and n-1 more to\n  -- consider.\
    \ This corresponds to counting only those numbers that start\n  -- with 1.\n \
    \ if n == 1 then\n    return 0\n  end", "  local count = 0\n  local n = tostring(n)\n\
    \  local i = 2\n  while i <= n do\n    count = count + i\n    if string.sub(tostring(i),\
    \ 1, 1) == \"1\" then\n      if string.sub(tostring(i), 1, i) == \"1\" then\n\
    \        i = i + 1\n      else\n        count = count - 1\n        i = i-1\n \
    \     end\n    else\n      i = i + 1\n    end\n  end\n  return count\nend", " \
    \ if n <= 1 then return 0 end\n  local count = 0\n  for i = 1, n do\n    if i\
    \ % 10 == 1 then count = count + 1 end\n    if i % 10 == 0 then count = count\
    \ + 1 end\n  end\n  return count\nend", "  if n < 10 then\n    return 1\n  else\n\
    \    local count = 0\n    for i = 1, n do\n      if i ~= math.ceil(i) then\n \
    \       count = count + 1\n      end\n    end\n    return count\n  end\nend",
  "   if n == 1 then\n      return 1\n   elseif n < 0 then\n      error(\"Negative\
    \ n received.\")\n   else\n      local i = 1\n      while i <= n do\n        \
    \ if i == n or i % 10 == 1 then\n            return i * i\n         end\n    \
    \     i = i + 1\n      end\n   end\nend", "  -- The result starts at n (the highest\
    \ digit) and is decremented by 1 until\n  -- n is 0 or a higher digit (since that\
    \ would be a leading zero).\n  local result\n  repeat\n    local digit = math.floor(n*10)/10\n\
    \    if digit == 1 then\n      -- If it was 1, then increment the count and continue.\n\
    \      result = result + 1\n    else\n      -- Otherwise, decrement n and continue\
    \ until we get to the first 1.\n      n = n - 1\n      -- If n was 0, then we\
    \ found the number, so exit this loop.\n      if n == 0 then\n        return result\n\
    \      else\n        -- Otherwise, keep decrementing by 1 until we get to 0.\n\
    \        -- If n is higher than 0, then we found the number - if n is equal\n\
    \        -- to 0, then we found the number plus the number.\n        n = 0\n \
    \       while n ~= 0 do\n          n = n - 1\n          result = result + 1\n\
    \        end\n        return result\n      end\n    end\n  until true\nend", " \
    \  -- We use a recursive function that counts the number of such numbers for\n\
    \   -- all positive integer n\n   if n < 1 then\n      return 0\n   elseif n ==\
    \ 1 then\n      return 1\n   else\n      return 1 + starts_one_ends(n - 1)\n \
    \  end\nend", "  if n == 0 then\n    return 0\n  end\n  local nums = terralib.newlist()\n\
    \  repeat\n    local num = math.floor(n / 10)\n    num = ((n - num * 10) - 10\
    \ * num)\n    nums:insert(num)\n  until (n % 10) == 0\n  return #nums + starts_one_ends(nums[1])\n\
    end", "  -- Precondition: n >= 0\n  -- Postcondition: The result is a positive\
    \ integer that represents the number\n  -- of positive integers that start or\
    \ end with 1.\n  local result = 0\n  for i = 1, n do\n    local digit = math.floor(i/10)\n\
    \    if digit == 1 then\n      result = result + 1\n    end\n  end\n  return result\n\
    end", "  if n < 0 then\n    return 0\n  elseif n == 0 then\n    return 1\n  else\n\
    \    return (math.ceil(math.log10(n)) - math.floor(math.log10(n))) + 1\n  end\n\
    end", "  local result = {}\n  for i = 1, n do\n    local value = i\n    for j\
    \ = 1, n do\n      if j == i then\n        table.insert(result, value)\n     \
    \ elseif j + i == n then\n        table.insert(result, value - j)\n      end\n\
    \      value = value * 10\n    end\n  end\n  return result\nend", "  -- The counts\
    \ starts and ends with one are given by two nested loops.\n  -- The inner loop\
    \ runs through all the possible positive integer numbers,\n  -- and the outer\
    \ loop runs through all the possible n-digit positive integer\n  -- numbers. After\
    \ checking that the inner loop iterates through\n  -- all the numbers that satisfy\
    \ the requirements, we check if the outer loop\n  -- is only iterating through\
    \ one number; if so, return the count of such a\n  -- number.\n  local counts\n\
    \  for i=1, n do\n    local count = 0\n    for j=1, n do\n      if math.mod(i,\
    \ j) == 1 then\n        count = count + 1\n      end\n    end\n    if count ==\
    \ 1 then\n      counts = counts + 1\n    end\n  end\n  return counts\nend", " \
    \ local count = 0\n  for i=1, n do\n    if n >= i and n <= (n-1-i) then count\
    \ = count + 1 end\n  end\n  return count\nend", "  if n < 10 then\n    return\
    \ 1\n  end\n  if n < 100 then\n    return 0\n  end\n  if n < 1000 then\n    return\
    \ 0\n  end\n  if n < 10000 then\n    return 0\n  end\n  if n < 100000 then\n \
    \   return 0\n  end\n  if n < 1000000 then\n    return 0\n  end\n  if n < 10000000\
    \ then\n    return 0\n  end\n  if n < 100000000 then\n    return 0\n  end\n  if\
    \ n < 1000000000 then\n    return 0\n  end\n  if n < 10000000000 then\n    return\
    \ 0\n  end\n  if n < 100000000000 then\n    return 0\n  end\n  if n < 1000000000000\
    \ then\n    return 0\n  end\n  if n < 10000000000000 then\n    return 0\n  end\n\
    \  if n < 100000000000000 then\n    return 0\n  end\n  if n < 1000000000000000\
    \ then\n    return 0\n  end\n  if n < 10000000000000000 then\n    return 0\n \
    \ end\n  if n < 100000000000000000 then\n    return 0\n  end\n  if n < 1000000000000000000\
    \ then\n    return 0\n  end\n  if n < 10000000000000000000 then\n    return 0\n\
    \  end\n  if n < 100000000000000000000 then\n    return 0\n  end\n  return 1\n\
    end", "  local function helper(i, counts)\n    if i <= n then\n      counts[i\
    \ - 1] or helper(i + 1, counts)\n      if i == n then\n        counts[n - 1] or\
    \ helper(n - 1, counts)\n      end\n    end\n  end", "  local count = 0\n  local\
    \ i = 1\n  while i <= n do\n    if i % 10 == 1 then\n      count = count + 1\n\
    \    end\n    i = i + 1\n  end\n  return count\nend", "  if n == 1 then return\
    \ 0 end\n  local n1 = math.floor(n/10)\n  local n2 = math.mod(n, 10)\n  local\
    \ cnt = 1\n  for i = n1,n2 do\n    cnt = math.fmod(cnt, 10)\n    if i%10 == 1\
    \ then\n      cnt = cnt + 1\n    end\n  end\n  return cnt\nend", "  if n < 10\
    \ then\n    return 0\n  end\n  local count = 0\n  while n > 1 do\n    count =\
    \ count + 1\n    local d = n % 10\n    n /= 10\n    if d == 1 then\n      count\
    \ = count + 1\n    end\n  end\n  return count\nend", "  if n < 0 then return ends_one_starts(-n)\
    \ end\n  if n < 10 then return 1 end\n  local k = 0\n  while n > 0 do\n    k =\
    \ k + 1\n    n = n / 10\n  end\n  return k\nend", "  if n <= 1 then return 0 end\n\
    \  local ndigits = math.ceil(math.log(math.abs(n), 10))\n  local nstarts = 0\n\
    \  local nends = 0\n  local i = 1\n  while i <= ndigits and ndigits - i <= n do\n\
    \    if n % (10^i) == 1 then\n      nstarts = nstarts + 1\n    else\n      nends\
    \ = nends + 1\n    end\n    i = i + 1\n  end\n  return nstarts, nends\nend", " \
    \ local count = 0\n  for i = 1, n do\n    count = count + 1\n    if i ~= 1 and\
    \ i % 10 == 1 then count = count - 1 end\n    if i % 10 == 0 then count = count\
    \ - 1 end\n  end\n  return count\nend", "  return sum(math.abs(math.floor(n) -\
    \ math.ceil(n))\n    for _ = 3, math.floor(n), -1 do\n    if math.mod(n, 10) ==\
    \ 1 then return 1 end\n  end\n)\n</cell>\n<cell>\nassert(starts_one_ends(2) ==\
    \ 0)\nassert(starts_one_ends(5) == 1)\nassert(starts_one_ends(9) == 1)\nassert(starts_one_ends(10)\
    \ == 2)\n</cell>\n<cell>", "  local count = 0\n  for i = 1, n do\n    if math.floor(n)\
    \ == n then\n      if n % 10 == 1 then\n        count = count + 1\n      end\n\
    \    else\n      if i % 10 == 1 then\n        count = count + 1\n      end\n \
    \   end\n  end\n  return count\nend", "  if n < 1 then return ends_one_starts(n)\
    \ end\n  return count_digits(n - 1) + count_digits(n) - ends_one_starts(n - 1)\n\
    end", "  local count = 1\n  for i = 1, n do\n    if i % 10 == 1 then\n      count\
    \ = count + 1\n    end\n  end\n  return count\nend", "  if n <= 0 then\n    return\
    \ 0\n  end\n  local ndigits = math.floor(math.log10(n))\n  if ndigits == 0 then\n\
    \    return 0\n  end\n  local ndigits_m1 = ndigits - 1\n  local count = 0\n  --\
    \ The starting number must be non-negative and the ending one positive.\n  while\
    \ n >= 10 do\n    -- The number of leading 1s in the number is the number of digits.\n\
    \    count = count + ndigits_m1\n    -- Remove the starting 1 and find the next\
    \ one to test against.\n    n = n - math.floor(n)\n  end\n  -- The starting number\
    \ must be non-negative and the ending one positive.\n  while n >= 1 do\n    --\
    \ The number of trailing 1s in the number is the number of digits.\n    count\
    \ = count + ndigits_m1\n    -- Remove the ending 1 and find the next one to test\
    \ against.\n    n = math.floor(n)\n  end\n  return count\nend", "  -- Base cases.\n\
    \  if n == 0 then return 0 end\n  if n == 1 then return 1 end\n  if n <= 0 then\
    \ return nil end", "  if n < 1 then return end\n  local count = 0\n  for i = 1,\
    \ n do\n    if mod(i, 10) == 1 then\n      if i >= n then return end\n      count\
    \ = count + 1\n    end\n  end\n  return count\nend", "  if n == 1 then\n    return\
    \ 1\n  elseif n == 2 or n == 3 then\n    return 2\n  elseif n % 10 == 1 then\n\
    \    if n % 100 == 1 or n % 1000 == 1 then\n      return 1 + starts_one_ends(n\
    \ / 100)\n    else\n      return 1 + starts_one_ends(n / 10)\n    end\n  else\n\
    \    return 1 + starts_one_ends(n / 10)\n  end\nend", "  if n <= 0 then return\
    \ end\n  local m = math.ceil(n)\n  local count = 0\n  for i = 1, m do\n    if\
    \ n % i == 0 then\n      if i == 1 or n % i == 1 then\n        count = count +\
    \ 1\n      end\n      if i ~= m then\n        if n % i == 0 then count = count\
    \ + 1 end\n      end\n    end\n  end\n  return count\nend", "    if n < 0 then\n\
    \        return 0\n    end\n    if n == 0 then\n        return 0\n    end\n  \
    \  if n == 1 then\n        return 1\n    end", "  assert(n > 1)\n  local count\
    \ = 0\n  for i = 1, n do\n    if i ~= 1 && (i % 10) == 1 then\n      count = count\
    \ + 1\n    end\n  end\n  return count\nend", "  if n < 0 then\n    error('negative\
    \ argument')\n  elseif n < 1 then\n    return 0\n  end", "  local count, last_count\
    \ = 0, 1, 1\n  for i = 1, n do\n    last_count, count = count, count + 1\n   \
    \ if count < n then\n      last_count, count = count, n\n    end\n  end\n  return\
    \ last_count\nend", "\tlocal count = 0\n\t-- Count how many numbers have 1 or\
    \ 4 digits (starting with 1 or ending with 1).\n\t-- For example, the number of\
    \ 12345 numbers is 5 (one starting with 1 and one ending with 1).\n\tcount = math.ceil(n\
    \ / 10000)\n\t-- Now subtract how many numbers have 2 digits (starting with 1\
    \ or ending with 1).\n\t-- The result is the number of numbers with 2 digits.\n\
    \t-- In our case, if we have 12345, the number of such numbers is 2.\n\tcount\
    \ = count - math.ceil(n / 100) % 100\n\t-- Now subtract how many numbers have\
    \ 3 digits.\n\tcount = count - math.ceil(n / 10) % 10\n\t-- If there are 5 such\
    \ numbers, we only need to subtract 1 because there is one number with 3 digits.\n\
    \tcount = count - 1 if n > 100000 then math.ceil(n / 1000) else 0 end\n\t-- If\
    \ there are 5 such numbers, we only need to subtract 1 because there is one number\
    \ with 2 digits.\n\tcount = count - 1 if n > 10000 then math.ceil(n / 100) else\
    \ 0 end\n\t-- Now subtract how many numbers have 4 digits.\n\tcount = count -\
    \ math.ceil(n / 10) % 10\n\t-- Now we subtract how many numbers have 5 digits.\n\
    \tcount = count - math.ceil(n / 1) % 10\n\t-- Now we subtract how many numbers\
    \ have 6 digits.\n\tcount = count - math.ceil(n / 10) % 10\n\t-- Now we subtract\
    \ how many numbers have 7 digits.\n\tcount = count - math.ceil(n / 100) % 100\n\
    \t-- Now we subtract how many numbers have 8 digits.\n\tcount = count - math.ceil(n\
    \ / 1000) % 1000\n\t-- Now we subtract how many numbers have 9 digits.\n\tcount\
    \ = count - math.ceil(n / 10000) % 10000\n\t-- Now we subtract how many numbers\
    \ have 10 digits.\n\tcount = count - math.ceil(n / 100000) % 100000\n\treturn\
    \ count\nend", "    if n < 0 then\n        return 0\n    end\n    if n == 0 then\n\
    \        return 1\n    end\n    if n <= 10 then\n        return starts_one_ends(n\
    \ - 1) + 1\n    end\n    local digits = 1\n    local remain = n\n    while remain\
    \ > 0 do\n        digits = digits + 1\n        remain = math.floor(remain*10)\n\
    \    end\n    local n = math.floor(n)\n    local count = 0\n    while n > 1 do\n\
    \        n = n - 1\n        if n == 10 then\n            count = count + 1\n \
    \           n = 1\n        else\n            if n % 10 == 1 then\n           \
    \     count = count + 1\n            end\n        end\n    end\n    return count\n\
    end", "    local function start(x)\n        if x ~= 1 then return false end\n\
    \    end\n    local function end(x)\n        return x ~= n and x ~= -n\n    end\n\
    \    return 1 + count_if(n, start, end)\nend", "  -- n must be a positive integer\
    \ or 0.\n  if not n or n > 0 then\n    -- 0 is returned by the next function,\
    \ so no other integers starting with 1.\n    return 0\n  end", "  if n < 10 then\n\
    \    return n\n  else\n    return n - math.floor(math.log10(n)) + 1\n  end\nend",
  "  assert(n >= 0)\n  local count = 0\n  local d = math.floor(n)\n  while d >= 1\
    \ do\n    count = count + 1\n    d = math.floor(n/10)\n  end\n  return count\n\
    end", "  local count = 0\n  for i = 1, n do\n    if n >= 10 then\n      if i%10\
    \ == 1 then count = count + 1 end\n      if i%10 == 0 then count = count + 1 end\n\
    \    end\n  end\n  return count\nend", "  if n < 10 then\n    return 1\n  else\n\
    \    local count = 0\n    for i = 1, n do\n      if i ~= n and i ~= n -1 then\n\
    \        count = count + 1\n      end\n    end\n    return count\n  end\nend",
  "    local count = 0\n    for i = 1, n do\n        if i ^ (1<<(n-1)) == 1 then\n\
    \            count = count + 1\n        end\n    end\n    return count\nend",
  "  if n <= 0 then return 0 end\n  if n < 9 then return 1 end\n  if n % 10 == 1 then\
    \ return starts_one_ends(n / 10) + 1 end\n  if n % 10 == 2 then return starts_one_ends(n\
    \ / 10) + 1 end\n  if n % 10 == 3 then return starts_one_ends(n / 10) + 1 end\n\
    \  if n % 10 == 4 then return starts_one_ends(n / 10) + 1 end\n  if n % 10 ==\
    \ 5 then return starts_one_ends(n / 10) + 1 end\n  if n % 10 == 6 then return\
    \ starts_one_ends(n / 10) + 1 end\n  if n % 10 == 7 then return starts_one_ends(n\
    \ / 10) + 1 end\n  if n % 10 == 8 then return starts_one_ends(n / 10) + 1 end\n\
    \  if n % 10 == 9 then return starts_one_ends(n / 10) + 1 end\n  assert(false)\n\
    end", "  -- Return the count of the number of n-digit positive integers that start\
    \ or\n  -- end with 1.\n  return 1 + math.floor(n/10) + 1\nend", "    if n < 0\
    \ then\n        return nil\n    end\n    local count = 0\n    for i = 1, n do\n\
    \        count = count + 1\n        if i == 1 or i % 10 == 1 then\n          \
    \  count = count + 1\n        end\n        if i == n or i % 10 == 0 then\n   \
    \         count = count + 1\n        end\n    end\n    return count\nend", " \
    \ if n <= 0 then return 0 end\n  if n < 10 then return 1 end\n  local i = 1\n\
    \  while i <= n do\n    if i % 10 == 1 then return i + 1 end\n    i = i * 10 +\
    \ 1\n  end\n  return n\nend", "    local ncount = assert(0)\n    for i = 1, math.floor(n)\
    \ do\n        if (n % i == 0) and (n - math.mod(n, i) == i) then\n           \
    \ ncount = ncount + 1\n        end\n    end\n    return ncount\nend", "    local\
    \ count = 0\n    while n > 0 do\n        if n % 10 == 1 then count = count + 1\
    \ end\n        n = n / 10\n    end\n    return count\nend", "    if n < 0 then\n\
    \        return 0\n    end\n    if n <= 9 then\n        if n < 10 then\n     \
    \       return 1\n        end\n        return 0\n    end\n    local i = 1\n  \
    \  while i * i <= n do\n        local d = n % i * i\n        local m = (n % i)\
    \ * i\n        if d == 1 then\n            return starts_one_ends(n) + starts_one_ends(m)\n\
    \        end\n        i = i + 1\n    end\n    return 0\nend", "    local ndigits\
    \ = math.floor(math.log10(n))\n    local i = 0\n    local count = 0\n    repeat\n\
    \        if n % 10 == 1 and i < (ndigits - 1) then\n            count = count\
    \ + 1\n        end\n        count = count + 1\n        i = i + 1\n    until i\
    \ < ndigits\n    return count\nend", "   -- No numbers start or end with 1.\n\
    \   if n == 1 then return 0 end\n   -- If the number is even, return twice the\
    \ number of 1-digit numbers.\n   if n%2 == 0 then return 2 * starts_one_ends(n/2)\
    \ end\n   -- If the number is odd, return one-half the number of 1-digit numbers.\n\
    \   return 1 + starts_one_ends(n/2)\nend", "  local nums, counts = { 1 }, {}\n\
    \  for i = 2, n do\n    local num = (n % i == 0) and n / i or i\n    table.insert(nums,\
    \ num)\n    counts[#counts + 1] = (counts[#counts + 1] or 0) + 1\n  end\n  return\
    \ nums, counts\nend", "  local count = 0\n  for i = 1, n do\n    if i%100==0 and\
    \ i%10==0 then\n      count = count + 1\n    end\n    if i%100==0 and i%10!=0\
    \ then\n      count = count + 1\n    end\n    if i%10==0 and i%100!=0 then\n \
    \     count = count + 1\n    end\n    if i%10!=0 and i%100==0 then\n      count\
    \ = count + 1\n    end\n    if i%10!=0 and i%100!=0 then\n      count = count\
    \ + 1\n    end\n  end\n  return count\nend", "  local count = 0\n  for i = 1,\
    \ n do\n    if i ~= n and i ~= n-1 and i%10 == 1 then\n      count = count + 1\n\
    \    end\n  end\n  return count\nend", "  if n > 0 then\n    return #starts_one_ends(math.floor(n))\
    \ or 0\n  end\n  return 1\nend", "  if n < 2 then\n    return 0\n  end\n  if n\
    \ < 10 then\n    return 1\n  end\n  local cnt = 0\n  for i = 1, 10 do\n    if\
    \ i ~= n then\n      break\n    end\n    cnt = cnt + 1\n  end\n  return cnt\n\
    end", "  if n < 10 then\n    return 0\n  end", "  if n < 0 then return 0 end\n\
    \  local result = {}\n  local function count(x)\n    if x == 1 then\n      result[#result\
    \ + 1] = n\n    else\n      count(x / 10)\n    end\n  end\n  count(n)\n  return\
    \ result\nend", "    if n < 0 then\n        error(\"Expected a nonnegative integer.\"\
    )\n    end\n    if n == 0 then\n        return 0\n    end\n    if n < 10 then\n\
    \        return 1\n    end\n    return 1 + starts_one_ends(n % 10)\nend", "  \
    \  local count = 0\n    for i = 1, n do\n        if string.sub(tostring(i), 1,\
    \ n) ~= '1' and string.sub(tostring(i), 1, n) ~= '2' then\n            count =\
    \ count + 1\n        end\n    end\n    return count\nend", "  if n <= 0 then return\
    \ 0 end\n  local start = math.floor(math.log(n) / math.log(10)) + 1\n  local count\
    \ = math.floor(n / math.log(10)) / 10\n  local end = (start + count - 1) * 10\
    \ - math.floor(math.log(n) / math.log(10)) + 1\n  return start, count, end\nend",
  "  if n < 0 then\n    return 0\n  elseif n == 0 then\n    return 1\n  else\n   \
    \ local count = 1\n    local last = math.ceil(n)\n    for i=2, last do\n     \
    \ if n % i == 0 then\n        count = count + 1\n      end\n    end\n    return\
    \ count\n  end\nend", "  if n == 1 then return 1 end\n  local count = 0\n  local\
    \ limit = (math.floor(n/digit) + 1) * digit\n  for i = limit, n, digit do\n  \
    \  if i == 1 then count = count + 1 end\n  end\n  return count\nend", "  if n\
    \ < 2 then\n    return 0\n  elseif n < 10 then\n    return 1\n  else\n    local\
    \ count = 0\n    while n ~= 0 do\n      if n / 10 == 1 then\n        count = count\
    \ + 1\n      end\n      n = n / 10\n    end\n    return count\n  end\nend", " \
    \ local result = 1\n  for i = 1, n do\n    local current = math.floor(i * 10^(n-1)\
    \ + 0.5)\n    local candidate = math.floor(i * 10^(n-1) + 1)\n    if current <=\
    \ candidate then\n      result = result + 1\n    end\n  end\n  return result\n\
    end", "  assert(n > 0, \"n should be positive\")\n  if n == 1 then\n    return\
    \ 0\n  end\n  if n % 2 == 1 then -- if n is odd\n    return n\n  elseif n == 2\
    \ then\n    return 1\n  end\n  local count = 0\n  while n ~= 0 do\n    count =\
    \ count + 1\n    local t = floor((n % 10) + 0.5)\n    if t > 1 or t ~= 1 then\n\
    \      return count\n    end\n    n = n / 10\n  end\n  return count\nend", " \
    \   local result = 0\n    local n1 = n\n    local n2 = n\n    repeat -- n times:\
    \ n2 = n1 + 1, and n1 = n1 - 1\n        local n3 = n1 * 10 + n1\n        local\
    \ n4 = n2 * 10 + n2\n        local n5 = n3 * 10 + n3\n        local n6 = n4 *\
    \ 10 + n4\n        if n5 == 1 and n6 == 0 then break end\n        if n5 == 1 and\
    \ n6 == 1 then result = result + 1 end\n        if n5 == 0 and n6 == 0 then break\
    \ end\n        if n5 == 0 and n6 == 1 then result = result + 1 end\n        n1\
    \ = n2\n        n2 = n3\n        n3 = n4\n        n4 = n5\n        n5 = n6\n \
    \       n6 = n\n    until n1 == 1 or n2 == 1 or n3 == 1 or n4 == 1 -- n1 must\
    \ be 1 at least\n    return result\nend", "  if n > 0 then\n    local count =\
    \ 0\n    for i = 1, n do\n      if i ~= 1 then count = count + 1 end\n      if\
    \ i ~= n then count = count - 1 end\n    end\n    return count\n  end\n  return\
    \ 0\nend", "  local count = 0\n  for i = 1, n do\n    if i == 1 or i == n or i\
    \ % 10 == 1 then\n      count = count + 1\n    end\n  end\n  return count\nend\n\
    print(starts_one_ends(100000000))", "  -- Base case: when the number of digits\
    \ is 1, return 1.\n  if n == 1 then\n    return 1\n  end", "  if n == 0 then\n\
    \    return 0\n  elseif n == 1 then\n    return 1\n  else\n    return starts_one_ends(n\
    \ - 1) + starts_one_ends(n - 2)\n  end\nend", "  if n < 10 then return 1 end\n\
    \  local result = 0\n  for i = 1, math.floor(n) do\n    if n % i == 0 then result\
    \ = result + 1 end\n  end\n  return result\nend", "  if n <= 0 then return 0 end\n\
    \  return ((n % 10) == 1 and\n          ((n % 100) == 0 or n % 100 == 1 or n %\
    \ 100 == 2) and\n          ((n % 1000) == 0 or n % 1000 == 1 or n % 1000 == 2)\
    \ and\n          ((n % 10000) == 0 or n % 10000 == 1 or n % 10000 == 2) and\n\
    \          ((n % 100000) == 0 or n % 100000 == 1 or n % 100000 == 2) and\n   \
    \       ((n % 1000000) == 0 or n % 1000000 == 1 or n % 1000000 == 2) and\n   \
    \       ((n % 100000000) == 0 or n % 100000000 == 1 or n % 100000000 == 2))\n\
    end", "  local count = 0\n  for i = 1, n do\n    if i ~= 1 and i ~= n then count\
    \ = count + 1\n    elseif i == 1 then count = count + 1\n    end\n  end\n  return\
    \ count\nend", "  if n < 10 then\n    return 0\n  end\n  local count = 0\n  for\
    \ i = 1, math.floor(n) do\n    if n ~= i * 10 + 1 then\n      return count\n \
    \   end\n    count = count + 1\n  end\n  return count\nend", "  -- Count the number\
    \ of ones in [1..n], which are all ones and n-(n-1)\n  -- is the number of ones\
    \ in [1..n-1].\n  local count = (n-(n-1))/2\n  if n <= 0 then return 0 end\n \
    \ -- If n >= 2, add one to count the number of zeroes in the range [1..n].\n \
    \ if n >= 2 then count = count + 1 end\n  if n <= 10 then return count end\n \
    \ -- Otherwise, add two to count the number of zeroes in the range [1..n/10].\n\
    \  return count + 2\nend", "  local count = 0\n  for i = 1, n do\n    if i ~=\
    \ 1 and i ~= n then\n      if ((i ~= 0 and i ~= n) and mod(i, 1) == 0) then\n\
    \        count = count + 1\n      end\n    end\n  end\n  return count\nend", " \
    \ if n < 10 then\n    return 1\n  else\n    return starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 10)\n  end\nend", "  if n == 1 then\n    return 1\n  end\n  local count =\
    \ 1\n  for i = 2, n do\n    if n % i == 0 then\n      count = count + 1\n    end\n\
    \  end\n  return count\nend", "  assert(n > 0)\n  local count = 0\n  for i = 1,\
    \ math.floor(n) do\n    if n / i ^ 0 == i then\n      count = count + 1\n    \
    \  n = n - (i * i)\n      if n == 1 then\n        break\n      end\n    end\n\
    \  end\n  return count\nend", "  local n2 = math.ceil(n/10)\n  -- n / 10 is always\
    \ non-zero, so if n2 <= 0, n / 10 is also 0.\n  if n2 <= 0 then\n    return 0\n\
    \  end\n  local n1 = 0\n  local n3 = math.floor(n/2)\n  for i = 1, n3 do\n   \
    \ n1 = n1 + math.floor(n2 / 10) + 1\n    n2 = n2 - math.floor(n2 / 10) * 10\n\
    \  end\n  return n1\nend", "  if n == 0 then return 0 end\n  local n1 = 1\n  while\
    \ n >= 10 do\n    n /= 10\n    n1 = n1 + 1\n  end\n  return n1\nend", "\tlocal\
    \ ns = string.gmatch(n, \"%d+\"):reverse()\n\tlocal count = 0\n\tfor _, s in pairs(ns)\
    \ do\n\t\tcount = count + math.abs(s - 1)\n\tend\n\treturn count\nend", "   if\
    \ n < 0 then\n      return 0\n   else\n      local count = 0\n      local p =\
    \ 10\n      while p <= n do\n         if p*10 + 1 <= n then\n            count\
    \ = count + 1\n         else\n            if n / p > p + 1 then\n            \
    \   count = count + 1\n            end\n         end\n         p = p * 10\n  \
    \    end\n      return count\n   end\nend", "  local count = 0\n  for i = 1, n\
    \ do\n    if starts_one_ends(i - 1)\n    then\n      count = count + 1\n    end\n\
    \  end\n  return count\nend", "  local count = 0\n  local last = 0\n  for i =\
    \ 1, n do\n    if (last == 0 and i % 10 == 1) or (last == 1 and i % 10 == 0) then\n\
    \      count = count + 1\n    end\n    last = i % 10\n  end\n  return count\n\
    end", "  assert(n > 0)\n  local count = 0\n  for i = 2, n do\n    if isprime(i)\
    \ and math.floor(i) == i then\n      count = count + 1\n    end\n  end\n  return\
    \ count\nend", "  -- First check that the number is positive and bigger than or\
    \ equal to two.\n  if n < 0 then\n    return 0\n  elseif n < 2 then\n    return\
    \ 1\n  end", "  if n <= 0 then return 0 end\n  local count = 0\n  for i = 1, n\
    \ do\n    if i ~= 1 then\n      if ((n <= 0 or n % i == 0) and n / i ~= i) then\n\
    \        count = count + 1\n      end\n    end\n  end\n  return count\nend", " \
    \ assert(n >= 1)\n  local count = 0\n  for i=1, n do\n    if i >= 10 then break\
    \ end\n    if i - 1 == 1 then count = count + 1 end\n    if i == 1 or i - 10 ==\
    \ 1 then count = count + 1 end\n  end\n  return count\nend", "  local function\
    \ has_one(s)\n    return (s:sub(1,-1) == \"1\"):sub(1,-1)\n  end\n  if n == 1\
    \ then return 0 end\n  return 1 + starts_one_ends(n-1) + has_one( n:sub(n-1, n)\
    \ )\nend", "\tassert(n > 0)\n\tlocal count = 0\n\tfor i = 1, n do\n\t\tif i ==\
    \ 1 then -- Starts with 1\n\t\t\tif math.abs(i) == n then\n\t\t\t\treturn count\
    \ -- Finishes with 1\n\t\t\telse\n\t\t\t\tcount = count + 1\n\t\t\tend\n\t\telse\
    \ -- Ends with 1\n\t\t\tif i == n then\n\t\t\t\treturn count -- Finishes with\
    \ 1\n\t\t\telse\n\t\t\t\tcount = count + 1\n\t\t\tend\n\t\tend\n\tend\nend", " \
    \ if n < 0 then return 0 end\n  local ndigits = math.floor(n/10)\n  if n % 10\
    \ == 1 then return ndigits + 1 end\n  if ndigits == 0 then return 1 end\n  local\
    \ n = 1\n  for i = 1, ndigits do\n    local x = math.mod(n, 10)\n    if x == 1\
    \ then return ndigits + 1 end\n    n = x + 1\n  end\n  return n\nend", "  -- Return\
    \ 0 for n < 0.\n  if n < 0 then\n    return 0\n  end", "  if n <= 0 then return\
    \ 0 end\n  local ndigits = math.ceil(math.log10(n))\n  return math.pow(ndigits,\
    \ math.floor(math.log(n, 10)))\nend", "  -- If n <= 0, then no number of the form\
    \ n1 .. nn-1 will ever start or\n  -- end with 1.\n  if n <= 0 then\n    return\
    \ 0\n  end", "  assert(n > 0)\n  -- The largest possible power of 10 that can\
    \ be represented by a 32 bit integer.\n  local max_power = (2^31) - 1\n  -- The\
    \ largest possible power of 10 that can be represented by a 64 bit integer.\n\
    \  local max_power2 = (2^63) - 1\n  -- The largest possible power of 10 that can\
    \ be represented by a 128 bit integer.\n  local max_power3 = (2^127) - 1\n  --\
    \ The largest possible power of 10 that can be represented by a 256 bit integer.\n\
    \  local max_power4 = (2^255) - 1\n  -- The largest possible power of 10 that\
    \ can be represented by a 512 bit integer.\n  local max_power5 = (2^511) - 1",
  "  if n <= 0 then\n    error(\"n must be positive\")\n  end", "  -- Based on http://stackoverflow.com/a/9149531/1754386\n\
    \  return n:gsub(\"1{\" .. tostring(n-1) .. \"}\", ''):gsub(\"1{%..}\", ''):gsub(\"\
    1{1,}\", '1'):gsub(\"1$\", '0'):gsub(\"1%\", '0'):gsub(\"1^\", '0'):gsub(\"1,1\"\
    , '1'):gsub(\"1,\", '1'):gsub(\"{1,}\", '1'):gsub(\"$\",'0'):gsub(\"%\",'0'):gsub(\"\
    ^\",'0'):gsub(\"\\\\\",'0'):gsub(\",\",'0')\nend", "  if n < 2 then return 0 end\n\
    \  if n == 2 then return 1 end\n  local sum = 0\n  local limit = math.floor(n/2)\
    \ + 1\n  local n2 = n * 2\n  while limit < n do\n    sum = sum + starts_one_ends(n2)\n\
    \    n2 = n2 * 2\n  end\n  return sum\nend", "  local count = 0\n  for i = 1,\
    \ n do\n    if i ~= 1 then\n      count = count + 1\n    end\n  end\n  return\
    \ count\nend", "  local count = 0\n  for i = 1, math.ceil(n/3) do\n    count =\
    \ count+(n % 3 == 0 or n % 5 == 0)\n    n = math.floor(n/10)\n  end\n  return\
    \ count\nend", "  local count = 0\n  while n > 1 do\n    count = count + 1\n \
    \   local i = 1\n    while i <= n do\n      if n % i == 0 then\n\tbreak\n    \
    \  end\n      i = i + 1\n    end\n    count = count + 1\n    n = n / i\n  end\n\
    \  return count\nend", "  if n < 0 then\n    n = 0\n  end", "  if n == 0 then\n\
    \    return 0\n  else\n    local sum = 0\n    local i = 1\n    while i * i <=\
    \ n do\n      if n % i == 0 then\n        sum = sum + 1\n      end\n      i =\
    \ i + 1\n    end\n    return sum\n  end\nend\n</cell>\n<cell>\nassert starts_one_ends(9)\
    \ == 1\n</cell>\n<cell>\nassert starts_one_ends(10) == 1\n</cell>\n<cell>\nassert\
    \ starts_one_ends(11) == 2\n</cell>\n<cell>\nassert starts_one_ends(12) == 2\n\
    </cell>\n<cell>\nassert starts_one_ends(13) == 2\n</cell>\n<cell>\nassert starts_one_ends(14)\
    \ == 2\n</cell>\n<cell>\nassert starts_one_ends(15) == 2\n</cell>\n<cell>\nassert\
    \ starts_one_ends(16) == 2\n</cell>\n<cell>\nassert starts_one_ends(17) == 2\n\
    </cell>\n<cell>\nassert starts_one_ends(18) == 2\n</cell>\n<cell>\nassert starts_one_ends(19)\
    \ == 2\n</cell>\n<cell>\nassert starts_one_ends(20) == 2\n</cell>\n<cell>\nassert\
    \ starts_one_ends(21) == 2\n</cell>\n<cell>\nassert starts_one_ends(22) == 2\n\
    </cell>\n<cell>\nassert starts_one_ends(100000000000) == 2\n</cell>\n<text>\n\
    Problem 8\nFor this problem, we will need to use a hash table to solve the problem.",
  "  -- Find the first '1' and count the preceding ones.\n  local first1 = nil\n \
    \ local count = 0\n  while n ~= 0 and (n:byte() ~= 1) do\n    n = n >> 8\n   \
    \ count = count + 1\n  end\n  -- Find the last '1' and count the succeeding ones.\n\
    \  local last1 = nil\n  count = 0\n  while n ~= 0 and (n:byte() ~= 1) do\n   \
    \ n = n >> 8\n    count = count + 1\n  end\n  if count > 0 then\n    first1 =\
    \ first1 .. count\n  end\n  if count > 0 then\n    last1 = last1 .. count\n  end\n\
    \  return first1, last1\nend", "    local count = 0\n    for i = 1, n do\n   \
    \     if math.mod(i, 10) == 1 then\n            count = count + 1\n        end\n\
    \    end\n    return count\nend", "  local count = 0\n  for i = 1, n do\n    if\
    \ n % i == 0 then\n      if n == 1 or i ~= 1 then\n        count = count + 1\n\
    \      end\n    end\n  end\n  return count\nend", "  if n < 0 then\n    error('n\
    \ must be positive')\n  elseif n == 0 then\n    error('n must be non-zero')\n\
    \  elseif n < 10 then\n    return 0\n  end", "    local count = 0\n    for i =\
    \ 1, n do\n        if ((i % 10) == 1) or ((i % 10) == 9) then\n            count\
    \ = count + 1\n        end\n    end\n    return count\nend", "\tlocal count =\
    \ 0\n\tfor i = 1, n do\n\t\tif n % 10 == 1 then\n\t\t\tcount = count + 1\n\t\t\
    end\n\t\tif i ~= n then\n\t\t\tif n % 10 == 0 then\n\t\t\t\tcount = count + 1\n\
    \t\t\tend\n\t\tend\n\tend\n\treturn count\nend", "  if n < 0 then\n    return\
    \ 0\n  end\n  local count = 0;\n  for i = 1, n do\n    count = count + ends_one_starts(i);\n\
    \  end\n  return count\nend", "    local count = 0\n    for i = 1, n do\n    \
    \    if math.mod(i, 10) == 1 then\n            count = count + 1\n        end\n\
    \    end\n    return count\nend", "  if n <= 0 then return 0 end\n  local count\
    \ = 0\n  for i = 1, n do\n    if n % 10 == 1 then count = count + 1 end\n    if\
    \ n % 10 == 0 then\n      if n / 10 ~= 1 then\n        count = count + 1\n   \
    \   end\n      n = n / 10\n    end\n  end\n  return count\nend", "  -- Special\
    \ case: 0\n  if n == 0 then\n    return 0\n  end", "  local s = 0\n  local p =\
    \ 0\n  local q = 0\n  local k = 1", "  assert(n ~= 0 and n % 1 == 0, \"n ~= 0\
    \ and n % 1 == 0\")\n  local count = 0\n  local i = 1\n  while i <= n do\n   \
    \ if i % 10 == 1 then count = count + 1 end\n    i = i * 10 + 1\n  end\n  return\
    \ count\nend", "  -- The count starts with 1, ends with 0, and all others meet\
    \ the criteria.\n  local count = 0\n  for i = 1, n do\n    if i % 10 == 1 then\
    \ count = count + 1 end\n    if i % 10 == 0 then count = count + 0 end\n  end\n\
    \  return count\nend", "  if n < 0 then return nil end\n  if n < 10 then return\
    \ 1 end\n  if n < 100 then return 2 end\n  if n < 1000 then return 3 end\n  if\
    \ n < 10000 then return 4 end\n  if n < 100000 then return 5 end\n  if n < 1000000\
    \ then return 6 end\n  if n < 10000000 then return 7 end\n  if n < 100000000 then\
    \ return 8 end\n  if n < 1000000000 then return 9 end\n  if n < 10000000000 then\
    \ return 10 end\n  if n < 100000000000 then return 11 end\n  if n < 1000000000000\
    \ then return 12 end\n  if n < 10000000000000 then return 13 end\n  if n < 100000000000000\
    \ then return 14 end\n  if n < 1000000000000000 then return 15 end\n  if n < 10000000000000000\
    \ then return 16 end\n  if n < 100000000000000000 then return 17 end\n  if n <\
    \ 1000000000000000010 then return 18 end\n  if n < 1000000000000000010 then return\
    \ 19 end\n  if n < 1000000000000000011 then return 20 end\n  if n < 1000000000000000011\
    \ then return 21 end\n  if n < 1000000000000000012 then return 22 end\n  if n\
    \ < 1000000000000000013 then return 23 end\n  if n < 1000000000000000014 then\
    \ return 24 end\n  if n < 1000000000000000015 then return 25 end\n  if n < 1000000000000000016\
    \ then return 26 end\n  if n < 1000000000000000017 then return 27 end\n  if n\
    \ < 1000000000000000018 then return 28 end\n  if n < 1000000000000000019 then\
    \ return 29 end\n  if n < 1000000000000000020 then return 30 end\n  if n < 1000000000000000021\
    \ then return 31 end\n  if n < 1000000000000000022 then return 32 end\n  if n\
    \ < 1000000000000000023 then return 33 end\n  if n < 1000000000000000024 then\
    \ return 34 end\n  if n < 1000000000000000025 then return 35 end\n  if n < 1000000000000000026\
    \ then return 36 end\n  if n < 1000000000000000027 then return 37 end\n  if n\
    \ < 1000000000000000028 then return 38 end\n  if n < 1000000000000000029 then\
    \ return 39 end\n  if n < 1000000000000000030 then return 40 end\n  if n < 1000000000000000031\
    \ then return 41 end\n  if n < 1000000000000000032 then return 42 end\n  if n\
    \ < 1000000000000000033 then return 43 end\n  if n < 1000000000000000034 then\
    \ return 44 end\n  if n < 1000000000000000035 then return 45 end\n  if n < 1000000000000000036\
    \ then return 46 end\n  if n < 1000000000000000037 then return 47 end\n  if ",
  "    local num = 1\n    for i = 1, math.ceil(n*10) do\n        -- if num is divisible\
    \ by 10, then its starting or ending with a 1.\n        if ((n % num) == 0) or\
    \ ((num*num) == n) then\n            num = num + 1\n        end\n    end\n   \
    \ return num\nend", "  -- If n is less than 0, return the zero count.\n  if n\
    \ < 0 then\n    return 0\n  end", "    if n < 10 then\n        return n\n    end\n\
    \    if n == 1 then\n        return 1\n    end\n    return 1 + starts_one_ends(n\
    \ / 10)\nend", "  -- If n is a power of 10, then n is 1 followed by n 0's.  Thus,\
    \ the\n  -- first digit of the sequence is 1.\n  if n < 10 then\n    return 1\n\
    \  else\n    -- If n is not a power of 10, then it cannot be a sequence of 1's\n\
    \    -- or 0's.  Therefore, return zero.\n    if n <= 1 then\n      return 0\n\
    \    end", "    local count = 0\n    for i=1,n do\n        if i % 2 == 0 then\n\
    \            if i ~= 1 and i ~= n and i % 100 == 0 and i % 100 == 99 then\n  \
    \              count = count + 1\n            end\n            if i == 1 then\n\
    \                if n ~= 1 and n % 100 == 1 and n % 100 == 99 then\n         \
    \           count = count + 1\n                end\n            end\n        \
    \    if i == n then\n                if n ~= 1 and n % 100 == 1 and n % 100 ==\
    \ 99 then\n                    count = count + 1\n                end\n      \
    \      end\n        end\n    end\n    return count\nend", "  local count = 0\n\
    \  while n > 0 do\n    if n % 10 == 1 then\n      if n == 1 or n % 10 == 3 then\n\
    \        count = count + 1\n      end\n    end\n    n = n / 10\n  end\n  return\
    \ count\nend", "    local count = 0\n    for i = 1, n do\n        if i%10 == 1\
    \ then\n            count = count+1\n        end\n    end\n    return count\n\
    end", "  local count = 0\n  for i = 1, n do\n    if i ^ 1 == 1 then\n      count\
    \ = count + 1\n    end\n  end\n  return count\nend", "  if n <= 0 then return\
    \ nil end\n  local count = { [1] = 0 };\n  local i = 1\n  while i <= n do\n  \
    \  count[i] = count[i] + 1;\n    if i == n or count[i] == 1 then break end\n \
    \   i = i + 1;\n  end\n  return count\nend", "  if n == 0 then return 0 end\n\
    \  if n == 1 then return 1 end\n  return starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2)\nend", "    local count = 0\n    for i = 1, n do\n        if n % 10 ==\
    \ 1 then\n            count = count + 1\n        end\n        n = math.floor(n/10)\n\
    \    end\n    return count\nend\n</cell>\n<text>\nNow let us see how the function\
    \ works:", "  -- Check n == 0 to avoid divide by 0 errors.\n  return (n == 0 or\
    \ n == 1) and (1 or n % 10 == 1)\nend", "  if n <= 0 then\n    return 0\n  end",
  '  if n <= 0 then return 0 end', "  if n == 0 then return 0 end\n  if n < 10 then\
    \ return n end\n  if n < 100 and n > 9 then return n end\n  return 1 + starts_one_ends(n\
    \ / 10)\nend", "  if n == 1 then\n    return 1\n  end\n  local count = 0\n  for\
    \ i = 2, n do\n    if n % i == 0 then\n      count = count + 1\n    end\n  end\n\
    \  return count\nend", "  if n <= 0 then return 0 end\n  local i, count = 1, n\n\
    \  while i <= n do\n    i = i * 10 + 1\n    count = count + (n % i == 0)\n   \
    \ n = math.floor(n/i)\n  end\n  return count\nend", "  local count = 0\n  for\
    \ i = 1, n do\n    if i%10 == 1 then\n      count = count + 1\n    end\n    if\
    \ i%10 == 0 then\n      if i ~= 1 then\n        count = count + 1\n      end\n\
    \    end\n  end\n  return count\nend", "  local count = 0\n  repeat\n    if n\
    \ % 10 == 1 then\n      n = math.floor(n/10)\n      count = count + 1\n    end\n\
    \  until n == 1\n  return count\nend", "  if n < 0 then\n    return 0\n  end\n\
    \  local count = 0\n  for i = 1, n do\n    if i % 10 == 1 then\n      count =\
    \ count + 1\n      if i == 1 then\n        if n % 10 == 1 then\n          count\
    \ = count + 1\n        end\n      end\n    else\n      if i % 10 == 0 then\n \
    \       count = count + 1\n      end\n    end\n  end\n  return count\nend", " \
    \   local total = 0\n    for i = 1,n do\n        if ntoi(i) == 1 then\n      \
    \      total = total + 1\n        end\n    end\n    return total\nend", "  local\
    \ count = 0\n  for i = 1, n do\n    if i == 1 then -- starts with 1\n      if\
    \ n <= 10 then -- n is 10 or less\n        count = count + 1\n      else -- n\
    \ >= 10, so n is in the range 10^(n-1)\n        count = count + math.floor(math.log(math.pow(10,\
    \ n-1), 2))\n      end\n    else -- ends with 1\n      if n <= 10 then -- n is\
    \ 10 or less\n        count = count + 1\n      else -- n >= 10, so n is in the\
    \ range 10^(n-1)\n        count = count + math.ceil(math.log(math.pow(10, n-1),\
    \ 2))\n      end\n    end\n  end\n  return count\nend", "  -- The answer is guaranteed\
    \ to be either zero or a power of two, so the\n  -- final result is either one\
    \ or 2^(n-1).\n  local answer = 0\n  local i = 1\n  while i <= n do\n    if i\
    \ ~= 1 then\n      answer = answer + 1\n    end\n    i = i * 10\n  end\n  return\
    \ answer, (answer and (2^n - 1))\nend", "  if n < 0 then\n    return 0\n  else\n\
    \    return math.floor(n/2) + math.floor(n/2) + n%2 == 1\n  end\nend", "  if n\
    \ < 0 then return ends_one_ends(-n) end\n  local s = math.floor(n)\n  return starts_one_ends(s)\
    \ + (n % 1 == 0)\nend", "  -- The first one or last one is 1 and the rest is 0.\n\
    \  local s = math.floor(n/2)\n  local rest = n - s\n  local start = 1\n  local\
    \ end = 1\n  for i=1,rest do\n    local t = start\n    start = start + t\n   \
    \ local d = math.mod(n, 10) + 1\n    local dp = d - t - 1\n    if dp == 0 then\n\
    \      start = d\n      end = 0\n    end\n  end\n  return s+1, start\nend", " \
    \ if n > 0 then\n    local count = 0\n    while n > 0 do\n      if math.modf(n)\
    \ == 1 then\n        n = math.floor(n / 10)\n        count = count + 1\n     \
    \ else\n        count = count + 1\n      end\n    end\n    return count\n  end\n\
    \  return 0\nend", "    local count = 0\n    for i = 1, n do\n        if i ~=\
    \ 1 and i ~= n - 1 and\n           digits[i] == 1 and digits[i - 1] == 1 and\n\
    \           digits[i + 1] == 1 then\n            count = count + 1\n        end\n\
    \    end\n    return count\nend", "    local count = 0\n    for x = 1, n do\n\
    \        if x % 10 == 1 then\n            count = count + 1\n        end\n   \
    \ end\n    return count\nend", "  assert(n > 0)\n  local i = math.ceil(math.log10(n))\n\
    \  local count = 0\n  while n ~= 0 do\n    count = count + 1\n    n = math.floor(n/10)\n\
    \  end\n  return count\nend", "  local num_starts = 0\n  local num_ends = 0\n\
    \  for i = 1, n do\n    if i ~= 1 then\n      if i == 1:\n        num_starts =\
    \ num_starts + 1\n      else\n        num_ends = num_ends + 1\n      end\n   \
    \ end\n  end\n  return num_starts, num_ends\nend", "  return torch.add(torch.eq(n,\
    \ 1):sum(), torch.eq(n:narrow(1, -1, 1):sum()))\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
