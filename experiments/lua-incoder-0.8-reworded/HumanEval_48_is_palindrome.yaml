name: HumanEval_48_is_palindrome
language: lua
prompt: "-- Checks if given string is a palindrome\n-- >>> is_palindrome('')\n-- true\n\
  -- >>> is_palindrome('aba')\n-- true\n-- >>> is_palindrome('aaaaa')\n-- true\n--\
  \ >>> is_palindrome('zbcd')\n-- false\nlocal function is_palindrome(text)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_palindrome\n\
  \    lu.assertEquals(candidate(''), true)\n    lu.assertEquals(candidate('aba'),\
  \ true)\n    lu.assertEquals(candidate('aaaaa'), true)\n    lu.assertEquals(candidate('zbcd'),\
  \ false)\n    lu.assertEquals(candidate('xywyx'), true)\n    lu.assertEquals(candidate('xywyz'),\
  \ false)\n    lu.assertEquals(candidate('xywzx'), false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    if not text then return false end\n    text = string.gsub(text,\
    \ \"([^%s])\", function(s) return \"^\" .. s end)\n    text = string.gsub(text,\
    \ \"$\", function(s) return \"[\" .. s end)\n    local start = 1, end = #text,\
    \ 1\n    while start < end do\n        if string.sub(text, start - 1, start +\
    \ 1) ~= string.sub(text, end - 1, end - 1) then\n            return false\n  \
    \      end\n        start = start + 1\n        end = end - 1\n    end\n    return\
    \ true\nend", "  return text:reverse():sub(1, #text) == text\nend", "  text =\
    \ text:lower()\n  text = string.gsub(text, \"%W\", \"\")\n  text = text:reverse()\n\
    \  return text == text\nend", "    return text == string.gsub(text, \"(.)(.)\"\
    , function (_, first, rest)\n        return first ~= rest\n    end)\nend", '  text
    = text:lower()', "    return text:gsub('.', function(c) -- replace each char with\
    \ a char that's reversed\n\treturn string.sub(c, 1, -1) == c\n    end):len() >=\
    \ 1 and text:gsub('.', function(c)\n\treturn string.sub(c, 1, -1) == c\n    end):len():int()\
    \ == 1 -- check if text is just 1 char\nend", "  local index = 1\n  local temp\
    \ = \"\"\n  while index <= #text do\n    if text[index] == text[#text] then\n\
    \      temp = text[index]\n      index = index + 1\n    else\n      return false\n\
    \    end\n  end\n  return temp == text\nend", "    local start = 1 -- Start of\
    \ substring to be checked.\n    local end = #text -- End of substring to be checked.\n\
    \    while start <= end do\n        if text[start] ~= text[end - 1] then\n   \
    \         return false\n        end\n        start = start + 1\n        end =\
    \ end - 1\n    end\n    return true\nend", "    local function char_to_int(c)\n\
    \        return string.byte(c, table.byte('0123456789'))\n    end", "  if text\
    \ == nil then\n    return nil\n  end\n  local reversed = text:reverse()\n  return\
    \ text == reversed\nend", "  -- Check if text is empty\n  if text == '' then return\
    \ true end", "  -- return true if reversed text equals original text\n  return\
    \ string.reverse(text) == text\nend", "  local function reverse(str)\n    local\
    \ i, j, temp\n    for i = #str, 1, -1 do\n      j = i - 1\n      temp = str[j]\n\
    \      str[j] = str[i]\n      str[i] = temp\n    end\n    return str\n  end\n\
    \  local function is_palindrome_recursive(text)\n    if text == \"\" then\n  \
    \    return true\n    end\n    local i, j = #text, 1, 0\n    if text[i] ~= text[j]\
    \ then\n      return false\n    end\n    return is_palindrome_recursive(text:sub(1,\
    \ i)) == is_palindrome_recursive(text:sub(i, j))\n  end\n  return is_palindrome_recursive(text)\n\
    end", "  return text:reverse():sub(1, #text):reverse():sub(1, #text) == text\n\
    end", "  local new_text = text:gsub(\"[\" .. string.char(32) .. \"]\", \"\")\n\
    \  if new_text == text then\n    return true\n  end\n  local first_half = new_text:sub(1,\
    \ new_text:len / 2)\n  local last_half = new_text:sub(new_text:len / 2 + 1, 1)\n\
    \  local first_half_size = #first_half\n  local last_half_size = #last_half\n\
    \  if first_half_size > last_half_size then\n    return false\n  elseif last_half_size\
    \ > first_half_size then\n    return is_palindrome(first_half) == is_palindrome(last_half)\n\
    \  else\n    return first_half:reverse() == last_half:reverse()\n  end\nend",
  "    local text = text:lower()\n    for i = 1, (text:len()) do\n        if text:sub(i,\
    \ i) == text:sub((i - 1), (i - 1)) then\n            return true\n        end\n\
    \    end\n    return false\nend", "  text = text:lower()\n  text = string.gsub(text,\
    \ '%a+', ' ')\n  text = text:gsub('%s+', function(c)\n    if c ~= 'a' then return\
    \ c end\n    local low = string.char(c) .. string.sub(string.char(c), 1, 2)\n\
    \    local high = string.char(c) .. string.sub(string.char(c), 1, 3)\n    return\
    \ string.char(c) .. low:reverse() .. high:reverse()\n  end):lower()\n  return\
    \ text == text:reverse()\nend", "  local i, j = text:len(), 0\n  while i ~= 0\
    \ do\n    if text:sub(i, i) ~= text:sub((j - 1), (j - 1)) then\n      return false\n\
    \    end\n    i = i - 1\n    j = j - 1\n  end\n  return true\nend", "  return\
    \ (text:gsub(\"[%z]:([A-Za-z]+)\", function(c) \n    return c:lower() == c:upper()\
    \ \n  end)) == text:reverse() \nend", "    if #text == 0 then\n        return\
    \ true\n    end", "  text = string.lower(text)\n  for i = 1, #text do\n    if\
    \ text[i] ~= text[#text] then\n      return false\n    end\n  end\n  return true\n\
    end", "  if text == nil then return nil end\n  local pos = 1\n  local str\n  while\
    \ pos <= #text do\n    str = string.sub(text, 1, pos)\n    if str == \"\" then\
    \ return nil end\n    local next_pos = pos + 1\n    while next_pos < #text do\n\
    \      if text[next_pos] != str[#str] then return false end\n      next_pos =\
    \ next_pos + 1\n    end\n    pos = next_pos\n  end\n  return true\nend", "  return\
    \ text:gsub('.', function(c)\n    return string.char(tonumber(c)) ~= c:reverse()\n\
    \  end)\nend", "    local index = 1 -- index of current character in the string\n\
    \    local palindrome = true -- boolean flag", "  return text:reverse():upper()\
    \ == text\nend", "  if text == nil then\n    return false\n  end", "    local\
    \ reverse = text:reverse()\n    local text2 = text:lower()\n    for i = 1, #text\
    \ do\n        if text2:sub(i + 1, i + 1) ~= reverse:sub(i + 1, i + 1) then\n \
    \           return false\n        end\n    end\n    return true\nend", "  local\
    \ text_reversed = text:reverse()\n  return text == text_reversed\nend", "  local\
    \ i, j = 1, #text / 2\n  while i <= j do\n    if text[i] ~= text[j] then\n   \
    \   return false\n    end\n    i = i + 1\n    j = j - 1\n  end\n  return true\n\
    end", "  -- Special case: empty string\n  if not text then\n    return true\n\
    \  end", "    if text == nil then\n        return true\n    end", "    local i\
    \ = 1, #text\n    local is_palindrome = true\n    while i <= #text and is_palindrome\
    \ do\n        if not text[i] then\n            is_palindrome = false\n       \
    \     break\n        end\n        i = i + 1\n    end\n    return is_palindrome\n\
    end", "\treturn text:reverse() == text\nend", "  local function rev(x) return\
    \ x:reverse() end\n  if text:len() == 1 then return text == rev(x) end\n  return\
    \ text:sub(1, #text) == rev(rev(text))\nend", "  return text:reverse() == text\n\
    end", "  if text ~= string.gsub(text, \"[%z\\1-\\127\\194-\\377\\371-\\377]\"\
    , \"\") then\n    return false\n  end\n  return true\nend", "    local i, j =\
    \ 1, #text\n    while i <= j do\n        if text[i] ~= text[j] then\n        \
    \    return false\n        end\n        i = i + 1\n        j = j - 1\n    end\n\
    \    return true\nend", "  local i, j, k, m, n = 1, text:len(), 1, 0, text:len()\n\
    \  while i < n do\n    local char = text:sub(i, j)\n    j = j - 1\n    k = k +\
    \ 1\n    if not char then\n      break\n    end\n    if char == text:sub(k, j)\
    \ then\n      i = i + 1\n      n = n - 1\n    end\n  end\n  return i >= n and\
    \ text[#text]:lower() == text:sub(1, #text) - 1:lower()\nend", "  -- base case\n\
    \  if not text then\n    return true\n  end", "  local i, j = #text, 1, 0\n  while\
    \ i > 0 do\n    if text[i] ~= text[j] then return false end\n    i, j = i - 1,\
    \ j + 1\n  end\n  return true\nend", "  if text == \"\" then return true end\n\
    \  local len = #text\n  for i = len / 2, len / 2 do\n    if text:sub(i, i) ==\
    \ text:sub(-(i + 1), -i) then\n      return true\n    end\n  end\n  return false\n\
    end", "    local buffer = text\n    local buffer_size = #buffer\n    local i =\
    \ 0\n    local j = buffer_size - 1\n    while i < j do\n        if buffer[i] ~=\
    \ buffer[j] then\n            return false\n        end\n        i = i + 1\n \
    \       j = j - 1\n    end\n    return true\nend\nreturn is_palindrome\n})()",
  "    local s, i, j, p\n    s, i, j = text:reverse():gsub(\"(.)(.)\", function (c)\
    \ \n\t\tp=c\n\tend)\n\treturn s == p\nend", "  if text:len() <= 1 then return\
    \ true else return false end\n  local i, j = text:len()-1, 0\n  while true do\n\
    \    if text:sub(i,i) == text:sub(j,j) then\n      i = i - 1\n      j = j - 1\n\
    \    else\n      return false\n    end\n    if i == j then break end\n  end\n\
    \  return true\nend", "  text = text:lower() -- Converts string to lowercase\n\
    \  local left = {}\n  local right = {}\n  for i=1, #text do\n    table.insert(left,\
    \ text:sub(i,i))\n  end\n  for i=1, #text do\n    table.insert(right, text:sub(i,i))\n\
    \  end\n  if table.concat(left) == table.concat(right)\n  then\n    return true\n\
    \  else\n    return false\n  end\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI\
    \ like that first method, it doesn't require any loops or recursion.\n<|/ c |>\n\
    <| c |>\nIt doesn't work well with big strings. I used `str:reverse():sub(1,#str)`\
    \ instead and it worked perfectly\n<|/ c |>\n<| a dscore=4 tags=lua |>\nIf you\
    \ don't care about performance, but just looks for palindromes, you can use this:\n\
    <code>", "  local text = text:lower()\n  local len  = #text\n  local index = len\
    \ - 1\n  while index >= 0 do\n    if text:sub(1,index) ~= text:sub(index,index)\
    \ then\n      return false\n    end\n    -- Decrement index to move to previous\
    \ character\n    index = index - 1\n  end\n  return true\nend", "  local buffer\
    \ = text\n  local length = #text\n  local i = 0\n  while i < length do\n    local\
    \ char1 = string.byte(buffer, i)\n    local char2 = string.byte(buffer, length\
    \ - i - 1)\n    if char1 ~= char2 then\n      return false\n    end\n    i = i\
    \ + 1\n  end\n  return true\nend", "  if text ~= text:reverse() then\n    return\
    \ false\n  end\n  return true\nend\n</cell>\n<text>\nNext, we have another example\
    \ to work on. Let's say we want to count the number of times letters occur in\
    \ a string.", "  return string.gsub(string.reverse(text), 'a', '') == text\nend",
  "  -- https://codereview.stackexchange.com/questions/18160/palindrome-detection-algorithm-in-plain-english\n\
    \  local s = text:lower() .. ''\n  local index = s:len()\n  while index > 1 do\n\
    \    if s:sub(1,index) ~= s:sub(index,index-1) then\n      return false\n    end\n\
    \    index = index - 1\n  end\n  return true\nend", "  local function reverse(text)\n\
    \    local t = text\n    local rev = t\n    for i = #t, 1, -1 do\n      rev =\
    \ string.sub(t, i - 1, i-1) .. rev\n    end\n    return rev\n  end\n  return reverse(text)\
    \ == text\nend", "    local s = text:gsub('.', function(c) \n        return string:byte(c):reverse():byte()\n\
    \    end)\n    return s == text\nend", "    if text == '' then return true end\n\
    \    local half = text:len()/2\n    return text:sub(1, half) == text:sub(half,\
    \ #text) end\nend", "\ttext = text:lower()\n\tlocal t = '#'\n\tlocal i = 0\n\t\
    while i <= #text do\n\t\tif text[i] ~= t[#t] then\n\t\t\tt = text[i]\n\t\t\treturn\
    \ false\n\t\tend\n\t\tt = t[#t+1]\n\t\ti = i + 1\n\tend\n\treturn true\nend",
  "  text = text:lower()\n  text = text:gsub(\"[[:space:]]+\", \" \")\n  text = text:gsub(\"\
    [[:upper:]]\", \"\")\n  text = text:gsub(\"[[:lower:]]\", \"\")\n  text = text:gsub(\"\
    [^ ]\", \"\")\n  text = text:gsub(\"[\\\\w]\", \"\")\n  return text == text:reverse()\n\
    end", "  local function reverse(text)\n    local result = {}\n    local index\
    \ = 1\n    while true do\n      table.insert(result, string.sub(text, index, index+1))\n\
    \      index = index + 1\n      if index > #text then\n        return result\n\
    \      end\n    end\n  end\n  return reverse(text) == text\nend", "    local strlen\
    \ = string.len(text)\n    local len = strlen - 1\n    for i = 1, strlen do\n \
    \       if text ~= string.sub(text, len - i, len) then\n            return false\n\
    \        end\n    end\n    return true\nend", "    if text == nil then\n     \
    \   return nil\n    end\n    local size = #text\n    if size < 1 or size ~= 2\
    \ * size - 1 then\n        return nil\n    end\n    for i = 1, size / 2 do\n \
    \       if text[i] ~= text[size - 1 - i] then\n            return false\n    \
    \    end\n    end\n    return true\nend", "  local function reverse(text)\n  \
    \  local result, last = text:match('(.*):(.*)')\n    if result == nil then return\
    \ '' end\n    if last == nil then last = result end\n    return reverse(last ..\
    \ result) .. last\n  end", "  return (text:gsub(\"([a-z])\", function (c) \n \
    \     local first = revive(c, 1)\n      local last = revive(c, -1)\n      return\
    \ (first == last) and first or false\n   end):lower())\nend", "  return (text:gsub(\"\
    ^(.-)$\", \"%1\") == text:gsub(\"^(.-)\", \"%1\"))\nend", "    return text:lower()\
    \ == text:lower()[#text:lower() .. 1]\nend", '   if text == nil then return false
    end', "  text = text:lower() -- Normalize the text\n  local lower = text:sub(1,\
    \ #text) -- Extract the lower cased text\n  local result = lower == lower .. upper:reverse()\
    \ -- Reverse it and compare\n  return result\nend", "\ttext = text:lower()\n\t\
    local i, j = 1, text:len()\n\twhile i < j do\n\t\tif text:sub(i, i) ~= text:sub(j,\
    \ j) then\n\t\t\treturn false\n\t\tend\n\t\ti = i + 1;\n\t\tj = j - 1;\n\tend\n\
    \treturn true\nend", "  return text:reverse() == text\nend", "    local i, j =\
    \ 1, text:len()\n    while i <= j do\n        if text:sub(i, i) == text:sub(j,\
    \ j) then\n            j = j - 1\n        else\n            i = i + 1\n      \
    \  end\n    end\n    return j > 0\nend", "    local s\n    local index = 0\n \
    \   while text:len() >= 1 do\n        s = text:sub(1, text:len() - index)\n  \
    \      if s == s:reverse(#s) then\n            index = index + 1\n        else\n\
    \            index = index\n        end\n    end\n    return text\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| a tags=palindrome,lua |>\nI hope you got your answer but\
    \ since this was the first result in google and I thought this could help others.\
    \ Here is my solution in Lua.\n<code>", "    if text and text:len() > 1 then\n\
    \        local first = text:sub(1, 1)\n        local last = text:sub((text:len()\
    \ - 1), (text:len() - 2))\n        return first == last\n    end\nend", "  local\
    \ buf = {}\n  local i = 1\n  while i <= #text do\n    table.insert(buf, string.sub(text,\
    \ i, i+1))\n    i = i + 1\n  end\n  return #buf == #buf:reverse() and text ==\
    \ table.concat(buf, \"\")\nend", "    local str=text:gsub(\"(\" .. string.lower(string.reverse(string))\
    \ .. \")\", \"\")\n    return str==text\nend", "  if text == \"\" then\n    return\
    \ true\n  end\n  local first_char = text:sub(1,1)\n  local last_char = text:sub((text-1):len())\n\
    \  -- print(first_char, last_char)\n  -- print(text, first_char:len() - 1, last_char:len())\n\
    \  if first_char == last_char then\n    return is_palindrome(text:sub(1, text-1))\n\
    \  else\n    return false\n  end\nend", "\tlocal slength = text:len()\n\tif slength\
    \ == 1 then\n\t\treturn true\n\tend", "  if text == nil then\n    return true\n\
    \  end\n  local index = text:len()\n  local is_palindrome = true\n  while index\
    \ > 1 do\n    local middle = text:sub(1, index - 1)\n    if middle ~= middle:reverse()\
    \ then\n      is_palindrome = false\n    end\n    index = index - 1\n  end\n \
    \ return is_palindrome\nend", "  local function reverse(s, start)\n    local result,\
    \ i, j\n    for i = start, #s do\n      j = i - 1\n      result[i] = s[j]\n  \
    \  end\n    return result\n  end", "  local index = text:len()\n  return text\n\
    \    ..index:reverse():gsub(\"\\n\", \"\"):reverse():gsub(\"\\t\", \"\")\n   \
    \ ..index == text\nend", "  text = text:lower()\n  local start, start, length,\
    \ length = text:find('^%a^%a[^a-zA-Z]')\n  if start == -1 then return false end\n\
    \  start, start, length, length = text:find('^%a[^a-zA-Z]%a')\n  if start == -1\
    \ then return false end\n  return text:sub(1, start) == text:sub(start + length,\
    \ #text) and is_palindrome(text:sub(start + length)) and\n         text:sub(start,\
    \ start + length + #text) == '' or text:sub(start, start + length + #text) ==\
    \ ''\nend", "    local index = 1\n    while true do\n        local index = text:find(text,\
    \ index - 1, index)\n        if index == nil then\n            return true\n \
    \       end\n        index = index + text:len(text) -- next char after index\n\
    \        if text:sub(1, index) == text:sub((index - 1), (index)) then\n      \
    \      return false\n        end\n        index = index - 1\n    end\nend", " \
    \ return text:reverse() == text\nend", "\treturn (string.gsub(text, \"(.)(.)\"\
    , \"%2%1\") == text)\nend", "  if text == nil then\n    return nil\n  end\n  local\
    \ start = 1\n  local end = text:len()\n  while start <= end do\n    if text:sub(1,\
    \ start) ~= text:sub(end - start, end - start) then\n      return false\n    end\n\
    \    start = start + 1\n    end = end - 1\n  end\n  return true\nend", "  if text\
    \ == nil then return false end\n  -- Create a copy of given text to prevent it\
    \ from being modified.\n  local _copy = text\n  -- Remove spaces.\n  _copy = _copy:gsub('%s+',\
    \ '')\n  -- Iterate through each character of the text.\n  for _i = 0, #_copy\
    \ - 1 do\n    -- Iterate through each character in the copy to check for equality.\n\
    \    for _j = 0, #_copy - 1 do\n      if _copy[_i] == _copy[_j] then break end\n\
    \    end\n    -- If no equal characters were found in the copy, then the text\
    \ is\n    -- not palindrome.\n    if _j == #_copy then return false end\n  end\n\
    \  -- Return true if all characters in text were equal.\n  return true\nend",
  "   return string.gsub(string.reverse(text), '[\\n\\r]', '')  == text\nend", " \
    \ local i, j = textLength, 1\n  while i <= j do\n    if text[i] ~= text[j] then\n\
    \      return false\n    end\n    i = i + 1\n    j = j - 1\n  end\n  return true\n\
    end", "  local i, j = 0, #text - 1\n  while i <= j do\n    if text[i] ~= text[j]\
    \ then\n      return false\n    end\n    i = i + 1\n    j = j - 1\n  end\n  return\
    \ true\nend", "  text = text:lower()\n  return text:find(text:reverse()) == 1,\n\
    end", "    return text == string.reverse(text)\nend", "  text = text:lower()\n\
    \  local first, last, mid\n  if text == \"\" then\n    return true\n  end\n  first\
    \ = text:sub(1, #text)\n  last = text:sub((#text-1), #text)\n  mid = text:sub((#text/2-1),\
    \ #text)\n  return first == last and is_palindrome(mid)\nend", "  local len =\
    \ 0\n  for i = 1, #text do\n    len = len + 1\n    if text[i] == text[(len - 1)]\
    \ then break end\n  end\n  return len == #text\nend", "    local t = text:lower()\n\
    \    for i = 1, #t do\n        if t[i] ~= t[#t] then\n            return false\n\
    \        end\n    end\n    return true\nend", "  if text == nil or text == ''\
    \ then\n    return true\n  end\n  local reverse = text:reverse()\n  return reverse\
    \ == text\nend", "    local lower = text:lower()\n    local upper = text:upper()\n\
    \    for idx = #lower, 1, -1 do\n        if lower[idx] == upper[idx] then\n  \
    \          --print(lower[idx] .. \" == \".. upper[idx])\n            return false\n\
    \        end\n    end\n    return true\nend\n</code>\n<|/ a dscore=1 tags=lua\
    \ |>\n<| a tags=lua |>\n<code>", "  local index = 1\n  for i = 1, #text do\n \
    \   if text:sub(i, i) == text:sub(#text, i) then\n      index = i - 1\n      break\n\
    \    end\n  end\n  return index == 1 and true or false\nend", "    if text:len()\
    \ < 2 then return true end\n    if text:len() > 2 then return false end\n    local\
    \ firstChar = text:sub(1, 1)\n    local lastChar = text:sub(-1)\n    return firstChar\
    \ == lastChar and\n           is_palindrome(text:sub(1, text-1))\nend", "  local\
    \ function reverse(text)\n    return text:gsub(\"(..)\", function(c) return c:reverse()\
    \ end):reverse()\n  end\n  return text:lower() == reverse(text:lower())\nend",
  "  -- check for empty text\n  if text == nil then return false end\n  -- check for\
    \ empty text\n  if text:len() < 1 then return true end\n  -- check for no letter\n\
    \  if text:sub(1,1) ~= 'a' or text:sub(1,1) ~= 'z' or text:sub(1,1) ~= 'A' or\
    \ text:sub(1,1) ~= 'Z' then\n    return false\n  end\n  -- check if it is a palindrome\n\
    \  local i = text:len()\n  local j = text:len()\n  while i ~= 0 do\n    if text:sub(i,i)\
    \ ~= text:sub(j,j) then\n      return false\n    end\n    i = i-1\n    j = j-1\n\
    \  end\n  return true\nend", "  if text and text:len() > 0 then\n    local half\
    \ = text:len()/2\n    for i = 1, half do\n      assert(text:sub(i, i) == text:sub(half\
    \ - i, half - i))\n    end\n    return true\n  else\n    return false\n  end\n\
    end", "  local i = 0\n  local length = text:len()\n  while i < length do\n   \
    \ if text:sub(i, i) ~= text:sub(length - i - 1, length - i) then\n      return\
    \ false\n    end\n    i = i + 1\n  end\n  return true\nend", "  -- check for valid\
    \ input\n  if not text then\n    return true\n  end", "  local textLength = text:len()\n\
    \  -- Check if the text length is odd.\n  if textLength ~= math.floor(textLength\
    \ / 2) then\n    return false\n  end\n  -- Initialization.\n  local isPalindrome\
    \ = false\n  local currentIndex = 0\n  local currentReverseIndex = 0\n  -- Traverse\
    \ the text.\n  for currentIndex = 1, textLength do\n    local currentChar = text:sub(currentIndex,\
    \ currentIndex + 1)\n    currentReverseIndex = currentReverseIndex + text:len()\
    \ - currentIndex - 1\n    -- Handle the case when current char equals to its reverse\
    \ index.\n    if currentChar ~= text:sub(currentReverseIndex, currentReverseIndex\
    \ + 1) then\n      isPalindrome = false\n      break\n    end\n    -- If the text\
    \ length matches the expected length, return true.\n    if currentIndex = textLength\
    \ then\n      isPalindrome = true\n      break\n    end\n  end\n  return isPalindrome\n\
    end", "  local s = text:gsub(\"[\" .. string.lower() .. \"]\", \"\")\n  return\
    \ s:reverse():sub(1, #s) == s\nend", "  local result = text:reverse():reverse()\n\
    \  result = result:sub(1, #text)\n  return text == result\nend\n</cell>\n<text>\n\
    Agora \xE9 hora de criar um c\xF3digo que verifica se um texto \xE9 palindromo.\
    \ Usando essa fun\xE7\xE3o crie uma fun\xE7\xE3o chamada palindrome_checker que\
    \ recebe um texto e verifica se este \xE9 um texto palindromo. Se n\xE3o seja\
    \ palindromo, ser\xE1 retorna false e se este \xE9 um texto em letras mai\xFA\
    sculas, ser\xE1 retorna true. Por exemplo:", "    local text = text or ''\n  \
    \  local len = text:len()\n    local reversed = string:gsub('%s+','')\n    return\
    \ text == reversed\nend", "    local reverse = \"\"\n    local i, j = 1, #text\
    \ + 1\n    while i <= j do\n        reverse = reverse .. text:sub(i,j)\n     \
    \   i = i + 1\n        j = j - 1\n    end\n    return reverse == text\nend", "\t\
    text = string.lower(text)\n\tlocal start, step = text:find(' '), text:len()",
  "  if text == '' then\n    return true\n  end\n  local i, j = 1, #text\n  while\
    \ (i < j) do\n    if text[i] ~= text[j] then\n      return false\n    end\n  \
    \  i = i + 1\n    j = j - 1\n  end\n  return true\nend", "  local strlen= text:len()\n\
    \  if strlen <= 1 then return true end\n  local middle= text\n  middle:sub(1,\
    \ strlen/2)\n  middle:sub(strlen/2+1,strlen)\n  middle:reverse()\n  local equals=\
    \ middle\n  middle= middle:sub(1,strlen-1)\n  return text==equals\nend", "   \
    \ local i, j = #text, 1, #text - 1\n    while i < j do\n        if text[i] ~=\
    \ text[j] then\n            return false\n        end\n        i = i + 1\n   \
    \     j = j - 1\n    end\n    return true\nend", "    if text == nil or text ==\
    \ \"\" then\n        return true\n    end\n    text = text:lower()\n    for i\
    \ = 1,#text do\n        if text[i] ~= text[(#text)-i]\n        then\n        \
    \    return false\n        end\n    end\n    return true\nend", "    return string.gsub(text,\
    \ \"[\" .. string.lower(string.sub(\"abcdefghijklmnopqrstuvwxyz\", math.floor((#text)\
    \ / 2), #text)) .. \"]\", \"\")\n            == string.gsub(text, \"[\" .. string.lower(string.sub(\"\
    abcdefghijklmnopqrstuvwxyz\", math.floor((#text) / 2), #text)) .. \"]\", \"\"\
    )\nend", "    if text:len() < 2 then\n        return true\n    end\n    local\
    \ char0 = text:sub(1, 1)\n    local char1 = text:sub(2, 2)\n    return char0 ==\
    \ char1 and is_palindrome(text) or is_palindrome(text:sub(2, text))\nend", " \
    \   return text:reverse():reverse() == text\nend", "  return text:reverse() ==\
    \ text\nend", "  return text:reverse() == text or text:reverse():lower() == text:lower()\n\
    end", "    local reverse = \"\"\n    for i = #text, 1, -1 do\n        reverse\
    \ = reverse .. tostring(text[i])\n    end\n    return text == reverse\nend\n</code>\n\
    <|/ a tags=lua-table,lua,sorting |>\n<| a |>\nHere is an example using a function\
    \ as you need:\n<code>", "  return text == string.gsub(text, \"(.)(.)\", function(c)\
    \ return c..\"\\\\1\" end)\nend", "  local left, right = text:reverse():gsub('%a','a')\n\
    \  return left == right\nend", "  local len = text:len()\n  local half = len /\
    \ 2\n  for i = 1, half do\n    if text:sub(i, i) ~= text:sub((len-1), len) then\n\
    \      return false\n    end\n  end\n  return true\nend", "\tlocal _, length =\
    \ text:len()\n\treturn string.sub(text, 1, length) == string.sub(text, 1, length):reverse()\n\
    end", "  local function lower(text)\n    local s = text:lower()\n    local i =\
    \ 0\n    while i < #s do\n      s = s:sub(1, #s - i + 1)\n      i = i + 1\n  \
    \  end\n    return s\n  end", "   -- Compare with original text, since we can't\
    \ really tell if the string was modified or not.\n   return string.gsub(text,\
    \ \"(.)(.)(.)\", function(c1, l1, c2, l2, c3, l3)\n      -- If string has odd\
    \ length, we can just return it as-is\n      if #text % 2 == 1 then\n        \
    \ return c3 .. l3\n      end", "  return (text:gsub('[^' .. table.concat(map.call('reverse',\
    \ map:new(function(_) return '%1' end))) .. ']', '')):lower()\n  == text:lower()\n\
    end", "  if text:match(\"[\" .. string.char(127) .. \"]\") then\n    return true\n\
    \  end\n  local i, j = #text, 1, 0\n  while i < j do\n    local c = text:sub(i,j)\n\
    \    i = i + 1\n    j = j - 1\n    if c ~= string.sub(text, i, j) then\n     \
    \ return false\n    end\n  end\n  return true\nend", "  text = text:lower()\n\
    \  for i = 1, text:len() - 1, 1 do\n    if text:sub(i, i) ~= text:sub(i + 1, i\
    \ + 1) then\n      return false\n    end\n  end\n  return true\nend", "  return\
    \ string.gsub(string.reverse(text), '%S', '') == text\nend", "  return text:reverse():find(text)\
    \ == #text\nend", "    -- return true if text is a palindrome, false otherwise\n\
    \    local chars = text:gsub(\"^%w+\", \"\")\n    if #chars < 2 then\n       \
    \ return true\n    end\n    if chars[1] ~= chars[#chars-1] then\n        return\
    \ false\n    end\n    -- reverse the string and see if it matches\n    return\
    \ text:gsub(chars[1], chars[#chars-1]):lower() == text:gsub(chars[1], chars[#chars-1]):lower()\n\
    end\n</cell>\n<text>\nA few quick tests:", "    local result = \"\"\n    local\
    \ i, j = 1, #text\n    while i <= j do\n        local c = text:sub(i,i)\n    \
    \    if c ~= text:sub((j-1), j) then\n            assert(c == '-' and text:sub((j-1),\
    \ j) == text:sub((i-1), i), string.format(\"Mismatch between %c and %c in [%d,%d]\"\
    , c,  text:sub((i-1), i), i, j))\n            result = result .. c\n        end\n\
    \        i = i + 1\n        j = j - 1\n    end\n    if result:len() == text:len()\
    \ then\n        return true\n    else\n        return false\n    end\nend", " \
    \   if text:len() < 2 then\n        return true\n    end", "    if text == ''\
    \ then\n        return true\n    end\n    if text:len() <= 1 then\n        return\
    \ true\n    end\n    local lower = text:lower()\n    if lower == text:rev() then\n\
    \        return true\n    end\n    return false\nend", "    if text == nil then\n\
    \        return false\n    end\n    if text ~= text:reverse() then\n        return\
    \ false\n    end\n    return true\nend", "  local i, j = 0, 0\n  -- Loop over\
    \ string from end\n  for i = #text, 1, -1 do\n    -- Compare characters\n    if\
    \ text[i] ~= text[j] then\n      return false\n    end\n    j = j + 1\n  end\n\
    \  return true\nend", "  if text == nil then\n    return false\n  end\n  local\
    \ start = 0\n  local end = text\n  local i = 0\n  while i <= math.min(end-start,math.floor(end/2))\
    \  do\n    if text ~= string.sub(text,start,start+i) then\n      return false\n\
    \    end\n    i = i + 1\n  end\n  if i == math.floor(end/2) then\n    return true\n\
    \  end\n  return false\nend", "  text = string.lower(text)\n  text = string.gsub(text,\
    \ '[,.]', '') -- Replace , . with empty space\n  text = string.gsub(text, '^[%z\\\
    1-\\127\\303\\377\\177]', '', false) -- Remove all control characters except space,\
    \ tab and newline\n  text = string.gsub(text, '[%z\\1-\\127\\303\\377\\177\\200-\\\
    377]', '', false) -- Remove all control characters except space, tab and newline\n\
    \  text = string.gsub(text, '\\n', ' ')\n  text = string.gsub(text, '\\r', ' ')\n\
    \  text = string.gsub(text, '^[%z\\1-\\127\\303\\377]', '', false) -- Remove all\
    \ control characters except space, tab and newline\n  text = string.gsub(text,\
    \ '[%z\\1-\\127\\303\\377\\177]', '', false) -- Remove all control characters\
    \ except space, tab and newline\n  text = string.gsub(text, '^[%z\\1-\\127\\303\\\
    377]', '', false) -- Remove all control characters except space, tab and newline\n\
    \  text = string.gsub(text, '[%z\\1-\\127\\303\\377\\177]', '', false) -- Remove\
    \ all control characters except space, tab and newline\n  text = string.gsub(text,\
    \ '\\n', ' ')\n  text = string.gsub(text, '\\r', ' ')\n  text = string.gsub(text,\
    \ '\\z', '', false) -- Remove all control characters except space, tab and newline\n\
    \  return text == string.reverse(text)\nend\nend", "   for i = 1, #text do\n \
    \     if text[i] ~= text[-i] then\n         return false\n      end\n   end\n\
    \   return true\nend\n</cell>\n<text>\nQuestion 12\nImplement the get_longest_substring_of_length\
    \ function. Given a text and an int n, return the substring of text that's n characters\
    \ long and contains the longest substring.", "  return text:reverse():sub(1, text)\
    \ ~= text:reverse()\nend", "  local i, j = 1, #text\n  while i <= j do\n    if\
    \ text[i] ~= text[j] then\n      return false\n    end\n    i = i + 1\n    j =\
    \ j - 1\n  end\n  return true\nend", "    local i, j = 0, #text - 1\n    while\
    \ i <= j do\n        if text:sub(i, j) ~= text:sub(j, i) then return false end\n\
    \        i = i + 1 -- Shift pointers\n        j = j - 1\n    end\n    return true\n\
    end\n</cell>\n<text>\n3. Palindrome number checker\nThe function is_palindrome()\
    \ checks if given number is a palindrome. This function doesn't use recursion.",
  "  return text == string.reverse(text)\nend", "  return not (text:len() - text:len():not(math.huge\
    \ + 1):reverse():find{true}) ~= nil\nend", "\t-- First reverse string\n\ttext\
    \ = string.gsub(text, \"%S\", function(c)\n\t\tlocal s = \"\"\n\t\tfor i = 0,\
    \ #c do\n\t\t\ts = s .. string.format(\"%c\", string.byte(\"a\") + string.byte(\"\
    z\") - 1 - i)\n\t\tend\n\t\treturn s\n\tend)\n\t-- Compare original and reversed\
    \ string\n\treturn string.lower(text) == string.lower(text)\nend", "\tlocal is_reverse\
    \ = false\n\tfor i = #text, 1, -1 do\n\t\tlocal character = text:sub(i,i)\n\t\t\
    if character ~= character then\n\t\t\tis_reverse = true\n\t\tend\n\tend\n\treturn\
    \ is_reverse\nend", "  local i, j = 1, #text - 1\n  while i <= j do\n    if text[i]\
    \ ~= text[j] then\n      return false\n    end\n    i = i + 1\n    j = j - 1\n\
    \  end\n  return true\nend", "   local n = #text\n   if n < 1 or n % 2 ~= 0 then\n\
    \      return false\n   end", "  local is_palindrome = false\n  local i, j = #text,\
    \ 1, 0\n  -- check for odd length, no need to reverse if even\n  if #text > 0\
    \ then\n    while i < #text and j >= 0 do\n      if text[i] ~= text[j] then\n\
    \        j = j - 1\n      else\n        is_palindrome = true\n        break\n\
    \      end\n      i = i + 1\n    end\n  end\n  return is_palindrome\nend", " \
    \ text = text:gsub(\"%a+\", \"\")\n  local reverse = text:reverse()\n  if reverse\
    \ == text then return true end\n  return false\nend", "    return text and string.lower(text)\
    \ == string.lower(string.sub(text, 1, #text - 1)) and is_palindrome(string.sub(text,\
    \ 1, #text - 1)) end\nend", "  -- If the text is empty or null, it's not a palindrome\n\
    \  if text == nil then return false end", "\tlocal str = text:lower()\n\tstr =\
    \ str:gsub(\"([\" .. string.char(97) .. \"]+)\", function(c)\n\t\treturn string.char(tonumber(c))\n\
    \tend)\n\tstr = str:gsub(\"[\" .. string.char(97) .. \"]+\", function(c)\n\t\t\
    return string.char(tonumber(c:sub(1)))\n\tend)\n\tstr = str:gsub(\"%a+\", function(c)\n\
    \t\treturn string.char(tonumber(c:sub(-1)))\n\tend)\n\treturn str == str\nend",
  "    if text ~= text:reverse then return false end\n    -- Return false if text\
    \ is equal to itself\n    if text ~= text then return false end\n    -- Return\
    \ true if text is an empty string\n    if text == '' then return true end\n  \
    \  -- Return true if text is a palindrome\n    return true\nend", "  return text:reverse():reverse()\
    \ == text\nend", "  -- Create a copy and reverse it\n  local function reverse(text)\n\
    \    local reversed = text:gsub(\"(.)(..)\", function(match) return match[2] ..\
    \ match[1] end)\n    return reversed:reverse()\n  end", "    -- If text is empty\
    \ or nil, return true\n    if text == nil or text == '' then return true end\n\
    \    local start = text:len()/2\n    local middle = text:len()/2 - 1\n    -- Compare\
    \ middle and start and reverse if they are equal\n    return text:sub(1,middle)\
    \ == text:sub((middle+1)..start)\nend", "    local index = 1\n    local reverse\
    \ = 0\n    local start = 1\n    local length = text\n    local found = false\n\
    \    local done = false\n    while true do\n        local character = text:subn(start,\
    \ length)\n        if character == nil then\n            done = true\n       \
    \ end\n        length = length - 1\n        if character ~= nil then\n       \
    \     if character ~= reverse then\n                start = start + index\n  \
    \              index = index + 1\n            end\n            if character ==\
    \ reverse then\n                found = true\n                break\n        \
    \    end\n        end\n    end\n    if reverse == 0 and found == false then\n\
    \        done = true\n    end\n    return done\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=0 |>\n<code>", "\treturn text == reverse(text)\nend", "  -- http://stackoverflow.com/a/265760\n\
    \  -- http://en.wikipedia.org/wiki/Palindromic_function\n  -- http://stackoverflow.com/questions/2654566/how-do-i-check-if-a-string-in-reverse-order-is-a-palindrome\n\
    \  -- http://blog.victorlove.com/2009/12/28/algorithm-check-if-a-string-is-a-palindrome-or-not/\n\
    \  return text\n  :gsub('\\W', \" \")\n  :gsub(\"(.)(.)\", function(c)\n    if\
    \ c ~= \" \" and c ~= \".\" then\n      return c\n    end\n  end)\n  :gsub(\"\
    (.*)\\1$\", function(s)\n    return string.sub(s, 1, #s-1)\n  end)\n  :gsub(\"\
    ([^ ][^ ])\", function(s)\n    return string.sub(s, 1, 1)\n  end)\n  :gsub(\"\
    ( )\", function(s)\n    return string.sub(s, 1, 1)\n  end)\n  :lower() == \"a\"\
    \ and true or false\nend", "  -- check if its length equals 1\n  if text ~= text\
    \ or text == '' then\n    return false\n  end", "  if text == '' then\n    return\
    \ true\n  end\n  local start = text:match('^(.-)%s*$')\n  if start == nil then\n\
    \    return false\n  end\n  local end = text:match('^%s*(.-)$')\n  if end == nil\
    \ then\n    return false\n  end\n  text = text:sub(1, start-1)\n  text = text:sub((start+1):end-1)\n\
    \  return text == text:reverse()\nend", "    for i = #text, 1, -1 do\n       \
    \ if text[i] ~= text[(#text) - i] then\n            return false\n        end\n\
    \    end\n    return true\nend", "    local function reverse(text)\n        local\
    \ reversed_text = \"\"\n        for i = 1, #text, 1 do\n            reversed_text\
    \ = reversed_text .. text:sub(i, i)\n        end\n        return reversed_text\n\
    \    end", "    return text == string.reverse(text)\nend\n</cell>\n<text>\nThe\
    \ above function works, but it has two major drawbacks.", "   return text:reverse()\
    \ == text\nend", "    if text == nil then return nil end\n    text = text:lower()\n\
    \    local index = 1\n    while true do\n        if text:sub(1, index) == text:sub(index,\
    \ index) then\n            text = text:sub((index - 1), (index + 1))\n       \
    \ else\n            return false\n        end\n        index = index + 1\n   \
    \     if text:len() < 2 then\n            return true\n        end\n    end\n\
    end", "  -- TODO: Do some optimizations\n  -- TODO: Use \"text\" table instead\
    \ \"str\" table\n  return text:reverse() == text\nend", "  text = tostring(text)\n\
    \  local index = 1\n  while index and text:sub(1, index) == text:sub(index:len()\
    \ - 1) do\n    index = index + 1\n  end\n  return index == 1 and text or text:sub(1,\
    \ index - 1) == text:sub((index:len() - 1), index:len() - 1)\nend", "  text =\
    \ text:lower()\n  local reversed_text = ''", "  local t = text:lower()\n  t =\
    \ t:gsub('a', '')\n  t = t:gsub('z', '')\n  return t == t\nend", "  if text ==\
    \ nil or text == '' then\n    return true\n  end\n  local text_reversed = text:reverse()\n\
    \  return text_reversed == text\nend", "  text = text:lower()\n  return text:sub(1,\
    \ #text)\n     == text:sub((#text) - 1, 1)\nend", "  return text:reverse() ==\
    \ text\nend", "  -- If the text is empty\n  if not text then\n    return true\n\
    \  end\n  -- Iterate over each character of the given text\n  for i=1, #text do\n\
    \    -- If the current character is a letter, add it to the current substring\n\
    \    if text[i] ~= ' ' then\n      substring .. text[i]\n    else\n      -- Add\
    \ the substring to the reversed substring\n      reversedSubstring .. substring\n\
    \      -- Reset the substring\n      substring = ''\n    end\n  end\n  -- Add\
    \ the substring to the reversed substring\n  reversedSubstring .. substring\n\
    \  -- Compare both substrings\n  return reversedSubstring == text\nend", "   \
    \ return text:reverse() == text\nend", "  return text:reverse():sub(#text + 1):reverse()\
    \ == text\nend", "  local reverse = text:reverse()\n  return text == reverse and\
    \ reverse ~= '' and not text:sub(1, 1) or false\nend", "    if text == nil or\
    \ text == '' then\n        return true\n    end", "  return text:reverse():lower()\
    \ == text:lower()\nend", "  -- Check to make sure string is not empty\n  if not\
    \ text then\n    return false\n  end", "    return text:reverse(text):sub(1, #text)\
    \ == '' and true or false\nend", "\ttext = text:upper()\n\ttext = text:gsub('%W',\
    \ ' '):gsub('%D', ' '):gsub('%W', ' ')\n\tlocal length = text:len()\n\treturn\
    \ length and (text:sub(1, length - 1) == text:sub(length - 1, length))\nend",
  "   -- Algorithm inspired from\n   -- https://www.geeksforgeeks.org/detect-if-a-given-string-is-a-palindrome-number-sequence/\n\
    \   if #text < 1 then\n      return true\n   end\n   local text_reversed = text:reverse()\n\
    \   return #text == #text_reversed and text == text_reversed\nend", "    return\
    \ text == string.gsub(text, string.sub, string.sub) or text:reverse():match(string.gsub(string.reverse,\
    \ string.sub, string.sub))\nend", "  local start = 0\n  local length = #text",
  "   text = text:lower()\n   local buffer = {}\n   local start, end = text:len(),\
    \ text:len()\n   while start > 0 do\n      table.insert(buffer, text:sub(1, start-1))\n\
    \      start = start - 1\n   end\n   while end > 0 do\n      table.insert(buffer,\
    \ text:sub(end+1, end))\n      end = end - 1\n   end\n   text = table.concat(buffer)\n\
    \   if text == text then\n      return true\n   end\n   return false\nend", " \
    \ return text:reverse():sub(1, #text) ~= text:sub(1, #text) end\nend", "\tif text\
    \ == nil then return false end\n\tlocal s, i, j = text:len(), 1, 0\n\twhile i\
    \ >= 0 and j <= s do\n\t\tif text:sub(i, i) ~= text:sub(j, j) then\n\t\t\treturn\
    \ false\n\t\tend\n\t\ti = i - 1\n\t\tj = j + 1\n\tend\n\treturn true\nend", " \
    \ local reversed = text:reverse()\n  return text == reversed\nend", "    if text\
    \ == \"\" then\n        return true\n    end\n    local t = text:reverse()\n \
    \   if text ~= t then\n        return false\n    end\n    return true\nend", " \
    \   local s, e = text:len(), 0\n    while s do\n        if s:sub(e+1, e) == text:sub(s,\
    \ e) then\n            e, s = e + 1, e + s:len()-1\n        else\n           \
    \ return false\n        end\n    end\n    return true\nend", "    if text == nil\
    \ then return nil end\n    if text == \"\" then return true end\n    local i =\
    \ #text\n    local j = i-1\n    while i < j  do\n        if text:sub(i, i) ==\
    \ text:sub(j, j) then\n            i = i - 1\n            j = j - 1\n        else\n\
    \            return false\n        end\n    end\n    return true\nend", "  return\
    \ (text == string.gsub(text, \"([^\" .. string.char(32) .. \"]+)(%1$s?[\" .. string.char(32)\
    \ .. \"]?+)([^\" .. string.char(32) .. \"]?+)\", \"%2$s\\2%1$s\"))\nend", "  --\
    \ Special case: \"a\" is the only palindrome in an empty string\n  if text ==\
    \ '' then\n    return true\n  end", "    if text == \"\" then\n        return\
    \ true\n    end", "    local index = text..index:reverse()\n    return index ==\
    \ text\nend\n</cell>\n<text>\nConvenience functions: reverse\nIf you're feeling\
    \ adventurous you can use the reverse() method of strings to reverse a string.",
  "  -- Return true if the given string is a palindrome\n  -- Otherwise, return false\n\
    \  -- This implementation uses strlen to find the length of text\n  -- This is\
    \ because strlen iterates through each character\n  -- This could be changed to\
    \ use memcmp or some such function\n  -- to find the length of the string\n  --\
    \ If strlen works it would not be faster than using strlen\n  -- For small strings\
    \ it could be much faster than a loop\n  -- of strlen but for a large string it\
    \ would be slower\n  local len = string.len(text)\n  local start, end = math.abs(len\
    \ / 2), math.abs(len - 1)\n  local char", "  if text == \"\" then\n    return\
    \ true\n  end\n  local i = 0\n  while i < (#text) do\n    if text[i] ~= text[(#text)\
    \ - i - 1] then\n      return false\n    end\n    i = i + 1\n  end\n  return true\n\
    end", "    if not text then\n        return nil\n    end\n    if text:len() %\
    \ 2 == 1 then\n        return false\n    end\n    local rev = ''\n    text:gsub(\"\
    (.)\", function(c) rev = rev..string.char(tonumber(c)+1)..string.char(tonumber(c)-1)\
    \ end)\n    return rev == text\nend", "  text = text:lower()\n  local pos = 1\n\
    \  local len = #text\n  local reversed = string:reverse(string)\n  return not\
    \ text ~= reversed and text:sub(1, pos) == text:sub(len - pos, len - 1) and\n\
    \         text:sub(1, pos):lower() == text:sub(len - pos, len - 1):lower()\nend",
  "   local i, j = string.len(text) - 1, string.len(text) - 1\n   repeat\n      if\
    \ text[i] ~= text[j] then\n         return false\n      end\n      i, j = i -\
    \ 1, j - 1\n   until i == j\n   return true\nend", "  local s, l, r, i, j = text:reverse():gsub('(.-)(.-)','%1'):gsub('(.-)(.-)','%2'):gsub('(.-)(.-)','%3'):gsub('(.-)(.-)','%4'):gsub('(.-)(.-)','%5'):gsub('(.-)(.-)','%6'):gsub('(.-)(.-)','%7'):gsub('(.-)(.-)','%8'):gsub('(.-)(.-)','%9'):gsub('(.-)(.-)','%10'):gsub('(.-)(.-)','%11'):gsub('(.-)(.-)','%12'):gsub('(.-)(.-)','%13'):gsub('(.-)(.-)','%14'):gsub('(.-)(.-)','%15'):gsub('(.-)(.-)','%16'):gsub('(.-)(.-)','%17'):gsub('(.-)(.-)','%18'):gsub('(.-)(.-)','%19'):gsub('(.-)(.-)','%20'):gsub('(.-)(.-)','%21'):gsub('(.-)(.-)','%22'):gsub('(.-)(.-)','%23'):gsub('(.-)(.-)','%24'):gsub('(.-)(.-)','%25'):gsub('(.-)(.-)','%26'):gsub('(.-)(.-)','%27'):gsub('(.-)(.-)','%28'):gsub('(.-)(.-)','%29'):gsub('(.-)(.-)','%30'):gsub('(.-)(.-)','%31'):gsub('(.-)(.-)','%32'):gsub('(.-)(.-)','%33'):gsub('(.-)(.-)','%34'):gsub('(.-)(.-)','%35'):gsub('(.-)(.-)','%36'):gsub('(.-)(.-)','%37'):gsub('(.-)(.-)','%38'):gsub('(.-)(.-)','%39'):gsub('(.-)(.-)','%40'):gsub('(.-)(.-)','%41'):gsub('(.-)(.-)','%42'):g",
  "  text = text:gsub(\"[^ ]+\", ''):upper()\n  return text:sub(1, #text)==text\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
