name: HumanEval_59_largest_prime_factor
language: lua
prompt: "-- Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  -- >>> largest_prime_factor(13195)\n-- 29\n-- >>> largest_prime_factor(2048)\n--\
  \ 2\nlocal function largest_prime_factor(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = largest_prime_factor\n\
  \    lu.assertEquals(candidate(15), 5)\n    lu.assertEquals(candidate(27), 3)\n\
  \    lu.assertEquals(candidate(63), 7)\n    lu.assertEquals(candidate(330), 11)\n\
  \    lu.assertEquals(candidate(13195), 29)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local factors\n  if n <= 1 then return 1 end\n  if n <= 2 then return\
    \ 1 end\n  factors = {}\n  for i = 2, n do\n    local j = 1\n    while i * j <=\
    \ n do\n      if n % i == 0 then break\n      end\n      j = j + 1\n    end\n\
    \    if j > 1 then\n      table.insert(factors, i)\n    end\n  end\n  local max\
    \ = table.max(factors)\n  if max % 2 == 0 then return max + 1 else return max\
    \ end\nend", "  if n <= 1 then return 1 end\n  local result = 2\n  while n % result\
    \ == 0 do\n    local s = 2\n    while s * s <= n do\n      if n % s == 0 then\
    \ break end\n      s = s + 1\n    end\n    result = s\n  end\n  return result\n\
    end", "  -- Base case: small prime factor.\n  if n < 2 then return 1 end", " \
    \ -- Base case: n == 1 or n == 0\n  if n == 1 then return 2 end\n  -- Return the\
    \ largest prime factor of n (where n >= 2)\n  if n == 2 then return 2\n  else\n\
    \    -- Find a divisor of n that divides evenly into n\n    -- by considering\
    \ all the integers up to n / 2.\n    -- n is divided into i by considering integer\
    \ division of i by 2\n    -- which means a division remainder of 1 will divide\
    \ i evenly\n    -- (by considering all integers up to n / 2)\n    -- The largest\
    \ such divisor is the one that divides evenly into n\n    -- by considering all\
    \ integers up to n / 2. Thus the\n    -- largest prime divisor is the largest\
    \ divisor of n that divides evenly into n.\n    for i = 2, n / 2 do\n      --\
    \ Check if i is prime using the Miller-Rabin algorithm\n      -- This algorithm\
    \ is quite fast for small numbers but will\n      -- fail eventually on large\
    \ ones. Also it fails on 0 which we check separately\n      if not isprime(i)\
    \ then return nil\n      -- Check if n is divisible by i\n      if n % i == 0\
    \ then\n        -- Divide n by i and check if this is equal to the remainder\n\
    \        if n % (i / i) == 0 then return i end\n      end\n    end\n  end\nend\n\
    </code>\n<|/ a |>\n<| a |>\nHere is another approach. It just checks whether a\
    \ number is prime or not and returns a list of its prime factors.\n<code>", "\t\
    -- https://stackoverflow.com/questions/13036463/fast-way-of-finding-the-greatest-prime-factor-in-an-integer\n\
    \tlocal function factor(n)\n\t\tif n == 0 then\n\t\t\treturn nil\n\t\tend", " \
    \   assert(n > 1)\n    local i = 1\n    while i * i <= n do\n        i = i + (n\
    \ % i)\n        n = n / i\n    end\n    return i\nend", "    local p = 2\n   \
    \ local q = 3\n    repeat\n        local t = n % p\n        if t == 0 then\n \
    \           return p\n        elseif t < q then\n            p = p * 2\n     \
    \   else\n            q = q * 2\n        end\n    until n % p == 0\n    return\
    \ p\nend", "\tlocal div, mod = div(n, 2)\n\tif not mod then\n\t\treturn n\n\t\
    end\n\twhile div > 1 do\n\t\tlocal p, q = div, mod \n\t\tdiv, mod = q, p % q\n\
    \tend\n\treturn p\nend", "    local m = n % 2\n    if m == 0 then\n        return\
    \ 1\n    end\n    for i = 2, n / 2 do\n        if n % i == 0 then\n          \
    \  return i\n        end\n    end\n    return n\nend", "  -- Special cases\n \
    \ if n < 2 then return 1 end\n  if n == 2 then return 2 end", "    local n = math.floor(n)\n\
    \    if n == 2 then\n        return n\n    end\n    local d = n\n    local p =\
    \ 2\n    while d % 2 == 0 and p <= n do\n        local q = n / p\n        if p\
    \ % 2 == 0 and q * p <= n then\n            d = q\n        end\n        p = p\
    \ + 2\n    end\n    return d\nend", "  -- Trial division algorithm from https://en.wikipedia.org/wiki/Trial_division\n\
    \  -- Find the highest power of prime p <= n where 2^(p-1) <= n <= 2^p.\n  local\
    \ p = 1\n  while p * p <= n do\n    local q = 2\n    while q * q <= n and n %\
    \ q == 0 do\n      q = q + 1\n    end\n    -- p * p > n if p^2 > n\n    local\
    \ p = p * 2\n    if q > n then\n      break\n    end\n  end\n  if p * p > n then\n\
    \    p = 1\n  end\n  -- Return the largest prime factor of n.\n  return p\nend",
  "  -- Sieve of Eratosthenes\n  local function sieve(n)\n    if n == 1 then return\
    \ 1 end\n    local i, b = 2, 2\n    while i <= n do\n      if n % i == 0 then\n\
    \        b, i = b, i + b\n      else\n        i = i + 2\n      end\n    end\n\
    \    return b\n  end", "  -- Trick: Divide by all the primes less than or equal\
    \ to n.\n  -- http://www.primesieve.com/\n  -- https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \  -- http://oeis.org/A008272\n  -- http://research.microsoft.com/~unsr/00045630/\n\
    \  -- http://stackoverflow.com/questions/15609/primality-test-for-python\n  --\
    \ https://en.wikipedia.org/wiki/Primality_test\n  local primes = [2, 3]\n  local\
    \ i = 3\n  while i <= math.sqrt(n) do\n    local p = primes[i]\n    while n %\
    \ p == 0 do\n      n = n / p\n      table.insert(primes, p)\n    end\n    i =\
    \ i + 1\n  end\n  -- Find the largest prime factor of n and return it.\n  -- This\
    \ algorithm is guaranteed to return the largest prime factor of n\n  -- when n\
    \ is larger than sqrt(2).\n  return table.remove(primes, #primes)\nend", "  --\
    \ The prime factors of n are all the factors of the product of\n  -- prime numbers.\
    \  See Pollard's rho and cst's primefactors as\n  -- an excellent resource for\
    \ this technique.\n  --\n  -- This algorithm is naive and can be improved.\n \
    \ -- A more efficient algorithm will need a better factoring\n  -- algorithm which\
    \ can produce a less sparse factorization.\n  -- A better factoring algorithm\
    \ may be found here:\n  --\n  --   http://www.cs.dartmouth.edu/~doug/courses/cs252/lectures/06_factorisation.html\n\
    \  -- http://www.cs.dartmouth.edu/~doug/Courses/175/fall11/lectures/L06.html\n\
    \  --\n  -- This algorithm is implemented by Pollard's rho factorization\n  --\
    \ and is therefore very slow.  This is because the factoring\n  -- algorithms\
    \ of Peter Dartmouth are too slow for this simple task.\n  --\n  -- The first\
    \ step is to factor n into primes using the prime\n  -- factorization algorithm\
    \ from Pollard's rho factorization.\n  -- See primefactors() for an implementation\
    \ of this.\n  --\n  -- The second step is to find the largest prime factor of\
    \ the\n  -- product of the prime factorization of the input number.", "    --\
    \ If n is prime then largest prime factor is n\n    if n == 1 then return n end",
  "  local primes = {}\n  for i = 2, math.sqrt(n) do\n    local prime = 2\n    while\
    \ prime < math.sqrt(n) and n % prime == 0 do\n      prime = prime + 1\n    end\n\
    \    if prime > 1 then\n      primes[#primes + 1] = prime\n    end\n  end\n  return\
    \ primes[#primes + 1]\nend", "  -- First we try to get the largest prime factor\
    \ of n\n  local function next_prime_factor(factor)\n    local factors = factor\n\
    \    repeat\n      factor = factors[#factors] - 1\n    until not factors[factor]\
    \ and factor > 1\n    return factor\n  end\n  -- The largest prime factor of n\
    \ is the largest integer such that n % factor is zero.\n  local function largest(factor)\n\
    \    local factors = factor\n    repeat\n      factor = factors[#factors] - 1\n\
    \    until not factors[factor] and factor > 1\n    return factor\n  end\n  --\
    \ Next we try to get another prime factor.\n  local function try_next_prime_factor(factor)\n\
    \    local factors = factor\n    repeat\n      factor = next_prime_factor(factor)\n\
    \    until not factors[factor] and factor > 1\n    return factor\n  end\n  --\
    \ If that didn't work, we divide n by primes[largest(primes)-1] and try again.\n\
    \  -- >>> largest_prime_factor(938)\n  -- 7\n  -- >>> largest_prime_factor(937)\n\
    \  -- 7\n  -- >>> largest_prime_factor(1800)\n  -- 5\n  -- >>> largest_prime_factor(999)\n\
    \  -- 3\n  -- >>> largest_prime_factor(999)\n  -- 3\n  -- >>> largest_prime_factor(2044)\n\
    \  -- 2\n  local primes = {}\n  repeat\n    primes[#primes+1] = 2\n  until primes[largest(primes)-1]\
    \ > n\n  -- The prime factors of n are primes[largest(primes)-1].\n  -- So we\
    \ check whether n is divisible by primes[largest(primes)-1].\n  -- >>> largest_prime_factor(938)\n\
    \  -- 7\n  -- >>> largest_prime_factor(937)\n  -- 7\n  -- >>> largest_prime_factor(1800)\n\
    \  -- 5\n  -- >>> largest_prime_factor(999)\n  -- 3\n  -- >>> largest_prime_factor(999)\n\
    \  -- 3\n  -- >>> largest_prime_factor(2044)\n  -- 2\n  -- >>> largest_prime_factor(73)\n\
    \  -- 0\n  -- >>> largest_prime_factor(73)\n  -- 0\n  -- >>> largest_prime_factor(73)\n\
    \  -- 0\n  -- >>> largest_prime_factor(73)\n  -- 0\n  -- >>> largest_", "  if\
    \ n < 2 then return 1 end\n  -- If n is a prime, then the largest prime factor\
    \ is n-1.\n  if primes then\n    for i=2, n do\n      if n % i == 0 then\n   \
    \     return i\n      end\n    end\n  end\n  -- If a composite is larger than\
    \ the largest prime factor of n-1 then we\n  -- need to take a closer look to\
    \ see if the number is composite.\n  local factor = 2\n  while n % factor == 0\
    \ do\n    factor = factor * 2\n  end\n  if factor > n then\n    return factor\n\
    \  end\n  return n\nend", "  if n > 1 then return nil end\n  local i = 1\n  repeat\n\
    \    while i * i <= n do\n      if n % i == 0 then\n        n = n / i\n      \
    \  break\n      end\n      i = i + 1\n    end\n  until not n\n  return i\nend",
  "    local n = tointeger(n)\n    if not n then\n        return nil\n    end\n  \
    \  local prime = 2\n    local counter = 1\n    while prime < n do\n        while\
    \ n % prime == 0 do\n            n = n / prime\n            counter = counter\
    \ + 1\n        end\n        if counter == 1 then\n            return prime\n \
    \       end\n        prime = prime + 1\n    end\n    return nil\nend", "    local\
    \ d = 2\n    while d <= n / 2 do\n        if n % d == 0 then\n            return\
    \ d\n        end\n        d = d + 1\n    end\n    return n\nend", "    local primes\
    \ = {}\n    for i = 2, n do\n        if n % i == 0 then\n            table.insert(primes,\
    \ i)\n        end\n    end\n    return table.getn(primes)\nend", "\t-- TODO: Implement\
    \ this function!\nend", "  local factors = {}\n  -- Check for small factors, first\
    \ by primality and then by size.\n  for i = 2, n do\n    local prime = prime_factor(i)\n\
    \    if prime > 1 then\n      factors[i] = prime\n    else\n      if n < i then\n\
    \        factors[i] = n / i\n      else\n        factors[i] = i\n      end\n \
    \   end\n  end\n  -- Scan factors in reverse order as we assume larger factors\
    \ are of higher prime.\n  for i = #factors, 1, -1 do\n    local prime = prime_factor(i)\n\
    \    if prime > 1 then\n      return factors[i]\n    end\n  end\n  return 1\n\
    end", "    -- TODO: implement a more efficient primality test.\n    while n >\
    \ 1 do\n        if n % 2 == 0 then return end\n        if n % 4 == 0 then return\
    \ end\n        if n % 16 == 0 then return end\n        if n % 32 == 0 then return\
    \ end\n        if n % 64 == 0 then return end\n        -- n must be odd and not\
    \ a prime, we can get any composite factor of n.\n        n = math.floor(n/2)\n\
    \    end\n    return n\nend", "  if n < 2 then return nil end\n  if n == 1 then\
    \ return 2 end\n  if n % 2 == 0 then return n / 2 end\n  if n % 3 == 0 then return\
    \ 3 * largest_prime_factor(n / 3) end\n  local factor = 3\n  while factor <= math.sqrt(n)\
    \ do\n    if n % factor == 0 then\n      return factor\n    end\n    factor =\
    \ factor + 2\n  end\n  return nil\nend", "  if n == 1 then return n end\n  if\
    \ n % 2 == 0 then return largest_prime_factor(n/2) end\n  for i=3,math.floor(n/2),2\
    \ do\n    if n % i == 0 then return i end\n  end\nend\n</cell>\n<text>\nExercise\
    \ 4", "  -- Make n prime by dividing by all numbers less than or equal to n.\n\
    \  local function factor()\n    if n <= 1 then return 0 end\n    local m = 2\n\
    \    while m <= n do\n      if n % m == 0 then\n        return m\n      else\n\
    \        m = m * 2\n      end\n    end\n  end\n  -- Iterate n from 2 to n / 2,\
    \ and find the largest factor.\n  for i = 2, n / 2 do\n    if n % i == 0 then\n\
    \      return i\n    end\n  end\n  return n -- Didn't find any factors\nend",
  "\t-- Find largest divisor < n.\n\tlocal factors, index = 1, 1\n\twhile factors\
    \ and index < n do\n\t\tlocal next = factors:max(2)\n\t\tlocal candidate = n /\
    \ next\n\t\tif n % candidate == 0 then\n\t\t\tn = candidate\n\t\t\tfactors = next\
    \ + 1\n\t\telse\n\t\t\tn = next\n\t\t\tfactors = factors * next + 1\n\t\tend\n\
    \t\tindex = index + 1\n\tend\n\t-- Return n + 1 (i.e. largest factor) and n itself.\n\
    \treturn n, n\nend", "    local prime = 2 -- Prime starts out as 2\n    local\
    \ largest = n -- Start out with the largest prime factor of n", "  -- Base case:\
    \ n is 1 or even. 1 has no prime factors.\n  if n <= 1 then return 2 end", " \
    \ if n > 1 then\n    for i = 2, n do\n      if n % i == 0 then\n        return\
    \ i\n      elseif n == i then\n        return nil\n      end\n    end\n  end",
  "    local max = 2\n    local x = 1\n    while n > 1 do\n        if n % x == 0 then\n\
    \            max = x\n        end\n        x = x * 2\n    end\n    return max\n\
    end", "    -- If the number is divisible by 2 or 3, then it is easy. There are\
    \ no\n    -- more factors.\n    if n % 2 == 0 or n % 3 == 0 then\n        return\
    \ nil\n    end", "  local p\n  local i\n  -- 2 is the only even prime number\n\
    \  if n == 2 then\n    return 2\n  end -- 3 is the only odd prime number\n  --\
    \ even prime numbers under 4 are all primes\n  if n % 2 == 0 then\n    for i=3,n,2\
    \ do -- 3 is the only even prime number greater than 4\n      -- test whether\
    \ the number is not prime or composite\n      if n % i == 0 then\n        return\
    \ nil\n      end\n      if i > n then return nil end\n    end -- all odd prime\
    \ numbers are primes\n  end -- all even prime numbers are primes\n  -- start at\
    \ 3 and see if any factor is found\n  for i=3,n,2 do\n    -- test whether the\
    \ number is not prime or composite\n    if n % i == 0 then\n      p = i\n    \
    \  break\n    end\n    if i > n then return nil end\n  end -- all odd prime numbers\
    \ are primes\n  if p == nil then\n    return nil\n  end\n  -- remove prime factors\
    \ and return largest prime\n  -- >>> largest_prime_factor(22)\n  -- 5\n  -- >>>\
    \ largest_prime_factor(391)\n  -- 23\n  return n / p\nend", "  -- Sieve of Eratosthenes\
    \ for primes\n  -- https://rosettacode.org/wiki/Sieve_of_Eratosthenes#Lua\n  --\
    \ https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Implementation\n  -- The\
    \ numbers in the list are assumed to be\n  -- odd. All even numbers are assumed\
    \ to be primes\n  local function sieve(n,p)\n    local dp = math.floor(math.log(n,p))\n\
    \    local tbl = { }\n    for i = 3, n+1, dp do\n      if n % i == 0 then\n  \
    \      tbl[i] = nil\n      end\n    end\n    return tbl\n  end", "    -- If n\
    \ is prime return the prime factor.\n    if primes{n} then return n end\n    --\
    \ Set max to smallest integer not greater than n.\n    local max = math.floor(n/2)\
    \ + 1\n    -- Find the largest prime factor of n.\n    local factor\n    while\
    \ factor < max do\n        if primes{max} then break end\n        max = max -\
    \ 1\n    end\n    -- Return largest prime factor.\n    return factor\nend", " \
    \ -- The largest prime factor is twice the greatest prime factor.\n  -- Also known\
    \ as Philip's Algorithm or Fermat's little theorem.\n  -- http://math.berkeley.edu/~dhouse/math302/node6.html",
  "  if n == 1 then\n    return n\n  end\n  if n <= 1 then\n    return nil\n  end\n\
    \  local d\n  for d = 2, n do -- loop until factor > sqrt(n)\n    if n % d ==\
    \ 0 then -- if n % d == 0\n      n = n / d -- then n /= d\n      if n == 1 then\
    \ -- if n == 1, then d == n so return d and keep going\n        return d\n   \
    \   else\n        return nil -- if n > 1, return nil and stop searching further\n\
    \      end\n    end\n  end\nend", "\t-- Special case: 1 is trivial.\n\tif n ==\
    \ 1 then\n\t\treturn n\n\tend", "  -- http://en.wikipedia.org/wiki/Primality_test\n\
    \  -- http://www.primitiv.eu/PP/00/00/00/01/01/PP-00-00-00-01-01.pdf\n  -- http://www.dsprelated.com/showmessage/165286/The-Prime-Number-Algorithm\n\
    \  -- http://primes.utm.edu/notes/faq.html\n  -- http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.39.5099&rep=rep1&type=pdf\n\
    \  -- http://math.berkeley.edu/~mpa/SHEBREW/schoolbook/chapter3.html\n  if n <\
    \ 2 then return n end\n  -- Check even and odd numbers\n  if mod(n, 2) == 0 then\
    \ return n end\n  -- Check up to sqrt(n)\n  for i = 2, sqrt(n) do\n    -- If no\
    \ prime factors, return n\n    if n % i == 0 then\n      return n\n    end\n \
    \   -- If prime, return largest factor of n that is prime\n    if isPrime(i) then\n\
    \      return i\n    end\n  end\n  -- If n is larger than what could be a factor\
    \ (the largest factor would be 1), return n\n  return n\nend", "    local d =\
    \ 0\n    local i = 1\n    repeat\n        d, i = d, i/2\n        if n % d == 0\
    \ then\n            break\n        end\n    until i > n\n    return d\nend", " \
    \   local lfp = 1\n    for i = 2, n do\n        if n % i == 0 then\n         \
    \   lfp = i\n        end\n    end\n    return lfp\nend", "  -- http://oeis.org/A005381\n\
    \  -- http://oeis.org/A005382\n  -- http://oeis.org/A005383\n  -- http://oeis.org/A005384\n\
    \  -- http://oeis.org/A005385\n  -- http://oeis.org/A005386\n  -- http://oeis.org/A005387\n\
    \  -- http://oeis.org/A005388\n  -- http://oeis.org/A005389\n  -- http://oeis.org/A005390\n\
    \  -- http://oeis.org/A005391\n  -- http://oeis.org/A005392\n  -- http://oeis.org/A005393\n\
    \  -- http://oeis.org/A005394\n  -- http://oeis.org/A005395\n  -- http://oeis.org/A005396\n\
    \  -- http://oeis.org/A005397\n  -- http://oeis.org/A005398\n  -- http://oeis.org/A005399",
  "  local limit = 2\n  while limit*limit <= n do\n    if n % limit == 0 then\n  \
    \    n = n / limit\n      return limit\n    end\n    limit = limit + 1\n  end\n\
    \  return n\nend", "  -- Sieve of Eratosthenes.\n  --\n  -- The prime factors\
    \ of n are all factors of the number 2*n + 1\n  -- (excluding n). For example,\
    \ the prime factors of 220 are 2, 7, and 7.\n  --\n  -- The sieve is lazy in the\
    \ sense that it only considers divisors up\n  -- to, but not including, the square\
    \ root of n. It only operates as long as\n  -- it is asked to as n grows (making\
    \ sieving very very fast). Thus it can\n  -- be used to find the largest prime\
    \ factor of a number even if this is\n  -- extremely slow.\n  --\n  -- This is\
    \ handy if you're using it to find the largest factor of a large\n  -- number\
    \ while making very long calculations (for instance when finding\n  -- primes).\n\
    \  --\n  -- The sieve is easy to modify if you want it to operate on floating\n\
    \  -- point numbers. Just change the calls to sieve and call it like this\n  --\n\
    \  --     n = math.floor(math.log(n)/math.log(2.0))\n  --\n  -- Then pass n to\
    \ sieve for it to operate correctly.\n  --\n  -- This sieve is pretty fast because\
    \ it's really just a trial division that\n  -- stops when it divides two numbers.\
    \ You can modify the division to use\n  -- floats if you want.\n  --\n  -- It's\
    \ also very interesting to note that 2 is a prime because it has two\n  -- prime\
    \ factors, one being 2 and the other being 2+1. We can find these\n  -- factors\
    \ by sieving until we find one that divides n evenly.\n  --\n  -- This is faster\
    \ than the sieve of Erathostenes which makes a single\n  -- pass through all of\
    \ the numbers. If you need this sieve of Erathostenes\n  -- in many places then\
    \ it's worth considering.\n  --\n  -- For smaller numbers, it is faster to simply\
    \ try to find the largest factor\n  -- of the number. There are faster ways of\
    \ finding the largest factor in\n  -- -- increasing order of efficiency, but this\
    \ algorithm has complexity in\n  -- O(sqrt(n)) which is better than the sieve\
    \ of Erathostenes.\n  --\n  -- >>> largest_prime_factor(29)\n  -- 29\n  -- >>>\
    \ largest_prime_factor(2048)\n  -- 2\n  -- >>> largest_prime_factor(13123)\n \
    \ -- 1312", "    local function loop(i1,i2)\n        if i2 > n then return 1 end\n\
    \        if i1 < i2 then\n            local r = 1\n            repeat\n      \
    \          r = r * i1\n                i1 = i2 / i1\n                i2 = r\n\
    \            until (i1 == 1)\n        end\n        return i1\n    end", "    local\
    \ div, mod\n    local max_div = 1\n    local max_mod = 1\n    for div = 2, n do\n\
    \        mod = n % div\n        if mod == 0 then return div end\n        if mod\
    \ > max_mod then max_div = div end\n        max_mod = mod\n    end\n    return\
    \ max_div\nend", "    if n < 2 then return 1 end\n    for i = 2, n - 1 do\n  \
    \      if n % i == 0 then\n            return i\n        end\n    end\n    return\
    \ n\nend", "  assert(n > 1)\n  assert(not primep(n))\n  local max_factor = 1\n\
    \  while n > 1 do\n    local factor = 2\n    while factor * factor <= n do\n \
    \     if n % factor == 0 then\n        return max_factor\n      end\n      factor\
    \ = factor + 1\n    end\n    max_factor = max_factor * 2\n    n = n / max_factor\n\
    \  end\n  return max_factor\nend", "  -- Sieve of Eratosthenes -- see Wikipedia\n\
    \  local max_factor = 1\n  -- The prime factors of n are those that divide evenly\
    \ into n.\n  local primes = {}\n  -- i is the largest prime factor of n\n  for\
    \ i = 2, n do\n    -- Test if i is a prime number\n    if n % i == 0 then\n  \
    \    -- If n is not a prime, test if it is prime\n      if n ~= i then\n     \
    \   -- If n is prime, test whether it is larger than i\n        if n % i == 0\
    \ then\n          -- If i is a prime factor, test whether it is larger than i.\n\
    \          -- If not, i is the largest prime factor of n\n          if i > i then\n\
    \            max_factor = i\n          end\n        end\n      end\n    end\n\
    \    primes[i] = i\n  end\n  return max_factor\nend", "  if n < 2 then\n    return\
    \ nil\n  end\n  -- Make sure n is a prime by checking for factors of 2, 3, 5 and\
    \ 7.\n  local function is_factor(n, factor)\n    if n < factor then\n      return\
    \ false\n    end\n    for i = 2, n / factor do\n      if n % i == 0 then\n   \
    \     return false\n      end\n    end\n    return true\n  end", "  local divisors\
    \ = {}\n  local d", "  -- Factor n such that n is greater than or equal to one\
    \ and less than or equal to n.\n  -- Also known as \"ceiling integer factorization\"\
    .\n  -- Adapted from code by Mike Koratnikov:\n  -- http://www.robertwray.co.uk/2012/01/17/the-mysteries-of-ceiling-integers/\n\
    \  -- http://robertwarren.org/2012/01/13/the-mysteries-of-ceiling-integers/\n\
    \  -- http://robertwarren.org/2012/01/28/the-mysteries-of-ceiling-integers/\n\
    \  -- http://robertwarren.org/2012/01/17/the-mysteries-of-ceiling-integers/",
  "  -- Start with n, and continue factoring by n until a factor is found that is\
    \ a prime or reaches n-1.\n  -- The only prime factors greater than sqrt(n) are\
    \ 1 and n-1 (obviously).\n  local factor = 1\n  local prime = 1\n  while factor\
    \ < math.sqrt(n) and prime ~= n do\n    factor = factor * prime\n    prime = math.floor((factor\
    \ + 0.5) / factor)\n  end\n  return prime > n and factor or nil\nend", "    local\
    \ factors = {}\n    for i=2,n do\n        if n % i == 0 then\n            table.insert(factors,\
    \ i)\n            n = n / i\n        end\n    end\n    table.sort(factors)\n \
    \   if n == 1 then\n        return factors[1]\n    else\n        return factors[#factors]\n\
    \    end\nend", "  -- Test the obvious cases.\n  if n < 2 then return 2 end\n\
    \  if n % 2 == 0 then return 2 end\n  if n % 3 == 0 then return 3 end\n  if n\
    \ % 5 == 0 then return 5 end\n  if n % 7 == 0 then return 7 end", "  if n < 2\
    \ then return 1 end\n  local f = 1\n  for i = 2, n do\n    while n % i == 0 do\n\
    \      f = i\n      n = n / i\n    end\n  end\n  return f\nend", "    local factors,\
    \ primes = prime_factor_table(n), {}\n    for i = 1, n do\n        local f = factors[i]\n\
    \        if f > n then\n            break\n        end\n        if f == 1 then\n\
    \            primes[#primes+1] = i\n        end\n    end\n    local max_primes\
    \ = #primes\n    return n, {max_primes = max_primes, primes = primes}\nend", " \
    \   local divisor = 1\n    while n > 1 do\n        if n % divisor == 0 then\n\
    \            divisor = divisor * 2\n        else\n            n = n / divisor\n\
    \        end\n    end\n    return divisor\nend", "  -- Initialize max prime factor\
    \ to n\n  local max_factor = n\n  -- Iterate from 2 to n / 2 using only odd numbers\n\
    \  for i = 2, n / 2 do\n    -- If the current number is even, divide n by it\n\
    \    if n % 2 == 0 then\n      n = n / 2\n    else\n      -- If the current number\
    \ is odd, multiply n by all odd numbers\n      for j = 3, 1, -1 do\n        --\
    \ Skip even numbers\n        if j % 2 == 0 then\n          n = n * j\n       \
    \   -- If n is larger than the largest prime factor so far, update it\n      \
    \    if n > max_factor then\n            max_factor = n\n          end\n     \
    \     break\n        end\n      end\n    end\n  end\n  return max_factor\nend",
  "\t-- Base case: n is 1 or is even.\n\tif n == 1 or n % 2 == 0 then\n\t\treturn\
    \ n\n\tend", "    local is_prime = {}\n    for i=2,math.floor(n/2) do\n      \
    \  if is_prime[i]==1 then\n            is_prime[i]=false\n        elseif i%n==0\
    \ then\n            return i\n        end\n    end\nend", "  local factors = {}\n\
    \  for i = 2, n do\n    factors[i] = 1\n    while i * i ~= n do\n      factors[i]\
    \ = i * i -- factoring loop\n    end\n    -- TODO: test if i divides n\n  end\n\
    \  for i = 2, n do\n    if i ~= factors[i] then -- if i does not divide n, then\
    \ i is larger than our prime factor\n      return i\n    end\n  end\n  return\
    \ n -- n is prime, return it\nend", "  -- If n is prime then its prime factors\
    \ are 1 and n\n  -- -- so return 1 here instead\n  if prime_factor(n) == n then\n\
    \    return 1\n  end", "  if n <= 2 then\n    return 1\n  elseif n % 2 == 0 then\n\
    \    return n\n  else\n    local i = 3\n    local d = 2\n    while i * i <= n\
    \ do\n      if n % i == 0 then\n        return i\n      end\n      d = d * i\n\
    \      i = i + 2\n    end\n    return n\n  end\nend", "  local factors = {}\n\
    \  -- First test the unconditional case\n  if n <= 1 then\n    return 1\n  end\n\
    \  for i = 2, n do\n    local j = 2\n    local prime = true\n    while prime and\
    \ j <= i do\n      prime = n % j == 0\n      j = j + 1\n    end\n    if prime\
    \ then\n      table.insert(factors, i)\n    end\n  end\n  -- Now find the largest\
    \ prime factor of n\n  local largest_prime_factor = 1\n  for i = #factors, 1,\
    \ -1 do\n    largest_prime_factor = math.max(largest_prime_factor, factors[i])\n\
    \  end\n  return largest_prime_factor\nend", "    local p = 1\n    while true\
    \ do\n        if n % p == 0 then\n            n = n / p\n        else\n      \
    \      p = p + 1\n        end\n        if p * p > n then\n            return p\n\
    \        end\n    end\nend", "  -- If the number is small then there is only one\
    \ prime factor.\n  -- If n is divisible by 3 then there is no factor.\n  if n\
    \ < 2 then return 1 end\n  -- The only factor that divide n will be 3\n  if n\
    \ % 3 == 0 then return n end\n  -- Check if n is divisible by any prime divisor\
    \ of 3.\n  local prime = 3\n  local i = 2\n  while prime % 3 ~= 0 do\n    while\
    \ i * prime <= n do\n      if n % i == 0 then\n        return nil\n      end\n\
    \      i = i * 2\n    end\n    prime = prime + 2\n  end\n  -- If n is prime then\
    \ return the smallest prime divisor that is greater than n.\n  local factor =\
    \ 3\n  while n % factor == 0 do\n    factor = factor * 3\n  end\n  return factor\n\
    end", "  -- https://en.wikipedia.org/wiki/Prime_number#Maximum_prime_divisors\n\
    \  if n < 2 then\n    return 1\n  end\n  local i = 1\n  while i * i <= n do\n\
    \    if n % i == 0 then\n      local div = i / i\n      i = i + 1\n      while\
    \ i <= n do\n        -- if n / i == i then it's prime\n        if n % i == 0 then\n\
    \          n = n / i\n          i = i + 1\n          break\n        else\n   \
    \       i = i + 1\n        end\n      end\n      -- if i * i > n then it's prime\n\
    \      if i * i > n then\n        return i\n      end\n    end\n    i = i + 1\n\
    \  end\n  return n\nend", "  local largest_prime_factor = 1\n  local i = 1\n \
    \ while i * i <= n do\n    local factor\n    factor = n / i\n    if factor > largest_prime_factor\
    \ then\n      largest_prime_factor = factor\n    end\n    i = i + 1\n  end\n \
    \ return largest_prime_factor\nend", "    -- Base cases\n    if n < 2 then\n \
    \       return nil\n    end\n    if n == 1 then\n        return 2\n    end\n \
    \   -- Check if n is a prime\n    for _, p in ipairs(prime_factors) do\n     \
    \   if n ~= p * p then\n            return nil\n        end\n    end\n    -- n\
    \ > 1\n    local m = n / 2\n    local largest_p = prime_factors[1]\n    for _,\
    \ p in ipairs(prime_factors) do\n        if n % p == 0 then\n            m = n\
    \ / p\n            largest_p = p\n        end\n    end\n    return m and largest_p\
    \ and p * m or nil\nend\n</code>\n<|/ a dscore=2 tags=algorithm,primes,lua |>\n\
    <| a dscore=2 tags=algorithm,primes,lua |>\nTo get the nth prime just loop over\
    \ them and stop when n % i == 0 for all i less than n:\n<code>", "  -- https://rosettacode.org/wiki/Largest-prime_factor#Python\n\
    \  -- Python implementation:\n  --\n  --   import primes\n  --   for p in primes.primes(n):\n\
    \  --     if n % p == 0: return p\n  --\n  -- Reference:\n  --\n  --   http://www.math.utexas.edu/users/EWD/ewd02xx/EWD215.HTM\n\
    \  --\n  -- Reference:\n  --\n  --   http://stackoverflow.com/questions/137657/\n\
    \  --   how-to-determine-if-a-number-is-a-prime-number-in-python", "\t-- https://en.wikipedia.org/wiki/Divisor_(number)#Limits\n\
    \t-- We use the Euclidean algorithm.\n\t-- The algorithm works for any positive\
    \ integer\n\tif n % 2 == 0 then\n\t\treturn 2\n\tend", "  -- https://stackoverflow.com/a/307699/13113491\n\
    \  -- https://stackoverflow.com/questions/3076838/algorithm-to-find-the-largest-factor-of-n\n\
    \  -- https://www.geeksforgeeks.org/largest-prime-factor-number/\n  -- https://www.geeksforgeeks.org/find-the-number-of-largest-prime-factors-in-a-given-number/\n\
    \  -- https://www.geeksforgeeks.org/python-program-to-find-largest-prime-factor/\n\
    \  -- https://www.geeksforgeeks.org/largest-prime-factor-program-in-python/\n\
    \  -- https://www.geeksforgeeks.org/python-program-for-factorization/\n  -- https://stackoverflow.com/questions/3076838/algorithm-to-find-the-largest-factor-of-n\n\
    \  -- https://www.geeksforgeeks.org/largest-prime-factor-number/", "  local factor\
    \ = 1\n  while n > 1 and n ~= 1 do\n    if n % 2 == 0 then\n      n = n / 2\n\
    \      factor = factor * 2\n    end\n    if n % 3 == 0 then\n      n = n / 3\n\
    \      factor = factor * 3\n    end\n    if n % 5 == 0 then\n      n = n / 5\n\
    \      factor = factor * 5\n    end\n    if n % 7 == 0 then\n      n = n / 7\n\
    \      factor = factor * 7\n    end\n  end\n  if n ~= 1 then\n    factor = factor\
    \ * n\n  end\n  return factor\nend", "  if n == 2 then\n    return 1\n  elseif\
    \ n % 2 == 0 then\n    return 2\n  elseif n % 3 == 0 then\n    return 3\n  elseif\
    \ n % 5 == 0 then\n    return 5\n  elseif n % 7 == 0 then\n    return 7\n  elseif\
    \ n % 11 == 0 then\n    return 11\n  elseif n % 13 == 0 then\n    return 13\n\
    \  elseif n % 17 == 0 then\n    return 17\n  elseif n % 19 == 0 then\n    return\
    \ 19\n  elseif n % 23 == 0 then\n    return 23\n  elseif n % 29 == 0 then\n  \
    \  return 29\n  elseif n % 31 == 0 then\n    return 31\n  else\n    return primes_small[n]\
    \ or largest_prime_factor(n / primes_small[n])\n  end\nend", "  -- Base case\n\
    \  if(n==1) then return 1 end", "  -- https://en.wikipedia.org/wiki/Prime_number_theory#Algorithms\n\
    \  -- https://primes.utm.edu/notes/faq/smallest_primes.html\n  -- http://www.ericdickson.ca/weblog/uploads/2009/08/smallestPrimeSieve-EricDickson.pdf\n\
    \  -- https://en.wikipedia.org/wiki/Miller-Rabin_primality_test", "  if n == 1\
    \ then\n    return 1\n  else\n    local factor = 2\n    while factor * factor\
    \ <= n do\n      if n % factor == 0 then\n        return factor\n      else\n\
    \        factor = factor + 1\n      end\n    end\n    return n\n  end\nend", " \
    \ -- Base case:\n  if n==1 then return 1 end", "    local lf = nil\n    for i\
    \ = 2, n do\n        if n % i == 0 then\n            if not lf or lf > i then\n\
    \                lf = i\n            end\n        end\n    end\n    return lf\n\
    end", "\t-- The largest prime factor of a number is the largest divisor of the\
    \ number.\n\t-- If n is a prime, then it's prime factor is 1. Otherwise, it's\
    \ composite factor is the\n\t-- largest number that divides n. If n is a composite\
    \ number, then it has no prime factor.\n\t-- A prime factor is a factor that only\
    \ divides integers. A composite factor is a factor\n\t-- that also divides positive\
    \ integers. If n is even, then its prime factor is two.\n\t-- If n is odd, then\
    \ it's prime factor is 1.\n\t-- This solution does not require a division operation,\
    \ so it's optimal.", "\t-- Special cases.\n\tif n == 1 or n == 2 then\n\t\treturn\
    \ 1\n\tend\n\tif n % 2 == 0 then\n\t\treturn nil\n\tend\n\t-- Set n to the smallest\
    \ power of two that divides n.\n\tn = 2\n\twhile n <= math.sqrt(n) do\n\t\tif\
    \ n % 2 == 0 then\n\t\t\treturn nil\n\t\telse\n\t\t\tn = n + 1\n\t\tend\n\tend\n\
    \t-- Now n is a power of two and n >= 2\n\tn = 2\n\twhile n <= math.sqrt(n) do\n\
    \t\t-- If n is prime, return its factors.\n\t\tif isPrime(n) then\n\t\t\treturn\
    \ factors(n)\n\t\telse\n\t\t\tn = n + 1\n\t\tend\n\tend\n\treturn nil\nend", "\t\
    -- n is guaranteed to be an integer greater than 1.\n\t-- The smallest factor\
    \ is 1 itself.\n\tif n < 2 then\n\t\t-- 2 is not a prime factor of any number.\n\
    \t\t-- However, it is only 1 itself that is not a prime factor.\n\t\treturn 1\n\
    \tend", "    if n == 1 then\n        return 1\n    end", "    -- Largest prime\
    \ factor for numbers <= n is equal to their gcd + 1\n    if n < 2 then return\
    \ n end\n    if n == 2 then return 1 end\n    if n % 2 == 0 then return n end\n\
    \    local gcd = math.gcd(n, 2)\n    return gcd + largest_prime_factor(n / gcd)\n\
    end", "  if n < 2 then return nil end\n  local i, s, t = 0, n - 1, 2\n  while\
    \ s <= t do\n    while i * t < n and (n % i) == 0 do\n      i = i + 1\n      if\
    \ i > t then return i end\n    end\n    s = s + 1\n    t = t + t + 1\n  end\n\
    \  return nil\nend", "  if n < 2 then\n    -- n is a prime\n    return 1\n  elseif\
    \ n < 3 then\n    -- n is a composite number 3n+1 or larger\n    return 3\n  end",
  "    local n2 = n % 2\n    local n3 = n % 3\n    local n5 = n % 5\n    local n7\
    \ = n % 7\n    local n11 = n % 11\n    local n13 = n % 13", "  -- We need to take\
    \ care of a few special cases because this algorithm is very slow\n  -- >>> largest_prime_factor(1)\n\
    \  -- 1\n  -- >>> largest_prime_factor(2)\n  -- 2\n  -- >>> largest_prime_factor(127)\n\
    \  -- 7\n  -- >>> largest_prime_factor(1728)\n  -- 5\n  if n == 2 then\n    return\
    \ 2\n  elseif n == 1 then\n    return 1\n  elseif n < 2 or n % 2 == 1 then\n \
    \   return nil\n  elseif n % 4 == 1 then\n    return 3\n  else\n    -- The algorithm\
    \ is not correct but it is fast enough for our needs.\n    -- A faster algorithm\
    \ could be implemented using trial division.\n    -- I chose to return the largest\
    \ prime factor which can be evenly divided by n\n    -- because that gives us\
    \ the most potential benefit.\n    -- The algorithm should give the largest prime\
    \ factor of n which is > than or equal to\n    -- sqrt(n) and is at least 2.",
  "    assert(n >= 1)\n    local max = 0\n    for i = 2, n do\n        if n % i ==\
    \ 0 then\n            max = i\n        end\n    end\n    return max\nend", " \
    \ -- https://rosettacode.org/wiki/Largest-prime_factor#Lua\n  n = math.abs(n)\n\
    \  local i\n  if n == 0 then return 0 end\n  -- Test n-1 for divisibility.\n \
    \ for i = 2, n do\n    if n % i == 0 then return i end\n  end\n  -- n has a prime\
    \ factor.\n  -- The smallest prime factor greater than n/2 is n-1.\n  -- The largest\
    \ prime factor less than n/2 is n-2.\n  -- If n is perfect square, primes greater\
    \ than n are not possible.\n  for i = n-1, n/2, -1 do\n    if n % i == 0 then\
    \ return i end\n  end\nend", "    local primes, i = {}, 1\n    while i <= n do\n\
    \        if n % i == 0 then\n            table.insert(primes, i)\n           \
    \ n = n / i\n        end\n        i = i + 1\n    end\n    return primes[#primes]\
    \ or n\nend", "  if n == 1 then\n    return 1\n  end", '  if n < 2 then return
    0 end', "   if n == 0 then\n      return nil\n   end\n   if n <= 1 then\n    \
    \  return 1\n   end\n   if n <= 3 then\n      return n\n   end\n   if n % 2 ==\
    \ 0 then\n      return largest_prime_factor(n / 2)\n   end\n   -- We know that\
    \ n >= 2\n   local max_factor = 1\n   for i=3, n/2, 1 do\n      if n % i == 0\
    \ then\n         if max_factor < i then\n            max_factor = i\n        \
    \ end\n         n = n / i\n      end\n   end\n   return max_factor\nend", "  assert(n\
    \ > 1)\n  -- Search for prime factors.\n  for i = 2, n do\n    if n % i == 0 then\n\
    \      return i\n    end\n  end\n  return n\nend", "    local factors = prime_factors(n)\n\
    \    local largest = 0\n    local largestFactor\n    for i=1,#factors do\n   \
    \     largestFactor = factors[i]\n        if largest < largestFactor then\n  \
    \          largest = largestFactor\n        end\n    end\n    return largest\n\
    end", "\t-- Start with a divisor of 2 and check up to\n\t-- n / 2. Since we know\
    \ that n is prime, then\n\t-- we will have found our factor\n\tlocal divisor =\
    \ 2", "  local result = 1\n  -- TODO: implement a more efficient algorithm\n \
    \ for i = 2, n do\n    while n % i == 0 do\n      result = i\n      n = n / i\n\
    \    end\n  end\n  return result\nend", "   if n < 2 then return nil end\n   if\
    \ n == 2 then return 1 end\n   if n%2 == 0 then return 2 end\n   if n%3 ~= 0 then\
    \ return 3 end\n   local i = 3\n   while i*i <= n do\n      if n%i == 0 then\n\
    \         return i\n      end\n      i = i*2\n   end\n   return n\nend", "  --\
    \ Largest prime factor is the largest prime factor of n or n itself.\n  if n <\
    \ 2 then return n end", "  local factor = 2\n  while n > 1 do\n    if n % factor\
    \ == 0 then\n      return factor\n    end\n    factor = factor * 2\n    n = n\
    \ / factor\n  end\n  return factor\nend", "  if n <= 2 then\n    return 1\n  elseif\
    \ n <= 4 and n % 2 == 0 then\n    return 2\n  elseif n <= 8 and n % 4 == 0 then\n\
    \    return 3\n  elseif n%2 == 0 and n % 4 == 0 then\n    return 4\n  elseif n%2\
    \ == 0 and n % 8 == 0 then\n    return 5\n  elseif n%4 == 0 and n % 8 == 0 then\n\
    \    return 6\n  elseif n%8 == 0 and n % 8 == 0 then\n    return 7\n  else\n \
    \   local factor = 2\n    local counter = 1\n    while n > factor do\n      n\
    \ = n / factor\n      counter += 1\n      if n > factor then\n        break\n\
    \      end\n      factor = factor * counter\n    end\n    return factor\n  end\n\
    end", "  -- Even number. Find the largest divisor.\n  if n % 2 == 0 then\n   \
    \ if n % 4 == 0 then\n      if n % 8 == 0 then\n        return 3\n      else\n\
    \        return 2\n      end\n    else\n      return 2\n    end\n  else\n    --\
    \ Odd number. Test all odd divisors.\n    for i = 3, sqrtn + 1, 2 do\n      if\
    \ n % i == 0 then\n        return i\n      end\n    end\n  end", "   local m =\
    \ math.floor(math.sqrt(n))\n   if m ~= math.floor(n/m) then\n      return nil\n\
    \   end\n   local root = math.sqrt(n)\n   if root == 1 then\n      return nil\n\
    \   end\n   local t = 1\n   local q = math.floor(n/2)\n   while q > 0 and root\
    \ % q == 0 do\n      q = q - 1\n      t = t + 1\n   end\n   return t\nend", " \
    \ -- Make n positive.\n  if n <= 0 then return 0 end\n  -- Trial division will\
    \ sometimes give a wrong result if n is very small.\n  -- For example, math.lcm(5,\
    \ 2) gives 6, but the correct answer is 5.\n  -- Use a slightly higher threshold\
    \ for trial division here.\n  if n % 2 == 0 then return n / 2 end\n  -- Check\
    \ only odd numbers.\n  if n % 3 == 0 then return n / 3 end\n  -- Check only even\
    \ numbers.\n  if n % 5 == 0 then return n / 5 end\n  -- Factor out powers of two.\n\
    \  if n % 8 == 0 then\n    local tmp = n + n / 8\n    -- Check only odd numbers.\n\
    \    if tmp % 2 == 0 then return tmp / 2 end\n    return tmp\n  end\n  -- Factor\
    \ out powers of three.\n  if n % 11 == 0 then\n    local tmp = n + n / 11\n  \
    \  -- Check only odd numbers.\n    if tmp % 3 == 0 then return tmp / 3 end\n \
    \   return tmp\n  end\n  -- Factor out powers of five.\n  if n % 13 == 0 then\n\
    \    local tmp = n + n / 13\n    -- Check only odd numbers.\n    if tmp % 5 ==\
    \ 0 then return tmp / 5 end\n    return tmp\n  end\n  -- Factor out powers of\
    \ seven.\n  if n % 17 == 0 then\n    local tmp = n + n / 17\n    -- Check only\
    \ odd numbers.\n    if tmp % 7 == 0 then return tmp / 7 end\n    return tmp\n\
    \  end\n  -- Factor out powers of 9.\n  if n % 19 == 0 then\n    local tmp = n\
    \ + n / 19\n    -- Check only odd numbers.\n    if tmp % 9 == 0 then return tmp\
    \ / 9 end\n    return tmp\n  end\n  -- Factor out powers of twenty.\n  local tmp\
    \ = n + n / 21\n  if tmp % 23 == 0 then return tmp / 23 end\n  return tmp\nend",
  "\t-- http://mathforum.org/dr.math/faq/faq.numbers.html#faq.numbers.sieve -- Sieve\
    \ of Eratosthenes\n\tlocal function primes(n)\n\t\tlocal p = 2\n\t\tlocal q =\
    \ 3\n\t\twhile p < n do\n\t\t\twhile q * p < n do\n\t\t\t\tlocal x = n / q\n\t\
    \t\t\tn = x % q\n\t\t\t\tq = p\n\t\t\t\tp = p + x\n\t\t\tend\n\t\t\tp = p + 2\n\
    \t\t\tq = q * 3\n\t\tend\n\t\treturn p\n\tend", "\t-- We only need to test up\
    \ to half the number to get the largest prime factor\n\t-- We stop once we reach\
    \ the square root of n\n\tlocal m = prime_factorization(n)\n\tlocal i = 1\n\t\
    while i * i <= n do\n\t\tif n % i == 0 then\n\t\t\tbreak\n\t\tend\n\t\ti = i +\
    \ 1\n\tend\n\tif i == n then\n\t\treturn n\n\tend\n\ti = 2\n\twhile i * i <= n\
    \ do\n\t\tif n % i == 0 then\n\t\t\tbreak\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn\
    \ i\nend", "  -- Start with an initial prime factorization of n.\n  local m =\
    \ n\n  -- Iterate until an explicit factor of n has been found.\n  -- No need\
    \ to check for divisors of n or n.\n  while m > 1 do\n    -- Divide n by each\
    \ prime factor that hasn't been found\n    -- yet.\n    local found = false\n\
    \    for i = 2, m do\n      if m % i == 0 then\n        found = true\n       \
    \ m = i\n        break\n      end\n    end\n    -- If n's prime factor hasn't\
    \ been found, n isn't prime.\n    if not found then\n      return nil\n    end\n\
    \  end\n  return m\nend", "  local result = 1\n  -- Check if n is prime.\n  if\
    \ n == 1 then return 1 end\n  for i = 2, n do\n    if n % i == 0 then\n      local\
    \ m = math.fmod(n, i)\n      result = max(result, m + 1) / i\n      n = math.floor(n\
    \ / i)\n    end\n  end\n  return result\nend", "    local i = 1\n    while i <=\
    \ n do\n        if n % i == 0 then\n            n = n / i\n        elseif i ==\
    \ 2 then\n            n = n + 1\n        end\n        i = i + 1\n    end\n   \
    \ return n\nend", "  -- Special case: 1 and 2 are prime factors of 2.\n  if n\
    \ == 1 or n == 2 then\n    return 2\n  end -- End of special case.\n  -- Check\
    \ for 2 first so we don't have to deal with even numbers.\n  local p2 = 2 -- Start\
    \ at 2 since 2 is the only even prime factor of 2.\n  -- Loop while p2 <= n and\
    \ we can divide n evenly.\n  while p2 < n and n % p2 == 0 do\n    p2 = p2 + 1\n\
    \  end -- End of while loop\n  -- Divide the number by p2 because we've found\
    \ a factor.\n  n = n / p2\n  -- The first p2 of n divides n. If it was evenly\
    \ divisible, return the factor of n.\n  if p2 == 2 then return n end\n  -- If\
    \ p2 > 2, then n is not prime and we can test the next prime factor.\n  -- If\
    \ n is not prime, then\n  -- p3 is a prime factor of n and n is divisible by p3.\n\
    \  -- If p2 > p3, then we only need to check p2-p3 for primality.\n  local p3\
    \ = 2 -- Start at 2 since 2 is the only even prime factor of 2.\n  -- Loop while\
    \ p3 <= n and we can divide n evenly.\n  while p3 < n and n % p3 == 0 do\n   \
    \ p3 = p3 + 1\n  end -- End of while loop\n  -- The first p3 of n divides n. If\
    \ it was evenly divisible, return the factor of n.\n  if p3 == 2 then return n\
    \ end\n  -- If p3 > 2, then n is not prime and we can test the next prime factor.\n\
    \  -- If n is not prime, then\n  -- p4 is a prime factor of n and n is divisible\
    \ by p4.\n  -- If p2 > p4, then we only need to check p2-p4 for primality.\n \
    \ local p4 = 3 -- Start at 3 since 3 is the only even prime factor of 3.\n  --\
    \ Loop while p4 <= n and we can divide n evenly.\n  while p4 < n and n % p4 ==\
    \ 0 do\n    p4 = p4 + 1\n  end -- End of while loop\n  -- The first p4 of n divides\
    \ n. If it was evenly divisible, return the factor of n.\n  if p4 == 3 then return\
    \ n end\n  -- If p4 > 3, then n is not prime and we can test the next prime factor.\n\
    \  -- If n is not prime, then\n  -- p5 is a prime factor of n and n", "  -- The\
    \ prime factors less than n are those smaller than n / i. So\n  -- we need to\
    \ factor all numbers from 2 to n / 2, which is (n/2 + 1)\n  -- The largest prime\
    \ factor is at most n/2 + 1, so we need to check\n  -- n / 2 + 1 to n. We use\
    \ a simple method because it's fast and\n  -- effective, and it conserves memory.\
    \ See\n  -- https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n  -- http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/primes.html\
    \ for\n  -- a detailed discussion of this method\n  local max_p, i = n, 2\n  while\
    \ i <= n do\n    -- prime factors are only composite numbers, so if we factor\
    \ n / i\n    -- we only need to check n / i + i. Hence, i > max_p is correct.\n\
    \    if i > max_p then\n      -- found a larger prime factor\n      max_p = i\n\
    \    end\n    -- i must be the smallest factor of the number (i = 1 in each case)\n\
    \    i = (i - 1) * (i - 1) + 1\n  end\n  return max_p\nend", "    local m = prime_factors(n)\n\
    \    local largest = tonumber(m)[1]\n    for i = 2, #m do -- Find the largest\
    \ prime factor.\n        if m[i] == largest then return i end\n        largest\
    \ = m[i]\n    end\nend", "  if n > 1 then\n    for i = 1, n do\n      if n % i\
    \ == 0 then\n        return i\n      end\n    end\n  end\n  return nil\nend",
  "  if n < 2 then\n    return nil\n  elseif n < 4 then\n    return 2\n  elseif n\
    \ > 2 then\n    for k = 2, n / 2 do\n      local i = math.floor(k / 2)\n     \
    \ if i % 2 ~= 0 and n % i == 0 then\n        return i\n      end\n    end\n  end\n\
    \  return nil\nend", "   if n == 1 then\n      return n\n   else\n      local\
    \ m = n % 2\n      if m ~= 0 then\n         n = n / 2\n         while not n %\
    \ 2 do\n            n = n / 2\n         end\n         return n\n      else\n \
    \        return largest_prime_factor(n * 3) + 1\n      end\n   end\nend", "  \
    \  local factors = {}\n    local div = 1\n    local i = 1\n    while n > 1 do\n\
    \        if n % i == 0 then\n            n = n / i\n            factors[i] = i\n\
    \            i = i + 1\n        else\n            i = i + 1\n        end\n   \
    \ end\n    for i = 2, #factors do\n        if n > factors[i] then\n          \
    \  div = i\n        end\n    end\n    return div\nend", "\t-- Make n positive\n\
    \tif n < 1 then return nil end\n\tif n == 1 then return 1 end\n\t-- Find p (the\
    \ divisor)\n\tlocal p = 2\n\twhile p * p <= n do\n\t\tif n % p == 0 then\n\t\t\
    \t-- Skip multiples of p\n\t\t\twhile n % p == 0 do\n\t\t\t\tn = n / p\n\t\t\t\
    end\n\t\telse\n\t\t\t-- Stop at p\n\t\t\tbreak\n\t\tend\n\t\tp = p + 1\n\tend\n\
    \t-- Return the highest prime factor if n was prime\n\tif n > 1 then\n\t\twhile\
    \ n >= 2 do\n\t\t\tif n % 2 == 0 then\n\t\t\t\tn = n / 2\n\t\t\telse\n\t\t\t\t\
    break\n\t\t\tend\n\t\tend\n\t\treturn n\n\tend\nend", "  if n < 2 then\n    return\
    \ nil\n  end", "  -- See \"Trial Division\" for details on why this algorithm\
    \ is faster than the general algorithm.\n  local limit = Math.sqrt(n)\n  -- The\
    \ limit should be sqrt(n) so that we can use the prime table for trial division.\n\
    \  limit = limit + 0.5\n  local limit = limit + 0.5\n  -- The last prime in the\
    \ prime table should be less than limit and larger than sqrt(limit).\n  -- The\
    \ first prime greater than sqrt(limit) should be less than limit and larger than\
    \ sqrt(limit).\n  for i = 2, limit do\n    if i % 2 == 0 then\n      if n / i\
    \ == i then\n        return i\n      end\n    else\n      if limit % i == 0 then\n\
    \        return i\n      end\n    end\n  end\nend", "  if n < 2 then\n    return\
    \ nil\n  elseif n % 2 == 0 then\n    return 2\n  elseif n % 3 == 0 then\n    return\
    \ 3\n  else\n    -- Do a binary search on the prime factors.\n    local factor\
    \ = 1\n    local index = nil\n    local max_factor = 0\n    for i = 2, n do\n\
    \      local fact = math.mod(n, i)\n      if fact > 1 then\n        index = i\n\
    \        max_factor = fact\n        break\n      else\n        factor = fact\n\
    \      end\n    end\n    if index == nil then\n      return nil\n    end\n   \
    \ return max_factor + 1\n  end\nend", "    local factors = {}\n    for i=2,n do\n\
    \        factors[i] = 1\n        for j=1,i do\n            if n % j == 0 then\n\
    \                factors[j] = factors[j] * j\n                factors[i] = factors[i]\
    \ * j\n                break\n            end\n        end\n    end\n    return\
    \ factors[n]\nend", "\t-- https://en.wikipedia.org/wiki/Largest-prime-factor\n\
    \t-- Find the largest prime factor of an odd number with at most 100 iterations\n\
    \t-- https://en.wikipedia.org/wiki/Primality_test\n\t--\n\t-- This implementation\
    \ does not assume that n > 1\n\t-- (which would have been the case for most prime\
    \ factor implementations I believe)", "  -- We only need to check until sqrt(n)\
    \ to find the largest\n  -- prime factor. Once we find it, we can check if any\
    \ smaller\n  -- factor is even.\n  -- If we find any smaller factors, then there\
    \ is still a large\n  -- prime factor to divide n with.\n  -- If we find a larger\
    \ factor, then we're done.\n  local factors = {1}\n  local found = false\n  local\
    \ root = math.sqrt(n)\n  local i = 2\n  while not found and i < root do\n    --\
    \ If the current factor is even, then it cannot be the largest\n    -- factor.\
    \ Otherwise, check if it divides n.\n    if n % i == 0 then\n      if i ~= root\
    \ then\n        found = true\n      else\n        -- Update largest prime factor.\n\
    \        factors[#factors + 1] = i\n      end\n    else\n      i = i + 1\n   \
    \ end\n  end\n  -- If we made it this far, there was not largest prime factor.\n\
    \  if i == root then\n    factors[#factors + 1] = 1\n  end\n  -- Return largest\
    \ prime factor if it is larger than n.\n  -- It could be 1 or even.\n  local largest\
    \ = nil\n  for i = #factors, 1, -1 do\n    largest = factors[i]\n    if largest\
    \ ~= n and largest % 2 == 0 then\n      return largest\n    end\n  end\n  return\
    \ largest\nend", "  local p, i = 2, n\n  while i <= math.sqrt(n) do\n    i = i\
    \ * p % n\n    p = p * 2 % n\n  end\n  return p\nend", "    local m = 1\n    while\
    \ m <= n do\n        -- Check if m divides n.\n        if n % m == 0 then\n  \
    \          -- If it divides, then m divides n as well.\n            n = n / m\n\
    \        else\n            -- If m does not divide n, then n is not a prime factor.\n\
    \            -- Increase m by 1 and continue the loop from where m left off.\n\
    \            m = m + 1\n        end\n    end\n    return n\nend", "  assert(n\
    \ > 1)\n  local i\n  for i = 2, n do\n    if n % i == 0 then\n      return i\n\
    \    end\n  end\n  return n\nend", "\t-- Sieve of Eratosthenes (to find all prime\
    \ factors of n).\n\t-- From the wikipedia pseudocode:\n\t--\tSieve of Eratosthenes\n\
    \t--\t\tFor i = 2, S[i] = 1\n\t--\t\tFor i = 2, p*p <= N\n\t--\t\t\tFor j = i,\
    \ S[j] = 0\n\t--\t\t\tFor j = i*i, S[j] = i\n\t--\t\tFor i = p*p, S[2*i] = 1,\
    \ ..., S[2*i + 1] = 1\n\t--\t\tFor i = p*p + 1 to N\n\t--\t\t\tFor j = i, S[2*j]\
    \ = 0\n\t--\t\t\tFor j = i*i, S[2*j] = 2*i, ..., S[2*j + 1] = 2*i + 1\n\t--\t\t\
    For i = 0, S[2*N] = 0", "  local is_prime, factors = 2, {}\n  for i = 2, n do\n\
    \    if is_prime == false then\n      local candidate = factors[math.floor((n\
    \ - i) / 2)]\n      if n == i*candidate then\n        factors[math.floor((n -\
    \ i) / 2)] = candidate\n      else\n        -- Don't bother testing odd numbers.\n\
    \        is_prime = true\n      end\n    elseif n % i == 0 then\n      -- Don't\
    \ bother testing odd numbers.\n      is_prime = false\n    end\n  end\n  if #factors\
    \ == 0 then\n    -- n has no prime factors.\n    return n\n  else\n    -- Choose\
    \ the larger prime factor.\n    local factor\n    for _, factor in pairs(factors)\
    \ do\n      if factor > n then\n        break\n      end\n    end\n    return\
    \ factor\n  end\nend", "    -- Prime factor of n can be found using the formula\
    \ P=sqrt(n) where P is prime:\n    -- >>> math.floor(math.sqrt(n))\n    -- 4\n\
    \    -- >>> math.floor(math.sqrt(25))\n    -- 5\n    local p = math.sqrt(n)\n\
    \    local factor = 1\n    while not p%2 do\n        p = p / 2\n        factor\
    \ = factor+1\n    end\n    return factor\nend", "    -- The largest prime factor\
    \ of n is roughly the sqrt of n, so n is prime\n    -- and is also a factor of\
    \ n squared.\n    -- The algorithm for prime factoring is slightly different from\n\
    \    -- the one in \"Programming Perl\", where a trial division is used\n    --\
    \ instead.", '  local factors, i, factor', "\tassert(n >= 1, \"n must be >= 1\"\
    )\n\t\n\t-- This number would be a divisor of the next smallest prime, so it\n\
    \t-- is not necessarily the largest.\n\tlocal limit = (n - 1) % 2\n\t\n\t-- Try\
    \ a prime factor of n and hope to find one that is > 1.\n\t-- If there isn't,\
    \ then return n.\n\tlocal i = 1\n\tlocal x = 1\n\tlocal found = false\n\t\n\t\
    while i <= limit and not found do\n\t\tif isprime(i) then\n\t\t\t-- The isprime(i)\
    \ test can sometimes return a false positive.\n\t\t\t-- I believe it is caused\
    \ by certain composite numbers being found\n\t\t\t-- in consecutive runs of isprime(i)\
    \ tests. For example, if\n\t\t\t-- isprime(9) returns false, isprime(26) returns\
    \ true. This\n\t\t\t-- causes the isprime(i) test to think that n is composite.\n\
    \t\t\t-- This problem has been tested in Python 2.6.5 and Python 2.6.6.\n\t\t\t\
    -- If this bug happens to you, try rerunning with Python 2.6.6.\n\t\t\t-- If that\
    \ works, please let me know and I'll update the code to\n\t\t\t-- prevent the\
    \ bug happening again in the future.\n\t\t\tfound = true\n\t\telse\n\t\t\ti =\
    \ i + 2\n\t\tend\n\tend\n\t\n\tif i <= limit then\n\t\treturn i\n\telse\n\t\t\
    return n\n\tend\nend", "  if n == 1 then\n    return 1\n  end\n  local result\
    \ = 2\n  while n > 1 do\n    if n % result == 0 then\n      result = result\n\
    \    else\n      result = result + 1\n    end\n    n, n = div(n, result)\n  end\n\
    \  return result\nend", "    assert(n > 1)\n    local x = math.floor(math.sqrt(n))\n\
    \    while x > 1 do\n        if n % x == 0 then\n            return x\n      \
    \  end\n        x = x - 1\n    end\n    return x\nend", '  if n < 2 then return
    nil end', "  -- Base case\n  if n == 2 then\n    return 2\n  -- Sieve of Erastothenes\
    \ (https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\n  -- Iterate until 2p+1\n\
    \  elseif n < 2 then\n    return nil\n  -- Iterate for odd numbers\n  elseif n\
    \ % 2 == 1 then\n    return largest_prime_factor(n/2)\n  -- Iterate for even numbers,\
    \ skip 2\n  else\n    local p = 3\n    local q = (math.sqrt(2 * n + 1))/2\n  \
    \  while p <= q do\n      -- If p*p is greater than n\n      if p * p > n then\n\
    \        return nil\n      -- If it is prime\n      elseif p == n then\n     \
    \   return p\n      -- If it is not prime, increment p and decrement q\n     \
    \ else\n        p = p + 2\n        q = (math.sqrt(2 * p + 1))/2\n      end\n \
    \   end\n  end\nend", "  -- n is an odd integer\n  if n > 1 and (n % 2 == 0) then\n\
    \    -- return largest factor of n\n    return math.ceil(math.sqrt(math.floor(n)))\n\
    \  elseif n == 1 then\n    -- if n is prime return the smallest factor of n\n\
    \    return 2\n  elseif n < 1 then\n    -- if n is negative return nil\n    return\
    \ nil\n  end", "    local num_factors = 1\n    local factor = 1", "  if n > 2\
    \ then\n    for i = 2, n do\n      local factor = 1\n      while i * factor <=\
    \ n do\n        factor = factor * i\n      end\n      if n == factor then\n  \
    \      return factor\n      else\n        n = n / factor\n      end\n    end\n\
    \  end\n  return n\nend", "\t-- Set up variables. Assume n is a composite.\n\t\
    local i = 2\n\tlocal k = 1\n\tlocal largest = n\n\t-- Perform trial division on\
    \ n up to the square root of n.\n\t-- Keep dividing by smallest prime until n\
    \ is larger than k.\n\t-- Increment k by 1 to ensure n is not divided by k.\n\t\
    while i * i <= n and k ~= 1 do\n\t\ti = i + 1\n\t\tif n % i == 0 then\n\t\t\t\
    largest = i\n\t\t\tk = k + 1\n\t\tend\n\tend\n\treturn largest\nend", "  -- We\
    \ use a naive sieve for finding prime factors until we find a prime factor > sqrt(n)\n\
    \  local primes = [2]\n  for i = 1, n do\n    -- Skip numbers divisible by 2\n\
    \    if n % 2 == 0 then\n      -- If no prime factor is found, skip even numbers\n\
    \      if primes[#primes] == nil then\n        while not n % primes[#primes] do\n\
    \          primes[#primes+1] = primes[#primes]\n        end\n      else\n    \
    \    -- If we have found a prime factor and it is greater than sqrt(n), skip the\
    \ even number\n        if primes[#primes] <= sqrt(n) then\n          n = n / primes[#primes]\n\
    \        else\n          -- Otherwise we found a larger prime factor\n       \
    \   primes[#primes+1] = n\n        end\n      end\n    end\n  end", "    if n\
    \ < 2 then return n end\n    local m = tonumber(math.sqrt(n)) -- The square root\
    \ of n\n    if m % 2 == 0 then return 1 end\n    if m * m > n then return largest_prime_factor(n/2)\
    \ end\n    -- Keep incrementing while m is larger than n.\n    local i = 2\n \
    \   while i * i <= n do\n        if n % i == 0 then\n            -- n is probably\
    \ a composite number.\n            -- If it's larger than m then return m as the\
    \ largest\n            -- prime factor of n and leave i alone.\n            if\
    \ m > n then return m end\n            break\n        end\n        i = i + 2\n\
    \    end\n    return i\nend", "\t-- If n is prime, return 1.\n\tif n <= 2 then\n\
    \t\treturn 1\n\tend", "  if n <= 1 then return 0 end\n  local i\n  for i = 2,\
    \ n do\n    local prime = primes[i]\n    if prime > n then return n end\n    if\
    \ prime == n then\n      local factor = 1\n      while n % prime == 0 do\n   \
    \     n = n / prime\n        factor = factor * prime\n      end\n      return\
    \ factor\n    end\n  end\nend", "    local lp = 2\n    local i = 1\n    while\
    \ i <= math.sqrt(n) do\n        if n % i == 0 then\n            lp = lp + 1\n\
    \            n = n / i\n        else\n            i = i + 1\n        end\n   \
    \ end\n    return lp\nend", "  if n <= 2 then return 1 end\n  local m = math.ceil(n/2)\n\
    \  if primes[m] then return primes[m] end\n  local d = 2\n  local i = 2\n  while\
    \ i <= m do\n    local s = n*d\n    if s == d then return i end\n    if s % i\
    \ == 0 then return i end\n    i = i + 2\n    d = d * 2\n  end\n  return i\nend",
  "  -- The prime factors of 13195 are 5, 7, 13 and 29.\n  -- Since the largest prime\
    \ factor of 2046 is 2,\n  -- all the prime factors of 2046 are 2 and 29, which\
    \ are the largest.\n  local factor = {}\n  local i = 1\n  while i * i <= n do\n\
    \    while n % i == 0 do\n      i = i * i\n      if i > n then break end\n   \
    \ end\n    table.insert(factor, i * i)\n    n = n / i\n  end\n  -- If n is a prime,\
    \ then one of the prime factors is greater than sqrt(n).\n  if n > 1 then table.insert(factor,\
    \ n) end\n  -- Scan factors in reverse order and return the largest one.\n  local\
    \ largest = nil\n  for i = #factor - 2, 1, -1 do\n    local p = factor[i]\n  \
    \  if largest == nil or p > largest then\n      largest = p\n    end\n  end\n\
    \  return largest\nend", "  local max_factor = 1\n  local max_factor_index = 1\n\
    \  for i = 2, n do\n    if n % i == 0 then\n      local new_factor = 1\n     \
    \ while n % i == 0 do\n        new_factor = i * max_factor\n        n, i = n/i,\
    \ new_factor\n      end\n      if n > max_factor then\n        max_factor, max_factor_index\
    \ = new_factor, max_factor_index\n      end\n    end\n  end\n  if max_factor >\
    \ 1 then\n    return max_factor\n  else\n    return 1\n  end\nend", "\t-- Set\
    \ n to its smallest prime factor.\n\t-- >>> largest_prime_factor(21)\n\t-- 3\n\
    \t-- >>> largest_prime_factor(541)\n\t-- 13", "\t-- We only need to consider the\
    \ prime factors up to n.\n\t-- We only need to consider odd numbers.\n\t-- If\
    \ n is even, then return n because no prime factor is found.\n\t-- If n is odd,\
    \ then return either the smallest prime factor of n or 2.\n\t-- The smallest prime\
    \ factor is easiest to find if the number is even.\n\t-- >>> largest_prime_factor(30)\n\
    \t-- 3\n\t-- >>> largest_prime_factor(59)\n\t-- 6\n\t-- >>> largest_prime_factor(60)\n\
    \t-- 2\n\t-- If the number is odd, then we can divide by the smallest prime factor\
    \ and\n\t-- get the smallest factor.\n\t-- >>> largest_prime_factor(47)\n\t--\
    \ 2\n\t-- >>> largest_prime_factor(63)\n\t-- 3\n\t-- >>> largest_prime_factor(99)\n\
    \t-- 2\n\t-- >>> largest_prime_factor(100)\n\t-- 2\n\t-- >>> largest_prime_factor(176)\n\
    \t-- 8\n\t-- >>> largest_prime_factor(600)\n\t-- 3\n\t-- >>> largest_prime_factor(600)\n\
    \t-- 3\n\t-- >>> largest_prime_factor(600)\n\t-- 3\n\t-- >>> largest_prime_factor(6343)\n\
    \t-- 6\n\t-- >>> largest_prime_factor(1000000007)\n\t-- 17\n\t-- >>> largest_prime_factor(1000000007)\n\
    \t-- 17", "   -- First check for small factors (1 through 4).\n   if n < 2 then\n\
    \      return 1\n   end", "  -- Initialize some variables\n  local factor = 2\n\
    \  local i = 1\n  \n  -- Find largest factor of n\n  while (n % factor) == 0 do\n\
    \    i = i + 1\n    factor = factor * i\n  end", "    local factor = 1\n    while\
    \ n ~= 1 do\n        if n % factor = 0 then\n            n = n / factor\n    \
    \        factor = factor + 1\n        end\n    end\n    return factor\nend", " \
    \ if n < 2 then return 1 end\n  local function factorize(n,p,d)\n    if d == 0\
    \ then return p end\n    for i = p, n - 1, p-1 do\n      local f = factorize(n,\
    \ i, d-1)\n      if f > d then return d end\n      d = f\n    end\n  end\n  return\
    \ factorize(n, 2, 1)\nend", "    local factor = 1\n    for x = 2, math.floor(n/2)\
    \ do\n        if n % x == 0 then\n            factor = x\n            break\n\
    \        end\n    end", "  if n < 2 then\n    return 1\n  end\n  if n == 2 then\n\
    \    return 2\n  end\n  if n % 2 == 0 then\n    return largest_prime_factor(n\
    \ / 2)\n  end\n  local i = 3\n  while i * i <= n do\n    i = i * i\n  end\n  return\
    \ i\nend", "  if n == 2 then\n    return 2\n  else\n    local lfp = 0\n    while\
    \ n > 2 do\n      lfp = (lfp * 2) % n\n      n = n / 2\n    end\n    return lfp\n\
    \  end\nend", "    local factors\n    local max\n    factors = prime_factorize(n)\n\
    \    if n > 1 then\n        max = 0\n        for i = 1, #factors do\n        \
    \    if max < factors[i] then max = factors[i] end\n        end\n    end\n   \
    \ return max\nend", "    local i = 1\n    local primes = {}\n    while i <= n\
    \ do\n        local prime_factor = i\n        for j = 1, n do\n            if\
    \ (n % prime_factor) == 0 then\n                prime_factor = nil\n         \
    \       break\n            end\n        end\n        if prime_factor == nil then\n\
    \            prime_factor = i\n        end\n        primes[i] = prime_factor\n\
    \        i = i + 1\n    end\n    local largest = primes[1]\n    for i = 2, #primes\
    \ do\n        if primes[i] == largest then\n            largest = primes[i]\n\
    \        else\n            largest = nil\n        end\n    end\n    return largest\n\
    end", "  -- Factor into prime and non-prime factors.\n  local factor = {}\n  local\
    \ factor = {}\n  for i = 2, math.sqrt(n) + 1 do\n    if n % (i) == 0 then\n  \
    \    factor[i] = 1\n    else\n      factor[i] = n%i\n    end\n  end", "\tif n\
    \ <= 2 then\n\t\treturn nil\n\tend\n\t-- Test if n is a prime. Most tests are\
    \ on primes. Testing for composites is cheaper.\n\tif is_prime(n) then\n\t\treturn\
    \ n\n\tend\n\t-- Test if n is a perfect power of 2. If so, return n as the largest\
    \ prime factor.\n\tif n % 2 = 0 then\n\t\tlocal power = 2\n\t\tlocal limit = n\
    \ / power\n\t\twhile power < limit do\n\t\t\tpower = power * 2\n\t\t\tif power\
    \ <= limit then\n\t\t\t\tlimit = power / 2\n\t\t\tend\n\t\tend\n\t\tif power ==\
    \ limit then\n\t\t\treturn power\n\t\tend\n\tend\n\t-- Repeatedly divide n by\
    \ 2. If any prime factors were found, they were removed and the process repeated.\n\
    \t-- After n is divided by 2, the largest prime factor is always the square root\
    \ of n.\n\tlocal i = 1\n\tlocal limit = tointeger(math.sqrt(n))\n\twhile i < limit\
    \ do\n\t\tlocal p = 2\n\t\tlocal limit = n / p\n\t\twhile p <= limit do\n\t\t\t\
    if n % p == 0 then\n\t\t\t\tbreak\n\t\t\tend\n\t\t\tp = p * 2\n\t\t\tlimit = n\
    \ / p\n\t\tend\n\t\tif p == limit then\n\t\t\treturn p\n\t\tend\n\t\ti = i + 1\n\
    \tend\nend", "   if n < 2 then\n      return nil\n   end\n   if n == 2 then\n\
    \      return n\n   end\n   local p = 1\n   while n > p do\n      if n % p ==\
    \ 1 then\n         return nil\n      end\n      p = p + 1\n   end\n   return p\n\
    end", "  -- Only odd numbers need to be tested\n  if not is_prime(n) then return\
    \ nil end\n  -- Only odd numbers need to be tested\n  if n % 2 == 0 then return\
    \ nil end\n  -- The largest prime factor is half the lower limit of the square\
    \ root of n\n  --\n  -- Source: https://en.wikipedia.org/wiki/Prime_number#Prime_number_theorem\n\
    \  local function sqrt(n)\n    return math.sqrt(n)\n  end\n  -- The largest prime\
    \ factor is half the lower limit of the square root of n\n  --\n  -- Source: https://en.wikipedia.org/wiki/Prime_number#Prime_number_theorem\n\
    \  local function factor(n)\n    local factors = {}\n    for i = 2, sqrt(n) do\n\
    \      if n % i == 0 then\n        table.insert(factors, i)\n      end\n    end\n\
    \    return factors\n  end\n  -- The largest prime factor is half the lower limit\
    \ of the square root of n\n  --\n  -- Source: https://en.wikipedia.org/wiki/Prime_number#Prime_number_theorem\n\
    \  local function largest(factors)\n    local largest = nil\n    for _, factor\
    \ in ipairs(factors) do\n      if largest == nil or largest > factor then\n  \
    \      largest = factor\n      end\n    end\n    return largest\n  end\n  -- Find\
    \ the largest prime factor\n  -- Source: https://en.wikipedia.org/wiki/Prime_number#Prime_number_theorem\n\
    \  local function largest(factors)\n    local largest = nil\n    for _, factor\
    \ in ipairs(factors) do\n      if largest == nil or largest > factor then\n  \
    \      largest = factor\n      end\n    end\n    return largest\n  end\n  -- Find\
    \ the largest prime factor of n\n  -- Source: https://en.wikipedia.org/wiki/Prime_number#Prime_number_theorem\n\
    \  local function largest_prime_factor(n)\n    local factors = factor(n)\n   \
    \ if factors ~= nil then\n      return largest(factors)\n    end\n  end\n  return\
    \ largest_prime_factor(n)\nend", "    assert(type(n) == \"number\")\n    if n\
    \ < 2 then return nil end\n    if n % 2 == 0 then return 2 end\n    if n % 3 ==\
    \ 0 then return 3 end\n    local limit = math.ceil(math.sqrt(n))\n    for i =\
    \ 5, 2, -1 do\n        while n % i == 0 do\n            limit = limit - 1\n  \
    \          if limit == 0 then\n                return i\n            end\n   \
    \     end\n    end\nend", '  if n < 2 then return n end', "  -- TODO: more efficient\
    \ way?\n  -- https://rosettacode.org/wiki/Largest-prime_factor#Lua\n  local function\
    \ is_prime(n)\n    local factors = {}\n    for i = 2, n do\n      local k\n  \
    \    for k = 0, n / i do\n        factors[k] = i\n        if n % i == 0 then\n\
    \          return false\n        end\n      end\n      if i == 1 then\n      \
    \  factors[1] = 1\n      end\n    end\n    return true\n  end\n  if n < 2 then\n\
    \    return nil\n  end\n  local prime\n  for i = 1, n do\n    prime = i\n    break\n\
    \  end\n  for prime = 2, n do\n    if n % prime == 0 then\n      local p = prime\n\
    \      while n % prime == 0 do\n        n = n/div\n      end\n      if p == prime\
    \ then\n        return n\n      end\n    end\n  end\n  return nil\nend", "  --\
    \ Check primality of n, and set p accordingly.\n  -- Assume n > 1 and is not a\
    \ prime.\n  local p\n  if primes.is_prime(n) == false then\n    error(\"'n' is\
    \ not a prime.\")\n  else\n    -- Find the largest factor of n larger than 1,\
    \ and return the product.\n    local i = 1\n    while i <= math.sqrt(n) do\n \
    \     -- if n is evenly divisible by 2 return 2*p\n      if n % 2 == 0 and math.floor(n\
    \ / 2) ~= math.floor((n/2) do\n      p = 1\n      else\n        p = 2\n      end\n\
    \      -- return largest prime factor of n\n      if p ~= 1 and p > p then\n \
    \       p = p * 2\n      end\n      i = i + 1\n    end\n  end\n  return p\nend",
  "    local largest_pf = 1\n    local i = 1\n    while i <= n do\n        if n %\
    \ i == 0 then\n            largest_pf = largest_pf + 1\n        end\n        i\
    \ = i + 1\n    end\n    return largest_pf\nend", "    assert(n > 1)\n    local\
    \ r = 2 -- r = largest prime factor\n    while r * r <= n do\n        if n % r\
    \ == 0 then\n            n = n / r\n        else\n            -- composite number\n\
    \            n = n - (n % r)\n        end\n        r = r + 1\n    end\n    return\
    \ n\nend\n</cell>\n<text>\nFor those of you who are interested, you can also take\
    \ a look at a few of the built-in functions:", "\t-- Return largest prime factor\
    \ of n using sieve of Eratosthenes:\n\t-- https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \t-- https://codereview.stackexchange.com/questions/114613/sieve-of-eratosthenes\n\
    \t-- http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf", "    local d = 3\n \
    \   local i = 2\n    local p = 2\n    while i * p <= n and p <= n / i do\n   \
    \     p = p * i\n        i = i + 1\n        d = d + i\n    end", "    if n <=\
    \ 1 then\n        return 1\n    end", "  -- The prime factors of n are 1, 2, ...,\
    \ n-1.\n  -- Let d = 2\n  local d = 0\n  -- n is greater than or equal to 1, so\
    \ n-1 is greater than or equal to 1.\n  -- n is also greater than or equal to\
    \ d, so n-1 is greater than or equal to d.\n  -- Continue while n-1 is greater\
    \ than or equal to d.\n  -- n-1 is greater than or equal to (2d)+1 = 2d+1.\n \
    \ while n >= d do\n    -- n-1 is greater than or equal to 2d+1. 2d+1 is a multiple\
    \ of d.\n    -- n-1 is also greater than or equal to d+1 = 2d+2. 2d is a multiple\
    \ of d.\n    -- Continue while n-1 is greater than or equal to 2d+2.\n    -- Continue\
    \ while n-1 is greater than or equal to 2d+1.\n    -- 2d+1 is a multiple of d.\n\
    \    d = d + 1\n    -- n is greater than or equal to 2d+1.\n    -- n-1 is greater\
    \ than or equal to 2d+2, so n-1 is greater than or equal to 2d+2.\n    -- Continue\
    \ while n-1 is greater than or equal to 2d+2.\n    n = n / d\n  end\n  return\
    \ d\nend", "    if n < 2 then\n        return nil\n    end\n    local function\
    \ factorize(n)\n        if n == 1 then\n            local x = 1\n            while\
    \ n >= x do\n                n = n / x\n                local y = 1\n        \
    \        while n >= y do\n                    n = n / y\n                    x\
    \ = x + 1\n                end\n            end\n            return x\n      \
    \  else\n            local x = 1\n            while n >= x do\n              \
    \  n = n / x\n                local y = 1\n                while n >= y do\n \
    \                   n = n / y\n                    y = y + 1\n               \
    \ end\n                x = x + 1\n            end\n            return x\n    \
    \    end\n    end\n    local function primality(n)\n        if n % 2 == 0 then\n\
    \            return false\n        end\n        for i = 2, n - 1 do\n        \
    \    if n % i == 0 then\n                return false\n            end\n     \
    \   end\n        return true\n    end\n    local factors = factorize(n)\n    local\
    \ primes = nil\n    if factors ~= nil and factors ~= n then\n        primes =\
    \ factors\n    end\n    if not primes or not primality(n) then\n        return\
    \ nil\n    end\n    local m = nil\n    if primes == 2 then\n        m = n\n  \
    \  elseif primes == 3 then\n        local a = 3\n        if n % a == 0 then\n\
    \            m = n\n        end\n    end\n    while not m do\n        local b\
    \ = m * 2\n        if n % b == 0 then\n            m = n\n        end\n    end\n\
    \    return m\nend", "  if n < 2 then\n    return 1\n  end\n  if n < 7 then\n\
    \    return n\n  end\n  local num_factors = 1\n  local i = 2\n  local prime_factor\
    \ = 1\n  while i * prime_factor <= n do\n    -- Assume primes are all >= 2, except\
    \ for the smallest.\n    -- If we find a larger prime, we'll still have to try\
    \ factoring it.\n    -- If we find a smaller prime less than the smallest factor,\n\
    \    -- we know we've found a large prime, so stop.\n    -- Otherwise, try it.\n\
    \    if n % prime_factor == 0 then\n      if prime_factor > num_factors then\n\
    \        num_factors = prime_factor\n      end\n      num_factors = num_factors\
    \ * prime_factor + 1\n      prime_factor = 2\n    else\n      prime_factor = prime_factor\
    \ + 1\n    end\n    i = i * prime_factor + 1\n  end\n  return num_factors\nend",
  "    local max = 1\n    local i = 1\n    while i <= n do\n        local p = math.floor((math.sqrt(i\
    \ * 2 + 1) - 1) / 2)\n        if i % p == 0 then\n            max = p\n      \
    \  else\n            if p > max then\n                max = p\n            end\n\
    \        end\n        i = i + 1\n    end\n    return max\nend", "    if n < 2\
    \ then return 1 end\n    if n == 1 then return 1 end\n    -- Trial division\n\
    \    for _ = 1, n do\n        local i = 1\n        while i * i <= n do\n     \
    \       if n % i == 0 then\n                n = n / i\n                break\n\
    \            else\n                i = i + 1\n            end\n        end\n \
    \   end\n    return n\nend", "  if n <= 1 then\n    return nil\n  end", "\tlocal\
    \ p, s = n, 1\n\twhile p*p <= n do\n\t\ts = p*s + 1\n\t\tp = n / s\n\tend\n\t\
    return s\nend", "\tassert(n > 1, \"n must be a positive integer\")\n\tassert(math.fmod(n,\
    \ 2) == 1, \"n must be odd to find a prime factor\")\n\tlocal function factorizer(n)\n\
    \t\tif n <= 1 then return nil end\n\t\tlocal m = n / 2\n\t\twhile m > 1 do\n\t\
    \t\tif n % m == 0 then\n\t\t\t\treturn m \n\t\t\telseif m % n == 0 then\n\t\t\t\
    \treturn nil\n\t\t\telse\n\t\t\t\tm = m / 2\n\t\t\tend\n\t\tend\n\t\treturn nil\n\
    \tend\n\treturn math.max(factorizer(n), largest_prime_factor(math.fdiv(n,2)))\n\
    end", "\tlocal m = 2\n\twhile not n % m do\n\t\tm = 2 * m\n\tend\n\t-- Only prime\
    \ factors matter. No need to consider multiplicities.\n\t-- But even the smallest\
    \ prime factor matters. So if m is prime, then\n\t-- m / 2 == 1.\n\twhile m ==\
    \ 1 do\n\t\tm = 2 * m\n\tend\n\treturn m\nend", "    local i\n    local n = 1\n\
    \    local prime = 2\n    -- Find prime factors (using Sieve of Eratosthenes).\n\
    \    for i = 2, math.sqrt(n) do\n        while n % i == 0 do\n            n =\
    \ n / i\n            prime = prime*i\n        end\n    end\n    -- If n is 1,\
    \ return n (i.e. the prime itself).\n    if n == 1 then\n        return n\n  \
    \  else\n        return prime\n    end\nend", "  -- https://math.stackexchange.com/questions/22876/find-the-largest-prime-factor-of-a-number\n\
    \  -- The algorithm given by Sieve of Eratosthenes is efficient and elegant.\n\
    \  -- See https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n  -- The code below\
    \ is taken from https://stackoverflow.com/questions/1135167/what-is-the-most-efficient-way-to-find-the-highest-prime-factor-of-a-number\n\
    \  if n == 1 then return 1 end", "  local factors = {}\n  for i = 2, n do\n  \
    \  while n % i == 0 do\n      table.insert(factors, i)\n      n = n / i\n    end\n\
    \  end\n  if n == 1 then\n    return n\n  elseif #factors == 1 then\n    return\
    \ factors[1]\n  else\n    return nil\n  end\nend", "  -- Make n a positive integer.\n\
    \  n = tonumber(n)", "  if n < 2 then\n    return nil\n  elseif n == 2 then\n\
    \    return 2\n  elseif n == 3 then\n    return 3\n  else\n    if n % 2 == 0 then\n\
    \      return largest_prime_factor(n / 2)\n    else\n      -- if n is odd, it\
    \ is divisible by 3\n      if n % 2 == 1 then\n        return largest_prime_factor(n\
    \ / 3) + 1\n      else\n        local f = math.floor(math.sqrt(n))\n        local\
    \ u = n % f\n        -- if u is divisible by 2 then it is a prime factor\n   \
    \     if u == 0 then\n          return f\n        else\n          -- if u is divisible\
    \ by 3 then it is a prime factor\n          if u == 1 then\n            return\
    \ f + 1\n          else\n            -- if u is divisible by 5 and not 1 then\
    \ it is a prime factor\n            if u == 2 or u == 0 then\n              return\
    \ f + 2\n            else\n              -- if u is divisible by 7 and not 2 then\
    \ it is a prime factor\n              if u == 3 or u == 1 then\n             \
    \   return f + 3\n              else\n                -- if u is divisible by\
    \ 9 and not 3 then it is a prime factor\n                if u == 0 or u == 2 then\n\
    \                  return f + 4\n                else\n                  -- if\
    \ u is divisible by 11 and not 0 and not 2 and not 3 then it is a prime factor\n\
    \                  if u == 1 or\n                    u == 3 or\n             \
    \       u == 0 or\n                    u == 2 or\n                    u == 1 then\n\
    \                    return f + 5\n                  else\n                  \
    \  -- if u is divisible by 13 and not 1 or 3 and not 0 then it is a prime factor\n\
    \                    if u == 1 or\n                      u == 3 then\n       \
    \               return f + 6\n                    else\n                     \
    \ -- if u is divisible by 17 and not 1 or 2 and 3 then it is a prime factor\n\
    \                      if u == 1 or\n                        u == 2 or\n     \
    \                   u == 0 then\n                        return f + 7\n      \
    \                else\n                        -- if u is divisible by 19 and\
    \ not 1 or 2 and 3 or 0 then it is a prime factor\n                        if\
    \ u == 1 or\n                          u == 2 or\n                          u\
    \ == 3 or\n                          u == 0 then\n                          return\
    \ f + 8\n                        else\n                          -- if u is divisible\
    \ by 23 and not 1 or 2 and 3 or 0 and 5 then it is a prime factor\n          \
    \                if u == 1 or\n                            u == 2 or\n       \
    \                     u == 3 or\n                            u == 0 or\n     \
    \                       u == 1 then\n                            return f + 9\n\
    \                          else\n                            -- if u is divisible\
    \ by 29 and not 1 or 2 and 3 or 0 and 5 or 9 then it is a prime factor\n", " \
    \   local factor = 1\n    while n > 1 do\n        if n % factor == 0 then\n  \
    \          factor = 2\n        else\n            n = n / factor\n        end\n\
    \    end\n    return factor\nend", "  if n < 2 then return nil end\n  local maxp,\
    \ p, q = 1\n  local i = 1\n  for _ = 1, n do\n    while i * p <= n do\n      local\
    \ pq = i * p\n      p = p + q\n      q = pq - p\n      if p * p > n then\n   \
    \     break\n      end\n      if p == maxp then\n        maxp = p\n        break\n\
    \      end\n      i = i + 1\n    end\n    if maxp ~= 1 then\n      break\n   \
    \ end\n  end\n  if maxp < n then\n    local lf = largest_prime_factor(n / maxp)\n\
    \    if lf ~= nil then\n      return lf\n    else\n      return maxp\n    end\n\
    \  end\n  return n\nend", "  if n == 1 then\n    return 1\n  else\n    local max_factor\
    \ = 1\n    local i = 1\n    while i * i <= n do\n      local prime_factor = n\n\
    \      for j = i * 2 to n do\n        prime_factor = prime_factor % j\n      end\n\
    \      if prime_factor > max_factor then\n        max_factor = prime_factor\n\
    \      end\n      i = i + 2\n    end\n    return max_factor\n  end\nend", "  if\
    \ n < 2 then\n    return nil\n  elseif n < 3 then\n    return 2\n  elseif n %\
    \ 2 == 0 then\n    return 3\n  elseif n % 3 == 0 then\n    return 5\n  elseif\
    \ n % 5 == 0 then\n    return 7\n  else\n    -- We only need to test up to sqrt(n).\n\
    \    -- From wolfram:\n    --\n    -- P[n, S] := (S-1)/(S+sqrt(n))\n    -- P[n,\
    \ 2] := 2(S-1/sqrt(n))\n    -- P[n, 3] := (6(2S-1/sqrt(n))^2)/(6S+sqrt(n))\n \
    \   -- P[n, 4] := (10(6(2S-1/sqrt(n))^2)^2)/(10S+sqrt(n))\n    -- P[n, 5] := (15(10(6(2S-1/sqrt(n))^2)^2)^2)/(15S+sqrt(n))\n\
    \    -- P[n, 6] := (20(15(10(6(2S-1/sqrt(n))^2)^2)^2)^2)/(20S+sqrt(n))\n    --\
    \ P[n, 7] := (27(20(15(10(6(2S-1/sqrt(n))^2)^2)^2)^2)^2)/(27S+sqrt(n))\n    --\
    \ P[n, 8] := (30(27(20(15(10(6(2S-1/sqrt(n))^2)^2)^2)^2)^2)^2)/(30S+sqrt(n))\n\
    \    -- P[n, 9] := (33(30(27(20(15(10(6(2S-1/sqrt(n))^2)^2)^2)^2)^2)^2)^2)/(33S+sqrt(n))\n\
    \    -- P[n, 10] := (36(33(30(27(20(15(10(6(2S-1/sqrt(n))^2)^2)^2)^2)^2)^2)^2)^2)/(36S+sqrt(n))\n\
    \    -- P[n, 11] := (40(36(33(30(27(20(15(10(6(2S-1/sqrt(n))^2)^2)^2)^2)^2)^2)^2)^2)^2)/(40S+sqrt(n))\n\
    \    -- P[n, 12] := (45(40(36(33(30(27(20(15(10(6(2S-1/sqrt(n))^2)^2)^2)^2)^",
  "  -- Make sure that n is prime.\n  if n <= 1 then\n    return nil\n  end", "  --\
    \ Sieve of Eratosthenes (https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\n\
    \  -- See https://stackoverflow.com/questions/1267869/eratosthenes-sieve-of-eratosthenes-why-does-this-work-in-python\n\
    \  -- The sieve only needs to be recalculated if n is prime and n > 2\n  -- To\
    \ save time, the sieve is re-used if n is prime and n < 2\n  local max_factor\
    \ = 1\n  local prime_factors = []\n  local prime = 2\n  local i = 2", "  if n\
    \ < 1 then return nil end\n  if n % 2 == 0 then\n    if n == 2 then return 2 end\n\
    \    local i = 3\n    while i <= math.sqrt(n) do\n      if n % i == 0 then\n \
    \       return i\n      end\n      i = i * 2\n    end\n    return n\n  end\n \
    \ local m = 1\n  while m <= math.sqrt(n) do\n    while n % m == 0 do\n      m\
    \ = m + 1\n    end\n    if m > 2 then\n      return m\n    end\n    n = n / m\n\
    \  end\n  return n\nend", '  if n < 2 then return nil end', "\tlocal p = 2\n\t\
    while p:lt(n) do\n\t\tn = n / p\n\t\tp = p + 1\n\tend\n\treturn p\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
