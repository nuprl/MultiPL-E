name: HumanEval_18_how_many_times
language: lua
prompt: "-- Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\n-- >>> how_many_times('', 'a')\n-- 0\n-- >>> how_many_times('aaa',\
  \ 'a')\n-- 3\n-- >>> how_many_times('aaaa', 'aa')\n-- 3\nlocal function how_many_times(string,\
  \ substring)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = how_many_times\n\
  \    lu.assertEquals(candidate('', 'x'), 0)\n    lu.assertEquals(candidate('xyxyxyx',\
  \ 'x'), 4)\n    lu.assertEquals(candidate('cacacacac', 'cac'), 4)\n    lu.assertEquals(candidate('john\
  \ doe', 'john'), 1)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tlocal count = 0\n\tfor i = 1, #string do\n\t\tif string.sub(i, #i\
    \ - #substring) == substring then\n\t\t\tcount = count + 1\n\t\telseif string.sub(i,\
    \ #i - #substring) == string.sub(substring, 1, #substring) then\n\t\t\tcount =\
    \ count + 1\n\t\tend\n\tend\n\treturn count\nend", "\t-- https://stackoverflow.com/questions/22670598/find-the-number-of-times-substring-occurs-in-a-string\n\
    \t-- https://stackoverflow.com/questions/34488028/how-do-i-count-the-number-of-occurrences-of-a-substring-in-a-string-in-lua\n\
    \t-- https://stackoverflow.com/questions/13543215/lua-how-to-count-string-occurrence-in-string\n\
    \t-- https://www.reddit.com/r/lua/comments/4vk9va/how_to_count_number_of_times_a_word_occurs_in_a_string/\n\
    \tlocal count = 0\n\tlocal index = string.find(string, \"%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d%.-]%%-[%d",
  "  local result = 0\n  for match in string.gfind(string, \"[^\"..substring..\"]\"\
    ) do\n    local start = match[1] - 1\n    local length = match[2] - start + 1\n\
    \    if start + length == #string then\n      result = result + 1\n    end\n \
    \ end\n  return result\nend", "  local count = 0\n  for i = 1, #string do\n  \
    \  if string.sub(i, i) == substring then\n      count = count + 1\n    end\n \
    \ end\n  return count\nend", "  if string == substring then\n    return 1\n  end\n\
    \  if #string > #substring then\n    return 0\n  end\n  local index = string.find(string,\
    \ '[' .. substring .. ']')\n  if index == nil then\n    return 0\n  end\n  return\
    \ 1 + how_many_times(string[index + 1], substring)\nend", "  local function count_overlaping_cases(i,\
    \ j)\n    if i ~= j then\n      if string.sub(i, j) == substring then\n      \
    \  count = count + 1\n      end\n    end\n  end\n  count = 0\n  for i, s in ipairs(string)\
    \ do\n    count_overlaping_cases(i, #string + 1)\n  end\n  return count\nend",
  "    return string.gsub(substring, \"[^\"..substring..\"]\"):gsub(\"^%s*\", \"\"\
    ):gsub(\"%s*$\", \"\"):gsub(\"^%s*\", \"\"):gsub(\"%s*$\", \"\"):gsub(\">%c\"\
    , \"<\"):gsub(\"<%c\", \">\"):gsub(\"%c\", \"<\"):gsub(\"%c\", \"<\")\nend", '  local
    count = 1', "    if string == nil then\n        return 0\n    end\n    if substring\
    \ == nil then\n        return 0\n    end\n    if type(string) == 'string' then\n\
    \        if type(substring) == 'string' then\n            -- If the two strings\
    \ are the same length, we can do some quick comparisons\n            -- instead\
    \ of looking up each character in the original string.\n            if #string\
    \ == #substring then\n                local num_matches = 0\n                for\
    \ i = 1, #string do\n                    if string.sub(i, i) == substring then\n\
    \                        num_matches = 1 + num_matches\n                    end\n\
    \                end\n                return num_matches\n            end\n  \
    \      end\n    end\n    -- If the given string is of the wrong type, return nil.\n\
    \    return nil\nend", "    if string == '' or substring == '' then return 0 end\n\
    \    if substring == '' then return 1 end\n    local index_1 = string.find(string,\
    \ '%a') + 1\n    local index_2 = string.find(string, '%a', index_1)\n    if index_1\
    \ == index_2 then return 1 end\n    if index_2 == nil then return 0 end\n    local\
    \ index_3 = string.find(string, '%a', index_2)\n    local index_4 = string.find(string,\
    \ '%a', index_3)\n    if index_3 == nil then return 0 end\n    local index_5 =\
    \ string.find(string, '%a', index_4)\n    local index_6 = string.find(string,\
    \ '%a', index_5)\n    if index_4 == nil then return 0 end\n    local index_7 =\
    \ string.find(string, '%a', index_6)\n    local index_8 = string.find(string,\
    \ '%a', index_7)\n    if index_5 == nil then return 0 end\n    local index_9 =\
    \ string.find(string, '%a', index_8)\n    local index_10 = string.find(string,\
    \ '%a', index_9)\n    if index_6 == nil then return 0 end\n    local index_11\
    \ = string.find(string, '%a', index_10)\n    local index_12 = string.find(string,\
    \ '%a', index_11)\n    if index_7 == nil then return 0 end\n    local index_13\
    \ = string.find(string, '%a', index_12)\n    local index_14 = string.find(string,\
    \ '%a', index_13)\n    if index_8 == nil then return 0 end\n    local index_15\
    \ = string.find(string, '%a', index_14)\n    local index_16 = string.find(string,\
    \ '%a', index_15)\n    if index_9 == nil then return 0 end\n    local index_17\
    \ = string.find(string, '%a', index_16)\n    local index_18 = string.find(string,\
    \ '%a', index_17)\n    if index_10 == nil then return 0 end\n    local index_19\
    \ = string.find(string, '%a', index_18)\n    local index_20 = string.find(string,\
    \ '%a', index_19)\n    if index_11 == nil then return 0 end\n    local index_21\
    \ = string.find(string, '%a', index_20)\n    local index_22 = string.find(string,\
    \ '%a', index_21)\n    if index_12 == nil then return 0 end\n    local index_23\
    \ = string.find(string, '%a', index_22)\n    local index_24 = string.find(string,\
    \ '%a', index_23)\n    if index_13 == nil then return 0 end\n    local index_25\
    \ = string.find(string, '%a', index_24)\n    local index_26 = string.find(string,\
    \ '%", "    local count = 0\n    for _, c in ipairs(string) do\n        if c ==\
    \ substring then count = count + 1 else count = count + 1 end\n    end\n    return\
    \ count\nend", "    local counter = 1\n    for _, char in string.gfind(string)\
    \ do\n        if char == substring then\n            counter = counter + 1\n \
    \       end\n    end\n    return counter\nend", "\tlocal substrings = string:gsub('(.-)(.-)',\
    \ '\\1\\2'):gsub('(.-)(.-)', '\\2\\1'):gsub('(.-)(.-)', '\\3\\2')\n\tlocal matches\
    \ = 0", "    local counter = 0\n    while true do\n        counter = counter +\
    \ 1\n        local index = string:find(substring, 1, 1)\n        string = string.sub(string,\
    \ index+1)\n        if index == nil then\n            break\n        end\n   \
    \ end\n    return counter\nend", "\t-- Initialize a counter to zero\n\tlocal count\
    \ = 0", "  local count = 0\n  for char in string do\n    if char == substring\
    \ then\n      count = count + 1\n    end\n  end\n  return count\nend", "\tlocal\
    \ n = 0\n\tlocal pos = 0\n\twhile true do\n\t\tlocal idx = string.find(substring,\
    \ string, pos)\n\t\tif idx == nil then\n\t\t\tbreak\n\t\tend\n\t\tpos = idx +\
    \ 1\n\t\tn = n + 1\n\tend\n\treturn n\nend", "    local pos = 1\n    local substring_len\
    \ = string.len(substring)\n    local substring = string.lower(substring)\n   \
    \ \n    while pos <= string.len(string) do\n        if string.sub(s, pos, pos\
    \ + substring_len) == substring then\n            return pos\n        end\n  \
    \      pos = pos + 1\n    end\n    \n    return 0\nend", "  if string == nil then\
    \ return 0 end\n  if substring == nil then return 1 end\n  if string.find(string)\
    \ == nil then return 0 end\n  local count = #string.match(string, \"[^\"..substring..\"\
    ]*\")\n  return count > 0 and count or 0\nend", "    return string.gsub(string,\
    \ substring, \"\")\nend", "    local count = 0\n    while true do\n        count\
    \ = count + 1\n        local substring_index = string.find(substring, string,\
    \ 1, true)\n        if substring_index == nil then\n            return count\n\
    \        end\n        string = string.sub(string, substring_index + 1)\n    end\n\
    end", "  local count_a, count_b, overlaps_a, overlaps_b\n  count_a = 1\n  count_b\
    \ = 1\n  overlaps_a = count_a == 0\n  overlaps_b = count_b == 0", "    if string\
    \ == nil then return 0 end\n    if string == substring then return 1 end\n   \
    \ local count = 0\n    local i = string.find(string, \"%c\"):byte() - 1\n    while\
    \ i >= 0 do\n        if string.sub(i, string.len() - string.len(substring)) ~=\
    \ substring then\n            count = count + 1\n        end\n        i = string.find(string,\
    \ \"%c\", i + 1)\n    end\n    return count\nend", "    if not string then\n \
    \       return 0\n    end\n    if not substring then\n        return #string\n\
    \    end\n    if #string == 0 then\n        return 0\n    end\n    if #substring\
    \ == 0 then\n        return #string\n    end\n    local count = 0\n    for i =\
    \ 1, #string do\n        if string.sub(i, #string) == substring then\n       \
    \     count = count + 1\n        end\n    end\n    return count\nend", "  return\
    \ #string > 0 and #substring > 0 and string.find(substring, string) or 0\nend",
  "    if string == nil or substring == nil then\n        return 0\n    end\n    --\
    \ Find the number of occurrences of substring in the string.\n    local result\
    \ = string.gsub(substring, \"[^\" .. string.char(127) .. \"]+\", \"\") .. 0\n\
    \    -- If substring is not found return number of occurrences in the whole string.\n\
    \    if result == \"\" then\n        return string\n    end\n    -- Handle overlapping\
    \ cases. Count how many times the substring occurs in original string.\n    result\
    \ = string.gsub(substring, \"[^\" .. string.char(127) .. \"]+\", \"\") .. 0\n\
    \    return string\nend", "  if string == '' or substring == '' then return 0\
    \ end\n  local count = 1\n  for i = 1, #string do\n    local substring_found =\
    \ false\n    for j = 1, #substring do\n      if string[i] == substring[j] then\n\
    \        count = count + 1\n      end\n      if string[i] == substring[j] then\n\
    \        substring_found = true\n      end\n    end\n    if not substring_found\
    \ then\n      count = count + 1\n    end\n  end\n  return count\nend", "    local\
    \ i, j = 1, #string\n    while i <= j and string.find(substring, string[i]) do\n\
    \        i = i + 1\n    end\n    return i\nend", "\tlocal num_times = 0\n\twhile\
    \ true do\n\t\tlocal index = string.find(substring, 1, true)\n\t\tif index ==\
    \ nil then break end\n\t\tnum_times = num_times + 1\n\t\tstring = string.sub(string,\
    \ index + #substring)\n\tend\n\treturn num_times\nend", "   if not string then\
    \ return 0 end\n   local result = 1\n   for i = 1, string.len() do\n      local\
    \ start = string.find(string, substring, i)\n      if start ~= nil then\n    \
    \     if start > i then\n            start = string.find(string, substring, start+1)\n\
    \            if start ~= nil then\n               result = result + 1\n      \
    \         i = start\n            end\n         end\n         i = start + string.len(substring)\
    \ - 1\n      end\n   end\n   return result\nend", "   if string == '' then\n \
    \     return 0\n   end\n   if string == '' then\n      return 1\n   end\n   if\
    \ string ~= '' and substring == '' then\n      return 0\n   end\n   if string\
    \ ~= '' and substring ~= '' and string == substring then\n      return 1\n   end\n\
    \   return string.find(substring, 1, true) + 1\nend", "  if string == nil or substring\
    \ == nil then\n    return 0\n  end\n  local pos = string.find(string, \"%\"..substring..\"\
    %\")\n  if pos ~= nil then\n    local substring_len = len(substring)\n    local\
    \ count = 0\n    pos = string.find(string, \"%\"..substring..\"%\", pos + 1)\n\
    \    while pos != nil do\n      count = count + substring_len\n      pos = string.find(string,\
    \ \"%\"..substring..\"%\", pos + 1)\n    end\n    return count\n  end\n  return\
    \ 0\nend", "\tlocal n = #string\n\tif n == 0 then\n\t\treturn 0\n\tend\n\t-- Find\
    \ the starting and ending position of the substring\n\tlocal start = string.find(string,\
    \ substring, 1, true)\n\tlocal end   = string.find(string, substring, start +\
    \ #substring, true)\n\t-- If the substring was not found then return 0\n\tif start\
    \ == nil then\n\t\treturn 0\n\tend\n\treturn end-start\nend", "    local count\
    \ = string.find(string, substring)\n    if count == nil then\n        return nil\n\
    \    end\n    local last_index = string.find(string, \"[\", string.len(string)\
    \ - count + 2)\n    if last_index == nil then\n        return nil\n    end\n \
    \   count = string.sub(string, last_index + 1, string.len(string))\n    count\
    \ = tonumber(count)\n    if count == nil then\n        return nil\n    end\n \
    \   return count + 1\nend", "    local count = 0\n    for s in string.gmatch(string,\
    \ \"([^%s]+)\") do\n        if string.find(substring, s) then\n            count\
    \ = count + 1\n        end\n    end\n    return count\nend", "  return string.gsub(string,\
    \ substring, '%d'):gsub('%d+', function(count, substring)\n    return string.gsub(substring,\
    \ substring, '%d'):gsub('%d+', count + 1)\n  end)\nend", "\treturn string.gsub(string,\
    \ substring, function()\n\t\treturn function(s, i1, i2)\n\t\t\treturn string.sub(s,\
    \ i1, i2) end\n\tend):match(\"^%S+\"):gsub(\"^%z\", \"\"):gsub(\" \", \"\"):gsub(\"\
    %z\", \"\")\nend", "  if string == nil then return 0 end\n  if substring == nil\
    \ then return 1 end\n  local count = 0\n  local start = 0\n  while start < #string\
    \ do\n    local substring_found = false\n    for i = start, #string do\n     \
    \ if string.sub(i, #i - #substring) == substring then\n        substring_found\
    \ = true\n        break\n      end\n    end\n    if substring_found then count\
    \ = count + 1 end\n    start = start + 1\n  end\n  return count\nend", "\t-- Check\
    \ if the string contains any substring.\n\tif not string.find(string, substring)\
    \ then\n\t\treturn 0\n\tend", "    local count = 0\n    for _, c in ipairs(string)\
    \ do\n        if string.sub(c, 1, #substring) == substring then\n            count\
    \ = count + 1\n        end\n    end\n    return count\nend", "  if string==nil\
    \ or substring==nil then return 0 end\n  local count = 0\n  for char in string.gmatch(string,\
    \ \"%c\") do\n    count = count + 1\n    if string.find(substring, char, 1, true)\
    \ then\n      count = count + 1\n    end\n  end\n  return count\nend", "   if\
    \ string == substring then\n      return 1\n   end\n   if string.find(substring)\
    \ == nil then\n      return 0\n   end\n   local count = 1\n   local index = string.find(substring,\
    \ 1, true)\n   while index~=nil do\n      if index:find(substring,1,true) then\n\
    \         count = count + 1\n      end\n      index = string.find(substring, index\
    \ + 1, true)\n   end\n   return count\nend", "   if string == nil or substring\
    \ == nil then\n      return 0\n   end", "  -- If the string contains no substring,\
    \ return 0 times the length of the string.\n  if not string then return 0 end\n\
    \  -- If the string does not contain the substring, return 0 times the length\
    \ of the string.\n  if not substring then return 0 end\n  -- If the substring\
    \ is longer than the string, return 0 times the length of the string.\n  if substring\
    \ > string then return 0 end\n  -- If the substring length is 1, return 1 times\
    \ the length of the string.\n  if substring == 1 then return 1 end\n  -- Initialize\
    \ a counter to 0\n  local count = 0\n  -- If the substring length is 2, check\
    \ for equality of the substrings up to the middle of the string.\n  if substring:len()\
    \ <= string then\n    -- If the substring is not equal to the entire string, return\
    \ 0 times the length of the string.\n    if substring ~= string then return 0\
    \ end\n    -- Otherwise, the substring equals the entire string. Increment the\
    \ counter by 1.\n    count = count + 1\n  -- If the substring length is 3, check\
    \ for equality of the substrings up to the middle of the string.\n  elseif substring:len()\
    \ == 2 then\n    -- If the substring is not equal to the entire string, return\
    \ 0 times the length of the string.\n    if substring ~= string then return 0\
    \ end\n    -- Otherwise, the substring equals the entire string. Increment the\
    \ counter by 1.\n    count = count + 1\n    -- If the first two characters of\
    \ the substring are equal to the first two characters of the string, return 1\
    \ times the length of the string.\n  elseif substring:sub(1, 1) == string.sub(1,\
    \ 1) then\n    -- If the substring is not equal to the entire string, return 0\
    \ times the length of the string.\n    if substring ~= string then return 0 end\n\
    \    -- Otherwise, the substring equals the entire string. Increment the counter\
    \ by 1.\n    count = count + 1\n    -- If the first two characters of the substring\
    \ are equal to the last two characters of the string, return 1 times the length\
    \ of the string.\n  elseif substring:sub(1, 1) ~= string.sub(string:len() - 1,\
    \ 1) then\n    -- If the substring is not equal to the entire string, return 0\
    \ times the length of the string.\n    if substring ~= string then return 0 end\n\
    \    -- Otherwise, the substring equals the entire string. Increment the counter\
    \ by 1.\n    count = count + 1\n    -- If the last two characters of the substring\
    \ are equal to the first two characters of the string, return 1 times the length\
    \ of the string.\n  elseif substring:sub(1, 1) ~= string.sub(1, substring:len()\
    \ - 1) then\n    -- If the substring is not equal to the entire string, return\
    \ 0 times the length of the string.\n    if substring ~= string then return 0\
    \ end\n    -- Otherwise, the substring equals the entire string. Increment the ",
  "    return string.gsub(function(word)\n        return string.find(word, substring)\n\
    \    end, '()', 1, 'count')\nend", "    return #string > 0 and #substring > 0\
    \ and string.find(string) >= 0 and string.find(string, substring) >= 0 and\n \
    \          #(string.gsub(string, \"[\"..substring..\"]\", \"\") or '') == (string.gsub(string,\
    \ \"[\"..substring..\"]\", \"\") or ''):len(substring)\nend", "    return string.gsub('.',\
    \ string.gsub('([^' .. substring .. ']+)', \"%1\\1%2\"))\nend", "  return string.gsub(string.gsub(string,\
    \ substring, 1, 'g'), '(%1):(%d%d)'):format(substring)\nend", "  if string ==\
    \ nil then string = '' end\n  if substring == nil then substring = '' end\n  local\
    \ substring_index = string.find(substring, 1, true)\n  return math.min(string.find(string,\
    \ '.', 1, substring_index, true) - 1, string.find(string, substring, 1, true)\
    \ - substring_index - 1)\nend", "  if string == nil or substring == nil then\n\
    \    return nil\n  end\n  local count = 0\n  local start = 0\n  while start <=\
    \ #string do\n    local stop = string.find(string, substring, start, true)\n \
    \   if stop == nil then\n      return nil\n    end\n    start = stop + 1\n   \
    \ count = count + 1\n  end\n  return count\nend", "  -- Make string and substring\
    \ lower case to avoid case issues.\n  string = string.lower(string)\n  substring\
    \ = substring.lower()", "   if string == substring then\n      return 1\n   elseif\
    \ substring == \"\" then\n      return 0\n   elseif string.find(substring, 1,\
    \ true) then\n      return 1 + how_many_times(string, string.sub(string, 1, string.find(string,\
    \ substring, 1, true) - 1))\n   else\n      return 0\n   end\nend", "  if string\
    \ == '' or substring == '' then\n    return 0\n  end\n  local count = 0\n  for\
    \ i = 1, string.len() do\n    if string.sub(i, string.length()) == substring then\n\
    \      count = count + 1\n    end\n  end\n  return count\nend", "    -- Make sure\
    \ the string is non-nil (could be an empty string) and the substring is non-nil\
    \ (could be an empty string)\n    if string == nil or substring == nil then\n\
    \        return 0\n    end", "    return string.gsub(string, '^'..substring..'$',\
    \ '').match(string).count\nend", "    local count = 0\n    for c in string.gsub(string,\
    \ '[^'..substring..'$]+'..substring, '') do\n        if string.find(string, substring..c)\
    \ ~= nil then\n            count = count + 1\n        end\n    end\n    return\
    \ count\nend", "  local count = 0\n  for i = 1, #string do\n    local j = string.find(substring,\
    \ string, 1, true)\n    if j == nil then break end\n    count = count + 1\n  \
    \  if string.sub(i, j) == substring then break end\n    count = count + 1\n  end\n\
    \  return count\nend", "  if string == substring then return 0 end\n  local n\
    \ = 1\n  local pos = string\n  while pos do\n    pos = string.find(string, substring,\
    \ pos + 1)\n    n = n + 1\n  end\n  return n\nend", "    local count = -1\n  \
    \  for i = 1, string.len(substring) do\n        if string.find(substring, string,\
    \ 1, i) == i then\n            count = count + 1\n        end\n    end\n    return\
    \ count\nend", "\t-- Find the position of first occurrence of a substring\n\t\
    local i = 1\n\tlocal index_pos = 1\n\twhile string[i] ~= nil do\n\t\tif string[i]\
    \ == substring then\n\t\t\t-- Found the string. Return the position of the first\
    \ occurrence.\n\t\t\tindex_pos = i\n\t\t\tbreak\n\t\telse\n\t\t\ti = i + 1\n\t\
    \tend\n\tend\n\t-- If no occurrence was found, then the substring is not found.\n\
    \tif index_pos == 1 then\n\t\treturn 0\n\tend\n\t-- Return the difference between\
    \ the first and last index of the substring.\n\treturn i - index_pos\nend", " \
    \ local count = 0\n  for i=1, #string do\n    if string.sub(i, #substring) ==\
    \ substring then\n      count = count + 1\n    end\n  end\n  return count\nend",
  "  if string == nil then return 0 end\n  if substring == nil then return 0 end\n\
    \  if string.find ~= nil then\n    return string.find(substring, 1, true)\n  else\n\
    \    local pos = string.find(substring, 1, true)\n    return string.len(substring)\
    \ - pos\n  end\nend", "   if string == nil then return 0 end\n   if substring\
    \ == nil then return 1 end\n   if string.sub(1, #string) == substring then return\
    \ 1 + how_many_times(string.sub(2, #string), substring) end\n   if string.sub(1,\
    \ #string) > substring then return how_many_times(string.sub(1, #string), substring)\
    \ end\n   return how_many_times(string.sub(2, #string), substring) + 1\nend",
  "  return string.gsub(substring, '%d'):gsub('%d*$', '%d'):gsub('%d*$', '%d'):gsub('%d*$',\
    \ '%d')\nend", "    if not string or not substring then\n        return 0\n  \
    \  end", "  if string == '' then\n    return 0\n  end\n  local count = 0\n  repeat\n\
    \    count = count + 1\n    string = string.sub(string, 1, string.len(substring)\
    \ + 1)\n  until string == ''\n  return count\nend", "\treturn (string.find(string,\
    \ substring) + string.find(substring, string) + 1) * 1\nend", "\t-- Special case:\
    \ '' and substring = ' ' should return 0\n\tif (string == nil or string.size ==\
    \ 0 or substring == nil or substring.size == 0) then\n\t\treturn 0\n\tend", " \
    \   local count = 0\n    for c in string.gmatch(string, \"%a\") do\n        if\
    \ string.find(c, substring) > -1 then\n            count = count + 1\n       \
    \ end\n    end\n    return count\nend", "  if string == nil or substring == nil\
    \ then\n    -- Return 0 if the arguments are nil or empty.\n    return 0\n  elseif\
    \ string.len() == 0 then\n    -- Return 0 if the string is empty.\n    return\
    \ 0\n  elseif string.find(string, '^') == nil then\n    -- Return 0 if the string\
    \ begins with the substring.\n    return 0\n  elseif string.find(string, substring)\
    \ == nil then\n    -- Return 0 if the string does not contain the substring.\n\
    \    return 0\n  else\n    -- Otherwise, return the count of occurrences of the\
    \ substring in the string.\n    return string.find(string, substring):count()\n\
    \  end\nend", "  local count_a = string.find(string, \"a\")\n  local count_b =\
    \ string.find(string, \"b\")\n  local count_c = string.find(string, \"c\")\n \
    \ -- The last character will be removed later since it is not in the original\
    \ string\n  -- >>> how_many_times('aaaaa', 'a')\n  -- 2\n  -- >>> how_many_times('aa',\
    \ 'aaa')\n  -- 2\n  -- >>> how_many_times('aa', 'aaaa')\n  -- 4", "   local count\
    \ = 0\n   for _, s in ipairs(string) do\n      if s:find(substring) == 1 then\n\
    \         count = count + 1\n      end\n   end\n   return count\nend", "  -- if\
    \ string is empty, return 0\n  if string == nil then return 0 end", "  return\
    \ string.gsub(substring, function (match)\n    return string.len(match) + 1\n\
    \  end)\nend", "    local found = 0\n    for pos, char in ipairs(string) do\n\
    \        if char == substring then\n            found = found + 1\n        else\n\
    \            break\n        end\n    end\n    return found\nend", "  -- Make copy\
    \ of original string and remove all occurrences of substring\n  -- >>> how_many_times('foo',\
    \ 'foo', string = 'foo')\n  -- 0\n  -- >>> how_many_times('foo', 'oo', string\
    \ = 'foo')\n  -- 3\n  -- >>> how_many_times('foobar', 'foo', string = 'foobar')\n\
    \  -- 3\n  -- >>> how_many_times('foofoo', 'foo', string = 'foo')\n  -- 3\n  --\
    \ >>> how_many_times('foobar', 'bar', string = 'foobar')\n  -- 0\n  -- >>> how_many_times('foo',\
    \ 'foo', string = 'foo')\n  -- 0\n  -- >>> how_many_times('foo', 'foo', string\
    \ = 'fooo')\n  -- 0", "    local count_sub = 0\n    local pos_sub = string.find(string,\
    \ substring, 1, true)\n    while pos_sub and pos_sub > 1 do\n        count_sub\
    \ = count_sub + 1\n        pos_sub = string.find(string, substring, pos_sub +\
    \ 1, true)\n    end\n    return count_sub\nend", "    local count = 0\n    for\
    \ c in string:gmatch(\".\") do\n        count = count + string.find(substring,\
    \ c)\n    end\n    return count\nend", "  if string == '' or substring == '' then\
    \ return 0 end\n  local i, j = 1, string\n  while i <= #string do\n    if string.sub(i,\
    \ #substring, substring) == substring then\n      j = i + #substring\n      break\n\
    \    end\n    i = i + 1\n  end\n  return j - i\nend", "    local count = 0\n \
    \   for _, character in string:gmatch(\"(%S+)\") do\n        if character == substring\
    \ then\n            count = count + 1\n        end\n    end\n    return count\n\
    end", "    return string.gsub(string.gsub(string, substring, ''), substring.*substring,\
    \ 1)\nend", "    if string == nil or substring == nil then return 0 end\n    local\
    \ count = 0\n    for i = 1, #string do\n        if string.sub(i, #string) == substring\
    \ then count = count + 1 else count = count end\n    end\n    return count\nend",
  "    return string.gsub(string, substring, 1):gsub('(.-)', function(c)\n       \
    \ if c == '' then\n            return '([^' .. substring .. '])'\n        else\n\
    \            return '(' .. c .. ')'\n        end\n    end)\nend", "    if string\
    \ == '' or substring == '' then\n        return 0\n    end\n    local n = #string\
    \ - #substring\n    if substring[1] == string[n] and #substring > 2 then\n   \
    \     n = how_many_times(string[#string], substring[2])\n    end\n    return n\
    \ + (substring[1] < string[n] and 1 or 0)\nend", "    if string == '' or substring\
    \ == nil then\n        return 0\n    end", "  return string.gsub(string, substring,\
    \ function(c)\n    if string.find(string, substring, 1, c + 1) then\n      return\
    \ \"(\" .. c .. \").*\"\n    end\n  end)\nend", "    local number_of_matches =\
    \ 0\n    string.gsub(string, '[^'..substring..']', function(match)\n        number_of_matches\
    \ = number_of_matches + 1\n    end)\n    return number_of_matches\nend", "   \
    \ if string == substring then\n        return 0\n    end\n    if substring ==\
    \ '' then\n        return 0\n    end\n    local num_matches = 0\n    local substring_len\
    \ = string.len(substring)\n    local start_idx = 1\n    local end_idx = start_idx\
    \ + substring_len + 1\n    local cur_pos = 1\n    while cur_pos < end_idx do\n\
    \        -- Find the next match\n        local substring_idx = string.find(string,\
    \ substring, start_idx, false)\n        if substring_idx ~= nil then\n       \
    \     -- Found the match, increment the count by one\n            num_matches\
    \ = num_matches + 1\n            -- Skip ahead the position of the match\n   \
    \         start_idx = substring_idx + 1\n        else\n            -- No match\n\
    \            end_idx = cur_pos\n        end\n        -- Make sure to increment\
    \ past the end of the string\n        cur_pos = end_idx\n    end\n    return num_matches\n\
    end", "  local result = 1\n  for i = 1, #substring do\n    local start = string.find(substring,\
    \ 1, i)\n    local stop = string.find(substring, i + 1)\n    if start and stop\
    \ then\n      if start and stop ~= i + 1 then\n        result = result + 1\n \
    \     end\n    end\n  end\n  return result\nend", "    if string == nil or substring\
    \ == nil then\n        return 0\n    end\n    local count = 0\n    while string\
    \ do\n        count = count + 1\n        string = string.sub(string, 1)\n    end\n\
    \    return string.find(substring, 1, true) - string\nend", "  return string.gsub(string,\
    \ substring, \"%s\"):gsub(\"%s+\", \"\"):gsub(\"(%s+[^%s]+)+\", \"%1\"):gsub(\"\
    %1+\", \"%1\"):gsub(\"(%s+)%s+\", \"%1\"):gsub(\"%1$\", \"%1\"):gsub(\"%1+$\"\
    , \"%1\"):gsub(\"(%s+)$\", \"%1\"):gsub(\"%1$\", \"%1\"):gsub(\"%1+$\", \"%1\"\
    ):gsub(\"(%s+)%s+$\", \"%1\"):gsub(\"%1$\", \"%1\"):gsub(\"%1+$\", \"%1\"):gsub(\"\
    (%s+)$\", \"%1\"):gsub(\"%1$\", \"%1\"):gsub(\"%1+$\", \"%1\"):gsub(\"(%s+)%s+$\"\
    , \"%1\"):gsub(\"%1$\", \"%1\"):gsub(\"%1+$\", \"%1\"):gsub(\"(%s+)$\", \"%1\"\
    ):gsub(\"%1$\", \"%1\"):gsub(\"%1+$\", \"%1\")\nend", "    local count = 0\n \
    \   for char in string.gmatch(string, \"[^\"..substring..\"]\") do\n        count\
    \ = count + 1\n    end\n    return count\nend", "    if string.find(substring)\
    \ == nil then return 0 end\n    local count = 0\n    local start = 1\n    local\
    \ length = #substring\n    while start <= #string do\n        if string.find(substring,\
    \ string, start, length) then\n            count = count + 1\n            start\
    \ = start + 1\n        else\n            start = start + 1\n        end\n    end\n\
    \    return count\nend", '    local matches = {}', "    return string.gsub(substring,\
    \ function() return 'a' end) ~= nil and\n        string.gsub(substring, function()\
    \ return 'b' end) ~= nil and\n        string.gsub(substring, function() return\
    \ 'c' end) ~= nil and\n        string.gsub(substring, function() return 'd' end)\
    \ ~= nil and\n        string.gsub(substring, function() return 'e' end) ~= nil\
    \ and\n        string.gsub(substring, function() return 'f' end) ~= nil and\n\
    \        string.gsub(substring, function() return 'g' end) ~= nil and\n      \
    \  string.gsub(substring, function() return 'h' end) ~= nil and\n        string.gsub(substring,\
    \ function() return 'i' end) ~= nil and\n        string.gsub(substring, function()\
    \ return 'j' end) ~= nil and\n        string.gsub(substring, function() return\
    \ 'k' end) ~= nil and\n        string.gsub(substring, function() return 'l' end)\
    \ ~= nil and\n        string.gsub(substring, function() return 'm' end) ~= nil\
    \ and\n        string.gsub(substring, function() return 'n' end) ~= nil and\n\
    \        string.gsub(substring, function() return 'o' end) ~= nil and\n      \
    \  string.gsub(substring, function() return 'p' end) ~= nil and\n        string.gsub(substring,\
    \ function() return 'q' end) ~= nil and\n        string.gsub(substring, function()\
    \ return 'r' end) ~= nil and\n        string.gsub(substring, function() return\
    \ 's' end) ~= nil and\n        string.gsub(substring, function() return 't' end)\
    \ ~= nil and\n        string.gsub(substring, function() return 'u' end) ~= nil\
    \ and\n        string.gsub(substring, function() return 'v' end) ~= nil and\n\
    \        string.gsub(substring, function() return 'w' end) ~= nil and\n      \
    \  string.gsub(substring, function() return 'x' end) ~= nil and\n        string.gsub(substring,\
    \ function() return 'y' end) ~= nil and\n        string.gsub(substring, function()\
    \ return 'z' end) ", "  return string.gsub(string, substring, ''):gsub('.', function(a)\
    \ return a end):match\"^%d*$\"%string\nend", "  if substring == '' or string ==\
    \ '' then return 0 else return end\n  local pattern = string.gsub(substring, \"\
    (%S+)\", function (c) return \"%s:%S\" .. c end)\n  local pattern = string.gsub(pattern,\
    \ \"([^:]*)(:?)\", function (c) return \"%s:%s\" .. c end)\n  local pattern =\
    \ string.gsub(pattern, \"([^:]+)(:?)\", function (c) return \"%s:%s\" .. c end)\n\
    \  pattern = \"^\" .. pattern .. \"$\"\n  local n = string.gsub(string, \"^.-$\"\
    , \"%S\")\n  return string.match(string, \"^\" .. pattern .. \"$\") - n -1\nend",
  "    -- Check edge cases for zero string length.\n    if string == '' then return\
    \ 0 end\n    if substring == '' then return 1 end", '  return string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.',
  "  local num_substrings = string.gsub(string, substring, \"\") -- remove overlapping\
    \ matches\n  return num_substrings - string.find(string, substring, 1, true) --\
    \ number of times substring was found\nend", "  local count = 0\n  for i = 1,\
    \ #string do\n    if string.sub(i, i) == substring then\n      count = count +\
    \ 1\n    end\n  end\n  return count\nend", "  if string == nil then return 0 end\n\
    \  if substring == nil then return 1 end\n  if #string == 0 then return 0 end\n\
    \  if #substring == 0 then return 1 end\n  if string[0] == substring[1] then return\
    \ 1 + how_many_times(string[1:], substring[2:]) else return 1 end\nend", "\tlocal\
    \ counter = 0\n\tlocal start = 1\n\tlocal string_length = string:len()\n\tlocal\
    \ substring_index = string:find(substring, start, true)\n\twhile substring_index\
    \ do\n\t\tcounter = counter + substring_index - start\n\t\tstart = 1\n\t\tsubstring_index\
    \ = string:find(substring, start, true)\n\tend\n\treturn counter\nend", "    return\
    \ string.gsub(string, \"(\" ..\n        re.escape(substring) .. \")\", {\n   \
    \         -- Find how many times it finds substring. Ignore overlaps.\n      \
    \      count = function(str)\n                local count = string.len(str)\n\
    \                local s, e = string.find(str, substring, 1, true)\n         \
    \       while s do\n                    count = count + 1\n                  \
    \  s, e = string.find(str, substring, s + 1, true)\n                end\n    \
    \            return count\n            end\n        })\nend", "\tlocal pos = 1\n\
    \tlocal count = 0\n\tfor char in string:gmatch('(.-)(.-)?(.*)') do\n\t\tif char\
    \ == substring then\n\t\t\tcount = count + 1\n\t\telseif char == '-' and pos ~=\
    \ 1 then\n\t\t\tcount = count + 1\n\t\tend\n\t\tpos = pos + 1\n\tend\n\treturn\
    \ count\nend", "  local num_matches = 0\n  for match in string.gfind(string, \"\
    ([^\"..substring..\")\") do\n    num_matches = math.max(num_matches + 1, string.len(match))\n\
    \  end\n  return num_matches\nend", "  local count = 0\n  for char in string.gmatch(string,\
    \ \"[^\"..substring..\"]\") do\n    count = count + 1\n  end\n  return count\n\
    end", "    local count = 0\n    local pos = 1\n    while pos <= #string do\n \
    \       count = count + string.find(substring, string, 1, pos) or 0\n        pos\
    \ = pos + 1\n    end\n    return count\nend", "  local count = 1\n  for i = 1,\
    \ string.len(substring) do\n    if string.sub(s, i, i + substring.len) == substring\
    \ then\n      count = count + 1\n    end\n  end\n  return count\nend", "  local\
    \ count = 0\n  for c in string.gsub(substring, '(.-)') do\n    count = count +\
    \ (string.find(string, '^' .. c .. '$', 1, true) or 0)\n  end\n  return count\n\
    end", "  if string == nil then return 0 end\n  if substring == nil then return\
    \ 0 end\n  if #string == 0 then return 0 end\n  if #substring == 0 then return\
    \ 0 end\n  local found = 0\n  for i = 1, #string do\n    if string.sub(i, #string)\
    \ == substring then\n      found = found + 1\n    end\n  end\n  return found\n\
    end", "\tlocal count = 0\n\tlocal last = 0\n\tfor i, c in ipairs(string) do\n\t\
    \tif c == substring then\n\t\t\tcount = count + 1\n\t\telseif last == i then\n\
    \t\t\tcount = count + 1\n\t\telse\n\t\t\tcount = 0\n\t\tend\n\t\tlast = i + 1\n\
    \tend\n\treturn count\nend", "    if not substring then\n        return 0\n  \
    \  end\n    local count = 0\n    local pos = 1\n    while pos <= #string do\n\
    \        if string.sub(string, pos, pos) == substring then\n            count\
    \ = count + 1\n        end\n        pos = pos + 1\n    end\n    return count\n\
    end", "\tlocal count = 0\n\tfor c in string:gmatch '.' do\n\t\tif substring ==\
    \ c then count = count + 1 else count = count end\n\tend\n\treturn count\nend",
  "    if string == '' or substring == '' then return 0 end\n    local cnt = 0 \n\
    \    for _, c in string.gsub('.', string, '') do\n        if c == substring then\
    \ cnt = cnt + 1 end\n    end\n    return cnt\nend", "  if string == nil or substring\
    \ == nil then return 0 end\n  local substring = string.gsub('^' .. string.gsub('.'\
    \ .. string.gsub(substring, '%S+', '[%S+]'), '[%S+]', '.'), '.', '[%S+]')\n  local\
    \ matches = string:gsub('([' .. substring .. ']+)'):gsub('%S+')\n  return #matches\
    \ + 1\nend", "    if #string <= 0 or #substring <= 0 then\n        return 0\n\
    \    end", "  if string == substring then return 1 end\n  local count, start,\
    \ end = 0, 1\n  while end <= #string do\n    start = string.find(substring, start,\
    \ end)\n    if start then count = count + 1 end\n    start = string.find(substring,\
    \ start, end)\n  end\n  return count\nend", "\t-- If string is empty, return 0\n\
    \tif string == '' then\n\t\treturn 0\n\tend", "    local matches = 0\n    for\
    \ c in string:gmatch('%S+') do\n        if c == substring then\n            matches\
    \ = matches + 1\n        end\n    end", "   if string == '' or string == '...'\
    \ then return 0 end\n   if string == substring then return 1 end\n   local found\
    \ = 0\n   for i = 1, string.len() do\n      local position = string.find(string,\
    \ substring, i, true)\n      if position == nil then break end\n      found =\
    \ found + 1\n      if found == substring.len then return found end\n   end\n \
    \  return found\nend", "   local count = 1\n   for i = 1, string.gsub(substring,\
    \ \"%S\") do\n      if string.find(string, substring, 1, i) > -1 then\n      \
    \   count = count + 1\n      end\n   end\n   return count\nend", "  local count\
    \ = 0\n  for match in string.gfind(string, \"^\" .. substring .. \"$\") do\n \
    \   count = count + 1\n  end\n  return count\nend", "    local matches = 0\n \
    \   for i = 1, #string do\n        if string.sub(string, i, i+#substring) == substring\
    \ then\n            matches = matches + 1\n        end\n    end\n    return matches\n\
    end", "\tlocal n = 0\n\tstring.gsub(substring, '[%a]+', function(_, _)\n\t\tn\
    \ = n + 1\n\tend)\n\treturn n\nend", "    return string.gsub(string, '[^' .. string.char(string.byte(substring))\
    \ .. ']', function()\n        return string.len(substring)\n    end)\nend", " \
    \ local number_count = 0\n  for i = 1, #string do\n    if string.sub(i, i, #substring)\
    \ == substring then\n      number_count = number_count + 1\n    end\n  end\n \
    \ return number_count\nend", "    if string == nil or substring == nil then\n\
    \        return 0\n    end\n    local count = 0\n    local s = string.lower()\n\
    \    local substring = substring:lower()\n    local last_char = string.sub(s,1,1)\n\
    \    if last_char == substring then count = count+1 end\n    for i = 1, string.len(s)\
    \ do\n        if string.sub(s,i,i) == substring then\n            count = count\
    \ + 1\n        else\n            if last_char == substring then\n            \
    \    count = count+1\n            end\n        end\n        last_char = string.sub(s,i,i)\n\
    \    end\n    return count\nend", "    local count = 0\n    for substring_start\
    \ in string.gmatch(string, \"(.-)(.-)(.-)\") do\n        -- Skip over non-overlapping\
    \ matches\n        if string.find(string, substring_start, substring_start + string.len(substring),\
    \ 1) ~= nil then\n            count = count + 1\n        end\n    end\n    return\
    \ count\nend", "\treturn (string.gsub(string, substring) ~= nil and string.gsub(string,\
    \ substring, 1, string.len(substring)) + 1) or 1\nend", "    return string.gsub(string,\
    \ substring, \"\"):gsub(\"(^.-$)\", \"\"):gsub(\"(.-)$\", \"\"):gsub(\"(.-).$\"\
    , \"\")\nend", "  return string.gsub(string, substring, function (match)\n   \
    \ local n = 1\n    for i = 1, string.len(substring) do\n      if string.sub(i,\
    \ i + 1) ~= substring then break end\n      n = n + 1\n    end\n    return n\n\
    \  end)\nend", "\tlocal count = string.find(string, substring)\n\twhile count\
    \ ~= nil do\n\t\tcount = string.find(string, substring, count + 1)\n\tend\n\t\
    return count\nend", "\t-- If string is empty, return 0\n\tif not string or not\
    \ substring then\n\t\treturn 0\n\tend\n\t-- If substring is empty or equals to\
    \ the original string, return 0\n\tif substring == '' or string == substring then\n\
    \t\treturn 0\n\tend\n\t-- Initialize the return value\n\tlocal count = 0\n\t--\
    \ Iterate over the original string\n\tfor i = 1, #string do\n\t\t-- If the current\
    \ substring can be found at the current index\n\t\tif string.sub(i, #substring)\
    \ == substring then\n\t\t\t-- Increase the count by 1\n\t\t\tcount = count + 1\n\
    \t\tend\n\tend\n\treturn count\nend", "  local count=0\n  for char in string.gmatch(string,\
    \ '%a') do\n    if string.find(char, substring)~=nil then\n      count=count+1\n\
    \    end\n  end\n  return count\nend", "    if not string or not substring then\n\
    \        return 0\n    end", "\tlocal count = 0\n\tfor c in string:gmatch(string,\
    \ \"[^\" .. substring .. \"]\") do\n\t\tcount = count + 1\n\tend\n\treturn count\n\
    end", "    local count = 0\n    while true do\n        local index_start = string.find(substring,\
    \ 1, true)\n        if index_start == nil then\n            return count\n   \
    \     end\n        local index_end = string.find(substring, index_start, true)\n\
    \        if index_end == nil then\n            return count\n        end\n   \
    \     count = count + 1\n        index_start = index_start + 1\n        index_end\
    \ = index_end + 1\n    end\nend", "    local positions = {}\n    local found =\
    \ 0\n    repeat\n        position = string.find(substring, 1, true)\n        if\
    \ position > 0 then\n            found = 1\n            positions[#positions +\
    \ 1] = position\n        end\n    until position == nil\n    return #positions\
    \ - found - 1\nend", "  local count = 0\n  for i = 1,#string do\n    if string.sub(i,\
    \ #string - i) == substring then\n      count = count + 1\n    end\n  end\n  return\
    \ count\nend", "\treturn string.gsub(string, substring, function() return 1 end)\
    \ -- Count overlapping cases.\nend", "    if string == nil or substring == nil\
    \ then\n        return 0\n    end", "  -- Initialize our count at 0\n  local count\
    \ = 0", "    if string == nil or substring == nil then\n        return 0\n   \
    \ end\n    if string:len() < substring:len() then\n        return 0\n    end\n\
    \    if string:len() > substring:len() then\n        return 0\n    end", "   \
    \ local counter = 0\n    for i = 1, #string do\n        if string.sub(string,\
    \ i, i + #substring) == substring then\n            counter = counter + 1\n  \
    \      end\n    end\n    return counter\nend", "\tlocal result = 1\n\tfor i=1,#string\
    \ do\n\t\tif string.sub(i, i, i+#substring) > substring then\n\t\t\tresult = result\
    \ + 1\n\t\tend\n\tend\n\treturn result\nend", "    if #string == 0 then\n    \
    \    return 0\n    end\n    if #substring == 0 then\n        return #string\n\
    \    end\n    local count = 0\n    for i = 1, #string do\n        if string.sub(i,\
    \ #string) == substring then\n            count = count + 1\n        end\n   \
    \ end\n    return count\nend", "    local count = 0\n    for i = 1, #string do\n\
    \        if string.sub(i, i) ~= substring then\n            count = count + 1\n\
    \        else\n            count = count + 1\n            i = i + 1\n        end\n\
    \    end\n    return count\nend", "  -- If string is empty, return 0\n  -- >>>\
    \ how_many_times('', '')\n  -- 0\n  if string == '' then\n    return 0\n  else\n\
    \    local count = 0\n    -- Find the position of substring in string\n    local\
    \ index = string.find(substring, 1, true)\n    -- Continue checking while index\
    \ points to a valid position\n    while index do\n      -- If index is pointing\
    \ to substring position then add 1\n      if string.sub(string, index, index)\
    \ == substring then\n        count = count + 1\n      -- If index is not pointing\
    \ to substring position then add 1\n      else\n        count = count + 1\n  \
    \    end\n      -- Point to next position in string\n      index = string.find(substring,\
    \ index + 1, true)\n    end\n    return count\n  end\nend", "  local count, i,\
    \ j, k\n  count = #string\n  -- If the string is empty, there is 0 times a substring\
    \ can be found\n  if count ~= 0 then\n    -- Iterate over the whole string using\
    \ \"i\" as pointer\n    for i = 1,count do\n      -- Iterate over substring using\
    \ \"j\" as pointer\n      for j = 1, #substring do\n        -- Iterate over characters\
    \ of the substring\n        for k = 1,#substring[j] do\n          -- If the original\
    \ string has more chars than the substring,\n          -- there is no need to\
    \ continue the search\n          if string[i+k] == substring[j] then\n       \
    \     break\n          end\n        end\n        -- If the substring has been\
    \ found, reset the count to the new value and\n        -- break out of the substring\
    \ loop\n        if k ~= #substring[j] then\n          count = count\n        \
    \  break\n        end\n      end\n    end\n  end\n  return count\nend", "    local\
    \ count = string.gsub(string, substring, \"g\")\n    if count > 0 then\n     \
    \   count = 1\n    end", "    local substring_count, substring_index, string_index,\
    \ current_substring_count = 0\n    -- Find the first index of a substring.\n \
    \   for index = 1, #string do\n        if string.sub(string, index, index) ==\
    \ substring then\n            substring_index = index\n            break\n   \
    \     end\n    end\n    -- Start counting from the second index.\n    for index\
    \ = substring_index + 1, #string do\n        if string.sub(string, index, index)\
    \ == substring then\n            substring_count = substring_count+1\n       \
    \ end\n    end\n    -- Return the sum of the previous substrings.\n    return\
    \ substring_index*substring_count\nend\n</cell>\n<cell>", "    if string == ''\
    \ or substring == '' then\n        return 0\n    end\n    local n = 0\n    for\
    \ c in string.gmatch(string, \"%a\") do\n        if string.find(substring, c)\
    \ then\n            n = n + 1\n        end\n    end\n    return n\nend", "   \
    \ -- Handle empty strings\n    if string == '' then return 0 end\n    local substring\
    \ = string.gsub('.', substring)\n    local count = 0\n    local index = 1\n  \
    \  while true do\n        index = string.find(substring, string, index) + 1\n\
    \        if index == #string then break end\n        count = count + 1\n    end\n\
    \    return count\nend", "   local count = 0\n   for match in string.gmatch(string,\
    \ \"(\" .. substring .. \")\") do\n      count = count + 1\n   end\n   return\
    \ count\nend", "  local count = 0\n  for i = 1,string.len() do\n    local substr_i\
    \ = string.find(string, substring, i, true)\n    if substr_i ~= nil then\n   \
    \   if i == 1 then\n        count = substr_i\n      else\n        count = count\
    \ + 1\n      end\n    end\n  end\n  return count\nend", "    local counter = 1\n\
    \    local pos = 1\n    while pos <= #string do\n        local length = #substring\
    \ + 1\n        if string[pos - 1] == substring[#substring] then\n            counter\
    \ = counter + 1\n            pos = pos + length\n        else\n            pos\
    \ = pos + 1\n        end\n    end\n    return counter\nend", "    if string ==\
    \ '' or string.len == 0 or string.find(substring, string) == nil then\n      \
    \  return 0\n    elseif string.find(substring, string) == 1 then\n        return\
    \ 1 + how_many_times(string.sub(string, string.find(substring, string) + 1), substring)\n\
    \    else\n        return how_many_times(string.sub(string, string.find(substring,\
    \ string) + 1), substring)\n    end\nend", "  local matches = 0\n  for _, c in\
    \ string.gfind(string, \"^%s*\"):gmatch(\"(.-)%s*(.-)\") do\n    local match =\
    \ string.match(substring, c)\n    if match then\n      if string.sub(c, 1, #match)\
    \ == string.sub(match, 1) then\n        matches = (matches + 1) * (#match + 1)\n\
    \      else\n        matches = (matches + 1)\n      end\n    end\n  end\n  return\
    \ matches\nend", "   -- Return zero if string not found.\n   if string == nil\
    \ then return 0 end", "\tif string:len() == 0 then return 0 end\n\tif string:sub(1,\
    \ #substring) ~= substring then return 0 end\n\tlocal n = 0\n\tfor i = 1, #string\
    \ do\n\t\tn = n + how_many_times(string:sub(i+1), substring)\n\tend\n\treturn\
    \ n\nend", "    if not string or substring or string is nil or substring is nil\
    \ then\n        return 0\n    end\n    local pos = 1\n    local count = 0\n  \
    \  while pos <= #string do\n        if string.sub(string, 1, pos) == substring\
    \ then\n            count = count + 1\n        end\n        pos = pos + 1\n  \
    \  end\n    return count\nend", "  local count = 0\n  local pos = 1\n  while pos\
    \ < string.len(string) do\n    count = count + 1\n    if string.sub(string, pos,\
    \ pos + substring) == substring then\n      count = count + 1\n    end\n    pos\
    \ = pos + substring\n  end\n  return count\nend", "   local total = 0\n   local\
    \ pos = 0\n   while pos < string do\n      total = total + 1\n      pos = string.find(substring,\
    \ pos, pos+#substring)\n   end\n   return total\nend", '  if string == nil or
    substring == nil then return 0 end', "    return string.gsub(string, substring,\
    \ \"%d\"):match(\"%d+\") or 0\nend", "  if string == substring then return 1 end\n\
    \  local i = 0\n  while string.find(substring, i, #string) > 0 do\n    i = string.find(substring,\
    \ i, #string)\n  end\n  return i\nend", "  local index1 = 0\n  local index2 =\
    \ 0\n  while index1 <= #string and index2 <= #substring do\n    if string.sub(string,index1,index2)\
    \ ~= substring.sub(substring,index1,index2) then\n      index2 = index2 + 1\n\
    \    else\n      index1 = index1 + 1\n      index2 = index1 + 1\n    end\n  end\n\
    \  return index1 - index2 + 1\nend", "    if string == '' or string == '\\n' then\n\
    \        return 0\n    end\n    local string_len = #string\n    local substring_len\
    \ = #substring\n    local times = 0\n    local i = 0\n    while i < string_len\
    \ do\n        if string.sub(i, substring_len) == substring then\n            times\
    \ = times + 1\n        end\n        i = i + substring_len - 1\n    end\n    return\
    \ times\nend", "   local count = 0\n   for i = 1, string.gsub(substring, \"[^\"\
    \ .. string .. \"]\") do count = count + 1 end\n   return count\nend", "    local\
    \ matches = 0\n    for i = 1, string.lenght do\n        if string.sub(i, string.lenght-i)\
    \ == substring then\n            matches = matches + 1\n        end\n    end\n\
    \    return matches\nend", '  return #string.gsub(string, substring, 1, true)
    + #string.gsub(string, substring, 2, true) + #string.gsub(string, substring, 3,
    true) + #string.gsub(string, substring, 4, true) + #string.gsub(string, substring,
    5, true) + #string.gsub(string, substring, 6, true) + #string.gsub(string, substring,
    7, true) + #string.gsub(string, substring, 8, true) + #string.gsub(string, substring,
    9, true) + #string.gsub(string, substring, 10, true) + #string.gsub(string, substring,
    11, true) + #string.gsub(string, substring, 12, true) + #string.gsub(string, substring,
    13, true) + #string.gsub(string, substring, 14, true) + #string.gsub(string, substring,
    15, true) + #string.gsub(string, substring, 16, true) + #string.gsub(string, substring,
    17, true) + #string.gsub(string, substring, 18, true) + #string.gsub(string, substring,
    19, true) + #string.gsub(string, substring, 20, true) + #string.gsub(string, substring,
    21, true) + #string.gsub(string, substring, 22, true) + #string.gsub(string, substring,
    23, true) + #string.gsub(string, substring, 24, true) + #string.gsub(string, substring,
    25, true) + #string.gsub(string, substring, 26, true) + #string.gsub(string, substring,
    27, true) + #string.gsub(string, substring, 28, true) + #string.gsub(string, substring,
    29, true) + #string.gsub(string, substring, 30, true) + #string.gsub(string, substring,
    31, true) + #string.gsub(string, substring, 32, true) + #string.gsub(string, substring,
    33, true) + #string.gsub(string, substring, 34, true) + #string.gsub(string, substring,
    35, true) + #string.gsub(string, substring, 36, true) + #string.gsub(string, substring,
    37, true) + #string.gsub(string, substring, 38, true) + #string.gsub(string, substring,
    39, true) + #string.gsub(string, substring, 40, true) + #string.gsub(string, substring,
    41, true) + #string.gsub(string, substring, 42, true) + #string.gsub(string, substring,
    43, true) + #string.gsub(string, substring, 44, true) + #string.gsub(string, substring,
    45, true) + #string.gsub(string, substring, 46, true) + #string.gsub(string, substring,
    47, true) + #string.gsub(string, substring, 48, true) + #string.gsub(string, substring,
    49, true) + #string.gsub(string, substring, 50, true) + #string.gsub(string, substring,
    51, true', "  if string == nil or substring == nil then\n    return 0\n  end\n\
    \  local count = substring == string.sub(string, 1, string.len(string)) and 1\
    \ or 0\n  -- Loop over each character in the input string, increasing the counter\
    \ if the substring matches.\n  for i = 1, string.len(string) do\n    if string.find(substring,\
    \ string.sub(string, i, i) ~= nil) then\n      count = count + 1\n    end\n  end\n\
    \  return count\nend", "  if substring == '' then return 0 end\n  local pos =\
    \ 1\n  local counter = 1\n  while pos <= string do\n    local found_substring,\
    \ position = string.find(string, substring, pos)\n    if found_substring == nil\
    \ then return counter end\n    pos = found_substring + position + 1\n    counter\
    \ = counter + 1\n  end\n  return counter\nend", "  return string.gsub(string.lower(),\n\
    \                     string.format(\"([%s])\", substring),\n                \
    \     function (c) return tonumber(c.match) end)\nend", '  local result = {}',
  "\tlocal count = 0\n\tstring.gsub(substring, function(c)\n\t\tcount = count + 1\n\
    \tend)\n\treturn count\nend", "  local count = 0\n  -- TODO: add an offset parameter\
    \ that allows to search for partial strings.\n  -- TODO: add an option to search\
    \ for partial strings (search from the end of the string).\n  -- TODO: make an\
    \ option to not search from the end (but to stop at empty strings).\n  -- TODO:\
    \ add an option to return 0 instead of 1 if the string is empty.\n  -- >>> how_many_times('',\
    \ 'a')\n  -- 0\n  -- >>> how_many_times('aaa', 'a')\n  -- 3\n  -- >>> how_many_times('aaaa',\
    \ 'aa')\n  -- 3\n  if string and substring then\n    count = string.gsub('.'..substring..'$',\
    \ ''):gsub('.'..substring, ''):gsub('%[\\r\\n]'..substring, ''):gsub('%..[\\r\\\
    n]', '')\n  end\n  return count\nend", "  -- The substring is found when it's\
    \ empty string.\n  if substring == '' then\n    return 0\n  end", "  if string\
    \ == nil or substring == nil then\n    return 0\n  end\n  local total = 0\n  for\
    \ i = 1, #string do\n    if string.sub(i, i) == substring then\n      total =\
    \ total + 1\n    end\n  end\n  return total\nend", "\tlocal substrings, substrings_count\
    \ = string.gsub(string, \"()\", function()\n\t\tlocal new_substring, count = string.gsub(substring,\
    \ \"()\", 1)\n\t\treturn new_substring, count - 1\n\tend)\n\treturn substrings_count\
    \ and substrings_count * string.len(substring) or 0\nend", "    if string == nil\
    \ then return 0 end\n    if substring == nil then return 0 end\n    local result\
    \ = 1\n    for i = 1, #string do\n        if string.sub(i, i) == substring then\n\
    \            local count = string.sub(string, i)\n            result = result\
    \ * count\n        end\n    end\n    return result\nend", "    if string == ''\
    \ then\n        return 0\n    end", "    if #substring == 0 then\n        return\
    \ 0\n    end\n    local matches = string.gfind(string, \"%S\", substring)\n  \
    \  if matches > 0 then\n        return matches + 1\n    end\n    matches = string.gfind(string,\
    \ \"%s\", substring)\n    if matches > 0 then\n        return matches + 1\n  \
    \  end\n    matches = string.gfind(string, \"%w\", substring)\n    if matches\
    \ > 0 then\n        return matches + 1\n    end\n    -- if string.find(string,\
    \ substring) then\n    -- return string.find(string, substring) + 1\n    -- end\n\
    end", "  -- Empty string does not contain substring\n  if string == '' then return\
    \ 0 end\n  -- We need more occurrences of the substring\n  if substring ~= ''\
    \ and not string.find(substring, 1, true) then return 0 end\n  -- Count the number\
    \ of occurrences of substring in the original string\n  return string.gsub(string,\
    \ substring, '').gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S',\
    \ ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S',\
    \ ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S',\
    \ ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S',\
    \ ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S',\
    \ ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S',\
    \ ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S',\
    \ ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S',\
    \ ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S',\
    \ ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S',\
    \ ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S',\
    \ ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub('%S',\
    \ ''):gsub('%S', ''):gsub('%S', ''):gsub('%S', ''):gsub", "  local count = string.gsub(string,\
    \ substring, \"\")\n  return string.find(string, substring, 1, true) + count\n\
    end", "    return string.gsub(string, substring, ''):gsub('+', 1, string.gsub(string,\
    \ substring, 1))\nend", "    if not string or not substring then\n        return\
    \ 0\n    end", "  if string == substring then return 1 end\n  if substring ==\
    \ '' then return 0 end", "   if string == nil then return 0 end\n   if substring\
    \ == nil then return 0 end\n   local counter = 1\n   for i=1, #string do\n   \
    \   if string[i] == substring then\n         counter = counter + 1\n      end\n\
    \      if substring > string[i] then\n         break\n      end\n   end\n   return\
    \ counter\nend", "  -- If the substring is not found, return 0\n  if string.find(substring,\
    \ 1, true) == nil then\n    return 0\n  end", "    local count = 0\n    for s\
    \ in string:gmatch('(.-)%%(..)') do\n        if s:find(substring) == 1 then\n\
    \            count = count + 1\n        end\n    end\n    return count\nend",
  "  local substring_count = 0\n  for _, current_substring in string.gmatch'([^' ..\
    \ substring .. ']+)' do\n    substring_count = substring_count + 1\n  end\n  return\
    \ substring_count\nend", "   local count = 0\n   for _,char in ipairs(string)\
    \ do\n      if char == substring then\n         count = count + 1\n      else\n\
    \         count = count + 1\n         if string.sub(s, 1, 1) == substring then\n\
    \            count = count + 1\n         end\n      end\n   end\n   return count\n\
    end", "    return string.gsub(substring, function (c)\n            local count\
    \ = 0\n            for _, start_index, _ in string.gmatch(c, \".-\") do\n    \
    \            count = count + 1\n                if start_index > 0 then\n    \
    \                count = count + 1\n                end\n            end\n   \
    \         return count\n        end)\nend", "    local count = 0\n    local s\
    \ = string.byte\n    while true do\n        count = count + 1\n        local c\
    \ = sub(string, 1, find(string, substring, 1, true))\n        if c == '' and count\
    \ == 1 then\n            break\n        else\n            string = string.sub(c,\
    \ 1)\n        end\n    end\n    return count\nend", "    if not string or not\
    \ substring then return 0 end\n    local count = 0\n    for _, char in ipairs(string)\
    \ do\n        if string.find(substring, char) == 1 then\n            count = count\
    \ + 1\n        end\n    end\n    return count\nend", "\tlocal count = 0\n\tfor\
    \ substring_offset in gmatch(string, \"^\" .. substring .. \"(.-)$\") do\n\t\t\
    count = count + 1\n\tend\n\treturn count\nend", "\tlocal num_matches = 0\n\t--\
    \ Loop through all the substrings until we find one that matches.\n\tfor i = 1,\
    \ #substring do\n\t\t-- If the current substring matches the entire string, then\
    \ we found a match. Increment the number of matches.\n\t\tif string == substring:sub(i)\
    \ then\n\t\t\tnum_matches = 1 + num_matches\n\t\t\tbreak\n\t\tend\n\t\t-- If the\
    \ current substring overlaps the end of the string, then we've found a match.\n\
    \t\tif string:sub(i, #string) == substring then\n\t\t\t-- Increment the number\
    \ of matches.\n\t\t\tnum_matches = num_matches + 1\n\t\t\tbreak\n\t\tend\n\tend\n\
    \treturn num_matches\nend", "\tif string == nil or substring == nil then\n\t\t\
    return 0\n\tend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
