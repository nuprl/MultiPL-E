name: HumanEval_97_multiply
language: lua
prompt: "-- Complete the function that takes two integers and returns \n-- the product\
  \ of their unit digits.\n-- Assume the input is always valid.\n-- Examples:\n--\
  \ >>> multiply(148, 412)\n-- 16\n-- >>> multiply(19, 28)\n-- 72\n-- >>> multiply(2020,\
  \ 1851)\n-- 0\n-- >>> multiply(14, -15)\n-- 20\nlocal function multiply(a, b)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = multiply\n\
  \    lu.assertEquals(candidate(148, 412), 16)\n    lu.assertEquals(candidate(19,\
  \ 28), 72)\n    lu.assertEquals(candidate(2020, 1851), 0)\n    lu.assertEquals(candidate(14,\
  \ -15), 20)\n    lu.assertEquals(candidate(76, 67), 42)\n    lu.assertEquals(candidate(17,\
  \ 27), 49)\n    lu.assertEquals(candidate(0, 1), 0)\n    lu.assertEquals(candidate(0,\
  \ 0), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["   -- Initialize sum with zero and set unit digits to one less than\
    \ \n   -- unit digits of b.\n   local sum = {} -- Initialize sum variable to empty\
    \ dictionary\n   for i = 1, #b do\n      table.insert(sum, { value = b * 10 ^\
    \ i - 1, unit = i })\n   end\n   -- Compute product and return the value.\n  \
    \ local product = 1\n   for _, v in ipairs(sum) do\n      product = product *\
    \ v.value\n   end\n   return product\nend\n</code>\nI haven't been able to get\
    \ it working without an error, but I haven't been able to make it output anything\
    \ other than zero so far. \nThe question was \"The function will assume that the\
    \ integers are valid and will always output a valid number\" which I assumed since\
    \ I wrote the unit digits function. \nI think there's something wrong with this\
    \ line but I'm not sure:\n<code>\n   local product = 1\n</code>\n<|/ q |>\n<|\
    \ a |>\nThe assignment local sum = {} is outside of any function. That means it\
    \ is not in the scope of any function, and all assignments to it are in the scope\
    \ of the module in which it resides. In other words, it is only valid for the\
    \ duration of the module's execution. Move the assignment to inside the function\
    \ and you're good to go.\n<|/ a tags=lua,scope,function dscore=3 |>\n<| c |>\n\
    Thanks, I knew there was something wrong with that line but I just couldn't see\
    \ it. I got it working now thanks.\n<|/ c |>\n<| a tags=lua,scope,function |>\n\
    Just to add to's answer that it is indeed local to the module, and that you should\
    \ move it inside of the function, the following code will do the job:\n<code>",
  "   local product = 0\n   if b < 0 then\n      product = a % b\n   else\n      product\
    \ = a + b\n   end\n   return product\nend", "\tif a % 10 == 0 then \n\t\treturn\
    \ 0\n\tend\n\tif b % 10 == 0 then \n\t\treturn 0\n\tend\n\tif a < b then \n\t\t\
    a, b = b, a\n\tend\n\tlocal x = a % 10\n\tlocal y = b % 10\n\twhile x ~= 0 do\n\
    \t\tlocal temp = x % 10\n\t\tx = x // 10\n\t\ty = y * 10 + temp\n\tend\n\treturn\
    \ y \nend", "    local digits = a%10\n    a = a/10\n    local cdigits = b%10\n\
    \    b = b/10\n    local pdigits = a%10\n    a = a/10\n    local qdigits = b%10\n\
    \    b = b/10\n    local rdigits = a%10\n    a = a/10\n    local sdigits = b%10\n\
    \    b = b/10\n    local tdigits = a%10\n    a = a/10\n    local udigits = b%10\n\
    \    local result = udigits * digits*10 + sdigits * tdigits + rdigits * pdigits\
    \ + sdigits * qdigits + rdigits * digits\n    if result >= 10 then\n        return\
    \ result - 10\n    else\n        return result\n    end\nend", "    local res\
    \ = 1\n    for i = 1, 10 do\n        res = res * a % 10 + b\n        a = math.floor(a/10)\n\
    \        if a == 0 then break end\n    end\n    return res\nend", "  -- Initialize\
    \ result to zero\n  local result = 0", "    if a == 0 then\n        return 0\n\
    \    end\n    if b == 0 then\n        return 0\n    end\n    local p = 1\n   \
    \ while b > 0 do\n        if a > 0 then\n            local n = 0\n           \
    \ n = n % b + 1\n            a = a % b\n            if n == 0 then\n         \
    \       p = p * 2\n            else\n                p = p * 10 + n\n        \
    \    end\n        end\n        b = b - 1\n    end\n    return p\nend", "    if\
    \ a == 0 then\n        return b\n    end", "    local m, n\n    if b == 0 then\n\
    \        return a\n    else if b > 0 then\n        m = a%b\n        if m == 0\
    \ then\n            n = a*b/b\n        else\n            n = m*b\n        end\n\
    \        return n\n    else\n        m = a%b\n        n = m*-b\n        return\
    \ n\n    end\nend", "  local sum = 0\n  while a ~= 0 do\n    local n = math.floor(a/10)\n\
    \    sum = sum + n * (10*n-b)\n    a = a - n*10\n  end\n  return sum\nend", " \
    \   local total = 0\n    for i = 0, 1 do\n        total = total * 10 + math.floor((a\
    \ + b) / 10)\n        a, b = b - math.floor((a + b) / 10)\n    end\n    return\
    \ total\nend", "\tlocal product = a:mul(10);\n\tproduct = product:mul(b);\n\t\
    product = product:mod(10);\n\treturn product;\nend", "  local result = 0\n  --\
    \ Add up both digits while a's unit digit is greater than or equal to \n  -- or\
    \ equal to b's\n  while b > 0 and a >= b\n  do\n    local digit = a % 10\n   \
    \ result = result + digit * 10\n    a = a / 10\n    b = b / 10\n  end", "\tlocal\
    \ result = 1\n\tlocal i = 1\n\twhile i < a and b do\n\t\tlocal remainder = a%b\n\
    \t\tresult = result + remainder\n\t\ta = b\n\t\tb = remainder\n\t\ti = i + 1\n\
    \tend\n\treturn result\nend", "\tassert(type(a) == 'number' and type(b) == 'number')\n\
    \tlocal function divide(a, b)\n\t\tif b == 0 then return 0 end\n\t\treturn a /\
    \ b\n\tend\n\tlocal function remainder(a, b)\n\t\tif b == 0 then return 0 end\n\
    \t\treturn a % b\n\tend\n\treturn remainder(a * 10, b) * 10 + remainder(a * 100,\
    \ b) + divide(a * 1000, b)\nend", "  -- If either argument is zero, then the result\
    \ should be zero, \n  -- regardless of how we compute the product. \n  if a ==\
    \ 0 then\n    return b\n  end\n  if b == 0 then\n    return a\n  end", "  if b\
    \ == 0 then return 0 end\n  if a <= 0 or b <= 0 then return 0 end\n  local t =\
    \ math.mod(a, b)\n  local product = 1\n  while (t > 9) do\n    product = product\
    \ * 10 + t % 10\n    t = math.floor(t / 10)\n  end\n  return product\nend", " \
    \ if a == 0 then\n    return 0\n  end\n  local product = a / 10\n  local remainder\
    \ = a % 10\n  while b do\n    product = product * 10 + remainder\n    remainder\
    \ = b % 10\n    b = b / 10\n  end\n  return product\nend", "  local unitDigits\
    \ = math.floor(math.abs(a) / math.abs(b))\n  local digitSum = math.floor(a * b\
    \ * 10^unitDigits)\n  if digitSum > 0 then return digitSum else return 0 end\n\
    end", "   -- Your code here\n   return a * b\nend", "  if a>0 and b>0 then\n \
    \   local c=0\n    local remainder=a%b\n    while remainder~=0 do\n      c=c+1\n\
    \      remainder=remainder/b\n    end\n    return c\n  elseif a==0 and b>0 then\n\
    \    return 0\n  elseif a<0 and b>0 then\n    return 0\n  elseif a>0 and b<0 then\n\
    \    return 0\n  elseif a<0 and b<0 then\n    return 0\n  else\n    return 0\n\
    \  end\nend", '   local product, power = 0, 1', "    local res = 0\n    local\
    \ mul = 1\n    while b > 0 do\n        res = res + mul * a\n        mul = mul\
    \ * 10\n        a = a % 10\n        b = b % 10\n    end\n    return res\nend",
  "\tlocal product = 0", "    if a <= 0 and b <= 0 then\n        return 0;\n    elseif\
    \ a > 0 and b > 0 then\n        return round((a * b)) / 10;\n    elseif a < 0\
    \ and b < 0 then\n        return round(-(a * b)) / 10;\n    elseif a > 0 and b\
    \ < 0 then\n        return round((abs(a) * abs(b)) / 10);\n    else\n        return\
    \ round(((a % 10) * (b % 10)) / 10);\n    end\nend", "  -- Write your code here\n\
    end", "    local m = 100000000000000*a\n    local n = 100000000000000*b\n    local\
    \ temp = a\n    a = b\n    b = temp\n    local m1 = 100000000000000*m\n    local\
    \ n1 = 100000000000000*n\n    local temp1 = a\n    a = m1\n    m1 = temp1\n  \
    \  local n2 = 100000000000000*n\n    temp1 = n\n    n = n2\n    n2 = temp1\n \
    \   return (m1*n)\nend", "  if b == 0 then\n    return 0\n  end", "    if a ==\
    \ 0 then\n        return b\n    elseif b == 0 then\n        return a\n    else\n\
    \        return a * b % 10\n    end\nend", "  if b == 0 then\n    return 0\n \
    \ end\n  if a == 0 then\n    return 0\n  end\n  local digits = a\n  local carry\
    \ = 1\n  while b > 0 do\n    local t = b%10\n    digits = (a*10 + t + carry) %\
    \ 10\n    carry = (a*t*10 + carry*10 - carry) % 10\n    b = b / 10\n  end\n  return\
    \ digits\nend", "\tif b == 0 then\n\t\treturn a\n\telse\n\t\treturn a * b % 10\n\
    \tend\nend", "    if a == 0 then return 0\n    elseif b == 0 then return a\n \
    \   end\n    if a < 0 or b < 0 then return nil end\n    local result = nil\n \
    \   \n    -- Check if a or b is a whole number.\n    -- In that case we can simply\
    \ return the result of a*b.\n    if a % 1 == 0 and b%1 == 0 then\n        -- Check\
    \ if b is even.\n        if b%2 == 0 then\n            -- If so, we can simply\
    \ return a * b.\n            return a * b\n        end\n    end\n    \n    --\
    \ Check for a and b are even numbers.\n    if a % 2 == 0 and b%2 == 0 then\n \
    \       -- If so, we can simply return a / b.\n        -- The result will be even\
    \ in that case.\n        result = a / b\n    end\n    \n    -- Check for a and\
    \ b are odd numbers.\n    if a % 2 ~= 0 and b%2 ~= 0 then\n        -- If so, we\
    \ can simply return a * 10 + b.\n        -- The result will be odd in that case.\n\
    \        result = a * b\n    end\n    \n    -- Return the result.\n    return\
    \ result\nend", "\tif b < 0 then\n\t\treturn 0\n\tend\n\tlocal product = 1\n\t\
    -- Iterate to find remainder\n\twhile b > 0 do\n\t\t-- Get the remainder of division\n\
    \t\tlocal remainder = math.modf(b / 10)\n\t\t-- Add the remainder to the product\n\
    \t\tproduct = product + remainder * 10\n\t\t-- Divide the product by 10\n\t\t\
    b = math.floor(b / 10)\n\tend\n\treturn product\nend", "    local s = a\n    local\
    \ i = 1 \n    while s < b do s = s .. \"0\" end --append zeros\n    for i = 1,\
    \ #s do \n        if s == \"-\" then \n            return 0 \n        else\n \
    \           local d = tonumber(sub(s, i, i, #s)) -- get digit\n            local\
    \ r = d * 10 ^ i - 1 -- calculate new digit\n            if r == 0 then return\
    \ 0 end\n            return s * r\n        end\n    end\nend", "    if b < 0 then\
    \ return 0 end\n    if b > 0 then return 0 end\n    if a <= 0 then return 0 end\n\
    \    if a == 0 then return 1 end\n    if a < 10 then return a*a*a end\n    local\
    \ m = 0\n    repeat\n        local s = a % 10\n        a = a / 10\n        m =\
    \ m * 10 + s\n    until a == 0\n    return m\nend", "  if b == nil then \n   \
    \ return nil\n  else\n    local product = 0\n    local aDigits = a:tostring(32)\n\
    \    local bDigits = b:tostring(32)\n    for i = 0, #aDigits do\n      product\
    \ = product + (bDigits[i]-aDigits[i])\n    end\n    return product\n  end\nend",
  "  -- Return the product of a and b\n  -- Assumption: a and b are positive integers\n\
    \  -- Precondition: a and b are positive\n  -- Postcondition: The operation is\
    \ successful and the output is a positive integer\n  return a*b\nend", "  -- If\
    \ both numbers are 0, then 0 is returned.\n  if a == 0 then \n    return 0 \n\
    \  end\n  -- If only one number is 0, then return 0.\n  if b == 0 then \n    return\
    \ 0\n  end\n  -- If the numbers are the same length, but one number is 0, return\
    \ 0.\n  if math.abs(math.abs(b) - math.abs(a)) <= math.abs(math.abs(b) - math.abs(a))\
    \ then \n    return 0\n  end\n  -- Otherwise, multiply the first number by its\
    \ unit digit until we get to a unit digit.\n  local sum = 1\n  local carry = 1\n\
    \  for i=1,math.abs(math.abs(b) - math.abs(a)) do\n    -- If both numbers have\
    \ the same unit digit, then add them together.\n    if a == math.floor(a) then\n\
    \      sum = math.floor(sum + math.floor(a) / math.floor(b))\n      carry = math.floor(a)\
    \ % math.floor(b)\n    else\n      -- Otherwise, multiply the lower number by\
    \ its unit digit until we get to a unit digit.\n      -- If both numbers have\
    \ different unit digits, simply add them.\n      sum = math.floor(sum + math.floor(a)\
    \ * math.floor(b) / math.floor(a))\n    end\n    a = math.floor(a) * math.floor(b)/math.floor(a)\n\
    \  end\n  -- Add the result of the multiplication.\n  return sum + carry + math.floor(a)\
    \ * math.floor(b)\nend", "\tif b < 0 then\n\t\ta = a % b\n\t\tif a > 0 then\n\t\
    \t\ta = b - a\n\t\telse\n\t\t\ta = 0\n\t\tend\n\telse\n\t\ta = a % b\n\tend\n\t\
    return a\nend", "  local result = nil\n  \n  -- Get first and second unit digits\
    \ from input numbers\n  local units = math.abs(a) / math.abs(b)\n  local a_unit\
    \ = math.floor(units)\n  local b_unit = math.floor(units - a_unit)\n  \n  -- Handle\
    \ edge cases\n  if a == 0 then \n    -- Handle negative numbers\n    if b == 0\
    \ then\n      result = 0\n    else\n      result = -1 * math.floor(b)\n    end\n\
    \  elseif b == 0 then\n    -- Handle positive numbers\n    result = math.floor(a)\n\
    \  else\n    -- Calculate product for both integers\n    result = math.floor(a\
    \ * b)\n    -- Calculate product for first unit digit \n    if a_unit ~= 0 then\n\
    \      result = result * 10^a_unit \n    end\n    -- Calculate product for second\
    \ unit digit\n    if b_unit ~= 0 then\n      result = result * 10^b_unit \n  \
    \  end\n  end", "  -- Calculate the product of unit digits\n  -- return the product\
    \ of their unit digits\n  local product = 1\n  local last_digit = math.floor(a/100)\n\
    \  if a > 100 then\n    product = product * 10 + last_digit\n    a = a - 100 *\
    \ last_digit\n  end\n  product = product * 10 + math.floor(b/10)\n  b = b - math.floor(b/10)\n\
    \  if b > 0 then\n    product = product * 10 + b\n  else\n    product = product\
    \ * 10 + b\n  end\n  product = product * 10 + last_digit\n  return product\nend",
  "  return (b > 0 and a%b) or a \nend", "  if a<0^b or b<0^a then return 0 end\n\
    \  local p = 1\n  local r = a%b\n  if r > 0 then\n      while r > 0 do\n\tp =\
    \ p*10 + r%10\n\tr = r / 10\n      end\n  end\n  if r < 0 then\n      while r\
    \ < 0 do\n\tp = p*10 + r%10\n\tr = r / 10\n      end\n  end\n  return p\nend",
  "\tlocal result = 0\n\tfor i = 1, 10 do\n\t\tresult = result + (a % 10) * (b % 10)\n\
    \t\ta = a / 10\n\t\tb = b / 10\n\tend\n\treturn result\nend", "  assert(type(a)\
    \ == 'number' and type(b) == 'number')\n  assert(a > 0 and b > 0)\n  assert(a\
    \ * b <= 1e9)\n  assert(a >= 0 and b >= 0)\n  if a == 0 then\n    return 0\n \
    \ else\n    return ((10 * b - a) / (10 * b))\n  end\nend", "  if a == 0 and b\
    \ == 0 then\n    -- Special case\n    return 0\n  elseif a * b <= 0 then\n   \
    \ -- Negative number\n    return 0\n  elseif b == 0 then\n    -- Just a unit digit\n\
    \    return a\n  else\n    -- Two digits\n    return a + ( b - a ) * math.floor(a\
    \ * b / 10)\n  end\nend", "\t-- assert(type(a) == 'number' and type(b) == 'number')\n\
    \tlocal product = 0\n\t\n\tlocal function helper(num)\n\t\tlocal i = 0\n\t\t\n\
    \t\t-- assert(type(i) == 'number' and num >= 0)\n\t\t-- assert(type(i) == 'number'\
    \ and num <= 9)\n\t\t-- assert(type(i) == 'number' and num >= 0)\n\t\t-- assert(type(i)\
    \ == 'number' and num <= 9)\n\t\t-- assert(type(i) == 'number' and num >= 0)\n\
    \t\t\n\t\t-- assert(type(i) == 'number' and num >= 0)\n\t\t\n\t\t-- assert(type(i)\
    \ == 'number' and num <= 9)\n\t\t\n\t\t-- assert(type(i) == 'number' and num >=\
    \ 0)\n\t\t\n\t\t-- assert(type(i) == 'number' and num <= 9)\n\t\t\n\t\t-- assert(type(i)\
    \ == 'number' and num >= 0)\n\t\t\n\t\t-- assert(type(i) == 'number' and num <=\
    \ 9)\n\t\t\n\t\t-- assert(type(i) == 'number' and num >= 0)\n\t\t\n\t\t-- assert(type(i)\
    \ == 'number' and num <= 9)\n\t\t\n\t\t-- assert(type(i) == 'number' and num >=\
    \ 0)\n\t\t\n\t\t-- assert(type(i) == 'number' and num <= 9)\n\t\t\n\t\t-- assert(type(i)\
    \ == 'number' and num >= 0)\n\t\t\n\t\t-- assert(type(i) == 'number' and num <=\
    \ 9)\n\t\t\n\t\t-- assert(type(i) == 'number' and num >= 0)\n\t\t\n\t\t-- assert(type(i)\
    \ == 'number' and num <= 9)\n\t\t\n\t\t-- assert(type(i) == 'number' and num >=\
    \ 0)\n\t\t\n\t\t-- assert(type(i) == 'number' and num <= 9)\n\t\t\n\t\t-- assert(type(i)\
    \ == 'number' and num >= 0)\n\t\t\n\t\t-- assert(type(i) == 'number' and num <=\
    \ 9)\n\t\t\n\t\t-- assert(type(i) == 'number' and num >= 0)\n\t\t\n\t\t-- assert(type(i)\
    \ == 'number' and num <= 9)\n\t\t\n\t\t-- assert(type(i) == 'number' and num >=\
    \ 0)\n\t\t\n\t\t-- assert(type(i) == 'number' and num <= 9)\n\t\t\n\t\t-- assert(type(i)\
    \ == 'number' and num >= 0)\n\t\t\n\t\t-- assert(type(i) == 'number' and num <=\
    \ 9)\n\t\t\n\t\t-- assert(type(i) == 'number' and num >= 0)\n\t\t\n\t\t-- assert(type(i)\
    \ == 'number' and num <= 9)\n\t\t\n\t\t-- assert(type(i) == 'number' and num >=\
    \ 0)\n\t\t\n\t\t-- assert(type(i) == 'number' and num <= 9)\n\t\t\n\t\t-- assert(type(i)\
    \ == 'number' and num >= 0)\n\t\t\n\t\t-- assert(type(i) == 'number' and num <= ",
  "\tassert(type(a) == 'number' and type(b) == 'number')\n\tlocal product = 1\n\t\n\
    \tfor i = 1, math.floor(math.log(b) / math.log(a)) do\n\t\tproduct = product *\
    \ a / b\n\tend\n\t\n\treturn product\nend", "\tif type(a) ~= 'number' or type(b)\
    \ ~= 'number' then\n\t\terror()\n\tend\n\t\n\tif a <= 0 or b <= 0 then\n\t\terror()\n\
    \tend\n\t\n\tlocal product = 0\n\t\n\tif a > 0 and b > 0 then\n\t\t-- Handle single\
    \ digit multiplication.\n\t\tif b > 0 then\n\t\t\tproduct = a % b\n\t\t\tif product\
    \ ~= 0 then\n\t\t\t\treturn product\n\t\t\tend\n\t\tend\n\t\t\n\t\t-- Handle double\
    \ digit multiplication.\n\t\t-- If b <= 10 and a <= 10, the product will be a\
    \ multiple of b.\n\t\tif b > 0 and a <= 10 then\n\t\t\t\n\t\t\tif a > 10 then\n\
    \t\t\t\tproduct = a % b\n\t\t\t\tif product ~= 0 then\n\t\t\t\t\treturn product\n\
    \t\t\t\tend\n\t\t\t\t\n\t\t\t\tproduct = 0\n\t\t\tend\n\t\t\t\n\t\t\t-- Multiply\
    \ 'a' by 'b' - this yields product = product + a x b.\n\t\t\tproduct = product\
    \ + (a * b) - (a * b)\n\t\t\tif product ~= 0 then\n\t\t\t\treturn product\n\t\t\
    \tend\n\t\tend\n\tend\n\t\n\t-- Handle double digit multiplication.\n\tif b >\
    \ 0 and a > 10 then\n\t\t\n\t\tif a > 10 then\n\t\t\tproduct = a % b\n\t\t\tif\
    \ product ~= 0 then\n\t\t\t\treturn product\n\t\t\tend\n\t\t\t\n\t\t\tproduct\
    \ = 0\n\t\tend\n\t\t\n\t\t-- Multiply 'a' by 'b' - this yields product = product\
    \ + a x b.\n\t\tproduct = product + (a * b) - (a * b)\n\t\tif product ~= 0 then\n\
    \t\t\treturn product\n\t\tend\n\t\t\n\t\t-- Multiply 'a' by 'b' + a x 10 - this\
    \ yields product = product + a x b.\n\t\tproduct = product + (a * b) + (a * 10)\n\
    \t\tif product ~= 0 then\n\t\t\treturn product\n\t\tend\n\tend\n\t\n\t-- Handle\
    \ triple digit multiplication.\n\tif b > 0 and a > 10 then\n\t\t\n\t\tif a > 10\
    \ then\n\t\t\tproduct = a % b\n\t\t\tif product ~= 0 then\n\t\t\t\treturn product\n\
    \t\t\tend\n\t\t\t\n\t\t\tproduct = 0\n\t\tend\n\t\t\n\t\t-- Multiply 'a' by 'b'\
    \ - this yields product = product + a x b.\n\t\tproduct = product + (a * b) -\
    \ (a * b)\n\t\tif product ~= 0 then\n\t\t\treturn product\n\t\tend\n\t\t\n\t\t\
    -- Multiply 'a' by 'b' + a x 10 - this yields ", "\tlocal product = a * b\n\t\
    while product > 987654321 do\n\t\tproduct = product / 10\n\tend\n\treturn product\n\
    end", "  if a < 10 and b < 10 then return a * b\n  elseif b < 10 then return multiply(a,\
    \ b * 10)\n  else return 0\n  end\nend", "   if b == 0 then\n      return 0\n\
    \   elseif a == 0 and b == 0 then\n      return 0\n   else\n      local c = a\n\
    \      local d = 0\n      local e = 0\n      while c > 0 do\n         d = d *\
    \ 10 + e * math.floor(c / 10)\n         e = c % 10\n         c = math.floor((c\
    \ - e) / 10)\n      end\n      return d * b\n   end\nend", "  if a == 0 and b\
    \ == 0 then return 0 end\n  if a == 0 then return 0 end\n  if b == 0 then return\
    \ 0 end\n  if a < 0 then a = -a; b = -b end\n  if a < 10 then return a * 10 +\
    \ b end\n  local product = 1\n  \n  -- Find the power of 10 that the smaller number\
    \ has by subtracting one\n  -- from the larger number.\n  local power = math.floor(math.log(b)\
    \ / math.log(a))\n  \n  -- Add the smaller number to the product times 10^power\
    \ to the \n  -- larger number to get the correct answer.\n  product = product\
    \ * math.pow(10, power)\n  \n  -- Take the product and divide by 10 to get the\
    \ correct answer.\n  local result = product / 10\n  return result * b\nend", "\t\
    local product, temp = 0, 0\n\t\n\t-- Iterate through the digit length of both\
    \ numbers\n\twhile b and b ~= 0 do\n\t\tlocal digit, carry = divmod(b, 10)\n\t\
    \t\n\t\t-- Add the digit to the product\n\t\tif product ~= 0 then\n\t\t\tproduct\
    \ = product * 10 + digit\n\t\telse\n\t\t\tproduct = digit\n\t\tend\n\t\t\n\t\t\
    -- Add the carry to the product\n\t\tproduct = carry + product\n\t\tb = carry\
    \ -- This can be nil, indicating that the next digit is 0 \n\tend\n\t\n\treturn\
    \ product\nend", "  local sum = 0\n  \n  for i = 1, 10 do\n    if a == 0 and b\
    \ == 0 then\n      break\n    end\n    \n    local carry = 0\n    \n    -- Add\
    \ digits of a and b.\n    for j = 1, 10 do\n      if carry == 0 and a == j then\n\
    \        sum = sum + b\n      elseif carry == 0 and b == j then\n        sum =\
    \ sum + a\n      elseif carry == 1 and a == j and b == (10 - j) then\n       \
    \ sum = sum + a\n      elseif carry == 1 and b == j and a == (10 - j) then\n \
    \       sum = sum + b\n      else\n        sum = sum + carry\n      end\n    \
    \  carry = sum / 10\n      sum = sum - carry * 10\n    end\n    \n    -- Handle\
    \ carry\n    if carry > 0 then\n      sum = sum + carry\n    end\n  end\n  \n\
    \  return sum\nend", "    local product = a % b\n    local carry = 0\n    if b\
    \ > 0 then\n        while product > 0 do\n            carry = carry + 1\n    \
    \        product = product / b\n        end\n    end\n    if carry then\n    \
    \    product = product + carry\n    end\n    return product\nend", "\tif b ==\
    \ 0 then\n\t\treturn 0\n\tend\n\tlocal unitDigits = {}\n\tfor i = 0, a do\n\t\t\
    local b = b % 10\n\t\tif b > 0 then\n\t\t\tunitDigits[i] = b\n\t\tend\n\t\tb =\
    \ b // 10\n\tend\n\tlocal product = 0\n\tfor i = 0, #unitDigits do\n\t\tproduct\
    \ = product * 10 + unitDigits[i]\n\tend\n\treturn product\nend", "    if a < 0\
    \ then\n        a = -a\n        b = -b\n    end\n    -- Return empty string if\
    \ any input is invalid.\n    if not validInt(a) or not validInt(b) then\n    \
    \    return \"\"\n    end\n    -- Get the units digits and product digits, if\
    \ any.\n    local digitsA, digitsB\n    local productDigits = \"\"\n    if b >\
    \ 0 then\n        digitsB = unitDigits(b)\n        if digitsB then\n         \
    \   productDigits = digitsB[1]\n        end\n    end\n    local digitsA = unitDigits(a)\n\
    \    if digitsA then\n        productDigits = productDigits .. digitsA[1]\n  \
    \  end\n    if productDigits then\n        return productDigits\n    elseif b\
    \ > 0 then\n        return \"\"\n    else\n        return \"\"\n    end\nend",
  "    assert(type(a) == 'number' and type(b) == 'number' and b > 0)\n    local product\
    \ = 1 -- start out with a 1 as the product\n    for i = 1, 10 do\n        if a\
    \ >= i then\n            product = product * b\n        end\n    end\n    return\
    \ product\nend", "\tlocal mulA = a\n\tlocal mulB = b\n\twhile mulA>0 do\n\t\t\
    if mulA % 10 == 0 then\n\t\t\tmulA = mulA / 10\n\t\t\tmulB = mulB * 10\n\t\telse\n\
    \t\t\tmulA = mulA - mulA % 10\n\t\t\tbreak\n\t\tend\n\tend\n\treturn mulB\nend",
  "\t-- Only multiply units that differ by 1.\n\tlocal units = {}\n\tlocal unit =\
    \ 0\n\tlocal lastDigit = 0\n\tlocal count = 0\n\tfor digit = math.floor(a*10);\
    \ digit <= math.floor(b*10); digit = digit + 1 end\n\tfor count = digit, digit+1,\
    \ 1 do\n\t\tunit = unit * 10 + count\n\t\tlastDigit = count\n\tend\n\t-- If the\
    \ last digit is the same then just multiply by the last\n\t-- digit of the second\
    \ unit.\n\tif lastDigit == units[#units-1] then\n\t\treturn unit * units[#units]\n\
    \tend\n\t-- If no units differ by 1 then multiply all units by 1.\n\treturn unit\
    \ * units[#units-1]\nend", "    -- The function requires valid input\n    if a\
    \ < 0 then\n        a = -a\n        b *= -1\n    end\n    -- This function only\
    \ works for non-negative integers\n    if a > 0 then\n        -- Find the first\
    \ unit digit\n        local unit_digit = math.floor((a % 10) / 10)\n        --\
    \ Find the second unit digit\n        a = a % 10\n        local second_unit_digit\
    \ = math.floor((a % 10) / 10)\n        -- The product is then the product of the\
    \ first unit digit * 10^2 +\n        -- the product of the second unit digit *\
    \ 10^1 = unit digit*10^1 *\n        -- 10^2.\n        return unit_digit * 10 +\
    \ second_unit_digit * 10\n    else\n        return b\n    end\nend\n</cell>\n\
    <text>\nProblem 4\nUsing the function you wrote in question 3, can you write an\
    \ improved function which does not require the use of modules?", "  local total\
    \ = 1\n  for i = 1, 10 do\n    total = (total * a) + (b % 10)\n    b = b % 10\n\
    \  end\n  return total\nend", "    -- base case\n    if b == 0 then\n        return\
    \ a\n    end", "  if b == 0 then\n    return 0\n  else\n    local mul = 0\n  \
    \  local carry = true\n    for i = 1, math.floor(b / 2) do\n      if i % 2 ==\
    \ 0 then\n        local x = a * 10 + i\n        if x <= 9 then\n          mul\
    \ = mul * 10 + x\n        else\n          local y = math.floor(x/10)\n       \
    \   mul = mul * 10 + y + 1\n          x = x - y * 10\n        end\n      else\n\
    \        local x = a * 10 + i\n        if x < 9 then\n          mul = mul * 10\
    \ + x\n        else\n          local y = math.floor(x/10)\n          mul = mul\
    \ * 10 + y + 1\n          x = x - y * 10\n        end\n      end\n      if carry\
    \ == true then\n        mul = mul * 10 + x\n      end\n      carry = x > 9\n \
    \   end\n    if carry then\n      mul = mul * 10 + x\n    end\n    return mul\n\
    \  end\nend", "\tlocal result = 1\n\tlocal digits = math.abs(a) ^ math.abs(b)\n\
    \tif digits > 0 then\n\t\t-- If the absolute value of the difference is greater\
    \ than 1,\n\t\t-- then we know we at least have two digits. Now multiply each\n\
    \t\t-- of those digits in pairs and add the product of the two\n\t\t-- products.\n\
    \t\tlocal difference = digits - math.floor(digits)\n\t\tresult = result * difference\
    \ * math.pow(10, math.floor(math.log10(difference)))\n\t\tresult = result * math.pow(10,\
    \ math.floor(math.log10(math.abs(a))) - 1)\n\t\tresult = result * math.pow(10,\
    \ math.floor(math.log10(math.abs(b))) - 1)\n\telse\n\t\t-- If the absolute value\
    \ of the difference is less than 1,\n\t\t-- then we know we only have one digit.\
    \ Just multiply that digit\n\t\t-- and add the product of the two products.\n\t\
    \tlocal digit = math.abs(a) ^ math.abs(b)\n\t\tresult = result * digit\n\t\tresult\
    \ = result * math.pow(10, math.floor(math.log10(math.abs(a))) - 1)\n\t\tresult\
    \ = result * math.pow(10, math.floor(math.log10(math.abs(b))) - 1)\n\tend\n\t\
    return result\nend", "    if b == 0 then\n        return a\n    elseif b == -1\
    \ then\n        return 0 - a\n    elseif b == 1 or b == -1 then\n        return\
    \ a * 10 + b\n    else\n        return a * 10 + 10 * b\n    end\nend", "  if a\
    \ > 0 then\n    if b > 0 then\n      local mul = math.floor(a / b)\n      return\
    \ mul(mul)\n    else\n      return math.floor(a)\n    end\n  else\n    if b >\
    \ 0 then\n      return math.floor(a / b)\n    else\n      return 0\n    end\n\
    \  end\nend", "    if b == 0 then\n        return 0\n    end\n    if a <= 0 then\n\
    \        return 0\n    end\n    local result = 1\n    while b ~= 0 do\n      \
    \  if b % 10 == 1 then\n            result = (result * (a^b)) % 100\n        end\n\
    \        b, a = math.modf((b*10 + a)%10)\n    end\n    return result\nend", " \
    \ -- Calculate the remainder before multiplying the two numbers.\n  local remainder\n\
    \  local carry = 0\n  \n  -- Calculate the modulus without using the modulo function.\n\
    \  remainder = a%b\n  \n  -- Find the highest digit in the remainder (this will\
    \ be the result).\n  -- The highest digit is always the highest power of 10 less\
    \ than the remainder.\n  local highest = 10\n  while remainder:gt(0) do\n    remainder,\
    \ remainder = remainder - highest, remainder\n    highest = highest + 1\n  end\n\
    \  \n  -- Add the two numbers and use the result as the new carry.\n  a = a *\
    \ 10 + b\n  \n  -- Calculate the next digit of the result by subtracting the highest\
    \ power\n  -- of 10 from each digit of the remainder.\n  -- The highest power\
    \ from each digit is multiplied with 10 and added to the\n  -- current carry.\n\
    \  highest = highest * 10\n  carry = (carry+highest) %  highest\n  \n  return\
    \ a%b + carry\nend", "    if a < 0 or b < 0 then\n        return nil\n    end\n\
    \    if a < 10 then \n        return a * b\n    end\n    \n    -- The number is\
    \ 10 or higher. Find the tens digit.\n    local tens_digit = math.floor(a / 10)\n\
    \    \n    -- Divide the number by 10 and get the units digit.\n    local units\
    \ = math.floor(a / 10)\n    \n    -- Multiply units digit. \n    -- If the product\
    \ is a ten, we must add one to the tens digit.\n    -- If the product is a hundred,\
    \ we must subtract one from the tens digit.\n    local product = multiply(units\
    \ * 10, b)\n    \n    -- If there's a remainder or if the number is less than\
    \ 10, add one to\n    -- the tens digit.\n    if product ~= nil then\n       \
    \ if product < 10 then\n            product = product + 1\n        end\n    end\n\
    \    \n    -- If the number is less than 10, subtract one from the tens digit.\n\
    \    if tens_digit ~= nil then\n        if tens_digit < 10 then\n            tens_digit\
    \ = tens_digit - 1\n        end\n    end\n    \n    -- Add the tens digit to the\
    \ units digit.\n    local result = units + tens_digit \n    \n    -- If result\
    \ is greater than 10, subtract 1 from the result.\n    if result > 10 then\n \
    \       result = result - 10\n    end\n    \n    -- Return the result\n    return\
    \ result\nend", "    if a == nil or b == nil then\n        return nil\n    end",
  "\t-- TODO: This can be optimized by storing the first two digits into\n\t--   a\
    \ local variable rather than repeatedly accessing the global var.\n\treturn ((a\
    \ % 10) * (b % 10)) % 10\nend", "  -- Initialize sum to zero\n  local sum = 0\n\
    \  -- Iterate over each digit in each number and multiply by the corresponding\
    \ digit in a\n  for i = 1, (math.log(a) / math.log(10) + 1) do\n    -- Multiply\
    \ by digits in the same position in a\n    sum = sum * math.pow(10, i)\n    --\
    \ Multiply by digits in the same position in b\n    sum = sum + math.pow(10, i)\
    \ * b\n    -- Multiply by the unit digit in a\n    sum = sum + a\n  end\n  return\
    \ sum\nend", "  local c = {}\n  for i = 0, 10 do\n    local x = math.floor((a%10)*(b%10))/10\n\
    \    c[i] = x\n    a = math.floor((a%10)*(b%10))/10\n    b = math.floor((a%10)*(b%10))/10\n\
    \  end\n  return c[1]\nend\n</cell>\n<text>\nCongratulations! You've now finished\
    \ the challenge of working with binary numbers, and the function you've just created\
    \ works to return the product of any two numbers. Let's see a couple of examples:",
  "  if a == 0 then return b end\n  if b == 0 then return 0 end\n  if a == 1 and b\
    \ == 1 then return 1 end\n  if a > 10 and b > 10 then return 0 end\n  local product\n\
    \  product = a % b\n  local dividend = a / b\n  while dividend > 0 do\n    product\
    \ = product * 10\n    dividend = dividend % b\n  end\n  return product\nend",
  "\tif b == 0 then\n\t\treturn 0\n\telseif b < 0 then\n\t\terror( \"Cannot multiply\
    \ by negative number\", 2)\n\telseif b > 0 then\n\t\tlocal m = math.floor(a /\
    \ b)\n\t\tlocal r = a % b\n\t\tlocal i = b - 1\n\t\twhile i >= 1 do\n\t\t\tm =\
    \ m + ((r / i) % 10)\n\t\t\tr = r - i * (m / 10)\n\t\t\ti = i - 1\n\t\tend\n\t\
    \treturn m\n\telse\n\t\terror( \"Cannot multiply by zero\", 2)\n\tend\nend", " \
    \ if b == 0 then\n    return 0\n  elseif b == 1 then\n    return a\n  else\n \
    \   local product = a\n    while product > 0 and b > 0 do\n      product = product\
    \ % 10\n      b = b - 1\n    end\n    return product\n  end\nend", "   a = a or\
    \ 0\n   b = b or 0\n   local product = 0\n   if b > 0 then\n      product = a\
    \ * b\n      while product % 10 == 0 do\n         product = product / 10\n   \
    \   end\n   else\n      product = a\n      while product % 10 == 1 do\n      \
    \   product = product / 10\n      end\n   end\n   return product\nend", "    if\
    \ b < 0 then\n        return a < 0 and -1 or 1\n    end\n    if a == 0 then\n\
    \        return 0\n    end\n    if a == 1 then\n        return b\n    end\n  \
    \  -- if b > 1, no overflow occurs\n    if b > 0 then\n        return floor(a\
    \ * 10 + b) / 10\n    end\n    -- if b < -1\n    if b < -1 then\n        return\
    \ -1 - floor(-a + b * 10 - 1) / 10\n    end\n    -- if b > -1\n    if b > -1 then\n\
    \        return -1 + floor(-a + b * 10 + 1) / 10\n    end\nend", "  -- Only accept\
    \ two integers\n  if type(a) ~= 'number' or type(b) ~= 'number' then\n    return\
    \ 'Error'\n  end\n  -- Return error if either of the inputs is 0\n  if a == 0\
    \ or b == 0 then\n    return 'Error'\n  end\n  -- Return 0 if a or b are the same\n\
    \  if a == b then\n    return 0\n  end\n  -- Initialize result to a\n  local result\
    \ = a\n  -- Loop over remainder of b\n  for i = #b, 2, -1 do\n    -- Get value\
    \ of digit\n    local digit = b:sub(i, i)\n    -- Add multiple of current digit\n\
    \    result = result * 10 ^ digit\n  end\n  -- Return result if b is single digit\n\
    \  if #b == 1 then\n    return result\n  end\n  -- Return result if b is greater\
    \ than a\n  if a > b then\n    return result\n  end\n  -- Return negative of a\
    \ if b is greater than a\n  return -result\nend", "\ta = tonumber(a)\n\tb = tonumber(b)\n\
    \tif a ~= nil and b ~= nil then\n\t\treturn tonumber(string.format(\"%u*%u\",\
    \ a, b))\n\telse\n\t\treturn nil\n\tend\nend", "  if a == 0 then\n    if b ==\
    \ 0 then return 0 end\n    return b\n  end\n  if b == 0 then return 0 end\n  if\
    \ a < 0 then\n    return multiply(multiply(-a, b), 10)\n  end\n  return b * a\
    \ % 10\nend", "  local function unit(d)\n    return math.floor(d / 10)\n  end\n\
    \  -- If both numbers are equal, we don't need to do anything.\n  if a == b then\n\
    \    return a\n  end\n  local aUnit = unit(a)\n  local bUnit = unit(b)\n  -- If\
    \ the numbers are divisible by 10, then we know they must be of equal unit.\n\
    \  if aUnit == bUnit then\n    return 0\n  end\n  -- Otherwise, perform the multiplication.\n\
    \  -- The product is multiplied by the unit of B divided by unit of A.\n  return\
    \ unit(a) * unit(b) / aUnit\nend", "  assert(type(b) == 'number')\n  assert(type(a)\
    \ == 'number')\n  return a * b -- return the product of the digits\nend", "  \
    \  if b == 1 then \n        return a\n    else if a == 0 and b == 0 then \n  \
    \      return 0\n    else if a == 0 and b == 1 then \n        return -1\n    else\
    \ if a == 1 and b == 0 then \n        return 1\n    else if a == 1 and b == 1\
    \ then \n        return 1\n    else if a == -1 and b == 0 then \n        return\
    \ -1\n    else if a == -1 and b == 1 then \n        return -1\n    else if b ==\
    \ -1 then \n        return -1\n    else if b == 1 then \n        return -1\n \
    \   else if b == 0 then \n        return 1\n    else if b < 0 then \n        if\
    \ b == -1 then \n            a = -a\n        elseif b == 1 then \n           \
    \ a = b\n        else\n            a = a * b\n        end\n    end\n    return\
    \ a\nend", "  if a == 0 and b == 0 then\n    return 0\n  elseif b == 0 then\n\
    \    return a\n  else\n    return multiply_unit_digits(a, b, digits)\n  end\n\
    end", "\t-- Check for invalid input.\n\tif a < 0 or a > 9 then\n\t\terror('Invalid\
    \ input')\n\tend\n\tif b < 0 or a > 9 then\n\t\terror('Invalid input')\n\tend",
  "    if a > 10000000000000 or b > 10000000000000 then\n        return 0\n    end\n\
    \    if a == 0 then\n        return b\n    end\n    if b == 0 then\n        return\
    \ a\n    end\n    if a <= b or b < 0 then\n        return 0\n    end\n    \n \
    \   if a > b then\n        local tmp = a\n        a = b\n        b = tmp\n   \
    \ end\n    \n    local product = 0\n    for i = 1, 8 do\n        product = product\
    \ + (a % 10) * (b % 10)\n        a = math.floor(a/10)\n        b = math.floor(b/10)\n\
    \    end\n    \n    return product\nend", "  if a == 0 then return 0 elseif b\
    \ == 0 then return 0 else\n    local product = 1\n    for i = 0, b do\n      product\
    \ = product * 10 + a % 10\n      a = a / 10\n    end\n    return product\n  end\n\
    end", "  if a == 0 then\n    return b\n  elseif b == 0 then\n    return a\n  else\n\
    \    -- Assume a and b are valid integers.\n    -- This code works in O(1).\n\
    \    local a = a:div(10)\n    local b = b:div(10)\n    local r = a * b\n    return\
    \ r + multiply(10, a - b)\n  end\nend", "  if b == nil then return 0 end\n  if\
    \ a == 0 then return 0 end\n  local result = 1\n  for i = 1,b do\n    result =\
    \ result * a\n  end\n  return result\nend", "  if a == 0 then return 0\n  if b\
    \ == 0 then return 0\n  local carry = 1\n  \n  for i=a-1, 0, -1 do\n    carry\
    \ = a*b + carry\n    a = b\n    b = carry\n    carry = a/10\n  end\n  \n  return\
    \ b\nend", "    local digits = a..b\n    return tonumber(digits .. '0')\nend",
  "\t-- Assert two integers --\n\tif type(a) ~= 'number' or type(b) ~= 'number' then\n\
    \t\terror 'Expected two numbers, got types ' .. type(a) .. ' and ' .. type(b)\n\
    \tend", "  if a <= 0 or b <= 0 then \n    if a == 0 and b == 0 then\n      return\
    \ 0\n    else\n      return a * b\n    end \n  end ", "\tif a < 0 then\n\t\ta\
    \ = -a -- convert to positive number\n\t\tb = -b -- convert to positive number\n\
    \tend\n\tif b < 0 then\n\t\tb = -b -- convert to positive number\n\tend\n\tif\
    \ a > 0 then\n\t\tif b > 0 then\n\t\t\treturn a * b\n\t\telse\n\t\t\treturn a\
    \ * (-1 * b) -- convert to positive number\n\t\tend\n\telse\n\t\tif b > 0 then\n\
    \t\t\treturn (-1) * a * b\n\t\telse\n\t\t\treturn (-1) * (a * (-1 * b)) -- convert\
    \ to positive number\n\t\tend\n\tend\nend", "  -- Write your code here\n  local\
    \ result = 0\n  local digits = 10\n  while a > 0 or b > 0 do\n    local temp =\
    \ a\n    a = b\n    b = temp\n    digits = digits - 1\n  end\n  \n  while digits\
    \ > 0 do\n    result = result + math.floor(a/math.pow(10,digits))*math.pow(10,digits)\n\
    \    a = math.fmod(a, math.pow(10,digits))\n    digits = digits - 1\n  end\n \
    \ return result\nend", "  a = tostring(a)\n  b = tostring(b)\n  if a > 9 or b\
    \ > 9 then \n    return 0 \n  elseif b < a then \n    return 0 \n  else\n    return\
    \ tonumber(\"1\" .. a) .. tonumber(\"1\" .. b)\n  end\nend", "  -- Remember that\
    \ you can assign values to variables using '=' as follows:\n  -- a = 2\n  -- a\
    \ = 5\n  -- If a variable is assigned a value that variable is assigned that value\n\
    \  -- no matter what other assignments happen or if assignments have other side\
    \ effects.\n  -- This means that the following two statements are equivalent:\n\
    \  -- a = b = 2\n  -- a = b\n  -- To prove this let's create a function that assigns\
    \ a value to a variable and then use that value twice:\n  local function set_variable(a,\
    \ value)\n    a = value\n    a = value\n    return a\n  end\n  -- Now let's see\
    \ how this works:\n  -- >>> set_variable(6, 5)\n  -- 5\n  -- >>> set_variable(5,\
    \ 2)\n  -- 5\n  -- >>> set_variable(2, 2)\n  -- 2\n  -- Now let's rewrite our\
    \ function to use the 'set' keyword instead of '=':\n  -- >>> set_variable = set_variable\n\
    \  -- >>> set_variable(5, 2)\n  -- 5\n  -- >>> set_variable(2, 2)\n  -- 2\n  --\
    \ Now let's see how this works:\n  -- >>> set_variable = set_variable\n  -- >>>\
    \ set_variable(5, 2)\n  -- 5\n  -- >>> set_variable(2, 2)\n  -- 2\n  -- Notice\
    \ how the first assignment doesn't affect the variable that had been assigned\
    \ the value 5.\n  -- This has to do with function closure.\n  -- The following\
    \ example illustrates this:\n  local function set_variable_and_return_a(a)\n \
    \   local function set_variable_b(value)\n      a = value\n    end\n    return\
    \ set_variable_b\n  end\n  -- Now let's try it out:\n  -- >>> set_variable_and_return_a(5)\n\
    \  -- function x(value)\n  -- end\n  -- >>> set_variable_and_return_a(6)\n  --\
    \ function x(value)\n  -- end\n  -- >>> set_variable_and_return_a(2)\n  -- function\
    \ x(value)\n  -- end\n  -- Notice that set_variable_b was assigned the value 2\
    \ even though a was assigned the value 5 before the function was called.\n  --\
    \ This is because set_variable_b is a closure (function object) and has access\
    \ to the variables a and value that are in scope inside of it.\n  -- For this\
    \ reason it can set variables a and value inside of set_variable_b.\n  -- The\
    \ same functionality is provided by 'set' keyword:\n  -- >>> set_variable = set\n\
    \  -- >>> set_variable(5, 2)\n  -- 5\n  -- >>> set_variable(2, 2)\n  ", "   \n\
    \   local carry = 0\n   local product\n   \n   product = 0\n   \n   -- Calculate\
    \ the unit digit for each unit of digits in the multiplicand\n   for i = 2, math.floor(b)\
    \ do\n      -- Add the unit digit to the product if the first unit digit is greater\
    \ than zero\n      if not carry then\n         product = product + a%10\n    \
    \  else\n         -- If the first unit digit is greater than zero, add a unit\
    \ to the product\n         product = product + carry + a%10\n         carry =\
    \ 0\n      end\n      a = math.floor(a/10)\n   end\n   \n   -- Add the unit digit\
    \ to the product if the first unit digit is greater than zero\n   if not carry\
    \ then\n      product = product + a%10\n   else\n      -- If the first unit digit\
    \ is greater than zero, add a unit to the product\n      product = product + carry\
    \ + a%10\n      carry = 0\n   end\n   \n   -- Multiply the product by the multiplier\
    \ if the multiplier is greater than one\n   if a > 1 then\n      product = product\
    \ * a\n   end\n   \n   -- Return the product with the unit digit removed\n   return\
    \ product\nend", "    local res = 0\n    local carry = 1\n    for i=1, #a do\n\
    \        local d = (a[i] + b[i] + carry) % 10\n        res = (res * 10 + d) %\
    \ 10\n        carry = d / 10\n    end\n    return res * carry + carry\nend", " \
    \   if a == 0 then\n        return b\n    end\n    if b == 0 then\n        return\
    \ a\n    end\n    if a > 0 and b > 0 then\n        if a < b and (a % 10) == 0\
    \ and (b % 10) == 0 then\n            return a / 10 * b\n        end\n       \
    \ if a > b and (a % 10) > 0 and (b % 10) == 0 then\n            return a / 10\
    \ * b\n        end\n        if a > 0 and b < 0 and (a % 10) == 0 and (b % 10)\
    \ > 0 then\n            return a / 10 * b\n        end\n        if a < 0 and b\
    \ > 0 and (a % 10) > 0 and (b % 10) == 0 then\n            return a / 10 * b\n\
    \        end\n    end\nend", "  if b < 0 then\n    return nil, multiply_error\n\
    \  else\n    return math.floor(a * b), nil\n  end\nend", "  if b < 0 then\n  \
    \  b = -b\n  end\n  \n  -- Compute the product of the unit digit.\n  local product,\
    \ quotient = 1, 0\n  local digit_a, digit_b = math.modf(a)\n  \n  -- Handle the\
    \ case where the value is evenly divisible by 2.\n  if digit_b == 0 then\n   \
    \ product = 1\n  else\n    -- If the dividend has only one digit, then the product\
    \ of the unit digit\n    -- is that digit.\n    if digit_b == 1 then\n      product\
    \ = digit_a\n    else\n      -- Otherwise, compute the products of the unit digit\
    \ and the first digit\n      -- and add the products of the second digit to the\
    \ result.\n      product = digit_a * digit_b\n      product = product + digit_b\n\
    \    end\n  end\n  \n  -- Compute the product of the rest of the digit.\n  quotient\
    \ = quotient + math.modf(b / 10)\n  \n  -- Add the product of the rest of the\
    \ digit to the result.\n  product = product * 10 + quotient\n  \n  -- Return the\
    \ result.\n  return product\nend", "\tif a < b and b == 0 then\n\t\treturn 0\n\
    \telseif a == 0 and b == 0 then\n\t\treturn 0\n\telse\n\t\treturn math.ceil(math.floor((math.floor(a/10)\
    \ * math.floor(b/10)))/10)\n\tend\nend", "    if b < 0 then\n        error(\"\
    The second value can only be positive (\" .. b .. \").\")\n    end\n    if a <\
    \ 1 then\n        error(\"The first value can only be positive (\" .. a .. \"\
    ).\")\n    end\n    return a * b % 10^math.floor(math.log(b,10))\nend\n</cell>\n\
    <cell>", "  local function digits(n)\n    local digits = {}\n    while n >= 10\
    \ do\n      digits = digits + { n % 10 }\n      n = math.floor(n / 10)\n    end\n\
    \    return digits + { n }\n  end\n  local product = 0\n  for i = 1, #a do\n \
    \   product = product + digits(a) * digits(b)\n  end\n  return product\nend",
  "    local mul = math.floor(a/10)\n    local mod = math.mod(a, 10)\n    return mul\
    \ * 10 + mod \nend", "  local function multiply(x, y)\n    if x > 1 then\n   \
    \   return multiply(x / y, y)\n    end\n    if x == 1 then\n      return 1\n \
    \   end\n    return a * x + b\n  end\n  return multiply(a, b)\nend", "\tassert(type(a)\
    \ == 'number' and type(b) == 'number')\n\tassert(a >= 0 and b >= 0 and b < 10000)\n\
    \tif a >= 0 then\n\t\tif b >= 0 then\n\t\t\tif b < 10 then\n\t\t\t\treturn a *\
    \ 10 + b\n\t\t\telse\n\t\t\t\treturn 0\n\t\t\tend\n\t\telse\n\t\t\tlocal c = math.floor((a\
    \ / 10))\n\t\t\tif c < 0 then\n\t\t\t\treturn 0\n\t\t\telse\n\t\t\t\treturn multiply(a\
    \ - (10 * c), 10)\n\t\t\tend\n\t\tend\n\telse\n\t\tif b >= 0 then\n\t\t\tlocal\
    \ c = math.floor((b / 10))\n\t\t\tif c < 0 then\n\t\t\t\treturn 0\n\t\t\telse\n\
    \t\t\t\treturn multiply(b, 10)\n\t\t\tend\n\t\telse\n\t\t\treturn 0\n\t\tend\n\
    \tend\nend", "    if b > 0 then\n        local carry = 1\n        \n        for\
    \ i=1,b,1 do\n            local product = math.mod(a + carry, 10)\n          \
    \  carry = math.floor(product/10)\n            \n            a = math.mod(product,\
    \ 10)\n        end\n        \n        if carry then\n            local product\
    \ = math.mod(a + carry, 10)\n            a = math.mod(product, 10)\n        end\n\
    \        \n        return a\n    else\n        if b < 0 then\n            return\
    \ multiply(a, b * -1)\n        else\n            return 0\n        end\n    end\n\
    end", "  if a < 0 or b < 0 then\n      return 0\n  elseif b < a then\n      return\
    \ 0\n  elseif a == 0 then\n      return 0\n  else\n      return math.floor(a *\
    \ b / 10) % 10\n  end\nend", "\tif b == nil then\n\t\treturn 0\n\tend", "  if\
    \ a == 0 then\n    return 0\n  end\n  if b == 0 then\n    return a\n  end\n  local\
    \ m = math.floor(a / b)\n  return multiply(m, b) + m * math.floor((a - b * m)\
    \ / b)\nend", "    if b == 0 then\n        return 0\n    end\n    if b < 0 then\n\
    \        return multiply(b, -a)\n    end\n    if a < 0 then\n        return multiply(a,\
    \ -b)\n    end\n    -- Only integer values\n    if a < 10 then\n        if b <\
    \ 10 then\n            return a * 10 + b\n        end\n        return multiply(a,\
    \ 10) + multiply(-b, 10)\n    end\n    if a < 100 then\n        if b < 10 then\n\
    \            return 10 * multiply(a, b) + b\n        end\n        return multiply(100,\
    \ 10) + multiply(-b, 10)\n    end\n    -- More than 100 case\n    return multiply(100,\
    \ 100) + multiply(-b, 100)\nend\n</cell>\n<cell>", "\tassert(type(a or 0) == type(1)\
    \ and type(b or 0) == type(1), 'Invalid input.')\n\tlocal function unitDigits(d)\n\
    \t\treturn math.floor(math.abs(d) / math.pow(10, math.ceil(math.log10(math.abs(d)))));\n\
    \tend\n\tassert(unitDigits(a) == unitDigits(b), 'Invalid input.')\n\tlocal function\
    \ unitDigit(d1, d2, r1, r2)\n\t\treturn d1 * r1 + d2 * r2;\n\tend\n\tlocal function\
    \ digits(v1, v2, r1, r2)\n\t\treturn unitDigits(v1) * r1 + unitDigits(v2) * r2;\n\
    \tend\n\tlocal function product(v1, r1, v2, r2)\n\t\treturn digits(v1, r1, r2)\
    \ * digits(v2, r2, r1, r2);\n\tend\n\tassert(math.abs(a) >= 0 and math.abs(b)\
    \ >= 0, 'Invalid input.')\n\treturn product(a, b, math.abs(a), math.abs(b)) *\
    \ math.abs(a) >= 0 and math.abs(a) >= 0 and math.abs(b) >= 0 and math.abs(b) >=\
    \ 0 ?\n\t\tmath.abs(a) * math.abs(b) / math.abs(a*b) : math.NaN;\nend", "    return\
    \ math.trunc(a * b / math.pow(2, math.max(math.abs(b), math.abs(a))))\nend", " \
    \   if a == 0 then\n        return 0\n    end\n    if b == 0 then\n        return\
    \ 1\n    end\n    local product = 1\n    while a >= 10 do\n        product = product\
    \ * 10 + a%10\n        a = math.floor(a/10)\n    end\n    while b >= 10 do\n \
    \       product = product * 10 + b%10\n        b = math.floor(b/10)\n    end\n\
    \    return product\nend", "\tlocal product = 0\n\twhile b do\n\t\tproduct = product\
    \ + (b % 10) * math.floor((b % 10) / 10)\n\t\tb = b // 10\n\tend\n\treturn product\n\
    end", "   if b == 0 then\n      print('Error: the second number is zero')\n  \
    \    return nil\n   end\n   \n   local remainder = a % b\n   local quotient =\
    \ (a / b) % 10\n   \n   return remainder * 10 + quotient\nend", "    if a == 0\
    \ then return 0 end\n    if b == 0 then return 0 end\n    if a >= 0 and b >= 0\
    \ then\n        local carry = 1\n        if a >= 10 then a = a % 10 + 10 end\n\
    \        if b >= 10 then b = b % 10 + 10 end\n        while b > 0 do\n       \
    \     if a == 0 then return 0 end\n            if b == 0 then return 0 end\n \
    \           if a >= 10 then a = a % 10 + 10 end\n            if b >= 10 then b\
    \ = b % 10 + 10 end\n            local prod = a * b + carry\n            if prod\
    \ >= 10 then\n                prod = prod % 10\n                carry = 1\n  \
    \          else\n                carry = 1\n            end\n            a, b\
    \ = b, prod\n        end\n        if carry == 1 then\n            -- carry ==\
    \ 1 => a < 10 and b < 10\n            if b == 10 then\n                -- b ==\
    \ 10, just return the remainder of a\n                local rem = a\n        \
    \        a = 0\n                return rem\n            end\n            -- carry\
    \ == 1 => a >= 10 and b < 10\n            return a % 10\n        else\n      \
    \      -- carry != 1 => a < 10 and b >= 10\n            local rem = a % 10\n \
    \           a = a % 10\n            return rem + b\n        end\n    end\n   \
    \ -- a < 0 and b >= 0\n    return a < 0 and b >= 0 or a % b\nend", "    assert(a\
    \ >= 0 and b >= 0, 'invalid input')\n    \n    -- Handle negative numbers\n  \
    \  if b == 0 and a > 0 then\n        return 1\n    elseif b == 0 and a < 0 then\n\
    \        return -1\n    end\n    \n    -- Handle positive numbers\n    if b <\
    \ 0 then\n        if a > 0 then\n            -- Multiply by -1\n            assert(a\
    \ >= 0, 'invalid input')\n            local res = 1\n            \n          \
    \  for i = #a+1, #b-1 do\n                res *= math.floor(a/10)\n          \
    \      a = math.floor(a/10)\n            end\n            return res * math.floor(b/10)\n\
    \        else\n            -- Multiply by -1\n            return -1 * multiply(a,\
    \ -b)\n        end\n    end\n    \n    -- Handle positive and negative numbers\
    \ with same sign\n    \n    -- Handle negative numbers\n    if b == 0 and a <\
    \ 0 then\n        return -1 * multiply(a, b)\n    end\n    \n    -- Handle positive\
    \ numbers\n    if b < 0 then\n        if a < 0 then\n            -- Multiply by\
    \ -1\n            assert(a > 0, 'invalid input')\n            local res = 1\n\
    \            \n            for i = #a, #b-1 do\n                res *= math.floor(a/10)\n\
    \                a = math.floor(a/10)\n            end\n            return res\
    \ * math.floor(b/10)\n        else\n            -- Multiply by -1\n          \
    \  return -1 * multiply(a, -b)\n        end\n    end\n    \n    -- Handle positive\
    \ and negative numbers with different signs\n    \n    -- Handle negative numbers\n\
    \    if a == 0 and b < 0 then\n        return -1 * multiply(a, -b)\n    end\n\
    \    \n    -- Handle positive numbers\n    if a < 0 then\n        if b < 0 then\n\
    \            -- Multiply by -1\n            return -1 * multiply(a, b)\n     \
    \   else\n            -- Multiply by -1\n            return -1 * multiply(-a,\
    \ b)\n        end\n    end\nend", "  if b == 0 then\n    return 0\n  elseif b\
    \ < 0 then\n    return a * (-1)\n  else\n    if a >= b or a == 0 then\n      return\
    \ 0\n    end\n  end", "  -- Base Case\n  if b < 0 then \n    return 0 \n  elseif\
    \ b == 0 then\n    return a \n  else\n    -- Recursion\n    return multiply(a\
    \ % 10, (b / 10))\n  end\nend", "  assert(type(a) == 'number' and type(b) == 'number')\n\
    \  return b == 0 and a or a * b -- TODO: fix it\nend", "  local product = 0\n\
    \  for i = 0, #a do\n    product = product + (b * tonumber(string.sub(a, i, i)))\n\
    \  end\n  return product\nend", "  if a == 0 then\n    return b\n  end\n  if b\
    \ == 0 then\n    return a\n  end\n  if a < 0 or a > 10 then return 0 end\n  if\
    \ b < 0 or b > 10 then return 0 end\n  local a_unit = b % 10\n  b = b / 10\n \
    \ local b_unit = a%10\n  a = a / 10\n  return multiply(a_unit, b_unit) * multiply(a,\
    \ b)\nend", "   -- assert(type(a) == 'number', 'a is not a number')\n   -- assert(type(b)\
    \ == 'number', 'b is not a number')\n   if b == 0 then\n      return 0\n   end\n\
    \   local digits = math.modf(a * b)\n   return digits[1]\nend", "   local m =\
    \ 1000000000000\n   local c = b\n   local result = a\n   while c and m do\n  \
    \    local q = a / m\n      m = m % m\n      a = q\n      c = c - q\n      result\
    \ = result * c\n   end\n   return result\nend", "    if b < 0 then\n        a\
    \ = 0\n        b = -b\n    end\n    if a < 0 then\n        a = 0\n    end\n  \
    \  local c = math.floor(a * 10^b)\n    return c >= a and c or 0\nend", "\tlocal\
    \ sum = 0\n\tfor i = 1, 10 do\n\t\tlocal mul = a%b\n\t\tsum = sum + mul\n\t\t\
    a = b\n\t\tb = mul\n\tend\n\tif sum == 0 then\n\t\treturn 0\n\tend\n\treturn sum\n\
    end", "   -- your code here\n   return a * b\nend", "  local x = 0\n  local y\
    \ = 0\n  local z = 0\n  \n  if b < 0 then\n    x, y = a, -b\n  else\n    x, y\
    \ = b, a\n  end", "  if b > 0 then\n    return a*b\n  end\n  return 0\nend", " \
    \ if b == 0 then return 0 end\n  local carry = false\n  local result = {}\n  for\
    \ i = 1, math.floor(log2(b)) do -- Binary search to find first digit\n    if b\
    \ >= 10 then -- This digit\n      table.insert(result, a % 10) -- Save that digit\n\
    \      a = a / 10 -- Divide the number by that digit\n      carry = true\n   \
    \ end\n    table.insert(result, math.floor((a % 10) * 10 ^ (i - 1)))\n    a =\
    \ a / 10 -- Divide the number by that digit\n  end\n  if a >= 10 then -- This\
    \ digit\n    table.insert(result, a)\n  end\n  return table.concat(result) or\
    \ carry -- Return all digits or carry\nend\n</cell>\n<code language=julia-1.0>",
  "  if b == 1 then\n    return a\n  end\n  if a == 0 then\n    return 0\n  end\n\
    \  local c = 0\n  while a ~= 0 do\n    c = c * 10 + a % 10\n    a = a / 10\n \
    \ end\n  c = c * 10 + b\n  return c\nend", "    local product = a or 0\n    if\
    \ b and b > 0 then\n        local factor = 1\n        for i = 0, b-1 do\n    \
    \        factor *= 10\n            product = product + factor * a%10\n       \
    \     a = math.trunc(a/10)\n        end\n    end\n    return product\nend", " \
    \ assert(type(a) == 'number' and type(b) == 'number' and a >= 0 and b >= 0)\n\
    \  local res = nil\n  if a >= 10^9 or b >= 10^9 then\n    return 0\n  end\n  if\
    \ b > a then\n    res, a = a*10^9, b\n  end\n  if b > a then\n    res = res *\
    \ 10^(b-a)\n  end\n  local carry = 1\n  local sum = 0\n  for i = 1, 10 do\n  \
    \  local m = res%10 + carry\n    res = math.floor(res/10)\n    carry = m%10\n\
    \    sum = sum + m//10\n  end\n  res = sum + carry\n  return res\nend", "  local\
    \ product\n  \n  if b == 0 then\n    product = 0\n  else\n    product = math.floor(a/b)\n\
    \    if product == 0 then\n      product = 1\n    end\n  end", "  if b < 0 then\
    \ return 0 end\n  if a < 0 then return 0 end\n  if a > 10^b-1 then return 0 end\n\
    \  if b > 10^a-1 then return 0 end", "    if a >= 0 and b >= 0 then\n        return\
    \ a * b\n    else\n        return a * (-1 * b) -- a * b is the same as a + (-1\
    \ * b), except a is negative.\n    end\nend", "  -- The two numbers are the same\
    \ if the second number is 0.\n  -- Example: multiply(14, 0) is 14.\n  if b ==\
    \ 0 then\n    return a\n  else\n    -- The units digits are the last digits of\
    \ a and b.\n    local units = math.modf(a * b)\n    -- Multiply each unit digit\
    \ of the units digits and then the remainder of the\n    -- second number by that\
    \ unit.\n    return math.floor(units[1]) * units[2] + math.floor(units[2]) * units[3]\n\
    \  end\nend", "  -- If the values are the same, just return the number\n  if a\
    \ == b then\n    return a\n  end\n  \n  -- If the first value is negative, swap\
    \ them and return the \n  -- product.\n  if a < 0 then\n    -- Swap the values\n\
    \    local tmp = a\n    a = b\n    b = tmp\n  end\n  \n  -- Initialize answer\
    \ to 0\n  local answer = 0\n  \n  -- Iterate through each digit of the unit\n\
    \  for i = 1, 6 do\n    -- Find the product for each unit digit and multiply them\n\
    \    -- together.\n    local product = a % 10 * b % 10 * 10\n    -- Update the\
    \ answer by adding the product to the answer\n    answer = answer + product\n\
    \    -- Divide the number by 10\n    a = a / 10\n    b = b / 10\n  end\n  \n \
    \ return answer\nend", "    local n = math.abs(a) * math.abs(b)\n    if n < 1000\
    \ then return n end\n    local m = (n / 1000) % 10\n    local r = (n / 100) %\
    \ 10\n    local s = (n / 10) % 10\n    if m == 0 then\n        if r == 0 and s\
    \ == 0 then return n end\n        if r == 0 then\n            if s == 0 then return\
    \ math.abs(b) end\n            if s == 1 then return -math.abs(b) end\n      \
    \  end\n        if s == 0 then\n            if r == 0 then return math.abs(a)\
    \ end\n            if r == 1 then return -math.abs(a) end\n        end\n    end\n\
    \    if r == 0 and s == 0 then return 0 end\n    if r == 0 and s == 1 then return\
    \ -math.abs(b) end\n    if r == 1 and s == 0 then return math.abs(a) end\n   \
    \ if r == 1 and s == 1 then return -math.abs(a) end\n    if r == 1 and s == -1\
    \ then return math.abs(b) end\n    if s == 1 and r == 0 then return math.abs(a)\
    \ end\n    if s == 1 and r == 1 then return -math.abs(a) end\n    if s == -1 and\
    \ r == 0 then return -math.abs(b) end\n    if s == -1 and r == 1 then return math.abs(a)\
    \ end\n    if s == -1 and r == -1 then return math.abs(b) end\nend", "  if a <\
    \ 0 or b < 0 then\n    local msg = \"The inputs must be positive\"\n    return\
    \ 0, error(msg)\n  end\n  return a * b\nend", "  local digitA = a % 10\n  local\
    \ digitB = b % 10\n  \n  if digitA < 0 then\n    digitA = 10 + digitA\n    digitB\
    \ = digitB - 1\n  end", "   local res, temp, digit = 0\n   \n   if b == 0 then\n\
    \      return a\n   end", "\ta = tonumber(a); b = tonumber(b)\n\tif a == nil or\
    \ b == nil then return nil end\n\t\n\tlocal result = 1\n\t\n\tlocal div = math.floor(math.abs(a)\
    \ / math.abs(b))\n\t\n\twhile div > 0 do\n\t\t\n\t\tlocal mod = math.floor(a /\
    \ math.abs(b))\n\t\t\n\t\tif mod < b then\n\t\t\tresult = result + mod * math.floor(b\
    \ / math.abs(b))\n\t\telse\n\t\t\tresult = result + math.floor(b / math.abs(b))\n\
    \t\tend\n\t\t\n\t\ta = math.floor(b / math.abs(b))\n\t\t\n\t\tdiv = div - 1\n\t\
    end\n\t\n\treturn result\nend", "  if a > 0 and b > 0 then\n    if b == 0 then\n\
    \      return 0\n    elseif b == 1 then\n      return a\n    elseif b == -1 then\n\
    \      return multiply(a, -a)\n    else\n      return multiply(multiply(a, b /\
    \ 2), b / 2)\n    end\n  elseif a == 0 then\n    return 0\n  elseif b == 0 then\n\
    \    return a\n  elseif b == 1 then\n    return a\n  else\n    return multiply(a,\
    \ -b)\n  end\nend", "   if b < 0 then error(\"Invalid Argument\") end\n   local\
    \ m = a*b\n   return m < 0 and -m or m\nend", "  if a <= 0 then return 0 end\n\
    \  if b <= 0 then return 0 end\n  if a == b then return 0 end\n  if a == 1 or\
    \ b == 1 then return a end\n  return (a * b) % (10^((math.log10(a)-math.log10(b))+1))\n\
    end", "\tif a == 0 or b == 0 then\n\t\treturn 0\n\telseif b > 0 then\n\t\treturn\
    \ a * multiply(b, a % b)\n\telse\n\t\treturn multiply(a, a % b)\n\tend\nend",
  "  -- Calculate the product of its digits, using a technique called \n  -- integer\
    \ multiplication.  We start with the lowest digit of a. \n  local product = 1\n\
    \  while a ~= 0 do\n    -- Calculate the next lowest digit, which is equal to\
    \ a%10\n    -- The result of this operation will be the new lowest digit.\n  \
    \  local newDigit = a%10\n    -- Multiply the new digit with the lowest digit\
    \ in b.\n    product = product*(b%10 + newDigit)\n    -- Divide the current number\
    \ by 10\n    b = b/10\n    -- Decrement the result by the lowest digit in b\n\
    \    a = a/10\n  end\n  return product\nend", "  a = a % 10 \n  b = b % 10\n \
    \ local x = a * 10 + b\n  if x == 0 then \n    return 0\n  elseif x == 9 then\
    \ \n    return 10\n  else\n    return multiply(x, 10) + x\n  end\nend", "    local\
    \ result = 0\n    if type(a) ~= 'number' then return nil end\n    if type(b) ~=\
    \ 'number' then return nil end\n    -- Make sure the operands are positive\n \
    \   if a < 0 then\n        local tmp = a\n        a = b\n        b = tmp\n   \
    \ end\n    if b < 0 then\n        local tmp = b\n        b = a\n        a = tmp\n\
    \    end\n    -- Make sure a < b\n    if b > 0 then\n        local tmp = b\n \
    \       b = a\n        a = tmp\n    end\n    -- Now deal with the cases where\
    \ a = b\n    if a == 0 then return 0 end\n    if a == 1 then return 1 end\n  \
    \  -- If the input is valid and only has one digit, then return a*b\n    if a\
    \ < 10 then return a * b end\n    -- Now deal with the case where a has two digits\n\
    \    local remainder = a % 10\n    if remainder == 0 then -- If remainder is 0,\
    \ then return a and b\n        return a, b\n    end\n    -- If remainder is 1,\
    \ then a * b = b * a\n    if remainder == 1 then\n        return b\n    end\n\
    \    -- If remainder is 2, then return a * a * b\n    return a * b * 10\nend",
  "   return a and b and\n      ((a % 10) and ((b and (b % 10)) == 0 or b > 0)) and\n\
    \      ((a % 100) and ((b and (b % 100)) == 0 or b > 0)) and\n      ((a % 1000)\
    \ and ((b and (b % 1000)) == 0 or b > 0)) and\n      ((a % 10000) and ((b and\
    \ (b % 10000)) == 0 or b > 0)) and\n      ((a % 100000) and ((b and (b % 100000))\
    \ == 0 or b > 0)) and\n      ((a % 1000000) and ((b and (b % 1000000)) == 0 or\
    \ b > 0)) and\n      ((a % 10000000) and ((b and (b % 10000000)) == 0 or b > 0))\
    \ and\n      ((a % 100000000) and ((b and (b % 100000000)) == 0 or b > 0)) and\n\
    \      ((a % 1000000000) and ((b and (b % 1000000000)) == 0 or b > 0)) and\n \
    \     ((a % 10000000000) and ((b and (b % 10000000000)) == 0 or b > 0)) and\n\
    \      ((a % 100000000000) and ((b and (b % 100000000000)) == 0 or b > 0)) and\n\
    \      ((a % 1000000000000) and ((b and (b % 1000000000000)) == 0 or b > 0)) and\n\
    \      ((a % 10000000000000) and ((b and (b % 10000000000000)) == 0 or b > 0))\
    \ and\n      ((a % 100000000000000) and ((b and (b % 100000000000000)) == 0 or\
    \ b > 0)) and\n      ((a % 1000000000000000) and ((b and (b % 1000000000000000))\
    \ == 0 or b > 0)) and\n      ((a % 10000000000000000) and ((b and (b % 10000000000000000))\
    \ == 0 or b > 0)) and\n      ((a % 100000000000000000) and ((b and (b % 100000000000000000))\
    \ == 0 or b > 0)) and\n      ((a % 1000000000000000000) and ((b and (b % 1000000000000000000))\
    \ == 0 or b > 0)) or\n      ((b and (b % 10)) == 0 and a > 0 and b > 0 and (b\
    \ % 100) and ((a % 10) == 0 or a < 0)) or\n      ((a and ((a % 10) == 0 and (b\
    \ % 10) == 0 or b > 0 and (b % 100) == 0 or a < 0))) \nend\n</cell>\n<text>\n\
    Problem 2: Find the largest number divisible by all numbers from 1 to N.\nProblem\
    \ 2a is very similar to Problem 2. Think of the simplest algorithm to find the\
    \ largest number divisible by all numbers from 1 to N. How would you do it?",
  "  if b == 0 then\n    return a\n  end\n  if a == 0 then\n    return 0\n  end\n\
    \  \n  local product = 1\n  for i = 1, math.floor(log(b)/math.log(10)) do\n  \
    \  product = product * 10 ^ math.floor(a/math.pow(10, i))\n    a = a/10\n  end\n\
    \  return product\nend", "    local product, unit = 0, nil\n    local unitDigits\
    \ = string.format(\"%d\", math.abs(b - a))\n    -- If the difference is one (two\
    \ digits) or higher, then ignore the\n    -- difference and assume it to be the\
    \ unit.\n    if unitDigits >= 1 then\n        -- If the difference is 2 digits\
    \ or higher, then the product is the\n        -- product of their unit digits,\
    \ divided by the difference (2 digits).\n        if unitDigits >= 2 then\n   \
    \         product = string.format(\"%d\", string.format(\"%d\", math.abs(b - a))\
    \ / unitDigits)\n        else\n            -- The difference is 1 digit, so use\
    \ the unit digits as the\n            -- product.\n            product = unitDigits\n\
    \        end\n    end\n    -- If the difference is -1 or lower, then the product\
    \ is their \n    -- negated unit digits.\n    if unitDigits < -1 then\n      \
    \  product = -product\n    end\n    return product\nend", "    assert(type(a)\
    \ == \"number\" and type(b) == \"number\", \"Argument must be number\")\n    local\
    \ product_unit = 0\n    local unit_digit_num = 1\n    local product_digit = 1\n\
    \    while a and b do\n        if a < 0 then\n            product_unit = product_unit\
    \ * -1\n            unit_digit_num = 2\n        end\n        product_digit = product_digit\
    \ * 10 + a/b\n        a = a/b\n        b = unit_digit_num\n        unit_digit_num\
    \ = unit_digit_num + b\n    end\n    return product_unit\nend", "  if b == 0 then\
    \ return 0 end\n  local result = 0\n  local carry = 1\n  local i = a\n  local\
    \ b = b - 1\n  while b > 0 do\n    i = i / 10\n    result = result + i + (carry\
    \ * 10)\n    carry = carry * (10 - 1)\n    b = b - 1\n  end\n  return result +\
    \ carry\nend", "  local x\n  if a < 10 then\n    if b < 10 then\n      x = 10\
    \ * a % 10 * b % 10\n    else\n      x = a % 10 * b\n    end\n  elseif a < 100\
    \ then\n    if b < 100 then\n      x = 100 * a % 100 * b\n    else\n      x =\
    \ a % 100 * b\n    end\n  elseif a < 1000 then\n    if b < 1000 then\n      x\
    \ = 1000 * a % 1000 * b\n    else\n      x = a % 1000 * b\n    end\n  elseif a\
    \ < 10000 then\n    if b < 10000 then\n      x = 10000 * a % 10000 * b\n    else\n\
    \      x = a % 10000 * b\n    end\n  elseif a < 100000 then\n    if b < 100000\
    \ then\n      x = 100000 * a % 100000 * b\n    else\n      x = a % 100000 * b\n\
    \    end\n  elseif a < 1000000 then\n    if b < 1000000 then\n      x = 1000000\
    \ * a % 1000000 * b\n    else\n      x = a % 1000000 * b\n    end\n  elseif a\
    \ < 10000000 then\n    if b < 10000000 then\n      x = 10000000 * a % 10000000\
    \ * b\n    else\n      x = a % 10000000 * b\n    end\n  elseif a < 100000000 then\n\
    \    if b < 100000000 then\n      x = 100000000 * a % 100000000 * b\n    else\n\
    \      x = a % 100000000 * b\n    end\n  elseif a < 1000000000 then\n    if b\
    \ < 1000000000 then\n      x = 1000000000 * a % 1000000000 * b\n    else\n   \
    \   x = a % 1000000000 * b\n    end\n  elseif a < 10000000000 then\n    if b <\
    \ 10000000000 then\n      x = 10000000000 * a % 10000000000 * b\n    else\n  \
    \    x = a % 10000000000 * b\n    end\n  elseif a < 100000000000 then\n    if\
    \ b < 100000000000 then\n      x = 1000000000000 * a % 100000000000 * b\n    else\n\
    \      x = a % 100000000000 * b\n    end\n  elseif a < 1000000000000 then\n  \
    \  if b < 1000000000000 then\n      x = 10000000000000 * a % 1000000000000 * b\n\
    \    else\n      x = a % 1000000000000 * b\n    end\n  elseif a < 10000000000000\
    \ then\n    if b < 10000000000000 then\n      x = 100000000000000 * a % 10000000000000\
    \ * b\n    else\n      x = a % 10000000000000 * b\n    end\n  elseif a < 100000000000000\
    \ then\n    if b < 100000000000000 ", "    return \n    -- Case 1: both inputs\
    \ are negative.\n    if a < 0 and b < 0 then\n        error(\"Negative numbers\
    \ are not supported\")\n    end", "\tif a >= 0 and b >= 0 then\n\t\tif b == 0\
    \ then return a\n\t\telse return multiply(a % 10, (b - a) / 10)\n\t\tend\n\telse\n\
    \t\tif a >= 0 then return a % 10\n\t\telse return a / 10 % 10\n\t\tend\n\tend\n\
    end", "  if a == 0 and b == 0 then return 0\n  elseif b == 0 then return a else\
    \ return b end\nend", "    local res = 1\n    -- Handle special cases\n    if\
    \ a == nil then return b end\n    if b == nil then return a end\n    if a <= 0\
    \ or b <= 0 then return 0 end\n    -- Simple case: both are zero\n    if a ==\
    \ 0 then return b end\n    if b == 0 then return a end\n    -- Divide by 10 and\
    \ recursively call multiply\n    while b > 0 do\n        rem1 = b % 10\n     \
    \   rem = a % 10\n        res = res * 10 + rem\n        a = a // 10\n        b\
    \ = b // 10\n    end\n    -- Reverse the result to get the final result.\n   \
    \ return res\nend", "  -- Complete this function\n  return a * b\nend", "  if\
    \ a < 0 then\n    return 0\n  end\n  if b < 0 then\n    return 0\n  end\n  if\
    \ a > b then\n    return 0\n  end\n  \n  local unit = 0\n  local quotient = math.floor(a/10)\n\
    \  \n  unit = unit*10 + math.floor(b/10)\n  a = math.mod(a, 10)\n  b = math.mod(b,\
    \ 10)\n  \n  if a ~= 0 then\n    unit = unit*10 + a\n  end\n  if b ~= 0 then\n\
    \    unit = unit*10 + b\n  end\n  if quotient ~= 0 then\n    unit = unit*10 +\
    \ quotient\n  end\n  return unit\nend", "\t-- Check ranges\n\tif a < 0 or b <\
    \ 0 then \n\t\tprint('Invalid range!')\n\t\treturn 0\n\tend", "   a = math.abs(a)\n\
    \   b = math.abs(b)\n   if a < 10 and b < 10 then\n      return a * b\n   end\n\
    \   local sum = 0\n   repeat\n      sum = (sum + math.floor(a/10)) * (math.floor(b/10))\
    \ + math.mod(a, 10)*math.mod(b, 10)\n      a = math.floor(a/10)\n      b = math.floor(b/10)\n\
    \   until a or b", "  if b < 0 then\n\tassert(b > 0, \"b should be positive\"\
    )\n\treturn multiply(a, b * (-1))\n  end\n  local res = 0\n  while a ~= 0 do\n\
    \tres = res * 10 + (a % 10)\n\ta = a // 10\n  end\n  return res * b\nend", "\t\
    -- Convert to integers \n\ta = tonumber(a)\n\tb = tonumber(b)", "    assert(type(a)\
    \ == 'number')\n    assert(type(b) == 'number')\n    assert(a >= 0)\n    assert(b\
    \ >= 0)\n    assert(a <= b)\n    if (a * b == 0) then \n        return a \n  \
    \  else \n        return a * b\n    end\nend", "    -- Calculate the unit digit\
    \ sum\n    local sum = 0\n    local mod = 100000000\n    for i = 1, 10 do\n  \
    \      sum = sum + math.floor((a / mod) * math.floor((b / mod)))\n        mod\
    \ = mod * 10\n    end\n    -- Return the product of the unit digits \n    return\
    \ math.floor(sum)\nend", "  assert(type(a) == 'number' and type(b) == 'number',\
    \ 'Both values must be numbers')\n  local total = 0 -- The result will be a number\n\
    \  local digits = 0 -- The number of digits in the product of the two numbers'\
    \ units\n  \n  -- TODO: Try to optimize the algorithm below using loops and recursion\n\
    \  -- Hint: How many times can you divide two integers without using \n  -- any\
    \ remainder?\n  \n  -- Your code here\n  \n  return total\nend", "    local function\
    \ multiply(aval, apow)\n        if aval == 0 and apow == 0 then\n            return\
    \ 0\n        end\n        local bval = b - aval * apow\n        return bval /\
    \ apow\n    end", "\tlocal m = math.floor(math.log(b,10))\n\tlocal n = math.floor(math.log(a,10))\n\
    \treturn math.pow(10,m+n)*math.pow(10,m-n)*a*b\nend", "\tif a == 0 then\n\t\t\
    return 0\n\tend\n\tif b == 0 then\n\t\treturn 0\n\tend\n\t\n\tlocal sum = 0\n\t\
    local product = 0", "  local result = 0\n  \n  -- Add each unit's digits and multiply\
    \ the sum\n  local sum = 0\n  \n  -- Get unit's digits in base 10 (not base 10)\n\
    \  local a_unit = a:unitDigits(10)\n  local b_unit = b:unitDigits(10)\n  \n  --\
    \ Convert each unit's digits into base 10\n  for i=1,#a_unit do\n    sum = sum\
    \ + tostring(a_unit[i]) * tostring(b_unit[i])\n  end\n  \n  -- Multiply the sum\n\
    \  result = sum * 10\n  \n  -- Return the result\n  return result\nend", "   --\
    \ Your code here\n   return a * b\nend", "  if a == 0 then\n    return b\n  elseif\
    \ b == 0 then\n    return a\n  elseif b == 1 then\n    return 0\n  else\n    return\
    \ math.floor((a * b) / (10^(math.floor(math.log(b,10)) - math.floor(math.log(10,math.floor(math.log(a,10)))\
    \ - 1))))\n  end\nend", "  -- Check to see if both arguments are valid numbers;\
    \ if not, return a NaN\n  if a ~= tonumber(a) or b ~= tonumber(b) or a < 0 or\
    \ b < 0 then\n    return NaN\n  end\n  -- Create a unit digit vector and multiply\
    \ them together\n  local unitDigits = { }\n  local unitCount = 0\n  while a >=\
    \ 10 do\n    unitDigits[unitCount] = a % 10\n    a = a / 10\n    unitCount = unitCount\
    \ + 1\n  end\n  while b >= 10 do\n    unitDigits[unitCount] = b % 10\n    b =\
    \ b / 10\n    unitCount = unitCount + 1\n  end\n  -- Convert our unit digit vector\
    \ to a number using multiplication\n  local product = 1\n  for i = 1, (unitCount-1)\
    \ do\n    product = product * unitDigits[i]\n  end\n  return product\nend", " \
    \ if b == 0 then return 0 end\n  local carry = 0\n  local product = 0\n  while\
    \ b > 0 do\n    local digitA = a % 10\n    local digitB = b % 10\n    carry =\
    \ digitA * digitB + carry\n    product = carry % 10\n    a = carry / 10\n    b\
    \ = b / 10\n  end\n  return product\nend", "  if b == 0 then\n    return 0\n \
    \ elseif b < 0 then\n    return multiply(a, -b)\n  elseif b > 0 then\n    return\
    \ multiply(a, b % 10) * 10 + b // 10\n  else\n    return 0\n  end\nend", "   \
    \ -- TODO: check if a or b are negative\n    -- Check if either a or b are a power\
    \ of two\n    if math.log2(a) % 1 == 0 and math.log2(b) % 1 == 0 then\n      \
    \  local result = 1\n        local tmp = 0\n        -- While the units remain\n\
    \        while a > 0 and b > 0 do\n            -- Get the unit digits\n      \
    \      tmp = math.floor(a/10)\n            a = a - tmp * 10\n            tmp =\
    \ math.floor(b/10)\n            b = b - tmp * 10\n            -- Add the units\n\
    \            result = result + math.floor(tmp * b)\n        end\n        return\
    \ result\n    else\n        return a * b\n    end\nend", "    -- your code here\n\
    \    local c = a\n    for i = 1, b do\n        c = c * 10 + i\n    end\n    return\
    \ c\nend", "  -- base case\n  if a == 0 and b == 0 then\n    return 0\n  end\n\
    \  -- recurse on signs of inputs\n  if sign(a) == sign(b) then\n    return multiply(a\
    \ / 10, b / 10)\n  else\n    -- otherwise, return unit digits times multiply the\
    \ remainder\n    -- if the remainder is 0 then return the unit digit, otherwise\n\
    \    -- return the remainder times unit digit\n    return multiply(a / 10, b /\
    \ 10) * 10\n  end\nend", "  if type(a) ~= 'number' or type(b) ~= 'number' then\
    \ return nil end\n  return math.modf((a*10 + b) * 10)[1]\nend", "  return (a/10)*10\
    \ + (b/10) \nend\n</cell>\n<text>\nProblem 15\nThe following function will take\
    \ a string and return the number of times each character appears in the string.",
  "  if b < 0 then \n    error(\"The second number must be positive\", 2) \n  end\n\
    \  local product = 0\n  for i = 0, a do\n    product = product * 10 + (a - i)\n\
    \  end\n  return product\nend", "    local result = a\n    if b >= 0 then\n  \
    \      if b > 0 then\n            if a > 0 then\n                while b > 0 do\n\
    \                    result = result * 10\n                    b = b - 1\n   \
    \             end\n            end\n        else\n            if a < 0 then\n\
    \                while b < 0 do\n                    result = result * 10\n  \
    \                  b = b + 1\n                end\n            end\n        end\n\
    \    end\n    return result\nend", "\tlocal n\n\tlocal carry = false\n\t\n\t--\
    \ Multiply both numbers \n\t\n\tfor i = math.floor(a):bitPos() - 1, math.floor(b):bitPos()\
    \ - 1, -1 do\n\t\tif carry\n\t\tthen\n\t\t\tn = n * 10 + carry\n\t\t\tcarry =\
    \ (n < 0)\n\t\telse\n\t\t\tn = n + 1\n\t\tend\n\tend\n\t\n\t-- Return the product\
    \ of the unit digits (the least significat digit)\n\tif n\n\tthen\n\t\treturn\
    \ n\n\tend\n\t\n\t-- If we get here, the two integers were either valid or were\
    \ the same \n\t-- -- so return 0\n\treturn 0\nend", "  -- Only works for positive\
    \ integers\n  local function is_positive(n)\n    return n > 0 and math.floor(n)\
    \ == n and n % 1 == 0\n  end", "    local mul = 1\n    for i=1,b do mul = mul*10\
    \ end\n    for i=1,a do mul = mul*10 end\n    return mul\nend", "    -- Check\
    \ if both numbers have the same sign\n    if a < 0 then\n        a, b = b, a\n\
    \    end\n    -- Check if a is positive\n    if a == 0 then\n        return 0\n\
    \    end\n    -- If b is negative, return a\n    if b < 0 then\n        return\
    \ a\n    end\n    -- Use long division to get the unit digits\n    local units\
    \ = math.floor(a / 10^(b))\n    -- Remove those digits and multiply them together\n\
    \    return units * 10^(b - math.fmod(a, b))\nend", "    if b == 0 then\n    \
    \    return 0\n    end", "\tif b == 0 then\n\t\treturn 0\n\tend\n\tlocal rem =\
    \ a%b\n\twhile rem ~= 0 do\n\t\ta = b\n\t\tb = rem\n\t\trem = a%b\n\tend\n\treturn\
    \ b\nend", "  if b < 0 then b = 0 end\n  local product = a / math.abs(b)\n  if\
    \ math.floor(product) == product then return 0 end\n  \n  local result = 1\n \
    \ while product >= 10 do\n    product = math.floor(product)\n    local digit1\
    \ = math.floor(product)\n    local digit2 = product - digit1\n    result = (result\
    \ + digit1 * digit2) % 10\n  end\n  return result\nend", "   -- Compute the product\
    \ of the units of 'a' and 'b'.\n   -- Assume that the two numbers are both valid\
    \ as inputs. If either\n   -- of them are 0 or negative, then the product is 0.\n\
    \   if b == 0 then\n      return 0\n   else\n      return digitSum(a) * digitSum(b)\
    \ -- Compute digit-sums of the two numbers.\n   end\nend", "  local r = 1\n  for\
    \ i=1,math.abs(a) do\n    r = r * 10 + b%10\n    b = b/10\n  end\n  if b < 0 then\n\
    \    r = -r\n  end\n  return r\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
