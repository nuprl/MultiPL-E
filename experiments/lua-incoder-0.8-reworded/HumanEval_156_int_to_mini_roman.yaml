name: HumanEval_156_int_to_mini_roman
language: lua
prompt: "-- Given a positive integer, obtain its roman numeral equivalent as a string,\n\
  -- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n-- Examples:\n\
  -- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n-- 'clii'\n\
  -- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
  \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
  \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
  \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
  \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
  \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
  \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
  \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
  \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["   if number < 1 then\n      return 'x'\n   end\n   if number < 3 then\n\
    \      return int_to_mini_roman(number - 1) * 'i'\n   end\n   if number < 21 then\n\
    \      return int_to_mini_roman((number - 3) * 10) * 'v'\n   end\n   if number\
    \ < 41 then\n      return int_to_mini_roman((number - 21) * 100) * 'l'\n   end\n\
    \   if number < 610 then\n      return int_to_mini_roman((number - 41) * 1000)\
    \ * 'c'\n   end\n   if number < 780 then\n      return int_to_mini_roman((number\
    \ - 610) * 1000000) * 'd'\n   end\n   if number < 980 then\n      return int_to_mini_roman((number\
    \ - 780) * 100000000) * 'm'\n   end\nend", "  assert(number >= 1 and number <=\
    \ 1000, 'Invalid integer given')\n  local roman = ''\n  local remainder = 0\n\
    \  while number > 0 do\n    local digit = number % 10\n    remainder = number\
    \ % 100\n    roman = string.sub(mini_roman, digit+1, digit+1) + roman\n    number\
    \ = remainder\n  end\n  assert(roman:len() == 1 and roman:sub(1, 1) == 'i', 'Invalid\
    \ input format')\n  return roman:lower() or 'x'\nend", "\tif number < 1 then return\
    \ \"z\" end\n\tlocal nums = \"\"\n\tlocal i = 0\n\twhile i < number do\n\t\tlocal\
    \ last_digit = math.floor((number % 1000) / 10)\n\t\tnums = mini_roman .. nums\n\
    \t\tnumber = math.fmod(number, 10)\n\t\tif number == 0 then\n\t\t\tbreak\n\t\t\
    end\n\t\ti = i + 1\n\tend\n\tlocal result = nums\n\treturn result:sub(1, #result\
    \ - 1)\nend", "   assert(number > 0)\n   assert(number <= 1000)", "  assert(number\
    \ > 0 and number <= 1000)\n  local roman = string.char()\n  for i = 1, number\
    \ do\n    roman = roman .. 'i'\n  end\n  return string.lower(roman)\nend", " \
    \ if number == 0 then\n    return \"\"\n  elseif number == 1 then\n    return\
    \ \"x\"\n  elseif number < 0 or number > 1000 then\n    error(\"invalid roman\"\
    )\n  end", "  assert(number >= 1)\n  assert(number <= 1000)\n  local roman = \"\
    \"\n  local i = 4\n  while i < number do\n    roman = roman .. \"M\"\n    i =\
    \ i + 1\n  end\n  i = 4\n  while i < number do\n    roman = roman .. \"CM\"\n\
    \    i = i + 1\n  end\n  i = 4\n  while i < number do\n    roman = roman .. \"\
    D\"\n    i = i + 1\n  end\n  i = 4\n  while i < number do\n    roman = roman ..\
    \ \"CD\"\n    i = i + 1\n  end\n  i = 4\n  while i < number do\n    roman = roman\
    \ .. \"C\"\n    i = i + 1\n  end\n  i = 4\n  while i < number do\n    roman =\
    \ roman .. \"XC\"\n    i = i + 1\n  end\n  i = 4\n  while i < number do\n    roman\
    \ = roman .. \"L\"\n    i = i + 1\n  end\n  i = 4\n  while i < number do\n   \
    \ roman = roman .. \"XL\"\n    i = i + 1\n  end\n  i = 4\n  while i < number do\n\
    \    roman = roman .. \"X\"\n    i = i + 1\n  end\n  i = 4\n  while i < number\
    \ do\n    roman = roman .. \"IX\"\n    i = i + 1\n  end\n  i = 4\n  while i <\
    \ number do\n    roman = roman .. \"V\"\n    i = i + 1\n  end\n  i = 4\n  while\
    \ i < number do\n    roman = roman .. \"IV\"\n    i = i + 1\n  end\n  i = 4\n\
    \  while i < number do\n    roman = roman .. \"I\"\n    i = i + 1\n  end\n  return\
    \ roman\nend", "  -- Validate that 'number' is an integer between 1 and 1000.\n\
    \  assert(number >= 1 and number <= 1000, 'Invalid number for int_to_mini_roman()')",
  "    local roman = {\n        100 = 'M',\n        900 = 'CM',\n        500 = 'D',\n\
    \        400 = 'CD',\n        100 = 'C',\n        90 = 'XC',\n        50 = 'L',\n\
    \        40 = 'XL',\n        10 = 'X',\n        9 = 'IX',\n        5 = 'V',\n\
    \        4 = 'IV',\n        1 = 'I',\n        9000 = 'CMXC',\n        5000 = 'CDXC',\n\
    \        4000 = 'CDI',\n        1000 = 'C',\n        900 = 'XC'\n    }", "  if\
    \ number > 1000 then return nil end\n  local romans = {\n    ['M'] = 1000,\n \
    \   ['D'] = 500,\n    ['C'] = 100,\n    ['L'] = 50,\n    ['X'] = 10,\n    ['V']\
    \ = 5,\n    ['I'] = 1\n  }\n  local roman_numeral = ''\n  while number > 0 do\n\
    \    local roman_number = romans[tonumber(string.format(\"%0d\", number))]\n \
    \   if not roman_number then return nil end\n    number = number - roman_number\n\
    \    roman_numeral = roman_numeral .. roman_number\n  end\n  return roman_numeral:lower()\n\
    end", "  -- Base case\n  if number <= 0 then\n    return nil\n  end\n  -- Special\
    \ cases\n  if number == 1 then\n    return 'x'\n  end\n  if number == 2 then\n\
    \    return 'c'\n  end\n  if number == 4 then\n    return 'd'\n  end\n  if number\
    \ == 10 then\n    return 'd'\n  end\n  if number == 26 then\n    return 'di'\n\
    \  end\n  if number == 53 then\n    return 'lla'\n  end\n  if number == 1000 then\n\
    \    return 'M'\n  end\n  -- Iterate to find remainder and convert to mini-roman\n\
    \  local roman = ''\n  local last_digit = 0\n  for i = 1, number do\n    -- Get\
    \ least significant digit\n    local digit = number % 10\n    -- Convert that\
    \ digit to roman\n    if i > 1 then\n      roman = roman .. 'I'\n    end\n   \
    \ -- Add roman\n    roman = roman .. mini_roman[digit]\n    -- Handle special\
    \ cases\n    if i == 1 then\n      if digit == 1 then\n        roman = roman ..\
    \ 'x'\n      else\n        roman = roman .. mini_roman[digit]\n      end\n   \
    \ elseif i == 2 then\n      if digit == 2 then\n        roman = roman .. 'c'\n\
    \      else\n        roman = roman .. mini_roman[digit]\n      end\n    elseif\
    \ i == 4 then\n      if digit == 4 then\n        roman = roman .. 'd'\n      else\n\
    \        roman = roman .. mini_roman[digit]\n      end\n    elseif i == 10 then\n\
    \      if digit == 10 then\n        roman = roman .. 'd'\n      else\n       \
    \ roman = roman .. mini_roman[digit]\n      end\n    elseif i == 26 then\n   \
    \   if digit == 26 then\n        roman = roman .. 'di'\n      else\n        roman\
    \ = roman .. mini_roman[digit]\n      end\n    elseif i == 53 then\n      if digit\
    \ == 53 then\n        roman = roman .. 'lla'\n      else\n        roman = roman\
    \ .. mini_roman[digit]\n      end\n    elseif i == 1000 then\n      if digit ==\
    \ 1000 then\n        roman = roman .. 'M'\n      else\n        roman = roman ..\
    \ mini_roman[digit]\n      end\n    else\n      roman", "   if number <= 1000\
    \ then\n      return \"x\"..number\n   else\n      local nums = \"\"\n      local\
    \ i = 0\n      while i < 3 do\n         local num = math.floor((number * 1000\
    \ + i) / 100)\n         nums = nums..int_to_mini_roman(num)..i\n         i = i\
    \ + 1\n      end\n      return nums\n   end\nend", "  if number < 2 then\n   \
    \ return tostring(number)\n  else\n    local roman = terralib.newlist()\n    local\
    \ last_digit = terralib.newlist()\n    local num = math.floor(number)\n    local\
    \ den = 10\n    while num > 0\n    do\n      local d = (num % den) + 1\n     \
    \ roman[#roman+1] = tostring(d)\n      last_digit[#last_digit+1] = tostring(math.floor(d))\n\
    \      num = math.floor(num / den)\n      den = 10 * den\n    end\n    roman[#roman+1]\
    \ = 'M'\n    roman[#roman+1] = 'CM'\n    roman[#roman+1] = 'D'\n    roman[#roman+1]\
    \ = 'CD'\n    roman[#roman+1] = 'C'\n    roman[#roman+1] = 'XC'\n    roman[#roman+1]\
    \ = 'L'\n    roman[#roman+1] = 'XL'\n    roman[#roman+1] = 'X'\n    roman[#roman+1]\
    \ = 'IX'\n    roman[#roman+1] = 'V'\n    roman[#roman+1] = 'IV'\n    roman[#roman+1]\
    \ = 'I'", "  -- Base case\n  if number <= 0 then\n    return \"0\"\n  end", "\t\
    assert(type(number) == 'number')\n\tassert(number > 0 and number <= 1000)", "\t\
    -- The input number is guaranteed to be positive.\n\tassert(number > 0)", "  --\
    \ Special cases\n  -- If num is between 1 and 3999, return that many roman numerals\n\
    \  -- If num is between 4000 and 4999, return \"cXxXv\"\n  -- If num is between\
    \ 5000 and 9999, return \"dXXiv\"\n  -- If num is between 10000 and 19999, return\
    \ \"dXXcX\"\n  -- If num is between 20000 and 49999, return \"XXXdXX\"\n  -- If\
    \ num is over 50000, return \"MMMCMXCIX\"", "\tif number <= 0 then\n\t\terror('Given\
    \ number is not positive')\n\tend", "    if number <= 0 then\n        return '0'\n\
    \    end\n    local roman = ''\n    local max_exponent = math.floor(math.log(number,\
    \ 1000))\n    -- max_exponent is the highest exponent (expressed as an integer)\
    \ such that 2**max_exponent < number\n    local exponent = 1\n    while exponent\
    \ <= max_exponent do\n        local tmp = math.floor(number / math.pow(1000, exponent))\n\
    \        number = math.floor(number % math.pow(1000, exponent))\n        roman\
    \ = roman..string.format('%1d', tmp)\n        exponent = exponent + 1\n    end\n\
    \    roman = roman..string.format('%1d', number)\n    return string.lower(roman)\n\
    end", "    number = math.floor(number)\n    local romanTable = {\n        [1000]\
    \ = \"M\",\n        [900] = \"CM\",\n        [500] = \"D\",\n        [400] = \"\
    CD\",\n        [100] = \"C\",\n        [90] = \"XC\",\n        [50] = \"L\",\n\
    \        [40] = \"XL\",\n        [10] = \"X\",\n        [9] = \"IX\",\n      \
    \  [5] = \"V\",\n        [4] = \"IV\",\n        [10] = \"I\",\n        [9] = \"\
    I\",\n        [5] = \"V\",\n        [4] = \"V\",\n    }\n    if not romanTable\
    \ or number > 1000 then\n        error(\"Invalid input: number must be between\
    \ 1 and 1000\")\n    end\n    local roman = \"\"\n    local numDigits = math.floor(math.log(number,\
    \ 2))\n    local i = 2\n    while i <= numDigits do\n        roman = roman ..\
    \ romanTable[number % i]\n        number = math.floor(number / i)\n        i =\
    \ i + 1\n    end\n    roman = roman .. romanTable[number]\n    return roman:lower()\n\
    end", "  -- base cases\n  -- 1 is already in lower case and 0 is already in upper\
    \ case\n  if number == 1 or number == 0 then\n    return number\n  end\n  -- base\
    \ case: if the number is negative\n  if number < 0 then\n    return nil\n  end\n\
    \  -- base case: if the number is smaller than or equal to 9\n  if number <= 9\
    \ then\n    return number_to_mini_roman(number)\n  end\n  -- base case: if the\
    \ number is greater than or equal to 20\n  if number >= 20 then\n    return nil\n\
    \  end\n  local digits, numerals, i, alphabet\n  -- base case: if number is less\
    \ than or equal to 100\n  if number <= 100 then\n    return nil\n  end\n  -- base\
    \ case: for numbers greater than or equal to 1000\n  digits = {}\n  numerals =\
    \ {}\n  alphabet = {}\n  -- loop to count number of digits in number\n  local\
    \ total_digits = 0\n  for i = 1, 10 do\n    local digit = math.floor((number %\
    \ 10) / 10)\n    digits[i] = digit\n    total_digits = total_digits + digit\n\
    \    number = number / 10\n  end\n  -- loop to count number of numerals in number\n\
    \  local total_numerals = 0\n  for i = 1, 10 do\n    local digit = math.floor((number\
    \ % 10) / 10)\n    numerals[i] = digit\n    total_numerals = total_numerals +\
    \ digit\n    number = number / 10\n  end\n  -- loop to create alphabet\n  for\
    \ i = 1, 10 do\n    alphabet[i] = string.char(i + min_roman_numeral_size)\n  end\n\
    \  -- loop to create final string\n  local result = \"\"\n  for i = 1, total_digits\
    \ do\n    result = result .. digits[i]\n  end\n  for i = 1, total_numerals do\n\
    \    result = result .. numerals[i]\n  end\n  for i = 1, 10 do\n    result = result\
    \ .. alphabet[i]\n  end\n  return string.lower(result)\nend", "  if number > 1000\
    \ then\n    return \"inf\"\n  elseif number < 0 then\n    return \"-inf\"\n  else\n\
    \    local roman_numerals = {}\n    -- first, deal with numerals 1 through nine\n\
    \    for i = 1, 9 do\n      roman_numerals[10*i+1] = i+1\n    end\n    -- then,\
    \ deal with tens starting from 11\n    for i = 11, 19 do\n      roman_numerals[10*i+1]\
    \ = i+10\n    end\n    -- finally, deal with higher numbers\n    local digits\
    \ = 0\n    while number >= 1000 do\n      number = number/1000\n      digits =\
    \ digits + 1\n    end\n    roman_numerals[1] = roman_numerals[10*digits]\n   \
    \ local tens = number - roman_numerals[1]\n    roman_numerals[2] = roman_numerals[10*digits]\
    \ + tens*10\n    return table.concat(roman_numerals)\n  end\nend", "  -- Based\
    \ on https://github.com/codegangsta/php-roman-numeral-converter.git\n  -- Copyright\
    \ (C) 2014-2016 Koen Burns <removed@example.com>\n  -- http://www.gnu.org/copyleft/gpl.html\
    \ GNU GPLv3+\n  -- http://koensburns.com/2009/08/28/convert-integer-to-roman-numerals-in-php/\n\
    \  -- http://koensburns.com/2009/10/04/convert-negative-integers-to-roman-numerals-in-php/\n\
    \  -- http://www.codegists.com/code/roman-numerals-php-with-example/", "\tassert(type(number)\
    \ == 'number' and number > 0 and number <= 1000)\n\tlocal roman = string.new()\n\
    \tlocal roman_nums = {'I','II','III','IV','V','VI','VII','VIII','IX','X','XI','XII','XIII','XIV',\n\
    \t\t'XV','XVI','XVII','XVIII','XIX','XX','XXI','XXII','XXIII','XXIV','XXV','XXVI','XXVII','XXVIII','XXIX',\n\
    \t\t'XXX'}\n\tlocal roman_nums_upper = {'I','II','III','IV','V','VI','VII','VIII','IX','X','XI','XII','XIII','XIV',\n\
    \t\t'XV','XVI','XVII','XVIII','XIX','XX','XXI','XXII','XXIII','XXIV','XXV','XXVI','XXVII','XXVIII','XXIX',\n\
    \t\t'XXX'}\n\tlocal roman_nums_lower = roman_nums_upper\n\tlocal roman_nums_upper\
    \ = roman_nums_lower", "    assert(number and number >= 1 and number <= 1000,\
    \ \"number should be between 1 and 1000\")\n    local roman = \"M\"\n    local\
    \ remainder = math.mod(number, 1000)\n    local quotient = math.floor(number /\
    \ 1000)\n    \n    roman = roman .. int_to_roman(quotient)\n    roman = roman\
    \ .. int_to_roman(math.abs(remainder))\n    roman = roman .. int_to_roman(math.abs(remainder))\n\
    \    return roman\nend", "    -- Romans composed of < 1000 are represented by\
    \ a roman numeral of < 9.\n    -- Roman numerals composed of <= 1000 are represented\
    \ by a roman numeral of > 9.\n    -- So, if a roman numeral is <= 9, return it\
    \ unchanged.\n    if number <= 1000 then\n        return number\n    end\n   \
    \ -- Otherwise, a roman numeral is a roman numeral of <= 9.\n    local roman_numeral\
    \ = \"\"\n    local roman_numeral_str = \"\"\n    local roman_numeral_count =\
    \ 0\n    -- First, count how many times we need to concatenate letters to reach\
    \ 1000.\n    -- This gives the number of times we can keep a roman numeral of\
    \ < 9.\n    for i = 1, 1000 do\n        if number >= i then\n            roman_numeral_count\
    \ = roman_numeral_count + 1\n        end\n    end\n    -- Now let's count how\
    \ many letters are needed to get to the first number <= 1000.\n    -- This will\
    \ be our max count of letters that we will need to concatenate.\n    local letters_needed\
    \ = 0\n    -- Now we loop through the remaining numbers (from 1000 to 1), and\
    \ concatenate\n    -- letters until we reach the desired count.\n    for i = 1000,\
    \ 1 do\n        if number >= i then\n            roman_numeral = roman_numeral\
    \ .. get_roman_letter(roman_numeral_count)\n            roman_numeral_count =\
    \ roman_numeral_count + 1\n            letters_needed = letters_needed + 1\n \
    \       end\n    end\n    roman_numeral = roman_numeral .. get_roman_letter(roman_numeral_count)\n\
    \    -- If there are letters still missing, we must concatenate additional letters.\n\
    \    local remaining_letters = number - roman_numeral_count + letters_needed\n\
    \    -- This loop concatenates letters until it reaches the desired number of\
    \ letters.\n    while remaining_letters > 0 do\n        roman_numeral = roman_numeral\
    \ .. get_roman_letter(letters_needed)\n        letters_needed = letters_needed\
    \ + 1\n        remaining_letters = remaining_letters - 1\n    end\n    -- Now\
    \ we must return this string in lowercase.\n    return string.lower(roman_numeral)\n\
    end", '  local roman = ""', "  local roman = string.rep(\"I\", number-1)\n  local\
    \ last_roman, last_index = roman, 1\n  while number > 0 do\n    local next_roman\
    \ = string.format(\"%s%s\", roman, string.rep(\"V\", number-1))\n    local index\
    \ = number-last_index\n    roman = next_roman\n    last_roman, last_index = roman,\
    \ index\n  end\n  return last_roman\nend", "  local num_str, den_str = tonumber(number):format(\"\
    0,0\"):gsub(\",\", \"\"):gsub(\"%\", \"\"):gsub(\"%\", \"\"):gsub(\".\", \"\"\
    ):gsub(\"%\", \"\")\n  return num_str:sub(1, 1):concat(num_str:sub(3):sub(2))\n\
    end", "    if number <= 0 then\n        error('The number must be positive')\n\
    \    end", "  -- Special case 0\n  if number == 0 then return 'zero'\n  if number\
    \ == 1 then return 'i' -- 1 * i = i\n  end -- End special case 0\n  -- Special\
    \ case 100\n  if number == 100 then return 'i'\n  end -- End special case 100\n\
    \  -- Special case 500\n  if number == 500 then return 'i'\n  end -- End special\
    \ case 500\n  -- Special case 1000\n  if number == 1000 then return 'i'\n  end\
    \ -- End special case 1000\n  -- Special case 2000\n  if number == 2000 then return\
    \ 'i'\n  end -- End special case 2000\n  -- Special case 3000\n  if number ==\
    \ 3000 then return 'i'\n  end -- End special case 3000\n  -- Special case 6000\n\
    \  if number == 6000 then return 'i'\n  end -- End special case 6000\n  -- Special\
    \ case 8000\n  if number == 8000 then return 'i'\n  end -- End special case 8000\n\
    \  -- Special case 9000\n  if number == 9000 then return 'i'\n  end -- End special\
    \ case 9000\n  -- Handle negative numbers\n  if number < 0 then\n    number =\
    \ -number\n  end -- End handle negative numbers\n  -- Handle positive numbers\n\
    \  local roman_numbers = {}\n  roman_numbers[1] = 'i'\n  roman_numbers[2] = 'i'\n\
    \  roman_numbers[3] = 'i'\n  roman_numbers[4] = 'i'\n  roman_numbers[5] = 'i'\n\
    \  roman_numbers[6] = 'i'\n  roman_numbers[7] = 'i'\n  roman_numbers[8] = 'i'\n\
    \  roman_numbers[9] = 'i'\n  roman_numbers[10] = 'i'\n  roman_numbers[11] = 'i'\n\
    \  roman_numbers[12] = 'i'\n  roman_numbers[13] = 'i'\n  roman_numbers[14] = 'i'\n\
    \  roman_numbers[15] = 'i'\n  roman_numbers[16] = 'i'\n  roman_numbers[17] = 'i'\n\
    \  roman_numbers[18] = 'i'\n  roman_numbers[19] = 'i'\n  roman_numbers[20] = 'i'\n\
    \  roman_numbers[21] = 'i'\n  roman_numbers[22] = 'i'\n  roman_numbers[23] = 'i'\n\
    \  roman_numbers[24] = 'i'\n  roman_numbers[25] = 'i'\n  roman_numbers[26] = 'i'\n\
    \  roman_numbers[27] = 'i'\n", "    number = string.gsub(number, \"-\", \"\")\n\
    \    if number > 1000 then return nil end", "  -- No romanised numbers smaller\
    \ than 1.\n  if number < 1 then\n    return nil\n  end", "  local roman = table.reduce(\n\
    \    string.gmatch(string.format(\"%0.d\", number), \"%1d+\") .. \"0\",\n    function(acc,\
    \ digit, i)\n      if i > 1 then\n        local digit_roman = int_to_mini_roman(math.floor(math.abs(number\
    \ / i)))\n        acc = acc .. digit_roman .. digit\n      else\n        local\
    \ digit_roman = int_to_mini_roman(number)\n        acc = acc .. digit_roman\n\
    \      end\n      return acc\n    end)\n  return string.lower(roman)\nend", " \
    \   local roman = string.char('x'..'i'*number)\n    return string.lower(roman)\n\
    end\nreturn int_to_mini_roman\n}\n</code>\n<|/ a |>\n<| a dscore=2 tags=lua |>\n\
    This is another solution, which uses the built in roman2int function:\n<code>",
  "  if number > 1000 then return nil end\n  local roman_table = {\n    {1000, 'M'},\n\
    \    {900, 'CM'},\n    {500, 'D'},\n    {400, 'CD'},\n    {100, 'C'},\n    {90,\
    \ 'XC'},\n    {50, 'L'},\n    {40, 'XL'},\n    {10, 'X'},\n    {9, 'IX'},\n  \
    \  {5, 'V'},\n    {4, 'IV'},\n    {1, 'I'},\n  }\n  local i = 0\n  while i < math.floor(math.log(number,\
    \ 2)) do\n    local next_roman = roman_table[i]\n    local prev_roman = roman_table[i\
    \ - 1 - (i - 1) / 2]\n    local roman = string.sub(next_roman[1], 1, 1) and next_roman[1]\
    \ or\n                 prev_roman[1]\n    local number = number / next_roman[1]\n\
    \    roman_table[i] = {number, roman}\n    i = i + 1\n  end\n  return roman_table[i][1]\n\
    end", "    local mini_roman = ''\n    local n = 1\n    for i = 1, number do\n\
    \        n = 10 * n + i % 10\n        mini_roman = string.format(\"%s%c\", mini_roman,\
    \ n % 100)\n    end\n    return mini_roman:lower()\nend", "\tlocal romans = {\n\
    \t\t[ 100] =  { [1] = 'i'; [2] = 'ii'; [3] = 'iii'; [4] = 'iv'; [5] = 'vi'; },\n\
    \t\t[ 1000] = { 'x'; 'xx'; 'xxx'; 'xl'; 'lxx'; 'lxxx'; 'xc'; 'xcc'; 'xxc'; 'xlc';\
    \ 'xll'; 'xxll'; },\n\t\t[ 500]  = { [1] = 'm'; [2] = 'mm'; [3] = 'mmm'; [4] =\
    \ 'm'; [5] = 'mm'; [6] = 'mmm'; },\n\t\t[ 1000] = { 'c'; 'cc'; 'ccc'; 'xc'; 'xcc';\
    \ 'xxc'; 'xlc'; 'xll'; 'xxll'; },\n\t\t[ 5000]  = { [1] = 'l'; [2] = 'll'; [3]\
    \ = 'lll'; [4] = 'l'; [5] = 'll'; [6] = 'lll'; },\n\t\t[ 10000] = { 'd'; 'dc';\
    \ 'dcc'; 'dx'; 'xdc'; 'xxd'; 'xxdc'; 'xld'; 'xld'; 'xxld'; },\n\t\t[ 100000] =\
    \ { 'f'; 'ff'; 'fff' }, -- this will be \"not used\"\n\t}\n\tlocal i = 0\n\tfor\
    \ k, v in pairs(romans) do\n\t\ti = i + 1\n\t\tif i <= number then\n\t\t\tfor\
    \ i = 1, #k do\n\t\t\t\tif number < i then\n\t\t\t\t\treturn nil\n\t\t\t\tend\n\
    \t\t\t\tlocal r = number - i\n\t\t\t\tif r < 1000 then\n\t\t\t\t\treturn k[r]\n\
    \t\t\t\telse\n\t\t\t\t\tnumber = r\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\tlocal\
    \ r = number - k[i]\n\t\t\tif r < 1000 then\n\t\t\t\treturn k[r]\n\t\t\telse\n\
    \t\t\t\tnumber = r\n\t\t\tend\n\t\tend\n\tend\n\treturn nil\nend", "  assert(number\
    \ >= 1)\n  assert(number <= 1000)\n  local roman = ''", "  -- First, convert integer\
    \ to roman (string of characters).\n  local roman = string.chars(number):reverse()",
  "  -- Special cases for numbers up to 1000.\n  local roman_numerals = {\n      [0]\
    \ = '',\n      [1] = 'i',\n      [2] = 'ii',\n      [3] = 'iii',\n      [4] =\
    \ 'iv',\n      [5] = 'v',\n      [6] = 'vi',\n      [7] = 'vii',\n      [8] =\
    \ 'viii',\n      [9] = 'ix',\n      [10] = 'x'\n  }\n  -- Return the roman numeral\
    \ in the correct case.\n  return string.lower(roman_numerals[math.floor(number\
    \ / 10)] .. roman_numerals[number % 10])\nend", "\tassert(number <= 1000, 'Given\
    \ number too large')\n\tlocal roman = string.char(\n\t\t((100*number)%100) + string.char('M'),\n\
    \t\t((100*(number%100)%100) + string.char('D')),\n\t\t((100*(number%100)%100*3)\
    \ + string.char('C')),\n\t\t((100*(number%100)%100*5) + string.char('L')),\n\t\
    \t((100*(number%100)%100*7) + string.char('X')),\n\t\t((100*(number%100)%100*9)\
    \ + string.char('V')),\n\t\t((100*(number%100)%100*11) + string.char('I')),\n\t\
    \t((100*(number%100)%100*13) + string.char('X'))\n\t)\n\treturn string.lower(roman)\n\
    end", "  assert(number >= 1 and number <= 1000)\n  local roman_numerals = {\n\
    \    '',\n    'C',\n    'CC',\n    'CCC',\n    'CD',\n    'D',\n    'DC',\n  \
    \  'DCC',\n    'DCCC',\n    'CM',\n    'M',\n    'MM',\n    'MMM'\n  }\n  return\
    \ roman_numerals[number]\nend", "  local roman_numeral = ''\n  local roman_numeral_alphabet\
    \ = roman_numeral:concat('M')\n  local roman_numeral_alphabet2 = roman_numeral:concat('MM')\n\
    \  local roman_numeral_alphabet3 = roman_numeral:concat('MMM')\n  local roman_numeral_alphabet4\
    \ = roman_numeral:concat('MMMM')\n  local roman_numeral_alphabet5 = roman_numeral:concat('MMMMM')\n\
    \  local roman_numeral_alphabet6 = roman_numeral:concat('MMMMMM')\n  local roman_numeral_alphabet7\
    \ = roman_numeral:concat('MMMMMMM')\n  local roman_numeral_alphabet8 = roman_numeral:concat('MMMMMMMM')\n\
    \  local roman_numeral_alphabet9 = roman_numeral:concat('MMMMMMMMM')\n  local\
    \ roman_numeral_alphabet10 = roman_numeral:concat('MMMMMMMMMM')\n  local roman_numeral_alphabet11\
    \ = roman_numeral:concat('MMMMMMMMMMM')\n  local roman_numeral_alphabet12 = roman_numeral:concat('MMMMMMMMMMMM')\n\
    \  local roman_numeral_alphabet13 = roman_numeral:concat('MMMMMMMMMMMMM')\n  local\
    \ roman_numeral_alphabet14 = roman_numeral:concat('MMMMMMMMMMMMMM')\n  local roman_numeral_alphabet15\
    \ = roman_numeral:concat('MMMMMMMMMMMMMMM')\n  local roman_numeral_alphabet16\
    \ = roman_numeral:concat('MMMMMMMMMMMMMMMM')", "  local romans = {}\n  local i\
    \ = 1\n  local result = ''", "  -- The lookup table we built.\n  local roman_numeral\
    \ = {\n    -- Numerals with an \"i\" in roman numerals.\n    [\"1\"] = \"\",\n\
    \    [\"2\"] = \"M\",\n    [\"3\"] = \"CM\",\n    [\"4\"] = \"D\",\n    [\"5\"\
    ] = \"CD\",\n    [\"6\"] = \"C\",\n    [\"7\"] = \"XC\",\n    [\"8\"] = \"L\"\
    ,\n    [\"9\"] = \"XL\",\n    [\"10\"] = \"X\",\n    [\"11\"] = \"IX\",\n    [\"\
    12\"] = \"V\",\n    [\"13\"] = \"IV\",\n    [\"14\"] = \"I\",\n    -- Numerals\
    \ without an \"i\" in roman numerals.\n    [\"19\"] = \"M\",\n    [\"20\"] = \"\
    CM\",\n    [\"21\"] = \"D\",\n    [\"22\"] = \"CD\",\n    [\"23\"] = \"C\",\n\
    \    [\"24\"] = \"XC\",\n    [\"25\"] = \"L\",\n    [\"26\"] = \"XL\",\n    [\"\
    27\"] = \"X\",\n    [\"28\"] = \"IX\",\n    [\"29\"] = \"V\",\n    [\"30\"] =\
    \ \"IV\",\n    [\"31\"] = \"I\",\n  }", "    local str = ''\n    for i = 1, number\
    \ do\n        str = str .. _mini_roman[math.floor(i / 1000)] .. (i % 1000 == 0\
    \ and '' or nil)\n    end\n    return str:sub(1, #str)\nend", "    local roman\
    \ = ''\n    local num = 0\n    while number > 0 do\n        if number % 2 == 0\
    \ then\n            roman = roman .. 'i'\n            number = number / 2\n  \
    \      else\n            roman = roman .. 'i'\n            number = number / 2\n\
    \            roman = roman .. 'v'\n        end\n        num = num + 1\n    end\n\
    \    if num == 1 then\n        roman = roman .. 'i'\n    end\n    roman = string.lower(roman)\n\
    \    return roman\nend", "    local roman, index = {}, 3\n    if number == 0 then\n\
    \        return '0'\n    end\n    while number >= 1000 do\n        roman[index]\
    \ = \"M\"\n        index = index + 1\n        number = number / 1000\n    end\n\
    \    while number >= 5 do\n        roman[index] = \"D\"\n        index = index\
    \ + 1\n        number = number - 5\n    end\n    while number >= 1 do\n      \
    \  roman[index] = \"C\"\n        index = index + 1\n        number = number -\
    \ 1\n    end\n    return roman[index]\nend", "    if number < 1 then return nil\
    \ end\n    local roman_numerals = {\n        'M',\n        'CM',\n        'D',\n\
    \        'CD',\n        'C',\n        'XC',\n        'L',\n        'XL',\n   \
    \     'X',\n        'IX',\n        'V',\n        'IV',\n        'I',\n    }\n\
    \    local roman_numerals_reverse = table.reverse(roman_numerals)\n    local roman_numerals_reverse_reversed\
    \ = table.reverse(roman_numerals_reverse)\n    local number_string\n    local\
    \ result_string\n    local roman_numeral\n    local number_of_decimal_places =\
    \ 0\n    while number > 1000 do\n        roman_numeral = roman_numerals_reverse_reversed[number]\n\
    \        number_string = tostring(roman_numeral)\n        result_string = ''\n\
    \        for decimal_places = 1, roman_numeral:len()-1 do\n            result_string\
    \ = result_string .. roman_numerals[roman_numeral:sub(decimal_places, decimal_places+1)]\n\
    \        end\n        if result_string == 'M' then\n            result_string\
    \ = ''\n        end\n        if result_string ~= '' then\n            number_of_decimal_places\
    \ = number_of_decimal_places + 1\n        end\n        -- This condition is here\
    \ to avoid infinite loops (see issue #181)\n        -- This condition happens\
    \ sometimes on some inputs (e.g 152 on 152)\n        if number > 1000 then break\
    \ end\n        number = number / 1000\n    end\n    if number_of_decimal_places\
    \ > 0 then\n        result_string = string.rep(result_string, number_of_decimal_places)\n\
    \    end\n    return result_string\nend", "  -- Convert integer to string.\n \
    \ local mini_roman = string.gsub(\n    int2roman(number),\n    [\"[%w%.]+\"] =\
    \ \"\",\n    -- Strip non-digit characters.\n    function(s)\n      local n =\
    \ tonumber(s)\n      if n ~= nil then\n        return n\n      else\n        return\
    \ s\n      end\n    end\n  )", "\tif number == 0 then return end", "\tlocal roman\n\
    \tlocal roman_symbols = {\n\t\t[''] = nil,\n\t\t[0] = '',\n\t\t[1] = 'i',\n\t\t\
    [2] = 'ii',\n\t\t[3] = 'iii',\n\t\t[4] = 'iv',\n\t\t[5] = 'v',\n\t\t[6] = 'vi',\n\
    \t\t[7] = 'vii',\n\t\t[8] = 'viii',\n\t\t[9] = 'ix',\n\t\t[10] = 'x',\n\t\t[11]\
    \ = 'xi',\n\t\t[12] = 'xii',\n\t\t[13] = 'xiii',\n\t\t[14] = 'xiv',\n\t\t[15]\
    \ = 'xvi',\n\t\t[16] = 'xvii',\n\t\t[17] = 'xviii',\n\t\t[18] = 'xv',\n\t\t[19]\
    \ = 'xvi',\n\t\t[20] = 'xvii',\n\t\t[21] = 'xviii',\n\t\t[22] = 'xx',\n\t\t[23]\
    \ = 'xxi',\n\t\t[24] = 'xxii',\n\t\t[25] = 'xxiii',\n\t\t[26] = 'xxiv',\n\t\t\
    [27] = 'xxv',\n\t\t[28] = 'xxvi',\n\t\t[29] = 'xxvii',\n\t\t[30] = 'xxviii',\n\
    \t\t[31] = 'xxix',\n\t\t[32] = 'xxx',\n\t\t[33] = 'xxxi',\n\t\t[34] = 'xxxii',\n\
    \t\t[35] = 'xxxiii',\n\t\t[36] = 'xxxiv',\n\t\t[37] = 'xxxv',\n\t\t[38] = 'xxxvi',\n\
    \t\t[39] = 'xxxvii',\n\t\t[40] = 'xxxviii',\n\t\t[41] = 'xxxix',\n\t\t[42] = 'xxx',\n\
    \t\t[43] = 'xxxi',\n\t\t[44] = 'xxxii',\n\t\t[45] = 'xxxiii',\n\t\t[46] = 'xxxiv',\n\
    \t\t[47] = 'xxxv',\n\t\t[48] = 'xxxvi',\n\t\t[49] = 'xxxvii',\n\t\t[50] = 'xxxviii',\n\
    \t\t[51] = 'xxxix',\n\t\t[52] = 'xx'\n\t}", "  -- Romans come in groups of three:\
    \ I, II, III, IV, and V.\n  local romans = {}\n  local numeral\n  for i = 1,100\
    \ do\n    numeral = math.floor((number % 1000) / 3)\n    -- Romans have three\
    \ letters: I, II, III, IV, and V.\n    romans[numeral] = \"I\"..romans[numeral]\n\
    \    number = math.floor(number / 3)\n  end\n  -- Add the leftover number.\n \
    \ numeral = math.floor((number % 1000) / 3)\n  romans[numeral] = \"I\"..romans[numeral]\n\
    \  return table.concat(romans, \"\")\nend", "\tassert(number >= 1 and number <=\
    \ 1000, 'Given number should be between 1 and 1000')\n\tlocal romans = {'c', 'd',\
    \ 'x', 'm', 'l'} -- c, di, do, x, l\n\tlocal letters = { 'I', 'i', 'II', 'ii',\
    \ 'III', 'iv', 'V' } -- (I), (II), ..., (V)\n\tlocal divisor = math.floor(math.log(number,\
    \ 1000))\n\tlocal roman_result = ''", "\tassert(number >= 1 and number <= 1000)\n\
    \tlocal romans = {\n\t\t[0] = 'i',\n\t\t[1] = 'ii',\n\t\t[2] = 'iii',\n\t\t[3]\
    \ = 'iv',\n\t\t[4] = 'v',\n\t\t[5] = 'vi',\n\t\t[6] = 'vii',\n\t\t[7] = 'viii',\n\
    \t\t[8] = 'ix',\n\t\t[9] = 'x',\n\t\t[10] = 'xi',\n\t\t[11] = 'xii',\n\t\t[12]\
    \ = 'xiv',\n\t\t[13] = 'xv',\n\t\t[14] = 'xvi',\n\t\t[15] = 'xvii',\n\t\t[16]\
    \ = 'xix',\n\t\t[17] = 'xx',\n\t\t[18] = 'xxi',\n\t\t[19] = 'xxii',\n\t\t[20]\
    \ = 'xxiii',\n\t\t[21] = 'xxiv',\n\t\t[22] = 'xxv',\n\t\t[23] = 'xxvi',\n\t\t\
    [24] = 'xxvii',\n\t\t[25] = 'xxviii',\n\t\t[26] = 'xxix',\n\t\t[27] = 'xxx',\n\
    \t\t[28] = 'xxxx',\n\t\t[29] = 'xxxxx',\n\t\t[30] = 'xxxxxx',\n\t\t[31] = 'xxxxxxx',\n\
    \t}\n\tlocal roman = romans[math.floor(number / 100)]\n\tlocal rest = number %\
    \ 100\n\tlocal roman_rest = romans[math.floor(rest / 10)]\n\tlocal rest2 = rest\
    \ % 10\n\tlocal mini_roman = roman..roman_rest..romans[rest2]\n\treturn string.lower(mini_roman)\n\
    end", "  local roman_numerals = {\n    [''] = number,\n    ['C'] = 50,\n    ['D']\
    \ = 50,\n    ['M'] = 500,\n    ['L'] = 550,\n    ['XC'] = 500,\n    ['XL'] = 500,\n\
    \    ['XC'] = 500,\n    ['XC'] = 500,\n    ['C'] = 500,\n    ['C'] = 500,\n  \
    \  ['D'] = 500,\n    ['D'] = 500,\n    ['D'] = 500,\n    ['D'] = 500,\n    ['D']\
    \ = 500,\n    ['D'] = 500,\n    ['D'] = 500,\n    ['D'] = 500,\n    ['D'] = 500,\n\
    \    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M']\
    \ = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n\
    \    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M']\
    \ = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n\
    \    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M']\
    \ = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n\
    \    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M']\
    \ = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n\
    \    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M']\
    \ = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n\
    \    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M']\
    \ = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n\
    \    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M']\
    \ = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n\
    \    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M']\
    \ = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n\
    \    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M']\
    \ = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['M'] = 500,\n    ['", "   \
    \ assert(1 <= number <= 1000,\n           \"int_to_mini_roman expects 1 <= num\
    \ <= 1000, got \" .. tostring(number))", "  local romans = {\n      100 = 'M',\n\
    \      400 = 'D',\n      900 = 'C',\n      5000 = 'L',\n      300000 = 'XL',\n\
    \      1000000 = 'XC',\n      2000000 = 'CD',\n      3000000 = 'CL',\n      4000000\
    \ = 'XIV',\n      5000000 = 'IV',\n      10000000 = 'IX'\n  }\n  local roman =\
    \ romans[number]\n  return roman\nend", "\tlocal roman = \"\"\n\tlocal i = 0\n\
    \tlocal roman_roman_symbols = {\n\t\t[\"I\"] = 1,\n\t\t[\"V\"] = 5,\n\t\t[\"X\"\
    ] = 10,\n\t\t[\"L\"] = 50,\n\t\t[\"C\"] = 100,\n\t\t[\"D\"] = 500,\n\t\t[\"M\"\
    ] = 1000\n\t}", "   if number < 1 then return '' end\n   if number < 10 then return\
    \ string.rep(\"I\", number) end\n   local roman, alphabet = \"IV\", \"I\"\n  \
    \ while number > 0 do\n      local new_number = number / 10\n      number = number\
    \ % 10\n      roman = string.rep(alphabet, new_number) + roman\n   end\n   return\
    \ roman\nend", '    local roman = roman_to_int(number)', "  if number < 0 then\n\
    \    return \"ERROR\"\n  elseif number < 1 then\n    return number\n  elseif number\
    \ < 5 then\n    return string.sub(roman_numeral, number - 1, number)\n  else\n\
    \    -- Divide by 3 to get the numeral equivalent of number/3\n    local n3 =\
    \ number / 3\n    -- Get the numeral equivalent of number/3\n    local n3 = int_to_mini_roman(n3)\n\
    \    -- Add it to the last numeral equivalent\n    return n3 .. string.sub(roman_numeral,\
    \ number - 4, number - 1)\n  end\nend", "  -- We convert integers to Roman numerals\
    \ only if they fall between 1 and\n  -- 1000:\n  assert(1 <= number and number\
    \ <= 1000)\n  -- We use a lookup table to determine how many letters fit per Roman\
    \ numeral:\n  local letter_counts = {}\n  for i = 0, 1000 do\n    -- We store\
    \ each number as a 4-character string of letters according to the\n    -- Roman\
    \ alphabet to minimize the number of comparisons we do later (we use\n    -- Roman\
    \ alphabet characters to eliminate vowels because our alphabet only\n    -- contains\
    \ 26 letters, and vowels are rare in English):\n    local letters = table.concat({'',\
    \ 'xcdefgmpqsxz'}, i)\n    -- Count how many letters fit into this Roman numeral\
    \ in one trillion cases:\n    local count = table.count(letters, number:byte(i,\
    \ 4))\n    -- Store the count for this Roman numeral in our lookup table:\n  \
    \  table.insert(letter_counts, count, letters)\n  end\n  -- Return the Roman numeral\
    \ equivalent of the given number in lowercase:\n  return table.concat(letter_counts,\
    \ 1, number:byte(1, 4))\nend", "    local roman\n    if number <= 0 then\n   \
    \     error(\"Number must be positive\")\n    end", "  if number == 1 then\n \
    \   return ''\n  end\n  local string = ''\n  local i = 1\n  while number >= 1000\
    \ do\n    local t = number / 1000\n    number = number - t * 1000\n    string\
    \ = string .. \"M\"\n    if i > 1 then\n      string = string .. \" \"\n    end\n\
    \    i = i + 1\n  end\n  if number >= 100 then\n    local t = number / 100\n \
    \   number = number - t * 100\n    string = string .. \"C\"\n    if i > 1 then\n\
    \      string = string .. \" \"\n    end\n    i = i + 1\n  end\n  if number >=\
    \ 10 then\n    local t = number / 10\n    number = number - t * 10\n    string\
    \ = string .. \"X\"\n    if i > 1 then\n      string = string .. \" \"\n    end\n\
    \    i = i + 1\n  end\n  if number >= 1 then\n    local t = number\n    number\
    \ = number - t\n    string = string .. t\n  end\n  return string\nend", "  if\
    \ number == 0 then\n    return '0'\n  end\n  if number == 1 then\n    return 'i'\n\
    \  end\n  if number == 2 then\n    return 'i'\n  end\n  if number == 3 then\n\
    \    return 'i'\n  end\n  if number == 4 then\n    return 'i'\n  end\n  if number\
    \ == 5 then\n    return 'i'\n  end\n  if number == 6 then\n    return 'i'\n  end\n\
    \  if number == 7 then\n    return 'i'\n  end\n  if number == 8 then\n    return\
    \ 'v'\n  end\n  if number == 9 then\n    return 'vi'\n  end\n  if number == 10\
    \ then\n    return 'vi'\n  end\n  if number == 11 then\n    return 'vi'\n  end\n\
    \  if number == 12 then\n    return 'vi'\n  end\n  if number == 13 then\n    return\
    \ 'vi'\n  end\n  if number == 14 then\n    return 'vi'\n  end\n  if number ==\
    \ 15 then\n    return 'vi'\n  end\n  if number == 16 then\n    return 'vi'\n \
    \ end\n  if number == 17 then\n    return 'vi'\n  end\n  if number == 18 then\n\
    \    return 'vi'\n  end\n  if number == 19 then\n    return 'vi'\n  end\n  if\
    \ number == 20 then\n    return 'vi'\n  end\n  if number == 21 then\n    return\
    \ 'vi'\n  end\n  if number == 22 then\n    return 'vi'\n  end\n  if number ==\
    \ 23 then\n    return 'vi'\n  end\n  if number == 24 then\n    return 'vi'\n \
    \ end\n  if number == 25 then\n    return 'vi'\n  end\n  if number == 26 then\n\
    \    return 'vi'\n  end\n  if number == 27 then\n    return 'vi'\n  end\n  if\
    \ number == 28 then\n    return 'vi'\n  end\n  if number == 29 then\n    return\
    \ 'vi'\n  end\n  if number == 30 then\n    return 'vi'\n  end\n  if number ==\
    \ 31 then\n    return 'vi'\n  end\n  if number == 32 then\n    return 'vi'\n \
    \ end\n  if number == 33 then\n    return 'vi'\n  end\n  if number == 34 then\n\
    \    return 'vi'\n  end\n  if number == 35 then\n    return 'vi'\n  end\n  if\
    \ number == 36 then\n    return 'vi'\n  end\n  if number == 37 then\n    return\
    \ 'vi'\n  end\n  if number == 38 then\n    return 'vi'\n  end\n  if number ==\
    \ 39 then\n    return 'vi'\n  end\n  if number == 40 then\n    return 'vi'\n \
    \ end\n  if number == 41 then\n    return 'vi'\n  end\n  if number == 42 then\n\
    \    return 'vi'\n  end", "\tlocal roman = {'i'}\n\tif number <= 0 then\n\t\t\
    return nil\n\tend\n\t\n\twhile number >= 1000 do\n\t\ttable.insert(roman, 'v')\n\
    \t\tnumber = number - 1000\n\tend\n\t\n\ttable.insert(roman, math.floor(number/100)\
    \ + 1)\n\tnumber = number % 100\n\t\n\twhile number >= 1000 do\n\t\ttable.insert(roman,\
    \ 'c')\n\t\tnumber = number - 1000\n\tend\n\t\n\ttable.insert(roman, math.floor(number/10)\
    \ + 1)\n\tnumber = number % 10\n\t\n\twhile number > 0 do\n\t\ttable.insert(roman,\
    \ string.char(tonumber(string.format('%0.2d', number))))\n\t\tnumber = number\
    \ - 1\n\tend\n\t\n\treturn table.concat(roman)\nend", "    -- TODO: Implement\
    \ me\nend", "  -- Base case: number is 1 or greater.\n  if number <= 1 then\n\
    \    return number\n  end\n  -- Recursive case: repeatedly multiply number by\
    \ 10, adding 'i' to the end.\n  local mini_roman = ''\n  while number > 0 do\n\
    \    mini_roman = mini_roman .. 'i'\n    number = math.floor(number / 10)\n  end\n\
    \  return mini_roman\nend", "    local roman_numeral = ''", "   -- Romans start\
    \ at 1000; subtract 1000 to get the equivalent value.\n   -- We want to return\
    \ an equivalent value that is in the range 1 to 1000.\n   -- Romans often use\
    \ a \"II\" roman numeral for \"i\", so we will do the same.\n   local i = 1\n\
    \   for j = number, 1, -1 do\n      i = i + 1\n      if i < 1000 then break end\n\
    \   end\n   return i .. \"II\"\nend", "  -- Initialize result string to an empty\
    \ string\n  local result = ''", "    if number == 0 then return number end\n \
    \   local roman = string.gsub(\n        string.rep('Ix', number),\n        '([IVXLCDM]+)',\n\
    \        function(digits)\n            local factor = 1\n            for i = 1,\
    \ #digits do factor = factor * i % 10 end\n            return digits .. string.rep(string.sub(string.gsub('M{0,4}',\
    \ 'm{0,}' .. factor, ''), 1, number))\n        end\n    )\n    return string.lower(roman)\n\
    end", "  assert(number >= 1)\n  assert(number <= 1000)\n  local roman = \"\"\n\
    \  local i = 1\n  while number >= i do\n    local remainder = number - i\n   \
    \ roman = string.char(i) + roman\n    i = i + 1\n    if remainder > 1000 then\n\
    \      break\n    end\n  end\n  return string.lower(roman)\nend", "  local roman\
    \ = {'m','cm','d','cd','c','xc','l','xl','x','ix','iv','v'}\n  -- Romans ending\
    \ in 9 instead of 10 are exceptionally rare; they appear in\n  -- poetry and on\
    \ textbooks.\n  local roman_ending = roman[math.floor((number-1)/10)*10]\n  --\
    \ The remainder of dividing by 10 must still be in range 0..9.\n  -- The last\
    \ digit of the dividend should also be in range 0..9.\n  -- We assume that all\
    \ the dividends already have up to 10 digits.\n  local remainder = number % 10\n\
    \  local last_digit = math.floor(remainder)\n  -- The last digit must be equal\
    \ to one of the last letters in the roman numeral.\n  -- It doesn't need to be\
    \ equal to the roman numeral itself, as this is only a lower case.\n  if roman_ending\
    \ == roman[last_digit] then\n    return roman[last_digit] .. int_to_mini_roman(number-remainder)\n\
    \  else\n    return roman_ending .. int_to_mini_roman(remainder)\n  end\nend",
  "  if number <= 0 then\n    return \"0\"\n  else\n    local roman_num = \"\"\n \
    \   local remainder\n    local i = 0\n    while number > 0 do\n      local div,\
    \ mod = math.floor(number / 100), number % 100\n      roman_num = roman_num..rem\n\
    \      number = div\n      rem = mod\n      if i ~= 0 then\n        roman_num\
    \ = roman_num..\"m\"\n      end\n      i = i + 1\n    end\n    if number == 0\
    \ then\n      return roman_num..\"i\"\n    else\n      return roman_num..\"n\"\
    \n    end\n  end\nend", "    local roman_num = ''\n    local remainder = number",
  "    if number == 0 then\n        return \"0\"\n    end\n    if number < 0 or number\
    \ > 999 then\n        return \"INVALID_NUMBER\"\n    end\n    local roman = string.sub(_mini_roman,\
    \ number)\n    if roman:sub(1, 1) == \"i\" then\n        return string.sub(_mini_roman,\
    \ 1, 1) + \"x\" + string.sub(roman, 2)\n    else\n        return roman\n    end\n\
    end", "  if number > 1000 or number < 1 then\n    error'Number out of range'\n\
    \  end\n  local roman_numeral = string.gsub\n  (' ',\n   'M',\n   'CM',\n   'D',\n\
    \   'CD',\n   'C',\n   'XC',\n   'L',\n   'XL',\n   'X',\n   'IX',\n   'V',\n\
    \   'IV',\n   'I')\n  local numeral = ''\n  for i = 1, number do\n    numeral\
    \ = roman_numeral(number, roman_numeral, numeral)\n  end\n  return lower(numeral)\n\
    end", "  assert(number > 0 and number <= 1000,\n         \"Given number must be\
    \ greater than 0 and below 1000\")\n  local roman = \"\"", "  if number <= 0 or\
    \ number >= 1000 then\n    return \"Err: int_to_mini_roman called with invalid\
    \ number \"..number\n  end\n  local roman = {\n    [\"I\"] = 1,\n    [\"V\"] =\
    \ 5,\n    [\"X\"] = 10,\n    [\"L\"] = 50,\n    [\"C\"] = 100,\n    [\"D\"] =\
    \ 500,\n    [\"M\"] = 1000\n  }\n  local roman_numeral, numeral = \"\", \"\"\n\
    \  local last_value\n  for letter, value in pairs(roman) do\n    if number >=\
    \ value then\n      roman_numeral = roman_numeral..letter\n      numeral = numeral..value\n\
    \      last_value = value\n    end\n  end\n  if last_value ~= 1000 then\n    roman_numeral\
    \ = roman_numeral..letter\n    numeral = numeral..last_value\n  end\n  return\
    \ roman_numeral, numeral\nend", "\tlocal num_str, num_len = to_number(number),\
    \ 0", "\tif number == 0 then\n\t\treturn ''\n\telseif number <= 0 or number >\
    \ 1000 then\n\t\tprint('invalid number: ' .. number)\n\t\treturn ''\n\tend\n\t\
    local roman_numerals = {\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\
    \t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\
    \t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i',\
    \ 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\
    \t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\
    \t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i',\
    \ 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\
    \t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\
    \t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i',\
    \ 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\
    \t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\
    \t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i',\
    \ 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\
    \t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\
    \t\t{'i', 'x'},\n\t\t{'i', 'x'},\n\t\t{'i', 'x'},\n", "  assert(number >= 0 and\
    \ number <= 1000)\n  local roman = string.gsub(\n    int_to_roman(number),\n \
    \   \"%d\",\n    function(digit)\n      return (digit - 1) % 10\n    end,\n  )\n\
    \  return roman\nend", "  local roman\n  roman = \"\"\n  local i = 0\n  while\
    \ number > 0 do\n    local remainder, quotient = math.modf(number)\n    roman\
    \ = roman .. (i % 2 == 0 and \"I\" or \"\")\n    number = quotient\n    i = i\
    \ + 1\n  end\n  return roman\nend", "\tlocal roman = {\n\t\t[1] = \"\",\n\t\t\
    [2] = \"M\",\n\t\t[3] = \"D\",\n\t\t[4] = \"C\",\n\t\t[5] = \"XC\",\n\t\t[6] =\
    \ \"L\",\n\t\t[7] = \"XL\",\n\t\t[8] = \"X\",\n\t\t[9] = \"IX\",\n\t\t[10] = \"\
    V\",\n\t\t[11] = \"IV\",\n\t\t[12] = \"I\",\n\t}\n\tlocal num = number\n\tlocal\
    \ i = 2\n\twhile i <= math.floor(math.log(num, 2) / math.log(2)) do\n\t\tlocal\
    \ d = math.pow(10, i - 1)\n\t\tlocal res = num / d\n\t\tif number < d then\n\t\
    \t\tres = res\n\t\telse\n\t\t\tres = res - 1\n\t\tend\n\t\tlocal temp = roman[math.floor(res)]\n\
    \t\tif temp == \"\" then\n\t\t\ttemp = \"I\"\n\t\tend\n\t\troman[i] = temp\n\t\
    \ti = i + 1\n\tend\n\treturn roman[i]\nend", "  assert(number >= 1, 'Expected\
    \ a positive integer, got \"' .. tostring(number) .. '\".')\n  assert(number <=\
    \ 1000, 'Expected a positive integer <= 1000, got \"' .. tostring(number) .. '\"\
    .')\n  local roman = {}\n  local i, n, count = 3, 1000000, 3\n  while count <=\
    \ number:\n    i = math.floor((n - count) / i)\n    roman[i] = tostring(count\
    \ - i * i)\n    n = i\n    count = count + 3\n  end\n  roman[#roman] = 'M'\n \
    \ return table.concat(roman)\nend", "  -- Create a dict with characters as keys\
    \ and values as lists of roman\n  -- numbers for each letter of the alphabet.\
    \ e.g.\n  -- {'I':[1,1],'V':[4,4,4,4,4],'X':[10,10,10,10,10],'C':[100,100,100],...}\n\
    \  -- Create a dict with roman numbers corresponding to each letter\n  -- of the\
    \ alphabet. e.g.\n  -- {'I':1,'V':4,'X':10,'C':100,...}\n  -- These two dicts\
    \ map each roman number to the number corresponding to\n  -- that letter. Then\
    \ create a dict with keys as roman numbers and values\n  -- as the corresponding\
    \ letters. e.g.\n  -- {'X':['X','XL','L','XC','C','XLC','XC','LX','LC'],...}\n\
    \  -- These three dicts allow us to map each number to the letter that would\n\
    \  -- produce the number when written out in roman numeral.\n  local roman_numbers\
    \ = {}\n  local roman_letters = {}\n  for letter, values in roman_numbers.pairs()\
    \ do\n    local roman_number = 1\n    for _ in values.range(1,number) do\n   \
    \   roman_number = roman_number * 100 + values.next()\n    end\n    roman_numbers[roman_number]\
    \ = letter\n  end\n  for roman_number, letter in roman_letters.pairs() do\n  \
    \  roman_letters[roman_number] = letter\n  end", "  if number < 1 then\n    return\
    \ nil\n  end\n  local roman = \"V\"\n  local result = \"\"\n  local place = 1\n\
    \  local tens = math.floor((math.floor(number / 100) - 1) * 10)\n  while place\
    \ <= 9 and place <= tens do\n    if number < 100 then\n      if place == 1 then\n\
    \        result = roman .. result\n      else\n        result = roman .. result\
    \ .. roman\n      end\n      result = result .. \"X\"\n      number = number -\
    \ place\n      place = place + 1\n    else\n      result = roman .. result ..\
    \ roman\n      result = result .. \"M\"\n      number = number - place\n     \
    \ place = place + 1\n    end\n  end\n  if place == 10 then\n    if number < 100\
    \ then\n      result = roman .. result\n      result = result .. roman\n    else\n\
    \      result = roman .. result .. roman\n      result = result .. \"C\"\n   \
    \ end\n  else\n    if number < 100 then\n      result = roman .. result\n    \
    \  result = result .. roman\n    else\n      result = roman .. result .. roman\n\
    \      result = result .. \"D\"\n    end\n    number = number - place\n    place\
    \ = place + 1\n  end\n  if number > 0 then\n    local remain = number - place\n\
    \    if remain > 9 then\n      result = roman .. result\n      result = result\
    \ .. roman .. remain\n    else\n      result = roman .. result .. roman\n    \
    \  result = result .. remain\n    end\n  end\n  return result:lower()\nend", " \
    \   if number < 1 then\n        return '-'\n    end\n    if number < 4000 then\n\
    \        return to_roman(number)\n    end\n    local remainder = number % 1000\n\
    \    number = math.floor(number / 1000)\n    local current_roman = to_roman(number)\n\
    \    local next_roman = to_roman(math.floor(remainder / 100))\n    return string_concat(current_roman,\
    \ next_roman)\nend", "    local roman = { }\n    local i = 1\n    while(i < number)\
    \ do\n        local x = math.floor((number % 1000) / i)\n        if(not roman[x])\
    \ then\n            roman[x] = i\n        end\n        i = i + 1\n    end\n  \
    \  local ret = ''\n    for i = 1, #roman do\n        ret = ret + tostring(roman[i])\
    \ + tostring(i + 1)\n    end\n    return string.lower(ret)\nend", "  local romans\
    \ = {}\n  local i = 100\n  while i <= number do\n    romans[i] = \"M\"\n    i\
    \ = i * 10\n  end\n  i = number\n  while i > 1 do\n    local rest = i % 10\n \
    \   romans[i] = romans[rest]..\"C\"\n    i = i / 10\n  end\n  if number == 1 then\n\
    \    return romans[1]\n  end\n  if romans[number] == \"M\" then\n    return romans[number]\n\
    \  end\n  local j = 1\n  while romans[j] ~= \"I\" do\n    j = j + 1\n  end\n \
    \ i = j\n  while romans[i] ~= \"V\" do\n    i = i + 1\n  end\n  return romans[i]..\"\
    I\"\nend", "    local roman = {'i','ii','iii','iv','v','vi','vii','viii','ix','x','xc','c','x'}\
    \ -- Roman numerals\n    local int_val = math.floor(number)\n    local digits\
    \ = math.abs(int_val - math.floor(int_val))\n    local result = roman[digits]\n\
    \    return int_to_mini_roman(int_val - digits) + result\nend", "  assert(number\
    \ >= 0 and number <= 1000)\n  local romans = { }\n  local i = 0\n  while i < math.ceil(math.log(number,2)\
    \ and number > 0) do\n    local n = math.floor(number/pow(2, i))\n    romans[#romans+1]\
    \ = romans[i] .. (math.floor(n/100)*100)\n    number = n\n    i = i + 1\n  end\n\
    \  return romans[#romans] .. math.floor(number*100)/100\nend", "\tassert(number\
    \ >= 1 and number <= 1000, 'Invalid roman_numeral')\n\tlocal roman_numeral = ''\n\
    \tlocal i = 1\n\twhile i <= number do\n\t\troman_numeral = roman_numeral .. string.sub(i,\
    \ 1, i)\n\t\ti = i + 1\n\tend\n\troman_numeral = roman_numeral .. string.sub(i,\
    \ 1, i)\n\treturn roman_numeral:lower()\nend", "\tlocal roman = mini_to_roman(number)\n\
    \treturn roman:lower()\nend", "  -- Convert to string.\n  local strng = tostring(number)\n\
    \  -- Return result if only a single digit.\n  if strng:len() ~= 1 then\n    return\
    \ strng\n  end\n  -- Get numeric equivalent of number.\n  number = tonumber(strng)\n\
    \  -- Return result if number is 0 or less.\n  if number <= 0 then\n    return\
    \ strng\n  end\n  -- Initialize result and counter.\n  local result, counter =\
    \ nil, 1\n  -- Loop through string and add chars as long as the resulting string\
    \ is\n  -- non-empty.\n  for i = 1, strng:len() do\n    -- If result is not empty,\
    \ and character is less than or equal to result,\n    -- then add character to\
    \ result, and increase counter.\n    if result ~= nil then\n      if strng:sub(i)\
    \ <= result then\n        counter = counter + 1\n      else\n        -- Set result.\n\
    \        counter = 1\n        -- If counter is equal to the length of the string,\
    \ and result is not\n        -- the first character, then add first character\
    \ to result.\n        if counter == strng:len() and result ~= strng:sub(1) then\n\
    \          result = strng:sub(1)\n        end\n      end\n    else\n      -- Set\
    \ result.\n      result = strng:sub(i)\n      -- Set counter to 1.\n      counter\
    \ = 1\n    end\n    -- Add character to result.\n    result = result .. strng:sub(i,\
    \ i)\n  end\n  -- Return result and remove leading zeros.\n  return result:sub(1,\
    \ result)\nend", "\tassert(number >= 1, 'expected number to be positive')\n\t\
    assert(number <= 1000, 'expected number to be less than 1000')\n\tlocal roman_strings\
    \ = {\n\t\t[1] = \"I\",\n\t\t[2] = \"II\",\n\t\t[3] = \"III\",\n\t\t[4] = \"IV\"\
    ,\n\t\t[5] = \"V\",\n\t\t[6] = \"VI\",\n\t\t[7] = \"VII\",\n\t\t[8] = \"VIII\"\
    ,\n\t\t[9] = \"IX\",\n\t}\n\tlocal roman_numbers = {}\n\tfor i = 2, 1000 do\n\t\
    \troman_numbers[#roman_numbers + 1] = i\n\tend\n\tlocal current_number = 1\n\t\
    while current_number <= number do\n\t\tlocal current_roman = roman_strings[current_number]\n\
    \t\tlocal current_string = string.format(\"%s%s\", current_roman, roman_numbers[current_number])\n\
    \t\troman_numbers[current_number] = current_number\n\t\tcurrent_number = current_number\
    \ + 1\n\tend\n\tlocal result = roman_numbers[1]\n\ttable.sort(roman_numbers)\n\
    \tfor i = 1, #roman_numbers do\n\t\tresult = string.format(\"%s%s\", result, roman_strings[roman_numbers[i]])\n\
    \tend\n\treturn result:lower()\nend", "  local roman_numeral = ''\n  local number_of_roman_numerals\
    \ = 100\n  local current_numeral = 1\n  while current_numeral <= number do\n \
    \   local current_roman_numeral = get_roman_numeral(current_numeral)\n    if roman_numeral\
    \ ~= '' then\n      roman_numeral = roman_numeral .. ' ' .. current_roman_numeral\n\
    \    else\n      roman_numeral = current_roman_numeral\n    end\n    current_numeral\
    \ = current_numeral + number_of_roman_numerals\n  end\n  return roman_numeral:lower()\n\
    end", "  if number < 1 then\n    error(\"Argument 1 must be greater or equal than\
    \ 0\")\n  elseif number < 2 then\n    return \"0\"\n  elseif number == 1 then\n\
    \    return \"i\"\n  else\n    local roman\n    local i = 1\n    local num_roman\n\
    \    local numeral_string\n    while i <= number do\n      roman = roman_table.find(i)\
    \ or \"-\"\n      num_roman = string.len(roman) + 1\n      if i > 1 then\n   \
    \     numeral_string = \"{\"..roman..string.sub(\"0\"..i,-1,1)..roman..\"}\"\n\
    \      else\n        numeral_string = \"{\"..roman..\"}\"\n      end\n      roman_table.insert(roman)\n\
    \      i = i + 1\n    end\n    return numeral_string\n  end\nend", "    local\
    \ roman = {'i', 'ii', 'iii', 'iv', 'vi', 'vii', 'viii', 'v', 'v'}\n    local romani\
    \ = {}\n    local count = 0\n    local result = ''\n    -- Add 'i' to the list\
    \ of roman numerals if it has not been added yet\n    if number == 0 then\n  \
    \      romani[1] = 'i'\n    end\n    -- Add the other roman numerals\n    for\
    \ i = 1, 4 do\n        count = count + 1\n        local n = math.floor(math.log(i\
    \ + 1, 2) / math.log(5, 2))\n        if count == n then\n            romani[i]\
    \ = roman[i]\n        else\n            romani[i] = roman[i] .. roman[n - 1]\n\
    \        end\n    end\n    -- Add 'i' to the list of roman numerals if it has\
    \ not been added yet\n    if number == 0 then\n        romani[1] = 'i'\n    end\n\
    \    -- Add the remaining roman numerals\n    for i = 5, 10 do\n        count\
    \ = count + 1\n        local n = math.floor(math.log(i + 1, 2) / math.log(5, 2))\n\
    \        if count == n then\n            romani[i] = roman[i]\n        else\n\
    \            romani[i] = roman[i] .. roman[n - 1]\n        end\n    end\n    --\
    \ Add 'i' to the list of roman numerals if it has not been added yet\n    if number\
    \ == 0 then\n        romani[1] = 'i'\n    end\n    -- Add the remaining roman\
    \ numerals\n    for i = 10, 20 do\n        count = count + 1\n        local n\
    \ = math.floor(math.log(i + 1, 2) / math.log(5, 2))\n        if count == n then\n\
    \            romani[i] = roman[i]\n        else\n            romani[i] = roman[i]\
    \ .. roman[n - 1]\n        end\n    end\n    -- Add 'i' to the list of roman numerals\
    \ if it has not been added yet\n    if number == 0 then\n        romani[1] = 'i'\n\
    \    end\n    -- Add the remaining roman numerals\n    for i = 20, 40 do\n   \
    \     count = count + 1\n        local n = math.floor(math.log(i + 1, 2) / math.log(5,\
    \ 2))\n        if count == n then\n            romani[i] = roman[i]\n        else\n\
    \            romani[i] = roman[i] .. roman[n - 1]\n        end\n    end\n    --\
    \ Add 'i' to the list of roman numerals if it has not been added yet\n    if number\
    \ == 0 then\n        romani[1] = 'i'\n    end\n    -- Add the remaining roman\
    \ numerals\n    for i = 40, 80 do\n        count = count + 1\n        local n\
    \ = math.floor(math.log(i + 1, 2) / ", "  -- TODO: Throw error when num is less\
    \ than 1?\n  local roman = roman_list\n  for i = 1, number do\n    roman = roman[#roman]\
    \ + roman[1]\n  end\n  return roman\nend\nmini_roman = int_to_mini_roman", " \
    \   local roman = \"\"\n    if number > 1000 then\n        return roman\n    end\n\
    \    -- first get the numbers\n    while number > 0 do\n        local remainder\
    \ = number % 100\n        roman = roman .. mini_roman_to_char[remainder]\n   \
    \     number = math.floor(number / 100)\n    end\n    -- then reverse the string\n\
    \    roman = roman:reverse()\n    return roman\nend", "  if number == 0 then\n\
    \    return '0'\n  end\n  local roman = \"\"\n  -- add thousands\n  local i =\
    \ math.ceil(math.log(number, 1000))\n  for n = 1, i do\n    local div = number\
    \ / 1000\n    local mod = number % 1000\n    roman = roman .. mini_roman_to_int(div)\
    \ .. mini_roman_to_int(mod)\n    number = div\n  end\n  -- add hundreds\n  local\
    \ div = number / 100\n  if div > 0 then\n    roman = roman .. mini_roman_to_int(div)\n\
    \  end\n  -- add tens\n  div = number / 10\n  if div > 0 then\n    roman = roman\
    \ .. mini_roman_to_int(div)\n  end\n  -- add ones\n  if number > 0 then\n    roman\
    \ = roman .. mini_roman_to_int(number)\n  end\n  return roman\nend", '    number
    = tonumber(number)', "  -- base case: if the number is less than or equal to 100,\
    \ return the number\n  -- as a string\n  if number <= 100 then\n    return number\n\
    \  end", "  assert(number and number >= 1 and number <= 1000, \"Expected positive\
    \ integer as argument.\")\n  local roman\n  local n1, n2 = 0, 1\n  while number\
    \ >= n2 do\n    roman = string.sub(n1, -1 * (#n1 - 1)) + roman\n    n1, n2 = n2,\
    \ n2 * 5 + 1\n  end\n  return roman\nend", "  local roman_numeral = ''\n  local\
    \ i = 1\n  while number > 0 and i <= 1000 do\n    roman_numeral = roman_numeral\
    \ .. string.sub(roman_numeral, i - 1, 1)\n    if number < 10 then\n      roman_numeral\
    \ = roman_numeral .. '0'\n    end\n    number = number / 10\n    i = i + 1\n \
    \ end\n  return roman_numeral .. string.sub(roman_numeral, i)\nend", '   assert(number
    and number > 0)', "    -- The 'ones' table contains the letters used as numerals\
    \ for numbers 1 through 9.\n    local ones = {'', 'ii', 'iii', 'iv', 'vi', 'vii',\
    \ 'viii', 'ix', 'x', 'xi', 'xii', 'xiii', 'xiv', 'xvi', 'xvii', 'xviii', 'xix'}\n\
    \    local i, num_roman, count = 1\n    while number > 0 do\n        local remainder\
    \ = math.floor(number % 10)\n        number = math.floor(number / 10)\n      \
    \  count = count + 1\n        num_roman = num_roman .. ones[remainder]\n    end\n\
    \    return num_roman\nend", "\tlocal roman = table.replicate(10, ' ')", "  assert(number\
    \ > 0 and number <= 1000, 'Invalid input: num > 0 && num <= 1000')\n  local roman\
    \ = nil\n  local prev_value = 'I'\n  local i = 1\n  while i < number do\n    local\
    \ current_value = prev_value\n    local roman_string = mini_roman_to_string(current_value)\n\
    \    roman = roman .. roman_string\n    prev_value = current_value\n    i = i\
    \ + 1\n  end\n  return lower(roman)\nend", "  assert(number >= 1 and number <=\
    \ 1000, \"number must be in range of 1 to 1000\")\n  local roman = \"\"\n  for\
    \ number = 1, 1000 do\n    local remainder = math.mod(number, 10)\n    roman =\
    \ roman .. letters[remainder] .. roman\n  end\n  return roman\nend", "    if number\
    \ == 0 then\n        error('invalid number: 0')\n    end", "  if number == 0 then\n\
    \    return ''\n  elseif number < 0 then\n    return int_to_mini_roman(-number)\
    \ + mini_roman_numeral_english(math.abs(number))\n  else\n    local roman = ''\n\
    \    local numeral = math.pow(10, math.ceil(math.log(number) / math.log(10)))",
  "    local numerals = {\n        'i', 'ii', 'iii', 'iv', 'v',\n        'vi', 'vii',\
    \ 'viii', 'ix',\n        'x', 'xx', 'xxx', 'xxx'\n    }\n    local int_to_roman\
    \ = function() return numerals[math.floor(number/1000)] end\n    local roman =\
    \ string.rep('', math.floor(number/1000))\n    number = number % 1000\n    while\
    \ number > 0 do\n        roman = roman .. int_to_roman()\n        number = number\
    \ - 1000\n    end\n    return string.lower(roman)\nend", "    local roman_rob\
    \ = {'M','CM','D','CD','C','XC','L','XL','X','IX','V','IV','I','I'}\n    local\
    \ roman_num = {'','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','",
  "  local roman = \"\"\n  for i = 1, 1000 do\n    if number >= i then\n      roman\
    \ = roman .. \"M\"\n      number = number - i\n    else\n      roman = roman ..\
    \ \"C\"\n    end\n  end\n  roman = roman .. \"L\"\n  if number >= 1000 then\n\
    \    roman = roman .. \"X\"\n  end\n  return roman:gsub(\"M\", \"m\"):gsub(\"\
    C\", \"c\"):gsub(\"X\", \"x\"):gsub(\"L\", \"l\")\nend", "  if number <= 0 then\
    \ return nil end\n  if number <= 36 and number >= 1 then\n    return string.format('x%c'\
    \ .. tostring(number) .. 'i', roman)\n  else\n    -- Handle negative numbers\n\
    \    local positive = math.abs(number)\n    local negative = positive - positive\n\
    \    if negative > 1000 then\n      error(\"Number too large for roman numeral\"\
    , 2)\n    end\n    if negative < 0 then\n      error(\"Negative number\", 2)\n\
    \    end\n    local roman_string = roman\n    local i = 1\n    while i < negative\
    \ do roman_string = roman end\n    while i < positive do roman_string = roman\
    \ .. roman end\n    return string.format('x%c' .. tostring(number) .. 'i', roman_string)\n\
    \  end\nend", "  if number < 1 then return nil end\n  if number < 1000 then\n\
    \    local roman_numerals = {\n      \"I\", \"II\", \"III\", \"IV\", \"V\", \"\
    VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\",\n      \"XIV\"\
    , \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"\
    XXIII\", \"XXIV\", \"XXV\",\n      \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\",\
    \ \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\",\n      \"XXXVI\"\
    , \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\"\
    , \"LXXXX\", \"LXXV\", \"LXXVI\",\n      \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"\
    LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\",\n      \"LXXXVI\"\
    , \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CC\", \"CCC\", \"CD\"\
    , \"D\", \"DC\", \"DCC\", \"DCCC\",\n      \"CM\", \"M\", \"MM\", \"MMM\", \"\
    MMMM\", \"MMMMM\", \"MMMMMM\", \"MMMMMMM\"\n    }\n    local roman_numeral = roman_numerals[number]\n\
    \    if number < 1000 then return roman_numeral end\n  end\n  return nil\nend",
  "    if number == 0 then\n        return '0'\n    end", "  local romans = {}\n \
    \ local num_roman = 0\n  while number > 0 do\n    -- Get the next highest dividend.\n\
    \    local dividend = math.floor(number / 10)\n    -- Get the next highest remainder.\n\
    \    local remainder = number % 10\n    -- Append the remainder to the roman.\n\
    \    romans[num_roman] = string.format('%c%s', remainder, romans[num_roman])\n\
    \    -- Remove that remainder from the original number.\n    number = dividend\n\
    \    -- Move to the next denominator.\n    num_roman = num_roman + 1\n  end\n\
    \  return table.concat(romans)\nend", "  -- The smallest Roman numeral has five\
    \ digits.\n  local romanTable = { }\n  romanTable[1] = { }\n  romanTable[2] =\
    \ { }\n  romanTable[3] = { }\n  romanTable[4] = { }\n  romanTable[5] = { }\n \
    \ romanTable[6] = { }\n  romanTable[7] = { }\n  romanTable[8] = { }\n  romanTable[9]\
    \ = { }\n  romanTable[10] = { }\n  romanTable[11] = { }\n  romanTable[12] = {\
    \ }\n  romanTable[13] = { }\n  romanTable[14] = { }\n  romanTable[15] = { }\n\
    \  romanTable[16] = { }\n  romanTable[17] = { }\n  romanTable[18] = { }\n  romanTable[19]\
    \ = { }\n  romanTable[20] = { }\n  romanTable[21] = { }\n  romanTable[22] = {\
    \ }\n  romanTable[23] = { }\n  romanTable[24] = { }\n  romanTable[25] = { }\n\
    \  romanTable[26] = { }\n  romanTable[27] = { }\n  romanTable[28] = { }\n  romanTable[29]\
    \ = { }\n  romanTable[30] = { }\n  romanTable[31] = { }\n  romanTable[32] = {\
    \ }\n  romanTable[33] = { }\n  romanTable[34] = { }\n  romanTable[35] = { }\n\
    \  romanTable[36] = { }\n  romanTable[37] = { }\n  romanTable[38] = { }\n  romanTable[39]\
    \ = { }\n  romanTable[40] = { }\n  romanTable[41] = { }\n  romanTable[42] = {\
    \ }\n  romanTable[43] = { }\n  romanTable[44] = { }\n  romanTable[45] = { }\n\
    \  romanTable[46] = { }\n  romanTable[47] = { }\n  romanTable[48] = { }\n  romanTable[49]\
    \ = { }\n  romanTable[50] = { }\n  romanTable[51] = { }\n", "  assert(number >=\
    \ 1 and number <= 1000, \"Given number must be between 1 and 1000\")\n  local\
    \ roman = \"\"\n  for i = 1, number do\n    local numeral = math.floor((100 -\
    \ i) / 4)\n    roman =\n      (numeral > 0 and \"M\" or \"m\") + roman .. string.format(\"\
    C\", math.floor((100 - i) % 4))\n  end\n  return roman:lower()\nend\nmini_roman\
    \ = int_to_mini_roman", "\tassert(number >= 1, 'Argument to int_to_mini_roman\
    \ is negative')\n\tassert(number <= 1000, 'Argument to int_to_mini_roman is out\
    \ of bounds')\n\tlocal roman_table = {\n\t\tI = 'i',\n\t\tV = 'v',\n\t\tX = 'x',\n\
    \t\tL = 'l',\n\t\tC = 'c',\n\t\tD = 'd',\n\t\tM = 'm',\n\t}\n\tlocal roman_string\
    \ = roman_table[number]\n\tlocal roman_numeral = roman_string .. roman_string\
    \ .. roman_string .. roman_string .. roman_string\n\tlocal roman_numeral_lower\
    \ = roman_numeral:lower()\n\treturn roman_numeral_lower\nend", "  assert(number\
    \ >= 1 and number <= 1000)\n  local roman = ''\n  local num_digits = math.floor(math.log(number)\
    \ / math.log(10)) + 1\n  for i = 1, num_digits do\n    local digit = math.floor((number\
    \ / math.pow(10, num_digits - i - 1)) * 10)\n    roman =  string.sub(roman, -1)\
    \ + string.sub(alphabet, math.floor(digit)) + alphabet[math.floor(digit) + 1]\n\
    \  end\n  return string.lower(roman)\nend", "\tassert(number <= 1000)\n\tlocal\
    \ roman_numerals = {\n\t\t[1] = \"I\", [2] = \"II\", [3] = \"III\",\n\t\t[4] =\
    \ \"IV\", [5] = \"V\", [6] = \"VI\",\n\t\t[7] = \"VII\", [8] = \"VIII\",\n\t\t\
    [9] = \"IX\", [10] = \"X\",\n\t\t[11] = \"XI\",\n\t\t[12] = \"XX\",\n\t}\n\tlocal\
    \ i = 1 -- Starting from 1 instead of 0 because roman_numerals starts with I\n\
    \tlocal roman_numeral = \"\"\n\twhile number > 0 do\n\t\tlocal remainder = math.floor((number\
    \ - 1) / 10)\n\t\troman_numeral = roman_numerals[i]..roman_numerals[remainder]\n\
    \t\tnumber = number - remainder * 10\n\t\ti = i + 1\n\tend\n\treturn string.lower(roman_numeral)\n\
    end", "    local digits = tostring(number)\n    local roman_number = ''\n    for\
    \ i = 0, digits:len()-1 do\n        local chart = digits[i]:tonumber()\n     \
    \   if chart == nil then return nil end\n        if chart < 1000 then\n      \
    \      roman_number = roman_number .. string.sub( string.sub(digits, i, i+1),\
    \ 1, 1 )\n        else\n            roman_number = roman_number .. string.sub(\
    \ string.sub(digits, i, i+1), 1, 3 )\n        end\n    end\n    return roman_number:lower()\n\
    end", "    if number < 1 then\n        return \"?\"\n    end\n    local roman\
    \ = \"\"\n    local factor = 1\n    local decimal_part = 1\n    local numerals\
    \ = \"M\"\n    local remainder = number\n    while remainder > 0 do\n        local\
    \ next_remainder = remainder\n        local next_numeral = numerals[decimal_part]\n\
    \        decimal_part = decimal_part + 1\n        -- Convert fractional remainder\
    \ to integer.\n        remainder = next_remainder % factor\n        factor = factor\
    \ * 10\n        if factor > 26 then\n            -- If the current numeral is\
    \ longer than 26 letters, append all\n            -- remaining numerals to the\
    \ start of the numeral, then reset\n            -- the numerals and factors.\n\
    \            roman = roman .. next_numeral .. numerals\n            factor = 1\n\
    \            decimal_part = 1\n            numerals = \"M\"\n        end\n   \
    \     -- Add the next numeral.\n        roman = roman .. next_numeral\n    end\n\
    \    roman = roman..numerals[decimal_part]\n    return roman\nend", "    if number\
    \ < 1 then return nil end\n    local romans = {\n        ['I'] = 1,\n        ['V']\
    \ = 5,\n        ['X'] = 10,\n        ['L'] = 50,\n        ['C'] = 100,\n     \
    \   ['D'] = 500,\n        ['M'] = 1000\n    }\n    local ret = \"\"\n    local\
    \ divisor = 0\n    repeat\n        local num = number / divisor\n        repeat\n\
    \            local letter = romans[letter]\n            local next = romans[letter\
    \ + num + 1]\n            repeat\n                if letter == \"M\" and number\
    \ > 1000 then\n                    ret = \"\"\n                    break\n   \
    \             elseif letter == \"M\" then\n                    ret = \"M\"\n \
    \                   break\n                elseif letter == \"D\" and number >\
    \ 500 then\n                    ret = \"\"\n                    break\n      \
    \          elseif letter == \"D\" then\n                    ret = \"D\"\n    \
    \                break\n                elseif letter == \"C\" and number > 100\
    \ then\n                    ret = \"\"\n                    break\n          \
    \      elseif letter == \"C\" then\n                    ret = \"C\"\n        \
    \            break\n                elseif letter == \"L\" and number > 50 then\n\
    \                    ret = \"\"\n                    break\n                elseif\
    \ letter == \"L\" then\n                    ret = \"L\"\n                    break\n\
    \                elseif letter == \"X\" and number > 10 then\n               \
    \     ret = \"\"\n                    break\n                elseif letter ==\
    \ \"X\" then\n                    ret = \"X\"\n                    break\n   \
    \             elseif letter == \"V\" and number > 5 then\n                   \
    \ ret = \"\"\n                    break\n                elseif letter == \"V\"\
    \ then\n                    ret = \"V\"\n                    break\n         \
    \       elseif letter == \"I\" and number > 1 then\n                    ret =\
    \ \"\"\n                    break\n                elseif letter == \"I\" then\n\
    \                    ret = \"I\"\n                    break\n                else\n\
    \                    ret = \"\"\n                    break\n            end\n\
    \            letter = next\n            number = number * next\n        end\n\
    \        divisor = divisor * 10\n    until number == 0\n    return ret\nend",
  "  if number == 0 then\n    return ''\n  elseif number <= 0 then\n    error('number\
    \ must be positive')\n  end", "  if number == 0 then\n    return ''\n  end\n \
    \ if number < 0 then\n    number = -number\n    sign = '-'\n  else\n    sign =\
    \ ''\n  end\n  assert(number <= 999)\n  local roman = ''\n  for i = 2, number\
    \ do\n    roman = roman..(i % 5 == 0 and 'M' or string.char(math.floor((i - 1)\
    \ / 5)) + roman)\n  end\n  return sign .. roman\nend", "    local roman_numerals\
    \ = {\n        '',\n        'i',\n        'ii',\n        'iii',\n        'iv',\n\
    \        'v',\n        'vi',\n        'vii',\n        'viii',\n        'ix',\n\
    \        'x',\n        'xi',\n        'xii',\n        'xiii',\n        'xiv',\n\
    \        'xv',\n        'xvi',\n        'xvii',\n        'xviii',\n        'xy',\n\
    \        'yx',\n        'yx',\n        'yx',\n        'yx',\n        'yy'\n  \
    \  }\n    local number_str = tostring(number)\n    local roman_numeral = roman_numerals[number_str]\n\
    \    if roman_numeral ~= '' then\n        return roman_numeral:lower()\n    else\n\
    \        -- The number is larger than that of the largest roman numeral\n    \
    \    -- possible, so return 'L'\n        return 'L'\n    end\nend", "\t-- No checks\n\
    \tlocal roman = \"\"\n\tlocal i = number", "  if number == 0 then\n    return\
    \ ''\n  end\n  if number < 0 then\n    number = 0\n  end\n  local roman_num =\
    \ ''\n  local remainder = math.modf(number)\n  while number > 0 do\n    roman_num\
    \ = roman_num .. 'I'\n    number = math.floor(number / 10)\n  end\n  while remainder\
    \ ~= 0 do\n    roman_num = roman_num .. mini_roman[remainder]\n    remainder =\
    \ math.floor(remainder / 10)\n  end\n  return roman_num:lower()\nend", "  if number\
    \ < 1 then\n    return '?'\n  elseif number < 100 then\n    return string.sub(mini_roman,\
    \ number-1, number-1)\n  else\n    local first_digit = math.floor((number-1)/100)\n\
    \    local second_digit = math.floor((number-1)%100)\n    return string.sub(mini_roman,\
    \ first_digit-1, first_digit-1) + \n      int_to_mini_roman(second_digit)\n  end\n\
    end", "\tif number == 0 then return 'zero' end\n\tlocal roman = { }\n\tlocal i\
    \ = 0\n\twhile i < number do\n\t\tlocal mul = math.floor((number - i) / 5)\n\t\
    \tlocal rem = math.fmod(number, 5)\n\t\troman[#roman + 1] = 'C' .. string.sub(mini_roman,\
    \ i, i)\n\t\ti = i + 1\n\t\troman[#roman + 1] = 'M' .. string.sub(mini_roman,\
    \ i, i + mul)\n\t\ti = i + 1\n\t\troman[#roman + 1] = 'D' .. string.sub(mini_roman,\
    \ i, i + mul)\n\t\ti = i + 1\n\t\tif rem > 0 then\n\t\t\troman[#roman + 1] = 'M'\
    \ .. string.sub(mini_roman, i, i)\n\t\t\ti = i + 1\n\t\tend\n\tend\n\treturn table.concat(roman)\n\
    end", "    -- sanity check\n    if number == nil then\n        return nil\n  \
    \  end\n    -- if the number is 1, return the empty string\n    if number == 1\
    \ then\n        return ''\n    end\n    -- if the number is a roman, then return\
    \ the string\n    if number >= 1000 then\n        return to_string(number)\n \
    \   end\n    -- if the number is even or odd\n    if number % 2 == 0 then\n  \
    \      number = math.floor(number / 2)\n    else\n        number = math.ceil(number\
    \ / 2)\n    end\n    -- store the string from the numeral table\n    local string\
    \ = ''\n    -- iterate over each of the numerals\n    for i = 1, 10 do\n     \
    \   -- find the number of times the numeral appears\n        -- times_numeral\
    \ = numerals:gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub('%d'):gsub",
  "\tlocal roman_numeral = {\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\"\
    ,\"IX\"}\n\tlocal roman_numbers = {}\n\tlocal index = 1\n\twhile number > 0 do\n\
    \t\tif index <= 4 then\n\t\t\troman_numbers[index] = roman_numeral[math.floor((number-1)/3)]\
    \ .. roman_numeral[(number % 3)+1]\n\t\tend\n\t\tlocal tmp = math.floor((number-1)/10)\n\
    \t\troman_numbers[index+1] = roman_numeral[tmp] .. roman_numeral[(number % 10)+1]\n\
    \t\tindex = index+2\n\t\tnumber = number/10\n\tend\n\treturn table.concat(roman_numbers,\"\
    \")\nend", "  local roman = ''\n  local i\n  for i = 1, 10 do\n    local digit\
    \ = math.mod(number, i)\n    roman = roman .. digit2string(digit, i)\n    number\
    \ = math.trunc(number / i)\n  end\n  if number > 0 then\n    roman = roman ..\
    \ digit2string(number, 10)\n  end\n  return string.lower(roman)\nend", "    local\
    \ roman = \"\"\n    local i = 1\n    while i < number do\n        roman = roman\
    \ .. mini_to_roman(i - 1)\n        i = i + 1\n    end\n    return roman\nend",
  "  assert(number > 0)\n  assert(number <= 1000)\n  local roman = ''\n  repeat\n\
    \    local remainder = number:mod(10)\n    roman = string.format('%s%s', roman,\n\
    \                           table.getn(mini_romans[remainder]))\n    number =\
    \ number:div(10)\n  until number == 0\n  return roman:lower()\nend", "  -- Special\
    \ case:\n  if number == 0 then\n    return '0'\n  end", "  assert(number >= 1\
    \ and number <= 1000)\n  if number <= 19\n  then\n    return string.format(\"\
    %xix\", number)\n  elseif number <= 99\n  then\n    return string.format(\"%cxxxii\"\
    , number - 20, number - 10)\n  elseif number <= 199\n  then\n    return string.format(\"\
    %cdxvii\", number - 100, number - 10)\n  elseif number <= 420\n  then\n    return\
    \ string.format(\"%cdii\", number - 4, number - 100)\n  else\n    return string.format(\"\
    %cddxii\", number - 400, number - 100)\n  end\nend", "    local string = ''\n\
    \    local roman\n    -- if number is too big, just return it\n    if number >\
    \ 1000 then\n        return string\n    end\n    -- if number is less than 1000,\
    \ we take roman\n    if number < 1 then\n        roman = string\n        return\
    \ roman\n    end\n    -- if number is in the range of 1 to 500, roman\n    if\
    \ 1 <= number <= 500 then\n        roman = string.char(number)\n        return\
    \ roman\n    end\n    -- if number is in the range of 501 to 1000, roman\n   \
    \ if 501 <= number <= 999 then\n        local roman = string.char(number - 500\
    \ - 1) + roman\n        return roman\n    end\n    -- if number is in the range\
    \ of 1001 to 2000, roman\n    if 1001 <= number <= 1499 then\n        local roman\
    \ = string.char(number - 1000 - 500 - 1) + roman\n        return roman\n    end\n\
    \    -- if number is in the range of 2001 to 3000, roman\n    if 2001 <= number\
    \ <= 2499 then\n        local roman = string.char(number - 2000 - 1000 - 500 -\
    \ 1) + roman\n        return roman\n    end\n    -- if number is in the range\
    \ of 3001 to 4000, roman\n    if 3001 <= number <= 3999 then\n        local roman\
    \ = string.char(number - 3000 - 2000 - 1000 - 500 - 1) + roman\n        return\
    \ roman\n    end\n    -- if number is in the range of 4001 to 5000, roman\n  \
    \  if 4001 <= number <= 4999 then\n        local roman = string.char(number -\
    \ 4000 - 3000 - 2000 - 1000 - 500 - 1) + roman\n        return roman\n    end\n\
    \    -- if number is in the range of 5001 to 6000, roman\n    if 5001 <= number\
    \ <= 6999 then\n        local roman = string.char(number - 5000 - 4000 - 3000\
    \ - 2000 - 1000 - 500 - 1) + roman\n        return roman\n    end\n    -- if number\
    \ is in the range of 6001 to 7000, roman\n    if 6001 <= number <= 7999 then\n\
    \        local roman = string.char(number - 6000 - 5000 - 4000 - 3000 - 2000 -\
    \ 1000 - 500 - 1) + roman\n        return roman\n    end\n    -- if number is\
    \ in the range of 701 to 8000, roman\n    if 701 <= number <= 8999 then\n    \
    \    local roman = string.char(number - 7010 - 6000 - 5000 - 4000 - 3000 - 2000\
    \ - 1000 - 500 - 1) + roman\n        return roman\n    end\n    -- if number is\
    \ in the range of 801 to 9000, roman\n    if 801 <= number <= 9999 then\n    \
    \    local ", "    local roman = ''\n    for i = 1, number do\n        roman =\
    \ roman .. int_to_mini_roman_number(i % 10)\n    end\n    return string.lower(roman)\n\
    end", "    if number == 0 then\n        error('The input number must be positive.')\n\
    \    end", '  local roman', "    if number < 1 then return nil end\n    local\
    \ roman\n    if number > 1000 then return nil end\n    -- Round to the closest\
    \ 'i', then 'x', then 'i'\n    local i = math.floor(math.floor(number / 1000)\
    \ / 100) % 100\n    local x = math.floor(number / 100) % 100\n    roman = roman:sub(1,\
    \ i):sub(x, 1):sub(1, i)\n    return roman\nend", "  local roman_numerals = roman_numeral_table.roman_numeral_table\n\
    \  -- For numbers <= 1000, we simply use their equivalent in the numeral table.\n\
    \  -- This is not sufficient for numbers above 1000. As such we use recursion.\n\
    \  -- If number < 1000, the number is simply returned as it is.\n  if number <=\
    \ 1000 then\n    return roman_numerals[number]\n  end\n  -- We need numbers in\
    \ the thousands, hundreds, thousands, hundreds,\n  -- millions, thousands, millions,\
    \ billions, thousands, billions, trillions, thousands, trillions.\n  -- The pattern\
    \ of recursion is: number * 1000 | number * 100 | number * 10 | number.\n  --\
    \ Each recursion step, we multiply number by 1000 to get number * 1000 and so\
    \ on.\n  -- To get number * 100, we simply multiply number by 100 to get number\
    \ * 10.\n  -- We get number * 10 in each recursion step.\n  -- The last recursion,\
    \ will always multiply number by 1 to get the final result.\n  -- For number >\
    \ 1000, we return string representation of the number in the numeral table.\n\
    \  return roman_numerals[number] .. (roman_numerals[number * 1000] or\n      \
    \                               roman_numerals[number * 100] or\n            \
    \                         roman_numerals[number * 10] or\n                   \
    \                  roman_numerals[number])\nend", "  assert(number > 0 and number\
    \ <= 1000, 'Given a number out of range')\n  local roman_numeral = nil\n  if number\
    \ < 1000 then\n    roman_numeral = 'x'\n  else\n    local numeral_value = math.floor((number\
    \ - 1) / 1000)\n    roman_numeral = mini_roman[numeral_value]\n  end\n  local\
    \ remainder = number % 1000\n  if remainder < 1000 then\n    roman_numeral = roman_numeral\
    \ .. mini_roman[remainder]\n  end\n  return roman_numeral:lower()\nend", "   \
    \ if number <= 0 then\n        return '0'\n    end", "\tlocal function to_roman(number)\n\
    \t\tif number <= 0 then\n\t\t\treturn \"\"\n\t\tend", "  if number == 0 then\n\
    \    return ''\n  else\n    local alphabet = {\n      ['I'] = 1,\n      ['V']\
    \ = 5,\n      ['X'] = 10,\n      ['L'] = 30,\n      ['C'] = 50,\n      ['D'] =\
    \ 90,\n      ['M'] = 90,\n      ['m'] = 90,\n      ['M'] = 90,\n      ['V'] =\
    \ 16,\n      ['IV'] = 16,\n      ['IX'] = 16,\n      ['XL'] = 40,\n      ['XC']\
    \ = 40,\n      ['CD'] = 90,\n      ['CM'] = 90,\n      ['M'] = 90,\n      ['V']\
    \ = 16,\n      ['IX'] = 16,\n      ['XC'] = 40,\n      ['LV'] = 40,\n      ['XL']\
    \ = 40,\n      ['CD'] = 90,\n      ['M'] = 90,\n      ['D'] = 90,\n      ['IV']\
    \ = 16,\n      ['V'] = 16,\n      ['IX'] = 16,\n      ['CD'] = 90,\n      ['CM']\
    \ = 90,\n      ['D'] = 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['L']\
    \ = 40,\n      ['X'] = 10,\n      ['I'] = 1,\n      ['I'] = 1,\n      ['C'] =\
    \ 50,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['D'] =\
    \ 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['D'] = 90,\n      ['M'] =\
    \ 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] =\
    \ 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] =\
    \ 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] =\
    \ 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] =\
    \ 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] =\
    \ 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] =\
    \ 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] =\
    \ 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] =\
    \ 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] = 90,\n      ['M'] =\
    \ 90,\n      ['", "  local roman = ''\n  local result\n  -- Get the first two\
    \ digits.\n  local first_two_digits = math.floor(number / 10000000000)\n  -- Get\
    \ the last digit.\n  local last_digit = math.floor((number % 10000000000) / 1000000000)\n\
    \  -- Add in the \"I\" if it is one less than the last digit.\n  roman = roman\n\
    \    .. mini_romans[first_two_digits]\n    .. if last_digit == 1 then 'i' else\
    \ 'i'\n  -- Add the last digit, if it is less than zero.\n  roman = roman\n  \
    \  .. mini_romans[last_digit]\n    .. 'vi'\n  -- Add in the \"x\" if it is greater\
    \ than zero.\n  roman = roman\n    .. 'x'\n  -- Return the converted string.\n\
    \  return roman\nend", "  local roman = {}\n  local alphabet = {'I','II','III','IV','V','VI','VII','VIII','IX','X','XI','XII','XIII','XIV','XV','XVI','XVII','XVIII','XIX','XX','XXI','XXII','XXIII','XXIV','XXV','XXVI','XXVII','XXVIII','XXIX','XXX'}\n\
    \  for i=1,#alphabet,1 do\n    local count = 1 -- how many times the character\
    \ is in the string.\n    for j=1,#alphabet,1 do\n      if alphabet[i] == alphabet[j]\
    \ then\n        count = count + 1\n      end\n    end\n    -- Add the count to\
    \ the dictionary.\n    roman[#roman+1] = alphabet[i]..count\n  end\n  local numeral\
    \ = ''\n  local i = number-1 -- The lowest roman numeral. Romans have no lower\
    \ numerals.\n  while roman[i] ~= nil do\n    -- Add each character to the numeral\n\
    \    numeral = numeral..roman[i]\n    i = i + 1\n  end\n  return numeral:lower()\n\
    end", "  if number <= 0 then\n    return nil\n  end\n  if number > 1000 then\n\
    \    return \"too many digits\"\n  end", "   assert(number >= 1 and number <=\
    \ 1000, 'Invalid roman')\n   local romans = {\n      I = 'i',\n      V = 'v',\n\
    \      X = 'x',\n      L = 'l',\n      C = 'c',\n      D = 'd',\n      M = 'm',\n\
    \      Q = 'q',\n      P = 'p',\n      N = 'n',\n      M = 'm',\n   }\n   local\
    \ result = ''\n   for i=1, number do\n      result = result .. romans[math.floor((number\
    \ % 1000) / 100)]\n      number = math.floor(number / 100)\n   end\n   return\
    \ result:lower()\nend", "  if number < 1 then return nil end\n  local roman_map\
    \ = {'i', 'x', 'c', 'd', 'm', 'o', 'l'}\n  local roman_result = \"\"\n  local\
    \ i = 1\n  while i <= number do\n    roman_result = roman_result .. (roman_map[math.floor((number\
    \ % i) / i)])\n    i = i + 1\n  end\n  return string.lower(roman_result)\nend",
  "  if number < 1 then\n    return nil\n  end\n  if number < 3 then\n    return mini_roman[number]\n\
    \  end\n  local roman = mini_roman\n  for i = number, 1, -1 do\n    local remainder,\
    \ result = remainder(roman[i], number)\n    roman[i] = result\n    if result ~=\
    \ nil then\n      roman[i+1] = remainder\n    end\n  end\n  return mini_roman.concat(roman)\n\
    end", "\tlocal roman = ''\n\tlocal count = 0\n\twhile number >= 1000 do\n\t\t\
    roman = roman .. 'M'\n\t\tnumber = number - 1000\n\t\tcount = count + 1\n\tend\n\
    \tif number > 0 then\n\t\troman = roman .. int_to_roman(number)\n\tend\n\tfor\
    \ i = 1, count do\n\t\troman = roman .. 'x'\n\tend\n\treturn roman\nend", "  \
    \  local roman_string = \"\"\n    local numeral_value = math.floor((number + 0.01)\
    \ / 10)\n    for i = 1, 10 do\n        if numeral_value >= i * 10 then\n     \
    \       roman_string = roman_string .. \"V\"\n            numeral_value = numeral_value\
    \ - i * 10\n        elseif numeral_value < i * 10 then\n            roman_string\
    \ = roman_string .. \"I\"\n            numeral_value = numeral_value + (i * 10)\
    \ - 1\n        else\n            roman_string = roman_string .. \"I\"\n      \
    \  end\n    end\n    return roman_string\nend", "  if number <= 0 then\n    return\
    \ '0'\n  end\n  local roman = string.char.roman(number)\n  local roman_string\
    \ = roman:sub(1, roman:len()-1)\n  local mini_roman = roman_string:gsub('(%d%d?%d?)'\
    \ % roman_roman_map, '%1$2')\n  return mini_roman\nend", "  if number == 0 then\
    \ return \"\" end\n  local romans = {\n      10010 = \"M\",\n      11000 = \"\
    D\",\n      10100 = \"C\",\n      10110 = \"C\",\n      10200 = \"D\",\n     \
    \ 11100 = \"C\",\n      11110 = \"C\",\n      11500 = \"D\",\n      11500 = \"\
    D\",\n      12000 = \"D\",\n      12100 = \"C\",\n      12100 = \"C\",\n     \
    \ 12200 = \"C\",\n      12200 = \"C\",\n      12300 = \"C\",\n      12300 = \"\
    C\",\n      12400 = \"C\",\n      12400 = \"C\",\n      12500 = \"C\",\n     \
    \ 12500 = \"C\",\n      12600 = \"C\",\n      12600 = \"C\",\n      12700 = \"\
    C\",\n      12700 = \"C\",\n      12800 = \"C\",\n      12800 = \"C\",\n     \
    \ 12900 = \"C\",\n      12900 = \"C\",\n      13000 = \"\",\n      13000 = \"\"\
    ,\n      13100 = \"C\",\n      13100 = \"C\",\n      13200 = \"C\",\n      13200\
    \ = \"C\",\n      13300 = \"C\",\n      13300 = \"C\",\n      13400 = \"C\",\n\
    \      13400 = \"C\",\n      13500 = \"C\",\n      13500 = \"C\",\n      13600\
    \ = \"C\",\n      13600 = \"C\",\n      13700 = \"C\",\n      13700 = \"C\",\n\
    \      13800 = \"C\",\n      13800 = \"C\",\n      13900 = \"C\",\n      13900\
    \ = \"C\",\n      14000 = \"\",\n      14000 = \"\",\n      14100 = \"C\",\n \
    \     14100 = \"C\",\n      14200 = \"C\",\n      14200 = \"C\",\n      14300\
    \ = \"C\",\n      14300 = \"C\",\n      14400 = \"C\",\n      14400 = \"C\",\n\
    \      14500 = \"C\",\n      14500 = \"C\",\n      14600 = \"C\",\n      14600\
    \ = \"C\",\n      14700 = \"C\",\n      14700 = \"C\",\n      14800 = \"C\",\n\
    \      14800 = \"C\",\n      14900 = \"C\",\n      14900 = \"C\",\n      15000\
    \ = \"\",\n      15000 = \"\",\n      15100 = \"C\",\n      15100 = \"C\",\n \
    \     15200 = \"", "  if number <= 0 then return end\n  local roman_table = {'',\
    \ 'M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'}\n  local\
    \ i, n = 1, #roman_table\n  while number >= n do\n    number = number / n\n  \
    \  i = i + 1\n  end\n  return roman_table[i]\nend", "  -- The Roman Numerals start\
    \ at 1, while our mini-Roman numerals start at 0.\n  local numerals = {\n    \
    \  [1] = \"M\",\n      [2] = \"MM\",\n      [3] = \"MMM\",\n      [4] = \"MMMM\"\
    ,\n      [5] = \"MMMMM\",\n      [6] = \"MMMMMM\",\n      [7] = \"MMMMMMM\",\n\
    \      [8] = \"MMMMMMMM\",\n      [9] = \"MMMMMMMMM\",\n      [10] = \"MMMMMMMMMM\"\
    ,\n      [11] = \"MMMMMMMMMMM\",\n      [12] = \"MMMMMMMMMMMM\",\n      [13] =\
    \ \"MMMMMMMMMMMMM\",\n      [14] = \"MMMMMMMMMMMMMM\",\n      [15] = \"MMMMMMMMMMMMMMM\"\
    ,\n      [16] = \"MMMMMMMMMMMMMMMM\",\n      [17] = \"MMMMMMMMMMMMMMMMM\",\n \
    \     [18] = \"MMMMMMMMMMMMMMMMMM\",\n      [19] = \"MMMMMMMMMMMMMMMMMMM\",\n\
    \      [20] = \"MMMMMMMMMMMMMMMMMMMM\",\n      [21] = \"MMMMMMMMMMMMMMMMMMMMM\"\
    ,\n      [22] = \"MMMMMMMMMMMMMMMMMMMMMM\",\n      [23] = \"MMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n      [24] = \"MMMMMMMMMMMMMMMMMMMMMMMM\",\n      [25] = \"MMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n      [26] = \"MMMMMMMMMMMMMMMMMMMMMMMMMM\",\n      [27] = \"MMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n      [28] = \"MMMMMMMMMMMMMMMMMMMMMMMMMMMM\",\n      [29] = \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n      [30] = \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\",\n      [31] = \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n      [32] = \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\",\n      [33] = \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n      [34] = \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\",\n      [35] = \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n      [36] = \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\",\n      [37] = \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n      [38] = \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\",\n      [39] = \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n      [40] = \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\",\n      [41] = \"\
    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\",\n      [42] = \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n      [43] = \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\",\n      [44] =\
    \ \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\",\n      [45", "  if number\
    \ > 1000 or number < 1 then\n    error (\"int_to_mini_roman: given number is not\
    \ in range [1..1000]\", 2)\n  end\n  if number < 1000 then\n    return string.format(\"\
    %u\", number)\n  end\n  local roman = { \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\",\n                  \"ix\", \"x\", \"xi\", \"xii\"\
    , \"xiv\", \"xix\",\n                  \"l\", \"lx\", \"lxx\", \"lxxx\", \"lxxxx\"\
    , \"lxxxxx\" }\n  local numeral = { \"m\", \"cm\", \"d\", \"cd\", \"m\", \"cm\"\
    , \"d\", \"cd\", \"m\", \"cm\", \"d\", \"cd\" }\n  local tens = { \"d\", \"cd\"\
    , \"c\", \"xc\", \"l\", \"xl\", \"x\",\n                \"s\", \"sd\", \"c\",\
    \ \"xc\", \"l\", \"xl\", \"x\",\n                \"s\", \"sd\", \"c\", \"xc\"\
    , \"l\", \"xl\", \"x\" }\n  local hundreds = { \"c\", \"xc\", \"l\", \"xl\", \"\
    x\",\n                     \"s\", \"sd\", \"c\", \"xc\", \"l\", \"xl\", \"x\"\
    ,\n                     \"s\", \"sd\", \"c\", \"xc\", \"l\", \"xl\", \"x\" }\n\
    \  local divisor = number\n  while divisor > 1000 do\n    divisor = divisor /\
    \ 1000\n  end\n  if divisor == 1000 then\n    return roman[number]\n  elseif divisor\
    \ == 5000 then\n    return roman[number]..\"ii\"\n  elseif divisor == 10000 then\n\
    \    return roman[number]..\"v\"\n  elseif divisor == 100000 then\n    return\
    \ roman[number]..\"vi\"\n  elseif divisor == 50000 then\n    return roman[number]..\"\
    vii\"\n  elseif divisor == 100000 then\n    return roman[number]..\"ix\"\n  elseif\
    \ divisor == 500000 then\n    return roman[number]..\"x\"\n  elseif divisor ==\
    \ 1000000 then\n    return roman[number]..\"xii\"\n  elseif divisor == 5000000\
    \ then\n    return roman[number]..\"xl\"\n  elseif divisor == 10000000 then\n\
    \    return roman[number]..\"lx\"\n  elseif divisor == 50000000 then\n    return\
    \ roman[number]..\"xx\"\n  elseif divisor == 100000000 then\n    return roman[number]..\"\
    xxx\"\n  else\n    error(\"int_to_mini", "    if number == 0 then\n        error(\"\
    Invalid input. Must be > 0.\")\n    end", "    local roman = \"\"\n    local i\
    \ = 1\n    while number > 0 and i <= 3 do\n        roman = roman .. mini_roman[math.floor((number\
    \ / i) + 0.5)]\n        number = number - i * mini_roman[i]\n        i = i + 1\n\
    \    end\n    return roman\nend", "  local roman = ''", "  if number <= 0 or number\
    \ > 999 then\n    return \"?\"\n  end", '  assert(number > 0 and number <= 1000)',
  "  local roman = {}\n  roman.symbols = {\n    \"I\",\n    \"V\",\n    \"X\",\n \
    \   \"L\",\n    \"C\",\n    \"D\",\n    \"M\"\n  }\n  roman.numerals = {\n   \
    \ \"I\",\n    \"II\",\n    \"III\",\n    \"IV\",\n    \"V\",\n    \"VI\",\n  \
    \  \"VII\",\n    \"VIII\",\n    \"IX\",\n    \"X\",\n    \"XI\",\n    \"XII\"\
    ,\n    \"XIII\",\n    \"XIV\",\n    \"XV\",\n    \"XVI\",\n    \"XVII\",\n   \
    \ \"XVIII\",\n    \"XIX\",\n    \"XX\",\n    \"XXI\",\n    \"XXII\",\n    \"XXIII\"\
    ,\n    \"XXIV\",\n    \"XXV\",\n    \"XXVI\",\n    \"XXVII\",\n    \"XXVIII\"\
    ,\n    \"XXIX\",\n    \"XXX\",\n    \"XXI\",\n    \"XXII\",\n    \"XXIII\",\n\
    \    \"XXIV\",\n    \"XXV\",\n    \"XXVI\",\n    \"XXVII\",\n    \"XXVIII\",\n\
    \    \"XXIX\",\n    \"XXX\",\n    \"XXXI\",\n    \"XXXII\",\n    \"XXXIII\",\n\
    \    \"XXXIV\",\n    \"XXXV\",\n    \"XXXVI\",\n    \"XXXVII\",\n    \"XXXVIII\"\
    ,\n    \"XXXIX\",\n    \"XXXX\",\n    \"XX\",\n    \"XXI\",\n    \"XXII\",\n \
    \   \"XXIII\",\n    \"XXIV\",\n    \"XXV\",\n    \"XXVI\",\n    \"XXVII\",\n \
    \   \"XXVIII\",\n    \"XXIX\",\n    \"XXX\",\n    \"XXXI\",\n    \"XXXII\",\n\
    \    \"XXXIII\",\n    \"XXXIV\",\n    \"XXXV\",\n    \"XXXVI\",\n    \"XXXVII\"\
    ,\n    \"XXXVIII\",\n    \"XXXIX\",\n    \"XXXX\"\n  }\n  roman.roman_table =\
    \ {}\n  roman.index = {}\n  roman.index[1] = roman.symbols[1]\n  roman.index[2]\
    \ = roman.symbols[2]\n  roman.index[3] = roman.symbols[3]\n  roman.index[4] =\
    \ roman.symbols[4]\n  roman.index[5] = roman.symbols[5]\n  roman.index[6] = ",
  "    if number <= 0 then\n        error('Negative number')\n    end\n    if number\
    \ >= 1000 then\n        error('Too large')\n    end", "  local roman = nil\n \
    \ for i = 1, 1000 do\n    local n = math.floor((number / i) * 10)\n    local mod\
    \ = number % i\n    if mod > 0 then\n      n = n .. 'x'\n    end\n    roman =\
    \ roman .. string.sub(n, 1, 1) .. string.sub(string.sub(n, 0, 1), 1, 1) .. i\n\
    \  end\n  return roman\nend", "\tif number < 1 then return nil end\n\tlocal str\
    \ = ''\n\twhile number > 1000 do\n\t\tstr = string.sub(str, 1, string.len(str)\
    \ - 1) ..\n\t\t\t'M'\n\t\tnumber = number - 1000\n\tend\n\treturn string.sub(str\
    \ .. 'M', 0, string.len(str) - 1) .. tostring(number)\nend", "  assert(1 <= number\
    \ and number <= 1000, \"`number` must be a positive integer <= 1000\")\n  local\
    \ roman = string.gsub(roman_table[number], '[a-z]', '')\n  return roman:gsub('(.)',\
    \ '%1 %1')\nend", "    -- Based on: http://rosettacode.org/wiki/Roman_numeral_system#Lua\n\
    \    -- We use an explicit recursion here for readability.\n    if number < 2\
    \ then\n        return number\n    end", "\tlocal roman_table = {\n\t\t1000,\n\
    \t\t500,\n\t\t400,\n\t\t100,\n\t\t90,\n\t\t80,\n\t\t70,\n\t\t60,\n\t\t50,\n\t\t\
    40,\n\t\t30,\n\t\t20,\n\t\t10,\n\t\t5,\n\t\t4,\n\t\t3,\n\t\t2,\n\t\t1,\n\t}\n\t\
    return string.sub(roman_table[number], 1, 1)\nend", "  assert(number >= 1 and\
    \ number <= 1000,\n         'int_to_mini_roman: number must be an integer between\
    \ 1 and 1000')\n  local roman = ''\n  local roman_numeral_to_int = {}\n  roman_numeral_to_int['M']\
    \ = 1000\n  roman_numeral_to_int['CM'] = 900\n  roman_numeral_to_int['D'] = 500\n\
    \  roman_numeral_to_int['C'] = 400\n  roman_numeral_to_int['XC'] = 100\n  roman_numeral_to_int['L']\
    \ = 50\n  roman_numeral_to_int['XL'] = 40\n  roman_numeral_to_int['X'] = 10\n\
    \  roman_numeral_to_int['IX'] = 9\n  roman_numeral_to_int['V'] = 5\n  roman_numeral_to_int['IV']\
    \ = 4\n  roman_numeral_to_int['I'] = 3\n  roman_numeral_to_int['A'] = 1", "  \
    \  local roman = \"\"\n    local num = number", "    if number == 0 then\n   \
    \     return '0'\n    end\n    if number == 1 then\n        return 'I'\n    end\n\
    \    local roman_values = {}\n    local i = 2\n    while i <= 1000 do\n      \
    \  roman_values[i] = i\n        i = i + 1\n    end\n    local num = 1\n    for\
    \ i = 2, 1000 do\n        local left_value = roman_values[i]\n        local right_value\
    \ = roman_values[i - 1]\n        if number >= left_value and number >= right_value\
    \ then\n            num = num * 10 + i - 1\n        end\n    end\n    return tostring(num)\n\
    end", "    local roman = {'M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX',\
    \ 'V', 'IV', 'I'}\n    local sum = 0\n    for i = 0, 1000 do\n        local tmp\
    \ = (number % 10) + sum\n        sum = tmp\n        number = math.floor(number\
    \ / 10)\n    end\n    local result = ''\n    for i = 1, 1000 do\n        if roman[i]\
    \ ~= roman[sum] then\n            table.insert(result, roman[i])\n        end\n\
    \        sum = sum + roman[i]\n    end\n    if number < 1000 then\n        table.insert(result,\
    \ roman[sum])\n    end\n    return table.concat(result, \"\")\nend", "\tassert(type(number)\
    \ == 'number', 'number is not a number')\n\tif number <= 0 then return nil end\n\
    \tif number <= 10 then return 'x' end\n\tif number <= 20 then return 'c' end\n\
    \tif number <= 30 then return 'm' end\n\tif number <= 40 then return 'd' end\n\
    \tif number <= 50 then return 'i' end\n\tif number <= 60 then return 'v' end\n\
    \tif number <= 70 then return 'l' end\n\tif number <= 80 then return 'xl' end\n\
    \tif number <= 90 then return 'xc' end\n\tif number <= 100 then return 'ix' end\n\
    \tif number <= 1000 then return 'v' end\nend", "  -- Return error if number <=\
    \ 0\n  if number <= 0 then\n    return nil\n  end\n  -- Return error if number\
    \ > 1000\n  if number > 1000 then\n    return nil\n  end\n  -- Initialize result\n\
    \  local result = \"\"\n  -- Iterate from 1-1000\n  for i = 1, 1000 do\n    --\
    \ Append i-th number to the result string\n    if number >= i then\n      result\
    \ = result .. roman_to_int(i)\n      -- If number is divisible by i, append the\
    \ lowercase roman numeral of i\n    elseif number % i == 0 then\n      -- Convert\
    \ to lowercase roman numeral and append it to the result\n      result = result\
    \ .. roman_to_lower(i)\n    end\n  end\n  -- Return result in lowercase\n  return\
    \ result:lower()\nend", "    local roman_nums = {\n        100 = 'C', 100 = 'C',\
    \ 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C',\n        100 = 'C', 100 = 'C', 100\
    \ = 'C', 100 = 'C', 100 = 'C', 100 = 'C',\n        100 = 'C', 100 = 'C', 100 =\
    \ 'C', 100 = 'C', 100 = 'C', 100 = 'C',\n        100 = 'C', 100 = 'C', 100 = 'C',\
    \ 100 = 'C', 100 = 'C', 100 = 'C',\n        100 = 'C', 100 = 'C', 100 = 'C', 100\
    \ = 'C', 100 = 'C', 100 = 'C',\n        100 = 'C', 100 = 'C', 100 = 'C', 100 =\
    \ 'C', 100 = 'C', 100 = 'C',\n        100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C',\
    \ 100 = 'C', 100 = 'C',\n        100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100\
    \ = 'C', 100 = 'C',\n        100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 =\
    \ 'C', 100 = 'C',\n        100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C',\
    \ 100 = 'C',\n        100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100\
    \ = 'C',\n        100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 =\
    \ 'C',\n        100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C',\n\
    \        100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C',\n \
    \       100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C',\n  \
    \      100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C',\n   \
    \     100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C',\n    \
    \    100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C',\n     \
    \   100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C',\n      \
    \  100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C', 100 = 'C',\n       \
    \ 100 = 'C', ", "   assert(type(number) == 'number' and number >= 0 and number\
    \ <= 1000)\n   local roman = \"\"\n   for count = 1, 5 do\n      local value =\
    \ number / count\n      roman = roman.. (value == 1 and 'I' or ('v'..value))\n\
    \      number = math.mod(number, count)\n   end\n   return lower(roman)\nend\n\
    </cell>\n<code language=xeus-cling-cpp14>", "  -- Convert integer to string and\
    \ remove everything that's not numeral,\n  -- then convert it to roman numeral,\
    \ and finally to lowercase.\n  return string.reverse(roman_to_int('' .. string.format(\n\
    \    '%0*d',\n    math.ceil(math.log(number, 10) / 3), number)))\n    ..lower(sub('%0*d',\
    \ 1, number))\nend", "    local roman_numerals = roman_numerals or {}\n    local\
    \ roman_string = roman_string\n        or ''\n    local i, i1, i2, i3, i4 = 1,\
    \ 0, 0, 100\n    local decimal_point = ''", "  if number < 0 then\n    error (string.format(\"\
    Invalid number %d for int_to_mini_roman\", number))\n  end", "    local roman\
    \ = \"\"\n    for i = 1, 4 do\n        local remainder = number:rem(i)\n     \
    \   roman = roman..res_to_roman(remainder)\n    end\n    return string.lower(roman)\n\
    end", "  -- Base case\n  if number <= 0 then\n    return ''\n  end", "    if number\
    \ == 0 then\n        return ''\n    end\n    local romans = {}\n    romans[1]\
    \ = 'M'\n    romans[10] = 'D'\n    romans[100] = 'C'\n    romans[1000] = 'L'\n\
    \    romans[10000] = 'X'\n    romans[1000000] = 'V'\n    romans[10000000] = 'I'\n\
    \    romans[100000000] = 'X'", "  local roman = {}\n  for i = 1, number do\n \
    \   roman[#roman+1] = i\n  end\n  local roman_numeral = ''\n  for i = 1, #roman\
    \ do\n    roman_numeral = roman_numeral .. roman[i]\n  end\n  return string.lower(roman_numeral)\n\
    end", "    local roman = romans[number]\n    if not roman then\n        roman\
    \ = string.gsub(roman_numerals[number], '([^%s])', '')\n        roman = roman:gsub('%w',\
    \ '')\n        roman = roman:gsub('%d%d?', '', roman)\n        roman = roman:gsub('([%s])%s',\
    \ '\\\\1%s\\\\2', roman)\n        roman = roman:gsub('([%s])(%s|%s|%s|%s)(%s|%s|%s|%s)',\n\
    \          '\\\\1%s\\3%s\\\\2%s\\\\4%s\\\\3',\n          '\\\\1%s\\3%s\\\\2%s\\\
    \\4%s\\\\3\\\\5%s\\\\4%s\\\\3\\\\4%s\\\\3',\n          '\\\\1%s\\3%s\\\\2%s\\\\\
    4%s\\\\3\\\\4%s\\\\3\\\\5%s\\\\4%s\\\\3\\\\5%s\\\\4%s\\\\3\\\\4%s\\\\3',\n   \
    \       '\\\\1%s\\3%s\\\\2%s\\\\4%s\\\\3\\\\4%s\\\\3\\\\5%s\\\\4%s\\\\3\\\\5%s\\\
    \\4%s\\\\3\\\\5%s\\\\4%s\\\\3\\\\4%s\\\\3',\n          '\\\\1%s\\3%s\\\\2%s\\\\\
    4%s\\\\3\\\\4%s\\\\3\\\\5%s\\\\4%s\\\\3\\\\5%s\\\\4%s\\\\3\\\\5%s\\\\4%s\\\\3\\\
    \\5%s\\\\4%s\\\\3',\n          '\\\\1%s\\3%s\\\\2%s\\\\4%s\\\\3\\\\4%s\\\\3\\\\\
    5%s\\\\4%s\\\\3\\\\5%s\\\\4%s\\\\3\\\\5%s\\\\4%s\\\\3\\\\5%s\\\\4%s\\\\3',\n \
    \         '\\\\1%s\\3%s\\\\2%s\\\\4%s\\\\3\\\\4%s\\\\3\\\\5%s\\\\4%s\\\\3\\\\\
    5%s\\\\4%s\\\\3\\\\5%s\\\\4%s\\\\3\\\\5%s\\\\4%s\\\\3\\\\5%s\\\\4%s\\\\3',\n \
    \         '\\\\1%s\\3%s\\\\2%s\\\\4%s\\\\3\\\\4%s\\\\3\\\\5%s\\\\4%s\\\\3\\\\\
    5%s\\\\4%s\\\\3\\\\5%s\\\\4%s\\\\3\\\\5%s\\\\4%s\\\\3\\\\5%s\\\\4%s\\\\3\\\\5%s\\\
    \\4%s\\\\3',\n          '\\\\1%s\\3%s\\\\2%s\\\\4%s\\\\3\\\\4%s\\\\3\\\\5%s\\\\\
    4", "\tif number <= 0 or number > 1000 then\n\t\treturn nil\n\tend", "    local\
    \ roman_num\n    if number <= 4000 then\n        roman_num = 'x'\n    elseif number\
    \ <= 999 then\n        roman_num = 'C'\n    elseif number <= 1999 then\n     \
    \   roman_num = 'D'\n    elseif number <= 3999 then\n        roman_num = 'M'\n\
    \    elseif number <= 4999 then\n        roman_num = 'I'\n    elseif number <=\
    \ 5999 then\n        roman_num = 'V'\n    elseif number <= 7999 then\n       \
    \ roman_num = 'X'\n    elseif number <= 9999 then\n        roman_num = 'L'\n \
    \   elseif number <= 39999 then\n        roman_num = 'C'\n    elseif number <=\
    \ 59999 then\n        roman_num = 'D'\n    elseif number <= 9999999 then\n   \
    \     roman_num = 'M'\n    elseif number <= 99999999 then\n        roman_num =\
    \ 'I'\n    elseif number <= 99999999999 then\n        roman_num = 'V'\n    elseif\
    \ number <= 99999999999999 then\n        roman_num = 'X'\n    else\n        roman_num\
    \ = 'L'\n    end\n    return roman_num\nend", "    local romans = {\n        ['I']\
    \ = 1,\n        ['V'] = 5,\n        ['X'] = 10,\n        ['L'] = 50,\n       \
    \ ['C'] = 100,\n        ['D'] = 500,\n        ['M'] = 1000\n    }\n    -- handle\
    \ special cases\n    if number <= 0 then\n        return '0'\n    end\n    if\
    \ number >= 1000 then\n        return nil\n    end", "  if number < 0 then\n \
    \   error()\n  end\n  local roman = string.char(\n    '',\n    string.char(\n\
    \      string.char(\n        '',\n        string.char(\n          'I',\n     \
    \     string.char(\n            'V',\n            string.char(\n             \
    \ 'X',\n              string.char(\n                'L',\n                string.char(\n\
    \                  'C',\n                  string.char(\n                    'D',\n\
    \                    string.char(\n                      'M',\n              \
    \        string.char(\n                        'N',\n                        string.char(\n\
    \                          'K',\n                          string.char(\n    \
    \                        'D',\n                            string.char(\n    \
    \                          'C'\n                            )\n              \
    \            )\n                        )\n                      )\n         \
    \           )\n                  )\n                )\n              )\n     \
    \       )\n          )\n        )\n      )\n    )\n  )\n  local roman_part = ''\n\
    \  for i = 1, number do\n    roman_part = roman_part .. roman:sub(1, i)\n  end\n\
    \  return roman_part:lower()\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
