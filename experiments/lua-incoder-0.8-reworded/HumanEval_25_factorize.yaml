name: HumanEval_25_factorize
language: lua
prompt: "-- Return table of prime factors of given integer in the order from smallest\
  \ to largest.\n-- Each of the factors should be tableed number of times corresponding\
  \ to how many times it appeares in factorization.\n-- Input number should be equal\
  \ to the product of all factors\n-- >>> factorize(8)\n-- {2, 2, 2}\n-- >>> factorize(25)\n\
  -- {5, 5}\n-- >>> factorize(70)\n-- {2, 5, 7}\nlocal function factorize(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = factorize\n\
  \    lu.assertEquals(candidate(2), {2})\n    lu.assertEquals(candidate(4), {2, 2})\n\
  \    lu.assertEquals(candidate(8), {2, 2, 2})\n    lu.assertEquals(candidate(57),\
  \ {3, 19})\n    lu.assertEquals(candidate(3249), {3, 3, 19, 19})\n    lu.assertEquals(candidate(185193),\
  \ {3, 3, 3, 19, 19, 19})\n    lu.assertEquals(candidate(20577), {3, 19, 19, 19})\n\
  \    lu.assertEquals(candidate(18), {2, 3, 3})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if n <= 1 then\n    return {}\n  else\n    local factors = {}\n \
    \   for i = 2, n do\n      if n % i == 0 then\n        if n / i == i then -- If\
    \ the given number is evenly divisible by each factor in factorization, it's prime\
    \ number.\n          table.insert(factors, i)\n        else\n          local factors_\
    \ = factorize(n / i)\n          for _, v in ipairs(factors_) do\n            table.insert(factors,\
    \ v)\n          end\n        end\n      end\n    end\n    return factors\n  end\n\
    end", "    local factors = {}\n    for i = 2, n do\n        -- If factor already\
    \ exists, increment it\n        if factors[i - 1] then factors[i - 1]:insert(i)\
    \ end\n        -- If number has reached its limit, break the loop and return\n\
    \        if n == i then break end\n    end\n    return factors\nend", "  -- We\
    \ use 'return' instead of 'break' to save time when all possible factors are checked\n\
    \  -- and all factors of n are already checked (so no need to check them again)\n\
    \  local factors = {}\n  local p, i, f, j, k, factor", "\tif n == 1 then\n\t\t\
    return {n}\n\tend", "  if n == 1 then\n    return {n}\n  end\n  local factors\
    \ = {}\n  for i = 2, n do\n    local f = n % i\n    if not factors[f] then\n \
    \     factors[f] = factorize(i)\n      table.insert(factors[f], f)\n    end\n\
    \  end\n  return table.concat(factors, \", \")\nend", "    local tbl = {}\n  \
    \  for i = 1, n do\n        local factor = 1\n        for j = 2, n do\n      \
    \      if n % j == 0 then\n                factor = factor * j\n            end\n\
    \        end\n        tbl[factor] = tbl[factor] + 1 or 1\n    end\n    return\
    \ tbl\nend", "  if n <= 1 then\n    return nil\n  end\n  local res = {}\n  local\
    \ i, f, rem, n, rem_i, rem_f = 1, 0, n, 1, 0\n  while rem_f < n do\n    -- Get\
    \ next prime factor of n\n    f = math.floor(n/div_f)\n    -- Get remainder of\
    \ n to next prime factor\n    rem = n % div_f\n    -- If rem = 0, then just increment\
    \ the count\n    if rem == 0 then\n      res[rem_i] = rem_f\n      rem_f = 1\n\
    \      n, rem_i = rem_i, rem_i+1\n    else\n      rem_f = rem_f + 1\n      n,\
    \ rem = rem, rem * div_f\n    end\n  end\n  return res\nend", "  -- Prime factors\
    \ of number are only prime numbers with multiplicity less than or equal to that\
    \ number\n  -- So we ignore those number whose multiplicity is less than or equal\
    \ to n by factorization.\n  local factors = {}\n  for i,f in ipairs(math.factor(n))\
    \ do\n    factors[i] = factors[i] + 1 if f < n and f % 2 == 1 end\n  end", " \
    \   local factors = {}\n    local f = 2\n    local p = n", "  assert(n > 1)\n\
    \  local primes, counters = {}, {}\n  local n = math.sqrt(n)\n  for i = 2, n do\n\
    \    counters[i] = 1\n    for p = 2, i * i do\n      if n % p == 0 then\n    \
    \    counters[i] = counters[i] + 1\n        primes[p] = true\n      end\n    end\n\
    \  end\n  -- Add all factors to result table\n  -- TODO: Check if result is correct\n\
    \  local result = {}\n  for i = 2, n do\n    if counters[i] == 1 then\n      table.insert(result,\
    \ i)\n    end\n  end\n  return result\nend", "    local factors = {}\n    local\
    \ a = factorize(n)\n    for _, factor in pairs(a) do\n        table.insert(factors,\
    \ factor * 1)\n    end\n    return factors\nend", "  local factors = {}\n  --\
    \ Fill the list of factors\n  local f = 2\n  while f <= n do\n    while n % f\
    \ == 0 do\n      table.insert(factors, f)\n      n = n / f\n    end\n    f = f\
    \ + 1\n  end\n  -- Sort them in ascending order\n  table.sort(factors)\n  -- Return\
    \ as table\n  return factors\nend", "   local factors = {}\n   local factorization\
    \ = {}\n   for i = 2, math.floor(n*0.5) do -- Start from largest to smallest factors\n\
    \      local current = n%i -- Find current factor\n      factors[current] = factors[current]\
    \ + 1 or 1 -- Increment count for this factor\n      factorization[current] =\
    \ factorization[current] or {} -- Add count for this factor if does not exist\n\
    \      if not factorization[current][current] then\n         factorization[current][current]\
    \ = i -- Add this factor to factor table\n      end\n      n = n / i -- Divide\
    \ the number by this factor\n   end\n   return factors, factorization\nend", " \
    \ assert(n >= 0, 'Input number should be non-negative')\n  assert(n <= math.pow(2,\
    \ #primes), 'Input number should be equal to product of all factors')\n  if n\
    \ < #primes then\n    local factors = {}\n    for i=2,n do\n      if n % i ==\
    \ 0 then\n        table.insert(factors, i)\n        n = n / i\n      end\n   \
    \ end\n    return factors\n  else\n    return nil\n  end\nend", "   local factors\
    \ = {}\n   for x = 2, n do\n      local i = 1\n      while i * x <= n do\n   \
    \      i = i + 1\n      end\n      if i == n then\n         table.insert(factors,\
    \ x)\n         i = i + 1\n      else\n         if i * x > n then\n           \
    \ table.insert(factors, i)\n         end\n      end\n   end\n   return factors\n\
    end", '  assert(n > 0)', "  -- Return table of prime factors of given integer\
    \ in the order from smallest to largest.\n  -- Each of the factors should be tableed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \  -- Input number should be equal to the product of all factors\n  -- >>> factorize(8)\n\
    \  -- {2, 2, 2}\n  -- >>> factorize(25)\n  -- {5, 5}\n  -- >>> factorize(70)\n\
    \  -- {2, 5, 7}", "\tlocal factors = {}\n\tfor _, f in pairs(factorization(n))\
    \ do\n\t\ttable.insert(factors, f)\n\tend\n\treturn factors\nend", "  if n <=\
    \ 1 then return {} end\n  local factors = {}\n  local m = 1\n  for i = 2, n do\n\
    \    if n % i == 0 then\n      if i <= m then\n        table.insert(factors, i,\
    \ m)\n      else\n        table.insert(factors, i, 1)\n      end\n      m = m\
    \ + 1\n    end\n  end\n  if n > m then\n    table.insert(factors, n, 1)\n  end\n\
    \  return factors\nend", "  assert(n > 1)\n  local factors = {}\n  for i = 2,\
    \ n do\n    local x = n / i\n    if x ~= math.floor(x) then break end\n    factors[i]\
    \ = x\n  end\n  if factors[#factors] == n then factors[#factors] = 1\n  else factors[#factors]\
    \ = factors[#factors] + 1\n  end\n  assert(#factors == n)\n  return factors\n\
    end", "\tlocal factors = {}\n\tfor i = 2, n do\n\t\tif n % i == 0 then\n\t\t\t\
    table.insert(factors, i)\n\t\t\tn = n / i\n\t\telse\n\t\t\tbreak\n\t\tend\n\t\
    end", "  assert(n > 1)\n  local factors = {}\n  local i = 1\n  while i * i <=\
    \ n do\n    while n % i == 0 do\n      i = i * i\n      table.insert(factors,\
    \ i)\n    end\n    i = i + 1\n  end\n  return factors\nend", "  if n < 2 then\n\
    \    return {}\n  elseif n == 1 then\n    return {n}\n  else\n    local factors\
    \ = {}\n    for i = 2, math.floor(n) do\n      local f = 2\n      repeat\n   \
    \     local candidate = n / i\n        if candidate > i then\n          table.insert(factors,\
    \ i)\n        end\n        f = f + 1\n        if f > math.sqrt(n) then\n     \
    \     break\n        end\n        i = i + 1\n      until f > math.floor(n)\n \
    \   end\n    table.sort(factors)\n    local factorsTable = {}\n    for _, i in\
    \ pairs(factors) do\n      table.insert(factorsTable, i)\n    end\n    return\
    \ factorsTable\n  end\nend", '    local factors = {}', "    local factors = {}\n\
    \    local f = 2\n    while f * f <= n do\n        while n % f == 0 do\n     \
    \       table.insert(factors, f)\n            n = n / f\n        end\n       \
    \ f = f + 1\n    end\n    if n ~= 1 then table.insert(factors, n) end\n    table.sort(factors)\n\
    \    return factors\nend", "   local factors = {}\n   if n <= 0 then return factors\
    \ end\n   if n <= 1 then return { 1 } end\n   for _, v in factorize(n-1).ipairs()\
    \ do\n      if n > v then return factors end\n      factors[v] = n/v\n   end\n\
    \   if n%2 == 0 then factors[2] = 2 end\n   return factors\nend", "   -- Create\
    \ new hash table for storing counts of factors found\n   local factors = {}\n\
    \   -- Initialise all counts to zero\n   for i = 1, n do\n      factors[i] = 0\n\
    \   end\n   -- Find factors and store their count in hash table\n   local m, d\
    \ = 1, n\n   while d % m ~= 0 do\n      m = m * 2\n      d = d / m\n   end\n \
    \  while d > 1 do\n      factors[d] = factors[d] + 1\n      d = d / 2\n   end\n\
    \   -- Return factors in order of size from smallest to largest\n   -- (i.e. largest\
    \ factor will be first)\n   table.sort(factors)\n   return factors\nend", "  if\
    \ n % 2 == 0 then\n    local factors = {}\n    repeat\n      factors[#factors\
    \ + 1] = n\n      n = n/2\n    until n <= 1\n    return factors\n  end\n  -- Check\
    \ if n can be written as a sum of two primes\n  local i = 1\n  while i <= math.sqrt(n)\
    \ do\n    local p = math.random(2, i)\n    i = i + p - 1\n    if n % p == 0 then\n\
    \      local factors = {}\n      repeat\n        factors[#factors + 1] = n/p\n\
    \        n = n/p\n      until n <= 1\n      return factors\n    end\n  end\nend",
  "  assert(n > 1, 'Input number must be greater than 1')\n  local factors = {} --\
    \ Initialize factors\n  -- Start from 1 to sqrt(n)\n  for i = 1, math.ceil(math.sqrt(n))\
    \ do\n    -- Consider every possible factorization\n    local d = 1\n    for j\
    \ = i, n do\n      -- If n divides current factor - it can't be prime number\n\
    \      if n % j == 0 then\n        d = d + 1\n        break\n      end\n    end\n\
    \    -- Store factorization\n    if d == 1 then\n      factors[i] = 1\n    else\n\
    \      factors[i] = d\n    end\n  end\n  return factors\nend", "  if n <= 1 then\n\
    \    return {}\n  end", "  if n <= 0 then return end\n  if n < 2^(3*(#n-1)) then\
    \ return {n} end\n  local ns = {}\n  local q = n\n  while q ~= 1 do\n    local\
    \ m = math.floor((q - 1) / 2)\n    local p = 2 * q - m\n    if p < 2*m then\n\
    \      ns[#ns + 1] = p\n      q = m\n    else\n      ns[#ns + 1] = p\n      q\
    \ = p\n    end\n  end\n  -- Return the numbers with no repeating factors\n  return\
    \ ns, #ns - 1\nend", "    local factors = {}\n    local p = 2\n    while n > 1\
    \ do\n        while n % p == 0 do\n            n = n / p\n            table.insert(factors,\
    \ p)\n        end\n        p = p * 3\n    end\n    table.insert(factors, n)\n\
    \    return factors\nend", "    -- Table where we store results\n    local factors\
    \ = {}\n    -- Fill table with all odd integers smaller than input number\n  \
    \  for i = 1, n do\n        table.insert(factors, i)\n    end\n    -- For all\
    \ even integers larger than input number find factors of them and multiply them\n\
    \    for i = n, 1, -1 do\n        local p = 1\n        for _, factor in ipairs(factors)\
    \ do\n            p = p * factor\n        end\n        table.insert(factors, p)\n\
    \    end\n    return factors\nend", "    local factors = { }\n    for i = 2, n\
    \ do\n        local r = 1\n        for j = 1, n do\n            if n % j == 0\
    \ then\n                r *= j\n            end\n        end\n        if r then\n\
    \            table.insert(factors, r)\n        end\n    end\n    return factors\n\
    end", "   if n == 1 then\n      return {1}\n   else\n      local p = math.ceil(math.sqrt(n))\n\
    \      local a = {}\n      for i = 1, p do\n         local q = n / p\n       \
    \  if i == 1 then\n            a[1] = q\n         else\n            local v =\
    \ {}\n            for j = 1, i do\n               v[j] = a[j] * q\n          \
    \  end\n            a[i] = v\n         end\n      end\n      table.sort(a)\n \
    \     local res = {}\n      for i = 1, #a do\n         local v = 1\n         for\
    \ j = 1, i do\n            v = v + a[j]\n         end\n         table.insert(res,\
    \ v)\n      end\n      return res\n   end\nend", "\tn = n or 0\n\t-- This algorithm\
    \ is guaranteed to be faster then other methods we could find and it is pretty\
    \ easy to understand.\n\t-- The idea here is to take prime factorization of n\
    \ and multiply them by their count in factorization.\n\t-- The function returns\
    \ tables of factors.\n\t-- We should take prime factors of n first and then multiply\
    \ them to their count in factorization.\n\t-- The reason for that is that if we\
    \ start factorizing after prime factorization we would end up with same factor\
    \ multiple times.\n\t-- (i.e. {5, 5} -> {5, 5} -> {5, 5} -> {5, 5})\n\t-- The\
    \ reason for that is that we start factorization from smallest prime factor to\
    \ largest one.\n\t-- That is because if we take prime factorization of n we would\
    \ end up with same prime factor multiple times.\n\t-- (i.e. {5, 5} -> {5, 5} ->\
    \ {5, 5} -> {5, 5})\n\tlocal factorization = {}\n\tlocal i = 1\n\tlocal prime\
    \ = 1\n\tlocal factor = 1\n\tlocal prime_factorization = {}\n\trepeat\n\t\t--\
    \ We are taking prime factorization of n and multiply them by their count in factorization.\n\
    \t\t-- We should take prime factors of n first and then multiply them to their\
    \ count in factorization.\n\t\t-- That is because if we take prime factorization\
    \ of n we would end up with same prime factor multiple times.\n\t\t-- i.e. {5,\
    \ 5} -> {5, 5} -> {5, 5} -> {5, 5}\n\t\tprime_factorization[i] = prime\n\t\ti\
    \ = i + 1\n\t\t-- If n is not prime then add it to factorization\n\t\t-- Otherwise\
    \ we could end up with same prime factor multiple times.\n\t\tif n ~= prime then\n\
    \t\t\tfactorization[i] = factor\n\t\t\ti = i + 1\n\t\tend\n\t\t-- Adding prime\
    \ factorization of n to factorization.\n\t\t-- Prime factorization of n contains\
    \ only prime numbers.\n\t\t-- We should not multiply it with count of prime factor\
    \ multiple times.\n\t\t-- i.e. {5, 5} -> {5, 5} -> {5, 5} -> {5, 5}\n\t\tfactorization[i]\
    \ = n\n\t\ti = i + 1\n\tuntil i <= math.floor(n/2)", "    local factors = {}\n\
    \    local factorsTable = {}\n    local divisor = 1\n    while n ~= 1 do\n   \
    \     while n % divisor == 0 do\n            factors[#factors+1] = divisor\n \
    \           factorsTable[divisor] = #factors\n            divisor = divisor +\
    \ 1\n        end\n        n = n/divisor\n    end\n    return factors, factorsTable\n\
    end", "\tif n % 2 == 0 then return factorize(n/2) end\n\tlocal d = 1\n\twhile\
    \ n % d == 0 do\n\t\td = d + 1\n\tend\n\tlocal factors = { }\n\twhile n >= d do\n\
    \t\tfactors[#factors+1] = n\n\t\tn = math.floor(n/d) + 1\n\tend\n\treturn factors\n\
    end", "\t-- Initialization\n\tlocal factors = {}\n\t-- For each digit\n\tfor i\
    \ = 1, math.floor(n) do\n\t\t-- If n is not a factor of the number\n\t\tif n %\
    \ i == 0 then\n\t\t\t-- Increment its counter\n\t\t\tfactors[#factors + 1] = i\n\
    \t\t\t-- Divide n by current digit to remove it from factors\n\t\t\tn = n / i\n\
    \t\tend\n\tend\n\t-- If n is divisible by all its factors\n\tif n == 1 then\n\t\
    \t-- Return factors\n\t\treturn factors\n\telse\n\t\t-- Recursion\n\t\treturn\
    \ factorize(--n)\n\tend\nend", "    local factors = {}\n    local factor_index\
    \ = 1\n    local prime_count = #primes\n    for i = 1, n do\n        local prime\
    \ = primes[i]\n        for j = 1, prime_index do\n            if n % prime ==\
    \ 0 then\n                factors[factor_index] = prime\n                factor_index\
    \ = factor_index + 1\n                n = n / prime\n                break\n \
    \           else\n                factor_index = 1\n            end\n        end\n\
    \    end\n    return factors\nend", "   -- Initialize result with integer\n  \
    \ local res = nil\n   -- Initialize counters\n   local max_factors = 1\n   --\
    \ Initialize current candidate\n   local candidate = 1\n   -- Initialize factorization\n\
    \   local factorization = {}\n   -- Set factorization to empty if n is zero\n\
    \   if n == 0 then\n      factorization = {}\n   -- Set factorization to factorization\
    \ of n if n is greater than one\n   elseif n > 1 then\n      -- Initialize factorization\
    \ with only a factor\n      factorization[1] = n\n      -- Initialize factorization\
    \ with two factors\n      factorization[2] = 2\n      -- Initialize factorization\
    \ with five factors\n      factorization[5] = 5\n      -- Initialize factorization\
    \ with seven factors\n      factorization[7] = 7\n      -- Initialize factorization\
    \ with 13 factors\n      factorization[13] = 13\n   -- Set factorization to the\
    \ factorization of n if n is less than one\n   else\n      -- Initialize factorization\
    \ with only two factors\n      factorization[2] = 2\n      -- Initialize factorization\
    \ with four factors\n      factorization[4] = 4\n      -- Initialize factorization\
    \ with eight factors\n      factorization[8] = 8\n      -- Initialize factorization\
    \ with ten factors\n      factorization[10] = 10\n      -- Initialize factorization\
    \ with eleven factors\n      factorization[15] = 15\n      -- Initialize factorization\
    \ with twelve factors\n      factorization[20] = 12\n      -- Initialize factorization\
    \ with thirteen factors\n      factorization[25] = 15\n      -- Initialize factorization\
    \ with thirty-two factors\n      factorization[28] = 2\n      -- Initialize factorization\
    \ with sixty-three factors\n      factorization[33] = 3\n   end\n   -- For each\
    \ factor in the factorization\n   for i = 1, max_factors do\n      -- If the factor\
    \ has already been found\n      if factorization[i] ~= nil then\n         -- Increment\
    \ the counter by one\n         factorization[i] = factorization[i] + 1\n     \
    \ -- If the factor has not already been found\n      else\n         -- If current\
    \ candidate is equal to or larger than the factor then\n         if candidate\
    \ <= n then\n            -- Add that factor to the factorization\n           \
    \ factorization[i] = 1\n            -- Increment the candidate by one\n      \
    \      candidate = candidate + factorization[i]\n         -- If the current candidate\
    \ is less than the factor then\n         else\n            -- Add the factor to\
    \ the factorization\n", "    local factors = {}\n    for i = 2, math.ceil(math.sqrt(n))\
    \ do\n        if n % i == 0 then\n            n = n / i\n            factors[i]\
    \ = factors[i + 1] or 1\n            factors[#factors + 1] = i\n        end\n\
    \    end", "    local factors = {}\n    for i=2,n do\n        if n % i == 0 then\n\
    \            local f = factorize(i)\n            table.insert(factors, i)\n  \
    \          table.insert(factors, f)\n        end\n    end\n    return factors\n\
    end", "  -- Factor out as many as possible\n  local result = {}\n  local max =\
    \ 0\n  -- Scan only up to the square root of n\n  for i = 2, math.sqrt(n) + 1\
    \ do\n    -- If there are more factors than what can be found in square root\n\
    \    -- just add them all\n    if n / i == i then\n      max = (max + 1) * i\n\
    \      break\n    end\n    -- Add all factors\n    max = max + 1\n    for x =\
    \ 2, i do\n      if n % x == 0 then\n        max = max + 1\n      end\n    end\n\
    \    result[#result + 1] = max\n  end\n  return result\nend", "    local factors\
    \ = {}\n    for i = 2, math.sqrt(n) + 1 do\n        local count = 0\n        for\
    \ f = 2, i * i do\n            if n % f == 0 then\n                count = count\
    \ + 1\n            end\n        end\n        if count > 0 then\n            table.insert(factors,\
    \ count)\n        end\n    end\n    return factors\nend", "    local factors =\
    \ {}\n    local n = math.floor(n)\n    local max_i = math.floor(n * math.log(n))\n\
    \    for i = 1, max_i do\n        local p = math.modf(n * math.pow(2, i - 1))[1]\n\
    \        if p ~= 0 and math.mod(n, p) == 0 then\n            n = math.div(n, p)\n\
    \            factors[#factors + 1] = i\n        end\n    end\n    return factors\n\
    end", "  local factors = {}\n  local count = 1\n  repeat\n    count = count +\
    \ 1\n  until n ~= 1\n  for i = 2, n do\n    if n % i == 0 then\n      n = n /\
    \ i\n      factors[#factors+1] = i\n    end\n  end\n  return factors\nend", " \
    \   local f = factorization(n)\n    local factors = {}\n    for i = 1, #f do\n\
    \        table.insert(factors, f[i])\n    end\n    return factors\nend\nreturn\
    \ factorize", "    local factors = {}\n    local i = 2\n    while i <= n do\n\
    \        local j = 1\n        while i * j <= n do\n            if n % i == 0 then\n\
    \                table.insert(factors, i)\n            end\n            j = j\
    \ + 1\n        end\n        i = i + 1\n    end\n    return factors\nend", "  local\
    \ function is_factor(n, factors)\n    for _, f in ipairs(factors) do\n      if\
    \ f == n then return true end\n      if n % f == 0 then return false end\n   \
    \ end\n    return true\n  end", "  if n < 2 then return {} end\n  local factors\
    \ = {}\n  local limit = n / 2\n  for i = 2, limit do\n    if n % i == 0 then\n\
    \      factors[#factors + 1] = {i, n / i}\n      factor = n / i\n      limit =\
    \ limit / i\n      break\n    end\n  end\n  if n == 1 then return factors end\n\
    \  if limit == 1 then\n    return factors\n  else\n    -- remove factors\n   \
    \ if n <= limit then\n      for i = 1, limit do\n        if n % i == 0 then\n\
    \          for j = i + 1, limit do\n            if n % j == 0 then\n         \
    \     factors[#factors + 1] = {j, n / j}\n              factors[#factors + 1]\
    \ = {i, n / i}\n              break\n            end\n          end\n        end\n\
    \      end\n    end\n    -- remove factors until n is odd\n    if n % 2 == 1 then\n\
    \      for i = #factors, 1, -1 do\n        factors[#factors - 1] = factors[#factors]\n\
    \      end\n    end\n    return factors\n  end\nend", "\t-- Use a hash table to\
    \ store factors\n\tlocal factors = {}\n\t-- Prime numbers ending in 1, and only\
    \ 1 other than 1, are not factors of any number\n\tif isPrime(n) and n ~= 1 then\n\
    \t\tfor _, factor in ipairs(primeFactors(n)) do\n\t\t\t-- Add factor if it is\
    \ not already present\n\t\t\tif factors[factor] == nil then\n\t\t\t\ttable.insert(factors,\
    \ factor)\n\t\t\t\t-- Adjust n so factors don't get too large\n\t\t\t\tn = n /\
    \ factor\n\t\t\tend\n\t\tend\n\tend\n\treturn factors\nend", "  local factors\
    \ = {}\n  local factor = 1\n  while n >= factor do\n    factors[factor] = nil\n\
    \    factor = factor * math.floor(n/factor)\n    n = math.mod(n, factor)\n  end\n\
    \  table.sort(factors, function(a, b)\n    return b - a\n  end)\n  return factors\n\
    end", "  local a = {}\n  local n = math.ceil(n)\n  for i = 0, n do\n    local\
    \ p = math.floor((n % i) / 2)\n    if a[p] == nil then\n      a[p] = i\n    end\n\
    \    n = math.floor(n / i)\n  end\n  -- sort smallest to largest\n  table.sort(a,\
    \ function(a,b) return a < b end)\n  return a\nend", "  if n == 1 then return\
    \ {n} end\n  if n < 2 then return nil end\n  local factors = {}\n  for i = 2,\
    \ math.sqrt(n) do\n    if n % i == 0 then\n      local t = factorize(i)\n    \
    \  if t then\n        factors[#factors + 1] = i ^ 1\n        for j = 1, #t do\n\
    \          factors[#factors + 1] = factors[#factors + 1] ^ t[j]\n        end\n\
    \      end\n    end\n  end\n  if #factors == 0 then\n    factors = nil\n  end\n\
    \  return factors\nend", "  local factors = {}\n  local product = 1\n  for i =\
    \ 2, n do\n    product = product * i\n    if product == n then\n      factors[#factors\
    \ + 1] = product\n    end\n  end\n  return factors\nend", "    local factors =\
    \ {}\n    for i = 2, n do\n        local f = math.floor(n/i)\n        if f ==\
    \ i then\n            table.insert(factors, f)\n        end\n    end\n    return\
    \ factors\nend", "  local factors = {}\n  local factorization = {}", "  assert(n\
    \ > 1, 'Input number should be greater than 1.')\n  local i = 1\n  local factors\
    \ = {}\n  repeat\n    factors[#factors + 1] = i\n    i = i * n - i\n  until i\
    \ <= 1\n  return factors\nend", "    local factors = {}\n    local p, factor_index\n\
    \    for p = 2, n do\n        while n > 1 do\n            factor_index = (n %\
    \ p)\n            n = n // p\n            table.insert(factors, factor_index)\n\
    \        end\n    end\n    return factors\nend", "    local factors = {}\n   \
    \ local factor = 1\n    local i = 2\n    local is_prime = 1\n    while i <= math.sqrt(n)\
    \ do\n        local is_prime = 1\n        while i <= math.sqrt(n) do\n       \
    \     if n % i == 0 then\n                is_prime = 0\n                break\n\
    \            end\n            i = i + 1\n        end\n        if is_prime then\n\
    \            factors[#factors+1] = i\n        end\n        i = i + 1\n    end\n\
    \    return factors\nend", "  if n==0 then\n    return {}\n  elseif n==1 then\n\
    \    return {n}\n  end\n  local p = primeFactorization(n)\n  local m = #p\n  if\
    \ m == 0 then\n    return {n}\n  end\n  local table = {}\n  local i = 2\n  while\
    \ i <= m do\n    if p[i] ~= n then\n      table.insert(p, n)\n      table.insert(table,\
    \ i-1)\n    end\n    n = n * p[i]\n    i = i + 1\n  end\n  return table\nend",
  "  local factors = {}\n  for i = 2, n do \n    local f = math.floor(n/i)\n    if\
    \ factors[f] == nil then\n      factors[f] = i\n      n = n-(f*i)\n    else\n\
    \      n = n-(f*i)\n      break\n    end\n  end\n  -- remove duplicates\n  table.sort(factors)\n\
    \  for i, f in pairs(factors) do \n    factors[f] = i\n  end\n  return factors\n\
    end", "  -- Get all prime factors of given number\n  local factors = {}\n  for\
    \ i = 2, n do\n    local factor = 1\n    while n % i == 0 do\n      factors[i]\
    \ = factor\n      n = n / i\n      i = i + 1\n    end\n    if factor > 1 then\n\
    \      table.insert(factors, factor)\n    end\n  end", "  local factors = {}\n\
    \  local factor = 1\n  local prime = 1", "\t-- Start with empty table\n\tlocal\
    \ factors = {}", "    local factors = {}\n    local product = n\n    local i =\
    \ 0\n    \n    -- Iterate from smallest to largest.\n    while product % 2 ==\
    \ 0 and i <= math.sqrt(n) do\n        -- Iterate through all factors of current\
    \ number.\n        local j = 1\n        while product % j == 0 do\n          \
    \  product = product / j\n            j = j + 1\n        end\n        -- Add factor\
    \ into factors table.\n        if i < math.sqrt(n) then\n            table.insert(factors,\
    \ j)\n        end\n        i = i + 1\n    end\n    \n    -- Return factors in\
    \ the order from smallest to largest\n    return factors\nend\n</cell>\n<text>\n\
    Question 1.2. Write a function factorize_range that takes in two arguments: an\
    \ input number and number of times to repeat it, and an optional parameter table.\
    \ Inside the function, the input number is multiplied by the number of times you\
    \ provided to repeat it, and the product is returned. You may use a table, or\
    \ any kind of data type (such as a list), to store the results. Make sure the\
    \ function returns a table with 2 rows, and as many columns as you provided the\
    \ number of times to repeat the input number when factorizing it. The first row\
    \ should contain the original input number and the second row should be your table\
    \ of results. If the number of times to repeat is not provided, the function should\
    \ return an empty table. The input numbers should not be equal to zero. Assume\
    \ that all integers will be less than 10 or greater than 20.", "\t-- The first\
    \ number is the largest prime factor of the number.\n\t-- This number is smaller\
    \ than or equal to the number itself.\n\tlocal primes = {}\n\t-- Start with the\
    \ first largest prime factor of the number\n\tlocal p = primes[1]\n\t-- While\
    \ there are factors left in the list\n\twhile #primes > 1 do\n\t\t-- Check if\
    \ the current number is divisible by any number in the list\n\t\tif n % p == 0\
    \ then\n\t\t\t-- If the number isn't divisible by any number in the list\n\t\t\
    \t-- Add it to the list of prime factors\n\t\t\ttable.insert(primes, p)\n\t\t\
    -- Otherwise, if there are still factors left in the list\n\t\telse\n\t\t\t--\
    \ Otherwise, remove a prime factor from the list.\n\t\t\t-- If the new prime is\
    \ the number itself, do nothing.\n\t\t\tif #primes > 1 then\n\t\t\t\tlocal r =\
    \ primes[#primes-1]\n\t\t\t\t-- If the new prime is larger than the original number,\
    \ subtract it from the original number\n\t\t\t\t-- (so long as it's not negative).\n\
    \t\t\t\t-- Otherwise, subtract it from the new prime.\n\t\t\t\twhile p >= r do\n\
    \t\t\t\t\tp = p * primes[#primes-1]\n\t\t\t\tend\n\t\t\t\t-- If the new prime\
    \ is smaller than or equal to the original number, subtract it from the\n\t\t\t\
    \t-- original number.\n\t\t\t\tif p <= n then\n\t\t\t\t\tn = n - p\n\t\t\t\tend\n\
    \t\t\tend\n\t\t\t-- Add the current number to the list of prime factors\n\t\t\t\
    table.insert(primes, n)\n\t\tend\n\tend\n\treturn primes\nend", "    local factors\
    \ = {}\n    local factor = 1\n    while n % factor == 0 do\n        factors[factor]\
    \ = factors[factor] + 1 if factors[factor] == nil then 1 else factors[factor]\
    \ end\n        factor = factor + 1\n    end\n    local prime_factors = {}\n  \
    \  for i = 2, n do\n        if factors[i] ~= nil and factors[i] > 1 then\n   \
    \         prime_factors[i] = true\n        end\n    end\n    prime_factors = prime_factors\
    \ or {false}\n    return prime_factors\nend", '    if n <= 1 then return {n} end',
  "  local factors = {}\n  local count = 1\n  local p = 2\n  while n ~= 1 do\n   \
    \ while n % p == 0 do\n      count = count + 1\n      p = p * 2\n    end\n   \
    \ if n % p == 1 then\n      factor = n / p\n      if factors[#factors] ~= 0 then\n\
    \        factors[#factors] = factors[#factors] + factor\n      else\n        factors[#factors]\
    \ = factor\n      end\n    end\n    n = n / p\n  end\n  return factors\nend",
  "    if n == 1 then\n        return {n}\n    end\n    local factors = {}\n    local\
    \ i = 1\n    while i <= n do\n        for p in factorize(i) do\n            if\
    \ n % p == 0 then\n                table.insert(factors, p)\n                n\
    \ = n / p\n                break\n            end\n        end\n        table.insert(factors,\
    \ i)\n        i = i + 1\n    end\n    if n ~= 1 then\n        table.insert(factors,\
    \ n)\n    end\n    return factors\nend", '  assert(n > 1)', "  if n <= 1 then\
    \ return {} end\n  local primes = {n}\n  repeat\n    primes = {}\n    local f\
    \ = 2\n    while f <= n do\n      if not (n % f) then\n        primes[#primes\
    \ + 1] = f;\n      end\n      f = f + 1\n    end\n    n = math.gcd(n, primes[#primes])\n\
    \  until not n\n  return primes\nend", "    local factors = {}\n    for i = 2,\
    \ n do\n        while n % i ~= 0 do\n            table.insert(factors, i)\n  \
    \          n = n / i\n        end\n    end\n    return factors\nend", "  -- Create\
    \ a table\n  local factors = {}\n  -- Loop through all factors\n  for i = 2, math.floor(n/2)\
    \ and n do -- If division by i failed (integer division), i is larger than n\n\
    \    -- If factor appears multiple times, add it to the table\n    if factors[i]\
    \ ~= nil and factors[i] < n then\n      factors[i] = factors[i] + 1\n      --\
    \ If factor was previously prime, divide n by it\n    elseif factors[i] ~= nil\
    \ and factors[i] == n then\n      factors[i] = nil\n      n = n / i\n    else\n\
    \      -- If factor did not appear previously or has multiple occurrences, add\
    \ it to the table\n      factors[i] = n\n    end\n  end\n  return factors\nend",
  "  if n < 1 then return {n} end\n  local factors = {}\n  for i=1, n do\n    for\
    \ j=1, n do\n      if j == i then continue end\n      if n%j == 0 then\n\tfactors[j]\
    \ = factors[j] or 1\n\tfactors[j] = factors[j] + (factors[i] and 1)\n      end\n\
    \    end\n  end\n  table.sort(factors)\n  local p = factors[1]\n  factors = factors[#factors]\n\
    \  for i=2, #factors do\n    local q = factors[i]\n    if p*q > n then\n     \
    \ break -- TODO: implement better search strategy\n    end\n    p = p * q\n  end\n\
    \  return factors\nend", "  n = math.floor(n)\n  local f = nil\n  local p = 2\n\
    \  local q = math.floor(n/p)\n  while q > 1 do\n    f, q = math.divmod(n, q)\n\
    \    n = q\n    p = p * f\n  end\n  return {p}\nend", "  -- Return table of prime\
    \ factors of given integer in the order from smallest to largest.\n  -- Each of\
    \ the factors should be tableed number of times corresponding to how many times\
    \ it appeares in factorization.\n  -- Input number should be equal to the product\
    \ of all factors\n  -- >>> factorize(8)\n  -- {2, 2, 2}\n  -- >>> factorize(25)\n\
    \  -- {5, 5}\n  -- >>> factorize(70)\n  -- {2, 5, 7}\n  -- >>> factorize(1000)\n\
    \  -- {8, 10, 12}\n  -- >>> factorize(100000000)\n  -- {100000000}\n  -- >>> factorize(1000000000)\n\
    \  -- {10000000000, 100000000000}\n  -- >>> factorize(100000000000)\n  -- {100000000000000}\n\
    \  -- >>> factorize(100000000000000)\n  -- {1000000000000000}\n  -- >>> factorize(1000000000000000)\n\
    \  -- {1000000000000000000}\n  -- >>> factorize(1000000000000000000)\n  -- {10000000000000000000}",
  "   -- Initialize table\n   local f = {}\n   \n   -- If n is a factor of itself\
    \ then return\n   if n <= 1 then return f end", "  -- Scan factorization array\
    \ and check if it contains this number. If it does - return its count.\n  -- Otherwise,\
    \ initialize this number to 1 (add it to the array) and add it to array.\n  local\
    \ count = 1\n  for i=1,#factorization do\n    if n == factorization[i] then\n\
    \      count = count + 1\n      break\n    end\n  end\n  -- Check if number is\
    \ less than or equal to 1 and add to array if it is.\n  if n <= 1 then\n    factorization[1]\
    \ = n\n    return count\n  end\n  -- If number is not in array, add it to the\
    \ array\n  factorization[count] = n\n  return count\nend", "  local factors =\
    \ {}\n  local p = 2", "  if n > 0 then\n    -- Test for prime factors\n    for\
    \ i = 2, n do\n      if not n % i then\n        return {}\n      end\n    end",
  "  local factors = {}\n  local p = 2\n  while n do\n    factors[#factors + 1] =\
    \ n\n    n = n / p\n    p = p * 2\n  end\n  return factors\nend", "    local f\
    \ = {}\n    local nf = math.floor(n)\n    local p, q = 1, nf -- The two starting\
    \ values\n    while q * p <= nf  do\n        while nf % p == 0 do\n          \
    \  table.insert(f, p)\n            nf = nf/p\n        end\n        p = p + 1\n\
    \    end\n    while p > 1 do\n        while nf % p == 1 do\n            table.insert(f,\
    \ p)\n            nf = nf/p\n        end\n        p = p - 2\n    end\n    return\
    \ f\nend", "   local factors = {}\n   for factor_count = 2, math.floor(n/factor_size)\
    \ do\n      local factor = 1\n      for _ = 1, factor_count do\n         if n\
    \ % factor == 0 then\n            factor = factor * factor_size\n         else\n\
    \            break\n         end\n      end\n      if not factor then\n      \
    \   break\n      end\n      table.insert(factors, factor)\n   end\n   return factors\n\
    end", "  assert(n >= 2)\n  local factors = {}\n  for i = 2, n do\n    factors[i]\
    \ = 1\n    local d = 1\n    while i * d <= n do\n      if n % i == 0 then\n  \
    \      factors[i] = factors[i] + 1\n        n = n / i\n      else\n        d =\
    \ d + 1\n      end\n    end\n    if n ~= 1 then factors[n] = factors[n] + 1 end\n\
    \  end\n  return factors\nend", "    local factors = {}\n    for i = 2, math.sqrt(n)\
    \ + 1 do\n        if n % i == 0 then\n            n = n / i\n            table.insert(factors,\
    \ i)\n        end\n    end\n    return factors\nend", "  -- Initialize a result\
    \ table with numbers 1..n\n  local factorization = {}\n  for i = 1, n do\n   \
    \ factorization[i] = i\n  end\n  -- Find all factors and add them to the result\
    \ table\n  for i = 2, n do\n    -- If the current number is divisible by all the\
    \ numbers from 1 to i (inclusive), add i to the factorization\n    if n % i ==\
    \ 0 then\n      for j = 1, i do\n        factorization[j] = i\n      end\n   \
    \ end\n  end\n  return factorization\nend", "    if n < 2 then\n        return\
    \ {}\n    end\n    local factors = {}\n    for i = 1, n do\n        local p =\
    \ 1\n        for j = 1, i do\n            p = p * j\n        end\n        factors[p]\
    \ = factors[p] + 1 or 1\n    end\n    return factors\nend", "\t-- Return factorization\
    \ of given integer\n\t-- Each factor should be tableed number of times corresponding\
    \ to how many times it appeares in factorization.\n\t-- Input number should be\
    \ equal to the product of all factors\n\t-- >>> factorize(8)\n\t-- {2, 2, 2}\n\
    \t-- >>> factorize(25)\n\t-- {5, 5}\n\t-- >>> factorize(70)\n\t-- {2, 5, 7}\n\t\
    local factorization = {}\n\tfor i = 2, math.floor(n) do\n\t\t-- Count number of\
    \ times this number appears in factorization\n\t\tlocal count = 0\n\t\tfor _,\
    \ factor in ipairs(factorization) do\n\t\t\tif factor == i then\n\t\t\t\tcount\
    \ = count + 1\n\t\t\tend\n\t\tend\n\t\tif count > 0 then\n\t\t\t-- Add current\
    \ factor\n\t\t\ttable.insert(factorization, i)\n\t\t\t-- Add remaining factors\n\
    \t\t\tfor i = count, math.floor(n/i) do\n\t\t\t\ttable.insert(factorization, i)\n\
    \t\t\tend\n\t\tend\n\tend\n\t-- Return factorization\n\treturn factorization\n\
    end", "  -- Find all factors\n  local factors = {}\n  local p = primefactors(n)\n\
    \  for _, v in ipairs(p) do\n    factors[#factors + 1] = v\n  end\n  -- Sort them\
    \ in increasing order\n  table.sort(factors)\n  return factors\nend", "  assert(n\
    \ > 1)\n  local factors = {}\n  repeat\n    local p, i = div(n, 2)\n    if i ==\
    \ 0 then table.insert(factors, p) end\n    n = p\n  until n == 1\n  return factors\n\
    end", "    local factors = {}\n    local primes, exponent = prime_factors(n)\n\
    \    if exponent > 0 then\n        table.insert(factors, 1)\n        table.insert(factors,\
    \ exponent)\n    end\n    for i = 2, #primes do\n        local p = primes[i]\n\
    \        local fact = 1\n        while n > p * fact do\n            table.insert(factors,\
    \ fact)\n            n = n / fact\n            fact = fact + 1\n        end\n\
    \        table.insert(factors, p)\n    end\n    return factors\nend", "  if n\
    \ % 2 == 1 then\n    return {}\n  end\n  local factors = {}\n  factors[1] = 1\n\
    \  factors[2] = 2\n  while n > 1 do\n    local _, i = math.modf(n/2)\n    factors[i]\
    \ = factors[i] + 1\n    n = n%2 * i\n  end\n  return factors\nend", "  -- If n\
    \ is prime\n  if n == 1 then\n    return {1}\n  end", "    -- if factorize(n)\
    \ return n -- no need to factorize if it already exists\n    -- check for prime\
    \ factors\n    if isPrime(n) then\n        return {n}\n    end", "    if n < 2\
    \ then return {} end\n    local res = { 2, 3 }\n    for i = 4, n, 2 do\n     \
    \   for _, v in ipairs(res) do\n            if n % v == 0 then\n             \
    \   table.insert(res, v)\n                n = n / v\n                break\n \
    \           end\n        end\n    end\n    if n > 1 then\n        local t = factorize(n\
    \ / 2)\n        table.insert(t, n)\n        res..= t\n    end\n    return res\n\
    end", "    local factors = {}\n    for i = 1, math.sqrt(n) do\n        if n %\
    \ i == 0 then\n            local temp = math.floor(n/i)\n            if #factors\
    \ > temp then\n                factors[temp] = factors[#factors] + 1\n       \
    \     else\n                table.insert(factors, 1)\n            end\n      \
    \  end\n    end\n    \n    table.sort(factors, function(a,b)\n        return a<b\n\
    \    end)\n    \n    return factors\nend", "    local factors = {}\n    local\
    \ f = 1\n    while f <= n do\n        if n % f == 0 then\n            table.insert(factors,\
    \ f)\n            n = n / f\n        else\n            f *= 2\n        end\n \
    \   end", "  local factors = {}\n  for i = 2, n do\n    if n % i == 0 then\n \
    \     table.insert(factors, i)\n      n = n / i\n    end\n  end\n  if n == 1 then\
    \ factors = {n} end\n  return factors\nend", "    local factors = {}\n    for\
    \ i = 2, n do\n        local f = n % i\n        if f ~= 0 then\n            n\
    \ = n / i\n            table.insert(factors, f)\n        end\n    end\n    return\
    \ factors\nend", "\tassert(n > 0 and n <= (1e5 * (1e5 - 1)), \"Invalid input\"\
    )\n\tlocal factors = {}", "  -- Return table of prime factors of given integer\
    \ in the order from smallest to largest.\n  -- Each of the factors should be tableed\
    \ number of times corresponding to how many times it appeares in factorization.\n\
    \  -- Input number should be equal to the product of all factors\n  local factors\
    \ = {}\n  for i = 2, math.sqrt(n) do\n    if n % i == 0 then\n      local factor\
    \ = i / n\n      for _ = 1, factor do\n        table.insert(factors, i)\n    \
    \  end\n      n = n / i\n    end\n  end\n  -- Remove factors that appear less\
    \ than k times\n  for i = 2, #factors do\n    local factor = factors[i]\n    if\
    \ #factors[factor] > 1 then\n      table.insert(factors, factor)\n    end\n  end\n\
    \  return factors\nend", "  local factors = {}\n  local primes = {}\n  local x\
    \ = 1\n  local m = primeFactors(n)\n  local i = 1\n  for _, v in pairs(m) do\n\
    \    if x > v then\n      factors[#factors + 1] = i\n      x = v\n    end\n  \
    \  i = i + 1\n  end\n  return factors\nend", "  assert(n >= 1)\n  local factors\
    \ = {}\n  local p = 1\n  while n do\n    if n % p == 0 then\n      factors[#factors+1]\
    \ = p\n      n = math.floor(n/p)\n    else\n      p = p * primes[p-1]\n    end\n\
    \  end\n  return factors\nend", "\tif n < 2 then return {} end\n\tlocal primes\
    \ = {}\n\tlocal factors = {}\n\t-- Start from 2, then divide by all previous prime\
    \ factors.\n\tlocal next_p = 2\n\tlocal next = 2\n\t-- Find out prime numbers\
    \ up to given number.\n\twhile next_p <= n do\n\t\t-- All factors for the next\
    \ iteration.\n\t\tnext = 2\n\t\t-- Check if current prime is factorized.\n\t\t\
    if next_p % next_p == 0 then\n\t\t\t-- If so, remove that prime from factors.\n\
    \t\t\tlocal _, index = table.find(primes, function(a, b) return a == next_p or\
    \ b == next_p end)\n\t\t\tif index then factors[#factors+1] = next_p end\n\t\t\
    \t-- If the prime is factorized at this point, remove it from prime factors.\n\
    \t\t\tnext_p = next_p // next_p\n\t\telse\n\t\t\t-- Otherwise, check if any of\
    \ the prime factors divide it.\n\t\t\tfor p, _ in pairs(primes) do\n\t\t\t\tif\
    \ next_p % p == 0 then\n\t\t\t\t\tlocal _, index = table.find(primes, function(a,\
    \ b) return a == p or b == p end)\n\t\t\t\t\tif index then factors[#factors+1]\
    \ = p + 1 end\n\t\t\t\t\tnext_p = next_p // p\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\
    \t\tend\n\t\tend\n\tend\n\t-- Return prime factors in sorted order.\n\ttable.sort(factors)\n\
    \tfor _, factor in pairs(factors) do\n\t\ttable.insert(primes, factor)\n\tend\n\
    \treturn primes\nend", "  -- If the number is divisible by 1, then it is irreducible\n\
    \  if n%2 == 0 then\n    return nil\n  end", "  local factors = {}\n  local p\
    \ = 2\n  local d = 2\n  local x = 1\n  while d <= n do\n    if n % d == 0 then\n\
    \      factors[#factors + 1] = d\n      x = x * d\n      n = n / d\n    else\n\
    \      d = d * 2\n    end\n  end\n  if n >= 2 then\n    factors[#factors + 1]\
    \ = n\n  end\n  return factors\nend", "    local factors = {}\n    local i = 1\n\
    \    while n % 2 == 0 do\n        if i ~= n then\n            factors[#factors+1]\
    \ = i\n        end\n        i = i * 2\n        n = n / 2\n    end\n    factors[#factors+1]\
    \ = n\n    return factors\nend", "    local factors = {}\n    for i = 2, n do\n\
    \        local d = n % i\n        if d == 0 then\n            factors[#factors\
    \ + 1] = i\n        end\n    end\n    return factors\nend", "    local table =\
    \ {}\n    local i = 1\n    while i * i <= n do\n        if n % i == 0 then\n \
    \           table.insert(i, n/i)\n            n = n / i\n        else\n      \
    \      i = i + 1\n        end\n    end\n    return table\nend", "\tif n==1 then\
    \ return {} end\n\tlocal d=1\n\tlocal m=1\n\tlocal factors={}\n\tlocal found={}\n\
    \twhile d*d <= n do\n\t\tif n % d==0 then\n\t\t\tfound[d]=1\n\t\t\tfactors[d]=factors[d]\
    \ or {}\n\t\t\tfor i=2,m-1 do\n\t\t\t\tfactors[d][m]=i\n\t\t\t\tif n % i == 0\
    \ then\n\t\t\t\t\tfound[i]=1\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\td=d+1\n\tend\n\
    \tlocal m=n\n\tfor i=1,m do\n\t\tif not found[i] then\n\t\t\tbreak\n\t\tend\n\t\
    end\n\treturn factors\nend", "  -- The prime factors of the product of the primes\
    \ are the prime factors of the original integer\n  -- If the input integer is\
    \ prime, then the factors of the original integer are the prime factors of the\
    \ input integer.\n  -- Otherwise the factors of the input integer are the prime\
    \ factors of the product of the primes of the input integer.\n  local factors\
    \ = {}\n  -- The prime factors of the input integer are prime factors of the original\
    \ integer.\n  local p = factors\n  -- The prime factors of the original integer\
    \ are prime factors of the input integer.\n  for i = 2, math.sqrt(n) do\n    local\
    \ q = math.floor(n/i)\n    if q * i ~= n then\n      table.insert(p, i)\n    \
    \  table.insert(factors, q)\n      p = factors\n    end\n  end\n  return factors\n\
    end", "  local function f(i)\n    local p = primes[i]\n    return p:map(function(k)\
    \ return i * k) end\n  end\n  local a = {1, 2, 3, 5}\n  local b = {2, 3, 5, 7}\n\
    \  local c = {}\n  local factorization = {}\n  for i = #a, 1 do\n    for j = #b,\
    \ 1 do\n      if a[i] == b[j] then c[a[i]] = c[a[i]] + 1 end\n      if c[a[i]]\
    \ > 1 then break end\n    end\n    if c[a[i]] > 1 then break end\n  end\n  local\
    \ max = 0\n  for i = 1, n do\n    if c[a[i]] > max then max = c[a[i]] end\n  end\n\
    \  for i = 1, n do\n    factorization[i] = c[a[i]]\n  end\n  return factorization\n\
    end", "  n = n or 1\n  local factor = {}\n  local p = 1\n  while p ~= n do\n \
    \   factor = { n=p, factor=factor }\n    p = p * p % n\n  end\n  table.sort(factor,\
    \ function(s1, s2)\n    return s1 ~= s2\n  end)\n  local factors = {}\n  for _,\
    \ v in pairs(factor) do\n    local f = v.factor\n    for i = 1, #f do\n      table.insert(factors,\
    \ f[i])\n    end\n  end\n  return factors\nend", "    local results = {}\n   \
    \ for i = 2, n do \n        local f = factorization(i)\n        if #f > 0 then\n\
    \            for j = 1, #f do\n                results[#results+1] = i / f[j]\n\
    \            end\n        end\n    end\n    return results\nend", "  -- Base case\n\
    \  if n <= 1 then return {} end\n  -- If the number is prime, return the factors\n\
    \  if prime_table[n] then return {n} end", "  if n == 1 then return { 1 } end\n\
    \  local factors = {}\n  for i = 2, n do\n    if n % i == 0 then\n      table.insert(factors,\
    \ i)\n      n = n / i\n    end\n  end\n  if n > 1 then\n    table.insert(factors,\
    \ n)\n  end\n  return factors\nend", "    local factors = {}\n    local i = 2\n\
    \    while i * i <= n do\n        if n % i == 0 then\n            local count\
    \ = factors[#factors + 1]\n            factor = i / i\n            for j = 1..count\
    \ do\n                table.insert(factors, factor)\n            end\n       \
    \     i = i\n        else\n            i = i + 1\n        end\n    end\n    table.sort(factors)\n\
    \    local product = 1\n    for _,f in ipairs(factors) do\n        product = product\
    \ * f\n    end\n    return product, factors\nend", "  local factors = {}\n  local\
    \ p = 2\n  local m = 1\n  while p * p <= n do\n    while n % p == 0 do\n     \
    \ local q = math.floor(n / p)\n      assert(n >= p, \"Factorization should be\
    \ ended after n >= p\")\n      factors[p] = factors[p] or {}\n      factors[p][m]\
    \ = q\n      n = q\n      m = m + 1\n    end\n    p = p + 1\n  end\n  -- TODO:\
    \ check what exactly should happen when input number is divisible by some prime\
    \ factor.\n  -- TODO: check what exactly should happen when input number is equal\
    \ to 1.\n  -- TODO: check what exactly should happen when input number is equal\
    \ to 0.\n  return factors\nend", "  if n <= 1 then\n    return {}\n  end\n  local\
    \ factors = {}\n  repeat\n    local f = factorize(n-1)\n    factors[#factors+1]\
    \ = table.concat(f, \"*\")\n    n = n / f[#f]\n  until n ~= 1\n  -- factors[#factors+1]\
    \ = n\n  return factors\nend", "    local primes, p, d = {}, {}, {}\n    for i\
    \ = 2, n do\n        -- All primes less than n have no factors\n        if n >\
    \ i then\n            table.insert(primes, i)\n            for x = i, n / i do\n\
    \                -- Update d if prime factor not yet discovered\n            \
    \    if not p[x] then\n                    -- Insert new prime factor\n      \
    \              table.insert(primes, x)\n                    -- Update d and p\n\
    \                    table.insert(d, i)\n                    p[x] = 1\n      \
    \          else\n                    -- Add its multiple to d\n              \
    \      table.insert(d, p[x] * i)\n                end\n            end\n     \
    \   end\n    end\n    -- Convert primes to factors\n    for i = 1, #primes do\n\
    \        table.insert(d, primes[i])\n    end\n    return d\nend", "    -- Find\
    \ all factors of given number\n    local factors = {}\n    for i=1,n do\n    \
    \    local num = n % i\n        if num ~= 0 then\n            factors[i] = factors[num]\
    \ + 1\n        end\n    end\n    -- Find how many times each number appeared in\
    \ factors\n    local fmap = {}\n    for i=1,n do\n        fmap[i] = fmap[factors[i]]\
    \ or 1\n    end\n    -- Reconstruct the factors\n    for i=1,n do\n        factors[i]\
    \ = fmap[factors[i]]\n    end\n    return factors\nend", "\tassert(n > 1, 'Factorizing\
    \ number should be greater than 1')\n\tlocal f = {}\n\twhile n != 1 do\n\t\tlocal\
    \ m = n / 2\n\t\tlocal r\n\t\twhile m > 1 do\n\t\t\tr = m % 2\n\t\t\tm = m / 2\n\
    \t\t\tif r == 1 then\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tf = setmetatable({n\
    \ = n}, factorize)\n\t\tf.m = m\n\t\tf = setmetatable(f, factorize)\n\t\tf.r =\
    \ r\n\t\tn = m\n\tend\n\treturn f\nend", "    local factors = {}\n    for i =\
    \ 2, n do\n        local p = 1\n        local k = 1\n        while k <= n and\
    \ n % k == 0 do\n            k = k + 1\n            p = p * k\n        end\n \
    \       table.insert(factors, p)\n    end\n    return factors\nend", "   -- Check\
    \ for perfect squares only\n   if n == math.floor(n) then return {n} end\n   if\
    \ n % 2 == 0 and n > 1 then\n      local p = factorize(math.floor(n/2))\n    \
    \  return table.concat {p, {p[1]*p[1]}}\n   end\n   local factors = {}\n   for\
    \ _ = 1, n do\n      local root = math.floor((math.sqrt(n) + 1) / 2)\n      local\
    \ factor = 1\n      while root * factor <= n do\n         factor = factor * root\
    \ + 1\n      end\n      if factor ~= n then\n         table.insert(factors, factor)\n\
    \      end\n   end\n   return factors\nend", "  if n <= 0 then return {} end\n\
    \  local m = 1\n  local primefactors = {}\n  for i = 2, n do -- Find prime factors\n\
    \    if n % i == 0 then\n      m = m*i\n      while n % i == 0 do\n        n =\
    \ n/i\n        primefactors[#primefactors+1] = i\n      end\n    end\n  end\n\
    \  primefactors[#primefactors+1] = m -- Add m to the list since it is a prime\
    \ number\n  if m == 1 then -- If the number has only one prime factor then we\
    \ cannot split it in two parts\n    primefactors = primefactors[1:]\n  end\n \
    \ return primefactors\nend", '  if n < 1 then return end', "    local factors\
    \ = {}\n    for i = 2, math.floor(n * 0.75) do\n        local factor = 1\n   \
    \     for ii = 1, math.floor(n/i) do\n            factor *= i\n        end\n \
    \       if factor > n then\n            factors[#factors+1] = i\n        end\n\
    \    end\n    return factors\nend", "  if n < 2 then return { n = n } end\n  local\
    \ table = { n = n }\n  local p = 2\n  repeat\n    local candidates = table\n \
    \   for i = #table - 1, 1, -1 do\n      for j = #candidates - 1, 1, -1 do\n  \
    \      if n % candidates[j] == 0 then\n          table.insert(table, candidates[j])\n\
    \          table[i] = 1\n          break\n        end\n      end\n    end\n  \
    \  table.insert(table, p)\n    p = p + 1\n  until not table[p]\n  table.sort(table.unpack,\
    \ function(a, b)\n    return a < b\n  end)\n  return table\nend", "    -- TODO:\
    \ make this faster\n    local factors = {}\n    for i = 1, n do\n        if n\
    \ % i == 0 then\n            local primeFactors = factorize(i)\n            for\
    \ _, factor in pairs(primeFactors) do\n                if not factors[factor]\
    \ then\n                    factors[factor] = 1\n                else\n      \
    \              factors[factor] = factors[factor] + 1\n                end\n  \
    \          end\n        end\n    end\n    return factors\nend", "  -- Prime numbers\
    \ have no factors\n  if n <= 1 then return {} end", "  local factors = {}\n  for\
    \ i = 0, n do\n    factors[i] = 1\n    for j = i, n do\n      if n % j == 0 then\n\
    \        factors[i] = factors[i] + 1\n        break\n      end\n    end\n  end\n\
    \  return factors\nend", "    local factors = {}\n    local p, c = n, 1\n    while\
    \ c > 1 do\n        if p == 1 then break end\n        if n % p == 0 then\n   \
    \         factors[#factors + 1] = p\n            n = n / p\n        else\n   \
    \         c = c + 1\n        end\n    end\n    factors[#factors + 1] = n\n   \
    \ return factors\nend", "    local function factors(n)\n        if n == 1 then\
    \ return {1}\n        elseif n == 2 then return {2, 1}\n        elseif n == 3\
    \ then return {1, 2, 3}\n        elseif n%2 ~= 0 then return {n}\n        end",
  "  if n <= 1 then return {} end\n  local factors = {}\n  -- Find all factors of\
    \ given number.\n  local function factorize(number)\n    for i = 2, math.floor(n/i)\
    \ do\n      if n % i == 0 then\n        table.insert(factors, i)\n        number\
    \ = number/i\n        factorize(number)\n      end\n    end\n  end\n  factorize(math.floor(n))\n\
    \  -- Remove all duplicate factors.\n  local new_factors = {}\n  for i = 2, #factors\
    \ do\n    if factors[i] ~= 1 then\n      new_factors[#new_factors+1] = factors[i]\n\
    \    end\n  end\n  factors = new_factors\n  return factors\nend", "    -- if input\
    \ number is equal to zero - return empty table\n    if n == 0 then\n        return\
    \ nil\n    end\n    local factors = {}\n    for i = 2, n do\n        if n % i\
    \ == 0 then\n            factors[i] = factors[i] or i\n            n = n / i\n\
    \        end\n    end\n    factors[#factors+1] = n -- add the last factor to factors\n\
    \    return factors\nend", "\tlocal table = {}\n\tlocal p = 2\n\twhile n ~= 1\
    \ do\n\t\tlocal count = 0\n\t\tlocal i = 2\n\t\twhile i * i <= n do\n\t\t\tif\
    \ n % i == 0 then\n\t\t\t\tcount = count + 1\n\t\t\t\ti = i + 1\n\t\t\telse\n\t\
    \t\t\ti = i + 1\n\t\t\tend\n\t\tend\n\t\tif count == 0 then\n\t\t\ttable.insert(table,\
    \ n)\n\t\t\tn = n / p\n\t\telse\n\t\t\ttable.insert(table, {p})\n\t\t\ttable.insert(table,\
    \ n)\n\t\t\tn = n / p\n\t\t\tp = p + 1\n\t\tend\n\tend\n\treturn table\nend",
  "  if n < 2 then\n    return nil\n  end", "  local factors = {}\n  for i = 2, n\
    \ do \n    local f = math.floor(n / i)\n    if not factors[f] then\n      factors[f]\
    \ = i\n    end\n  end\n  return factors\nend", "  local factors = {}\n  local\
    \ factor = math.floor(n/2) -- Prime number factorization\n  local factor1 = factorize(factor)\n\
    \  if factor == 0 then\n    return factor1\n  else\n    -- To find factors, we\
    \ only need the first factor of n-1\n    for k,v in pairs(factor1) do\n      for\
    \ i,j in pairs(factors) do\n        if i == j then\n          factors[j] = v*factor1[1]\n\
    \        end\n      end\n    end\n    -- Return factors\n    table.sort(factors,\
    \ function(a,b) return a < b end)\n    return factors\n  end\nend", "  local factors\
    \ = {}\n  local factorizer = prime_factorizer(n)\n  for i, factor in pairs(factorizer)\
    \ do\n    factors[#factors + 1] = factor\n  end\n  return factors\nend", "  --\
    \ Return list of factors with their counts\n  -- Count of factor is represented\
    \ by its position in returned list\n  -- e.g. factorize(70) = {2, 5, 7}, return\
    \ list with 7 at pos 2, thus 7 appears 3 times\n  local factors = {}\n  for i\
    \ = 2, n do\n    -- Only prime numbers are factors\n    if factors[i-1] == 0 then\n\
    \      for j = 2, n / i do\n        -- Add j to factors and increase count of\
    \ factor by 1\n        factors[i] = factors[i] or {}\n        factors[i][j] =\
    \ factors[i][j] + 1\n      end\n    end\n  end\n  return factors\nend", "   assert(type(n)\
    \ == 'number')\n   -- Create an empty table of prime factors\n   local factors\
    \ = {}\n   -- Add 2 to our prime factorization\n   local a = 2 -- Start with 2\n\
    \   while a <= n do -- Start while a <= n\n      if n % a == 0 then -- If n is\
    \ divisible by a\n         -- If n is not divisible by a, add 'a' to our factorization\n\
    \         if a == n then\n            factors[#factors+1] = a\n         else\n\
    \            factors[#factors+1] = a -- Otherwise, add 'a' to our factorization\n\
    \         end\n         -- Go through factorization of a\n         local b = 2\n\
    \         while b <= n do -- Start while b < n\n            if a % b == 0 then\
    \ -- If b is a factor of n\n               -- If b is not a factor of a, add it\
    \ to our factorization\n               if b == n then\n                  factors[#factors+1]\
    \ = b\n               else\n                  factors[#factors+1] = b -- Otherwise,\
    \ add it to our factorization\n               end\n            end\n         \
    \   -- Increment b\n            b = b * b -- Increment b and repeat until b >\
    \ n\n         end\n      end\n      -- Increment a\n      a = a * a\n   end\n\
    \   return factors\nend", "  -- Initialize prime table\n  -- Prime table is initialized\
    \ to all primes smaller than n\n  -- Prime table is initialized only with factors\
    \ up to sqrt(n)\n  -- Since we use prime table, we do not need to check up to\
    \ the square root of n\n  local prime = {}\n  -- Initialize number to be one more\
    \ than the greatest prime smaller than n\n  local max_n = 0\n  for i = 1, n do\n\
    \    -- Initialize number to 1 less than the greatest prime smaller than n\n \
    \   max_n = math.max(n, max_n + i)\n    -- Check for factor\n    if n % i == 0\
    \ then\n      -- If not prime, store prime and factor times\n      local p = i\n\
    \      prime[max_n] = prime[max_n] + 1 or 1\n      -- Divide n by i\n      n =\
    \ n / i\n    end\n  end\n  return prime, n, max_n\nend", "  assert(n > 0)\n  local\
    \ result = {}\n  local factors = {}\n  for i = 1, n do\n    factors[i] = 1\n \
    \ end\n  local i = 1\n  while i <= n do\n    -- Finding smallest factor by dividing\
    \ number by all its previous factors and finding biggest factor.\n    local f\
    \ = math.floor((n - i) / 2)\n    local g = math.floor(i * math.pow(2, f))\n  \
    \  if f > 0 then\n      assert(math.abs(f - g) == 1)\n      factors[f] = factors[f]\
    \ + 1\n      factors[g] = factors[g] + 1\n    end\n    i = g\n  end\n  for i =\
    \ 1, n do\n    -- Checking whether factors of n are in factorization.\n    if\
    \ factors[i] ~= 0 then\n      -- If any of them is equal to 1, it is a prime number.\n\
    \      if factors[i] == 1 then\n        result[i] = nil\n      else\n        --\
    \ If n is not a prime number, then it is a composite number with multiplicity\
    \ equal to number of its factors.\n        result[i] = {}\n        for j = 1,\
    \ factors[i] do\n          -- Removing the last factor (which is equal to number\
    \ of its multiplicity).\n          -- It is used to make multiplicity equal to\
    \ 0.\n          local f = i / math.pow(2, j - 1)\n          result[i][#result[i]\
    \ + 1] = f\n        end\n      end\n    end\n  end\n  return result\nend", " \
    \ if n == 1 then\n    local factors = {}\n    factors[1] = 1\n    return factors\n\
    \  end\n  local factors = {}\n  for i = 2, n do\n    if n % i == 0 then\n    \
    \  table.insert(factors, i)\n      n = n / i\n    end\n  end\n  table.insert(factors,\
    \ n)\n  return factors\nend", "  local factors = {}\n  local d = 2\n  while d\
    \ * d <= n do\n    while n % d == 0 do\n      table.insert(factors, d)\n     \
    \ n = n / d\n    end\n    d = d + 1\n  end\n  table.insert(factors, n)\n  return\
    \ factors\nend", "  -- Find all factors of n\n  local f = primeFactors(n)\n  --\
    \ Get all prime factors lesser than or equal to n\n  for i = 2, #f do\n    if\
    \ f[i] <= n then\n      n = n / f[i]\n      f[i] = 1\n    end\n  end\n  -- Return\
    \ table of factors\n  return f\nend", "\t-- Initialize table\n\tlocal factors\
    \ = {}\n\t-- Calculate how many times a given factor appears in factoriation\n\
    \tfor i = 2, math.floor(n/divisor); i = i * divisor do\n\t\t-- Check if given\
    \ factor has appeared already in factoriation\n\t\tif factors[i] == nil then\n\
    \t\t\t-- Check if factorization is prime\n\t\t\tif i == n then\n\t\t\t\tfactors[i]\
    \ = 1\n\t\t\t\tfactors[divisor] = 1\n\t\t\telse\n\t\t\t\t-- Find prime factors\
    \ of current number divided by i\n\t\t\t\tlocal prime_factors = prime_factorizer(i,\
    \ n)\n\t\t\t\t-- Check if factorization is prime\n\t\t\t\tif #prime_factors >\
    \ 0 then\n\t\t\t\t\t-- Remove factors that are already in factoriation\n\t\t\t\
    \t\tfor _, factor in ipairs(prime_factors) do\n\t\t\t\t\t\tif factors[factor]\
    \ == nil then\n\t\t\t\t\t\t\t-- Check if factorization is prime\n\t\t\t\t\t\t\t\
    if i == n then\n\t\t\t\t\t\t\t\tfactors[factor] = 1\n\t\t\t\t\t\t\t\tfactors[divisor]\
    \ = 1\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t-- Find prime factors of current number\
    \ divided by i\n\t\t\t\t\t\t\t\tlocal prime_factors = prime_factorizer(i, n)\n\
    \t\t\t\t\t\t\t\t-- Check if factorization is prime\n\t\t\t\t\t\t\t\tif #prime_factors\
    \ > 0 then\n\t\t\t\t\t\t\t\t\t-- Remove factors that are already in factoriation\n\
    \t\t\t\t\t\t\t\t\tfor _, factor in ipairs(prime_factors) do\n\t\t\t\t\t\t\t\t\t\
    \tif factors[factor] == nil then\n\t\t\t\t\t\t\t\t\t\t\t-- Check if factorization\
    \ is prime\n\t\t\t\t\t\t\t\t\t\t\tif i == n then\n\t\t\t\t\t\t\t\t\t\t\t\tfactors[factor]\
    \ = 1\n\t\t\t\t\t\t\t\t\t\t\t\tfactors[divisor] = 1\n\t\t\t\t\t\t\t\t\t\t\telse\n\
    \t\t\t\t\t\t\t\t\t\t\t\t-- Find prime factors of current number divided by i\n\
    \t\t\t\t\t\t\t\t\t\t\t\tlocal prime_factors = prime_factorizer(i, n)\n\t\t\t\t\
    \t\t\t\t\t\t\t\t-- Check if factorization is prime\n\t\t\t\t\t\t\t\t\t\t\t\tif\
    \ #prime_factors > 0 then\n\t\t\t\t\t\t\t\t\t\t\t\t\t-- Remove factors that are\
    \ already in factoriation\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor _, factor in ipairs(prime_factors)\
    \ do\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif factors[factor] == nil then\n\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t-- Check if factorization is prime\n\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\tif i == n then\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfactors[factor] = 1\n\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\tfactors[divisor] = 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \telse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- Find prime factors of current number\
    \ divided by i\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlocal prime_factors = prime_factorizer(i,\
    \ n)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- Check if factorization is prime\n\t\t\
    \t\t\t\t\t\t\t\t\t\t\t\t\t\tif #prime_factors > 0 then\n\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t-- Remove factors that are already in factoriation\n\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\tfor _, factor in ipairs(prime_factors) do\n\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t\t\t\t\tif factors[factor] == nil then\n\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\t\t\t-- Check if factorization is prime\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\
    \t\t\t\tif i == n then\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t", "    local factors\
    \ = {}\n    local f = 1\n    while f*f <= n do\n        -- If current number is\
    \ divisible by one factor of f*f\n        if n % f*f == 0 then\n            --\
    \ Add the factor in the list\n            factors[#factors+1] = f\n          \
    \  -- Double the factor number\n            f = f * 2\n        else\n        \
    \    -- Find the next divisor\n            f = f + 1\n        end\n    end\n \
    \   return factors\nend", '    local factors = {}', "  if n < 2 then return {}\
    \ end\n  if n == 2 then return {n} end\n  local f = factorize(n)\n  for i = 2,\
    \ n do\n    local fp = setmetatable({}, f)\n    local p = f[i]\n    for j = 1,\
    \ p * 2 do\n      if not f[j] then\n        table.insert(fp, j)\n      end\n \
    \   end\n  end\n  return f\nend", "  -- We are using Euclid's Algorithm for finding\
    \ GCD and Euclid's Algorithm for finding LCM below\n  -- See https://www.wikiwand.com/en/Euclid%27s_algorithm\
    \ for further details about Euclid's Algorithm", "  local factors = {}\n  local\
    \ p = 1\n  local f = 2\n  local i = 2\n  while i <= n do\n    while n % f == 0\
    \ do\n      factors[#factors + 1] = f\n      n = n / f\n      p = p + 1\n    \
    \  f = f + 1\n    end\n    f = f + 1\n    i = i + 1\n  end\n  -- print (table.concat(factors,\
    \ ','))\n  return factors\nend", "    -- Find out factors\n    -- Start with first\
    \ two numbers\n    local factors = {}\n    -- Divide by number that appears two\
    \ times\n    -- If that fails then increase the number that appears two times\n\
    \    -- We are using number that appears two times as starting point\n    local\
    \ count = 2\n    local n = n or 1\n    while n > 0 do\n        -- Check if number\
    \ has already appeared in factors\n        if factors[count] then\n          \
    \  -- Increase the count if it appears more than once\n            count = count\
    \ + 1\n        else\n            -- Add the number to the factor table\n     \
    \       factors[count] = n\n            -- Increase the count if it appears more\
    \ than once\n            count = count + 1\n        end\n        -- Divide the\
    \ number by current count\n        n = n / count\n    end", "    local factors\
    \ = {}\n    for i = 2, n do\n        local c = 1\n        while n % i == 0 do\n\
    \            c = c + 1\n            n = n / i\n        end\n        factors[i]\
    \ = c\n    end\n    return factors\nend", "  local factors = {}\n  local m = math.ceil(math.sqrt(n))\n\
    \  if n > 1 then\n    factors[1] = n\n    for i = 2, m do\n      if n % i == 0\
    \ then\n        factors[i] = nil\n      else\n        factors[i] = n\n       \
    \ n = n / i\n        factors[i] = i\n      end\n    end\n    if n ~= 1 then\n\
    \      factors[m] = n\n    end\n  else\n    factors[m] = 1\n  end\n  local sum\
    \ = 1\n  for i = 1, m do\n    if factors[i] == nil then\n      sum = sum * 2\n\
    \    else\n      sum = sum * factors[i]\n    end\n  end\n  return factors\nend",
  "  -- if already factorized, just return\n  if factorized_table[n] ~= nil then return\
    \ factorized_table[n] end\n  -- if number is not prime, just return\n  if not\
    \ is_prime(n) then return nil end\n  -- if number is even return nothing\n  if\
    \ n % 2 == 0 then\n    factorized_table[n] = nil\n    return nil\n  end\n  --\
    \ if number is odd, find prime factors recursively by dividing n by each prime\
    \ number\n  for i = 2, get_prime_number(n) do\n    n = n/i\n    factorized_table[n]\
    \ = i\n  end\n  return factorized_table[n]\nend", "  if n < 2 then return end\n\
    \  local fs = {}\n  local n = n-1\n  while n do\n    local r\n    for r=1,n do\n\
    \      if n%r == 0 then\n\tfs[#fs+1] = r\n\tbreak\n      end\n    end\n    local\
    \ p = 1\n    while r*p <= n do\n      p = p * r\n    end\n    n = p\n  end\n \
    \ return fs\nend", "    local factors = {}\n    local max_factorial = 1\n    local\
    \ max_factor = 1\n    while max_factorial < n do\n        max_factorial = math.floor(math.pow(max_factorial,\
    \ max_factor))\n        if max_factorial == max_factor then\n            local\
    \ fact = 1\n            for i = 1, max_factor do\n                fact = fact\
    \ * i\n            end\n            factors[max_factor] = factors[max_factor]\
    \ + 1\n            max_factorial = fact\n        end\n        max_factor = math.floor(math.pow(2,\
    \ max_factor))\n    end\n    return factors\nend", "    -- Initialize result table\
    \ with one entry for each prime in factorization.\n    local factors = {}\n  \
    \  -- Calculate prime factorization of given number.\n    local p = prime_factorization(n)\n\
    \    -- Iterate over all prime factors in the factorization.\n    for _, value\
    \ in pairs(p) do\n        -- Initialize result table with one entry for each prime\
    \ in factorization.\n        factors[value] = nil\n        -- Iterate over all\
    \ numbers that are divisible by current prime factor.\n        for i = 2, value\
    \ do\n            if n % value == 0 then\n                -- If current number\
    \ divisible by current prime factor, add it to result table.\n               \
    \ factors[value] = i + 1\n                -- Divide current number by current\
    \ prime factor.\n                n = n / value\n                -- Break loop.\n\
    \                break\n            end\n        end\n    end\n    -- Return result\
    \ table\n    return factors\nend", "   if n < 2 then\n      return nil\n   end\n\
    \   local fact = {}\n   fact[1] = 1\n   for i = 2, n do\n      for j = 1, fact[i-1]\
    \ do\n         fact[j] = fact[j] * i\n      end\n   end\n   return fact\nend",
  "   local primes = {}\n   for i = 2, n do primes[i] = true end\n   local factors\
    \ = {}\n   local count = 0\n   for i = 2, n do\n      for k, prime in pairs(primes)\
    \ do\n         if prime and n % i == 0 then\n            count = count + 1\n \
    \           primes[k] = false\n            factors[#factors + 1] = i\n       \
    \     break\n         end\n      end\n   end\n   return { n = n, factor = factors\
    \ }\nend", "    local factors = {}\n    local i = 2\n    while i <= n do\n   \
    \     if n % i == 0 then\n            table.insert(factors, i)\n            n\
    \ = n / i\n        else\n            i = i + 1\n        end\n    end\n    return\
    \ factors\nend", "  -- Store factorization in dictionary\n  local factorization\
    \ = {}\n  -- Store prime factorization in dictionary\n  local primefactorization\
    \ = {}\n  -- Store number of times an element appeared in factorization\n  local\
    \ factorization_size = {}\n  -- Store number of times an element appeared in primefactorization\n\
    \  local primefactorization_size = {}\n  -- Store how many times an element appeared\
    \ in factorization is also appeared in primefactorization\n  local primefactorization_multiplication\
    \ = {}", "  local factors = {}\n  local factorsSizes = {}\n  -- Check even numbers,\
    \ starting with 2\n  if n and (n%2==0) then\n    factors[1] = 2\n    factorsSizes[1]\
    \ = 1\n  end\n  -- Check odd numbers, starting with 3\n  if n and (n%3==0) then\n\
    \    factors[2] = 3\n    factorsSizes[2] = 1\n  end\n  -- Check even numbers,\
    \ starting with 4\n  if n and (n%4==0) then\n    factors[3] = 2\n    factorsSizes[3]\
    \ = 2\n  end\n  -- Check odd numbers, starting with 5\n  if n and (n%5==0) then\n\
    \    factors[4] = 5\n    factorsSizes[4] = 1\n  end\n  -- Check even numbers,\
    \ starting with 6\n  if n and (n%6==0) then\n    factors[5] = 2\n    factorsSizes[5]\
    \ = 2\n  end\n  -- Check odd numbers, starting with 7\n  if n and (n%7==0) then\n\
    \    factors[6] = 7\n    factorsSizes[6] = 2\n  end\n  -- Check even numbers,\
    \ starting with 8\n  if n and (n%8==0) then\n    factors[7] = 2\n    factorsSizes[7]\
    \ = 4\n  end\n  -- Check odd numbers, starting with 9\n  if n and (n%9==0) then\n\
    \    factors[8] = 9\n    factorsSizes[8] = 2\n  end\n  -- Check even numbers,\
    \ starting with 10\n  if n and (n%10==0) then\n    factors[9] = 10\n    factorsSizes[9]\
    \ = 1\n  end\n  -- Check odd numbers, starting with 11\n  if n and (n%11==0) then\n\
    \    factors[10] = 11\n    factorsSizes[10] = 1\n  end\n  -- Check even numbers,\
    \ starting with 12\n  if n and (n%12==0) then\n    factors[11] = 12\n    factorsSizes[11]\
    \ = 1\n  end\n  -- Check odd numbers, starting with 13\n  if n and (n%13==0) then\n\
    \    factors[12] = 13\n    factorsSizes[12] = 2\n  end\n  -- Check even numbers,\
    \ starting with 14\n  if n and (n%14==0) then\n    factors[13] = 14\n    factorsSizes[13]\
    \ = 2\n  end\n  -- Check odd numbers, starting with 15\n  if n and (n%15==0) then",
  "  local factors = {}\n  local prime_table = {}\n  local count = 1\n  local result\
    \ = 1\n  while n do\n    local p = prime_table[count]\n    if not p then\n   \
    \   p = prime_table[p] = prime_table[p] or 1\n      prime_table[p] = p * p\n \
    \   end\n    local q = (n * p) % p\n    count = count + 1\n    if q ~= 0 then\n\
    \      factors[#factors + 1] = q\n      n = n / q\n      result = result * q\n\
    \    end\n  end\n  return factors\nend", '  assert(n >= 1)', "    local primes,\
    \ factors = {}, {}\n    local i, prime, count = 1\n    while n >= 1 and count\
    \ < n do\n        prime, count = n % i, count\n        if prime == 0 then\n  \
    \          primes[i] = nil\n        elseif prime > 1 then\n            primes[i]\
    \ = (primes[prime] or 0) + 1\n        end\n        n = n / prime\n    end\n  \
    \  local k = 0\n    for i = 1, n do\n        if primes[i] ~= nil then\n      \
    \      k = k + primes[i]\n        end\n    end\n    return primes, k\nend", " \
    \ -- Initialization\n  local factors = {}", "    local factors = {}\n    for i\
    \ = 2, n do\n        if n % i == 0 then\n            table.insert(factors, i)\n\
    \            n = n / i\n        end\n    end\n    if n > 1 then\n        table.insert(factors,\
    \ n)\n    end\n    factors = table.sort(factors)\n    return factors\nend", " \
    \   local factors = {}\n    local i = 1\n    while i <= n do\n        if n % i\
    \ == 0 then\n            n = n / i\n            factors[i] = factors[i] or 1\n\
    \            factors[i] = factors[i] + 1\n        end\n        i = i + 1\n   \
    \ end\n    return factors\nend", "  assert(n > 1)\n  local table = {}\n  for i\
    \ = 2, n do\n    local rem = n % i\n    table.insert(table, rem)\n    if rem ==\
    \ 1 then table[i] = 1 end\n  end\n  return table\nend", "    local factors = {}\n\
    \    for i = 2, n do\n        if n % i == 0 then\n            table.insert(factors,\
    \ i)\n        end\n    end\n    if #factors == 0 then\n        table.insert(factors,\
    \ n)\n    end\n    return factors\nend", '    local factors = {}', "   -- To find\
    \ number of factors, we divide n by all prime factors (p) in the factorization\
    \ of n.\n   -- If remainder is 0, then there are no factors, so n is not prime\
    \ and we return {n}.\n   -- If remainder is not 0, then n is prime and we keep\
    \ dividing n by all factors in the factorization of n and then\n   -- return the\
    \ product of all factors, since factorization is a product of prime factors.\n\
    \   local factors = {}\n   for _, p in ipairs(primes) do -- For all primes in\
    \ the factorization\n      local r = n / p -- Divide n by prime p in factorization\n\
    \      if r ~= 0 then\n         factors[#factors + 1] = p -- Add p to the list\
    \ of factors\n         n = r\n      end\n   end\n   return factors\nend", "  if\
    \ n <= 1 then return {n} end\n  local factors = {}\n  for i = 2, n do\n    local\
    \ f = n / i\n    local p = factors[f]\n    factors[f] = p\n    if p then p[1]\
    \ <= i else table.insert(factors, {i}); end\n  end\n  return factors\nend", " \
    \  -- Use dynamic programming to save some time\n   local factorization = {}\n\
    \   local p = factorization\n   local m = {}\n   for i = 2, n do\n      p[i] =\
    \ {0, {}}\n      local ps = p[i][1]\n      local m = {}\n      for j = 2, i do\n\
    \         ps[i][j] = {}\n         local p = ps[i][j]\n         if j == i then\n\
    \            m[j] = true\n         else\n            p[0] = j\n            for\
    \ k = 1, (j - i + 1) do\n               if m[k] then\n                  p[k +\
    \ 1] = p[k] + 1\n                  m[k] = false\n               else\n       \
    \           p[k + 1] = p[k]\n               end\n            end\n         end\n\
    \      end\n      p[i] = m\n   end\n   return factorization\nend", "  if n % 2\
    \ == 0 then\n    return {}, 1\n  elseif n < 10 then\n    return {n}, 1\n  else\n\
    \    local results = {}\n    for i = 2, sqrt(n) do\n      if n % i == 0 then\n\
    \        local f = n * i / i\n        if f > n then\n          return nil, 1\n\
    \        else\n          for j = 1, n do\n            if f % j == 0 then\n   \
    \           return nil, 1\n            end\n          end\n          results[#results+1]\
    \ = i\n        end\n      end\n    end\n    return results\n  end\nend", "   if\
    \ n < 2 then return nil end\n   local result = {n}\n   local i = 1\n   while i\
    \ <= math.sqrt(n) do\n      n = n / i\n      if n % 1 == 0 then\n         table.insert(result,\
    \ i)\n         i = i + 1\n      end\n   end\n   return result\nend", "  local\
    \ factors = {}\n  local primes = {}", "    local factors = {}\n    local factor\
    \ = 1\n    \n    while n > 1 do\n        while n ~= factor do\n            n =\
    \ math.floor(n/factor)\n            table.insert(factors, factor)\n        end\n\
    \        factor = 1\n        while not n % factor do\n            factor = factor+1\n\
    \        end\n        table.insert(factors, factor)\n    end\n    \n    return\
    \ factors\nend", "\tif n <= 1 then\n\t\treturn {n}\n\telseif n % 2 == 0 then\n\
    \t\treturn factorize(n / 2)\n\telse\n\t\tlocal p, factors = factorize(n / 2),\
    \ {}\n\t\twhile p*p <= n do\n\t\t\tlocal new_factor = n / p\n\t\t\tif not factors[#factors]\
    \ then\n\t\t\t\ttable.insert(factors, new_factor)\n\t\t\telseif factors[#factors]\
    \ < new_factor then\n\t\t\t\tfactors[#factors] = new_factor\n\t\t\tend\n\t\t\t\
    p = p * 2\n\t\tend\n\t\treturn factors\n\tend\nend", "  assert(n >= 1, 'Input\
    \ number should be greater than 1')\n  local factors = {}\n  local i = 1\n  --\
    \ Start from square of n and loop until all numbers less than n have been found.\n\
    \  while i * i <= n do\n    i = i + 1\n  end -- Loop", "  -- This part is taken\
    \ from here: http://stackoverflow.com/questions/2289122/implement-factorization-using-number-of-occurrences-in-a-list\n\
    \  local primes = {}\n  local factors = {}\n  for i = 2, n do -- Sieve of Eratosthenes\n\
    \    local found = false\n    for j = 2, #primes do\n      if primes[j] <= i then\n\
    \        found = true\n        break\n      end\n    end\n    if not found then\n\
    \      primes[i] = true\n      for j = 2, #primes do\n        if primes[j] ~=\
    \ i then\n          primes[j] = nil\n          break\n        end\n      end\n\
    \    end\n  end", "  if n > 2 then\n    for x = 2, n do\n      for y = n / x do\n\
    \        if n % x == 0 then\n          return factorize(y), x\n        end\n \
    \     end\n    end\n  end\nend", "    local factors = {}\n    local a = 2\n  \
    \  while a <= n do\n        local count = 0\n        for b = a do count = count\
    \ + (n % b) == 0 and 1 or 0 end\n        if count > 0 then\n            table.insert(factors,\
    \ a)\n        end\n        a = a * 2\n    end", "   -- We use integer division\
    \ here to avoid potential precision issues\n   -- (especially for negative numbers)\n\
    \   local factors = {}\n   -- Start with factorization\n   for p = 2, n do \n\
    \      factors[p] = true\n      -- If number divides evenly into p, this should\
    \ always result in a factor of p\n      if n%p == 0 then\n         break\n   \
    \   end\n   end\n   -- Iterate over factors and count how often they appear\n\
    \   for _, p in pairs(factors) do \n      factors[p] = factors[p] + 1\n   end\n\
    \   -- Return result\n   return factors\nend", "  -- If n is a prime, return its\
    \ prime factors\n  if primes[n] then return {primes[n]}\n  -- If n is a power\
    \ of 2, return its prime factors\n  if n == 2 then return {2, 1}\n  -- If n is\
    \ divisible by 2 return that and all it's factors\n  if n % 2 == 0 then return\
    \ {n, 2} -- (2**2)**2\n  -- If n is even, return all factors of n/2\n  -- >>>\
    \ factorize(4)\n  -- {2, 2}\n  -- >>> factorize(6)\n  -- {2, 3}\n  -- >>> factorize(9)\n\
    \  -- {3, 5}\n  -- >>> factorize(25)\n  -- {5, 5}\n  -- >>> factorize(25)\n  --\
    \ {5, 5}\n  -- >>> factorize(251)\n  -- {5, 6, 9, 7}\n  -- >>> factorize(70)\n\
    \  -- {2, 5, 7}\n  -- >>> factorize(41)\n  -- {2, 5, 7, 11, 13}\n  -- >>> factorize(144)\n\
    \  -- {2, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31}\n  -- >>> factorize(192)\n  --\
    \ {2, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31, 39, 47, 51, 59}\n  -- >>> factorize(207)\n\
    \  -- {2, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31, 39, 47, 51, 59, 63, 67, 71, 79,\
    \ 85, 97}\n  -- >>> factorize(3051)\n  -- {2, 5, 7, 9, 11, 13, 17, 19, 23, 29,\
    \ 31, 39, 47, 51, 59, 63, 67, 71, 79, 85, 97, 103, 111, 119, 127, 131, 137, 139,\
    \ 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229,\
    \ 233, 239, 241, 251, 257}\n  -- >>> factorize(50823)\n  -- {2, 5, 7, 9, 11, 13,\
    \ 17, 19, 23, 29, 31, 39, 47, 51, 59, 63, 67, 71, 79, 85, 97, 103, 111, 119, 127,\
    \ 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211,\
    \ 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307,\
    \ 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 37", "   -- Base case\n  \
    \ if n < 2 then\n      return nil\n   end", "  -- The largest prime factor is\
    \ sqrt(n), or n / ln(2) if n is an integer.\n  -- n / ln(2) is equal to n * (log(2)\
    \ / ln(2)) if n is an integer and log(2) is 1.\n  -- So the greatest prime factor\
    \ is one less than sqrt(n).\n  local factors = {}\n  local m = math.floor(n/log(2))\
    \ + 1\n  for i = 1, m do\n    -- Prime factorization is straightforward:\n   \
    \ -- If number mod is i, then divide number by i. If i = 1, then return number.\n\
    \    -- If number mod is other than 1, then subtract number from i until it is\
    \ divisible by i.\n    -- Example:\n    -- number = 24\n    -- i = 3, m = 7\n\
    \    -- 24 % 3 = 0\n    -- 24 % 7 = 0\n    -- 24 - (24 % 3) = 12\n    -- 12 -\
    \ (24 % 7) = 12\n    -- 12 / 7 = 2\n    -- 24 - (12 % 3) = 24\n    -- 24 - (12\
    \ % 7) = 24\n    -- 24 / 3 = 3\n    -- 24 / 7 = 3\n    -- 12 % 3 = 0\n    -- 12\
    \ % 7 = 3\n    -- 12 + (12 % 3) = 12\n    -- 12 + (12 % 7) = 12\n    -- 12 / 3\
    \ = 1\n    -- 12 / 7 = 1\n    -- 12 % 3 = 12\n    -- 12 % 7 = 12\n    -- 24 %\
    \ 3 = 24\n    -- 24 % 7 = 24\n    -- 24 - (24 % 3) = 24\n    -- 24 - (24 % 7)\
    \ = 24\n    -- 24 / 3 = 6\n    -- 24 / 7 = 6\n    -- 12 % 3 = 2\n    -- 12 % 7\
    \ = 2\n    -- 12 - (12 % 3) = 12\n    -- 12 - (12 % 7) = 12\n    -- 12 / 3 = 2\n\
    \    -- 12 / 7 = 2\n    -- 12 % 3 = 12\n    -- 12 % 7 = 12\n    -- 24 % 3 = 24\n\
    \    -- 24 % 7 = 24\n    -- 24 - (24 % 3) = 24\n    -- 24 - (24 % 7) = 24\n  \
    \  -- 24 / 3 = 2\n    -- 24 / 7 = 2\n    -- 12 % 3 = 2\n    -- 12 % 7 = 2\n  \
    \  -- 12 - (12 % 3) = 12\n    -- 12 - (12 % 7) = 12\n    -- 12 / 3 = 2\n    --\
    \ 12 / 7 = 2\n    -- 12 % 3 = 12\n    -- 12 % 7 = 12\n    local m = n / i\n  \
    \  local factor = 1\n    while m ~= 1 do\n      factor = factor * i\n      n =\
    \ m - factor\n      m = n / i\n    end\n    table.insert(factors, factor)\n  end\n\
    \  return factors\nend", "  local factors = {}\n  local i = 1\n  local p = math.floor(n/2)\n\
    \  while i <= math.sqrt(n) do\n    if n % i == 0 then\n      factors[i] = i\n\
    \      n = n / i\n      i = i + 1\n    end\n  end\n  if n ~= 1 then\n    factors[n]\
    \ = n\n  end\n  return factors\nend", "  if n > 1 then\n    local factor = math.floor(n/2)\n\
    \    factorize(n-factor)\n    factorize(factor)\n  end\n  return factor\nend",
  "    local factors = {}\n    local p = 2\n    local m = 1\n    while n >= m do\n\
    \        local i = math.floor(n / m)\n        n = m - i * m\n        if p * i\
    \ <= n then\n            table.insert(factors, p * i)\n        else\n        \
    \    table.insert(factors, n)\n        end\n        local f = p\n        local\
    \ while p * f <= n do\n            n = n - p * f\n            table.insert(factors,\
    \ f)\n            f = p\n        end\n        table.insert(factors, m)\n     \
    \   table.insert(factors, p * i)\n        p = p + 1\n    end\n    if n > 1 then\n\
    \        table.insert(factors, n)\n    end\n    return factors\nend", "   local\
    \ ret = {}\n   local p = math.floor(n/5)\n   if p == 0 then\n      ret[1] = n\n\
    \      return ret\n   end\n   for i = 1, p do\n      local q = math.floor(n/5)\n\
    \      if p*p == q*q then\n         ret[p] = n\n         return\n      else\n\
    \         n = q\n      end\n   end\n   ret[p] = n\n   return ret\nend", "  local\
    \ factors = {}\n  local i = 2\n  while i <= n do\n    while n % i == 0 do\n  \
    \    factors[i] = i\n      n = n / i\n      i = i + 1\n    end\n    i = i + 1\n\
    \  end\n  if n > 1 then factors[#factors + 1] = n end\n  return factors\nend",
  "    local factors = {}\n    local fact = 1\n    local p = 0\n    local i = 1\n\
    \    while i <= n do\n        while n % fact == 0 do\n            factors[p] =\
    \ fact\n            p = p + 1\n            fact = fact * i\n        end\n    \
    \    i = i + 1\n    end\n    return factors\nend", "   local ret = {}\n   if n==1\
    \ then return ret\n   end\n   local p = 2\n   while p*p <= n do\n      if n%p\
    \ == 0 then\n         ret[p] = n\n         p = p + 1\n      end\n      p = p *\
    \ 2\n   end\n   return ret\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
