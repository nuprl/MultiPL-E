name: HumanEval_11_string_xor
language: lua
prompt: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
  \ binary XOR on these inputs and return result also as a string.\n-- >>> string_xor('010',\
  \ '110')\n-- '100'\nlocal function string_xor(a, b)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
  \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
  \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    return a:byte(1, 1) xor b:byte(1, 1):reverse()\nend", "\tassert(type(b)\
    \ == 'string', 'Second argument of string_xor must be a string.')\n\tassert(type(a)\
    \ == 'string', 'First argument of string_xor must be a string.')\n\tlocal result\
    \ = {}\n\tlocal i, j = 1, 1\n\tfor k in ipairs(a) do\n\t\tif a[k] == b[k] then\n\
    \t\t\tresult[i] = a[j]\n\t\t\tj = j + 1\n\t\tend\n\t\ti = i + 1\n\tend\n\tif i\
    \ == 1 then\n\t\treturn result\n\telse\n\t\treturn result\n\tend\nend", "  if\
    \ type(a) ~= 'string' or type(b) ~= 'string' then\n    return nil\n  end\n  return\
    \ a:gsub(\"%l\", function (c) return \"%d\" .. string.format('%x', b:byte(c))\
    \ end):gsub(\"%S\", function (c) return string.format('%d', a:byte(c)) end)\n\
    end", "    local res, tmp\n    res = ''\n    tmp = string.byte(a) .. string.byte(b)\n\
    \    for i = 1, 8 do\n        if string.byte(tmp .. i) == 0 then\n           \
    \ res = res .. string.byte(a)\n        else\n            res = res .. string.byte(b)\n\
    \        end\n    end\n    return res\nend", "\tlocal bina = '0'.. tostring(a:gsub('1',\
    \ '0'))\n\tlocal binb = '0'.. tostring(b:gsub('1', '0'))\n\tlocal s = \"\"\n\t\
    for i = 1, #bina do\n\t\ts = s .. tostring(bina:sub(i,i)):reverse()\n\tend\n\t\
    for i = 1, #binb do\n\t\ts = s .. tostring(binb:sub(i,i)):reverse()\n\tend\n\t\
    return s\nend", "  local function b2a(s)\n    local t = {}\n    for i = 1, #s,\
    \ 1 do\n      table.insert(t, tostring(s:byte(i) ~= s:byte(#s) - 1))\n    end\n\
    \    return table.concat(t)\n  end\n  return string(b2a(a) .. b2a(b), 2)\nend",
  "    local x = '00000000000000000000000000000000000000000000000000000000000000'\n\
    \    for i = 1, 32 do\n        x = (x XOR tostring(string_byte(a, i)))\n     \
    \   x = (x XOR tostring(string_byte(b, i)))\n    end\n    return tostring(x)\n\
    end", "  a = string.rep(a, 8)\n  b = string.rep(b, 8)\n  local result = a\n  for\
    \ i = 1, 8 do\n    if math.abs(tonumber(result) ^ tonumber(b[i])) ~= 0 then\n\
    \      result = string.rep('1', 8)\n    else\n      result = string.rep('0', 8)\n\
    \    end\n  end\n  return result\nend", "   local tmp = {}\n   for _, c in ipairs(a)\
    \ do\n      table.insert(tmp, c ^ b[#b])\n   end\n   return table.concat(tmp)\n\
    end", "\tlocal binA = '00000000'\n\tlocal binB = '00000000'\n\tlocal binRes",
  "  local output = \"\"\n  for i = 1, #a do\n    local tmp = a[i] or b[i]\n    output\
    \ = output .. string.char( (tmp XOR b[i]) ~= 0 end)\n  end\n  return output\n\
    end", "    local xor_value = 0\n    for i = 1, #a do\n        xor_value += tonumber(a[i])\
    \ xor tonumber(b[i])\n    end\n    return tostring(xor_value)\nend", "\tlocal\
    \ xor_table = {\n\t\t{'0', '0'},\n\t\t{'1', '1'},\n\t\t{'1', '0'},\n\t\t{'0',\
    \ '1'},\n\t}", "    return string.format('%d%d', tonumber(a) ^ tonumber(b), tostring(a)\
    \ ^ tostring(b))\nend", "    assert(type(a ~= 'string' or type(b ~= 'string'),\
    \ 'string'), 'a and b must be strings')\n    local r = {}\n    for _, v in pairs(a)\
    \ do r[v] = 1 end\n    for _, v in pairs(b) do r[v] = 0 end\n    return table.concat(r)\n\
    end", "    local c = '{'\n    for i=1, #a do\n        if a:sub(i, i) ~= '0' and\
    \ a:sub(i, i) ~= '1' then break end\n        local d = tostring(a:sub(i, i)) +\
    \ tostring(b:sub(i, i))\n        c = c .. '0' .. d .. '0'\n    end\n    c = c\
    \ .. '}'\n    return c\nend", "\tlocal bina = bit.band(a, 2^32)\n\tlocal binb\
    \ = bit.band(b, 2^32)\n\tlocal xored = bit.bxor(bina, binb)\n\treturn (bit.rshift(xored,32)..'0'):reverse()\n\
    end", "    local xor_result = a\n    for i = 1, #b do\n        xor_result = xor_result\
    \ ^ b[i]\n    end\n    return xor_result\nend", "  local result = \"\"\n  local\
    \ idx = 0\n  while idx <= #a do\n    idx = idx + 1\n    if idx > #a then return\
    \ result end\n    if a[idx] == \"0\" then\n      result = result .. \"1\" .. \"\
    0\"\n    else\n      result = result .. \"0\"\n    end\n  end\n  return result\n\
    end", "\ta = a:byte()\n\tb = b:byte()\n\tlocal s = ''\n\tfor i = 0, 8 do\n\t\t\
    local a = a or 0\n\t\tlocal b = b or 0\n\t\tlocal res = a xor b\n\t\ts = s ..\
    \ '1' if res > 0 else '0'\n\tend\n\treturn s\nend", "\tlocal bits = assert(io.open(b,\
    \ \"rb\"), \"Could not open file \" .. b)\n\tlocal result = assert(io.open(a,\
    \ \"wb\"), \"Could not open file \" .. a)\n\tlocal s = bits:read('*a')\n\tfor\
    \ i = 1, #s do\n\t\ts:set(i - 1, 1)\n\t\tassert(bits:write('*a', s), \"Could not\
    \ write to file \" .. a)\n\tend\n\tbits:close()\n\tresult:close()\n\treturn assert(io.open(a,\
    \ \"rb\"), \"Could not open file \" .. a)\nend", "  if a ~= nil then\n    if b\
    \ == nil then\n      return a\n    elseif type(b) == 'string' then\n      b =\
    \ tohex(b)\n    end\n  elseif a ~= nil then\n    b = a\n  elseif a == nil then\n\
    \    a = b\n  end\n  \n  local function xor(byte, bit)\n    if byte and bit then\n\
    \      byte = byte:byte(0) or byte\n      bit = bit:byte(0) or bit\n      return\
    \ tohex(byte and bit == 0 and 1 or byte and bit:byte(1) or byte xor bit)\n   \
    \ end\n  end\n  \n  local output = ''\n  \n  local byte1\n  local byte2\n  \n\
    \  while #a > 0 do\n    byte1, a = submatch(1, a)\n    byte2, a = submatch(2,\
    \ a)\n    \n    byte1 = tonumber(byte1, 2)\n    byte2 = tonumber(byte2, 2)\n \
    \   \n    byte1, byte2 = xor(byte1, byte2)\n    \n    output = output .. byte1\n\
    \  end\n  \n  while #b > 0 do\n    byte1, b = submatch(1, b)\n    byte2, b = submatch(2,\
    \ b)\n    \n    byte1 = tonumber(byte1, 2)\n    byte2 = tonumber(byte2, 2)\n \
    \   \n    byte1, byte2 = xor(byte1, byte2)\n    \n    output = output .. byte1\n\
    \  end\n  \n  return output\nend\n</code>\n<|/ a dscore=4 |>\n<| a |>\nFor anyone\
    \ still looking for an answer, this is the one I came up with. It uses the lua\
    \ built-in library to convert hex string to binary and back to a hex string -\
    \ which I find slightly simpler than the string handling I used in the other answers.\
    \ Also note that this approach assumes that all inputs are either strings of numbers\
    \ or nil.\n<code>", "  assert(type(a) == 'string' and type(b) == 'string')\n \
    \ local z = '00000000000000000000000000000000'\n  local n = #a\n  for i = 1, n\
    \ do\n    z = z .. string.format('%010x', b) .. a\n    a = a..'1'\n    b = b..'0'\n\
    \  end\n  return z\nend", "   local bin1 = assert(io.binary(a:sub(1, math.min(a:len(),\
    \ 8))),\n                      \"Invalid binary input.\")\n   local bin2 = assert(io.binary(b:sub(1,\
    \ math.min(b:len(), 8))),\n                      \"Invalid binary input.\")\n\
    \   return bin1:byte(1, bin1:len()-1) ^ bin2:byte(1, bin2:len()-1)\nend", "  local\
    \ result = \"\"\n  for i = 1, #a do\n    local carry = tostring(a[i]) ~= tostring(b[i])\n\
    \    local carry_str = carry and \"1\" or \"0\"\n    local new_char = carry_str\
    \ .. tostring(b[i])\n    result = (result and new_char) or (carry_str .. tostring(a[i]))\n\
    \  end\n  return result\nend", "  local bit1 = 0\n  local bit2 = 0\n  local result\
    \ = ''\n  for i = 1, #a do\n    bit1 = a[i] and 1 or 0\n    bit2 = b[i] and 1\
    \ or 0\n    result = result .. bit1 xor bit2\n  end\n  return result\nend", " \
    \ local out = ''\n  for i = 1, #a do\n    local carry = a[i] and b[i]\n    if\
    \ carry then\n      out = out .. string.format('%+d', carry)\n    else\n     \
    \ out = out .. a[i]\n    end\n  end\n  return out\nend", "  local ret = ''\n \
    \ for i = 1, #a do\n    ret = ret .. string.rep(tostring(a:byte(i)^b:byte(i)),\
    \ 4)\n  end\n  return ret\nend", "  if type(a) ~= 'string' or type(b) ~= 'string'\
    \ then\n    return nil\n  end\n  local length = math.min#a, math.min#b\n  local\
    \ result = \"\"\n  for i = 1, length do\n    local c = string.byte(a, i) or 0\n\
    \    local d = string.byte(b, i) or 0\n    local s = string.byte(result, i)\n\
    \    if s then\n      s = s ^ c ^ d\n    else\n      s = c ^ d\n    end\n    string.copy(result,\
    \ i, 1, s)\n  end\n  return result\nend", "  local n = #a\n  local m = #b\n  local\
    \ s = \"\"\n  for i = 1, n do\n    s = s .. tostring(a[i]) ^ tostring(b[i])\n\
    \  end\n  return s\nend", "  local s = ''\n  for i = 1, #a do\n    local p = string.format('.%d',\
    \ i)\n    s = s .. string.format('.%d', string.format('%x', a[p] xor b[p]))\n\
    \  end\n  return s\nend", "    assert(type(b) == 'string')\n    assert(type(a)\
    \ == 'string')\n    assert(#a == #b)\n    local ret = ''\n    for i = 1, #a do\n\
    \        ret = ret .. a[i]\n    end\n    return ret\nend", "   local bstr = b\n\
    \   local astr = a\n   local lena = #astr\n   local lenb = #bstr\n   local ret\
    \ = ''\n   for i = 1, lena do\n      ret = ret .. astr:byte(i) ^ bstr:byte(i)\n\
    \   end\n   return ret\nend", "\t-- Convert input strings to binary\n\tlocal a_bin\
    \ = ffi.string(a)\n\tlocal b_bin = ffi.string(b)", "\tlocal res = \"\"\n\tlocal\
    \ _a = a:gsub(\"%d%d%d?%d%d?%d%d?\", \"%1$2$3\")\n\tlocal _b = b:gsub(\"%d%d%d?%d%d?%d%d?\"\
    , \"%1$2$3\")\n\tfor i = 0, 8 do\n\t\t_a = string_sub(string_xor(_a, _b), i)\n\
    \t\t_b = string_sub(_b, i) \n\tend\n\treturn res\nend", "  local c = ''\n  for\
    \ i = 1, #a do\n    if a[i] ~= b[i] then\n      c = c .. a[i]\n    end\n  end\n\
    \  return c\nend", "    local bit1 = a\n    local bit2 = b\n    while true do\n\
    \        bit1 = bit1 XOR bit2\n        if bit1 == 0 then\n            break\n\
    \        end\n        bit2 = bit2 XOR bit1\n    end\n    return bit1\nend", " \
    \ local c = '00000000000000000000000000000000'\n  for i = 1, #a do\n    c = string.rep(c,\
    \ 1, #b) + b[i]\n  end\n  for i = 1, #a do\n    c = string.rep(c, 1, #a) + a[i]\n\
    \  end\n  return c\nend", "  if type(b) ~= 'string' then\n    error('Expected\
    \ two strings')\n  end\n  local a_list = split_bin(a)\n  local b_list = split_bin(b)\n\
    \  local xor_list = {}\n  local result = ''\n  for i = 1, #a_list do\n    xor_list[i]\
    \ = xor_list[i] + a_list[i]\n  end\n  for i = 1, #b_list do\n    xor_list[i +\
    \ #a_list] = xor_list[i + #a_list] + b_list[i]\n  end\n  for i = 1, #xor_list\
    \ do\n    if xor_list[i] > '1' then\n      xor_list[i] = '0'\n    end\n    if\
    \ xor_list[i] > '0' then\n      xor_list[i] = '1'\n    end\n    result = result\
    \ + string.sub(xor_list, i, i)\n  end\n  return result\nend", "  if type(a) ~=\
    \ 'string' or type(b) ~= 'string' then\n    error('First and second input arguments\
    \ must be strings')\n  end\n  local n1 = #a\n  local n2 = #b\n  if n1 ~= n2 then\n\
    \    error('Strings lengths must be equal')\n  end\n  local ret = ''\n  for i\
    \ = 1, n1 do\n    ret = ret .. (a[i] ~= b[i] and '1' or '0')\n  end\n  return\
    \ ret\nend", "    return a:gsub('0', '.'):gsub('1', '0'):gsub('00', '.')\nend",
  "    local bina = \"0000000000000000000000000000000000000000000000000000000000000\"\
    \ .. a\n    local binb = \"0000000000000000000000000000000000000000000000000000000000000\"\
    \ .. b", "  assert(type(a) == \"string\" and type(b) == \"string\")\n  assert(length(a)\
    \ == length(b))\n  local output = {}\n  for i = 1, #a do\n    local a_bin = a:sub(i,\
    \ i)\n    local b_bin = b:sub(i, i)\n    if a_bin == '1' then\n      table.insert(output,\
    \ '0')\n    elseif b_bin == '1' then\n      table.insert(output, '1')\n    end\n\
    \  end\n  return table.concat(output, '') -- Convert table of strings to string\n\
    end", "   local bits = string.format('%0', a)\n   for i = 1, #b do\n      bits\
    \ = bits .. string.format('%0', b[i])\n   end\n   return bits\nend", "  local\
    \ ret = ''\n  for i = 1, #a do\n    local c = table.remove(a, i)\n    ret = ret\
    \ .. string.char(c) ^ string.char(b)\n  end\n  return ret\nend", "  local result\
    \ = a .. b\n  local length = #result\n  for i = 1, length do\n    result[i] =\
    \ string.char(result[i]) XOR string.char(b)\n  end\n  return string.gsub(result,\
    \ '1', '0')\nend", "   local res = {}\n   for i = 1, #a do\n      res[i] = string.byte(a,\
    \ i) ~= string.byte(b, i)\n   end\n   return table.concat(res, '')\nend", "  \
    \  local bina = tonumber(tostring(a))\n    local binb = tonumber(tostring(b))\n\
    \    if bina == nil or binb == nil then return nil end\n    return tostring(bina\
    \ xor binb)\nend", "  local c = ''\n  for i = 1, #a do\n    c = c .. math.abs(math.floor((string.byte(a)\
    \ XOR string.byte(b)) % 2))\n  end\n  return c\nend", "    return a:gsub(\"1\"\
    , \"0\"):gsub(\"0\", \"1\"):gsub(\"11\", \"10\"):gsub(\"10\", \"11\")\nend", " \
    \   if a ~= nil then\n        a = tonumber(a)\n    end\n    if b ~= nil then\n\
    \        b = tonumber(b)\n    end", "    local result = \"\"\n    for i = 0, #a\
    \ do\n        if a[i] and b[i] then\n            result = (result .. tostring(a[i])\
    \ .. tostring(b[i]))\n        end\n    end\n    return result\nend", "   assert(type(a)\
    \ == 'string' and type(b) == 'string')\n   assert(a ~= nil and b ~= nil)\n   return\
    \ string.char(string.byte(a) xor string.byte(b))\nend", "    assert(type(a) ==\
    \ 'string', 'string_xor: First argument is not a string')\n    assert(type(b)\
    \ == 'string', 'string_xor: Second argument is not a string')\n    assert(a and\
    \ b, 'string_xor: Both arguments are empty')\n    return string.format('%s%s%s',\n\
    \        string.char(xor(unpack(a), unpack(b))),\n        string.char(xor(unpack(a),\
    \ unpack(b))),\n        string.char(xor(unpack(a), unpack(b)))\n    )\nend", " \
    \  local bits = {unpack(\n      a..b\n         :gsub('0', '.')\n         :gsub('1',\
    \ '.')\n         :gsub('1', '0'))}", "    if a~=b and a~=nil and b~=nil then\n\
    \        return tostring(a..b)\n    else\n        return nil\n    end\nend\nreturn\
    \ string_xor", "    if a ~= b then\n        return a\n    end\n    return ''\n\
    end", "  local c = ''\n  for i = 1, #a do\n    c = (string.byte(a, i):bit.xor(string.byte(b,\
    \ i):bit)):byte()\n  end\n  return c\nend", "    local a_arr = a:gsub('0', '\\\
    0')\n    local b_arr = b:gsub('0', '\\0')", "   local c = ''\n   for i = 1, #a\
    \ do\n      c = c..((a[i] == b[i]) and '0' or '1')\n   end\n   return c\nend",
  "    local na, nb = tonumber(a), tonumber(b)\n    if na == 0 and nb == 0 then return\
    \ \"0\" end\n    local bin1 = string.rep(\"1\", na)\n    local bin2 = string.rep(\"\
    1\", nb)\n    return binxor [bin1 .. bin2]\nend", "\ta = tostring(a)\n\tb = tostring(b)\n\
    \tassert(a == \"010\" and b == \"110\", \"Arguments should be strings of 1s and\
    \ 0s.\")\n\tlocal result = a\n\tfor i, v in ipairs(a) do\n\t\tresult = string.format('%s%s%s%s%s',\
    \ result, v, b, v, result)\n\tend\n\treturn result\nend", "    local ret = \"\"\
    \n    for i = 1, #a do\n        -- Perform binary XOR on two chars a and b.\n\
    \        local xor = string.byte(a, i) XOR string.byte(b, i) \n        if xor\
    \ > 255 then\n            -- We do not want to output binary XOR more than 2 chars\
    \ long.\n            xor = 255\n        end\n        -- Store XOR value in ret\
    \ as a string.\n        ret = ret .. string.format('%0.2x', xor)\n    end\n  \
    \  return ret\nend", "  local s = ''\n  for i = 0, #a do\n    s = s .. string.format(\"\
    %d%d%d%d%d\",\n      tonumber(a[i]), tonumber(b[i]),\n      tonumber(a[i + #a]),\
    \ tonumber(b[i + #b]),\n      tonumber(a[i + #a * 2]), tonumber(b[i + #b * 2]))\n\
    \  end\n  return s\nend", "    local function to_int(x)\n        local s = ''\n\
    \        for i = 1, 8 do\n            s = s .. x%2\n            x = x / 2\n  \
    \      end\n        return s\n    end", "    local res = a\n    for i = 1, #b,\
    \ 1 do\n        res = res ^ b[i]\n    end\n    return res\nend", "  return string.format('%x',\
    \ bit.bor(bit.bxor(bit.rshift(a, 8), bit.rshift(b, 8)), bit.bxor(bit.lshift(a,\
    \ 8), bit.lshift(b, 8)))) -- Convert decimal to binary and apply XOR.\nend", " \
    \ a = string_tobitarray(a)\n  b = string_tobitarray(b)\n  local c = ''\n  for\
    \ i = 1, #a do\n    local j = 0\n    while j + 8 <= #b do\n      local k = (i\
    \ + j + 8 - 1) >> 3\n      c = bit.lxor(a[i], b[k])\n      if c == 0 then break\
    \ end\n      j = j + 8\n    end\n  end\n  return c\nend", "  local x = a:byte()\n\
    \  local y = b:byte()\n  local s = ''\n  for i = x, y + 1 do\n    s = s .. bit.bor(bit.lshift(bit.band(x,\
    \ 2), 8), '0')\n    s = s .. bit.bor(bit.lshift(bit.band(x, 2), 8), '1')\n   \
    \ x = bit.rshift(x, 2)\n  end\n  return s\nend", "  if type(a) ~= 'string' or\
    \ type(b) ~= 'string' then return '~invalid~' end\n  local s = ''\n  for i = 1,\
    \ #a do\n    local c1 = string.byte(a) - i\n    local c2 = string.byte(b) - i\n\
    \    s = s .. string.format('%c%c', string.byte(c1), string.byte(c2))\n  end\n\
    \  return s\nend", "   return string.reverse(string.rep(a, math.min(a:len(), b:len())):sub(1,\
    \ math.min(a:len(), b:len())) .. string.rep(b, math.min(a:len(), b:len())):sub(1,\
    \ math.min(a:len(), b:len()))) -- Reverse of string.sub with start and end reversed.\n\
    end", "    assert(type(a) == \"string\" and type(b) == \"string\")\n    assert(#a\
    \ == #b)\n    local c = ''\n    for i = 1, #a do\n        c = (string.byte(a,\
    \ i) xor string.byte(b, i)) % 10\n    end\n    return c\nend", "  -- This doesn't\
    \ work with strings longer than 8 bits.\n  assert(tonumber(a) <= 2^8 - 1)\n  assert(tonumber(b)\
    \ <= 2^8 - 1)", "    assert(type(a) == 'string' and type(b) == 'string')\n   \
    \ assert(#a > 0 and #b > 0)\n    assert(b:byte(0) == a:byte(0))\n    return ffi.string(tostring(a)\
    \ .. tostring(b))\nend", "    assert(type(a) == 'string' and type(b) == 'string')\n\
    \    local bin1 = tonumber(a) .. '1' and 1\n    local bin2 = tonumber(b) .. '1'\
    \ and 1\n    local res = ''\n    for i = 1, #a do\n        local xc = bin1 xor\
    \ bin2\n        local temp = tostring(xc / 2)\n        res = (string.sub(res,\
    \ i - 1, i) + temp or '') + tostring(xc % 2)\n        bin1 = bin2\n        bin2\
    \ = temp\n    end\n    return (res)\nend", "    return tostring(tostring(a) XOR\
    \ tostring(b))\nend", "  return a:byte() ^ b:byte()\nend", "  local str1 = assert(string.reverse(a))\n\
    \  local str2 = assert(string.reverse(b))\n  return string.format('%x%x%x',\n\
    \      str1, str1, str1,\n      str2, str2, str2)\nend", "\ta = a or \"\"\n\t\
    b = b or \"\"\n\tlocal c = \"\"\n\tlocal i = 1\n\twhile i <= #a do\n\t\tlocal\
    \ x = string.byte(a, i)\n\t\tlocal y = string.byte(b, i)\n\t\tif x^y ~= 0 then\n\
    \t\t\tc = c .. tostring(x^y)\n\t\telse\n\t\t\tc = c .. tostring(x)\n\t\tend\n\t\
    \ti = i + 1\n\tend\n\treturn c\nend", "  a = tostring(a)\n  b = tostring(b)\n\
    \  return a:gsub(\"%1$s%1$s\", function (_, c, d)\n    return d .. c:upper()\n\
    \  end):gsub(\"%1$s%1$s\", \"%1$s%1$s\")\nend", "   -- Convert input arguments\
    \ to numbers\n   a = tonumber(a) or a\n   b = tonumber(b) or b\n   -- Perform\
    \ binary XOR on the inputs\n   return string.format('%d', a ^ b)\nend", "  a =\
    \ tonumber(a)\n  b = tonumber(b)\n  return tonumber(a:byte(1, 1):bit(8) * (not\
    \ b or '1') + a:byte(7, 1):bit(8) * (b or '1'):byte(1, 8))\nend", "    return\
    \ a:gsub('1', '0'):gsub('0', '1'):gsub('1', '0'):gsub('0', '1')\nend", "    return\
    \ tostring(unpack(a) XOR unpack(b))\nend", "  local c = ''\n  for i = 1, #a do\n\
    \    c = c .. tostring(a:byte(i) xor b:byte(i))\n  end\n  return c\nend", "  local\
    \ res = \"\"\n  for i=1,#a do\n    local tmp = a[i]\n    local xor = tmp ^ b[i]\n\
    \    if xor > 0 and xor <= #a then\n      res = res .. tmp\n    else\n      res\
    \ = res .. xor\n    end\n  end\n  return res\nend", "  local c = ''\n  for i =\
    \ 0, #a do\n    if tonumber(a[i]) ~= tonumber(b[i]) then c = c .. a[i] end\n \
    \ end\n  return c\nend", "  local a_bin = string.char(a)\n  local b_bin = string.char(b)\n\
    \  local x = \"\"\n  local done = false\n  for i = 1, 32 do\n    if a_bin == \"\
    \" and b_bin == \"\" then\n      done = true\n      break\n    end", "  local\
    \ res = \"\"\n  for i in string.byte(a) do\n    res  = res .. (string.byte(a)\
    \ ~ string.byte(b) ? '1' : '0')\n  end\n  return res\nend", "   local r, i = 0,\
    \ 0\n   for j = 1, #a do\n      r = r + (a[i] xor b[j])\n      i = i + 1\n   \
    \   if i > #a then\n         return string.format('%x', r) -- Convert back to\
    \ a string.\n      end\n   end\n   return string.format('%x', r)\nend", "  if\
    \ type(a) ~= 'string' then error('First argument is not a string') end\n  if type(b)\
    \ ~= 'string' then error('Second argument is not a string') end", "    -- This\
    \ code is more efficient than the C code because it only uses Lua string\n   \
    \ -- operations instead of calling C/Fortran string operations.\n    -- It uses\
    \ arithmetic operations instead of string operations.\n    -- The idea is that\
    \ it can operate on numbers which overflow Lua integer limits.\n    -- The Lua\
    \ code overflows a number to 9223372036854775807, which is beyond Lua's limits\n\
    \    -- when performing arithmetic operations.\n    -- This code also handles\
    \ Lua numbers larger than the integer limits.\n    local n = #a ^ #b\n    local\
    \ res\n    if n > 0 then\n        res = \"\"\n        for i = 1, n do\n      \
    \      res = res .. string.byte(a ^ b[i])\n        end\n    end\n    return res\n\
    end", "\tlocal xor_table = {\n\t\t[#a] = '1',\n\t\t[#b] = '1',\n\t}\n\tlocal xor_string\
    \ = ''\n\tfor _, c in ipairs(a) do\n\t\txor_string = xor_string .. xor_table[#c]\
    \ .. b[#c]\n\tend\n\treturn xor_string\nend", "   return string.format('%x' ..\
    \ a, '%x' .. b, '%x' .. ~a, '%x' .. ~b, '%x' .. ~a xor ~b)\nend", "\tassert(a\
    \ and b, 'First and second arguments of the function must be strings')\n\tassert(#a\
    \ == #b, 'The length of first argument must equal the length of second')\n\tlocal\
    \ res = ''\n\tfor i = 1, #a do\n\t\tres = res + a:sub(i, i) + b:sub(i, i)\n\t\
    end\n\treturn res\nend", "  return b:byte(1) xor a:byte(1)\nend", "  return b\
    \ or a\nend", "    return a:gsub(\"%d%d\", function(x)\n        return string.format('%x',\
    \ tonumber(x)) ^ tonumber(b)\n    end)\nend", "  -- Convert the strings to lists\
    \ of characters.\n  local list_a = string.char(a):byte()\n  local list_b = string.char(b):byte()",
  "    local binA   = tostring(a:gsub('1', '0'))\n    local binB   = tostring(b:gsub('1',\
    \ '0'))\n    local binAnd = binA .. binB\n    return binAnd:gsub('1', '0')\nend",
  "    local tmp, carry = 0, 1\n    for i = 1, #a do\n        tmp = tmp + carry *\
    \ tonumber(a[i], 2)\n        carry = tmp >= 256\n        tmp = tmp % 256\n   \
    \ end\n    return tostring(tonumber(tmp, 2)) .. tostring(carry or 0)\nend", " \
    \ local xor = ''\n  for i = 1, #a do\n    xor = xor .. a[i] xor b[i]\n  end\n\
    \  return xor\nend", "    local t = {}\n    for i = 1, #a do\n        local v\
    \ = a[i]\n        t[i] = v and 0 xor v\n    end\n    table.concat(t, '', 0)\n\
    end", "    if a == nil or b == nil then\n        return nil\n    end\n    if #a\
    \ ~= #b then\n        return nil\n    end\n    local ret = \"\"\n    for i = 1,\
    \ #a do\n        ret =  ret .. string.char((string.byte(a) ^ string.byte(b))[i])\n\
    \    end\n    return ret\nend", "    local xor, i = nil, 0\n    while i < #a do\n\
    \        xor = xor ^ (tostring(a[i]) .. (tostring(b[i])))\n        i = i + 1\n\
    \    end\n    return xor .. tostring(a[i])\nend", "    -- Convert to binary string\n\
    \    local xa = ffi.new(\"uint8_t[]\", ffi.string(a))\n    local xb = ffi.new(\"\
    uint8_t[]\", ffi.string(b))\n    local xc\n    local xd = ffi.new(\"uint8_t[]\"\
    )\n    local xe", "  if #a ~= #b then\n    return nil\n  end\n  local table =\
    \ {}\n  for i = 0, #a do\n    table[i] = tostring(a[i]) ^ tostring(b[i])\n  end\n\
    \  return table.concat(tostring(table.unpack(table, 2, #a)))\nend", "  assert(type(a)\
    \ == 'string' and type(b) == 'string')\n  assert(#a == #b)\n  local result = {}\n\
    \  for i = 1, #a do\n    local l = string.len(a[i])\n    if string.len(a[i]) >\
    \ 1 then\n      assert(a[i] == b[i])\n    end\n    for k = 1, l do\n      result[i]\
    \ = string.sub(a[i], k, k+1)\n    end\n  end\n  table.insert(result, #result,\
    \ '0')\n  table.insert(result, #result, '0')\n  return table.concat(result)\n\
    end", "    local result = {}\n    for i = 1, #a do\n        if a[i] == b[i] then\n\
    \            result[i] = a[i]\n        else\n            result[i] = a[i] ^ b[i]\n\
    \        end\n    end\n    return table.concat(result)\nend", "   local x = ''\n\
    \   for i = 1, #a do\n      x = x .. string.rep('0', #b) .. tostring(tonumber(b)\
    \ ^ tonumber(a[i]))\n   end\n   return x\nend", "  return a:byte(0) ^ b:byte(0)\n\
    end", "    local ret = ''\n    for i=1, #a do\n        ret = ret .. a[i] xor b[i]\n\
    \    end\n    return ret\nend", "  local l1 = #a\n  local l2 = #b", "\t-- Convert\
    \ from binary string to integer for fast computation of XOR\n\tlocal a_bin = tohex(a)\
    \ .. tohex(b)\n\t-- Convert from integer string to binary string\n\tlocal a_bin_bin\
    \ = string.gsub(a_bin, \".\", \"\")", "    if a ~= b or type(a) ~= 'string' or\
    \ type(b) ~= 'string' then\n        return 'Type Error'\n    end\n    local s\
    \ = a\n    for i = 1, #a do\n        s = string.sub(s,i,i)..b[i]\n    end\n  \
    \  return s\nend", "\tlocal r = \"\"\n\tfor i = 0, #a do\n\t\tr = r .. tostring(a:byte(i)^b:byte(i))\n\
    \tend\n\treturn r\nend", "  local res, str1, str2 = \"\", a, b\n  for i = 0, #str2\
    \ do res = res .. chr(math.abs(str1[i] ^ str2[i])) end\n  return res\nend", " \
    \ return a:gsub('0', 'X'):gsub('1', '0'):gsub('X', '1')\nend", "  a = tobits(a)\n\
    \  b = tobits(b)\n  return tobits(a) ^ tobits(b)\nend", "    local res = 0\n \
    \   for i = 1, #a, 1 do\n        res = res + tostring(a:sub(i, i)) - tostring(b:sub(i,\
    \ i))\n    end\n    return tostring(res)\nend", "   a = a..'0'\n   b = b..'0'\n\
    \   return ((a.char-b.char)^0xff)\nend", "  local binary = string.format(\"%08b\"\
    , tonumber(a))\n  binary = binary .. string.format(\"%08b\", tonumber(b))\n  local\
    \ result = binary..string.format(\"%08b\")\n  return result\nend", "  local xor\
    \ = \"\"\n  for i = 1, #a do\n    xor = xor .. math.abs(tonumber(a) ^ tonumber(b))\
    \ % 10\n    a = a[1:i]\n    b = b[1:i]\n  end\n  return xor\nend", "  if type(a)\
    \ ~= 'string' or type(b) ~= 'string' then\n    error('Input must be strings.')\n\
    \  end", "   local res = a:byte(1, 2):uint()\n   for i = 1, #a do\n      res =\
    \ (res XOR b:byte(i, 2):uint()) XOR a:byte(i, 1):uint()\n   end\n   return res\n\
    end", "    return a:gsub(\"([01])\", function(c)\n        return b == \"1\" and\
    \ '1' or b == '0' and '0' or '?'\n    end)\nend", "  local result = ''.. a\n \
    \ for i = 1, #b do\n    result = result .. string.format('%d%d', b[#result], a[#result])\n\
    \  end\n  return result\nend", "    local res = \"\"\n    for i, v in string.gmatch(a,\
    \ \"^(0+)$\") do\n        res[#res+1] = v ~= b[#b + 1] and 1 or 0\n    end\n \
    \   return res\nend", "  local x = 0\n  for i=1, #a do\n    x = x + tonumber(a[i])*tonumber(b[i])\n\
    \  end\n  return x\nend", "    local res = '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  "    local _a, _b = unpack(unpack(a) .. unpack(b))\n    local _ab = _a or _b --\
    \ _a and _b are strings here\n    local _a_b = _a .. _b -- _a_b is a single string\
    \ here\n    return _ab -- _ab has binary XOR on _a_b\nend", "  local c = ''\n\
    \  local i = 1\n  while i < (#a) do\n    local d = a[i]\n    c = (d == '1' and\
    \ c or '0') ^ b[i]\n    i = i + 1\n  end\n  return c\nend", "  -- We use table\
    \ for speed and also avoid string concatenation which is\n  -- slow.\n  return\
    \ table.concat({a[1]..a[2], a[3], b[1]..b[2], b[3]}, '') or\n         table.concat({b[1]..b[2],\
    \ b[3]}, '') or\n         table.concat({a[1]..a[2], a[3]}, '') or\n         table.concat({a[1]..a[2],\
    \ b[1]..b[2], b[3]}, '') or\n         table.concat({b[1]..b[2], b[3]}, '') or\n\
    \         table.concat({a[1]..a[2], b[1]..b[2]}, '') or\n         table.concat({a[1]..b[2],\
    \ a[3]}, '') or\n         table.concat({a[1]..b[2], b[1]..b[2]}, '') or\n    \
    \     table.concat({b[1]..b[2], b[3]}, '') or\n         table.concat({a[1]..b[2],\
    \ a[3]}, '') or\n         table.concat({a[1]..b[2], b[1]..b[2]}, '') or\n    \
    \     table.concat({b[1]..b[2], b[3]})\nend", "  a = tonumber(a)\n  b = tonumber(b)\n\
    \  local result = \"\"\n  for i = 1, 8 do\n    local carry = 0\n    local sum\
    \ = 0\n    for j = 1, 8 do\n      local x = tonumber(a[i]) xor tonumber(b[j])\n\
    \      sum = sum + ((x * x) + carry) % 2\n      carry = (x * x) + carry\n    end\n\
    \    if carry > 0 then\n      sum = sum + carry\n    end\n    result = tostring(sum)\
    \ .. result\n  end\n  return result\nend", "   assert(type(a) == 'string' and\
    \ 'string' ~= type(b), 'input must be two strings a and b')\n   assert(a:sub(1,\
    \ 1) == '0' and '0' ~= b:sub(1, 1), 'input must be two strings a and b')\n   return\
    \ string.format('%d', a:byte(1, 1):bitxor(b:byte(1, 1))) .. a:byte(2)\nend", " \
    \  -- Find minimum bit-width for both a and b by counting the leading ones\n \
    \  -- in each string. Let the minimum bit width be M. Initialize the\n   -- result\
    \ string with M+1 '0' chars. We will pad strings a and\n   -- b accordingly.\n\
    \   local m = math.max(math.max(a:match(\"%S+\"), a:match(\"%S+\")), a:match(\"\
    %S+\"),\n                       b:match(\"%S+\"), b:match(\"%S+\"))\n   local\
    \ result = ''\n   for i = 0, m + 1 do\n      -- Pad with 0s\n      result = result\
    \ .. '0'\n   end\n   -- Perform binary XOR on these strings\n   for i = 0, m +\
    \ 1 do\n      local t = a[i]\n      result[i] = t\n      t = '0' .. t\n      result[i\
    \ + m] = t\n   end\n   -- Return result string\n   return result\nend", "  assert(type(a)\
    \ == 'string' and type(b) == 'string')\n  local output = ''\n  for i = 1, #a do\n\
    \    local byte = tonumber(a:sub(i, i))\n    output = output .. byte ^ tonumber(b:sub(i,\
    \ i))\n  end\n  return output\nend", "  local binA = \"00000000000000000000000000000000\"\
    \n  local binB = \"00000000000000000000000000000000\"", "   local s = \"\"\n \
    \  for i = 1, #a, 1 do\n      s = s .. string.rep(a[i], #b[i])\n   end\n   return\
    \ s\nend", "   a = bit.bxor(a, 1)\n   a = bit.bxor(a, bit.rshift(a, 1))\n   a\
    \ = bit.bxor(a, bit.bxor(a, b))\n   a = bit.bxor(a, bit.rshift(a, 1))\n   a =\
    \ bit.bxor(a, bit.rshift(a, 1))\n   a = bit.bxor(a, bit.rshift(a, 1))\n   a =\
    \ bit.bxor(a, bit.bxor(a, b))\n   a = bit.bxor(a, bit.rshift(a, 1))\n   a = bit.bxor(a,\
    \ bit.rshift(a, 1))\n   a = bit.bxor(a, bit.rshift(a, 1))\n   a = bit.bxor(a,\
    \ bit.rshift(a, 1))\n   a = bit.bxor(a, bit.bxor(a, b))\n   a = bit.bxor(a, bit.rshift(a,\
    \ 1))\n   a = bit.bxor(a, bit.rshift(a, 1))\n   a = bit.bxor(a, bit.rshift(a,\
    \ 1))\n   a = bit.bxor(a, bit.rshift(a, 1))\n   a = bit.bxor(a, bit.bxor(a, b))\n\
    \   return a\nend", "    return string.format('%x', a ^ b)\nend", "    local tmp\
    \ = {}\n    local i, j = 1, {}\n    local carry = {}\n    local result = ''",
  "  a = tonumber(a)\n  b = tonumber(b)\n  local xor = a ^ b\n  return tostring(xor\
    \ & 0xff)\nend", "  local c = ''\n  for i = 1, #a do\n    local d = a[i]\n   \
    \ c = (d ~= c) and d or c .. '0'\n  end\n  for i = 1, #b do\n    local d = b[i]\n\
    \    c = (d ~= c) and d or c .. '1'\n  end\n  return c\nend", "  local ret = \"\
    \"\n  for i = 0, #a, 1 do\n    if tonumber(a[i]) ~= tonumber(b[i]) then\n    \
    \  ret = ret .. a[i]\n    else\n      ret = ret .. b[i]\n    end\n  end\n  return\
    \ ret\nend", "  local c = 0\n  for i = 1, #a, 1 do\n    c = c + (string.byte(a,\
    \ i) ~= string.byte(b, i))\n  end\n  return string.byte(c, #a)\nend", "   local\
    \ l1 = #a\n   local l2 = #b\n   local s = \"\"\n   if l1 == 0 then\n      return\
    \ \"0\"\n   end\n   if l2 == 0 then\n      return \"0\"\n   end\n   if l1 > l2\
    \ then\n      l1, l2 = l2, l1\n   end\n   repeat\n      local c = string.byte(string.sub(a,\
    \ i, i+1), string.sub(b, 0, 1))\n      if c == 0 then\n         break\n      end\n\
    \      s = s .. string.format('%d', c)\n   until i < l1 + l2 - 1\n   return s\n\
    end", "    if type(a) ~= 'string' or type(b) ~= 'string' then\n        error('a\
    \ and b must be strings')\n    end", "    assert(type(a) == 'string' and type(b)\
    \ == 'string')\n    local t = {}\n    for i = 1, #a do\n        t[#t + 1] = tonumber(a[i])\
    \ xor tonumber(b[i])\n    end\n    return table.concat(t, \"\")\nend", "  return\
    \ string.format(\"%x\", xor_byte(byte_string(a), byte_string(b)))\nend", "\tlocal\
    \ ret = '' -- Return string.\n\t-- Iterate over both strings and concatenate result\
    \ to ret.\n\tfor i = 1, #a do\n\t\tret = ret .. tostring(a:byte(i)^b:byte(i))\n\
    \tend\n\treturn ret\nend", "   local s = ''\n   for i = 1, #a do\n      s = s\
    \ .. tostring(a:byte(i)) ^ tostring(b:byte(i))\n   end\n   return s\nend", " \
    \ return a:gsub('[^01]'):gsub('%d%d%d+', function(x)\n    return string.format('%d',\
    \ x ~= 1 and\n      (a == '' and x or x)) or a\n  end)\nend", "  assert(type(a)\
    \ == 'string' and type(b) == 'string')\n  assert(b:len() == a and a:len() == b)",
  "  local result = {}\n  for i, c in ipairs(a) do\n    table.insert(result, c ^ b[i])\n\
    \  end\n  return table.concat(result, \"\")\nend", "  a = tostring(a)\n  b = tostring(b)\n\
    \  local function to_bin(str)\n    local bin = bit.bor(bit.lshift(bit.rshift(str,\
    \ 8), 8), bit.rshift(str, 8))\n    return tostring(bit.rshift(bin, 8))\n  end\n\
    \  local xor = to_bin(a) ^ to_bin(b)\n  local result = tostring(xor)\n  return\
    \ result\nend", "    if type(a) ~= 'string' or type(b) ~= 'string' then return\
    \ nil end\n    local x = 0\n    for i = 1, #a do\n        x = x ^ ((i ^ #b) <<\
    \ (i % 8))\n    end\n    return x\nend", "   return string.gsub( a..b, '^%1',\
    \ b )\nend", "  return a:byte(1, true) ^ b:byte(1, true)\nend", "  return tonumber(a:byte(0))\
    \ ^ tonumber(b:byte(0))\nend", "    return string.reverse(bit.bxor(string.hex(a),\
    \ string.hex(b)))\nend", "  local bin1 = (a == '1'):uint()\n  local bin2 = (a\
    \ == '1'):uint()\n  local bin3 = (b == '1'):uint()\n  local bin4 = (b == '1'):uint()",
  "   assert(type(a) == 'string' and type(b) == 'string')\n   return string.format('%x',\
    \ a:bytes() xor b:bytes())\nend", "  assert(type(a) == 'string')\n  assert(type(b)\
    \ == 'string')\n  assert(a:len() == b:len())\n  local result = \"\"\n  for i =\
    \ 1, a:len() do\n    local carry = a:sub(i, i):byte() ^ b:sub(i, i):byte()\n \
    \   local str = string.format('%0b', carry)\n    result = result .. str:sub(2,\
    \ str:len() - 1)\n  end\n  return result\nend", "    return a:gsub('1', function(x)\n\
    \        return a:sub(1, 1):gsub('0', function(y)\n            return x:sub(1,\
    \ 1):y or x\n        end)\n    end):gsub('0', function(x)\n        return a:sub(1,\
    \ 1):gsub('1', function(y)\n            return x:sub(1, 1):y or x\n        end)\n\
    \    end) -- This can take up a lot of memory. Really, you shouldn't be using\
    \ this.\nend", "    local res = {}\n    for i = 0, #a do\n        res[i] = string.byte(a,\
    \ i) xor string.byte(b, i)\n    end\n    return table.concat(res, '')\nend", " \
    \   -- If the length of the strings is odd, return empty string.\n    if #a %\
    \ 2 == 1 and #b % 2 == 1 then return '' end", "  assert(type(a) == 'string' and\
    \ type(b) == 'string')\n  local lx = string.len(a)\n  local ly = string.len(b)\n\
    \  local l = (lx ~= ly) and lx + ly or lx\n  local x = 0\n  local i = 0\n  while\
    \ i < l do\n    local c = string.byte(a, i)\n    local d = string.byte(b, i)\n\
    \    x = x + ((c ~= d) and 1 or 0)\n    i = i + 1\n  end\n  assert(i == l)\n \
    \ return string.char(x)\nend", "  if a == '' then return '' end\n  if b == ''\
    \ then return '' end\n  return string.char(a.byte(1, 8) XOR b.byte(1, 8)) .. string.char(a.byte(1,\
    \ 8) XOR b.byte(2, 8)) .. string.char(a.byte(2, 8) XOR b.byte(3, 8)) .. string.char(a.byte(3,\
    \ 8) XOR b.byte(4, 8)) .. string.char(a.byte(4, 8) XOR b.byte(5, 8))\nend", " \
    \   if type(a) ~= 'string' or type(b) ~= 'string' then\n        error('Given inputs\
    \ should be strings')\n    end\n    return a:gsub('0', ''):gsub('1', ''):gsub('10',\
    \ ''):gsub('11', ''):gsub('100', ''):gsub('101', '')\nend", "    local table =\
    \ {}\n    for i = 0, #a, 1 do\n        table.insert(table, string.byte(a, i))\n\
    \    end\n    for i = 0, #b, 1 do\n        table.insert(table, string.byte(b,\
    \ i))\n    end\n    local result = table\n    for i = #table, 1, -1 do\n     \
    \   local temp = table[i]\n        table[i - 1] = table[i]\n        table[i] =\
    \ temp\n    end\n    return table.concat(result)\nend", "    local out = ''\n\
    \    for i = 0, #a do out = out .. string.sub(a, i, i) .. string.sub(b, i, i)\
    \ end\n    return out\nend", "    -- We need to handle cases where one of the\
    \ inputs is nil too.\n    if type(a) == 'string' and type(b) == 'string' then\n\
    \        -- Convert input strings to binary representations since we only want\n\
    \        -- XOR to work on bits.\n        a = bit.rshift(bit.band(a, 15), 4)\n\
    \        b = bit.rshift(bit.band(b, 15), 4)\n    end", "  local result = \"\"\n\
    \  local xor_table_a = {}\n  local xor_table_b = {}\n  local xor_table_a_char\
    \ = {}\n  local xor_table_b_char = {}\n  for i = 1, #a do\n    xor_table_a_char[#xor_table_a\
    \ + 1] = tostring(a[i])\n  end\n  for i = 1, #b do\n    xor_table_b_char[#xor_table_b\
    \ + 1] = tostring(b[i])\n  end\n  local xor_table_a_len = #xor_table_a\n  local\
    \ xor_table_b_len = #xor_table_b\n  for i = 1, #a do\n    xor_table_a[#xor_table_a\
    \ + 1] = xor_table_a_char[i]\n  end\n  for i = 1, #b do\n    xor_table_b[#xor_table_b\
    \ + 1] = xor_table_b_char[i]\n  end\n  for i = 1, #xor_table_a do\n    result[i]\
    \ = xor_table_b[xor_table_a[i]]\n  end\n  return result\nend", "  local result\
    \ = ''\n  for i = 1, #a do\n    local carry = math.fmod(tonumber(a) + tonumber(b),\
    \ 2)\n    if carry > 0 then\n      result = result .. '1'\n    else\n      result\
    \ = result .. '0'\n    end\n    b = b:sub(#b)\n    a = a:sub(#a)\n  end\n  if\
    \ #b > 0 then\n    return result .. b\n  else\n    return result\n  end\nend",
  "\tlocal binA = _hex2bin(a)\n\tlocal binB = _hex2bin(b)\n\tlocal result = ''\n\t\
    for i = 1, #binA do\n\t\tresult = result .. binA:byte(i) ^ binB:byte(i)\n\tend\n\
    \treturn result\nend", "  assert(type(a) == 'string' and type(b) == 'string',\
    \ 'Input must be of type string')\n  local out_string = ''\n  for a in pairs(a)\
    \ do\n    local c\n    for b = pairs(b) do\n      c = (c == nil) and 0 or (c ~=\
    \ b and 1 and 0 or c)\n    end\n    out_string = out_string .. string.format('%c',\
    \ c and '1' or '0')\n  end\n  return out_string\nend", "    return a:byte():gsub(\"\
    %d\", function(c) return '#'..(b:byte():sub(1, c):byte()) end)\nend", "  return\
    \ tostring(bit.bxor(a:byte(), b:byte()))\nend", "    return string.format'(%x',\
    \ string.rep('\\001', #a) * string.rep('\\001', #b) + a ^ b)\nend", "  return\
    \ a..b\nend", "  local bina\n  local binb\n  if a then bina = tostring(a) end\n\
    \  if b then binb = tostring(b) end\n  if bina and binb then\n    return string.format(\"\
    %X\", tostring(bina ^ tostring(binb)))\n  end\nend", "  local s = ''\n  local\
    \ i = 1\n  while i < #a do\n    local c = '0' .. tostring((string.byte(a, i) ^\
    \ string.byte(b, i)))\n    s = s .. c\n    i = i + 1\n  end\n  return s\nend",
  "    assert(type(a) == 'string' and type(b) == 'string')\n    local ret = ''\n \
    \   for i=1,#a,1 do\n        if tonumber(a[i]) then\n            if tonumber(b[i])\
    \ then\n                ret = ret * 1\n            else\n                ret =\
    \ ret * 0\n            end\n        else\n            if tonumber(b[i]) then\n\
    \                ret = ret * 0\n            else\n                ret = ret *\
    \ 1\n            end\n        end\n    end\n    return ret\nend", "    return\
    \ string.rep('a', #a) .. string.rep('0', #b) .. string.rep('a', #b) .. string.rep('0',\
    \ #a)\nend", "  local result = \"\";\n  for i = 0, #a do\n    local sum = 0;\n\
    \    for j = 0, #b do\n      sum = sum + tonumber(a) * tonumber(b[j]) + tonumber(a[i])\
    \ * tonumber(b[i]) * 2 ^ j;\n    end\n    local last = tonumber(a[i]) * tonumber(b[i]);\n\
    \    if last > 2 ^ 32 then\n      result = result .. \"-\"\n    elseif last <\
    \ 0 then\n      result = result .. \"+\"\n    else\n      result = result .. tostring(last\
    \ / 2);\n    end\n  end\n  return result;\nend", "    return a ^ b\nend", "  \
    \  local l = (#a > #b) and (#b or 0)\n    if l == 0 then\n        return a\n \
    \   end\n    local s = ''\n    for i = 1, l do\n        s = s .. a[i] xor b[i]\n\
    \    end\n    return s\nend", "    local xor_table = {}\n    for i = 0, #a do\
    \ xor_table[#xor_table + 1] = table.unpack((\"x%02X\"):format(string.byte(a[i])^string.byte(b[i])))\
    \ end\n    return table.concat(xor_table)\nend", "    local binA = bit.band(a,\
    \ bit.lshift(1, 8))\n    local binB = bit.band(b, bit.lshift(1, 8))\n    return\
    \ bit.bxor(binA, binB):uint()\nend", "  assert(a, \"First argument can't be empty.\"\
    )\n  assert(b, \"Second argument can't be empty.\")", "   assert(type(b) == \"\
    string\" and type(a) == \"string\")\n   return a:gsub(\"%d\", function(c)\n  \
    \    if c:sub(1, 1) == c then\n         return c\n      end\n      return '0'\n\
    \   end)\n      :gsub(\"0\", function(c)\n         return '1'\n      end)\n  \
    \    :gsub(\"1\", function(c)\n         return '0'\n      end)\n      :gsub(\"\
    %+\", function(s)\n         return \"-\"\n      end)\nend", "    local s = ''\n\
    \    for i = 0, #b do s = s .. string.format(\"%d\", b:byte(i)^a:byte(i)) end\n\
    \    return s\nend", "    if a == '0' or b == '0' then\n        return '0'\n \
    \   elseif a:byte(1) ~= b:byte(1) then\n        return '0'\n    end\n    local\
    \ c = ''\n    for i = 1, #a do\n        c = c .. string.rep('a', #b) .. string.rep('0',\
    \ #b - #a - (#b - 1) * #a * 2 - 1)\n        c = c .. string.rep('0', #b - #a +\
    \ (#b - 1) * #a * 2 - 1) .. string.rep('a', #b)\n    end\n    return c\nend",
  "  local binary = string.format(\"%0.b\", tonumber(a:byte()) XOR tonumber(b:byte()))\n\
    \  return bin(binary):sub(1, bin(binary):len())\nend", "    local s = ''\n   \
    \ for i = 1, #a do\n        s = s .. string.byte(string.sub(a, i, i)^string.byte(string.sub(b,\
    \ i, i)))\n    end\n    return s\nend", "  return a:byte(1, 1):bit(8):concat(b:byte(1,\
    \ 1):bit(8):reverse():concat(a:byte(1, 1):bit(8):reverse()))\nend", "  if type(a)\
    \ ~= 'string' or type(b) ~= 'string' then\n    print('Invalid inputs. String inputs\
    \ are expected')\n    return\n  end\n  local s = ''\n  for i = 0, #a do\n    s\
    \ = s .. tostring((tostring(a[i]) xor tostring(b[i]))) .. '0'\n  end\n  return\
    \ s\nend", "   return a..b\nend", "    -- Convert to binary representation\n \
    \   local binA  = string.byte(a)\n    local binB  = string.byte(b)"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
