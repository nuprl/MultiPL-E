name: HumanEval_21_rescale_to_unit
language: lua
prompt: "-- Given table of numbers (of at least two elements), apply a linear transform\
  \ to that table,\n-- such that the smallest number will become 0 and the largest\
  \ will become 1\n-- >>> rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0})\n-- {0.0, 0.25,\
  \ 0.5, 0.75, 1.0}\nlocal function rescale_to_unit(numbers)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rescale_to_unit\n\
  \    lu.assertEquals(candidate({2.0, 49.9}), {0.0, 1.0})\n    lu.assertEquals(candidate({100.0,\
  \ 49.9}), {1.0, 0.0})\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}),\
  \ {0.0, 0.25, 0.5, 0.75, 1.0})\n    lu.assertEquals(candidate({2.0, 1.0, 5.0, 3.0,\
  \ 4.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\n    lu.assertEquals(candidate({12.0, 11.0,\
  \ 15.0, 13.0, 14.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local min = numbers[1]\n  local max = numbers[#numbers]\n  for i\
    \ = 1, #numbers do\n    numbers[i] = ((numbers[i] - min) / (max - min)) * (max\
    \ - min)\n  end\n  return numbers\nend", "  assert(#numbers > 1)\n  local minValue\
    \ = min(numbers)\n  local maxValue = max(numbers)\n  local diffValue = maxValue\
    \ - minValue\n  assert(diffValue ~= 0)\n  if diffValue == 0 then\n    return numbers\n\
    \  end\n  -- Get minimum value in interval (0, 1), and scale all others by this\
    \ amount.\n  local scaledNumbers = {}\n  for i = 1, #numbers do\n    scaledNumbers[#scaledNumbers+1]\
    \ = minValue + (numbers[i] - minValue) / diffValue\n  end\n  return scaledNumbers\n\
    end", "  -- This works on table of any number of elements, where each element\
    \ is a number.\n  -- It will also work for tables of one element, where it will\
    \ return a table\n  -- of that one element. The input table must always contain\
    \ at least 2 elements.\n  assert(#numbers >= 2, \"rescale_to_unit: input table\
    \ must have at least 2 elements\")", "  assert(#numbers >= 2)\n  local minv, maxv\
    \ = table.min(numbers), table.max(numbers)\n  local diff = maxv - minv\n  if diff\
    \ == 0 then return numbers end\n  local scale = 1 / (diff / 2)\n  local ret =\
    \ {}\n  for i = 1, #numbers do\n    ret[i] = numbers[i] * scale\n  end\n  return\
    \ ret\nend", "  if #numbers < 2 then\n    return {0.0, 1.0}\n  end", "    local\
    \ smallest, largest = table.min(numbers), table.max(numbers)\n    local range\
    \ = largest-smallest\n    return numbers-smallest+((numbers-largest)/range)\n\
    end", "    local minNum = math.min(numbers)\n    local maxNum = math.max(numbers)\n\
    \    -- If the smallest number happens to be 0, just return the largest number\n\
    \    if minNum == 0 then\n        return maxNum\n    end\n    local unitNum =\
    \ (maxNum - minNum) / (#numbers - 1)\n    -- Return the smallest number if all\
    \ numbers are 0\n    if minNum == maxNum then\n        return minNum\n    end\n\
    \    -- Divide all the numbers by unitNum\n    for i = 1, #numbers do\n      \
    \  numbers[i] = numbers[i] / unitNum\n    end\n    return numbers\nend", "  local\
    \ min = math.min(numbers)\n  local max = math.max(numbers)\n  local results =\
    \ {}\n  for i=1,#numbers do\n    local value = numbers[i]\n    local range = max\
    \ - min\n    local scaled_value = ((value - min) / range) * 100\n    table.insert(results,\
    \ scaled_value)\n  end\n  return results\nend", "  if #numbers < 2 then\n    return\
    \ numbers\n  end", "    local minV = math.min(numbers)\n    local maxV = math.max(numbers)\n\
    \    local scaled = {}\n    for i = 1, #numbers do\n        scaled[i] = (numbers[i]\
    \ - minV) / (maxV - minV)\n    end\n    return scaled\nend", "    local function\
    \ rescale(number)\n        if number < 1.0 then\n            local new_min = math.floor(number)\n\
    \            local new_max = math.ceil(number)\n            number = (new_max\
    \ - new_min) / 2.0 + new_min\n        end\n        return number\n    end\n  \
    \  local min_number = numbers[1]\n    local max_number = numbers[#numbers]\n \
    \   local result = {}\n    for i, number in pairs(numbers) do\n        result[i]\
    \ = rescale(number)\n    end\n    return result\nend", "  if #numbers < 2 then\
    \ return numbers end\n  local min = numbers[1]\n  local max = numbers[#numbers]\n\
    \  local scaled = { }\n  for i=1,#numbers do\n    scaled[i] = (numbers[i] - min)\
    \ / (max - min)\n  end\n  return scaled\nend", "  assert(#numbers > 1)\n  local\
    \ min = numbers[1]\n  local max = numbers[#numbers]", "  assert(#numbers >= 2,\
    \ 'rescale_to_unit called with table of length less than 2')\n  local minimum\
    \ = numbers[1]\n  local maximum = numbers[1]\n  local scale\n  for _, number in\
    \ pairs(numbers) do\n    if minimum > number then\n      minimum = number\n  \
    \  end\n    if maximum < number then\n      maximum = number\n    end\n  end\n\
    \  scale = maximum - minimum\n  local new_numbers = {}\n  for _, number in pairs(numbers)\
    \ do\n    new_numbers[number-minimum] = number\n  end\n  new_numbers[1] = minimum\n\
    \  return new_numbers, scale\nend", "   local min = numbers.min or numbers[1]\n\
    \   local max = numbers.max or numbers[#numbers]", "  if #numbers == 1 then\n\
    \    return {numbers[1]}\n  else\n    local scale_factor = math.min(numbers[1],\
    \ numbers[#numbers])\n    local new_numbers = numbers[#numbers]\n    for i = #numbers,\
    \ 2, -1 do\n      new_numbers[i] = numbers[i-1] / scale_factor\n    end\n    return\
    \ new_numbers\n  end\nend", "\tlocal min = 0\n\tlocal max = numbers[1]\n\tfor\
    \ i = 2, #numbers do\n\t\tif numbers[i] < min then\n\t\t\tmin = numbers[i]\n\t\
    \tend\n\t\tif numbers[i] > max then\n\t\t\tmax = numbers[i]\n\t\tend\n\tend\n\t\
    return {min, 0, (max - min)/#numbers, 1}\nend", "  local min = table.remove(numbers,\
    \ 1)\n  local max = table.remove(numbers, 1)\n  local rescale = 1\n  for i = 1,\
    \ #numbers do\n    local n = numbers[i]\n    if n < min then\n      min = n\n\
    \    end\n    if n > max then\n      max = n\n    end\n    rescale = rescale*(n-min)/(max-min)\n\
    \  end\n  local rescaled_numbers = {}\n  for i = 1, #numbers do\n    rescaled_numbers[i]\
    \ = min + (numbers[i] - min)*rescale\n  end\n  return rescaled_numbers\nend",
  "  local min = numbers.[1]\n  local max = numbers.[#numbers]", "    assert(#numbers\
    \ >= 2)\n    local first_number = numbers[1]\n    for i = 2, #numbers do\n   \
    \     numbers[i] = (numbers[i] - first_number) / (numbers[i-1] - first_number)\n\
    \    end\n    return numbers\nend", "  local function rescale(number)\n    return\
    \ (number - min(number)) / (max(number) - min(number))\n  end", "  local min =\
    \ math.min(numbers)\n  local max = math.max(numbers)", "  local min = table.min(numbers)\n\
    \  local max = table.max(numbers)\n  local delta = (max - min) / #numbers\n  local\
    \ scaled = {}\n  for i = 1, #numbers do\n    scaled[i] = min + delta * i\n  end\n\
    \  return scaled\nend", "  local min = numbers[1]\n  local max = numbers[1]\n\
    \  if #numbers > 1 then\n    for i = 2, #numbers do\n      min = math.min(min,\
    \ numbers[i])\n      max = math.max(max, numbers[i])\n    end\n  end\n  return\
    \ numbers:map(function (number) return number / (max - min) end)\nend", "   local\
    \ min = table.remove(numbers, 1)\n   local max = table.remove(numbers, 1)", " \
    \ local min_number = math.min(numbers)\n  local max_number = math.max(numbers)\n\
    \  if min_number == max_number then\n    return numbers\n  end", '   if #numbers
    < 2 then return numbers end', "    local min_value = min(numbers)\n    local max_value\
    \ = max(numbers)", "    local min = table.remove(numbers, 1)\n    local max =\
    \ table.remove(numbers)\n    local new_numbers = {}\n    for _, value in ipairs(numbers)\
    \ do\n        new_numbers[_] = ((value - min) / (max - min)) + (min / 2)\n   \
    \ end\n    return new_numbers\nend", "  -- if numbers is empty return the empty\
    \ set\n  if next(numbers) == nil then\n    return {}\n  end\n  local max = -1e9\n\
    \  local min = 1e9\n  -- Go through the numbers\n  for i = 1, next(numbers) do\n\
    \    -- If the number is bigger than the maximum so far, save the new max and\
    \ set it as the new max\n    if numbers[i] > max then\n      max = numbers[i]\n\
    \    end\n    -- If the number is smaller than the minimum so far, save the new\
    \ min and set it as the new min\n    if numbers[i] < min then\n      min = numbers[i]\n\
    \    end\n  end\n  -- If the min and max are the same, just return those numbers\n\
    \  if min == max then\n    return numbers\n  end\n  -- If min is greater than\
    \ max, return the set of numbers sorted by the given function\n  if min > max\
    \ then\n    -- If the given function is zero, just return the given set of numbers\n\
    \    if eq then\n      return numbers\n    end\n    -- Otherwise, return a sorted\
    \ copy of the given set of numbers with numbers normalized to the range 0 - 1\n\
    \    return table.sort(numbers, function(a, b)\n      return eq(b) ? (a - min)\
    \ / (max - min) : (b - min) / (max - min)\n    end)\n  end\n  -- If max is greater\
    \ than min, return the set of numbers sorted by the given function\n  if max >\
    \ min then\n    -- If the given function is zero, just return the given set of\
    \ numbers\n    if eq then\n      return numbers\n    end\n    -- Otherwise, return\
    \ a sorted copy of the given set of numbers with numbers normalized to the range\
    \ 0 - 1\n    return table.sort(numbers, function(a, b)\n      return eq(b) ? (b\
    \ - max) / (max - min) : (b - min) / (max - min)\n    end)\n  end\n  -- If min\
    \ and max are equal, return the set of numbers sorted by the given function\n\
    \  if eq then\n    return numbers\n  end\n  -- Otherwise, return a sorted copy\
    \ of the given set of numbers with numbers normalized to the range 0 - 1\n  return\
    \ table.sort(numbers, function(a, b)\n    return a <= b ? (a - min) / (max - min)\
    \ : (b - min) / (max - min)\n  end)\nend", "  local min = table.minimum(numbers)\n\
    \  local max = table.maximum(numbers)\n  local scale = (max - min) / (table.count(numbers)\
    \ - 1)\n  for i = 1, table.count(numbers) do\n    numbers[i] = ((numbers[i] -\
    \ min) * scale) + min\n  end\n  return numbers\nend", "  local min_number = math.min(numbers)\n\
    \  local max_number = math.max(numbers)\n  assert(min_number <= max_number)",
  "  assert(#numbers >= 2)\n  local min_val = numbers[1]\n  local max_val = numbers[#numbers]\n\
    \  local scale = (max_val - min_val) / (#numbers - 1)\n  -- If the largest number\
    \ is greater than 1, add 0.5 to make it equal to 1\n  if max_val > 1 then\n  \
    \  max_val = max_val + 0.5\n  else\n    max_val = max_val\n  end\n  -- If the\
    \ smallest number is less than 0, subtract 0.5 from it\n  if min_val < 0 then\n\
    \    min_val = min_val - 0.5\n  else\n    min_val = min_val\n  end\n  -- Build\
    \ a new table\n  local rescaled_numbers = {}\n  for i = 0, #numbers - 1 do\n \
    \   rescaled_numbers[i] = min_val + (numbers[i + 1] - min_val) * scale\n  end\n\
    \  return rescaled_numbers\nend", "  assert(#numbers > 0, 'Table of numbers is\
    \ empty!')\n  assert(#numbers >= 2, 'Table of numbers has less than two elements!')\n\
    \  -- Get minimum and maximum number in the list\n  local min = numbers[1]\n \
    \ local max = numbers[1]\n  for i = 2, #numbers do\n    min = math.min(min, numbers[i])\n\
    \    max = math.max(max, numbers[i])\n  end\n  -- Create a list of normalized\
    \ numbers\n  local normalized_numbers = {}\n  for i = 1, #numbers do\n    normalized_numbers[i]\
    \ = min + (max - min) * (i / #numbers)\n  end\n  return normalized_numbers\nend",
  "    local new_max = math.max(numbers)\n    local new_min = math.min(numbers)\n\
    \    local new_scale = (new_max - new_min) / 2.0\n    return { new_min, new_max,\
    \ new_scale }\nend", "    local min_value = math.min(numbers)\n    local max_value\
    \ = math.max(numbers)\n    local range = max_value - min_value\n    local scaled_numbers\
    \ = {}\n    for i = 1, #numbers do\n        scaled_numbers[i] = min_value + (numbers[i]\
    \ - min_value) / range\n    end\n    return scaled_numbers\nend", "  -- This should\
    \ have been obvious, but we'll check anyway\n  if #numbers < 2 then return numbers\
    \ end\n  if #numbers == 1 then return {numbers[1]} end\n  local min = numbers[1]\n\
    \  local max = numbers[#numbers]\n  local delta = max - min\n  if delta == 0 then\n\
    \    local half = math.floor(#numbers / 2)\n    local new_min = min + (half)\n\
    \    local new_max = min + (half) + 1\n    -- Make sure the new bounds are acceptable\n\
    \    -- TODO: is this a bug that we hit here?\n    if new_min < numbers[1] then\
    \ return numbers end\n    if new_max > numbers[#numbers] then return numbers end\n\
    \    min = new_min\n    max = new_max\n  end\n  local new_numbers = {}\n  local\
    \ old_numbers = numbers\n  for i = 1, #old_numbers do\n    local old_number =\
    \ old_numbers[i]\n    local new_number = old_number - min / delta * delta\n  \
    \  new_numbers[i] = new_number\n  end\n  return new_numbers\nend", "  local min\
    \ = numbers[1]\n  local max = numbers[#numbers]", "  assert(#numbers > 0, \"The\
    \ table to rescale to must have at least one element.\")\n  local smallest = tonumber(table.sort(numbers)[1])\n\
    \  local largest = tonumber(table.sort(table.reverse(numbers))[#numbers][2])\n\
    \  local length = #numbers\n  local scaling_factor = 1\n  if smallest < largest\
    \ then\n    scaling_factor = largest / smallest\n  end\n  for i = 2, length do\n\
    \    numbers[i] = numbers[i] / scaling_factor\n  end\n  return numbers\nend",
  "    local minNumber = math.min(unpack(numbers))\n    local maxNumber = math.max(unpack(numbers))\n\
    \    local results = {}\n    for number = minNumber, maxNumber do\n        local\
    \ i = 1\n        while i * i < number do\n            i = i + 1\n        end\n\
    \        results[#results+1] = number / i\n    end\n    return results\nend",
  "    -- If there are no numbers in the table (empty or only one number), return\
    \ an empty table\n    if not numbers or numbers[1] == nil then\n        return\
    \ {{}}\n    end\n    -- The smallest number will always have a value of 0\n  \
    \  numbers[1] = 0\n    -- The largest number will always have a value of 1\n \
    \   numbers[#numbers + 1] = 1\n    -- Calculate the difference between the first\
    \ and last element\n    local diff = numbers[#numbers]-numbers[1]\n    -- Calculate\
    \ the new smallest and largest number\n    local new_numbers = {}\n    new_numbers[1]\
    \ = numbers[1] + diff / 2\n    for i = 2, #numbers do\n        new_numbers[i]\
    \ = new_numbers[i-1] + diff * (numbers[i] - new_numbers[i-1])\n    end\n    return\
    \ new_numbers\nend", "  local min = table.min(numbers)\n  local max = table.max(numbers)\n\
    \  local scale = (max - min) / #numbers\n  for _, value in ipairs(numbers) do\n\
    \    value = ((value - min) / scale) + 0.5\n  end\n  return numbers\nend", " \
    \ -- Return an equivalent table with the smallest number set at 0\n  -- and the\
    \ largest number set at 1\n  local result = {}\n  local minval = 0\n  local maxval\
    \ = 0\n  for _, val in ipairs(numbers) do\n    minval = val < minval and 0 or\
    \ minval\n    maxval = val > maxval and 1 or maxval\n    result[#result + 1] =\
    \ val\n  end\n  result[1] = minval\n  result[#result + 1] = maxval\n  return result\n\
    end", "  if #numbers < 2 then return numbers end\n  local sum, min, max = 0.0,\
    \ numbers[1], numbers[1]\n  for i = 2, #numbers do\n    sum = sum + numbers[i]\n\
    \    if numbers[i] < min then min = numbers[i] end\n    if numbers[i] > max then\
    \ max = numbers[i] end\n  end\n  return min, max, sum\nend", "  assert(#numbers\
    \ >= 2, \"numbers must be of at least two elements\")\n  local min = tonumber(numbers[1])\
    \ or numbers[1]\n  local max = tonumber(numbers[#numbers]) or numbers[#numbers]\n\
    \  local sum = 0\n  for i = 1, #numbers do\n    sum = sum + numbers[i]\n  end\n\
    \  local new_sum = 0\n  for i = 1, #numbers do\n    new_sum = new_sum + numbers[i]\n\
    \  end\n  return new_sum / sum * (max - min) + min\nend", "    local min = math.min(numbers)\n\
    \    local max = math.max(numbers)\n    return numbers:map(function(x)\n     \
    \   return x / max - min\n    end)\nend", "    local minimum, maximum = unpack(numbers)\n\
    \    local min_size = minimum == nil and 1 or #minimum\n    local max_size = maximum\
    \ == nil and 1 or #maximum\n    local scaled_size = max_size - min_size\n    local\
    \ new_minimum = minimum + scaled_size * 0.1\n    local new_maximum = maximum +\
    \ scaled_size * 0.1\n    return new_minimum, new_maximum\nend", "  local min =\
    \ 0\n  local max = numbers[1]\n  for _, v in pairs(numbers) do\n    min = math.min(min,\
    \ v)\n    max = math.max(max, v)\n  end\n  local delta = max - min\n  min = -min\n\
    \  max = 1\n  local output = {}\n  for _, v in pairs(numbers) do\n    output[min+v*delta]\
    \ = v\n  end\n  return output\nend", "  local min = math.min(unpack(numbers))\n\
    \  local max = math.max(unpack(numbers))\n  if min == max then -- this can happen\
    \ if numbers is empty.\n    return {}\n  end\n  local factor = (max - min) / #numbers\n\
    \  local rescaled = {}\n  for _, number in ipairs(numbers) do\n    rescaled[#rescaled\
    \ + 1] = number * factor\n  end\n  return rescaled\nend", "   local min = table.min(numbers)\n\
    \   local max = table.max(numbers)\n   local range = max - min\n   assert(min\
    \ >= 0 and max > 0 and range > 0, \"rescale_to_unit - invalid input. min \" ..\
    \ min .. \" max \" .. max .. \" range \" .. range)\n   local scale_min = min /\
    \ range\n   local scale_max = 1 - (min / range)\n   for i = 1, #numbers do\n \
    \     numbers[i] = numbers[i] * scale_max\n   end\n   return numbers\nend", " \
    \ assert(#numbers >= 2, \"rescale_to_unit() expects table with at least two elements\"\
    )\n  assert(all(numbers[1] == numbers[#numbers]), \"rescale_to_unit() expects\
    \ table with numbers of the same magnitude\")\n  local smallest = numbers[1]\n\
    \  local largest = numbers[1]\n  for i = 2, #numbers do\n    smallest = smallest\
    \ > numbers[i] and smallest or numbers[i]\n    largest = largest < numbers[i]\
    \ and largest or numbers[i]\n  end\n  return { smallest / largest, largest / smallest\
    \ }\nend", "    if #numbers < 2 then return numbers end\n    local min = numbers[1]\n\
    \    local max = numbers[#numbers]\n    local scaled = table.repeat(min, #numbers)\n\
    \    for i = 2, #numbers do\n        scaled[i] = (numbers[i] - min) / (max - min)\n\
    \    end\n    return scaled\nend", "  local min, max = table.min(numbers), table.max(numbers)\n\
    \  local new_numbers = {}\n  for i = 1, #numbers do\n    new_numbers[i] = (((numbers[i]\
    \ - min) / (max - min)) - 0.5) * 2 + 0.5\n  end\n  return new_numbers\nend", " \
    \   if #numbers == 0 then\n        return {0, 1}\n    end", "  if #numbers < 2\
    \ then return {} end\n  local min = numbers[1]\n  local max = numbers[2]\n  local\
    \ range = (max - min) / (#numbers - 1)\n  local rescaled = {}\n  local i = 1\n\
    \  for i = 1, #numbers do\n    rescaled[i] = min + range * (numbers[i] - min)\n\
    \  end\n  return rescaled\nend", "  if #numbers < 2 then\n    error(\"Given table\
    \ is too small\")\n  end", "  local minElement = numbers[1]\n  local maxElement\
    \ = numbers[#numbers]", "  assert(#numbers >= 2)\n  local min = table.min(numbers)\n\
    \  local max = table.max(numbers)\n  local scale = 1.0 / max\n  local new_numbers\
    \ = {}\n  for i = 1, #numbers do\n    table.insert(new_numbers, numbers[i] * scale)\n\
    \  end\n  return new_numbers\nend", "  local minimum = #numbers > 0 and numbers[1]\
    \ or 1\n  local maximum = #numbers > 0 and numbers[#numbers] or 1\n  local delta\
    \ = (maximum - minimum)\n  local scale = (maximum + minimum - 1) / 2", "  if #numbers\
    \ < 2 then\n    return {}\n  end\n  local min_number = math.min(numbers)\n  local\
    \ max_number = math.max(numbers)\n  local length = #numbers\n  local scale = (max_number\
    \ - min_number) / (length - 1)\n  local results = {}\n  for i = 1, length do\n\
    \    results[#results + 1] = min_number + (numbers[i] - min_number) * scale\n\
    \  end\n  return results\nend", "  if #numbers < 2 then\n    return {}\n  end",
  "    -- No numbers: no rescaling is needed\n    if not numbers or #numbers < 2 then\n\
    \        return numbers", "  local largest = math.max(numbers)\n  local smallest\
    \ = math.min(numbers)", "  local min = table.min(numbers)\n  local max = table.max(numbers)",
  "  assert(#numbers >= 2, \"Rescaling by less than 2 elements is unsupported\")\n\
    \  local min_value = tonumber(numbers[1])\n  local max_value = tonumber(numbers[#numbers])\n\
    \  assert(min_value <= max_value, \"Min value is greater than max value\")", " \
    \ assert(#numbers > 1)\n  local minimum = numbers[1]\n  local maximum = numbers[#numbers]\n\
    \  local scaled_numbers = {}\n  assert(minimum > 0)\n  assert(maximum > 0)\n \
    \ assert(minimum < maximum)\n  local factor = 1 / (maximum - minimum)\n  for _,\
    \ number in ipairs(numbers) do\n    scaled_numbers[#scaled_numbers + 1] = (number\
    \ - minimum) * factor\n  end\n  return scaled_numbers\nend", "    local minimum\
    \ = math.min(numbers)\n    local maximum = math.max(numbers)\n    local minimum_index\
    \ = nil\n    local maximum_index = nil\n    for i, x in ipairs(numbers) do\n \
    \       if minimum_index == nil then\n            minimum_index = i\n        \
    \    minimum = x\n        elseif minimum == x then\n            minimum_index\
    \ = i\n        end\n        if maximum_index == nil then\n            maximum_index\
    \ = i\n            maximum = x\n        elseif maximum == x then\n           \
    \ maximum_index = i\n        end\n    end", '    local minimum, maximum = unpack(numbers)',
  "  assert(#numbers >= 2, \"Must have at least two numbers\")\n  local min_num =\
    \ min(numbers)\n  local max_num = max(numbers)\n  local factor = 1.0\n  if min_num\
    \ == 0.0 then\n    factor = 0.0\n  else\n    if min_num == max_num then\n    \
    \  factor = min_num\n    else\n      factor = max_num / min_num\n    end\n  end\n\
    \  local new_numbers = {}\n  for i = 1, #numbers do\n    new_numbers[i] = numbers[i]\
    \ * factor\n  end\n  return new_numbers\nend", "  if #numbers < 2 then return\
    \ {} end\n  local min = numbers[1]\n  local max = numbers[#numbers]\n  local offset\
    \ = min - max\n  local n = #numbers\n  local results = {}\n  local rescaled =\
    \ min + (max-min)/2\n  if offset < 0 then\n    local last_rescaled = rescaled\n\
    \    local last_offset = offset\n    while true do\n      local next_rescaled\
    \ = rescaled + offset\n      local next_offset = offset - last_offset\n      local\
    \ next_max = numbers[math.round(next_rescaled)]\n      if next_offset > 0 then\n\
    \        rescaled = next_rescaled\n        offset = next_offset\n      else\n\
    \        local next_min = numbers[math.round(next_rescaled-1)]\n        results[#results+1]\
    \ = next_min\n        if next_min < next_rescaled then\n          rescaled = next_rescaled\n\
    \          offset = next_offset\n        else\n          break\n        end\n\
    \      end\n      last_rescaled = next_rescaled\n      last_offset = next_offset\n\
    \    end\n  else\n    while true do\n      local next_rescaled = rescaled - offset\n\
    \      local next_offset = offset + last_offset\n      local next_min = numbers[math.round(next_rescaled)]\n\
    \      if next_offset < 0 then\n        rescaled = next_rescaled\n        offset\
    \ = next_offset\n      else\n        local next_max = numbers[math.round(next_rescaled+1)]\n\
    \        results[#results+1] = next_max\n        if next_max > next_rescaled then\n\
    \          rescaled = next_rescaled\n          offset = next_offset\n        else\n\
    \          break\n        end\n      end\n      last_rescaled = next_rescaled\n\
    \      last_offset = next_offset\n    end\n  end\n  return results\nend", "  local\
    \ smallest_num = numbers.[1]\n  local largest = numbers.[2]\n  local length =\
    \ #numbers\n  for i = 2, length do\n    smallest_num = math.min(smallest_num,\
    \ numbers[i])\n    largest = math.max(largest, numbers[i])\n  end\n  if smallest\
    \ == 0 then smallest_num = 1 end\n  return { smallest_num, largest }\nend", " \
    \ local min = table.min(numbers)\n  local max = table.max(numbers)", "   local\
    \ min, max = table.min(numbers), table.max(numbers)\n   local new_min, new_max\
    \ = (min and min * 0.0), (max and max * 1.0)\n   return (numbers - new_min) /\
    \ (new_max - new_min)\nend", "  local min = math.min(numbers)\n  local max = math.max(numbers)\n\
    \  local scaled = {}\n  local i = 1\n  for _, v in pairs(numbers) do\n    scaled[i]\
    \ = (v - min) / (max - min)\n    i = i + 1\n  end\n  return scaled\nend", "  if\
    \ #numbers < 2 then return end\n  if #numbers == 2 then\n    return {0, numbers[1]\
    \ / numbers[2]}\n  end\n  local min_num = math.min(numbers)\n  local max_num =\
    \ math.max(numbers)\n  if max_num - min_num == 1 then\n    return {}\n  end\n\
    \  local n = numbers[1] / min_num\n  return { 0, min_num + n * numbers[#numbers]\
    \ }\nend", "  if #numbers < 2 then\n    return numbers\n  else\n    local smallest\
    \ = numbers[1]\n    local largest = numbers[#numbers]\n    local scale = largest\
    \ / smallest\n    largest = largest * scale\n    local results = {}\n    for _\
    \ = 1, #numbers do\n      local value = numbers[_]\n      -- Round to nearest\
    \ whole number in each chunk (not doing it in one chunk would just give us non-monotonic\
    \ rescaling)\n      local rounded = round(value * scale) + 1e-10\n      results[rounded]\
    \ = rounded\n    end\n    return results\n  end\nend", "    local maxv = math.max(numbers)\n\
    \    local minv = math.min(numbers)\n    local len = #numbers\n    local scale\
    \ = 1\n    while minv ~= 0 and maxv ~= 1 do\n        scale = scale * 10\n    \
    \    if minv / scale == maxv / scale then\n            break\n        end\n  \
    \      minv = math.floor(minv / scale) * scale\n        maxv = math.ceil(maxv\
    \ / scale) * scale\n    end\n    local minv = minv / scale\n    local maxv = maxv\
    \ / scale", '  assert(#numbers >= 2)', "  assert(#numbers >= 2)\n  local first_element\
    \ = numbers[1]\n  local new_numbers = {}\n  local scale_factor = first_element\
    \ - math.min(numbers)\n  for i = 2, #numbers do\n    new_numbers[i - 1] = scale_factor\
    \ * numbers[i] + first_element\n    scale_factor = scale_factor * 0.5\n  end\n\
    \  return new_numbers\nend", "  local min = table.min(numbers)\n  local max =\
    \ table.max(numbers)\n  local range = max - min + 1\n  local new_numbers = {}\n\
    \  for i = 1, #numbers do\n    local num = numbers[i]\n    if num - min < 0 then\n\
    \      new_numbers[i] = math.floor(num - min)\n    elseif num - min > 1 then\n\
    \      new_numbers[i] = math.floor(num / (range / 2.0) + min)\n    else\n    \
    \  new_numbers[i] = num\n    end\n  end\n  return new_numbers\nend", "  if #numbers\
    \ == 1 then\n    return {numbers[1]}\n  end\n  local min = table.remove_by_ref(numbers,\
    \ 1)\n  local max = table.remove_by_ref(numbers, 1)\n  local sum_of_squares =\
    \ 0\n  for _, num in ipairs(numbers) do\n    sum_of_squares = sum_of_squares +\
    \ num * num\n  end\n  return {(numbers[1] - min) / (max - min) / sqrt(sum_of_squares)}\n\
    end", "  return setmetatable({\n    min = math.min(numbers),\n    max = math.max(numbers)\n\
    \  }, meta(numbers))\nend", "  local min_value = numbers[1]\n  local max_value\
    \ = numbers[#numbers]\n  local scale = (max_value - min_value) / #numbers\n  local\
    \ new_numbers = {}\n  local i = 1\n  while i <= #numbers do\n    table.insert(new_numbers,\
    \ min_value + i * scale)\n    table.insert(new_numbers, max_value + (i + 1) *\
    \ scale)\n    i = i + 1\n  end\n  return new_numbers\nend", "  local min, max\
    \ = math.min(numbers), math.max(numbers)\n  local length = #numbers", "  local\
    \ max_value = math.max(numbers)\n  local min_value = math.min(numbers)\n  return\
    \ numbers.map(function (x) return x - min_value / max_value end)\nend\nrescale_to_unit:setall(unpack)",
  "  return numbers.MinValue + numbers:Map(function(x) return x/numbers.MaxValue end):Min()\n\
    end", "  -- Find minimum\n  local minimum = numbers[1]\n  for i = 2, #numbers\
    \ do\n    if numbers[i] < minimum then\n      minimum = numbers[i]\n    end\n\
    \  end\n  -- Normalize so that minimum becomes 0 and maximum becomes 1\n  local\
    \ range = (maximum - minimum)\n  for i = 1, #numbers do\n    numbers[i] = numbers[i]\
    \ - minimum + range\n  end\n  return numbers\nend", "   local n = #numbers\n \
    \  local max = numbers.max\n   local min = numbers.min\n   local factor = (max-min)/n\n\
    \   return setmetatable({}, {\n      __index = function(self, k)\n         if\
    \ k == n then\n            return factor\n         elseif k == 1 then\n      \
    \      return min\n         else\n            return numbers[k]*factor\n     \
    \    end\n      end\n   })\nend", "  assert(#numbers > 1)\n  local minimum = numbers[1]\n\
    \  local maximum = numbers[#numbers]\n  local delta = maximum - minimum\n  local\
    \ newminimum = minimum + delta / 2\n  local newmaximum = maximum - delta / 2\n\
    \  local newnumbers = {}\n  for _, num in ipairs(numbers) do\n    if num < newminimum\
    \ then\n      newnumbers[#newnumbers + 1] = newminimum\n      newminimum = newminimum\
    \ + delta / 2\n    elseif num > newmaximum then\n      newnumbers[#newnumbers\
    \ + 1] = newmaximum\n      newmaximum = newmaximum - delta / 2\n    else\n   \
    \   newnumbers[#newnumbers + 1] = num\n    end\n  end\n  return newnumbers\nend",
  "  local minimum = math.min(numbers)\n  local maximum = math.max(numbers)", "  return\
    \ numbers[#numbers]:map(\n    function(number)\n      if number == nil then\n\
    \        return 0\n      else\n        return number / numbers[#numbers]\n   \
    \   end\n    end\n  )\nend", "  -- Rescale to the unit interval [0, 1]\n  local\
    \ min = math.min(numbers)\n  local max = math.max(numbers)\n  return map(function(number)\
    \ return number / max - min end, numbers)\nend", "  assert(#numbers > 2, \"This\
    \ function takes at least two input arguments.\")\n  assert(#numbers == 2 or #numbers\
    \ == 3, \"This function takes either two or three input arguments.\")\n  assert(#numbers\
    \ == 2 or (#numbers == 3 and\n                          numbers[1] == numbers[#numbers]),\
    \ \"Numbers in the input table must have equal number of elements.\")\n  local\
    \ min_value = numbers[1]\n  local max_value = numbers[#numbers]\n  local scale\
    \ = (max_value - min_value) / (#numbers - 1)\n  for _, v in ipairs(numbers) do\n\
    \    if v < min_value then min_value = v end\n    if v > max_value then max_value\
    \ = v end\n  end\n  for i = 1, #numbers do\n    numbers[i] = numbers[i] - min_value\
    \ * scale\n  end\n  return numbers\nend", "  assert(#numbers >= 2)\n  local min\
    \ = table.remove(numbers, 1)\n  local max = table.remove(numbers, 1)\n  local\
    \ rescaled_min = 0.0\n  local rescaled_max = 1.0\n  for i = 1, #numbers do\n \
    \   local value = numbers[i]\n    local rescale_value = ((value - min) * (max\
    \ - min) / (max - min)) + min\n    if rescale_value < min then\n      rescaled_min\
    \ = min\n    elseif rescale_value > max then\n      rescaled_max = max\n    else\n\
    \      rescaled_min = rescale_value\n    end\n  end\n  assert(rescaled_min < max)\n\
    \  assert(rescaled_max > min)\n  local result = {}\n  table.insert(result, 0)\n\
    \  table.insert(result, rescaled_min)\n  table.insert(result, rescaled_max)\n\
    \  return result\nend", "  local min, max = math.min(numbers), math.max(numbers)\n\
    \  local scale = max - min + 1\n  local scaled_numbers = {}\n  for i = 1, #numbers\
    \ do\n    scaled_numbers[i] = (numbers[i] - min) / scale\n  end\n  return scaled_numbers\n\
    end", "  if #numbers < 2 then\n    return numbers\n  else\n    return numbers[1]\
    \ + numbers[2] / math.abs(numbers[1] + numbers[2])\n  end\nend", "  if #numbers\
    \ < 2 then return numbers end\n  if #numbers == 1 then return {numbers[1]} end\n\
    \  if #numbers == 2 then return {numbers[1], numbers[2]} end\n  local min1 = numbers[1]\n\
    \  local max1 = numbers[1]\n  for i = 2, #numbers do\n    if numbers[i] < min1\
    \ then min1 = numbers[i] end\n    if numbers[i] > max1 then max1 = numbers[i]\
    \ end\n  end\n  local min2 = numbers[#numbers]\n  local max2 = numbers[#numbers]\n\
    \  for i = #numbers, 1, -1 do\n    if numbers[i] < min2 then min2 = numbers[i]\
    \ end\n    if numbers[i] > max2 then max2 = numbers[i] end\n  end\n  assert(min2\
    \ <= min1 and max2 >= max1)\n  local min = (min1 + min2) / 2\n  local max = (max1\
    \ + max2) / 2\n  if min == max1 then return {min} end\n  local scale = (max -\
    \ min) / (2 - min)\n  return {min, min, max, max, min}\nend", "  assert(#numbers\
    \ >= 2)\n  local first  = numbers[1]\n  local second = numbers[#numbers]\n  if\
    \ second > first then\n    numbers = numbers\n      :gsub('(%.-?%+?)(%.-?%+?)(%.-?%+?)(%.-?%+?)(%.-?%+?)',\n\
    \             function(_, p1, p2, p3, p4, p5, p6) -- return string where first\
    \ number is replaced by second\n               return string.format('%.1f', (first\
    \ + second) * (tonumber(p5) + tonumber(p6))) -- cast to number\n             end)\n\
    \      :gsub('(%.-?%+?)(%.-?%+?)(%.-?%+?)(%.-?%+?)(%.-?%+?)(%.-?%+?)',\n     \
    \        function(_, p1, p2, p3, p4, p5, p6) -- return string where first number\
    \ is replaced by second\n               return string.format('%.1f', (first +\
    \ second) * (tonumber(p5) + tonumber(p6))) -- cast to number\n             end)\n\
    \      :gsub('(%.-?%+?)(%.-?%+?)(%.-?%+?)(%.-?%+?)(%.-?%+?)(%.-?%+?)',\n     \
    \        function(_, p1, p2, p3, p4, p5, p6) -- return string where first number\
    \ is replaced by second\n               return string.format('%.1f', (first +\
    \ second) * (tonumber(p5) + tonumber(p6))) -- cast to number\n             end)\n\
    \      :gsub('(%.-?%+?)(%.-?%+?)(%.-?%+?)(%.-?%+?)(%.-?%+?)(%.-?%+?)',\n     \
    \        function(_, p1, p2, p3, p4, p5, p6) -- return string where first number\
    \ is replaced by second\n               return string.format('%.1f', (first +\
    \ second) * (tonumber(p5) + tonumber(p6))) -- cast to number\n             end)\n\
    \  end\n  return numbers\nend", "  local min = math.min(numbers)\n  local max\
    \ = math.max(numbers)", "  assert(#numbers >= 2, \"Must have at least two numbers\"\
    )\n  local minimum = numbers[1]\n  local maximum = numbers[2]", "  assert(#numbers\
    \ >= 2, \"rescale_to_unit requires a table of at least two elements\")\n  local\
    \ minimum = numbers[1]\n  local maximum = numbers[#numbers]\n  if minimum > maximum\
    \ then\n    local tmp = minimum\n    minimum = maximum\n    maximum = tmp\n  end\n\
    \  local scale = (maximum - minimum) / (#numbers - 1)\n  local output = {}\n \
    \ for i = 1, #numbers do\n    local value = numbers[i]\n    local rescale = value\
    \ - minimum\n    rescale = rescale / scale\n    table.insert(output, rescale)\n\
    \  end\n  return output\nend", "  if #numbers < 2 then return numbers end\n  local\
    \ min = tonumber(numbers[1])\n  local max = tonumber(numbers[#numbers])\n  local\
    \ range = max - min\n  local scale = 1.0 / range\n  local new_numbers = {}\n \
    \ local i = 1\n  for _ in pairs(numbers) do\n    new_numbers[i] = (i - 1) * scale\n\
    \    i = i + 1\n  end\n  return new_numbers\nend", "  return numbers:map(function\
    \ (number)\n    return number:min(1):max(1):mean()\n  end)\nend", "  local min_num\
    \ = min(numbers)\n  local max_num = max(numbers)", "  -- make sure it is a set\n\
    \  if not is_set(numbers) then return nil end", "    local length = #numbers\n\
    \    if length == 0 then\n        error('Cannot rescale_to_unit(): No numbers\
    \ to rescale')\n    end", "  return set:difference(({math.min(numbers)}, {math.max(numbers)}))\n\
    end", "    local maxx = math.max(numbers)\n    local minx = math.min(numbers)\n\
    \    local zerox = math.floor(minx)\n    local onex = math.ceil(maxx)\n    local\
    \ rangex = maxx - minx\n    if zerox > onex then\n        return onex:map(function\
    \ (x) return ((x - zerox) / rangex) * (maxx - minx) + minx end)\n    end\n   \
    \ return numbers:map(function (x) return ((x - zerox) / rangex) * (maxx - minx)\
    \ + minx end)\nend", "    if #numbers < 2 then\n        return {0, 1}\n    end\n\
    \    local sorted_numbers = table.sort(numbers)\n    local range = sorted_numbers[#sorted_numbers]\
    \ - sorted_numbers[1]\n    local scaled_numbers = {}\n    for i = 1, #sorted_numbers\
    \ do\n        scaled_numbers[i] = sorted_numbers[i] + range / 2\n    end\n   \
    \ return scaled_numbers\nend", "  local min, max = unpack(numbers)\n  min = min\
    \ or 0\n  max = max or 1\n  local factor = max - min\n  min = min - min\n  max\
    \ = max + min\n  return table.concat(numbers, function(x)\n    return (x - min)\
    \ * factor\n  end)\nend", "\tlocal max = numbers[1]\n\tlocal min = numbers[1]\n\
    \tfor i = 1, #numbers do\n\t\tif numbers[i] < min then min = numbers[i] end\n\t\
    \tif numbers[i] > max then max = numbers[i] end\n\tend\n\treturn {\n\t\tmin =\
    \ min,\n\t\tmax = max,\n\t}\nend", "  local min = numbers[1]\n  local max = numbers[#numbers]\n\
    \  if min == max then\n    return numbers\n  end", "  -- The minimum is zero,\
    \ maximum is 1\n  local min = 0\n  local max = 1\n  local num", "  local min,\
    \ max = numbers[1], numbers[#numbers]\n  local scale = (max - min) / (max - math.min(min))\n\
    \  for _, v in ipairs(numbers) do\n    if math.min(min) < v and math.max(max)\
    \ > v then\n      v = ((v - math.min(min)) + (max - min) * scale) .. 0.5\n   \
    \ end\n  end\n  return numbers\nend", "  assert(#numbers >= 2, 'Need at least\
    \ two numbers')\n  local min_value = numbers[1]\n  local max_value = numbers[#numbers]\n\
    \  local factor = max_value - min_value\n  local results = {}\n  for i = 2, #numbers\
    \ do\n    local value = numbers[i]\n    local new_value = value - min_value\n\
    \    results[i] = new_value * factor\n  end\n  return results\nend", "  local\
    \ length = #numbers\n  if length <= 1 then\n    return numbers\n  else\n    local\
    \ minimum = numbers[1]\n    local maximum = numbers[length]\n    if minimum ==\
    \ maximum then\n      return numbers\n    elseif minimum > maximum then\n    \
    \  return numbers\n    else\n      local scale = maximum - minimum\n      for\
    \ i = 1, length do\n        numbers[i] = numbers[i] - minimum\n      end\n   \
    \   for i = 1, length do\n        numbers[i] = numbers[i] / scale\n      end\n\
    \      return numbers\n    end\n  end\nend", "    local min_number = math.min(numbers)\n\
    \    local max_number = math.max(numbers)\n    local delta = (max_number - min_number)\
    \ / #numbers\n    local result = {}\n    for i = 1, #numbers do\n        result[i]\
    \ = min_number + (numbers[i] - min_number) * delta\n    end\n    return result\n\
    end\n</code>\n<|/ a |>\n<| c |>\nYou should be able to get rid of `local min`\
    \ and `local max`, by doing `local numbers = table.sort(numbers)` right at the\
    \ top.\n<|/ c |>\n<| c |>\n- Yes, you're right.  I didn't think of that.  My code\
    \ is intended to be used with a table of numbers.  My code assumed that there\
    \ was only a single number, so I was using the built-in `min` and `max` functions.\
    \  But, you're right, I could just as easily use `table.sort` instead of my `local\
    \ min` and `local max` variables.\n<|/ c |>\n<| a |>\nI couldn't really understand\
    \ the question, but I guess you want to rescale some table of numbers to the range\
    \ [0,1] (which you can easily do by dividing by number of numbers).\nHere's a\
    \ function that does it:\n<code>", "   if #numbers < 2 then\n      return numbers\n\
    \   end", "  assert(#numbers > 1, \"need at least two numbers\")\n  assert(#numbers\
    \ > 0, \"need at least one number\")\n  local min = numbers[1]\n  local max =\
    \ numbers[#numbers]\n  local scale = (max-min)/#numbers\n  for i=1,#numbers do\n\
    \    numbers[i] = numbers[i] - min\n  end\n  for i=1,#numbers do\n    numbers[i]\
    \ = numbers[i]*scale\n  end\n  return numbers\nend", "  if #numbers == 1 then\n\
    \    return table.remove(numbers, 1)\n  elseif #numbers == 0 then\n    return\
    \ {}\n  else\n    local lowest_num = table.remove(numbers)\n    local highest_num\
    \ = lowest_num\n    for _, num in pairs(numbers) do\n      if num ~= lowest_num\
    \ then\n        highest_num = num\n      end\n    end\n    local scale = highest_num\
    \ - lowest_num\n    local new_numbers = {}\n    for _, num in pairs(numbers) do\n\
    \      new_numbers[num - lowest_num] = lowest_num + (num - lowest_num) * scale\n\
    \    end\n    return new_numbers\n  end\nend", "  local min = table.min(numbers)\n\
    \  local max = table.max(numbers)", "  local minimum = math.min(numbers)\n  local\
    \ maximum = math.max(numbers)\n  local result = {}", "  assert(#numbers >= 2)\n\
    \  local min = table.remove(numbers, 1)\n  local max = table.remove(numbers, 1)\n\
    \  local scaled_numbers = {}\n  for i = 1, #numbers do\n    scaled_numbers[i]\
    \ = numbers[i] + ((numbers[i] - min) / (max - min))\n  end\n  return scaled_numbers\n\
    end", "  if #numbers < 2 then return numbers end\n  local min = numbers[1]\n \
    \ local max = numbers[#numbers]\n  local offset = min - max\n  local scale = 1.0\n\
    \  local new_numbers = {}\n  for i = 2, #numbers do\n    new_numbers[i] = min\
    \ + scale * (numbers[i] - min)\n    scale = scale * 1.0\n  end\n  return new_numbers\n\
    end", "    if #numbers < 2 then\n        error(\"rescale_to_unit() called with\
    \ less than 2 numbers\")\n    end\n    local new_numbers = numbers:map(function(n)\n\
    \        return n/#numbers;\n    end)\n    return new_numbers:min(1) / new_numbers:max(1);\n\
    end", "  local minimum, maximum = unpack(numbers)\n  return minimum + minimum\
    \ / numbers * sum(numbers) / (maximum - minimum)\nend", "  if #numbers < 2 then\n\
    \    error(\"expected table with at least two elements\")\n  end\n  local minval\
    \ = numbers[1]\n  local maxval = numbers[#numbers]\n  local unit = (maxval - minval)\
    \ / (#numbers - 1)\n  return { minval - unit, maxval + unit }\nend", "  local\
    \ min = math.min(numbers)\n  local max = math.max(numbers)", "   assert(#numbers\
    \ > 1)\n   local min = math.min(numbers)\n   local max = math.max(numbers)\n \
    \  return map:apply(function() map:new(min, max - min) end,\n                \
    \     numbers,\n                     function(number) return number:c() / 2.0\
    \ end)\nend", "    local smallest = numbers[1]\n    local largest = numbers[1]\n\
    \    local largestIdx = 0", "    local min = numbers[1]\n    local max = numbers[#numbers]\n\
    \    local range = max - min\n    local scaled_numbers = terralib.newlist()\n\
    \    for _, number in ipairs(numbers) do\n        scaled_numbers:insert(math.floor(number\
    \ * range / 2.0 + min))\n    end\n    return scaled_numbers\nend", "  local min\
    \ = 0\n  local max = 0\n  for i, n in pairs(numbers) do\n    min = math.min(min,\
    \ n)\n    max = math.max(max, n)\n  end\n  local range = max - min\n  local scale\
    \ = 1 / range\n  local result = {}\n  for i, n in pairs(numbers) do\n    result[i]\
    \ = min + (n - min) * scale\n  end\n  return result\nend", "  -- If the set of\
    \ numbers has no elements, return empty list\n  if not numbers then\n    return\
    \ {}\n  end\n  -- If the set has only one element, return single element set\n\
    \  if #numbers == 1 then\n    return numbers[1]\n  end\n  -- Choose the smallest\
    \ number as the initial min and largest number as the initial max\n  local min\
    \ = numbers[1]\n  local max = numbers[1]\n  for i = 2, #numbers do\n    local\
    \ cur = numbers[i]\n    if min > cur then\n      min = cur\n    end\n    if max\
    \ < cur then\n      max = cur\n    end\n  end\n  -- Calculate the scale to apply\
    \ to the numbers\n  -- If all of the numbers are below the initial min or above,\
    \ the scale should be zero\n  -- If all of the numbers are above the initial max,\
    \ the scale should be one\n  local scale = (min > max) and 1 or 0\n  local new_numbers\
    \ = {}\n  for i = 1, #numbers do\n    local cur = numbers[i]\n    new_numbers[i]\
    \ = min + (scale * (cur - min))\n  end\n  return new_numbers\nend", "  assert(#numbers\
    \ >= 2, 'Can only rescale table with 2 or more elements')", "  local n = #numbers\n\
    \  local min = numbers[1]\n  local max = numbers[n - 1]\n  local scale = (max\
    \ - min) / 2.0\n  for i = 2, n do\n    numbers[i] = numbers[i] - min\n    numbers[i]\
    \ = numbers[i] * scale\n  end\n  return numbers\nend", "  assert(#numbers >= 2,\
    \ 'The input table must be of at least two elements')\n  local min_number = numbers[1]\n\
    \  local max_number = numbers[#numbers]\n  if min_number == nil then\n    min_number\
    \ = 0.0\n  end\n  if max_number == nil then\n    max_number = 1.0\n  end\n  min_number\
    \ = min_number or 0.0\n  max_number = max_number or 1.0\n  local rescaled_numbers\
    \ = {}\n  for _, value in ipairs(numbers) do\n    rescaled_numbers[value] = (value\
    \ - min_number) / (max_number - min_number)\n  end\n  return rescaled_numbers\n\
    end", "  assert(#numbers > 1)\n  local min = numbers[1]\n  local max = numbers[#numbers]\n\
    \  local scale = 1.0\n  for i = 2, #numbers do\n    if numbers[i] < min then\n\
    \      min = numbers[i]\n    end\n    if numbers[i] > max then\n      max = numbers[i]\n\
    \    end\n    scale = scale * 1.0 / numbers[i]\n  end\n  local newMin = 0\n  local\
    \ newMax = 1\n  for i = 1, #numbers do\n    newMin = newMin * 1.0 + numbers[i]\
    \ / scale\n    newMax = newMax * 1.0 + numbers[i] / scale\n  end\n  newMin = newMin\
    \ * scale\n  newMax = newMax * scale\n  return table.concat({ min = newMin, max\
    \ = newMax })\nend", "  assert(#numbers >= 2, 'Given table must contain at least\
    \ two elements')\n  local scaled_numbers = {}\n  for i = 1, #numbers do\n    scaled_numbers[i]\
    \ = numbers[i] / numbers[1]\n  end\n  return scaled_numbers\nend", "  local min\
    \ = table.min(numbers)\n  local max = table.max(numbers)\n  if min == max then\n\
    \    return numbers\n  end", "  if #numbers < 2 then\n    return {0, 1}\n  end",
  "  local minimum = math.min(numbers)\n  local maximum = math.max(numbers)\n  local\
    \ interval = (maximum - minimum) / #numbers", "  if #numbers == 0 then\n    return\
    \ {}\n  end\n  local min = numbers[1]\n  local max = numbers[#numbers]\n  local\
    \ factor = (max - min) / ((#numbers - 1) * (max - min))\n  local new_numbers =\
    \ {}\n  local i = 1\n  while i <= #numbers do\n    local new_number = numbers[i]\n\
    \    new_number = (new_number - min) * factor\n    new_numbers[i] = new_number\n\
    \    i = i + 1\n  end\n  return new_numbers\nend", "  if #numbers < 2 then return\
    \ numbers end\n  local min, max = numbers[1], numbers[#numbers]\n  min = min -\
    \ min % min\n  if min < 0 then\n    min = min + min\n    max = max + max\n  end\n\
    \  local length = #numbers\n  local step = max / (length - 1)\n  for i = 1, length\
    \ do\n    numbers[i] = min + step * i\n  end\n  return numbers\nend", "  local\
    \ min, max = unpack(numbers)\n  assert(min < max, \"The given table of numbers\
    \ must have at least two elements\")", "  if #numbers == 1 then\n    return {numbers[1]}\n\
    \  end\n  local max = 0\n  local min = math.min(numbers[1])\n  local new_numbers\
    \ = table.deepcopy(numbers)\n  -- If there is only one number, then return that\
    \ number\n  if #new_numbers == 1 then\n    return numbers\n  end\n  -- Find the\
    \ new min/max based on the min/max of the original numbers\n  for i = 1, #new_numbers\
    \ do\n    if new_numbers[i] < min then\n      min = new_numbers[i]\n    end\n\
    \    if new_numbers[i] > max then\n      max = new_numbers[i]\n    end\n  end\n\
    \  -- Scale the numbers\n  for i = 1, #new_numbers do\n    new_numbers[i] = min\
    \ + (new_numbers[i] - min) / (max - min) * (max - min) + min\n  end\n  return\
    \ new_numbers\nend", "    local max = math.max(numbers[1])\n    local min = math.min(numbers[1])\n\
    \    local size = #numbers\n    local scale = (max - min) / (size - 1)\n    return\
    \ setmetatable({\n        scale = scale,\n        min = min,\n        max = max,\n\
    \    }, numbers)\nend", "  assert(#numbers > 1, \"Only works for tables with at\
    \ least two numbers\")\n  local new_numbers = {}\n  for i = 1, #numbers do\n \
    \   local number = numbers[i]\n    assert(number >= 0 and number <= 1, \"Passed\
    \ invalid number to rescale_to_unit: \" .. tostring(number))\n    if number >\
    \ 1 then\n      number = math.floor(number * 1000) / 1000\n    end\n    new_numbers[i]\
    \ = number\n  end\n  return new_numbers\nend", "  if #numbers < 2 then\n    return\
    \ nil\n  end", "   local smallest = numbers[1]\n   local largest = numbers[1]\n\
    \   for i = 2, #numbers do\n      smallest = math.min(numbers[i], smallest)\n\
    \      largest = math.max(numbers[i], largest)\n   end\n   return {\n      smallest\
    \ = smallest / largest,\n      largest = largest / largest,\n   }\nend\nreturn\
    \ rescale_to_unit", "  if #numbers < 2 then\n    return numbers\n  end", "  if\
    \ #numbers == 1 then\n    return {numbers[1]}\n  end\n  local range = (numbers[1]\
    \ - numbers[1]) * (numbers[#numbers]) / #numbers\n  local rescaled = {}\n  for\
    \ i, n in ipairs(numbers) do\n    rescaled[i] = n / range\n  end\n  return rescaled\n\
    end", "  assert(#numbers >= 2, 'need at least two elements in numbers')\n  local\
    \ minn = math.min(numbers)\n  local maxx = math.max(numbers)\n  local minnx =\
    \ math.min(minn, maxx)\n  local maxnx = math.max(maxx, minn)\n  local factor =\
    \ (maxnx - minnx) / (maxnx - minnx)\n  assert(factor >= 0, 'factor needs to be\
    \ > 0')\n  \n  return {}\nend", "  if #numbers < 2 then\n    return numbers\n\
    \  end\n  local first_positive = numbers[1]\n  local last_negative = numbers[#numbers]\n\
    \  if first_positive > 0 and last_negative < 0 then\n    numbers[1] = 0\n    numbers[#numbers]\
    \ = 0\n  end\n  if first_negative > 0 and last_positive < 0 then\n    numbers[#numbers]\
    \ = 0\n    numbers[1] = 0\n  end\n  if #numbers == 1 then\n    return numbers\n\
    \  end\n  local scale = 1.0\n  local i = 1\n  while i < #numbers and numbers[i]\
    \ < 0 do\n    scale = scale * -1.0\n    i = i + 1\n  end\n  while i < #numbers\
    \ and numbers[i] > 0 do\n    scale = scale * 1.0\n    i = i + 1\n  end\n  while\
    \ i < #numbers and not numbers[i] then\n    i = i + 1\n  end\n  while i < #numbers\
    \ and numbers[i] < 0 and numbers[i] ~= 0 do\n    numbers[i] = 0\n    i = i + 1\n\
    \  end\n  if scale == 0.0 then\n    return numbers\n  end\n  if scale == -1.0\
    \ then\n    local minimum = math.abs(numbers[1])\n    numbers[1] = minimum\n \
    \   if last_negative < minimum then\n      numbers[#numbers] = last_negative /\
    \ minimum\n    end\n  else\n    local maximum = math.abs(numbers[#numbers])\n\
    \    numbers[#numbers] = maximum\n    if first_negative > maximum then\n     \
    \ numbers[1] = first_negative / maximum\n    end\n  end\n  assert(math.abs(numbers[1])\
    \ == 1.0)\n  assert(math.abs(numbers[#numbers]) == 1.0)\n  return numbers\nend",
  "  local min = math.min(numbers)\n  local max = math.max(numbers)\n  local diff\
    \ = max - min\n  local inv_diff = -diff / max\n  return numbers.map(function(x)\
    \ return x * inv_diff + min end)\nend", "  assert(#numbers >= 2)\n  local smallest\
    \ = numbers[1]\n  local largest = numbers[1]\n  for i = 2, #numbers do\n    smallest\
    \ = smallest + ((numbers[i] - smallest) / (largest - smallest))\n    largest =\
    \ largest\n  end\n  return numbers\nend", "  if #numbers == 1 then\n    return\
    \ {numbers[1]}\n  end\n  local rescaled = numbers[1]\n  for i = 2, #numbers do\n\
    \    rescaled = rescaled * (1 - numbers[i]/rescaled)\n  end\n  return {0, rescaled}\n\
    end", '  local minimum, maximum = unpack(numbers)', "  assert(#numbers > 1)\n\
    \  local min = math.min(numbers)\n  local max = math.max(numbers)\n  local delta\
    \ = max - min\n  local scale = delta == 0 and 1 or delta / max\n  local new_numbers\
    \ = {}\n  for i = 1, #numbers do\n    new_numbers[i] = min + (numbers[i] - min)\
    \ * scale\n  end\n  return new_numbers\nend", '  assert(#numbers > 1)', "  local\
    \ scales = { 1.0 }\n  local largest = numbers[1]\n  local smallest = numbers[1]",
  "  if #numbers < 2 then\n    error(\"Invalid argument: \" .. #numbers)\n  end",
  "  assert(#numbers >= 2)\n  local min = numbers[1]\n  local max = numbers[#numbers]\n\
    \  local length = #numbers\n  if min == max then\n    return numbers\n  end\n\
    \  local min = math.min(min, max)\n  local max = math.max(min, max)\n  local factor\
    \ = (max - min) / length\n  local scaled_numbers = {}\n  for i = 1, length do\n\
    \    scaled_numbers[i] = min + factor * i\n  end\n  return scaled_numbers\nend",
  "    local min = numbers[1]\n    local max = numbers[#numbers]\n    local scale\
    \ = (max - min) / (#numbers - 1)", "    local min_element = math.min(numbers)\n\
    \    local max_element = math.max(numbers)\n    local scale = (max_element - min_element)\
    \ / (max_element + min_element)\n    local scaled_numbers = { }\n    for i, v\
    \ in ipairs(numbers) do\n        scaled_numbers[i] = v * scale\n    end\n    return\
    \ scaled_numbers\nend", "   if #numbers < 2 then\n      return nil\n   end\n \
    \  local min = math.min(numbers)\n   local max = math.max(numbers)\n   local scale\
    \ = max - min\n   if scale == 0 then\n      return nil\n   end", '  if #numbers
    < 2 then return {1} end', "  local min_val = min(numbers)\n  local max_val = max(numbers)\n\
    \  local scale = (max_val - min_val) / (#numbers - 1)\n  local output = {}\n \
    \ for i = 1, #numbers do\n    output[i - 1] = numbers[i] + scale * (i - 1)\n \
    \ end\n  return output\nend", "  assert(#numbers > 0, 'must have more than one\
    \ number')\n  local min = math.min(numbers)\n  local max = math.max(numbers)\n\
    \  assert(min < max, 'must specify at least one number in the table')\n  local\
    \ scale = (max - min) / 2.0\n  local result = {}\n  for i = 1, #numbers do\n \
    \   table.insert(result, numbers[i] + scale)\n  end\n  return result\nend", " \
    \  local min = numbers[1]\n   local max = numbers[#numbers]\n   for i = 1, #numbers\
    \ do\n      numbers[i] = ((numbers[i] - min) / (max - min)) * 1.0\n   end\nend",
  "  local min = table.min(numbers)\n  local max = table.max(numbers)\n  local min_pos\
    \ = nil\n  for i, n in ipairs(numbers) do\n    if n < min then\n      min = n\n\
    \      min_pos = i\n    end\n  end\n  if min == max then\n    return numbers\n\
    \  end", "  local largest = numbers[1]\n  local smallest = numbers[1]\n  for i\
    \ = 2, #numbers do\n    if numbers[i] < smallest then\n      largest = numbers[i]\n\
    \    elseif numbers[i] > largest then\n      largest = numbers[i]\n      smallest\
    \ = numbers[i]\n    end\n  end\n  largest = largest + 1 -- make largest number\
    \ 1 so we don't run off the edges\n  local scale = (largest - smallest) / (largest)\
    \ -- scale number range\n  local result = {}\n  local i = 1 -- keep track of where\
    \ we are in the resulting table\n  for ii = 1, #numbers do\n    result[i] = smallest\
    \ + scale * (numbers[ii] - smallest)\n    i = i + 1 -- increment our index counter\n\
    \  end\n  return result\nend", "  local min = numbers[1]\n  local max = numbers[2]\n\
    \  local range = max - min\n  for _, x in ipairs(numbers) do\n    x = x - min\
    \ + range / 2\n  end\n  return numbers\nend", "  assert(#numbers > 1)\n  local\
    \ min_value = math.min(numbers)\n  local max_value = math.max(numbers)\n  local\
    \ rescaled = min_value:clone()\n  local divisor = (max_value - min_value) / #numbers\n\
    \  for i, value in ipairs(numbers) do\n    rescaled[i] = min_value + value * divisor\n\
    \  end\n  return rescaled\nend", "  assert(#numbers > 0)\n  assert(#numbers ==\
    \ 1 or #numbers == 2)", "    local min_value = math.min(numbers)\n    local max_value\
    \ = math.max(numbers)\n    local unit = (max_value - min_value) / (numbers - 1)\n\
    \    local scaled_numbers = { 0.0 }\n    for i = 1, #numbers do\n        scaled_numbers[i]\
    \ = (numbers[i] - min_value) / unit\n    end\n    return scaled_numbers\nend",
  "\tassert(#numbers >= 2, \"rescale_to_unit expects at least 2 elements, got \" ..\
    \ #numbers)\n\tlocal min = math.min(numbers)\n\tlocal max = math.max(numbers)\n\
    \treturn numbers.map(function(number)\n\t\treturn number - min\n\tend)\nend",
  "  assert(#numbers >= 2, \"Expected table of numbers to contain at least two elements!\"\
    )\n  local min, max = numbers[1], numbers[#numbers]\n  local range = (max - min)\
    \ / #numbers\n  local scaled_numbers = {}\n  for i = 1, #numbers do\n    scaled_numbers[i]\
    \ = min + range * i\n  end\n  return scaled_numbers\nend", "  local min = table.min(numbers)\n\
    \  local max = table.max(numbers)\n  if min == max then\n    return numbers\n\
    \  end", "  assert(#numbers > 2, \"The given table of numbers is empty.\")\n \
    \ local minimum = numbers[1]\n  local maximum = numbers[#numbers]", "  assert(#numbers\
    \ > 0, \"At least two numbers are required\")\n  local smallest, largest = numbers[1],\
    \ numbers[#numbers]\n  if smallest > 0 then\n    largest = largest - smallest\
    \ + 1\n  end\n  local factor = largest / 2.0\n  return table.map((numbers - smallest\
    \ - 1), function(x)\n    return factor * x + smallest - factor + 1\n  end)\nend",
  "  assert(#numbers >= 2)\n  local min = {x = math.min(numbers[1][1], numbers[2][1]),\n\
    \              y = math.min(numbers[1][2], numbers[2][2])}\n  local max = {x =\
    \ math.max(numbers[1][1], numbers[2][1]),\n              y = math.max(numbers[1][2],\
    \ numbers[2][2])}\n  if min.x ~= nil and max.x ~= nil then\n    return {}\n  elseif\
    \ min.x ~= nil then\n    numbers[1][1] = numbers[1][1]\n    numbers[1][2] = numbers[1][2]\n\
    \    numbers[1][1] = min.x\n    numbers[1][2] = max.x\n    return numbers\n  elseif\
    \ max.x ~= nil then\n    numbers[2][1] = numbers[2][1]\n    numbers[2][2] = numbers[2][2]\n\
    \    numbers[2][1] = min.x\n    numbers[2][2] = max.x\n    return numbers\n  end\n\
    end", "  assert(#numbers >= 2)\n  local minval = math.min(numbers)\n  local maxval\
    \ = math.max(numbers)\n  -- Normalize each number in the table so that\n  --\n\
    \  -- The smallest number will be 0 and the largest will be 1\n  --\n  -- The\
    \ table is scaled so that we get the following range:\n  --\n  -- newmin = (minval\
    \ - minval) / range * newrange + newmin\n  -- newmax = (maxval - minval) / range\
    \ * newrange + newmax\n  local newmin = (minval - minval) / numbers[1] * newrange\
    \ + newrange\n  local newmax = (maxval - minval) / numbers[#numbers - 1] * newrange\
    \ + newrange", "  local min = numbers[1]\n  local max = numbers[#numbers]\n  local\
    \ num_digits = math.floor(math.log(max, 10))\n  local scaled_numbers = {}", " \
    \  local min = math.min(numbers)\n   local max = math.max(numbers)\n   local scale\
    \ = (max - min) / 2\n   local result = {}\n   for i = 1, #numbers do\n      local\
    \ element = numbers[i]\n      if element <= min then\n         result[i] = 0\n\
    \      elseif element >= max then\n         result[i] = 1\n      else\n      \
    \   result[i] = (element - min) / scale\n      end\n   end\n   return result\n\
    end", "  local min_val, max_val = unpack(numbers)\n  local delta = max_val - min_val\n\
    \  min_val = min_val - delta / 2.0\n  max_val = max_val + delta / 2.0\n  -- min_val\
    \ is now 0, max_val is 1\n  -- apply the linear transform to each number\n  for\
    \ i, v in pairs(numbers) do\n    numbers[i] = min_val + (v - min_val) / delta\n\
    \  end\n  return numbers\nend", "    local min = numbers.min()\n    local max\
    \ = numbers.max()\n    if min == max then\n        return numbers\n    end", " \
    \ local rescaled = {}\n  local min = 1\n  local max = 0\n  for _, v in pairs(numbers)\
    \ do\n    local num = tonumber(v)\n    min = min > num and min or num\n    max\
    \ = max < num and max or num\n    rescaled[#rescaled + 1] = num\n  end\n  table.sort(rescaled)\n\
    \  return table.unpack(rescaled, 1, #rescaled)\nend", "    local min = math.min(numbers)\n\
    \    local max = math.max(numbers)\n    if min == max then\n        return {1.0}\n\
    \    end", "  assert(#numbers > 1)\n  local min_num = numbers[1]\n  local max_num\
    \ = numbers[#numbers]\n  local delta = max_num - min_num\n  for _, num in pairs(numbers)\
    \ do\n    local new_num = num - min_num\n    new_num = new_num / delta\n    numbers[#numbers]\
    \ = new_num\n  end\n  return numbers\nend", "  assert(#numbers > 1)\n  local minimum\
    \ = math.min(numbers)\n  local maximum = math.max(numbers)\n  local range = (maximum\
    \ - minimum)\n  local scaled_numbers = {}\n  for i = 1, #numbers do\n    scaled_numbers[i]\
    \ = (numbers[i] - minimum) / range\n  end\n  return scaled_numbers\nend", "  --\
    \ First, make sure all numbers are positive (this is arbitrary, but it makes the\
    \ math easier)\n  for _, number in pairs(numbers) do\n    if number < 0 then\n\
    \      error(\"Rescaling input table by non-positive number: \", number)\n   \
    \ end\n  end", "  local maxElement = numbers[1]\n  local minElement = numbers[1]\n\
    \  for _, element in ipairs(numbers) do\n    maxElement = math.max(maxElement,\
    \ element)\n    minElement = math.min(minElement, element)\n  end\n  minElement\
    \ = minElement / maxElement\n  for _, element in ipairs(numbers) do\n    element\
    \ = element - minElement\n  end\n  return numbers\nend", "  if #numbers < 2 then\n\
    \    return numbers\n  end", "  local min_num = numbers[1]\n  local max_num =\
    \ numbers[2]\n  for i = 1, #numbers do\n    numbers[i] = math.min(numbers[i],\
    \ max_num - min_num)\n    min_num = math.max(numbers[i], min_num)\n  end\nend",
  "  assert(#numbers > 2, \"rescale_to_unit expects table of at least two elements\"\
    )\n  local min, max = numbers[1], numbers[#numbers]\n  if min == max then\n  \
    \  table.insert(numbers, 0, min, min, min)\n    return numbers\n  end\n  if min\
    \ == 0 then\n    min = 1.0\n  end\n  if max == 1 then\n    max = 1.0\n  end\n\
    \  local scale = (max - min) / (#numbers - 1)\n  local newmin = min\n  local newmax\
    \ = max\n  local scalei = 1\n  for i = #numbers - 2, 1, -1 do\n    local n = numbers[i]\n\
    \    local f = n - newmin\n    newmin = newmin + scale * f\n    newmax = newmax\
    \ - scale * f\n    scalei = scalei * scale\n  end\n  if newmin == min then\n \
    \   newmin = 0\n  end\n  if newmax == max then\n    newmax = 1\n  end\n  table.insert(numbers,\
    \ 0, newmin, newmax, newmax)\n  return numbers\nend", "  return table.sort(numbers,\
    \ function(n1, n2) return n1 - n2 end)\nend", "  local min = table.min(numbers)\n\
    \  local max = table.max(numbers)\n  return function(number)\n    return (number\
    \ - min) / (max - min)\n  end\nend", "  if #numbers == 1 then\n    return { numbers[1]\
    \ / numbers[1] }\n  else\n    local min = math.min(numbers)\n    local max = math.max(numbers)\n\
    \    local range = max - min\n    if range < 1.0 then\n      return { (numbers[1]\
    \ - min) / range }\n    else\n      return { (numbers[1] - min) / (max - min)\
    \ }\n    end\n  end\nend", "  local min_value = numbers[1]\n  local max_value\
    \ = numbers[2]", "  local max_value = table.max(numbers)\n  local min_value =\
    \ table.min(numbers)\n  assert(max_value >= min_value, \"Input table must contain\
    \ at least two elements\")\n  local scale = max_value - min_value\n  return map(\n\
    \    function(x) return min_value + scale * (x - min_value) end,\n    numbers\n\
    \  )\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
