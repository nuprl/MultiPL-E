name: HumanEval_153_Strongest_Extension
language: lua
prompt: "-- You will be given the name of a class (a string) and a table of extensions.\n\
  -- The extensions are to be used to load additional classes to the class. The\n\
  -- strength of the extension is as follows: Let CAP be the number of the uppercase\n\
  -- letters in the extension's name, and let SM be the number of lowercase letters\
  \ \n-- in the extension's name, the strength is given by the fraction CAP - SM.\
  \ \n-- You should find the strongest extension and return a string in this \n--\
  \ format: ClassName.StrongestExtensionName.\n-- If there are two or more extensions\
  \ with the same strength, you should\n-- choose the one that comes first in the\
  \ table.\n-- For example, if you are given \"Slices\" as the class and a table of\
  \ the\n-- extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n--\
  \ return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
  \ \n-- (its strength is -1).\n-- Example:\n-- >>> Strongest_Extension('my_class',\
  \ {'AA', 'Be', 'CC'})\n-- 'my_class.AA'\nlocal function Strongest_Extension(class_name,\
  \ extensions)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = Strongest_Extension\n\
  \    lu.assertEquals(candidate('Watashi', {'tEN', 'niNE', 'eIGHt8OKe'}), 'Watashi.eIGHt8OKe')\n\
  \    lu.assertEquals(candidate('Boku123', {'nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg'}),\
  \ 'Boku123.YEs.WeCaNe')\n    lu.assertEquals(candidate('__YESIMHERE', {'t', 'eMptY',\
  \ 'nothing', 'zeR00', 'NuLl__', '123NoooneB321'}), '__YESIMHERE.NuLl__')\n    lu.assertEquals(candidate('K',\
  \ {'Ta', 'TAR', 't234An', 'cosSo'}), 'K.TAR')\n    lu.assertEquals(candidate('__HAHA',\
  \ {'Tab', '123', '781345', '-_-'}), '__HAHA.123')\n    lu.assertEquals(candidate('YameRore',\
  \ {'HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-'}), 'YameRore.okIWILL123')\n\
  \    lu.assertEquals(candidate('finNNalLLly', {'Die', 'NowW', 'Wow', 'WoW'}), 'finNNalLLly.WoW')\n\
  \    lu.assertEquals(candidate('_', {'Bb', '91245'}), '_.Bb')\n    lu.assertEquals(candidate('Sp',\
  \ {'671235', 'Bb'}), 'Sp.671235')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tassert(type(extensions) == 'table')\n\tlocal strongest = extensions[1]\n\
    \tlocal index = 1\n\twhile index < #extensions do\n\t\tif extensions[index] ==\
    \ strongest then\n\t\t\tindex = index + 1\n\t\telse\n\t\t\tbreak\n\t\tend\n\t\
    end\n\tif index > 1 then\n\t\treturn class_name .. '.' .. extensions[index]\n\t\
    else\n\t\treturn class_name\n\tend\nend", "  local class = class_name\n  local\
    \ extension\n  local strengh\n  local strengh_index\n  local index\n  local new_extension",
  "  -- Write your code here.\n  local max_strength = -1\n  local max_extension\n\
    \  for _, ext in ipairs(extensions) do\n    local cap = string.match(ext, \"[A-Z]+\"\
    )\n    local sm = string.match(ext, \"[a-z]+\")\n    local strength = cap - sm\n\
    \    if strength > max_strength then\n      max_strength = strength\n      max_extension\
    \ = ext\n    end\n  end\n  return class_name .. \".\" .. max_extension\nend\n\
    </cell>\n<text>\nQuestion 3\nWrite a function that creates a hash. This function\
    \ should take in a string\nof any length and return a string of the same length\
    \ in which every character\nappears only once.\nFor example, if the input string\
    \ is \"aabbcc\" and we assume that the string is\nencoded in ASCII, then the output\
    \ should be \"aaBCc\".", "\tlocal StrongestExtension\n\tfor index, extension in\
    \ ipairs(extensions) do\n\t\tlocal CAP, SM = string.upper(extension:sub(1, 1)),\
    \ string.lower(extension:sub(2, 2))\n\t\tlocal SMcount = string.gsub(SM, '[^'\
    \ .. CAP .. ']', '') -- SM's length is CAP minus SM's\n\t\tlocal SMstrength =\
    \ SMcount - CAP\n\t\tif StrongestExtension == nil then\n\t\t\tStrongestExtension\
    \ = class_name\n\t\t\tStrongestExtension:gsub('%l', function(x) return tostring(x)\
    \ end)\n\t\telse\n\t\t\tif SMstrength > StrongestExtension:gsub('%l', function(x)\
    \ return tostring(x) end) then\n\t\t\t\tStrongestExtension = class_name\n\t\t\t\
    \tStrongestExtension:gsub('%l', function(x) return tostring(x) end)\n\t\t\tend\n\
    \t\tend\n\tend\n\treturn StrongestExtension\nend", "    local extension_map =\
    \ {}\n    for _, extension in ipairs(extensions) do\n        local cap = string.upper(extension:sub(1,\
    \ #extension))\n        local sm = string.lower(extension:sub((#extension) + 1))\n\
    \        local strength = capi.strongest_extension_strength(capi.class_name(capi.string_new(capi.char_add(capi.class_name(capi.string_new(class_name)),\
    \ capi.char_add(capi.string_new('.')), capi.char_add(capi.string_new(' ')), capi.char_add(capi.string_new('StrongestExtensionName')))))\n\
    \        table.insert(extension_map, cap, strength)\n    end\n    local lowest_strength\
    \ = nil\n    local lowest_extension = nil\n    for cap, strength in pairs(extension_map)\
    \ do\n        if lowest_strength == nil then\n            lowest_strength = strength\n\
    \            lowest_extension = cap\n        elseif strength < lowest_strength\
    \ then\n            lowest_strength = strength\n            lowest_extension =\
    \ cap\n        end\n    end\n    return class_name .. '.' .. lowest_extension\n\
    end", "   if #extensions <= 0 then\n      return class_name .. '.NONE'\n   end\n\
    \   local ext = {}\n   for i = 1, #extensions do\n      local c = extensions:sub(i,\
    \ i):upper()\n      local m = c:find('a')\n      local n = c:find('A')\n     \
    \ local s = m:len() + n:len()\n      if s > 0 then\n         ext = c .. ' ' ..\
    \ extensions[i - 1]\n      else\n         ext = c .. extensions[i - 1]\n     \
    \ end\n   end\n   return class_name .. '.' .. ext\nend", "  local min_strength\
    \ = -1\n  for _, extension in ipairs(extensions) do\n    if min_strength == -1\
    \ then\n      min_strength = CAP - SM\n    end\n    if CAP - SM > min_strength\
    \ then\n      min_strength = CAP - SM\n    end\n  end\n  for _, extension in ipairs(extensions)\
    \ do\n    if CAP - SM < min_strength then\n      min_strength = CAP - SM\n   \
    \ end\n  end\n  if min_strength > 0 then\n    return class_name .. '.' .. extensions[min_strength]\n\
    \  else\n    return class_name\n  end\nend", "  assert(class_name ~= nil and extensions\
    \ ~= nil, 'Class name and/or extensions are nil.')\n  if extensions == nil then\
    \ return class_name end\n  local strongest = nil\n  local strength = nil\n  for\
    \ _, extension in ipairs(extensions) do\n    local extension_class = get_class_name(extension)\n\
    \    local extension_class_cap = string.len(extension_class)\n    local extension_class_sm\
    \ = string.len(extension_class:lower())\n    local cap = string.upper(extension_class_cap)\n\
    \    local sm = string.upper(extension_class_sm)\n    local diff = cap - sm\n\
    \    if diff < 0 then diff = diff * -1 end\n    if diff == 0 then \n      table.insert(strongest,\
    \ extension)\n    else\n      if strength == nil or strength > diff then\n   \
    \     strength = diff\n        strongest = extension\n      end\n    end\n  end\n\
    \  if strongest == nil or strongest == [] then\n    -- If there are no extensions,\
    \ return the class\n    return class_name\n  else\n    table.insert(strongest,\
    \ class_name)\n    return table.concat(strongest, '.')\n  end\nend", "  local\
    \ cap_letters = string.gsub(class_name, '[A-Z]', '') -- Capital letters\n  local\
    \ sml_letters = string.gsub(class_name, '[a-z]', '') -- Small letters\n  if cap_letters\
    \ <= sml_letters then -- Check if we have same number of uppercase and lowercase\n\
    \    local strength = -1 -- Default value\n    for _, ext in ipairs(extensions)\
    \ do\n      local cap = string.gsub(ext, '[A-Z]', '')\n      local sml = string.gsub(ext,\
    \ '[a-z]', '')\n      if cap > sml then\n        local diff = cap - sml\n    \
    \    -- If CAP lesser than SM, we have same difference\n        if diff > 0 then\n\
    \          -- If CAP - SM is negative then there is no strength\n          if\
    \ diff < 0 then\n            strength = -1 -- Difference less than zero\n    \
    \        break\n          else\n            -- If CAP - SM is positive then we\
    \ have a strength \n            strength = diff\n            break\n         \
    \ end\n        end\n      else\n        -- If SM is less than CAP, we have same\
    \ difference\n        if diff < 0 then\n          -- If SM - CAP is negative then\
    \ there is no strength\n          if diff < 0 then\n            strength = -1\
    \ -- Difference less than zero\n            break\n          else\n          \
    \  -- If SM - CAP is positive then we have a strength \n            strength =\
    \ diff\n            break\n          end\n        end\n      end\n    end\n  \
    \  return string.gsub(class_name, \".\", \"\") .. class_name .. '.' .. class_name\
    \ .. \n      string.rep(string.sub(class_name, 1, cap_letters - 1), strength)\n\
    \  else\n    local strongest_extension_strength = -1 -- Default value\n    for\
    \ _, ext in ipairs(extensions) do\n      local cap = string.gsub(ext, '[A-Z]',\
    \ '')\n      local sml = string.gsub(ext, '[a-z]', '')\n      local diff = cap\
    \ - sml\n      if diff > 0 then\n        if diff > strongest_extension_strength\
    \ then\n          strongest_extension_strength = diff\n        end\n      end\n\
    \    end\n    if strongest_extension_strength > 0 then\n      return string.gsub(class_name,\
    \ \".\", \"\") .. class_name .. \n        string.rep(string.sub(class_name, 1,\
    \ cap_letters - 1), strongest_extension_strength)\n    else\n      return nil\
    \ -- No strongest extension\n    end\n  end\nend", "\tlocal cap = class_name:upper():sub(1,\
    \ #class_name-1)\n\tlocal sm = class_name:lower():sub(1, #class_name-1)\n\tlocal\
    \ cap_sum = #extensions:filter(function(e) return e:upper():sub(1, #e-1) = cap\
    \ end):double()\n\tlocal sm_sum = #extensions:filter(function(e) return e:lower():sub(1,\
    \ #e-1) = sm end):double()\n\tlocal ratio = cap_sum/sm_sum\n\t\n\tlocal strongest\
    \ = extensions[math.random(1, #extensions)]\n\t\n\twhile strongest:upper():sub(1,\
    \ #strongest-1) != class_name:upper() do\n\t\tstrongest = extensions[math.random(1,\
    \ #extensions)]\n\tend\n\t\n\twhile strongest:lower():sub(1, #strongest-1) !=\
    \ class_name:lower() do\n\t\tstrongest = extensions[math.random(1, #extensions)]\n\
    \tend\n\t\n\treturn class_name .. \".\" .. strongest\nend", "\tlocal cap_counts\
    \ = { }\n\tfor i, c in ipairs(extensions) do cap_counts[c] = 0 end\n\tfor i, c\
    \ in ipairs(extensions) do\n\t\tcap_counts[c] = cap_counts[c] + 1\n\t\tif cap_counts[c]\
    \ > 1 then\n\t\t\tcap_counts[c] = cap_counts[c] - 1\n\t\tend\n\tend\n\tlocal strength\
    \ = 0\n\tlocal strongest = nil\n\tfor i, c in ipairs(extensions) do\n\t\tstrength\
    \ = strength + 1\n\t\tlocal cap_count = cap_counts[c]\n\t\tif cap_count > strength\
    \ then\n\t\t\tstrength = cap_count\n\t\t\tstrongest = c\n\t\tend\n\tend\n\treturn\
    \ class_name .. '.' .. strongest\nend", "  local strongest = {}\n  local strength\
    \ = nil\n  local names = {}\n  local uppercase_count = 0\n  local lowercase_count\
    \ = 0\n  local cap_count = 0\n  local sm_count = 0\n  for i, ext in ipairs(extensions)\
    \ do\n    uppercase_count = uppercase_count + 1\n    lowercase_count = lowercase_count\
    \ + 1\n    cap_count = cap_count + 1\n    sm_count = sm_count + 1\n    if upper(ext)\
    \ == ext then\n      names[#names + 1] = {upper(ext), -1}\n    elseif lower(ext)\
    \ == ext then\n      names[#names + 1] = {lower(ext), -1}\n    elseif cap(ext)\
    \ == ext then\n      names[#names + 1] = {cap(ext), -1}\n    end\n  end", "  \
    \  local strongest = {}\n    for _, extension in ipairs(extensions) do\n     \
    \   local cap = string.upper(extension:sub(1,1)):len()\n        local sm = string.lower(extension:sub(1,1)):len()\n\
    \        local strength = cap - sm\n        if strength > 0 and strongest[strength]\
    \ == nil then\n            strongest[strength] = extension\n        end\n    end\n\
    \    return class_name .. '.' .. table.concat(table.sort(strongest, \n       \
    \                                            function (a, b) return a < b end),\
    \ '.')\nend", "  local result = ''\n  local extensions_len = #extensions\n  local\
    \ extensions_table = {}\n  for i = 1, extensions_len do\n    table.insert(extensions_table,\
    \ extensions[i])\n  end\n  table.sort(extensions_table)\n  for _, extension in\
    \ ipairs(extensions_table) do\n    local cap = string.upper(extension:sub(1, #extension))\n\
    \    local sm = string.lower(extension:sub((cap+1):len()))\n    local strength\
    \ = cap - sm\n    if strength > 0 then\n      result = result .. class_name ..\
    \ '.' .. extension .. '.' .. tostring(strength)\n    end\n  end\n  return result\n\
    end", "  local strengths = {}\n  -- Get the number of upper case letters in the\
    \ class' name.\n  for i, letter in ipairs(string.gsub( class_name, \"[A-Z]\",\
    \ \"\")) do\n    local key = string.sub( class_name, i, i+1)\n    strengths[ key\
    \ ] = strengths[key] + 1 -- Increase the strength of every uppercase letter in\
    \ key\n  end\n  -- Get the number of lower case letters in the class' name.\n\
    \  for i, letter in ipairs(string.gsub( class_name, \"[a-z]\", \"\")) do\n   \
    \ local key = string.sub( class_name, i, i+1)\n    strengths[ key ] = strengths[key]\
    \ + 1 -- Increase the strength of every lowercase letter in key\n  end\n  -- Sort\
    \ the strengths of the extensions\n  for _, value in pairs(extensions) do\n  \
    \  local key = string.sub( value, 2, length(value))\n    strengths[ key ] = strengths[\
    \ key ] + 1 -- Increase the strength of the extension\n  end\n  -- Return the\
    \ strongest extension\n  local max_strength = max( values(strengths) )\n  -- Loop\
    \ through the extensions until we find the extension with highest strength.\n\
    \  for _, extension in pairs(extensions) do\n    local strength = string.sub(\
    \ extension, 2, length(extension))\n    if strength == max_strength then\n   \
    \   return extension\n    end\n  end\nend\n</cell>\n<text>\nProblem 3.10\nLet\
    \ class_name be \"my_class\" and let extensions be the table of extensions described\
    \ above. The function should return the name of the class with the strongest extension.\
    \ The class name and the strongest extension name can contain only letters and\
    \ should be separated by a single space. For example: my_class has the strongest\
    \ extension 'AA'.", "\tlocal max_strength = -1\n\tfor _, extension in pairs(extensions)\
    \ do\n\t\tlocal count, strength = unpack(extension)\n\t\tif strength == 0 then\
    \ break end\n\t\tif max_strength < strength then\n\t\t\tmax_strength = strength\n\
    \t\t\tbreak\n\t\tend\n\tend\n\tif max_strength == -1 then\n\t\terror(class_name\
    \ .. ' has no extension')\n\tend\n\treturn class_name .. '.' .. extensions[#extensions]\n\
    end", "   if type(extensions) == 'table' then\n      local strongest_extension\
    \ = extensions[1]\n      for i, ext in ipairs(extensions) do\n         local new_extension\
    \ = ext:upper()\n         local c = new_extension:find('^%c'):upper()\n      \
    \   if c~=nil then\n            local s, m = c:lower():sub(1, 1):lower():find(class_name:lower(),\
    \ 1, true)\n            if s~=nil then\n               if strongest_extension:find(extensions[i+1]):lower()\
    \ > s:lower() then\n                  strongest_extension = extensions[i+1]\n\
    \               end\n            end\n         end\n      end\n      return strongest_extension\n\
    \   else\n      return nil\n   end\nend", "\tlocal best_extension, best_score\
    \ = nil, 0\n\tfor _, extension in ipairs(extensions) do\n\t\tlocal score = string.gsub(class_name,\
    \ '%c+', 1, extension:len())\n\t\tif score > best_score then\n\t\t\tbest_extension\
    \ = extension\n\t\t\tbest_score = score\n\t\tend\n\tend\n\treturn string.sub(class_name,\
    \ '%c+', 1, string.len(class_name) - best_score) .. best_extension\nend", "  local\
    \ max_strength = -1\n  local max_extension\n  for _, extension in ipairs(extensions)\
    \ do\n    local c, s = str:uppercase_and_lowercase(extension), str:uppercase_and_lowercase(class_name)\n\
    \    local c, s = c:sub(1, #c), s:sub(1, #s)\n    local cap, sm = str:uppercase_and_lowercase(extension):upper():len(),\
    \ str:uppercase_and_lowercase(class_name):upper():len()\n    local strength =\
    \ cap - sm\n    if strength > max_strength then\n      max_strength, c = strength,\
    \ max_extension\n    end\n  end\n  return max_extension\nend", "\tlocal stengths\
    \ = {}\n\tlocal longest = nil\n\tfor _, extension in pairs(extensions) do\n\t\t\
    local length = #extension\n\t\tlocal upper = 0\n\t\tlocal lower = 0\n\t\tfor c\
    \ in string.gsub(extension, \"[A-Z]\") do\n\t\t\tif string.sub(c, 1, 1) ~= string.sub(c,\
    \ 1, 1) then\n\t\t\t\tupper = upper + 1\n\t\t\tend\n\t\tend\n\t\tfor c in string.gsub(extension,\
    \ \"[a-z]\") do\n\t\t\tif string.sub(c, 1, 1) ~= string.sub(c, 1, 1) then\n\t\t\
    \t\tlower = lower + 1\n\t\t\tend\n\t\tend\n\t\tstengths[length] = ((upper + lower)\
    \ / 2)\n\tend\n\ttable.sort(stengths, function(a, b) return stengths[a] < stengths[b]\
    \ end)\n\tfor i, _ in pairs(stengths) do\n\t\tif stengths[i] == stengths[longest]\
    \ then\n\t\t\tlongest = i\n\t\tend\n\tend\n\treturn string.sub(class_name, 1,\
    \ string.len(class_name) - longest-1..-1..string.len(class_name) + longest+1,\
    \ string.len(class_name) - longest+1)\nend", "    local Strongest_Extension =\
    \ {}\n    for _, extension in ipairs(extensions) do\n        Strongest_Extension[extension]\
    \ = -1\n    end\n    for _, extension in ipairs(extensions) do\n        local\
    \ CC_count = 0\n        local AC_count = 0\n        for c in class_name:gmatch(\"\
    .\") do\n            if c:lower() == extension:lower() then\n                CC_count\
    \ = CC_count + 1\n            elseif c:upper() == extension:upper() then\n   \
    \             AC_count = AC_count + 1\n            end\n        end\n        if\
    \ CC_count > AC_count then\n            Strongest_Extension[extension] = extension\n\
    \        end\n    end\n    -- return the strongest extension if there is one,\
    \ otherwise return nil\n    for _, extension in ipairs(extensions) do\n      \
    \  if Strongest_Extension[extension] == nil then\n            return nil\n   \
    \     end\n    end\n    return Strongest_Extension\nend", "\tlocal strongest =\
    \ {}\n\tfor _, extension in ipairs(extensions) do\n\t\tlocal len = string.len(extension)\n\
    \t\tif len == 0 then\n\t\t\t-- Ignore extensions with length zero\n\t\t\tcontinue\n\
    \t\tend\n\t\tlocal num_uppercase = string.find(extension, '[A-Z]') + 2\n\t\tlocal\
    \ num_lowercase = string.find(extension, '[a-z]') + 2\n\t\tlocal cap = len + num_uppercase\
    \ + num_lowercase\n\t\tlocal sm = len - num_uppercase - num_lowercase\n\t\tlocal\
    \ strength = cap - sm\n\t\tif strongest[strength] == nil then\n\t\t\tstrongest[strength]\
    \ = {}\n\t\tend\n\t\tstrongest[strength][extension] = extension\n\tend\n\tlocal\
    \ strengths = {}\n\tfor _, strongest in ipairs(strongest) do\n\t\tfor _, extension\
    \ in ipairs(strongest) do\n\t\t\tlocal len = string.len(extension)\n\t\t\tif len\
    \ == 0 then\n\t\t\t\t-- Ignore extensions with length zero\n\t\t\t\tcontinue\n\
    \t\t\tend\n\t\t\tlocal num_uppercase = string.find(extension, '[A-Z]') + 2\n\t\
    \t\tlocal num_lowercase = string.find(extension, '[a-z]') + 2\n\t\t\tlocal cap\
    \ = len + num_uppercase + num_lowercase\n\t\t\tlocal sm = len - num_uppercase\
    \ - num_lowercase\n\t\t\tlocal strength = cap - sm\n\t\t\tif strengths[strength]\
    \ == nil then\n\t\t\t\tstrengths[strength] = {}\n\t\t\tend\n\t\t\tstrengths[strength][extension]\
    \ = extension\n\t\tend\n\tend\n\tlocal max_strength = nil\n\tlocal max_extension\
    \ = nil\n\tfor _, strength in ipairs(strengths) do\n\t\tif max_strength == nil\
    \ or strength > max_strength then\n\t\t\tmax_strength = strength\n\t\t\tmax_extension\
    \ = nil\n\t\tend\n\t\tif max_strength == strength then\n\t\t\tlocal extension\
    \ = strengths[strength]\n\t\t\tif max_extension == nil or string.len(extension)\
    \ > string.len(max_extension) then\n\t\t\t\tmax_extension = extension\n\t\t\t\
    end\n\t\tend\n\tend\n\treturn (string.sub(class_name, string.len(class_name) -\
    \ string.len(max_extension), -1)..'.'..max_extension)\nend", "\tassert(extensions\
    \ and type(extensions) ~= 'table', 'extensions must be a table')\n\tlocal s =\
    \ ''\n\tlocal num_a = 0\n\tlocal num_b = 0\n\tfor i, name in ipairs(extensions)\
    \ do\n\t\tlocal cap = #name\n\t\tlocal sm = #name\n\t\tlocal strength = cap -\
    \ sm\n\t\tif strength ~= 0 then\n\t\t\tif num_a < strength then\n\t\t\t\tnum_a\
    \ = strength\n\t\t\t\ts = name\n\t\t\telseif num_b < strength then\n\t\t\t\tnum_b\
    \ = strength\n\t\t\t\ts = name\n\t\t\tend\n\t\tend\n\tend\n\tif num_a == num_b\
    \ then\n\t\treturn class_name .. '.' .. s\n\telse\n\t\treturn class_name .. '.'\
    \ .. s[math.min(num_a, num_b)]\n\tend\nend", "\tlocal result = class_name\n\t\
    for _, extension in pairs(extensions) do\n\t\tlocal first_char = string.sub (extension,\
    \ 1, 1)\n\t\tlocal second_char = string.sub (extension, 2, 2)\n\t\tif first_char\
    \ == second_char then\n\t\t\tlocal strength = string.upper (extension) - string.lower\
    \ (extension)\n\t\t\tif strength > 0 then\n\t\t\t\t-- print(first_char, second_char,\
    \ strength)\n\t\t\t\tresult = result .. '.' .. extension\n\t\t\telseif strength\
    \ == 0 then\n\t\t\t\tresult = result .. '.' .. extension\n\t\t\telseif strength\
    \ < 0 then\n\t\t\t\tresult = result .. '.' .. extension\n\t\t\tend\n\t\tend\n\t\
    end\n\treturn result\nend", "    local total = 0\n    local max_str = ''\n   \
    \ local min_str = ''\n    for _, ext in ipairs(extensions) do\n        local ext_cap\
    \ = str:upper(ext)\n        local ext_sm = str:lower(ext)\n        local ext_str\
    \ = ext_cap - ext_sm\n        total = total + ext_str\n        if ext_str > 0\
    \ then\n            if ext_str > max_str then\n                max_str = ext_str\n\
    \            end\n            if ext_str < min_str then\n                min_str\
    \ = ext_str\n            end\n        end\n    end\n    local strength = total\
    \ / (#extensions - 1)\n    if strength > 0 then\n        return class_name ..\
    \ '[' .. max_str .. min_str .. ']'\n    else\n        return class_name\n    end\n\
    end", "  -- Write your code here\n  return class_name..'..'..extensions[1]\nend",
  "\tlocal function GetStrength(class_name)\n\t\tlocal count = #class_name\n\t\tlocal\
    \ strength = 0\n\t\tfor i, v in ipairs(class_name) do\n\t\t\tif v < 'A' or v >\
    \ 'Z' then\n\t\t\t\tcount = count - 1\n\t\t\telse\n\t\t\t\tstrength = strength\
    \ + 1\n\t\t\tend\n\t\tend\n\t\treturn math.floor(strength / count)\n\tend", " \
    \ assert(type(extensions) == 'table', 'extension should be a table')\n  \n  local\
    \ max_strength = -1\n  local strongest_extension = ''\n  \n  for _, extension\
    \ in pairs(extensions) do\n    if extension:upper():find(class_name:upper():sub(1,#extension):upper())\n\
    \    then\n      local cap_extension = extension:upper():sub(1,#extension)\n \
    \     local sm_extension = extension:upper():sub((#cap_extension + 1), #extension)\n\
    \      local str_extension = extension:sub(1,#extension)\n      \n      local\
    \ cap_strength = cap_extension:upper():sub(1,#cap_extension):upper():len()\n \
    \     local sm_strength = sm_extension:upper():sub(1,#sm_extension):upper():len()\n\
    \      local str_strength = str_extension:upper():sub(1,#str_extension):upper():len()\n\
    \      \n      if cap_strength > max_strength then\n        max_strength = cap_strength\n\
    \        strongest_extension = str_extension\n      end\n      if sm_strength\
    \ > max_strength then\n        max_strength = sm_strength\n        strongest_extension\
    \ = str_extension\n      end\n    end\n  end\n  \n  return strongest_extension\n\
    end", "  if extensions == nil then \n    error('Extensions cannot be nil!')\n\
    \  end\n  if #extensions == 0 then \n    error('There must be at least one extension!')\n\
    \  end\n  local counter = {}\n  for i = 1, #extensions do\n    counter[extensions[i]]\
    \ = -1\n  end\n  local extension_class = class_name:sub(1, class_name:len())\n\
    \  local extension_table = extensions:to_table()\n  for i = 1, #extension_table\
    \ do\n    counter[extension_table[i]] = i\n  end\n  local strength = -1\n  local\
    \ extension = nil\n  for key, val in pairs(counter) do\n    if val > 0 then\n\
    \      if strength == -1 then\n        strength = val\n        extension = key\n\
    \      else\n        if strength > val then\n          strength = val\n      \
    \    extension = key\n        end\n      end\n    end\n  end\n  return extension_class\
    \ .. '.' .. extension\nend", "  if #extensions <= 1 then\n    return class_name\n\
    \  end\n  local extension_strength = extensions[1] - extensions[2]\n  for i =\
    \ 2, #extensions do\n    if extensions[i] + extension_strength > extension_strength\
    \ then\n      extension_strength = extensions[i] + extension_strength\n    end\n\
    \  end\n  return class_name .. '.' .. extensions[2]\nend", "\tassert(type(class_name)\
    \ == 'string')\n\tassert(#extensions > 0)", "  if #extensions == 0 then\n    return\
    \ class_name\n  end", "   \n   -- Find the strongest extension among the given\
    \ extensions\n   local max_extension = extensions[1] -- Set the max extension\
    \ to first extension\n   for _, extension in ipairs(extensions) do\n      if string.find(extension,\
    \ '_', 1) then -- If an extension is found, check if the extension name is in\
    \ lowercase\n         if max_extension:len() >= string.find(extension, '_', 1)\
    \ then -- If the current extension is longer than the max extension name\n   \
    \         max_extension = extension\n         end\n      end\n   end\n   return\
    \ string.sub(class_name, 1, string.find(class_name, '_', 2) - 1) + '.' .. max_extension\n\
    end", "\t-- TODO: Implement this function.\nend", "  local max_strength = extensions[1]\n\
    \  for i = 2, #extensions do\n    local extension_strength = extensions[i]\n \
    \   if extension_strength > max_strength then\n      max_strength = extension_strength\n\
    \    end\n  end", "    assert(extensions[1] == extensions[#extensions])\n    local\
    \ strength = extensions[1] ~= extensions[#extensions] \n               and -1\
    \ or 0\n    for i = 2, #extensions do\n        local letters = extensions[i] ~=\
    \ extensions[#extensions]\n               and extensions[i-1] or extensions[#extensions]\n\
    \        if letters - strength >= 0 then\n            strength = letters\n   \
    \     end\n    end\n    return class_name .. '.' .. extensions[#extensions]\n\
    end", "  local results = {}\n  local max_strength = math.floor(#extensions)\n\
    \  for _, extension in ipairs(extensions) do\n    local c = string.lower(extension)\n\
    \    local c = string.gsub(c, \"[a-z]\", \"\") -- Strip out the letters.\n   \
    \ local c_strength = string.find(c, string.upper(class_name)) -- Find where CAP\
    \ is in the extension.\n    local c_strength = c_strength ~= nil and c_strength\
    \ or 0\n    local c_strength = c_strength / (#string.gsub(c, \"[^\" .. string.upper(class_name)\
    \ .. \"]\", \"\") + 1) -- Calculate the strength.\n    local strength = math.max(0,\
    \ max_strength - c_strength) -- Calculate the strongest extension.\n    if strength\
    \ == max_strength then\n      table.insert(results, extension)\n    else\n   \
    \   table.insert(results, string.sub(class_name, c_strength + 1, c_strength +\
    \ strength))\n    end\n  end\n  if #results > 1 then\n    results[1] = results[1]\
    \ .. \"_\" -- Add the underscore.\n  end\n  return table.concat(results, \".\"\
    )\nend\n</textarea></form>\n    <script>\n      var editor = CodeMirror.fromTextArea(document.getElementById(\"\
    code\"), {\n        lineNumbers: true,\n        matchBrackets: true,\n       \
    \ mode: \"text/x-lua\",\n        theme: \"lua\"\n      });\n    </script>\n  \
    \  <h3>Lua mode:</h3>\n    <form><textarea id=\"code2\" name=\"code2\">", "  if\
    \ extensions == nil then return nil end\n  local max_strength = -1\n  local max_index\
    \ = -1\n  for i = 1, #extensions do\n    local index = string.find(class_name:lower(),\
    \ '%.' .. string.sub(extensions[i], 1, 1) .. '%')\n    local extension_strength\
    \ = index:sub(1, 1)\n    if extension_strength > max_strength then\n      max_strength\
    \ = extension_strength\n      max_index = i\n    end\n  end\n  if max_index ==\
    \ -1 then return nil end\n  local new_class_name = class_name:sub(1, max_index)\n\
    \  return new_class_name .. '%.' .. string.sub(extensions[max_index], 1, 1) ..\
    \ '%'\nend", "  local best_strength = -1\n  local best_extension = nil\n  for\
    \ i, extension in ipairs(extensions) do\n    if extension:upper():find(class_name:upper())\
    \ == 0 then\n      if best_strength == -1 then\n        best_strength = extension:upper():upper():find(class_name:upper())\
    \ - extension:upper():upper():find('/')\n      else\n        if extension:upper():find(class_name:upper())\
    \ - extension:upper():upper():find('/') < best_strength then\n          best_strength\
    \ = extension:upper():upper():find(class_name:upper()) - extension:upper():upper():find('/')\n\
    \          best_extension = extension\n        end\n      end\n    end\n  end\n\
    \  return best_extension\nend", "   local strongest_strength = -1\n   local strongest_extension",
  "   assert(class_name ~= '' and class_name ~= nil, 'class_name is empty')\n   assert(extensions\
    \ ~= nil, 'extensions is nil')\n   local strongest_extension, counter = 0, -1\n\
    \   for i, ext in ipairs(extensions) do\n      if ext.upper:sub(1,1)~= ext.lower:sub(1,1)\
    \ then\n         counter = counter + 1\n      else\n         counter = -1\n  \
    \    end\n   end\n   if counter == -1 then\n      print('The extensions are not\
    \ strongest')\n      return ''\n   elseif counter > 0 then\n      strongest_extension\
    \ = extensions[#extensions]\n   end\n   return class_name .. '.' .. strongest_extension\n\
    end", "  local max_strength = -1\n  local max_index = -1\n  for i, e in ipairs(extensions)\
    \ do\n    local strength = string.upper(e:sub(#e)) .. string.lower(e:sub(1,#e))\n\
    \    if max_strength < strength then\n      max_strength = strength\n      max_index\
    \ = i\n    end\n  end", "    local strongest_extension = {}\n    for i, extension\
    \ in ipairs(extensions) do\n        local c = extension:sub(1, #extension)\n \
    \       if str:upper(c) == str:upper(class_name) then\n            table.insert(strongest_extension,\
    \ extension)\n        elseif str:lower(c) == str:lower(class_name) then\n    \
    \        table.insert(strongest_extension, extension)\n        end\n    end\n\
    \    table.sort(strongest_extension, function(a, b) return a:upper() <> a:lower()\
    \ end)\n    return strongest_extension[1]\nend\n</cell>\n<cell>", "  local strongest_extension\
    \ = {}\n  local class_index = #extensions\n  for index, extension in pairs(extensions)\
    \ do\n    local extension_upper = upper(extension)\n    local extension_lower\
    \ = lower(extension)\n    local upper_cap = #extension_upper\n    local lower_cap\
    \ = #extension_lower\n    local strongest_strength = class_index - upper_cap -\
    \ lower_cap\n    if strongest_strength > 0 then\n      table.insert(strongest_extension,\
    \ extension)\n      if strongest_strength == strongest_strength then\n       \
    \ if extension_lower < extension_upper then\n          strongest_strength = strongest_strength\
    \ - 1\n        end\n      end\n    end\n  end\n  table.sort(strongest_extension)\n\
    \  return string.format(class_name .. \".%s\", strongest_extension[1])\nend",
  "\tlocal best_extension = extensions[1]\n\tfor _, extension in ipairs(extensions)\
    \ do\n\t\tif strcmp(extension:lower(), class_name:lower()) >= 0 then\n\t\t\tbest_extension\
    \ = extension\n\t\t\tbreak\n\t\tend\n\tend\n\treturn best_extension\nend", " \
    \   local min_strength = extensions[1]\n    for i=2,#extensions do\n        if\
    \ extensions[i] == min_strength then\n            --TODO: remove min_strength\
    \ from the table\n            table.remove(extensions,i)\n        else\n     \
    \       min_strength = min_strength - 1\n        end\n    end\n    return class_name\
    \ .. '.' .. extensions[1]\nend", "  local strongest_extensions = {}\n  for i =\
    \ 1, #extensions do\n    local c = extensions[i]\n    if c == '' then\n      c\
    \ = class_name\n    end\n    local cap = c:sub(1, #c)\n    local sm = c:sub((#c\
    \ + 1), #c)\n    local strength = (cap - sm) / #c\n    if not strongest_extensions[strength]\
    \ then\n      strongest_extensions[strength] = c\n    end\n  end\n  return strongest_extensions[1]\n\
    end", "  assert(#extensions > 0)\n  local strongest = nil\n  for _, ext in ipairs(extensions)\
    \ do\n    local cap = #ext:upper():byte() + 1\n    local sm = #ext:lower():byte()\
    \ + 1\n    local strongest_score = cap - sm\n    if strongest_score == 0 then\n\
    \      strongest = ext\n      break\n    end\n    if strongest_score > 0 then\n\
    \      break\n    end\n  end\n  assert(strongest)\n  return class_name .. '.'\
    \ .. strongest\nend", "\tif extensions.size == 0 then\n\t\treturn nil\n\tend\n\
    \tlocal strongest = extensions[1]\n\tlocal strength = 0\n\tfor i = 2, #extensions\
    \ do\n\t\tlocal name = extensions[i]\n\t\tif name:find(class_name, 1, true):len()\
    \ ~= 0 then\n\t\t\tlocal cap = name:sub(#class_name)\n\t\t\tlocal sm = name:find(\"\
    [a-z]\", 1, true)\n\t\t\tif cap - sm > strength then\n\t\t\t\tstrength = cap -\
    \ sm\n\t\t\t\tstrongest = name\n\t\t\tend\n\t\tend\n\tend\n\treturn strongest\n\
    end", "    local num_caps = #(class_name):upper() - 1\n    local num_lows = #(class_name):lower()\
    \ - 1\n    local nums = num_caps - num_lows\n    local max_strongest_extension\n\
    \    local max_strongest_extension_strength\n    for extension in pairs(extensions)\
    \ do\n        local caps = #extension:upper()\n        local lows = #extension:lower()\n\
    \        local diff = caps - lows\n        local strength = num_caps - diff +\
    \ 1\n        if strength > max_strongest_extension_strength then\n           \
    \ max_strongest_extension_strength = strength\n            max_strongest_extension\
    \ = extension\n        end\n    end\n    return max_strongest_extension\nend",
  "   -- The function argument should be the class name and a table of the\n   --\
    \ extensions: \n   -- >>> Strongest_Extension('my_class', {'AA', 'Be', 'CC'})\n\
    \   -- >>> Strongest_Extension('my_class', {'AA', 'Be'})\n   -- >>> Strongest_Extension('my_class',\
    \ {'AA'})\n   -- >>> Strongest_Extension('my_class', {'B'})\n   -- >>> Strongest_Extension('my_class',\
    \ {})\n   -- 'my_class'\n   \n   -- Your code here\n   local strongest_extension\
    \ = {}\n   local cap_counter = 0\n   local sl_counter = 0\n   for _, extension\
    \ in ipairs(extensions) do\n      local cap = #extension:upper()\n      if cap\
    \ > cap_counter then\n         cap_counter = cap\n      end\n      local sl =\
    \ #extension:lower()\n      if sl > sl_counter then\n         sl_counter = sl\n\
    \      end\n   end\n   if cap_counter ~= sl_counter then\n      local cap_diff\
    \ = cap_counter - sl_counter\n      if cap_diff > 1 then\n         return nil\n\
    \      elseif cap_diff > 0 then\n         -- return the best extension, if the\
    \ extension is stronger\n         -- than the strongest extension\n         if\
    \ cap_counter > sl_counter then\n            return extensions[1]\n         else\n\
    \            return extensions[1]\n         end\n      else\n         return nil\n\
    \      end\n   else\n      -- return the best extension, if the extension is stronger\n\
    \      -- than the strongest extension\n      return extensions[1]\n   end\nend",
  "    local extension = nil\n    local strongest_extension = nil\n    for _, e in\
    \ pairs(extensions) do\n        local num_upper = string.len(e:upper())\n    \
    \    local num_lower = string.len(e:lower())\n        local num_cap = string.len(e:upper():sub(1,1))\n\
    \        local num_sm = string.len(e:lower():sub(1,1))\n        local strength\
    \ = num_upper - num_lower - num_cap - num_sm\n        if strength >= 0 then\n\
    \            if extension == nil then\n                extension = e\n       \
    \         strongest_extension = e\n            elseif strength > strongest_extension:len()\
    \ - 1 then\n                strongest_extension = e\n                extension\
    \ = e\n            end\n        end\n    end\n    return class_name .. '.' ..\
    \ strongest_extension\nend", "    local max_strength = -1\n    local max_extension\
    \ = ''\n    for _, extension in ipairs(extensions) do\n        local cap = string.upper(extension):sub(1,1)\n\
    \        local sm = string.lower(extension):sub(1,1)\n        local strength =\
    \ (cap - sm)/(#cap)\n        if strength > max_strength then\n            max_extension\
    \ = extension\n            max_strength = strength\n        end\n    end\n   \
    \ return class_name .. '.' .. max_extension\nend", "  local max_strength = -1;\n\
    \  for _, extension in ipairs(extensions) do\n    local letter_count = #extension;\n\
    \    if letter_count == 0 then break end", "\tlocal strongest = {}\n\tfor _, extension\
    \ in ipairs(extensions) do\n\t\tlocal cap = string.upper(extension:sub(1, #extension))\n\
    \t\tlocal sm = #extension - cap\n\t\tlocal strength = cap - sm\n\t\tif strongest[strength]\
    \ then\n\t\t\ttable.insert(strongest[strength], extension)\n\t\telse\n\t\t\tstrongest[strength]\
    \ = {{extension}}\n\t\tend\n\tend\n\tlocal strongest_str = class_name\n\tfor k,\
    \ extension in ipairs(strongest) do\n\t\tif #extension > 1 then\n\t\t\ttable.insert(strongest_str,\
    \ extension:first())\n\t\tend\n\tend\n\treturn strongest_str\nend", "  local strongest_extensions\
    \ = {}\n  local last_extension_strength = nil\n  local first_extension = extensions[1]\n\
    \  local first_extension_name = string.lower(first_extension)", "\tlocal max_strength\
    \ = -1\n\tlocal max_extension = \"\"", "  local extensions = extensions or {}\n\
    \  local strongest_extensions = {}\n  local capitals, lowercases = unpack(extensions:gsub('([A-Z])',\
    \ '\\1'):gsub('([a-z])', '\\2'):gsub('(.)_(.)', '\\1\\3'):gmatch('(.-)(.-)'))\n\
    \  for i, v in ipairs(capitals) do\n    table.insert(strongest_extensions, v)\n\
    \  end\n  local strength_sum = 0\n  for i, v in ipairs(lowercases) do\n    table.insert(strongest_extensions,\
    \ v)\n    strength_sum = strength_sum + #capitals - #lowercases - 1\n  end\n \
    \ local strength_fraction = strength_sum / #capitals\n  for i, v in ipairs(lowercases)\
    \ do\n    if i == #strongest_extensions and #strongest_extensions > 0 then\n \
    \     table.insert(strongest_extensions, v);\n    elseif #strongest_extensions\
    \ == 0 then\n      table.insert(strongest_extensions, v);\n    end\n    local\
    \ strength_difference = #capitals - #lowercases - 1\n    if #strongest_extensions\
    \ > 0 then\n      table.insert(strongest_extensions, v);\n    end\n    if strength_fraction\
    \ < strength_difference then\n      table.insert(strongest_extensions, v);\n \
    \   end\n  end\n  return class_name .. '.' .. table.concat(extensions, '.')\n\
    end", "   local i, c = 0, -1\n   for _,x in pairs(extensions) do\n      if string.match(x,\
    \ '^%s*(%A+)%s*$') then\n         if i == c then\n            i = -1\n       \
    \     c = -1\n         end\n         i = i + 1\n         c = c+#x[1]\n      end\n\
    \   end\n   return (string.sub(class_name, 1, (c+1)-1)..'.'..extensions[c])\n\
    end", "    local strongest_extensions = { }\n    for extension in extensions do\n\
    \        local cap = string.upper(extension):find(string.upper)\n        local\
    \ sm = string.lower(extension):find(string.lower)\n        if cap - sm > 0 then\n\
    \            strongest_extensions[#strongest_extensions + 1] = extension\n   \
    \     end\n    end\n    local num_strongest_extensions = #strongest_extensions\n\
    \    if num_strongest_extensions == 0 then\n        return class_name\n    end\n\
    \    local strength = 0\n    local strongest_extension = nil\n    for _, extension\
    \ in ipairs(strongest_extensions) do\n        local cap = string.upper(extension):find(string.upper)\n\
    \        local sm = string.lower(extension):find(string.lower)\n        if cap\
    \ - sm > strength then\n            strength = cap - sm\n            strongest_extension\
    \ = extension\n        end\n    end\n    return class_name .. \".\" .. strongest_extension\n\
    end", "\tlocal extension_strengths = {}\n\tfor i = 1, #extensions do\n\t\tlocal\
    \ extension = string.sub(class_name, 1, string.len(class_name) - string.len(extensions[i]))\
    \ + extensions[i]\n\t\tlocal strongest_extension_strength = extension_strengths[extension]\
    \ or -1\n\t\tif strongest_extension_strength < 0 then\n\t\t\textension_strengths[extension]\
    \ = strongest_extension_strength\n\t\tend\n\tend\n\treturn extension_strengths[#extension_strengths]:sub(1,\
    \ -#extension_strengths[#extension_strengths])\nend", "    local cap = #class_name\n\
    \    local sm = #class_name:lower() - cap + 1\n    local exts = table.remove_by_ref(extensions,\
    \ 1)\n    local max_strength = -1\n    for ext, s in pairs(exts) do\n        local\
    \ strength = #ext - #ext:lower() - s\n        if strength > max_strength then\n\
    \            max_strength = strength\n        end\n    end\n    if max_strength\
    \ == -1 then\n        return '[ERROR] Strongest_Extension: No extensions with\
    \ this class' \n    end\n    local strongest = ''\n    for ext, s in pairs(exts)\
    \ do\n        if #ext > #ext:lower() - s then\n            local s = #ext:lower()\
    \ - s\n            strongest = strongest .. extension:sub(1, s) .. extension:sub(s\
    \ + 1)\n        else\n            strongest = strongest .. extension:sub(1)\n\
    \        end\n    end\n    return class_name .. '.' .. strongest\nend", "  if\
    \ #extensions == 1 then\n    return class_name..'.'..extensions[1]\n  end\n  local\
    \ max_strength = -1\n  local max_index = -1\n  local index_to_remove = nil\n \
    \ local extension_name = ''\n  for i, extension in pairs(extensions) do\n    local\
    \ str_strength = string.upper(extension:sub(1, #extension)) - string.lower(extension:sub(1,\
    \ #extension))\n    if str_strength > max_strength then\n      max_strength =\
    \ str_strength\n      max_index = i\n      index_to_remove = i\n      extension_name\
    \ = extension\n    end\n  end\n  if index_to_remove ~= nil then\n    extensions.remove(index_to_remove)\n\
    \  end\n  return class_name..'.'..extension_name\nend", "    local exts = sort(extensions,\
    \ function(a, b) return a:upper() - b:upper() end)\n    local result = class_name\n\
    \    for _,e in ipairs(exts) do\n        if e == exts[#exts] then break end\n\
    \        local cap = e:match('(.):(.)')\n        if cap then\n            local\
    \ sm = cap:match('(.):(.)')\n            local strength = tonumber(cap - sm)\n\
    \            if strength >= 0 then\n                result = result .. '.' ..\
    \ e\n            end\n        end\n    end\n    return result\nend", "    assert(type(extensions)\
    \ == 'table')\n    local maxStrength = -1\n    local maxExtension\n    for _,\
    \ ext in pairs(extensions) do\n        local ext = ext:upper()\n        local\
    \ num = #ext\n        if num == 0 then break end\n        local cap = #ext - num\
    \ + 1\n        local sm = #ext - cap\n        if cap > sm then\n            maxStrength\
    \ = math.floor(100 * cap - sm)\n            maxExtension = ext\n        end\n\
    \    end\n    return class_name .. '.' .. maxExtension\nend", "   local max_strength\
    \ = -1\n   for _, extension_name in ipairs(extensions) do\n      local strength\
    \ = string.upper(class_name):find(extension_name)\n      if strength then\n  \
    \       local cap = string.upper(class_name):sub(1, strength-1)\n         local\
    \ sm = string.upper(class_name):sub(strength+1, #class_name)\n         local cap_diff\
    \ = cap - string.upper(extension_name)\n         if cap_diff > 0 then\n      \
    \      max_strength = math.max(cap_diff, max_strength)\n         elseif cap_diff\
    \ < 0 then\n            max_strength = max_strength + cap_diff\n         end\n\
    \      end\n   end\n   return max_strength < 0 then\n      class_name .. 'Not'\
    \ .. extensions[1]\n   elseif max_strength > 0 then\n      return class_name ..\
    \ string.upper(extensions[1]) .. extensions[max_strength + 1]\n   else\n     \
    \ return class_name .. string.upper(extensions[1])\n   end\nend", "  local extension_strengths\
    \ = {}\n  for _, extension in ipairs(extensions) do\n    local cap = string.upper(extension)\n\
    \    local sm = string.lower(extension)\n    local diff = cap-sm\n    local strength\
    \ = if diff == 0 then 1 else diff end\n    extension_strengths[extension] = strength\n\
    \  end\n  local strongest, strong_strength = nil, -1\n  local max_strength = #extension_strengths\n\
    \  for _, strength in ipairs(extension_strengths) do\n    if strength > strong_strength\
    \ then\n      strong_strength, strongest = strength, extension_strengths[max_strength]\n\
    \    end\n  end\n  return string.sub(class_name, 1, string.len(class_name)-#strongest)..strongest\n\
    end", "    local highestStrength = -1\n    local highestExtension = {}\n    for\
    \ _, extension in ipairs(extensions) do\n        local strength = #class_name:match(\"\
    ^\" .. extension)\n        if strength > highestStrength then\n            highestStrength\
    \ = strength\n            highestExtension = extension\n        end\n    end\n\
    \    return class_name .. highestExtension\nend\n</cell>\n<text>\nWrite a function\
    \ that creates a new class from the given definition and adds the given extensions.\
    \ The function should be called in the following way: create_class(class_name,\
    \ extensions). class_name is the name of the class that is to be created and extensions\
    \ is a list of extensions that should be added to the class. Example: create_class('my_class',\
    \ {'AA', 'Be', 'CC'}) creates the class my_class with the extensions AA and Be.\
    \ Make sure that you can correctly add extensions and that your new class has\
    \ the right number of extensions.", "\tlocal strongest = {}\n\tlocal extensions_count\
    \ = #extensions\n\tlocal extensions_table = extensions[1]\n\tfor i, extension\
    \ in ipairs(extensions) do\n\t\tlocal extension_upper = extension:upper()\n\t\t\
    local extension_lower = extension:lower()\n\t\tlocal strength = extensions_count-extension:gsub('[^'..extension_upper..'-'..extension_lower..']',\
    \ '')\n\t\tif strength > 0 then\n\t\t\ttable.insert(strongest, extension)\n\t\t\
    end\n\tend\n\ttable.sort(strongest)\n\treturn string.format(class_name .. '.%s',\n\
    \t\ttable.unpack(strongest))\nend", "  if extensions == nil then\n    return nil\n\
    \  end\n  local extension_map = {}\n  for _, extension in pairs(extensions) do\n\
    \    local class_name, extension = string.match(extension, \"^([^.]+)%.(.*)$\"\
    )\n    if extension_map[class_name] == nil then\n      extension_map[class_name]\
    \ = 0\n    end\n    extension_map[class_name] = extension_map[class_name] + 1\n\
    \  end\n  local max_strength = extension_map[class_name]\n  local strongest_extension\n\
    \  for _, extension in pairs(extensions) do\n    local class_name, extension =\
    \ string.match(extension, \"^([^.]+)%.(.*)$\")\n    local strength = extension_map[class_name]\n\
    \    if strength > max_strength then\n      max_strength = strength\n      strongest_extension\
    \ = extension\n    end\n  end\n  return string.sub(class_name, 1, string.len(class_name)\
    \ - string.len(strongest_extension)) + strongest_extension\nend", "   local table\
    \ = {} -- To store the strength of each extension\n   for _, extension in ipairs(extensions)\
    \ do\n      local cap, sm = unpack(extension:match('(.)([A-Z]+)'))\n      table[extension]\
    \ = (cap - sm) * (cap + sm) / 100\n   end\n   local strongest = {} -- To store\
    \ the strongest extension\n   table.sort(table) -- Sort the table from highest\
    \ to lowest\n   for _, extension in ipairs(extensions) do\n      if table[extension]\
    \ == table[#table] then\n         strongest[extension] = extension\n      end\n\
    \   end\n   return string.gsub(class_name, \"([A-Z]+)\", function (c) return strongest[c]\
    \ end)\nend", "    if not extensions then \n        return 'error'\n    end\n\
    \    local strengths = {}\n    local counts = {}\n    for _, extension in ipairs(extensions)\
    \ do\n        local length = #extension\n        local uppercase_count = 0\n \
    \       local lowercase_count = 0\n        for _, char in ipairs(extension) do\n\
    \            uppercase_count = uppercase_count + (string.uppercase (char):byte()\
    \ - 64)\n            lowercase_count = lowercase_count + (string.lowercase (char):byte()\
    \ - 64)\n        end\n        local strength = (uppercase_count-lowercase_count)/(length)\n\
    \        if strengths[strength] == nil then\n            strengths[strength] =\
    \ 1\n        else\n            strengths[strength] = strengths[strength] + 1\n\
    \        end\n        local counts[strength] = counts[strength] + 1\n    end\n\
    \    local max = 0\n    local maxStrength = nil\n    for _, strength in ipairs(strengths)\
    \ do\n        if max < strength then\n            max = strength\n           \
    \ maxStrength = strength\n        end\n    end\n    if maxStrength == nil then\n\
    \        return 'error'\n    end\n    if #counts[maxStrength] == 1 then\n    \
    \    return class_name .. '.' .. extensions[#extensions]\n    end\n    local maxCount\
    \ = 0\n    for _, count in ipairs(counts[maxStrength]) do\n        if maxCount\
    \ < count then\n            maxCount = count\n        end\n    end\n    return\
    \ class_name .. '.' .. extensions[#extensions]\nend", "    local strongest_extension\
    \ = {}\n    for _,extension in ipairs(extensions) do\n        local CAP = #extension\n\
    \        local SM = #class_name:upper()\n        if CAP - SM > 0 then\n      \
    \      local strength = CAP - SM\n            if strength > 0 then\n         \
    \       table.insert(strongest_extension, extension..'_'..class_name:sub(1, strength-1))\n\
    \            end\n        end\n    end\n    if #strongest_extension > 1 then\n\
    \        return table.remove(strongest_extension, 1)\n    else\n        return\
    \ strongest_extension[1]\n    end\nend\n</code>\n<|/ a tags=lua-table,lua |>\n\
    <| c |>\nThanks for the answer. Your code works perfect but I'm still having trouble\
    \ understanding it. I have looked up what sub and upper do. But the problem I'm\
    \ having is that I cannot figure out what \"class_name:sub(1, strength-1)\" does.\
    \ What does it do? Does it remove the first letter of the extension (first letter\
    \ is capital)? Thank you so much for your time and effort. I'm really new to lua\
    \ and i'm trying to learn as I go.\n<|/ c |>\n<| c |>\n`extension:sub(1, strength-1)`\
    \ removes the first character of the extension (the character is uppercase and\
    \ it is \"removed\" from the string). `class_name:sub(1, strength-1)` removes\
    \ the first letter of the class (`class_name` is the class name and `:sub(1,strength-1)`\
    \ is the part of a string from the first character to the first `strength - 1`\
    \ characters). So if you have a class `'AAB'` and an extensions `{'AA', 'BBB'}`\
    \ then the extension `'AA'` is \"removed\" from the class `'AAB'`, then `'BB'`\
    \ is \"removed\" from the class `'AAB'` and so on. The reason for using only `:sub(1,strength-1)`\
    \ is to avoid counting \"the spaces\" in the extension.\n<|/ c |>\n<| c |>\nI\
    \ see, thank you so much. I'm learning lua as I go so this was very helpful!\n\
    <|/ c |>\n<| c |>\nIf you find my answer helpful then please consider to accept\
    \ it.\n<|/ c |>\n<| c |>\nSorry for asking so much questions, I'm struggling a\
    \ little bit now and i'm not even getting this error : Attempt to index a nil\
    \ value (global 'class_name'). I'm new to lua and I'm struggling with understanding\
    \ the problem so I appreciate your patience. Thanks.\n<|/ c |>", "   local strongest_extension\
    \ = {}\n   for _, extension in ipairs(extensions) do\n      local cap = string.match(extension,\
    \ \"%w\")\n      local sm = string.match(extension, \"%W\")\n      if cap and\
    \ sm then\n         local strength = cap - sm\n         if strength > -1 then\n\
    \            if #strongest_extension < strength then\n               table.insert(strongest_extension,\
    \ extension)\n            end\n         elseif #strongest_extension == strength\
    \ then\n            table.insert(strongest_extension, extension)\n         end\n\
    \      end\n   end\n   return string.gsub(class_name, \"^\" .. string.sub(class_name,\
    \ 1, 1), '')..\".\"..table.concat(strongest_extension, \"\")\nend", "\tlocal strongest\
    \ = {}\n\tfor k,v in pairs(extensions) do\n\t\tlocal ext = v:gsub(\"%l\", function(x)\n\
    \t\t\treturn string.upper(x)\n\t\tend)\n\t\tif strongest[ext] then\n\t\t\tif strongest[ext]\
    \ ~= 0 then\n\t\t\t\tif strongest[ext] < k then\n\t\t\t\t\tstrongest[ext] = k\n\
    \t\t\t\tend\n\t\t\telse\n\t\t\t\tstrongest[ext] = k\n\t\t\tend\n\t\telse\n\t\t\
    \tstrongest[ext] = k\n\t\tend\n\tend\n\tlocal res = string.sub(class_name,1,string.find(class_name,\
    \ \".\")-1)\n\tfor k,v in pairs(strongest) do\n\t\tres = string.sub(res, 1, string.find(res,\
    \ k)+1)\n\tend\n\treturn res\nend", "    -- TODO: Write your code here\nend",
  "  local strongest = {}\n  for _, e in ipairs(extensions) do\n    local num_upper\
    \ = e:find(upper(class_name))\n    local num_lower = e:find(lower(class_name))\n\
    \    local cap_upper = num_upper - num_lower\n    local sm = num_upper - cap_upper\n\
    \    if cap_upper > 0 and sm > 0 then\n      table.insert(strongest, e)\n    elseif\
    \ cap_upper > 0 then\n      table.remove(extensions, e)\n    elseif sm > 0 then\n\
    \      table.remove(extensions, e)\n    end\n  end\n  if #strongest == 0 then\
    \ \n    return '[ERROR] No extension with the name ' .. class_name .. ' could\
    \ be found'\n  end\n  if #strongest == 1 then\n    return strongest[1]\n  end\n\
    \  local i = #strongest - 1\n  while i ~= 1 do\n    local e = strongest[i]\n \
    \   if e[1] == strongest[i-1] then\n      table.remove(extensions, e)\n    else\n\
    \      i = i - 1\n    end\n  end\n  return 'my_class.' .. strongest[1]\nend",
  "    -- base case\n    if extensions.size == 0 then\n        return class_name\n\
    \    end", "  local max_strength = -1\n  local max_extension = ''\n  for _, extension\
    \ in ipairs(extensions) do\n    local extension_strength = string.lower(extension:gsub('.%',\
    \ '%'))\n    if extension_strength > max_strength then\n      max_strength = extension_strength\n\
    \      max_extension = extension\n    end\n  end\n  return class_name .. '.' ..\
    \ max_extension\nend", "\tlocal cap = #class_name\n\tlocal sm = #class_name:lower()\n\
    \tlocal cap_score = cap - sm\n\tlocal score = -cap_score\n\tlocal strongest, strongest_score\
    \ = '', 0", "\tassert(class_name, 'class_name is required')\n\tassert(extensions,\
    \ 'extensions is required')", "  if extensions == nil then\n    return class_name\n\
    \  end\n  local strength = nil\n  local index = 1\n  for extension in extensions\
    \ do\n    local n = #extension\n    if n == 0 then\n      n = 1\n    end\n   \
    \ local cap = string.upper(extension:sub(1, n))\n    local sm = #string.lower(extension:sub(n,\
    \ n))\n    local cap_diff = (#cap - sm) * -1\n    if strength == nil or strength\
    \ > cap_diff then\n      strength = cap_diff\n      index = #extensions\n    end\n\
    \  end\n  return class_name .. '.' .. extensions[index]\nend", "    local function\
    \ strongest_extension(extension)\n        local CAP = #extension\n        local\
    \ SM = #tolower(extension)\n        local strength = -(CAP - SM)\n        local\
    \ max_strength = #extensions\n        if strength == max_strength then\n     \
    \       return extension\n        elseif strength > max_strength then\n      \
    \      return nil\n        else\n            return extensions[strength]\n   \
    \     end\n    end\n    return class_name .. \".\" .. strongest_extension(extensions[1])\
    \ .. \".\" .. strongest_extension(extensions[2])\nend", "    if extensions ==\
    \ nil then\n        extensions = {}\n    end\n    local strongest = \"\"\n   \
    \ for i = 1, #extensions do\n        local capitals = 0\n        local lowercases\
    \ = 0\n        for j = 1, #extensions[i] do\n            if stringx:upper(extensions[i][j])\
    \ == extensions[i][j] then\n                capitals = capitals + 1\n        \
    \    else\n                lowercases = lowercases + 1\n            end\n    \
    \    end\n        if capitals > lowercases then\n            strongest = class_name..extensions[i]\n\
    \        else\n            strongest = class_name..extensions[i][#extensions[i]]\n\
    \        end\n    end\n    return strongest\nend", "    local max_extension, min_extension\
    \ = 0, 0\n    for _, extension in ipairs(extensions) do\n        local cap = string.match(extension,\
    \ \"(.)(.)\"):match(\"..(..)\")\n        local sm = string.match(extension, \"\
    (.)\"):match(\"..(..)\")\n        local strength = cap - sm\n        if (strength\
    \ > max_extension) then\n            max_extension = strength\n        end\n \
    \       if (strength < min_extension) then\n            min_extension = strength\n\
    \        end\n    end\n    if (max_extension > min_extension) then\n        return\
    \ string.format(class_name .. '.%s%s',\n                             string.sub(class_name,\
    \ 1, string.len(class_name) - 1),\n                             extensions[max_extension])\n\
    \    end\n    return ''\nend", "   local strongest_extension = {} -- To store\
    \ the extension that was chosen first\n   for _, extension in ipairs(extensions)\
    \ do\n      local cap = tonumber(extension:match('%[%a]'))\n      local sm = tonumber(extension:match('%[%A]'))\n\
    \      local strength = cap - sm -- The strength of the extension is given by\
    \ CAP - SM\n      if strength == 0 then break end\n      if #strongest_extension\
    \ == 0 then strongest_extension = extension end\n      if strongest_extension.strength\
    \ < strength then\n         strongest_extension.name = extension\n         strongest_extension.strength\
    \ = strength\n      end\n   end\n   return class_name..'.'..strongest_extension.name\n\
    end", "    -- TODO: Write code here\n    \nend", "    local max_strength = -1\n\
    \    local max_extension_name = \"\"\n    local count = {}\n    for _, extension\
    \ in pairs(extensions) do\n        local cap = string.upper(extension:sub(1,1))\n\
    \        local sm = string.lower(extension:sub(1,1))\n        if cap:sub(1,1)\
    \ == sm:sub(1,1) then\n            count[cap] = count[cap] + 1\n        elseif\
    \ cap:sub(1,1) < sm:sub(1,1) then\n            count[cap] = count[cap] + 1\n \
    \       elseif cap:sub(1,1) > sm:sub(1,1) then\n            count[sm] = count[sm]\
    \ + 1\n        end\n    end\n    for _, item in pairs(count) do\n        if max_strength\
    \ < item then\n            max_strength = item\n            max_extension_name\
    \ = class_name\n        end\n    end\n    return max_extension_name\nend", " \
    \ local streng = {}\n  for _, e in ipairs(extensions) do\n    streng[#streng +\
    \ 1] = e .. '.' .. class_name\n  end\n  table.sort(streng)\n  return streng[1]\n\
    end\n</cell>\n<text>\nThe next cell will load the classroom extension into the\
    \ class we already created and print out the strongest extension.", "    assert(type(extensions)\
    \ == 'table')\n    local strongest_extensions = {}\n    for i = 1,#extensions\
    \ do\n        local extension = extensions[i]\n        local cap_counter = 0\n\
    \        for letter in string.gsub(extension, '_', '') do\n            cap_counter\
    \ = cap_counter + tolower(letter)\n        end\n        local sm_counter = 0\n\
    \        for letter in string.gsub(extension, '_', '') do\n            sm_counter\
    \ = sm_counter + tolower(letter)\n        end\n        local strength = cap_counter\
    \ - sm_counter\n        if (strength > 0) then\n            table.insert(strongest_extensions,\
    \ class_name .. '.' .. extension)\n        end\n    end\n    if #strongest_extensions\
    \ > 0 then\n        local strength_counter = 0\n        for i = 1,#strongest_extensions\
    \ do\n            local extension = strongest_extensions[i]\n            local\
    \ cap_counter = 0\n            for letter in string.gsub(extension, '_', '') do\n\
    \                cap_counter = cap_counter + tolower(letter)\n            end\n\
    \            local sm_counter = 0\n            for letter in string.gsub(extension,\
    \ '_', '') do\n                sm_counter = sm_counter + tolower(letter)\n   \
    \         end\n            local strength = cap_counter - sm_counter\n       \
    \     if (strength > strength_counter) then\n                strength_counter\
    \ = strength\n                table.insert(strongest_extensions, extension)\n\
    \            end\n        end\n    end\n    table.sort(strongest_extensions, function(a,b)\n\
    \        return string.sub(a,1,string.len('')) - string.sub(b,1,string.len(''))\n\
    \    end)\n    local index = -1\n    for i = 1,#strongest_extensions do\n    \
    \    index = index + 1\n        if (string.find(strongest_extensions[i], '.')\
    \ == #strongest_extensions) then\n            return strongest_extensions[i]\n\
    \        end\n    end\n    return ''\nend", "  local min_strength = extensions[1]\n\
    \  for i = 2, #extensions do\n    if extensions[i]:lower() - min_strength:lower()\
    \ == 0 then \n      min_strength = extensions[i]\n    end\n  end\n  return class_name:concat('.'\
    \ .. min_strength:lower())\nend", "  -- Write your solution here\n  local strongest_extension_found\
    \ = false\n  local strongest_extension = ''\n  for _, extension in ipairs(extensions)\
    \ do\n    if extension:find(class_name, 1, true) then\n      if strongest_extension_found\
    \ then\n        strongest_extension = extension\n        break\n      else\n \
    \       strongest_extension_found = true \n      end\n    end\n  end\n  return\
    \ strongest_extension\nend", "  local extensions_length = #extensions;\n  local\
    \ max_extension_strength = -1\n  local max_extension_class = nil\n  for i=1,extensions_length\
    \ do\n    local extension = extensions[i]\n    local extension_class_name = class_name:sub(1,class_name:find(extension))\n\
    \    local extension_strength = #extension_class_name:sub(1,extension_class_name:find(extension))\n\
    \    if (max_extension_strength < extension_strength) then\n      max_extension_strength\
    \ = extension_strength\n      max_extension_class = extension_class_name\n   \
    \ end\n  end\n  return max_extension_class .. (extensions_length > 1 and '' or\
    \ '.' .. max_extension_strength)\nend", "    local class_extensions = {}\n   \
    \ for _, extension_name in ipairs(extensions) do\n        local cap = extension_name:match('^%u+%u+')\n\
    \        local sm = extension_name:match('^%l+%l+')\n        local strength =\
    \ cap - sm\n        table.insert(class_extensions, {extension_name, strength})\n\
    \    end", "    if #extensions == 0 then\n        return '' -- No extensions\n\
    \    end\n    local strength = 0\n    local max = 0\n    for _, extension in ipairs(extensions)\
    \ do\n        if string.find(class_name, extension, 1, true) then\n          \
    \  local c, s, m = string.match(class_name, '(.)%s(.)%s(.)')\n            if s\
    \ > strength then\n                strength = s\n                max = c\n   \
    \         end\n        end\n    end\n    return string.gsub(class_name, '(.)%s(.)%s(.)',\
    \ \n            '\\1%s.\\2', \n            string.gsub(max, '(.)%s(.)%s(.)', \n\
    \            '\\1%s.\\2', \n            strength))\nend", "\tlocal strengths =\
    \ {} -- To store the strengths of extensions\n\tlocal first_extension = nil --\
    \ To store the extension that comes first\n\tlocal last_extension = nil -- To\
    \ store the extension that comes last\n\tfor extension in pairs(extensions) do\n\
    \t\tlocal str = string.sub(class_name, 0, string.len(extension)) + extension\n\
    \t\tlocal length = string.len(str)\n\t\tlocal cap = string.upper(str)\n\t\tlocal\
    \ sm = string.lower(str)\n\t\tlocal strength = length - cap - sm\n\t\tif strengths[length]\
    \ == nil then\n\t\t\tstrengths[length] = strength\n\t\telseif strengths[length]\
    \ > strength then\n\t\t\tlast_extension = extension\n\t\t\tfirst_extension = extension\n\
    \t\t\tstrengths[length] = strength\n\t\telseif strengths[length] < strength then\n\
    \t\t\tlast_extension = first_extension\n\t\t\tfirst_extension = extension\n\t\t\
    \tstrengths[length] = strength\n\t\tend\n\tend\n\tif #strengths > 1 then\n\t\t\
    local total_strength = sum(pairs(strengths))\n\t\tlocal max_strength = max_key(pairs(strengths))\n\
    \t\tfor i = 1, total_strength do\n\t\t\tlocal extension = first_extension + string.format(\"\
    \ - %s\", last_extension)\n\t\t\t-- print(extension)\n\t\t\t-- print(class_name)\n\
    \t\t\t-- print('Strongest extension with strength: ' .. class_name .. '.' .. extension\
    \ .. '.')\n\t\t\t-- print('Total strength: ' .. total_strength .. '.')\n\t\t\t\
    -- print('Max strength: ' .. max_strength .. '.')\n\t\t\t-- print('Extension:\
    \ ' .. extension)\n\t\t\tif string.find(extension, \".\") then\n\t\t\t\textension\
    \ = string.sub(extension, string.len(extension) - 1)\n\t\t\tend\n\t\t\t-- print(class_name\
    \ .. '.' .. extension .. '.')\n\t\t\tif string.find(class_name, \".\") then\n\t\
    \t\t\tclass_name = string.sub(class_name, string.len(class_name) - 1)\n\t\t\t\
    end\n\t\t\tif string.find(extension, \".\") then\n\t\t\t\textension = string.sub(extension,\
    \ string.len(extension) - 1)\n\t\t\tend\n\t\t\tif string.find(class_name, \".\"\
    ) then\n\t\t\t\tclass_name = string.sub(class_name, string.len(class_name) - 1)\n\
    \t\t\tend\n\t\t\tif total_strength > 1 then\n\t\t\t\treturn class_name .. '.'\
    \ .. extension .. '.'\n\t\t\tend\n\t\tend\n\tend\nend", "   for _, extension in\
    \ ipairs(extensions) do\n      local name_length = #extension\n      local first_upper\
    \ = string.sub(class_name, 1, name_length) \n      local first_lower = string.sub(class_name,\
    \ 1, name_length) \n      local strength = math.abs(first_upper-first_lower)\n\
    \      if strength > 1 then\n         for i=1,strength do\n            class_name\
    \ = string.sub(class_name, 1, name_length+i)\n         end\n      end\n      if\
    \ first_upper == first_lower then\n         return class_name .. extension\n \
    \     else\n         return class_name .. first_upper .. extension \n      end\n\
    \   end\n   return class_name\nend", "\tlocal str_extensions = {}\n\tfor i=1,#extensions\
    \ do\n\t\tlocal str_extension = extensions[i]\n\t\tlocal cap_letters, sm_letters,\
    \ count = 0, 0, 0\n\t\tfor j,k in pairs(str_extension:gsub(\"%([A-Z]*)%\", \"\
    %1\")) do\n\t\t\tcount = count + 1\n\t\t\tif k:upper() ~= k then\n\t\t\t\tcap_letters\
    \ = cap_letters + 1\n\t\t\telse\n\t\t\t\tsm_letters = sm_letters + 1\n\t\t\tend\n\
    \t\tend\n\t\tlocal strength = cap_letters - sm_letters\n\t\tif strength > 0 then\n\
    \t\t\ttable.insert(str_extensions, str_extension)\n\t\telse\n\t\t\ttable.insert(str_extensions,\
    \ str_extension..\"_\" .. strength)\n\t\tend\n\tend\n\ttable.sort(str_extensions)\n\
    \tlocal strongest_extension = str_extensions[1]\n\tfor i=2,#str_extensions do\n\
    \t\tif str_extensions[i]:sub(1,1) = strongest_extension:sub(1,1) then\n\t\t\t\
    strongest_extension = strongest_extension:sub(2)\n\t\telse\n\t\t\tstrongest_extension\
    \ = strongest_extension..\".\"..str_extensions[i]\n\t\tend\n\tend\n\treturn class_name\
    \ .. '.' .. strongest_extension\nend", "   local class_name = string.format('%s.%s',\
    \ class_name, string.upper(string.sub(class_name, 1, 1)) - string.lower(string.sub(class_name,\
    \ 1, 1)) + 1)\n   local extension_table = {}\n   for _, extension in ipairs(extensions)\
    \ do\n      local extension_class_name = string.format('%s.%s', class_name, extension)\n\
    \      table.insert(extension_table, extension_class_name)\n   end\n   table.sort(extension_table)\n\
    \   local strongest_extension = extension_table[1]\n   for _, extension in ipairs(extension_table)\
    \ do\n      if extension == strongest_extension then\n         strongest_extension\
    \ = extension\n      end\n   end\n   return strongest_extension\nend", "\tlocal\
    \ max = 0\n\tlocal strongest = ''", "  local strongest_extension = extensions[1]\n\
    \  for _, extension in ipairs(extensions) do\n    local cap = string.upper(extension:sub(1,\
    \ -1))\n    local sm = string.lower(extension:sub(1, -1))\n    local strength\
    \ = cap - sm\n    if strength == 0 then\n      break\n    end\n    if strength\
    \ > strongest_extension:len() then\n      strongest_extension = extension\n  \
    \  end\n  end\n  return string.sub(class_name, '.', -1..(strongest_extension:len()))\
    \ .. '.' .. strongest_extension\nend", "  local strongest, strong, count = 0,\
    \ -1, 0\n  local i = 1\n  for ext,s in pairs(extensions) do\n    local cap, sm\
    \ = string.gsub(ext, \"%a\", \"\")\n    local cap_delta = cap - sm\n    \n   \
    \ if cap_delta > 0 then\n      if cap_delta > count then\n        count, strong,\
    \ strongest = cap_delta, ext, ext\n      else\n        count = count + cap_delta\n\
    \      end\n    end\n  end\n  \n  if strongest ~= nil then\n    return string.gsub(class_name,\
    \ \".\", \".[\"..strong..\"]\")..strongest\n  end\nend\n  ", "  if extensions.__len\
    \ == 0 then\n    return class_name\n  else\n    local max_index = extensions:find(function(x)\n\
    \      return x:upper():match(\"^%l\")\n    end)\n    if max_index == nil then\n\
    \      return class_name\n    else\n      local count = 0\n      for index, _\
    \ in pairs(extensions) do\n        if index:upper():match(\"^%l\") > max_index:upper():match(\"\
    ^%l\") then\n          count = count + 1\n        end\n      end\n      local\
    \ strength = math.abs(count - #extensions) / #extensions\n      return class_name\
    \ .. '.' .. extensions[max_index] .. '.' .. extensions[max_index] .. '(' .. tostring(strength)\
    \ .. ')'\n    end\n  end\nend", "    assert(extensions[#extensions] == 0)\n  \
    \  local strongest_ext = nil\n    for i=1,#extensions do\n        local extension\
    \ = extensions[i]\n        local cap = #extension:gsub(\"[A-Z]\", '#'):upper()\n\
    \        local sm = #extension:gsub(\"[a-z]\", '#'):lower()\n        if (cap -\
    \ sm) == 0 then\n            assert(strongest_ext == nil)\n            strongest_ext\
    \ = extension\n        else\n            local strength = cap - sm\n         \
    \   if strength > 0 then\n                if strongest_ext == nil then\n     \
    \               strongest_ext = extension\n                else\n            \
    \        if strength > strongest_ext:len() then\n                        strongest_ext\
    \ = extension\n                    end\n                end\n            else\n\
    \                assert(strongest_ext == nil)\n                strongest_ext =\
    \ extension\n            end\n        end\n    end\n    return class_name .. \"\
    .\" .. strongest_ext\nend", "\tif extensions.size == 0 then return nil end\n\t\
    local min_str = ''\n\tlocal max_str = ''\n\tlocal min_value = nil\n\tlocal max_value\
    \ = nil\n\tfor _, extension in pairs(extensions) do\n\t\tif extension:match('^([A-Z]{1})([a-z]*)$')\
    \ then\n\t\t\tlocal cap = tonumber(extension:sub(1,2))\n\t\t\tlocal sm = tonumber(extension:sub(-2,-1))\n\
    \t\t\tlocal diff = cap - sm\n\t\t\tif min_value ~= nil and diff < min_value then\n\
    \t\t\t\tmin_value = diff\n\t\t\t\tmin_str = extension\n\t\t\telseif max_value\
    \ ~= nil and diff > max_value then\n\t\t\t\tmax_value = diff\n\t\t\t\tmax_str\
    \ = extension\n\t\t\tend\n\t\tend\n\tend\n\treturn class_name .. '.' .. min_str\
    \ .. '.' .. max_str\nend", "    -- Your code here\n    local Strongest_Extension_Count\
    \ = 0;\n    for _, extension in ipairs(extensions) do\n        if string.upper(extension:sub(1,1))\
    \ ~= string.upper(extension:sub(1,1:upper(extension:sub(1,1):lower()))) then\n\
    \            Strongest_Extension_Count = (Strongest_Extension_Count - 1)\n   \
    \     else\n            if string.lower(extension:sub(1,1)) == string.lower(extension:sub(1,1:upper(extension:sub(1,1):lower())))\
    \ then\n                Strongest_Extension_Count = (Strongest_Extension_Count\
    \ + 1)\n            end\n        end\n    end\n    \n    if Strongest_Extension_Count\
    \ ~= 0 then\n        local Strongest_Extension_Strength = 0;\n        for _, extension\
    \ in ipairs(extensions) do\n            if string.upper(extension:sub(1,1)) ~=\
    \ string.upper(extension:sub(1,1:upper(extension:sub(1,1):lower()))) then\n  \
    \              Strongest_Extension_Strength = (Strongest_Extension_Strength -\
    \ 1)\n            else\n                if string.lower(extension:sub(1,1)) ==\
    \ string.lower(extension:sub(1,1:upper(extension:sub(1,1):lower()))) then\n  \
    \                  Strongest_Extension_Strength = (Strongest_Extension_Strength\
    \ + 1)\n                end\n            end\n        end\n        Strongest_Extension_Strength\
    \ = (Strongest_Extension_Strength / Strongest_Extension_Count)\n    end\n    \n\
    \    if Strongest_Extension_Count ~= 0 and Strongest_Extension_Strength >= 2 then\n\
    \        return class_name .. '.' .. extensions[#extensions]\n    end\n    return\
    \ nil\nend", "   -- TODO: Implement Function\nend", "   local strongest = -1\n\
    \   local index = 1", "\tlocal max = 0 \n\tfor _, ext in pairs(extensions) do\n\
    \t\tlocal cap = #ext:match(string.upper)\n\t\tlocal sm = #ext:match(string.lower)\n\
    \t\tif cap > max then\n\t\t\tmax = cap\n\t\tend\n\t\tif sm > max then\n\t\t\t\
    max = sm\n\t\tend\n\tend\n\tlocal result\n\tfor _, ext in pairs(extensions) do\n\
    \t\tif #ext:match(string.upper) == max then\n\t\t\tresult = class_name .. '.'\
    \ .. ext\n\t\t\tbreak\n\t\tend\n\tend\n\treturn result\nend", "\tlocal i, strongest\
    \ = 1, nil\n\tfor i,extension in ipairs(extensions) do\n\t\tlocal c1 = tostring(class_name)\n\
    \t\tlocal c2 = tostring(extension)\n\t\tlocal s1,s2,s3 = {}, {}, {}\n\t\tfor k,v\
    \ in pairs(c1) do\n\t\t\ts1[k] = s1[k] or v\n\t\tend\n\t\tfor k,v in pairs(c2)\
    \ do\n\t\t\ts2[k] = s2[k] or v\n\t\tend\n\t\tfor k,v in pairs(s1) do\n\t\t\ts3[k]\
    \ = s3[k] or v\n\t\tend\n\t\tlocal c = s3\n\t\tfor k,v in pairs(s2) do\n\t\t\t\
    c[k] = c[k] or v\n\t\tend\n\t\tlocal e = #c\n\t\t\n\t\tif #s1 > #s2 then\n\t\t\
    \te = #s1\n\t\tend\n\t\t\n\t\tif #s1 < #s2 then\n\t\t\te = #s2\n\t\tend\n\t\t\n\
    \t\tif s1[e] > s2[e] then\n\t\t\tstrongest = extension\n\t\t\tbreak\n\t\tend\n\
    \tend\n\t\n\treturn class_name .. '.' .. strongest\nend", "\tlocal strongest_extension\
    \ = nil\n\tfor _, extension in pairs(extensions) do\n\t\tlocal cap = string.upper(extension:sub(1,\
    \ #extension))\n\t\tlocal sm = string.lower(extension:sub((#extension + 1)));\n\
    \t\tif cap - sm > strongest_extension then\n\t\t\tstrongest_extension = extension\n\
    \t\tend\n\tend\n\treturn string.sub(class_name, 1, #class_name-1) .. strongest_extension\n\
    end", "    -- Set up some variables we'll need\n    local extension_strongest,\
    \ extension_strength = nil, 0\n    -- Set up the output string\n    local strongest_extension\
    \ = class_name\n    -- Loop through the extensions, counting up the strength\n\
    \    for _, extension in ipairs(extensions) do\n        if string.find(extension,\
    \ '_') then\n            local letter_count = #extension:gsub('_', ''):lower()\
    \ - #extension:gsub('%c', ''):lower()\n            -- If the extension letters\
    \ have the same count, choose the one with the smallest index\n            if\
    \ letter_count > 0 then\n                if extension_strength < letter_count\
    \ then\n                    extension_strength = letter_count\n              \
    \      extension_strongest = extension\n                end\n            end\n\
    \        end\n    end\n    -- Return the strongest extension\n    return strongest_extension\n\
    end", "    local extensions_map = {}\n    for i = 1, #extensions do\n        local\
    \ extension = extensions[i]\n        local letters = #extension:upper() - #extension:lower()\n\
    \        local strength = letters / #class_name\n        local extensions_map[strength]\
    \ = extension\n    end\n    \n    local extensions_strengths = #extensions_map\n\
    \    if extensions_strengths == 0 then\n        return class_name\n    end\n \
    \   \n    local max_strength = extensions_strengths\n    local max_extension =\
    \ \"\"\n    local max_class_name = class_name\n    for i = 1, extensions_strengths\
    \ do\n        if i > 1 then\n            if extensions_map[i] > extensions_map[max_strength]\
    \ then\n                max_strength = i\n                max_extension = extensions_map[max_strength]\n\
    \                max_class_name = class_name\n            end\n        else\n\
    \            max_strength = i\n            max_extension = extensions_map[max_strength]\n\
    \            max_class_name = class_name\n        end\n    end\n    return max_class_name\
    \ .. \".\" .. max_extension\nend", "  local highest_strength = -1\n  local highest_idx\
    \ = 0\n  for idx, extension in ipairs(extensions) do\n    local cap = extension:upper():byte()\n\
    \    local sm = extension:lower():byte()\n    local strength = cap - sm\n    if\
    \ strength > highest_strength or highest_strength == -1 then\n      highest_strength\
    \ = strength\n      highest_idx = idx\n    end\n  end\n  return class_name ..\
    \ '.' .. extensions[highest_idx] \nend", "\tlocal max_strongest = -1\n\tlocal\
    \ max_extension = \"\"\n\tlocal total_cap = 0\n\tlocal total_sm = 0\n\tfor _,\
    \ extension in ipairs(extensions) do\n\t\tlocal cap = string.upper(extension):len()\n\
    \t\tlocal sm = string.lower(extension):len()\n\t\tif cap > total_cap then\n\t\t\
    \ttotal_cap = cap\n\t\tend\n\t\tif sm > total_sm then\n\t\t\ttotal_sm = sm\n\t\
    \tend\n\tend\n\tif total_cap - total_sm ~= 0 then\n\t\tmax_strongest = total_cap\
    \ - total_sm\n\telse\n\t\tmax_strongest = total_cap\n\tend\n\tfor _, extension\
    \ in ipairs(extensions) do\n\t\tlocal cap = string.upper(extension):len()\n\t\t\
    local sm = string.lower(extension):len()\n\t\tif cap - sm ~= 0 then\n\t\t\tif\
    \ cap > max_strongest then\n\t\t\t\tmax_strongest = cap\n\t\t\t\tmax_extension\
    \ = extension\n\t\t\tend\n\t\tend\n\tend\n\treturn \"%s.%s\"..class_name, max_extension\n\
    end", "    assert(class_name and extensions)\n    local best_extension = extensions[1]\n\
    \    local best_strength = -1\n    for _, extension in pairs(extensions) do\n\
    \        local strength = string.gsub(class_name, extension, \"[^A-Z]\") -- Remove\
    \ extension from class name\n        if strength ~= nil then\n            if strength\
    \ > best_strength then\n                best_extension = extension\n         \
    \       best_strength = strength\n            end\n        end\n    end\n    if\
    \ best_strength >= 0 then\n        return string.format(class_name, best_extension,\
    \ best_strength)\n    else\n        return nil\n    end\nend", "  local max_strength\
    \ = -1;\n  local max_extension;\n  \n  for _, extension in ipairs(extensions)\
    \ do\n    if extension:match('^[%a%c%u]+$') then\n      local strength = extension:lower():upper():len();\n\
    \      if strength > max_strength then\n        max_strength = strength;\n   \
    \     max_extension = extension;\n      end\n    end\n  end\n  return string.gsub(class_name,\
    \ \"[%a%c%u]+\", \"\") .. max_extension;\nend", "    local strengths = {}\n  \
    \  for _,extension in ipairs(extensions) do\n        local _, s = extension:match(\"\
    ^(.):(.)\")\n        local _, c = extension:match(\"^(.)%%(.):(.)\")\n       \
    \ local s, c = s:toupper(), c:toupper()\n        -- If c is longer than s, ignore\
    \ it.\n        if #c > #s then continue end\n        strengths[s] = c\n    end\n\
    \    local strength = #strengths\n    -- Find the strongest extension\n    local\
    \ _,strongest = table.max(pairs(strengths))\n    -- Return the class name with\
    \ the strongest extension\n    return class_name .. '.' .. strongest\nend", " \
    \ local strongest_extension\n  local cap_counter = 0\n  local sma_counter = 0\n\
    \  for i, extension in pairs(extensions) do\n    local cap_count = cap_counter\
    \ + #extension:upper()\n    local sma_count = sma_counter + #extension:lower()\n\
    \    local frac = cap_count - sma_count\n    if frac > 0 then\n      strongest_extension\
    \ = class_name .. \".\" .. extension:sub(1,cap_counter) ..\n        extension:sub(cap_count)\n\
    \      cap_counter = cap_count\n      sma_counter = sma_count\n    end\n  end\n\
    \  return strongest_extension\nend", "    assert(class_name, 'Class name is a\
    \ string')\n    assert(extensions, 'Extensions is a table')\n    local extension_sum\
    \ = 0\n    for _, extension in ipairs(extensions) do\n        local cap, sm =\
    \ string.match(extension, '_%[A-z]%d')\n        assert(cap and sm, 'Extension\
    \ name does not match the expected format')\n        extension_sum = extension_sum\
    \ + cap - sm\n    end\n    return string.sub(class_name, 1, string.len(class_name)\
    \ - 1) .. '.' .. \n           string.sub(class_name, string.len(class_name) -\
    \ 1, string.len(class_name)) .. \n           string.format('%1', extensions[math.floor(extension_sum)])\n\
    end", "    local classname = class_name -- We don't want class name to be modified\n\
    \    local strongest_extension\n    local cap = #classname -- Capital letters\
    \ count in the name\n    local sm = #classname -- Small letters count in the name\n\
    \    local cap_count = 0 -- Capital letters count in the class name\n    local\
    \ sm_count = 0 -- Small letters count in the class name\n    local extension_length\
    \ = #extensions -- The count of extensions\n    for i,e in pairs(extensions) do\
    \ \n        e = e:lower() -- We convert the extension name to lower case\n   \
    \     cap_count = cap_count + cap:find(e)\n        sm_count = sm_count + sm:find(e)\n\
    \    end\n    strongest_extension = classname .. '_' .. cap:sub(1,cap-cap_count)\
    \ .. '_' .. sm:sub(1,sm-sm_count)\n    for i,e in pairs(extensions) do \n    \
    \    e = e:lower() -- We convert the extension name to lower case\n        if\
    \ cap_count+cap:find(e) > sm_count+sm:find(e) then\n            strongest_extension\
    \ = strongest_extension .. '_' .. e\n        end\n    end\n    return strongest_extension\n\
    end", "    local max_extension_strength = -1\n    local max_extension_strongest\
    \ = nil\n    for _, extension_name in ipairs(extensions) do\n        local extension_strength\
    \ = extension_name:upper()\n        local extension_strongest = extension_name:sub(1,\
    \ extension_name:len():upper() - 1)\n        if extension_strength == max_extension_strength\
    \ then\n            if extension_strongest > max_extension_strongest then\n  \
    \              max_extension_strongest = extension_strongest\n            end\n\
    \        elseif extension_strength > max_extension_strength then\n           \
    \ max_extension_strength = extension_strength\n            max_extension_strongest\
    \ = extension_strongest\n        end\n    end\n    return string.format(\"%s.%s\"\
    , class_name, max_extension_strongest)\nend", "   local maxes = {}\n   for i=1,#extensions\
    \ do\n      local strength = extensions[i]\n      local classname = class_name\
    \ .. '.' .. extensions[i]\n      -- Add this extension name to maximums\n    \
    \  if maxes[strength] == nil then\n         maxes[strength] = {classname}\n  \
    \    else\n         maxes[strength][#maxes[strength]+1] = classname\n      end\n\
    \   end", "    local max_extension, min_extension = extensions[#extensions], extensions[1]\n\
    \    for i = 2, #extensions do\n        local extension = extensions[i]\n    \
    \    local letters = #class_name -- Length of class name\n        -- Compute number\
    \ of uppercase letters in extension\n        while letters > 0 and class_name[letters-1]\
    \ == '.' do\n            letters = letters - 1\n        end\n        -- Compute\
    \ number of lowercase letters in extension\n        local sm = #extension\n  \
    \      while sm > 0 and extension[sm-1] == '.' do\n            sm = sm - 1\n \
    \       end\n        -- Compare extension strengths\n        local strength =\
    \ letters - sm\n        if strength > 0 then\n            if strength > max_strength\
    \ then\n                max_extension = extension\n                max_strength\
    \ = strength\n            elseif strength == max_strength then\n             \
    \   -- Choose the extension that comes first\n                if min_strength\
    \ < strength then\n                    min_extension = extension\n           \
    \         min_strength = strength\n                end\n            end\n    \
    \    end\n    end\n    -- Return a string with ClassName.STRONGEST_EXTENSION_LETTERS\n\
    \    local str = class_name .. '.'\n    if max_strength > 0 then\n        str\
    \ = str .. max_extension\n    elseif min_strength > 0 then\n        str = str\
    \ .. min_extension\n    end\n    return str\nend", "  local strongest_extension\
    \ = {}\n  local cap = 0\n  local sm = 0\n  for _, extension in ipairs(extensions)\
    \ do\n    local cap_s = extension:upper():byte()\n    local sm_s = extension:lower():byte()\n\
    \    local strength = cap_s - sm_s\n    if strength > 0 then\n      if cap ==\
    \ 0 then cap = cap_s end\n      if sm == 0 then sm = sm_s end\n      if cap +\
    \ sm >= strength then \n        strongest_extension[#strongest_extension+1] =\
    \ class_name .. \".\" .. extension\n        cap = cap_s\n        sm = sm_s\n \
    \     end\n    end\n  end\n  return table.concat(strongest_extension, \"\")\n\
    end", "  assert(type(class_name) == 'string')\n  assert(extensions ~= nil and\
    \ type(extensions) == 'table')", "  local strongest_extension = {}\n  for _, ext\
    \ in ipairs(extensions) do\n    local cap = #ext:upper()\n    local sm = #ext:lower()\n\
    \    local cap_diff = cap - sm\n    local strongest = ext == class_name or cap_diff\
    \ == 0\n    if not strongest then\n      table.insert(strongest_extension, {cap,\
    \ sm, ext})\n    end\n  end\n  if #strongest_extension > 0 then\n    return class_name\
    \ .. '.' .. table.unpack(table.sort(strongest_extension, '<', function(ext)\n\
    \      return ext.cap\n    end))[2].name\n  end\n  return class_name\nend", " \
    \ local strongest = extensions[1]\n  for i = 2, #extensions do\n    if extensions[i]\
    \ > strongest then\n      strongest = extensions[i]\n    end\n  end\n  return\
    \ class_name .. '.' .. strongest\nend", "    -- Base case\n    if not extensions\
    \ then\n        return class_name\n    end", "  if extensions.count == 0 then\n\
    \    return class_name\n  end", "\tif extensions == nil then return nil end\n\t\
    local strongest = nil\n\tfor i, e in ipairs(extensions) do\n\t\tif tonumber(e,\
    \ 16) < tonumber(strongest, 16) then\n\t\t\tstrongest = e\n\t\tend\n\tend\n\t\
    if tonumber(strongest, 16) == tonumber(class_name, 16) then\n\t\treturn strongest\n\
    \telse\n\t\treturn class_name .. '.' .. strongest\n\tend\nend", "  local max_strength,\
    \ extension = 1, extensions[1]\n  for _, e in pairs(extensions) do\n    if max_strength\
    \ > string.find(class_name, '[^' .. (string.upper(string.sub(class_name, 1, 1))\
    \ + string.lower(string.sub(class_name, 2, 1))) .. ']') then\n      max_strength\
    \ = string.find(class_name, '[^' .. (string.upper(string.sub(class_name, 1, 1))\
    \ + string.lower(string.sub(class_name, 2, 1))) .. ']')\n      extension = e\n\
    \    end\n  end\n  return class_name .. '.' .. extension\nend", "\tlocal sorted_extensions\
    \ = table.sort(extensions, function(a, b) return (a - b) end)\n\tlocal strongest\
    \ = sorted_extensions[1]\n\tfor _, extension in ipairs(sorted_extensions) do\n\
    \t\tif strongest.Strength > extension.Strength then\n\t\t\tstrongest = extension\n\
    \t\tend\n\tend\n\treturn string.sub(class_name, 1, #class_name - #strongest.Name)\
    \ .. strongest.Name\nend\n</cell>\n<text>\nQuestion 4\nNow that you've implemented\
    \ Strongest_Extension you can solve the Fourth\nProblem of Week 1 as follows:",
  "  local extensions_sorted = table.sort(extensions, function(a, b)\n    return a:upper():byte()\
    \ - b:upper():byte()\n  end)\n  local max_index = 1\n  local max_strength = 0\n\
    \  for index, extension in ipairs(extensions_sorted) do\n    local s = extension:byte()\n\
    \    if s > max_strength then\n      max_index = index\n      max_strength = s\n\
    \    end\n  end\n  return string.format(class_name..'.%s%s', class_name:lower(),\
    \ \n                       max_strength < 0 and 'Extension' or '', max_index)\n\
    end", "  local strongest = ''\n  for _, extension in ipairs(extensions) do\n \
    \   if string.upper(extension):gsub('%l', string.lower):sub(1,-string.upper(extension))-1\
    \ < 0 then\n      if strongest ~= '' then\n        return class_name .. '.' ..\
    \ strongest\n      else\n        return class_name\n      end\n    end\n    strongest\
    \ = extension\n  end\n  return class_name\nend", "\tlocal strongest, strength\
    \ = nil, nil -- We need to store the strongest\n\tlocal i, j, k -- Necessary iterators\
    \ to iterate the extension table and \n\t\t\t\t-- find their strength.", "   if\
    \ extensions == nil then\n      error(\"The extensions table is nil.\")\n   end\n\
    \   local strongest = nil\n   for i = 1, #extensions do\n      local cap = #string.format(extensions[i],\
    \ 1)\n      local sm = #string.format(extensions[i], 2)\n      if cap - sm > strongest\
    \ then\n         strongest = cap - sm\n         strongest_extension = extensions[i]\n\
    \      end\n   end\n   return string.format(class_name, strongest, strongest_extension)\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe code does not compile with the latest\
    \ version of Lua. `string.format` requires an argument of type `string`.\n<|/\
    \ c |>\n<| a tags=lua-table,lua,lua-patterns dscore=0 |>\nTry this:\n<code>",
  "    -- Your code here\n    local strongest_extension = {}\n    for i = 1, #extensions\
    \ do\n        local len = string.len(extensions[i])\n        if len ~= 0 then\n\
    \            local cap = string.sub(class_name, 1, #class_name-1)\n          \
    \  local sm = string.sub(class_name, #class_name, #class_name)\n            local\
    \ score = math.floor(cap - sm)\n            if score == 0 then\n             \
    \   score = -1\n            elseif score > 0 then\n                score = -1\n\
    \            elseif score < 0 then\n                score = 1\n            end\n\
    \            if strongest_extension[score] == nil then\n                strongest_extension[score]\
    \ = extensions[i]\n            else\n                table.insert(strongest_extension,\
    \ extensions[i])\n            end\n        end\n    end\n    table.sort(strongest_extension,\
    \ 1)\n    return strongest_extension[1]\nend", "    local class_name_length =\
    \ string.len(class_name)\n    if class_name_length < 1 then\n        return ''\n\
    \    end\n    local extension_length = #extensions\n    if extension_length <\
    \ 1 then\n        return ''\n    end\n    local strength = class_name_length -\
    \ 1\n    for index, extension in pairs(extensions) do\n        local extension_length\
    \ = string.len(extension)\n        local extension_class_name_length = string.len(extension:sub(1,1))\n\
    \        if extension_class_name_length < 1 then\n            error(\"The extension's\
    \ name cannot be empty\")\n        end\n        if extension_length < extension_class_name_length\
    \ then\n            error(\"The extension's name cannot be shorter than the class\
    \ name\")\n        end\n        if strength > extension_length then\n        \
    \    strength = extension_length\n        end\n    end\n    local extension_length\
    \ = string.len(extensions[strength])\n    if extension_length < 1 then\n     \
    \   error(\"The strongest extension is not in the table\")\n    end\n    return\
    \ class_name .. extensions[strength]\nend", "\tlocal min_strength = nil\n\tlocal\
    \ first_extension = nil\n\tfor _, extension in pairs(extensions) do\n\t\tlocal\
    \ letters = string.gsub(extension, \"[A-Z]\", \"\")\n\t\tlocal letters_count =\
    \ #letters\n\t\tlocal letters_count_upper = letters_count + #string.upper(letters)\n\
    \t\tlocal letters_count_lower = letters_count + #string.lower(letters)\n\t\tlocal\
    \ strength = letters_count_upper - letters_count_lower\n\t\tif min_strength ==\
    \ nil or strength < min_strength then\n\t\t\tmin_strength = strength\n\t\t\tfirst_extension\
    \ = extension\n\t\tend\n\tend\n\treturn class_name .. first_extension\nend", " \
    \ local strongest_extension = {}\n  for i = 1, #extensions do\n    if extensions[i]:find(class_name\
    \ .. '([A-Z]*)') ~= nil then\n      local cap = extensions[i]:find('[A-Z]')\n\
    \      local sm = extensions[i]:find('[a-z]')\n      if cap - sm > 0 then\n  \
    \      local index = i - 1\n        local strongest_extension_name = extensions[i]\n\
    \        for j = 1, cap - sm do\n          strongest_extension_name = strongest_extension_name\
    \ .. '_' .. extensions[j + 1]\n        end\n        strongest_extension = {strongest_extension_name,\
    \ cap - sm, extensions[index]}\n        break\n      end\n    end\n  end\n  if\
    \ #strongest_extension == 0 then\n    return 'NONE'\n  end\n  return '' .. class_name\
    \ .. '.' .. strongest_extension[1].. strongest_extension[2]\nend", "    local\
    \ extension = nil\n    local max_extension_strength = -1\n    local max_extension_strength_index",
  "  local strength = -math.inf\n  local result = class_name\n  for _, extension in\
    \ ipairs(extensions) do\n    if class_name:match(\"(.-)\" .. extension .. \"$\"\
    ) then\n      local letters = #extension\n      local cap_letters = math.floor(letters\
    \ / 2)\n      local sm_letters = letters - cap_letters\n      local cap_strength\
    \ = cap_letters * -1\n      local sm_strength = sm_letters * -1\n      if cap_strength\
    \ > strength then\n        strength = cap_strength\n        result = class_name:sub(1,\
    \ cap_letters)..extension\n      end\n      if sm_strength > strength then\n \
    \       strength = sm_strength\n        result = class_name..extension:sub(1)..class_name:sub(cap_letters\
    \ + 1)\n      end\n    end\n  end\n  return result\nend", "   local max_extension_strength\
    \ = -1\n   local max_extension_name = ''", "    local strongest_extension = {}\n\
    \    for _, extension in ipairs(extensions) do\n        local cap = string.upper(extension:sub(1,2))\n\
    \        local sm = string.lower(extension:sub(3, extension:len()))\n        local\
    \ strength = (cap - sm) / cap\n        table.insert(strongest_extension, string.sub(class_name,\
    \ 1, \n            string.len(class_name)-2), strength, extension)\n    end\n\
    \    table.sort(strongest_extension, function(a, b) return a[2] < b[2] end)\n\
    \    return string.sub(class_name, 1, string.len(class_name)-2) .. \n        \
    \   strongest_extension[1]\nend", "  local extension_strengths = { }\n  local\
    \ max_strength = -1\n  local max_index\n  for i = 1, #extensions do\n    local\
    \ extension = string.lower(extensions[i])\n    local strength = tonumber(string.gsub(extension,\
    \ '(.)', function(m)\n      return string.upper(m) .. '.'\n    end, 1))\n    if\
    \ strength > 0 then\n      extension_strengths[extension] = strength\n      if\
    \ strength > max_strength then\n        max_strength = strength\n        max_index\
    \ = i\n      end\n    end\n  end\n  \n  local strongest_extension = nil\n  local\
    \ best_index\n  for i, extension_strength in pairs(extension_strengths) do\n \
    \   if extension_strength == max_strength then\n      strongest_extension = extensions[i]\n\
    \      if best_index is nil then\n        best_index = i\n      else\n       \
    \ if extension_strengths[best_index] > extension_strength then\n          best_index\
    \ = i\n        end\n      end\n    end\n  end\n  return string.format(class_name,\
    \ '.', strongest_extension)\nend", "    local max_strength = -1\n    local max_extension\n\
    \    for _, extension in ipairs(extensions) do\n        local s = string.find(extension,\
    \ \"(.)\") - 1\n        local c = string.sub(extension, s, s - 1)\n        local\
    \ cap = string.find(c, string.upper(class_name))\n        local sm = string.find(c,\
    \ string.lower(class_name))\n        local strength = cap - sm\n        if strength\
    \ > max_strength then\n            max_extension = extension\n            max_strength\
    \ = strength\n        end\n    end\n    return string.sub(max_extension, 1, string.len(max_extension)-2)\n\
    end", "\tlocal max_strength = -1 -- Initialize the maximum strength to -1\n\t\
    for extension in extensions do\n\t\tlocal c, s = string.split(extension, \".\"\
    )\n\t\tlocal c = string.upper(c) -- Capitalize the class\n\t\tlocal s = string.lower(s)\
    \ -- Capitalize the strength\n\t\tlocal c = c..string.upper(s)\n\t\tlocal count\
    \ = {}\n\t\tfor i=1,#c do\n\t\t\tcount[i] = count[i] + 1 -- Count how many times\
    \ a letter appears\n\t\tend\n\t\tlocal cs = #c -- Get the number of letters in\
    \ the class\n\t\tlocal x = 0\n\t\tfor i=1,#s do -- Count how many times each letter\
    \ appears\n\t\t\tx = x + count[s[i]]\n\t\tend\n\t\tlocal strength = x - cs\n\t\
    \tif strength > max_strength then\n\t\t\tmax_strength = strength\n\t\t\tlocal\
    \ tmp = c ..'.'\n\t\t\tfor i=1,#s do -- Remove from the class all the letters\
    \ that appear more than once\n\t\t\t\tif count[s[i]]>1 then\n\t\t\t\t\ttmp = tmp\
    \ .. s[i]:lower() -- 'lower' is used to change all the letters to lowercase\n\t\
    \t\t\tend\n\t\t\tend\n\t\t\treturn tmp -- Return class + strongest extension\n\
    \t\tend\n\tend\n\treturn class_name .. '.'\nend", "\tassert(type(extensions) ~=\
    \ 'table')\n\tlocal extensions_count = {}\n\tfor k, v in pairs(extensions) do\
    \ \n\t\textensions_count[v] = extensions_count[v] or 0 \n\tend \n\tlocal strongest\
    \ = extensions[1]\n\tlocal strongest_strength = 0\n\tlocal strongest_extension\
    \ = class_name\n\tlocal strongest_extension_strength = -1\n\tfor k = 2, #extensions\
    \ do \n\t\tlocal extension = extensions[k]\n\t\tlocal extension_strength = extensions_count[extension]\n\
    \t\tif strongest_strength < extension_strength then\n\t\t\tstrongest_strength\
    \ = extension_strength\n\t\t\tstrongest_extension = extension\n\t\t\tstrongest_extension_strength\
    \ = extension_strength\n\t\telseif extension_strength > strongest_strength then\n\
    \t\t\tstrongest_extension_strength = extension_strength\n\t\tend \n\tend \n\t\
    return strongest_extension\nend", "   -- Write your code here\n   return class_name..extensions.sort():reverse():nth(1)\n\
    end", "\tlocal max = -1\n\tfor _,e in ipairs(extensions) do\n\t\tlocal c = string.upper(e):sub(1,1)\n\
    \t\tlocal s = string.upper(e):sub(2,2)\n\t\tlocal cap = #c\n\t\tlocal sm = #s\n\
    \t\tlocal diff = cap - sm\n\t\tif diff > 0 then\n\t\t\tmax = math.max(max, diff)\n\
    \t\tend\n\tend\n\tlocal index = #extensions \n\tfor i, e in ipairs(extensions)\
    \ do\n\t\tlocal c = string.upper(e):sub(1,1)\n\t\tlocal s = string.upper(e):sub(2,2)\n\
    \t\tlocal cap = #c\n\t\tlocal sm = #s\n\t\tlocal diff = cap - sm\n\t\tif diff\
    \ > 0 then\n\t\t\tif diff == max then\n\t\t\t\treturn class_name..'.'..e\n\t\t\
    \tend\n\t\tend\n\tend\nend", "   -- Your code here\nend", "    -- start with the\
    \ extension that comes first in the table\n    local strongest_extension = extensions[1]\n\
    \    for i = 2, #extensions do\n        -- if the name of the extension starts\
    \ with a lowercase letter,\n        -- then this extension is less strong than\
    \ the previous one.\n        if extensions[i][1] < strongest_extension[1] then\n\
    \            strongest_extension = extensions[i]\n        end\n    end\n    --\
    \ split the name of the class by uppercase letters and lowercase letters\n   \
    \ local class_name_splited = string.gsub(class_name, \"[A-Z]\", \"%s\")\n    local\
    \ extension_splited = string.gsub(strongest_extension, \"[A-Z]\", \"%s\")\n  \
    \  -- calculate the strength of the extension\n    local extension_strength =\
    \ extension_splited:sub(1, #class_name_splited) - extension_splited:sub(1, #extension_splited)\n\
    \    -- return the class name with the extension's name as the strongest extension\n\
    \    return string.gsub(class_name, \"%s\", extension_splited):gsub(\"%..%s\"\
    , extension_strength):gsub(\".\", \" \")\nend", "    local max_strength = -math.huge;\n\
    \    local max_name = class_name;\n    local extnum = 1;\n    for _, ext in ipairs(extensions)\
    \ do\n        local cap, sm = string.match(ext:lower(), '%a%c%s');\n        if\
    \ (cap > sm) then\n            extnum = extnum + 1;\n            if extnum > 1\
    \ then\n                max_strength = math.huge;\n                max_name =\
    \ class_name;\n            end\n        else\n            extnum = extnum;\n \
    \       end\n    end\n    max_name = max_name .. extnum;\n    if extnum == 1 then\n\
    \        return max_name;\n    else\n        if max_strength > 0 then\n      \
    \      return class_name .. '.' .. max_name;\n        else\n            return\
    \ max_name;\n        end\n    end\nend\n</cell>\n<cell>\n#export", "  local max_strength\
    \ = -1\n  local max_extension\n  for i = 1, #extensions do\n    local extension_strength\
    \ = string.upper(class_name):gsub('(.)' ..extensions[i]..'$', '\\1')\n    if max_strength\
    \ == -1 then\n      max_strength = extension_strength\n      max_extension = extensions[i]\n\
    \    elseif extension_strength > max_strength then\n      max_strength = extension_strength\n\
    \      max_extension = extensions[i]\n    end\n  end\n  return max_extension ..\
    \ '.' .. class_name\nend", "\tlocal best_extension = ''\n\tlocal best_strength\
    \ = -1\n\tfor i=1,#extensions do\n\t\tlocal cap = string.upper(string.sub(class_name,1,i))\n\
    \t\tlocal sm = string.lower(string.sub(class_name,i+1,#class_name))\n\t\tlocal\
    \ score = math.abs(cap - sm)\n\t\tif score > best_strength then\n\t\t\tbest_extension\
    \ = class_name\n\t\t\tbest_strength = score\n\t\tend\n\tend\n\treturn best_extension\n\
    end", "\tlocal strongest_extension = {}", "   assert(type(class_name) == \"string\"\
    )\n   assert(type(extensions) == \"table\")\n   \n   local strongest = {}\n  \
    \ for i = 1, #extensions do\n      if tonumber(extensions[i]) > tonumber(strongest[i])\
    \ then\n         strongest[i] = extensions[i]\n      end\n   end\n   \n   return\
    \ class_name .. \".\" .. table.concat(strongest, \".\")\nend", "\tlocal cap =\
    \ string.match(class_name, '[A-Z]') \n\tlocal sm = string.match(class_name, '[a-z]')\
    \ \n\tlocal strongest = nil\n\tfor _, extension in ipairs(extensions) do\n\t\t\
    local cap2 = string.match(extension, '[A-Z]') \n\t\tlocal sm2 = string.match(extension,\
    \ '[a-z]') \n\t\tlocal strength = cap - sm \n\t\tif strength == cap2-sm2 then\n\
    \t\t\tstrongest = extension\n\t\tend\n\tend\n\treturn strongest\nend", "  local\
    \ strongest_extension = nil\n  \n  for _, extension in ipairs(extensions) do\n\
    \    local cap = string.upper(extension:sub(1,#extension))\n    local sm  = string.lower(extension:sub(#cap+1))\n\
    \    \n    if cap - sm > 0 then\n      strongest_extension = string.gsub(class_name,\
    \ '^' .. extension .. '.', '', 1)\n      break\n    end\n  end\n  return strongest_extension\n\
    end", "  assert(extensions[#extensions] == class_name, \"class_name should be\
    \ the whole name of the class\")\n  local max_strength = -1\n  for _, extension\
    \ in pairs(extensions) do\n    local cap = #extension:upper()\n    local sm =\
    \ #extension:lower()\n    local strength = cap - sm\n    if strength > max_strength\
    \ then\n      max_strength = strength\n    end\n  end\n  return class_name ..\
    \ '.' .. extensions[max_strength]\nend", "    local capitals = {}\n    local smalls\
    \ = {}\n    for i,v in pairs(extensions) do\n        capitals[#capitals+1] = v:sub(1,1)\n\
    \        smalls[#smalls+1] = v:sub(2)\n    end\n    \n    local strength = #capitals\
    \ - #smalls\n    local min_strength = #smalls\n    local best_extension = extensions[1]\n\
    \    for i,v in pairs(extensions) do\n        if v < min_strength then\n     \
    \       best_extension = v\n            min_strength = v\n        end\n    end\n\
    \    return class_name .. '.' .. best_extension\nend\n</cell>\n<text>\nExercise\
    \ 5\nWrite a function that takes a table of extensions as input, loops through\
    \ the table and\nprints out the name of the class along with the strongest extension\
    \ in that table.\nFor example, if you are given this table: {'AA', 'Be', 'CC'}\n\
    You should print out:", "\tassert(type(extensions) ~= 'table')\n\tlocal cap, sm\
    \ = 0, 0\n\tfor _, e in ipairs(extensions) do\n\t\tcap = cap + toupper(e):byte()\n\
    \t\tsm = sm + tolower(e):byte()\n\tend\n\tlocal strength = math.floor(cap - sm)\n\
    \tfor _,e in ipairs(extensions) do\n\t\tif cap == sm then\n\t\t\treturn class_name..'.'..e\n\
    \t\tend\n\t\tstrength = strength + toupper(e):byte()\n\tend\n\treturn class_name..'.'..extensions[#extensions]\n\
    end", "\tlocal best_extensions = #extensions -- Number of extensions to consider\n\
    \tlocal best_extension = 0\t-- Index of the strongest extension\n\tlocal count\
    \ = {}\t-- Maps letter of the extension to the number of it\n\tfor i = 1, #extensions\
    \ do -- Initialize count of each letter\n\t\tcount[string.format('%c', extensions[i])]\
    \ = 1 -- Maps uppercase letters to 1\n\tend\n\tlocal index_of_the_best_extension\
    \ = 1\t-- Index of the strongest extension\n\tfor letter, count in pairs(count)\
    \ do -- Find the strongest extension\n\t\tif count == best_extensions then --\
    \ If this extension already has the best extension\n\t\t\tindex_of_the_best_extension\
    \ = letter\n\t\tend\n\t\tlocal strength = #class_name -- Strength of the extension\
    \ based on the number of letters\n\t\tif count == 1 then -- If there is only one\
    \ letter, it is irrelevant\n\t\t\tstrength = -1 -- We put it on the end as long\
    \ as it is lowercase letter\n\t\tend\n\t\tlocal extension = string.format('%c',\
    \ letter) -- Extension name based on the letter we are considering\n\t\t-- If\
    \ it is a lowercase letter or the first letter\n\t\tif #extension == 1 or letter\
    \ > #extension or #class_name == 1 then\n\t\t\t-- If strength is less than the\
    \ last one found, set a new strength\n\t\t\tif #best_extensions < best_extension\
    \ then -- If there is a best extension so far\n\t\t\t\tbest_extension = #best_extensions\n\
    \t\t\tend\n\t\t\t-- Set the strongest extension\n\t\t\tif best_extension == #best_extensions\
    \ then -- If there are more extensions so far\n\t\t\t\tbest_extension = #best_extensions\
    \ + 1\n\t\t\tend\n\t\t\t-- Set the extension\n\t\t\textension = string.format('%s.%s',\
    \ class_name, extension)\n\t\telse -- If more than one letter\n\t\t\t-- If strength\
    \ is less than the last one found, set a new strength\n\t\t\tif #best_extensions\
    \ < best_extension then -- If there is a best extension so far\n\t\t\t\tbest_extension\
    \ = #best_extensions\n\t\t\tend\n\t\t\t-- Set the strongest extension\n\t\t\t\
    if best_extension == #best_extensions then -- If there are more extensions so\
    \ far\n\t\t\t\tbest_extension = #best_extensions + 1\n\t\t\tend\n\t\t\t-- If there\
    \ are extensions with same strength, choose the one that comes first in the table\n\
    \t\t\tif string.format('%c', extensions[best_extension]) ~= string.format('%c',\
    \ extension) then\n\t\t\t\t-- Set the extension\n\t\t\t\textension = string.format('%s.%s',\
    \ class_name, extensions[best_extension])\n\t\t\tend\n\t\tend\n\t\t-- Check if\
    \ the extension already exists\n\t\tif #extension_exist(class_name, extension)\
    \ ~= 0 then\n\t\t\t-- If the extension already exists, choose the one ", "  if\
    \ extensions == nil then\n    return class_name\n  end\n  local strengths = {}\n\
    \  for k,v in pairs(extensions) do\n    local C = v:sub(1,1)\n    local S = v:sub(2,2)\n\
    \    if strengths[C] == nil then\n      strengths[C] = {}\n    end\n    if strengths[C][S]\
    \ == nil then\n      strengths[C][S] = -1\n    end\n    strengths[C][S] = strengths[C][S]\
    \ + 1\n  end\n  local Strongest = -1\n  local Strongest_C = -1\n  local Strongest_S\
    \ = -1\n  for C in pairs(strengths) do\n    if Strongest < 0 or strengths[C][Strongest]\
    \ < strengths[Strongest_C][Strongest_S] then\n      Strongest = C\n      Strongest_C\
    \ = C\n      Strongest_S = Strongest == Strongest_C ? Strongest_S : Strongest\n\
    \    end\n  end\n  return class_name .. '.' .. Strongest_C\nend", "   assert(type(extensions)\
    \ == 'table', class_name ..' is expected to be a table')\n   assert(#extensions\
    \ > 0, 'Extension table is expected to be non-empty')\n   local strongest_ext\
    \ = ''\n   local extension_table = {}\n   for _, extension in ipairs(extensions)\
    \ do\n      extension_table[extension] = extension_table[extension] or 1\n   \
    \   extension_table[extension] = extension_table[extension] + 1\n      if extension_table[extension]\
    \ > strongest_ext then\n         strongest_ext = extension\n      end\n   end\n\
    \   local strongest_extension = strongest_ext and strongest_ext or extensions[1]\n\
    \   return '%s.%s' .. class_name .. '.' .. strongest_extension\nend", "    local\
    \ str_extensions = {}\n    for _, extension in ipairs(extensions) do\n       \
    \ local cap, sm = GetFirstCapitalLetter(extension), GetFirstCapitalLetter(extension:lower())\n\
    \        local diff = cap - sm\n        str_extensions[diff] = extension\n   \
    \ end\n    local str_class = class_name:lower()\n    if str_extensions[str_class:len()]\
    \ then\n        return str_class .. '.' .. str_extensions[str_class:len()]:lower()\n\
    \    else\n        return 'error.' .. class_name .. '.extension_does_not_exist'\n\
    \    end\nend", "  if #extensions == 0 then\n    return ''\n  end\n  local maxes\
    \ = {} \n  for i, extension in ipairs(extensions) do\n    local cap = #extension:gsub('%^[A-Z]+$',\
    \ '')\n    local sm = #extension:gsub('%^[a-z]+$', '')\n    local ext = extension:gsub('%^_%$',\
    \ '')\n    local strength = cap - sm\n    if strength > 0 then\n      if #maxes\
    \ == 0 then\n        maxes = {extension}\n      else\n        if maxes[#maxes\
    \ + 1] > strength then\n          maxes[#maxes + 1] = strength\n        end\n\
    \      end\n    end\n  end\n  if #maxes > 0 then\n    return class_name .. '._'\
    \ .. maxes[#maxes]\n  end\nend", "  return extensions[#extensions]\nend", "  local\
    \ max_extension_strength = -1\n  local max_extension = \"\"\n  for _, extension\
    \ in ipairs(extensions) do\n    local char_length = #extension\n    if char_length\
    \ == 1 then\n      -- The extension is only one letter.\n      -- In this case,\
    \ we want to compare it against the class name.\n      if extension:lower():upper()\
    \ == class_name:lower() then\n        -- The extension is one letter long.\n \
    \       -- In this case, we want to compare it against the max strength\n    \
    \    -- of extensions in the table.\n        if max_extension_strength == -1 then\n\
    \          max_extension_strength = char_length\n          max_extension = extension\n\
    \        else\n          -- We have two extensions with the same strength.\n \
    \         -- We want to compare it against the alphabetically earliest extension.\n\
    \          if char_length < max_extension_strength then\n            max_extension_strength\
    \ = char_length\n            max_extension = extension\n          end\n      \
    \  end\n      end\n    elseif char_length > 1 then\n      -- The extension is\
    \ more than one letter.\n      -- In this case, we want to compare it against\
    \ the class name.\n      if extension:lower():upper() == class_name:lower() then\n\
    \        -- The extension is more than one letter long.\n        -- In this case,\
    \ we want to compare it against the strength\n        -- of extensions in the\
    \ table.\n        if max_extension_strength == -1 then\n          max_extension_strength\
    \ = char_length\n          max_extension = extension\n        else\n         \
    \ -- We have two extensions with the same strength.\n          -- We want to compare\
    \ it against the alphabetically earliest extension.\n          local char_length\
    \ = char_length\n          if char_length < max_extension_strength then\n    \
    \        max_extension_strength = char_length\n            max_extension = extension\n\
    \          end\n        end\n      end\n    end\n  end\n  return max_extension\n\
    end", "    local cap_idx = 1\n    local sm_idx = 1\n    local index = 1\n    while\
    \ cap_idx < #extensions and sm_idx < #extensions do\n        if cap_idx+sm_idx\
    \ <= #extensions then\n            if tostring(extensions[cap_idx]) == tostring(extensions[cap_idx+sm_idx])\
    \ then\n                cap_idx = cap_idx + 1\n                sm_idx = sm_idx\
    \ + 1\n            else\n                index = index + 1\n                cap_idx\
    \ = cap_idx + 1\n                sm_idx = 1\n            end\n        else\n \
    \           if extensions[cap_idx+1] > extensions[cap_idx] then\n            \
    \    index = index + 1\n                cap_idx = 1\n                sm_idx =\
    \ 1\n            else\n                index = index + 1\n                cap_idx\
    \ = 1\n                sm_idx = 1\n            end\n        end\n    end\n   \
    \ if cap_idx >= #extensions or sm_idx >= #extensions then\n        return class_name\
    \ .. '.' .. extensions[cap_idx+sm_idx]\n    end\n    return class_name .. '.'\
    \ .. extensions[cap_idx+1]\nend", "   assert(extensions:len() == 1)\n   local\
    \ num_cap, num_sm = 0, 0, 0\n   for _, ext in ipairs(extensions) do\n      if\
    \ ext:upper():find(class_name:upper()) == 1 then\n         num_cap = num_cap +\
    \ 1\n      elseif ext:find():lower() == class_name:lower() then\n         num_sm\
    \ = num_sm + 1\n      end\n   end\n   if num_cap > num_sm then\n      return class_name\
    \ .. '.' .. extensions[num_cap]\n   elseif num_sm * 2 > num_cap then\n      return\
    \ class_name .. '.' .. extensions[num_sm]\n   else\n      return class_name ..\
    \ '.' .. extensions[1]\n   end\nend", "    local max_strength = 0\n    local max_extension\
    \ = ''\n    for _, extension in ipairs(extensions) do\n        local s = string.upper(extension):upper():len()\n\
    \        if max_strength == 0 or max_strength < s then\n            max_strength\
    \ = s\n            max_extension = extension\n        end\n    end\n    if max_strength\
    \ == 0 then\n        return '' -- no extension with strength > 0\n    end\n  \
    \  -- TODO: if there are more extensions with the same strength, choose the one\
    \ that\n    -- comes first\n    return string.gsub(class_name, max_extension,\
    \ string.upper(max_extension):upper())\nend", "  local cap_counter = CountLetters(class_name)\n\
    \  local sml_counter = CountLetters(class_name)", "\tlocal strongest_extension\
    \ = nil\n\tfor _, extension in ipairs(extensions) do\n\t\tif extension:upper():match('^[%a]+$')\
    \ then\n\t\t\tlocal capitals = extension:upper():gsub('%a','')\n\t\t\tlocal lowercases\
    \ = extension:upper():gsub('%A','')\n\t\t\tlocal fractality = capitals - lowercases\n\
    \t\t\tif fractality ~= 0 then\n\t\t\t\tif strongest_extension then\n\t\t\t\t\t\
    if fractality > strongest_extension.fractality then\n\t\t\t\t\t\tstrongest_extension\
    \ = nil\n\t\t\t\t\telse\n\t\t\t\t\t\tstrongest_extension = { class_name, extension,\
    \ fractality }\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tstrongest_extension = {\
    \ class_name, extension, fractality }\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\
    \treturn strongest_extension\nend", "  local strongest_extensions = { }\n  for\
    \ i = 1, #extensions do\n    local cap_extensions = string.gsub(extensions[i],\
    \ \"[A-Z]\", \"\") -- CAP\n    local sm_extensions = string.gsub(extensions[i],\
    \ \"[a-z]\", \"\") -- SM\n    local frac = cap_extensions - sm_extensions -- Strongest\
    \ extension's fraction\n    \n    if not strongest_extensions[frac] then\n   \
    \   strongest_extensions[frac] = extensions[i]\n    elseif strongest_extensions[frac]\
    \ > extensions[i] then\n      strongest_extensions[frac] = extensions[i]\n   \
    \ end\n  end", "    local caps = table_count(extensions)\n    local sms = table_count(extensions)\n\
    \    local capsu = table_count(extensions)", "    local strongest = -1\n    local\
    \ strongest_class = class_name\n    for _, extension in ipairs(extensions) do\n\
    \        local _, strength = string.find(extension, class_name, '([A-Z])') --\
    \ Find CAP and SM\n        if strength ~= nil then\n            local strength_frac\
    \ = strength - string.find(extension, class_name, '([a-z])') -- Calculate strength\
    \ frac\n            if strength_frac > strongest then\n                strongest\
    \ = strength_frac\n                strongest_class = class_name\n            end\n\
    \        end\n    end\n    return strongest_class .. '.' .. strongest\nend", " \
    \ local max_strength = -1\n  local best_extension\n  for _, extension in ipairs(extensions)\
    \ do\n    local c = string.sub(class_name, 1, string.len(class_name)-string.len(extension))\n\
    \    local s = string.sub(extension, 1, string.len(extension))\n    local cap\
    \ = string.match(c, \"[A-Z]\") or 0\n    local sm = string.match(s, \"[a-z]\"\
    ) or 0\n    local strength = cap - sm\n    if max_strength == -1 or max_strength\
    \ > strength then\n      max_strength = strength\n      best_extension = extension\n\
    \    end\n  end\n  return string.sub(class_name, 1, string.len(class_name)-string.len(best_extension))..best_extension\n\
    end", "\tlocal strongest_extensions = extensions.sort(function(a,b) return a:lower()\
    \ > b:lower() end)\n\tif not strongest_extensions then\n\t\treturn class_name\
    \ .. '.' .. extensions[1]\n\tend\n\tlocal strongest_extension = strongest_extensions[1]\n\
    \t\n\tfor _, extension in ipairs(strongest_extensions) do\n\t\tlocal cap = string.upper(extension)\n\
    \t\tlocal sm = string.lower(extension)\n\t\t\n\t\t-- Sort extensions by the strength\n\
    \t\tif cap - sm > 0 then\n\t\t\treturn class_name .. '.' .. extension\n\t\tend\n\
    \tend\n\treturn class_name .. '.' .. strongest_extension\nend", "    local counts\
    \ = {}\n    for i = 1, #extensions do\n        counts[#counts + 1] = extensions[i]:gsub('%[Bb][a-z]+','%'):gsub('%[a-z]',''):gsub('%[A-Z][a-z]+','%'):gsub('%[a-z]','')\n\
    \    end\n    local maxStrength = -1\n    for i = 1, #counts do\n        if maxStrength\
    \ == -1 or counts[i][1] > counts[maxStrength][1] or counts[i][1] < 0 then\n  \
    \          maxStrength = i\n        end\n    end\n    if maxStrength >= #counts\
    \ then return class_name end\n    local count = 0\n    for i = 1, #counts do\n\
    \        if counts[i][1] == counts[maxStrength][1] then\n            count = count\
    \ + 1\n        end\n    end\n    if count == 1 then\n        return class_name\
    \ .. counts[maxStrength][2]\n    elseif count > 1 then\n        return class_name\
    \ .. counts[maxStrength][2]\n    elseif #counts == 1 then\n        return class_name\
    \ .. counts[maxStrength][2]\n    else\n        return class_name .. counts[maxStrength][1]\n\
    \    end\nend", "   assert(type(extensions) ~= 'table', 'extensions table is not\
    \ a table')\n   local best_extension_strength = -1\n   local best_extension_name\
    \ = 'NotDefined'\n   for _,extension in ipairs(extensions) do\n      if extension:find('%.%.%')\
    \ == class_name:lower():sub(1, 2) then\n         local current_strength = extension:find('%.%.%')\n\
    \         if current_strength > best_extension_strength then\n            best_extension_strength\
    \ = current_strength\n            best_extension_name = extension\n         end\n\
    \      end\n   end\n   return best_extension_name\nend", "    local capitals =\
    \ #class_name % 2\n    local lowers = #class_name - capitals\n    for i=1,#extensions\
    \ do\n        local cap = string.sub(extensions[i],1,capitals)\n        local\
    \ lower = string.sub(extensions[i],capitals+1,lowers)\n        local cap_str =\
    \ string.upper(cap)\n        local low_str = string.lower(lower)\n        if cap_str\
    \ == low_str then\n            cap_str = cap_str..'_'\n        end\n        if\
    \ #cap_str < #low_str then\n            return string.format('%s.%s',class_name,cap_str)\n\
    \        end\n        if #cap_str > #low_str then\n            return string.format('%s.%s',class_name,low_str)\n\
    \        end\n    end\n    return string.format('%s.%s',class_name,string.upper(class_name))\n\
    end", "    if #extensions < 1 then\n        return \"\"\n    end", "    local\
    \ strongest, i, best_len = nil, 0, 1\n    for _, name in pairs(extensions) do\n\
    \        local cap, sm = string.upper(name), string.lower(name)\n        local\
    \ diff = math.abs(cap - sm)\n        if diff > strongest then\n            strongest,\
    \ i, best_len = diff, 1, cap\n        elseif diff == strongest then\n        \
    \    i = i + 1\n            -- check whether we found the best extension\n   \
    \         if i == best_len then\n                return string.sub(class_name,\
    \ 0, i - 1)\n            end\n        end\n    end\n    return class_name\nend",
  "  -- Write your code here\nend\n</cell>\n<text>\nExercise 2\nUse these methods\
    \ to solve Exercise 1 and 2.", "  if #extensions == 0 then\n    return nil\n \
    \ end\n  local max_strength = -1\n  local max_extension = nil\n  for _, extension\
    \ in ipairs(extensions) do\n    local extension_name = extension:sub(1, #extension)\n\
    \    local ext_strength = extension_name:upper()-extension_name:sub(1,1):lower()\n\
    \    if ext_strength > max_strength then\n      max_extension = extension\n  \
    \    max_strength = ext_strength\n    end\n  end\n  return string.sub(class_name,1,#class_name-1)..'.'..max_extension\n\
    end", "\tlocal strongest = extensions[1]\n\tfor _, strongest_extension in ipairs(extensions)\
    \ do\n\t\tif strongest_extension ~= strongest then\n\t\t\tstrongest = strongest_extension\n\
    \t\tend\n\tend\n\treturn '%s.%s' % (class_name, strongest)\nend", "    local strengths\
    \ = {}\n    for _, extension in ipairs(extensions) do\n        local c = class_name:sub(#class_name+2)\n\
    \        local _, s = str:find(extension, '.', 2)\n        if s then\n       \
    \     local _, e = str:find(extension, '.', s+3)\n            if e then\n    \
    \            local c = c:sub(#c+2)\n                local e = e:sub(#e+2)\n  \
    \              if strengths[c] == nil then\n                    strengths[c] =\
    \ -1\n                end\n                strengths[c] = strengths[c] + s:sub(e-s,\
    \ e-s):lower():match('%W')\n            end\n        end\n    end\n    local strongest,\
    \ strength = #strengths, -1\n    for _, s in ipairs(strengths) do\n        if\
    \ strength > strength then\n            strongest, strength = s, -1\n        end\n\
    \    end\n    return class_name .. '.' .. strongest .. '.' .. #extensions\nend",
  "    local max_strength = -1\n    local max_extension = nil\n    for _, extension\
    \ in ipairs(extensions) do\n        local strength = string.upper(extension:sub(1,\
    \ #extension)) -\n                         string.upper(extension:sub(1, #extension\
    \ - 1))\n        if strength > 0 and strength > max_strength then\n          \
    \  max_extension = extension\n            max_strength = strength\n        end\n\
    \    end\n    return string.sub(class_name, 1, string.len(class_name)-string.len(max_extension)-1)\
    \ .. max_extension\nend", "   assert(type(class_name) == 'string' and type(extensions)\
    \ == 'table')\n   local strongest, count, highest = nil, 0, 0\n   for i=1,#extensions\
    \ do\n      if string.upper(extensions[i]) >= string.upper(extensions[highest])\
    \ then\n         highest = i\n      end\n   end\n   for i=1,#extensions do\n \
    \     if string.upper(extensions[i]) == string.upper(extensions[highest]) then\n\
    \         count = count+1\n      else\n         if count > 0 then\n          \
    \  strongest = class_name .. '_' .. extensions[highest]\n            break\n \
    \        end\n         count = 0\n      end\n   end\n   if count > 0 then\n  \
    \    return strongest .. '.' .. extensions[highest]\n   end\nend", "\tlocal sorted_extensions\
    \ = {}\n\tfor _, extension_name in ipairs(extensions) do\n\t\tlocal cap = extension_name:upper():byte()\n\
    \t\tlocal sm = extension_name:lower():byte()\n\t\tlocal strength = math.abs(cap\
    \ - sm)\n\t\ttable.insert(sorted_extensions, { extension_name, strength })\n\t\
    end\n\ttable.sort(sorted_extensions)\n\treturn table_concat(sorted_extensions,\
    \ '.')\nend", "  -- Write your code here.\n  local strongest = extensions[1]\n\
    \  for i=2, #extensions do\n    local count = #extensions[i]:lower() - #extensions[i-1]:lower()\n\
    \    if count == 0 then\n      count = 1 -- count the number of lowercase letters\
    \ in a string\n    end\n    strongest = class_name .. '.' .. extensions[i]:lower()\
    \ .. '.' .. strongest\n    if count > 1 then\n      strongest = extensions[i]:lower()\
    \ .. '.' .. strongest\n    end\n  end\n  return strongest\nend", "   if extensions.count\
    \ == 0 then\n      return ''\n   end\n   if extensions.count == 1 then\n     \
    \ local extension = extensions[1]\n      if extension == nil then\n         return\
    \ ''\n      else\n         if extension:gsub('[A-Z]', '', 1):gsub('[a-z]', '',\
    \ 1):gsub('[0-9]', '', 1) == 0 then\n            return ''\n         end\n   \
    \   end\n   end\n   local counts = {}\n   for _, extension in ipairs(extensions)\
    \ do\n      if extension:gsub('[A-Z]', '', 1):gsub('[a-z]', '', 1):gsub('[0-9]',\
    \ '', 1) ~= 0 then\n         local capitals = extension:gsub('[A-Z]', '', 1):gsub('[a-z]',\
    \ '', 1):gsub('[0-9]', '', 1)\n         if counts[capitals] then\n           \
    \ counts[capitals] = counts[capitals] + 1\n         else\n            counts[capitals]\
    \ = 1\n         end\n      end\n   end\n   local max_count = 0\n   local max_capitals\
    \ = ''\n   for capitals, count in pairs(counts) do\n      if count > max_count\
    \ then\n         max_count = count\n         max_capitals = capitals\n      end\n\
    \   end\n   return class_name .. '.' .. max_capitals\nend", "  if extensions.count\
    \ == 0 then\n    return class_name\n  end\n  local strongest = extensions[1]\n\
    \  for i = 2, #extensions do\n    if strongest[1] < extensions[i][1] then\n  \
    \    strongest = extensions[i]\n    end\n  end\n  return '%s.%s'\n  % (class_name,\
    \ strongest[1])\nend", "  local max_strength = -1\n  local max_extension = \"\"",
  "\tlocal strongest, i, count = 0, 0, 0\n\tfor _, extension in ipairs(extensions)\
    \ do\n\t\tcount = count + 1\n\t\tlocal letters = string.upper(extension:sub(1,\
    \ 1))\n\t\tlocal nums = string.lower(extension:sub(2, 2))\n\t\tlocal strength\
    \ = math.abs(#letters - #nums) / #letters\n\t\tif strength > strongest then\n\t\
    \t\tstrongest = strength\n\t\t\ti = count\n\t\tend\n\tend\n\treturn string.format(class_name\
    \ .. '.%.2d', i)\nend", "    -- Your code here\n    local ext = {}\n    for _,\
    \ v in ipairs(extensions) do\n        local cap, sm = v:match(\"(.-)([A-Z])\"\
    )\n        table.insert(ext, v..cap)\n    end\n    table.sort(ext)\n    return\
    \ class_name .. string.sub(class_name,1,string.find(class_name,\".\")-1) .. ext[#ext]\n\
    end", "  local cap = string.upper(class_name:match(\"%u\"))\n  local sm = string.lower(class_name:match(\"\
    %l\"))\n  local max_len = -1\n  \n  -- For every extension, check the strength.\n\
    \  for _, extension in pairs(extensions) do\n    local cap2 = string.upper(extension:match(\"\
    %u\"))\n    local sm2 = string.lower(extension:match(\"%l\"))\n    local diff\
    \ = cap2-sm2\n    \n    -- Ignore extensions with zero strength.\n    if diff\
    \ == 0 then\n      continue\n    end\n    \n    -- Ignore extensions with too\
    \ low strength.\n    if diff < 0 then\n      diff = diff * (-1)\n    end\n   \
    \ \n    -- Ignore extensions with high strength.\n    if diff > max_len then\n\
    \      max_len = diff\n    end\n  end\n  \n  if max_len == -1 then\n    -- No\
    \ extensions exist.\n    return class_name\n  else\n    -- Return the strongest\
    \ extension.\n    for _, extension in pairs(extensions) do\n      local cap2 =\
    \ string.upper(extension:match(\"%u\"))\n      local sm2 = string.lower(extension:match(\"\
    %l\"))\n      local diff = cap2-sm2\n      \n      if diff == 0 then\n       \
    \ continue\n      end\n      \n      if diff < 0 then\n        diff = diff * (-1)\n\
    \      end\n      \n      if diff > max_len then\n        max_len = diff\n   \
    \   end\n    end\n    \n    -- Return the class name followed by \".\".\n    return\
    \ string.format(\"%s%s\", class_name, class_name[max_len+1])\n  end\nend\n</cell>\n\
    <text>\nNext you will define a function that will return a random integer in the\
    \ range \n[low, high].", "  local strongest = nil\n  local strength = -1\n  for\
    \ _, extension in ipairs(extensions) do\n    if extension:match(\"^[%a]+\") then\n\
    \      local length = extension:len()\n      if length > 0 then\n        local\
    \ cap = tonumber(extension:sub(length - 1, length):upper())\n        local sm\
    \ = tonumber(extension:sub(length - 1, length):lower())\n        if cap - sm >\
    \ strength then\n          strength = cap - sm\n          strongest = class_name\
    \ .. \".\" .. extension\n        end\n      end\n    end\n  end\n  return strongest\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
