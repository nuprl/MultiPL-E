name: HumanEval_4_mean_absolute_deviation
language: lua
prompt: "-- For a given table of input numbers, calculate Mean Absolute Deviation\n\
  -- around the mean of this dataset.\n-- Mean Absolute Deviation is the average absolute\
  \ difference between each\n-- element and a centerpoint (mean in this case):\n--\
  \ MAD = average | x - x_mean |\n-- >>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})\n\
  -- 1.0\nlocal function mean_absolute_deviation(numbers)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = mean_absolute_deviation\n\
  \    lu.assertEquals(candidate({1.0, 2.0}), 0.5)\n    lu.assertEquals(candidate({1.0,\
  \ 2.0, 3.0, 4.0}), 1.0)\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}),\
  \ 1.2)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local mean = torch.mean(numbers)\n  local deviations = torch.abs(numbers\
    \ - mean)\n  return torch.mean(deviations)\nend", "  local n = #numbers\n  if\
    \ n ~= 1 then\n    error(\"table size must be 1\")\n  end", "    local mean =\
    \ numbers[1]\n    for _, value in pairs(numbers) do\n        mean = mean + value\n\
    \    end\n    local sum = 0\n    for _, value in pairs(numbers) do\n        sum\
    \ = sum + math.abs(value - mean)\n    end\n    return sum / #numbers\nend", " \
    \ -- The absolute difference between elements and mean must be calculated.\n \
    \ local numbers_mean = sum(numbers) / (#numbers)", "  if not rawget(numbers, 'stats')\
    \ then\n    rawset(numbers, 'stats', {})\n  end", "  local sum = 0\n  for _, value\
    \ in pairs(numbers) do\n    sum = sum + math.abs(value - table.concat(numbers))\n\
    \  end\n  return sum / #numbers\nend", "  local deviation = 0\n  local n = 0\n\
    \  for _, value in pairs(numbers) do\n    n = n + 1\n    deviation = deviation\
    \ + abs(value - mean)\n  end\n  return deviation/n\nend", "  if #numbers == 0\
    \ then\n    return 0\n  else\n    return math.abs((numbers.mean - table.mean(numbers))/(numbers.mean\
    \ or 1))\n  end\nend", "  local sum_diffs = 0\n  for _, number in ipairs(numbers)\
    \ do\n    sum_diffs = sum_diffs + math.abs(number - mean_number(numbers))\n  end\n\
    \  return sum_diffs / #numbers\nend", "  if #numbers < 2 then return nil end\n\
    \  local n = #numbers\n  if n == 0 then return nil end\n  if n == 1 then return\
    \ numbers[1] end\n  local x_mean = math.round(#numbers / 2)\n  local sum = 0\n\
    \  for i=1,n do\n    sum = sum + numbers[i] - x_mean\n  end\n  return math.round(math.sqrt(sum\
    \ / n))\nend", "  if #numbers == 0 then\n    return 0\n  end", "  local sum =\
    \ 0\n  for _, value in pairs(numbers) do\n    sum = sum + math.abs(value - (math_mean(numbers)))\n\
    \  end\n  return sum / (#numbers - 1)\nend", "  local mean = {}\n  for _, v in\
    \ pairs(numbers) do table.insert(mean, math.abs(v)) end\n  return mean_(mean)\n\
    end", "  local sum = 0.0\n  local sum_sq = 0.0\n  for i = 1, #numbers do\n   \
    \ sum = sum + numbers[i]\n    sum_sq = sum_sq + math.pow(numbers[i] - mean, 2)\n\
    \  end\n  return math.pow(sum / #numbers, 0.5)\nend", "   -- Get the mean of the\
    \ numbers:\n   local mean_value = table.aggregate(numbers, function(total, value)\n\
    \      total = total + value\n      return total\n   end, 0)", "  local xs = numbers.values\n\
    \  local n = numbers:size()\n  if n ~= 1 then\n    error(\"Mean Absolute Deviation\
    \ only calculates average for one number.\")\n  end\n  local mean = xs[1]\n  local\
    \ mean_abs = 0\n  for i = 1, n do\n    local abs = math.abs(xs[i] - mean)\n  \
    \  mean_abs = mean_abs + abs\n  end\n  return mean_abs / n\nend", "  local n =\
    \ #numbers\n  if n == 0 then\n    return 0\n  else\n    return math.sqrt(sum((numbers\
    \ - mean) * (numbers - mean)) / n)\n  end\nend", "  local sum = 0\n  for _, value\
    \ in pairs(numbers) do\n    sum = sum + math.abs(value - mean)\n  end\n  return\
    \ sum / (#numbers - 1)\nend", "  local sum = 0.0\n  local n = #numbers\n  local\
    \ sumsq = 0.0\n  local xmean = math.huge\n  for i = 1, n do\n    sum = sum + numbers[i]\n\
    \    sumsq = sumsq + math.pow(numbers[i] - xmean, 2)\n  end\n  return math.sqrt(sumsq\
    \ / n)\nend", "    local mean = 0\n    for _, x in pairs(numbers) do\n       \
    \ mean = mean + x\n    end\n    mean /= #numbers\n    for _, x in pairs(numbers)\
    \ do\n        if x ~= 0 then\n            return mean - x\n        end\n    end\n\
    \    return nil\nend", "  local mean\n  if next(numbers) ~= nil then\n    mean\
    \ = table.avg(numbers)\n  else\n    mean = nil\n  end\n  local total_deviation\
    \ = 0\n  for i = 1, #numbers do\n    local deviation\n    if mean == nil then\n\
    \      deviation = 0\n    else\n      deviation = numbers[i] - mean\n    end\n\
    \    total_deviation = total_deviation + deviation\n  end\n  return total_deviation\
    \ / #numbers\nend", "    local sum = 0.0\n    local mean = 0\n    for i = 1, #numbers\
    \ do\n        sum = sum + math.abs(numbers[i] - mean)\n        mean = mean + numbers[i]\n\
    \    end\n    return mean / #numbers\nend", "  local sum = 0\n  for _, x in pairs(numbers)\
    \ do\n    sum = sum + math.abs(x - math.mean(x))\n  end\n  return sum / #numbers\n\
    end", "\tlocal x_mean = table.mean(numbers)\n\treturn math.sqrt(table.fold(\n\t\
    \tfunction(sum_, x)\n\t\t\tsum_ + math.abs(x - x_mean)\n\t\tend,\n\t\t0,\n\t\t\
    numbers\n\t))\nend", "    local mean_count = 0\n    local dev_count = 0\n    for\
    \ _, x in pairs(numbers) do\n        if x then\n            local mean_val = x:mean()\n\
    \            local dev_val = x - mean_val\n            mean_count = mean_count\
    \ + 1\n            dev_count = dev_count + dev_val\n        end\n    end\n   \
    \ if mean_count == 0 then\n        return nil\n    end\n    return math.abs(dev_count\
    \ / mean_count)\nend", "  local sum = 0\n  for _, v in ipairs(numbers) do\n  \
    \  sum = sum + abs(v - v)\n  end\n  return sum / #numbers\nend", "  if #numbers\
    \ == 0 then return 0 end\n  local sum = 0\n  for _, x in ipairs(numbers) do sum\
    \ = sum + x end\n  return sum / #numbers\nend", "  local sum = 0\n  for i = 1,\
    \ #numbers do\n    sum = sum + math.abs(numbers[i] - math.tofloat(numbers[i])/#numbers)\n\
    \  end\n  return sum / #numbers\nend", "  if #numbers == 0 then\n    return 0\n\
    \  end\n  return torch.mean((numbers - numbers[1]):abs():float())\nend", "  assert(numbers[1]\
    \ and numbers[2] and numbers[3] and #numbers == 4)\n  local mean = numbers[1]\n\
    \  local x_mean = numbers[2]\n  local deviation = 0\n  for _, x in pairs(numbers)\
    \ do\n    deviation = deviation + math.abs(x - mean)\n  end\n  return math.abs(deviation\
    \ / #numbers)\nend", "  local squared_diffs = {math.pow((numbers[i] - mean(numbers)),\
    \ 2)\n    for i = 1, #numbers }\n  return math.sqrt(#numbers - 1) * sum(squared_diffs)\
    \ / #numbers\nend", "  local mean\n  local deviation = 0\n  for _, value in ipairs(numbers)\
    \ do\n    if not mean then mean = value end\n    deviation = deviation + (value\
    \ - mean)**2\n  end\n  return deviation / #numbers\nend", "  return math.sqrt(math.fsum(\n\
    \    function(x) return math.abs(x - mean_number(x)) end,\n    numbers))\nend",
  "   local sum = 0\n   local count = 0\n   for _ in pairs(numbers) do\n      sum\
    \ = sum + _\n      count = count + 1\n   end\n   return math.abs(sum / count)\n\
    end", "  local mean = 0\n  for _, value in pairs(numbers) do\n    local n = value\n\
    \    if type(value) ~= 'number' then\n      n = tonumber(value)\n    end\n   \
    \ local diff = mean - n\n    local avg = mean + diff / 2\n    mean = avg\n  end\n\
    \  return mean\nend", "  local x_mean = table.avg(numbers)\n  if x_mean == nil\
    \ then\n    -- If there are no numbers, return 0, otherwise return nil.\n    return\
    \ 0\n  end\n  local sum_abs_diff = 0\n  for _, number in ipairs(numbers) do\n\
    \    sum_abs_diff = sum_abs_diff + math.abs(number - x_mean)\n  end\n  return\
    \ sum_abs_diff / #numbers\nend", "   local x_mean = math.average(numbers)\n  \
    \ return x_mean - math.average(numbers)\nend", "  local sum = 0\n  for i = 1,\
    \ #numbers do\n    sum = sum + numbers[i] - numbers[i - 1]\n  end\n  return sum\
    \ / #numbers\nend", "  if #numbers == 0 then\n    return 0\n  end", "  -- If there\
    \ are no elements, return NaN.\n  if not numbers or #numbers == 0 then\n    return\
    \ 0\n  end", "  local deviation = 0\n  local num = 0\n  for _, num in ipairs(numbers)\
    \ do\n    deviation = deviation + (num - math_mean(num))^2\n    num = num + 1.0\n\
    \  end\n  return deviation / num\nend", "   -- Calculate the average.\n   -- The\
    \ average is the sum of the numbers, divided by the number of\n   -- elements:\n\
    \   -- avg = (x1 + x2 + x3 + ...) / (N + 1).\n   -- The sum of numbers divided\
    \ by the number of elements yields the mean:\n   -- avg = sum(x1 + x2 + x3 + ...)\
    \ /  N\n   -- We are summing absolute deviations from the mean:\n   -- sum( |x\
    \ - avg| )\n   -- We are using N to compute the mean: N = (N1 + N2 + N3 + ...)\n\
    \   -- The formula is sum over i = 1 to N of ( xi - avg) / N.\n   -- The deviations\
    \ from the mean are then the sum of squares minus the\n   -- mean:\n   -- sum(\
    \ xi^2 - (xi - avg)^2 ) / N\n   -- Sum over i = 1 to N of ( (xi - avg)^2 ) / N:\n\
    \   -- sum over i = 1 to N of ( (xi - avg)^2 )\n   local sum = 0\n   for _, number\
    \ in ipairs(numbers) do\n      sum = sum + (math.abs(number - math.floor(number)))\
    \ / number\n   end\n   return sum / numbers[1]\nend", "  local total = 0\n  for\
    \ _, x in ipairs(numbers) do\n    total = total + x\n  end\n  local mean = total\
    \ / #numbers", "    local sum = 0.0\n    for _, x in ipairs(numbers) do\n    \
    \    sum = sum + x\n    end\n    return sum / #numbers\nend", "  local sum, avg\
    \ = 0, numbers.mean or numbers -- if mean not set, use numbers\n  for _, v in\
    \ pairs(numbers) do\n    sum = sum + math.abs(v - avg)\n  end\n  return sum /\
    \ #numbers\nend", "  local means = {}\n  for _, v in pairs(numbers) do\n    means[#means\
    \ + 1] = v\n  end\n  if #means == 0 then\n    return 0\n  end\n  local sum = 0\n\
    \  for _, v in pairs(means) do\n    sum = sum + v\n  end\n  return math.abs(sum\
    \ / #means)\nend", "  local mean_value = numbers[1]\n  local deviations = numbers[{\
    \ 1 }]:map(function(x) return x - mean_value end)\n  local absolute_differences\
    \ = deviations:map(function(x) return math.sqrt(x) end)\n  return tonumber(table.concat(absolute_differences,\
    \ '/' .. #deviations))\nend", "  local mean\n  if next(numbers) == nil then\n\
    \    -- empty list\n    mean = nil\n  else\n    -- add first number to get mean\n\
    \    mean = table.add(numbers)\n    -- remove first number from numbers\n    table.insert(numbers,\
    \ 1)\n    -- call recursively on the tail\n    -- numbers now contains [mean of\
    \ first number + next number + ...]\n    mean = mean_absolute_deviation(numbers)\n\
    \    -- divide by size of list\n    mean = mean / table.len(numbers)\n  end\n\
    \  return mean\nend", "  -- First, find the mean of this numbers. If all numbers\
    \ are the same, this\n  -- will be the mean of the set itself:\n  -- >>> mean_absolute_deviation({1.0,\
    \ 2.0, 3.0}) == mean({1.0, 2.0, 3.0}) == 3.0\n  -- >>> mean_absolute_deviation({1,\
    \ 2, 3, 4})\n  -- 3.0\n  local mean = statistics.mean(nil, numbers)", "  local\
    \ counts = terralib.newlist()\n  local sum = 0\n  for i = 1, #numbers do\n   \
    \ local value = numbers[i]\n    local count = counts[i] or 0\n    count = count\
    \ + 1\n    sum = sum + (value - count) / count\n    counts[i] = count\n  end\n\
    \  assert(#counts == 1)\n  return sum\nend", "  local x_mean = mean(numbers)\n\
    \  local deviations = numbers - x_mean\n  return deviations:map(function(d) return\
    \ abs(d) end)\n     .mean()\nend", "  local sum = 0\n  for _, x in pairs(numbers)\
    \ do\n    sum = sum + math.abs(x - math.mean(x))\n  end\n  return sum / #numbers\n\
    end", "  -- If the input is an empty array, the function returns nil.\n  if not\
    \ numbers then\n    return nil\n  end", "  local mean = select(numbers, 1)\n \
    \ local deviations = numbers.\n                       map(function(number)\n \
    \                         local deviation\n                          if number\
    \ ~= number then\n                            deviation = number - mean\n    \
    \                      else\n                            deviation = 0\n     \
    \                     end\n                          -- The deviation is non-negative\n\
    \                          deviation = math.abs(deviation)\n                 \
    \         -- Return the mean of the deviations\n                          return\
    \ deviation\n                       end).\n                       -- Return the\
    \ mean of the deviations\n                       mean()\n  return deviations\n\
    end", "  if type(numbers) ~= 'table' then\n    error('Only tables can be averaged.')\n\
    \  end\n  local total = 0\n  for _, x in pairs(numbers) do\n    total = total\
    \ + x\n  end\n  local n = #numbers\n  if n == 0 then\n    return nil\n  end\n\
    \  local sum2 = total / n\n  local mad = math.sqrt(sum2 / n)\n  return mad\nend",
  "    -- The 'numbers' parameter may be either a table of numbers or a number,\n\
    \    -- so we convert it to a table here.\n    if type(numbers) == 'table' then\n\
    \        numbers = table.to_array(numbers)\n    end\n    -- The 'numbers' parameter\
    \ is a table, so we convert it to a number.\n    local num_numbers = #numbers\n\
    \    local mean\n    if num_numbers == 0 then\n        mean = 0\n    else\n  \
    \      mean = numbers[1]\n        for i = 2, num_numbers do\n            mean\
    \ = mean + numbers[i]\n        end\n        mean = mean / num_numbers\n    end\n\
    \    local mad_sum = 0\n    local num_numbers_to_return\n    -- We want to calculate\
    \ the MAD around the mean, so we create a temporary\n    -- table of numbers where\
    \ the current input number is replaced with the mean.\n    -- We then calculate\
    \ the MAD for that temporary table of numbers.\n    if num_numbers == 0 then\n\
    \        num_numbers_to_return = 0\n    else\n        local tmp_numbers = {}\n\
    \        for i = 1, num_numbers do\n            tmp_numbers[i] = numbers[i]\n\
    \        end\n        local tmp_num_numbers = #tmp_numbers\n        local tmp_mean\n\
    \        if tmp_num_numbers == 0 then\n            tmp_mean = 0\n        else\n\
    \            tmp_mean = tmp_numbers[1]\n            for i = 2, tmp_num_numbers\
    \ do\n                tmp_mean = tmp_mean + tmp_numbers[i]\n            end\n\
    \            tmp_mean = tmp_mean / tmp_num_numbers\n        end\n        -- Find\
    \ the MAD around the mean.\n        for i = 1, num_numbers do\n            --\
    \ If the current number is not the mean value, add it to a temporary\n       \
    \     -- table of the numbers where the current number is the mean.\n        \
    \    if numbers[i] != mean then\n                table.insert(tmp_numbers, tmp_mean)\n\
    \            end\n        end\n        mad_sum = 0\n        for i = 1, num_numbers_to_return\
    \ do\n            mad_sum = mad + abs(tmp_numbers[i] - tmp_mean)\n        end\n\
    \    end\n    return mad_sum / num_numbers_to_return\nend", "  if #numbers ==\
    \ 0 then\n    return nil\n  end", "    -- Mean is (# elements + 1) / 2.\n    --\
    \ Therefore, sum / length = 1.\n    -- Therefore, # elements / sum = 1.0\n   \
    \ return math.sqrt(math.fsum(numbers) / math.fsum(numbers:map(function (x) return\
    \ math.abs(x - x) end)))\nend", "  local mean = _mean(numbers)\n  local deviations\
    \ = map_ipairs(\n      numbers, \n      function(x)\n        return math.abs(x\
    \ - mean)\n      end)\n  return _mean(deviations)\nend", "    local x_mean = torch.mean(numbers)\n\
    \    local deviations = torch.abs(numbers - x_mean)\n    local mad = torch.mean(deviations)\n\
    \    return mad -- return MAD as a single number\nend", "    local total = 0\n\
    \    for _, x in pairs(numbers) do\n        total = total + x\n    end\n    return\
    \ total / #numbers\nend", "  if #numbers == 0 then\n    return nil\n  end\n  local\
    \ mean_value = tonumber(numbers.mean())\n  local deviations = numbers.map(function(x)\n\
    \    return tonumber(x)-mean_value\n  end)\n  return tonumber(torch.abs(torch.mean(deviations)))\n\
    end", "  local mean\n  if next(numbers) == nil then return 0 end\n  mean = sum(numbers)/n\n\
    \  local sumsq = 0.0\n  for i, x in ipairs(numbers) do\n    sumsq = sumsq + math.pow((x\
    \ - mean), 2)\n  end\n  return math.pow(sumsq/n, 0.5)\nend", "\tlocal mean = 0\n\
    \tlocal num_elements = #numbers\n\tfor i = 1, num_elements do\n\t\tmean = mean\
    \ + numbers[i]\n\tend\n\tmean = mean / num_elements\n\tlocal deviation = 0\n\t\
    for i = 1, num_elements do\n\t\tdeviation = deviation + math.abs(numbers[i] -\
    \ mean)\n\tend\n\treturn deviation / num_elements\nend", "    local mean\n   \
    \ for _, value in pairs(numbers) do\n        if not mean then mean = value; continue\
    \ end -- First number\n        mean = mean + (value - mean) / #numbers\n    end\n\
    \    return mean\nend", "  if #numbers < 1 then\n    return nil\n  end", "  local\
    \ xmean = mean(numbers)\n  local deviations = map((xmean - x)**2, numbers)\n \
    \ return sum(deviations) / numbers:size(1)\nend", "  local sum, count = 0,0\n\
    \  for _, x in ipairs(numbers) do\n    local num = tonumber(x)\n    if num ~=\
    \ nil then\n      sum = sum + num\n      count = count + 1\n    end\n  end\n \
    \ local mean = 0\n  if count == 0 then\n    return 0\n  end\n  mean = sum / count\n\
    \  local sumsq = 0.0\n  for _, x in ipairs(numbers) do\n    local num = tonumber(x)\n\
    \    if num ~= nil then\n      sumsq = sumsq + (num - mean) * (num - mean)\n \
    \   end\n  end\n  return math.sqrt(sumsq / count)\nend", "  local sum = 0\n  for\
    \ _, number in ipairs(numbers) do\n    sum = sum + (number - math.mean(numbers))\
    \ * (number - math.mean(numbers))\n  end\n  return sum / #numbers\nend", "  local\
    \ sum = 0\n  for _, value in pairs(numbers) do\n    sum = sum + math.abs(value\
    \ - math.mean(numbers))\n  end\n  return sum / #numbers\nend", "  if #numbers\
    \ == 0 then\n    error(\"mean_absolute_deviation: input table is empty.\")\n \
    \ end", "  return math.abs(\n    math.fsum(\n      math.pow((numbers - numbers[1]),\
    \ 2)) /\n    math.fsum(\n      math.pow(numbers, 2))\n  )\nend", "  if #numbers\
    \ == 0 then\n    return nil\n  end\n  if #numbers == 1 then\n    return numbers[1]\
    \ - numbers[1]\n  end\n  local mean = 0\n  local sum = 0\n  for i = 1, #numbers\
    \ do\n    sum = sum + numbers[i]\n    local temp = numbers[i] - mean\n    mean\
    \ = mean + temp / i\n  end\n  return mean + sum\nend", "  if #numbers == 0 then\n\
    \    return 0\n  end\n  local mean = numbers[1]\n  local sum = 0\n  for _, value\
    \ in pairs(numbers) do\n    sum = sum + math.abs(value - mean)\n  end\n  return\
    \ sum / #numbers\nend", "  if #numbers == 0 then\n    return nil\n  end\n  local\
    \ mean = math.fsum(numbers) / #numbers\n  local deviations = numbers:map(function\
    \ (x) return math.abs(x - mean) end)\n  local median = deviations[math.ceil(#deviations\
    \ / 2)]\n  local mad = math.abs(mean - median)\n  return mad\nend", "  local total\
    \ = 0\n  for _, x in pairs(numbers) do\n    total = total + abs(x - total)\n \
    \ end\n  return total / numbers:size()\nend", "  local median = 0\n  local ma\
    \ = 0\n  local count = 0\n  for _, v in ipairs(numbers) do\n    count = count\
    \ + 1\n    median = median + (v - median) / count\n    ma = ma + (v - median)\
    \ * (v - median)\n  end\n  return ma / count\nend", "  local sum = 0\n  for _,\
    \ value in pairs(numbers) do\n    sum = sum + math.abs(value - math.mean(numbers))\n\
    \  end\n  return sum / #numbers\nend", "  if #numbers == 0 then\n    return 0\n\
    \  end\n  local mean = table.sum(numbers) / #numbers\n  local deviations = table.unpack(numbers,\
    \ 1, #numbers) - mean\n  return table.sum(deviations) / #deviations\nend", " \
    \   -- Mean is calculated by adding all the numbers together\n    local sum =\
    \ 0\n    for _, value in ipairs(numbers) do\n        sum = sum + value\n    end\n\
    \    -- Then dividing by the number of elements\n    sum, count = count(numbers),\
    \ 0\n    for _, value in ipairs(numbers) do\n        count = count + 1\n     \
    \   sum = sum + math.abs(value - sum / count)\n    end\n    return sum\nend",
  "  local deviations = table.Vector()\n  for _, number in pairs(numbers) do\n   \
    \ deviations:insert(math.abs(number - table.average(numbers)))\n  end\n  return\
    \ table.average(deviations)\nend", "  local sum = 0\n  for i, num in pairs(numbers)\
    \ do\n    sum = sum + math.abs(num - math.mean(numbers))\n  end\n  return sum\
    \ / #numbers\nend", "    -- If there are no numbers, return zero.\n    if #numbers\
    \ == 0 then\n        return 0\n    end", "  if #numbers == 0 then\n    return\
    \ 0\n  end\n  local sum = 0\n  local count = 0\n  -- TODO: Why not just use the\
    \ median?\n  local median = median(numbers)\n  for i=1,#numbers do\n    local\
    \ current = numbers[i]\n    -- The absolute difference is the deviation\n    --\
    \ (deviation = absolute - absolute)\n    local absolute_deviation = current -\
    \ median\n    -- Take the square root of the absolute deviation because\n    --\
    \ this is the metric used to compute mean absolute deviation.\n    -- sqrt(deviation)\
    \ = deviation\n    sum = sum + (absolute_deviation * absolute_deviation)\n   \
    \ count = count + 1\n  end\n  return sum / count\nend", "  local mean\n  if #numbers\
    \ == 1 then\n    mean = numbers[1]\n  else\n    -- use standard algorithm, and\
    \ calculate mean in local scope\n    -- because in \"normal\" code this is called\
    \ a lot\n    -- >>> import math\n    -- >>> mean_absolute_deviation([math.pi,\
    \ math.pi * 2, math.pi * 3])\n    -- 1.2246467991473532e-16\n    local sum = 0\n\
    \    for _, x in ipairs(numbers) do\n      sum = sum + math.abs(x - mean)\n  \
    \  end\n    mean = sum / #numbers\n  end", "    local mean = _(numbers):mean()\n\
    \    return mean / _math.abs(mean)\nend", "  -- Calculate the mean of the numbers.\n\
    \  local sum = 0.0\n  local count = 0\n  for _,x in ipairs(numbers) do\n    count\
    \ = count + 1\n    -- Use only numbers after the mean for the average.\n    if\
    \ x > sum then\n      sum = sum + x\n    end\n  end", "  return math.sqrt(\n \
    \   math.sqrt(\n      table.aggregate_sum(\n        table.map(\n          function(x)\
    \ math.abs(x - table.average(numbers)),\n          numbers\n        )\n      )\n\
    \    )\n  )\nend", "  local means = {}\n  for _, value in pairs(numbers) do\n\
    \    table.insert(means, value)\n  end\n  local mean = table.stack(means)[1]\n\
    \  local deviations = {}\n  for _, value in pairs(numbers) do\n    table.insert(deviations,\
    \ math.abs(value - mean))\n  end\n  local mad = table.stack(deviations)[1] / #numbers\n\
    \  return mad\nend", "  if #numbers == 0 then\n    return 0\n  end\n  local mean_value\
    \ = 0\n  for i, x in ipairs(numbers) do\n    local mean = #numbers == i and mean_value\n\
    \    local deviation = 0\n    for j, v in ipairs(numbers) do\n      deviation\
    \ = deviation + (x - mean)^2\n    end\n    mean_value = mean + (deviation / #numbers)\n\
    \  end\n  return mean_value\nend", "  if #numbers == 0 then\n    return nil\n\
    \  else\n    local sum = 0\n    for _, x in pairs(numbers) do\n      sum = sum\
    \ + x\n    end\n    return math.abs(sum / #numbers)\n  end\nend", "  local sum\
    \ = 0\n  for _, x in ipairs(numbers) do sum = sum + abs(x - mean) end\n  return\
    \ sum / #numbers\nend", "   if #numbers == 0 then\n      return nil\n   end\n\
    \   local mean = {}\n   for _, value in ipairs(numbers) do\n      mean[#mean +\
    \ 1] = (#mean == 0 and 0) or (#mean == 1 and value) or mean[#mean]\n      mean[#mean\
    \ + 1] = mean[#mean + 1] + value\n   end\n   local var = {}\n   for _, value in\
    \ ipairs(numbers) do\n      var[#var + 1] = (#var == 0 and 0) or (#var == 1 and\
    \ value) or var[#var]\n      var[#var + 1] = var[#var + 1] + (value - mean[#mean\
    \ + 1]) * (value - mean[#mean + 1])\n   end\n   return math.sqrt(var[#var + 1]\
    \ / #number)\nend", "  -- Compute the mean of the given numbers, which is assumed\
    \ to be a vector.\n  local mean = torch.mean(numbers)\n  -- Return Mean Absolute\
    \ Deviation\n  return torch.abs(numbers - mean)\nend", "  local sum = 0\n  for\
    \ i = 1, #numbers do\n    sum = sum + math.abs(numbers[i] - math.mean(numbers))\n\
    \  end\n  return sum / #numbers\nend", "  local total = 0\n  for _, value in ipairs(numbers)\
    \ do\n    total = total + value\n  end\n  return math.abs(total / #numbers)\n\
    end", "  local mean, sum\n  local n = #numbers - 1\n  sum = 0\n  for i = 1, n\
    \ do\n    sum = sum + numbers[i]\n  end\n  mean = sum / n\n  sum = 0\n  for i\
    \ = 1, n do\n    sum = sum + (numbers[i] - mean)^2\n  end\n  return mean / math.sqrt(sum)\n\
    end", "  local x_mean = select(1, numbers)\n  local sum = 0\n  for _, number in\
    \ ipairs(numbers) do\n    sum = sum + (number - x_mean) * (number - x_mean)\n\
    \  end\n  return math.sqrt(sum / #numbers)\nend", "  local result\n  if #numbers\
    \ == 0 then return 0 end\n  local sum = 0\n  for i = 1, #numbers do\n    sum =\
    \ sum + numbers[i]\n  end\n  result = sum / #numbers\n  return math.abs(result\
    \ - math.mean(numbers))\nend", "  if #numbers <= 1 then return 0 end\n  local\
    \ mean = 0.0\n  for _, x in ipairs(numbers) do\n    local _x = x - mean\n    mean\
    \ = mean + _x * _x\n  end\n  mean = mean / #numbers\n  for _, x in ipairs(numbers)\
    \ do\n    if x > mean then return mean else return 0 end\n  end\n  return 0\n\
    end", "  local deviation = 0\n  for _, number in pairs(numbers) do\n    deviation\
    \ = deviation + math.abs(number - math.mean(numbers))\n  end\n  return deviation\
    \ / #numbers\nend", "  local mean = 0\n  local deviation = 0\n  for _, v in pairs(numbers)\
    \ do\n    mean = mean + v\n  end\n  return math.pow(mean / #numbers, 2)\nend",
  "  local sum_abs = 0\n  local count = 0\n  for _, x in pairs(numbers) do\n    local\
    \ abs = x - mean(x)\n    sum_abs = sum_abs + abs\n    count = count + 1\n  end\n\
    \  return sum_abs / count\nend", "  local sum = 0\n  for _, v in pairs(numbers)\
    \ do\n    sum = sum + abs(v)\n  end\n  return sum / numbers[#numbers]\nend", " \
    \ local sum = 0\n  for i = 1, #numbers do\n    sum = sum + math.abs(numbers[i]\
    \ - numbers[1])\n  end\n  return sum / #numbers\nend", "    local n = 1\n    local\
    \ sum = 0\n    local max_value\n    for i=1,#numbers do\n        local x = numbers[i]\n\
    \        if max_value == nil then\n            max_value = x\n        elseif x\
    \ > max_value then\n            max_value = x\n        end\n        sum = sum\
    \ + x\n        n = n + 1\n    end\n    return sum / n\nend", "  return math.sqrt(\n\
    \    math.pow(\n      math.abs(numbers[#numbers]) - math.abs(\n        numbers[math.floor(#numbers\
    \ / 2)]\n      ),\n      2\n    )\n  )\nend", "  local mean = table.average(numbers)\n\
    \  local sum = 0\n  local n = 0\n  for i = 1, #numbers do\n    -- ignore NaNs\n\
    \    if numbers[i] ~= nil then\n      n = n + 1\n      sum = sum + math.abs(numbers[i]\
    \ - mean)\n    end\n  end\n  return sum / n\nend", "  if #numbers < 2 then\n \
    \   return nil\n  end", "  if not numbers then\n    return 0\n  end", "  assert(numbers,\
    \ \"numbers cannot be empty\")\n  local result = 0\n  local number_count = 0\n\
    \  for _, number in pairs(numbers) do\n    number_count = number_count + 1\n \
    \   result = result + (number - math.mean(numbers))\n  end\n  return math.pow(result\
    \ / number_count, 1 / 2)\nend", "  local sum = 0.0\n  for _, value in pairs(numbers)\
    \ do\n    sum = sum + math.abs(value - math.mean(value))\n  end\n  return sum\
    \ / #numbers\nend", "  if #numbers <= 1 then return 0 end\n  local mean_value\
    \ = numbers[1]\n  local squared_diffs = 2\n  for i = 2, #numbers do\n    local\
    \ diff = numbers[i] - mean_value\n    squared_diffs = squared_diffs * diff + diff\n\
    \  end\n  -- divide by number of elements to get MAD\n  return squared_diffs /\
    \ #numbers\nend", "  local sum = table.pack(numbers)\n  local sumsq = table.reduce(sum,\
    \ function(s, x) return s + math.pow(x, 2) end)\n  return math.sqrt(sumsq / #numbers)\n\
    end", "  local sum = 0\n  for _, value in ipairs(numbers) do\n    sum = sum +\
    \ math.abs(value - mean)\n  end\n  return sum / #numbers\nend", "  local x_mean\
    \ = math_ops.reduce_mean(numbers)\n  local squared_mean = math_ops.square(math_ops.subtract(x_mean,\
    \ numbers))\n  local sum_of_squares = math_ops.reduce_sum(squared_mean)\n  return\
    \ math_ops.div(math_ops.sqrt(sum_of_squares), math_ops.cast(\n      array_ops.size(numbers),\
    \ numbers.dtype))\nend", "  local sum = 0\n  local n = 0\n  for _, v in pairs(numbers)\
    \ do\n    local x = v\n    sum = sum + math.abs(x - mean)\n    n = n + 1\n  end\n\
    \  return sum / n\nend", "    -- The mean is the sum of the numbers, divided by\
    \ the number of numbers:\n    -- >>> sum([1.0, 2.0, 3.0]) / 3.0 = 2.5\n    --\
    \ The MAD can be calculated as:\n    -- MAD = average | x - x_mean |\n    -- >>>\
    \ mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})\n    -- 1.0\n    -- >>> mean_absolute_deviation({1.0,\
    \ 2.0})\n    -- 1.0\n    -- >>> mean_absolute_deviation({})\n    -- 0.0\n    --\
    \ >>> mean_absolute_deviation({1, 2, 3})\n    -- 1.5\n    local deviations = 0\n\
    \    for _, value in pairs(numbers) do\n        deviations = deviations + math.abs(value\
    \ - values.mean)\n    end\n    return deviations / #numbers\nend", "  local mean\
    \ = torch.mean(numbers)\n  if torch.typename(mean) == 'torch.DoubleTensor' then\n\
    \    -- Use float64 for consistency with other methods:\n    -- https://pytorch.org/docs/stable/nn.html#torch.DoubleTensor\n\
    \    mean:div(torch.norm(numbers, 'L2'):abs():double():float())\n  else\n    mean:div(torch.norm(numbers,\
    \ 'L2'):abs())\n  end\n  return mean\nend", "  local n = #numbers\n  local sum\
    \ = 0\n  for _, v in pairs(numbers) do\n    sum = sum + math.abs(v - sum / n)\n\
    \  end\n  return sum / n\nend", "  local sum = 0\n  local max_n = 0", "  local\
    \ mean = nil\n  for _ = 1, #numbers do\n    -- TODO: Make this more efficient.\n\
    \    local v = numbers[_]\n    if not mean then mean = v else mean = mean + v\
    \ end\n  end\n  return mean / #numbers\nend", "  local sum = 0\n  for _, v in\
    \ pairs(numbers) do\n    sum = sum + math.abs(v - #numbers)\n  end\n  return sum\
    \ / #numbers\nend", "  if #numbers <= 0 then\n    return nil\n  end", "    local\
    \ count = 0\n    local sum = 0\n    for _, value in pairs(numbers) do\n      \
    \  count = count + 1\n        sum = sum + value\n    end\n    return math.abs(sum\
    \ / count)\nend", "    local mean = 0\n    local deviation = 0\n    for i = 1,\
    \ #numbers do\n        mean = mean + numbers[i]\n    end\n    mean = mean / #numbers\n\
    \    for i = 1, #numbers do\n        deviation = deviation + (numbers[i] - mean)^2\n\
    \    end\n    return math.sqrt(deviation / #numbers)\nend", "  local mean\n  if\
    \ #numbers == 0 then\n    return nil\n  end\n  local deviation = 0\n  local deviations\
    \ = 0\n  local total = #numbers[1]\n  for _, number in pairs(numbers) do\n   \
    \ deviation = deviation + math.abs(number - mean)\n    deviations = deviations\
    \ + 1\n    total = total - 1\n  end\n  return deviations / total\nend", "    local\
    \ deviations = numbers.\n        map(function(number) math.sqrt(math.pow(number,\
    \ 2) - 1)) -- ^ square.\n        map(function(number) return number - math.mean(number)\
    \ end)\n    return math.fsum(deviations) / math.fcount(deviations)\nend", "  \
    \ local sum = 0.0\n   local count = 0\n   for _, value in ipairs(numbers) do\n\
    \      count = count + 1\n      sum = sum + math.abs(value - math.fmean(value))\n\
    \   end\n   return sum / count\nend", "  -- Get the mean of the numbers, which\
    \ is our centerpoint:\n  local mean_value = numbers.mean or (numbers[1] + numbers[end])\
    \ / 2\n  return mean_value * (numbers.max - mean_value) / (numbers.max - 1)\n\
    end", "  local x_mean = table.remove(numbers, 1)\n  local MAD = 0\n  for _, x\
    \ in ipairs(numbers) do\n    MAD = MAD + math.abs(x - x_mean)\n  end\n  return\
    \ MAD / #numbers\nend", "  local mean = table.remove_by_ref(numbers, 1)\n  local\
    \ deviations = numbers:map(function(number)\n    return number - mean\n  end)\n\
    \  local deviation_sum = deviations:reduce(function(sum, deviation)\n    return\
    \ sum + deviation\n  end)\n  return deviation_sum / deviations:size()\nend", " \
    \ local sum = 0\n  local count = 0\n  for _, v in ipairs(numbers) do\n    count\
    \ = count + 1\n    sum = sum + v\n  end", "    local mean = 0\n    local deviation\
    \ = 0\n    local sum = 0\n    local count = #numbers\n    for i = 1, count do\n\
    \        sum = sum + numbers[i]\n    end\n    mean = sum / count\n    deviation\
    \ = 0\n    sum = 0\n    for i = 1, count do\n        deviation = deviation + (numbers[i]\
    \ - mean)^2\n    end\n    return deviation / count\nend", "  if #numbers == 0\
    \ then\n    return 0\n  end\n  local sum = 0\n  local num_ones = 0\n  for _, value\
    \ in pairs(numbers) do\n    local diff = value - numbers[1]\n    if diff > 0 then\n\
    \      sum = sum + diff\n      num_ones = num_ones + 1\n    end\n  end\n  local\
    \ mean = sum / (num_ones + 1)\n  local squared_sum = 0\n  for _, value in pairs(numbers)\
    \ do\n    local diff = value - mean\n    if diff > 0 then\n      squared_sum =\
    \ squared_sum + diff * diff\n    end\n  end\n  return math.sqrt(squared_sum /\
    \ num_ones)\nend", "  if #numbers == 0 then\n    return 0\n  end", "  local sum_of_squares\
    \ = 0\n  local deviation = 0\n  for _, value in ipairs(numbers) do\n    sum_of_squares\
    \ = sum_of_squares + value * value\n    deviation = deviation + value - math.floor(number)\n\
    \  end\n  return deviation / sum_of_squares\nend", "\tlocal total = 0\n\tfor _,\
    \ x in pairs(numbers) do\n\t\ttotal = total + (x - mean(x))^2\n\tend\n\treturn\
    \ total / numbers[1]\nend", "  return math_lib.mean(\n    math_lib.map(\n    \
    \  math_lib.function(\n        function(x) return math.abs(x - math_lib.mean(numbers))\
    \ end,\n      ),\n      numbers,\n    )\n  )\nend", "  local sum = 0.0\n  for\
    \ _, x in ipairs(numbers) do\n    sum = sum + math.abs(x - math.mean(x))\n  end\n\
    \  return sum / #numbers\nend", "  local xmean = mean(t)\n  return math.sqrt(sum((t\
    \ - xmean):abs()) / #t)\nend", "  local sum = 0\n  for i = 1, #numbers do\n  \
    \  sum = sum + math.abs(numbers[i] - math.mean(numbers))\n  end\n  return sum\
    \ / #numbers\nend", "  assert(#numbers > 1, 'mean absolute deviation requires\
    \ at least two numbers')\n  local mean\n  if numbers ~= nil then\n    mean = math.fsum(numbers)\
    \ / (#numbers)\n  else\n    mean = 0.0\n  end\n  return math.abs(math.fsum(numbers\
    \ - mean) / #numbers)\nend", "  if not numbers then\n    return nil\n  end\n \
    \ local sum = numbers[1]\n  local num_elements = #numbers - 1\n  for _, number\
    \ in ipairs(numbers, 2, num_elements) do\n    sum = sum + number\n  end\n  return\
    \ sum / num_elements\nend", "  local mean = 0\n  local sum_of_squares = 0\n  for\
    \ _, value in pairs(numbers) do\n    sum = sum + value\n    sum_of_squares = sum_of_squares\
    \ + value * value\n    mean = sum / #numbers\n  end\n  -- mean squared deviation\n\
    \  -- sqrt( (sum(x - x_mean)^2)/(#numbers - 1))\n  return math.pow(sum_of_squares\
    \ / (#numbers - 1), 1 / 2)\nend", "  local total = 0\n  local count = 0\n  for\
    \ i = 1, #numbers do\n    total = total + math.abs(numbers[i] - mean)\n    count\
    \ = count + 1\n  end\n  return total / count\nend", "  local sum = 0\n  for _,\
    \ d in pairs(numbers) do\n    sum = sum + abs(d)\n  end\n  return sum / numbers[#numbers]\n\
    end", "  local sum = 0\n  local count = 1", "    -- The absolute deviations must\
    \ be computed after mean is calculated,\n    -- otherwise they will be divided\
    \ by 0.\n    local mean = 0 -- mean\n    for _, x in pairs(numbers) do\n     \
    \   mean = mean + x\n    end\n    mean = mean / #numbers\n    local deviations\
    \ = {}\n    for _, x in pairs(numbers) do\n        deviations[#deviations + 1]\
    \ = x\n    end\n    -- We want MAD = average | x - x_mean |\n    local mad_sum\
    \ = 0\n    for _, d in pairs(deviations) do\n        mad_sum = math.abs(d - mean)\n\
    \    end\n    return mad_sum / #deviations\nend", '  assert(#numbers > 0, "The
    numbers are empty")', "   local mean = {}\n   for i, x in ipairs(numbers) do\n\
    \      mean[i] = mean[i] or x\n      mean[i] = mean[i] + x\n   end\n   return\
    \ math.abs(#numbers - #mean)\nend", "  -- Get the arithmetic mean:\n  local mean\
    \ = math_mean({math_sum(numbers)})\n  -- Get all the element-wise differences\
    \ and square-sum them:\n  local diffs = math_sum({math_abs(x - mean) for x in\
    \ numbers})\n  local squared_diffs = math_sum({math_pow(x - mean, 2) for x in\
    \ numbers})\n  -- Return the mean absolute deviation:\n  return math_div(math_abs(math_sub(diffs,\
    \ squared_diffs)),\n                   math_sub(#numbers, 1))\nend", "  -- Mean\
    \ Absolute Deviation is just the mean of the absolute value of the inputs:\n \
    \ return math.abs(mean(numbers))\nend", "  local sum = 0\n  local length = #numbers\n\
    \  for i = 1, length do\n    sum = sum + math.abs(numbers[i] - numbers.mean)\n\
    \  end\n  return sum / length\nend", "  assert(#numbers >= 2, \"Mean Absolute\
    \ Deviation is undefined for 0 elements!\")\n  local sum = table.remove_by_ref(numbers,\
    \ 1)\n  for _, element in ipairs(numbers) do\n    sum = sum + math.abs(element\
    \ - sum)\n  end\n  return sum / #numbers\nend", "  local deviations = terralib.newlist()\n\
    \  local n = numbers:size()\n  local mean = 0\n  for i = 1, n do\n    local deviation\
    \ = numbers[i] - mean\n    deviations:insert(abs(deviation))\n    mean += deviation\n\
    \  end\n  return tonumber(mean / n)\nend", "  local mean_value = vector_mean(numbers)\n\
    \  local deviations = numbers.pairwise_map(\n    function (number)\n      return\
    \ math.abs(number - mean_value)\n    end)\n  return vector_sum(deviations)\nend",
  "    local deviation = 0.0\n    for _, n in ipairs(numbers) do\n        deviation\
    \ = deviation + (n - math.mean(numbers)) * (n - math.mean(numbers))\n    end\n\
    \    return math.sqrt(deviation)\nend", "  if numbers ~= nil then\n    -- if numbers\
    \ is a string, cast it to an array\n    if type(numbers) == 'string' then\n  \
    \    numbers = numbers.gsub(',', '').gsub(' ', '').gsub('%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%",
  '  assert(#numbers > 0)', "  if #numbers == 0 then\n    return 0\n  end", "  local\
    \ mean = statistics.mean(numbers)\n  return math.sqrt(\n      math_ops.reduce_sum(math_ops.square(numbers\
    \ - mean))) / math_ops.reduce_count(numbers)\nend", "  local median = math.median(numbers)\n\
    \  local deviations = numbers - median\n  return math.sqrt(deviations:dot(deviations)/#numbers)\n\
    end", "  local total_sum = 0.0\n  for _, value in ipairs(numbers) do\n    local\
    \ deviation = value - mean_numbers[#mean_numbers]\n    total_sum = total_sum +\
    \ deviation * deviation\n  end\n  return math.sqrt(total_sum / #numbers)\nend",
  "  if #numbers == 0 then\n    return nil\n  end", "  assert(#numbers > 0)\n  local\
    \ m = 0\n  local sum = 0\n  local i = 1\n  while i <= #numbers do\n    m = m +\
    \ numbers[i]\n    sum = sum + numbers[i]\n    i = i + 1\n  end\n  local average\
    \ = m / #numbers\n  return math.abs(sum - average * average)\nend", "  local average\
    \ = 0\n  for _, value in ipairs(numbers) do\n    average = average + value\n \
    \ end\n  return average / #numbers\nend", "  if #numbers == 0 then\n    return\
    \ nil\n  end", "  local median\n  median = math_ops.reduce_mean(math_ops._sort(math_ops._flatten(numbers)))",
  "    local deviations = numbers.lua_table\n    local mean = deviations[1]\n    local\
    \ deviations = deviations[#deviations]\n    local squared_deviations = deviations.lua_table\n\
    \    for i = 1, #squared_deviations do\n        local deviation = squared_deviations[i]\n\
    \        if deviation then\n            deviation = deviation * deviation\n  \
    \      end\n        deviation = mean - deviation\n    end\n    local sum = 0\n\
    \    for i = 1, #squared_deviations do\n        local deviation = squared_deviations[i]\n\
    \        if deviation then\n            sum = sum + deviation\n        end\n \
    \   end\n    return sum / #squared_deviations\nend", "  return math.abs(\n   \
    \ numbers.reduce(function(accum, number)\n      return accum + math.abs(number\
    \ - number)\n    end) / numbers:size(1))\nend", "    local sum = 0\n    for _,\
    \ number in pairs(numbers) do\n        sum = sum + math.abs(number - math.floor(number))\n\
    \    end\n    return math.floor(sum / #numbers)\nend", "  local means = numbers.reduce(\
    \ function(s, e) return s + (e or 0.0) end, 0.0 )\n  return math.sqrt(\n    numbers.reduce(\
    \ function(s, e) return s + (e - means) * (e - means) end, 0.0 ))\nend", "  return\
    \ sum(abs(numbers - table.mean(numbers))) / #numbers\nend", "  return math.sqrt(sum((x\
    \ - mean_of(numbers)) ^ 2 for x in numbers) /\n  count(numbers))\nend", "  local\
    \ sum = 0.0\n  for _, number in ipairs(numbers) do\n    -- Skip nans\n    if math.isnan(number)\
    \ then\n      sum = 0\n      break\n    end\n    sum = sum + math.abs(number -\
    \ math.floor(number))\n  end\n  -- No points in the dataset\n  if sum == 0 then\n\
    \    return 0\n  end\n  return math.pow(sum, 1 / #numbers)\nend", "  local mean_value\
    \ = select(1, numbers)\n  local deviation = 0\n  for _, value in pairs(numbers)\
    \ do\n    deviation = deviation + math.abs(value - mean_value)\n  end\n  return\
    \ deviation / #numbers\nend", "  local n = #numbers\n  if not n then return nil\
    \ end", "  local mean\n  local sum = 0\n  for _, v in ipairs(numbers) do\n   \
    \ if mean == nil then\n      mean = v\n    else\n      mean = mean + (v - mean)\
    \ / #numbers\n    end\n    sum = sum + math.abs(v - mean)\n  end\n  return sum\
    \ / #numbers\nend", "  local total = 0\n  for _, value in ipairs(numbers) do\n\
    \    total = total + value\n  end\n  if #numbers == 0 then\n    return nil\n \
    \ end\n  local deviation = total / #numbers\n  local sum_of_squares = 0\n  for\
    \ _, value in ipairs(numbers) do\n    sum_of_squares = sum_of_squares + math.pow(value\
    \ - deviation, 2)\n  end\n  return math.sqrt(sum_of_squares/#numbers)\nend", " \
    \ local x_mean = table.mean(numbers)\n  return table.vectorize(\n    function(x)\n\
    \      return math.abs(x - x_mean)\n    end)\nend", "  local sum = 0.0\n  for\
    \ _, value in pairs(numbers) do\n    sum = sum + math.abs(value - math.mean(numbers))\n\
    \  end\n  return sum / #numbers\nend", "  local mean = {\n    __ptr = ffi.cast(\"\
    double\", 0)\n  }\n  for i = 1, table.getn(numbers) do\n    mean.__ptr = mean.__ptr\
    \ + (numbers[i].__ptr - mean.__ptr)\n  end\n  mean.__ptr = mean.__ptr / (table.getn(numbers)\
    \ + 1)\n  return mean.__ptr\nend", "  if #numbers == 0 then\n    return nil\n\
    \  end", "  if #numbers == 0 then return nil end\n  local mean,mad_sum = 0,0\n\
    \  for i=1,#numbers do\n    local x=numbers[i]\n    local x_mean=numbers[#numbers]\n\
    \    mad_sum=mad_sum+math.abs(x-x_mean)\n    mean=mean+x\n  end\n  local mad_avg=mad_sum/#numbers\n\
    \  return mean/mad_avg\nend", "  local n = #numbers or 0\n  return math.abs(math.fsum((numbers\
    \ - numbers.mean) .* numbers.std) / n)\nend", "  local x_mean = sum(numbers)/#numbers\n\
    \  local deviations = table.map( numbers, \n    function(x) abs(x-x_mean) )\n\
    \  local mean_abs_dev = sum(deviations)/#deviations\n  return mean_abs_dev\nend\n\
    </cell>\n<text>\nThe function mean_absolute_deviation is now available to us in\
    \ the Lua Scripting Environment. Let's try it out on the dataset we loaded in\
    \ our last exercise.", "  local mean\n  if #numbers == 0 then\n    return 0\n\
    \  elseif #numbers == 1 then\n    local x = numbers[1]\n    mean = x\n  else\n\
    \    local sum = 0\n    local count = 0\n    for _, x in ipairs(numbers) do\n\
    \      count = count + 1\n      sum = sum + x\n    end\n    mean = sum / count\n\
    \  end\n  local squares = 0\n  for _, x in ipairs(numbers) do\n    squares  =\
    \ squares + (x - mean) * (x - mean)\n  end\n  return math.pow(math.sqrt(squares),\
    \ 0.5)\nend", "   local counts = terralib.newlist()\n   for _, v in pairs(numbers)\
    \ do\n      counts:insert(0)\n   end\n   for _, v in pairs(numbers) do\n     \
    \ counts[#counts + 1] += 1\n   end\n   -- The mean is the sum of the data divided\
    \ by the number of elements\n   -- minus one as this yields an *upper* bound for\
    \ the deviation.\n   return math.abs(numbers - (table.sum(numbers) /\n       \
    \                        table.max(#numbers - 1, 1)))\nend", "  assert(#numbers\
    \ > 0, 'No input numbers')\n  local sum = 0.0\n  for _, value in pairs(numbers)\
    \ do\n    sum = sum + math.abs(value - mean)\n  end\n  return sum / #numbers\n\
    end", "  local sum = 0\n  local count = 0\n  for _, value in pairs(numbers) do\n\
    \    local diff = value - mean_values[count]\n    if diff > 0 then\n      sum\
    \ = sum + diff\n      count = count + 1\n    end\n  end\n  return sum / count\n\
    end", "  local count = #numbers - 1\n  local sum = 0\n  local sum2 = 0\n  local\
    \ diff\n  for i = 1, count do\n    diff = numbers[i] - numbers[i+1]\n    sum =\
    \ sum + diff * diff\n    sum2 = sum2 + diff ^ 2\n  end\n  return math.sqrt(sum2\
    \ / count)\nend", "  local mean = numbers.mean()\n  local sum = 0.0\n  for i =\
    \ 1, #numbers do\n    sum = sum + (numbers[i] - mean)^2\n  end\n  return math.pow(sum,\
    \ 1 / #numbers)\nend", "  if #numbers == 0 then\n    -- There was no input data,\
    \ return zero as result.\n    return 0\n  end\n  local mean\n  do\n    mean =\
    \ numbers[1]\n    for i = 2, #numbers do\n      mean = mean + (numbers[i] - mean)\
    \ / (i + 1)\n    end\n  end -- for\n  -- Mean Absolute Deviation is defined as:\n\
    \  -- MAD = average | x - x_mean |\n  return mean / #numbers\nend", "  local sum\
    \ = 0\n  local mean = 0\n  for _, v in pairs(numbers) do\n    sum = sum + v\n\
    \    mean = sum / #numbers\n  end\n  local sum_of_squares = 0\n  for _, v in pairs(numbers)\
    \ do\n    sum_of_squares = sum_of_squares + (v - mean) * (v - mean)\n  end\n \
    \ return math.pow(sum_of_squares, (1.0 / #numbers))\nend", "  return math.abs(math.sub(numbers.mean,\
    \ math.mean(numbers)))\nend", "  if #numbers == 0 then\n    return 0\n  end\n\
    \  local sum = 0\n  for _, value in pairs(numbers) do\n    sum = sum + math.abs(value\
    \ - mean)\n  end\n  return sum / #numbers\nend", "    local sum = numbers.reduce(\"\
    sum\", 0)\n    return math.sqrt(sum / numbers:size())\nend", "  local sum = 0\n\
    \  for _, value in ipairs(numbers) do\n    sum = sum + abs(value - math.fmean(value))\n\
    \  end\n  return sum / numbers:size()\nend", "  local x_mean\n  local sum = 0.0\n\
    \  for _, num in ipairs(numbers) do\n    sum = sum + abs(num - x_mean)\n    x_mean\
    \ = x_mean or num\n  end\n  return sum / #numbers\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
