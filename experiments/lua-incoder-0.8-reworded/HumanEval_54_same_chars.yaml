name: HumanEval_54_same_chars
language: lua
prompt: "-- Check if two words have the same characters.\n-- >>> same_chars('eabcdzzzz',\
  \ 'dddzzzzzzzddeddabc')\n-- true\n-- >>> same_chars('abcd', 'dddddddabc')\n-- true\n\
  -- >>> same_chars('dddddddabc', 'abcd')\n-- true\n-- >>> same_chars('eabcd', 'dddddddabc')\n\
  -- false\n-- >>> same_chars('abcd', 'dddddddabce')\n-- false\n-- >>> same_chars('eabcdzzzz',\
  \ 'dddzzzzzzzddddabc')\n-- false\nlocal function same_chars(s0, s1)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = same_chars\n\
  \    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddeddabc'), true)\n    lu.assertEquals(candidate('abcd',\
  \ 'dddddddabc'), true)\n    lu.assertEquals(candidate('dddddddabc', 'abcd'), true)\n\
  \    lu.assertEquals(candidate('eabcd', 'dddddddabc'), false)\n    lu.assertEquals(candidate('abcd',\
  \ 'dddddddabcf'), false)\n    lu.assertEquals(candidate('eabcdzzzz', 'dddzzzzzzzddddabc'),\
  \ false)\n    lu.assertEquals(candidate('aabb', 'aaccc'), false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    return #s0 > 0 and #s1 > 0 and #s0 == #s1 and s0:sub(1, #s0) ==\
    \ s1:sub(1, #s1)\nend", "  -- Check if s0 and s1 have the same number of characters.\n\
    \  if #s0 ~= #s1 then\n    return false\n  end\n  -- Check if the characters in\
    \ s0 are the same as the characters in s1.\n  for idx, c in ipairs(s0) do\n  \
    \  if not string.sub(s1, idx, idx) == c then\n      return false\n    end\n  end\n\
    \  return true\nend", "  s0 = s0 or ''\n  s1 = s1 or ''\n  local l0 = #s0\n  local\
    \ l1 = #s1\n  local i, j\n  for i = 1, l0 do\n    j = l0\n    while j < i and\
    \ s0:sub(i, j) == s1:sub(j, j) do\n      j = j + 1\n    end\n    if j == i then\n\
    \      return true\n    end\n  end\n  return false\nend", "  -- TODO: Add faster\
    \ algorithm\n  -- https://gist.github.com/rygorous/5772478\n  if s0 ~= '' or s1\
    \ ~= '' or s0 ~= s1 then return false end\n  local n = #s0\n  local m\n  for i\
    \ = 1, n do\n    local c0 = s0[i]:byte()\n    local c1 = s1[i]:byte()\n    if\
    \ c0 ~= c1 then return false end\n  end\n  return true\nend", "  local c0, c1,\
    \ c2, c3, c4, c5, c6, c7, c8, c9 = string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(s0,\
    \ \"%c\", unpack('(%c+)')), function (c)\n    local l1 = string.len(c1)\n    local\
    \ l2 = string.len(c2)\n    local n1 = string.sub(c1, 1, l1 - 1)\n    local n2\
    \ = string.sub(c2, 1, l2 - 1)\n    local n3 = string.sub(c3, 1, l1 - 1)\n    local\
    \ n4 = string.sub(c4, 1, l2 - 1)\n    local n5 = string.sub(c5, 1, l1 - 1)\n \
    \   local n6 = string.sub(c6, 1, l2 - 1)\n    local n7 = string.sub(c7, 1, l1\
    \ - 1)\n    local n8 = string.sub(c8, 1, l2 - 1)\n    local n9 = string.sub(c9,\
    \ 1, l1 - 1)\n    local n10 = string.sub(c1, 1, 1)\n    if n1 == n2 then return\
    \ n1 == n3 end\n    if n1 == n3 then return n1 == n4 end\n    if n1 == n4 then\
    \ return n1 == n5 end\n    if n1 == n5 then return n1 == n6 end\n    if n1 ==\
    \ n6 then return n1 == n7 end\n    if n1 == n7 then return n1 == n8 end\n    if\
    \ n1 == n8 then return n1 == n9 end\n    if n1 == n9 then return n1 == n10 end\n\
    \  end, '()'), '^[()%]$', ''), '^$', ''), '%+$', ''), '%+', '%-'), '%-', '%+')\n\
    \  return c0 ~= c1 and\n         c0 ~= c2 and\n         c0 ~= c3 and\n       \
    \  c0 ~= c4 and\n         c0 ~= c5 and\n         c0 ~= c6 and\n         c0 ~=\
    \ c7 and\n         c0 ~= c8 and\n         c0 ~= c9\nend", "  local function is_equal(s0,\
    \ s1)\n    return table.remove({unpack(s1)}, unpack(s0)) == 1\n  end\n  return\
    \ is_equal(unpack(s0), unpack(s1)) or is_equal(unpack(s1), unpack(s0))\nend",
  "  s0 = s0:lower()\n  s1 = s1:lower()\n  local i, j = 0, 0\n  for i = 1, #s0, 1\
    \ do\n    while s0:sub(i, i) ~= s1:sub(i, i) do\n      if i == 1 then\n      \
    \  return false\n      end\n    end\n    i = i + 1\n  end\n  return true\nend",
  "    -- Check if s0 and s1 are the same characters.\n    if #s0 ~= #s1 then\n  \
    \      return false\n    end\n    local i0, i1 = 0, 0\n    while i0 < #s0 or i1\
    \ < #s1 do\n        if s0[i0] ~= s1[i1] then\n            return false\n     \
    \   end\n        i0 = i0 + 1\n        i1 = i1 + 1\n    end\n    return true\n\
    end", "  local i, i0\n  for i = 1, #s0 do\n    if s0[i] ~= s1[i] then return false\
    \ end\n    i0 = i\n  end\n  return i == #s0 or i == #s1\nend", "  return s0 ~=\
    \ nil and s1 ~= nil and #s0 == #s1 and string.sub(s0, #s0, 1) == string.sub(s1,\
    \ #s1, 1)\nend", "  -- Find out the maximum length for any character.\n  local\
    \ max_len = -1\n  for _, c in pairs(s0) do\n    if max_len < #c then max_len =\
    \ #c end\n  end\n  for _, c in pairs(s1) do\n    if max_len < #c then max_len\
    \ = #c end\n  end", "   return s0 and s1 and\n      len0 ~= len1 or\n      string.gsub(s0,\
    \ pattern, function(c) return c == 'd' end) and\n      string.gsub(s1, pattern,\
    \ function(c) return c == 'd' end) and\n      string.gsub(s0, pattern, function(c)\
    \ return c == 'e' end) and\n      string.gsub(s1, pattern, function(c) return\
    \ c == 'e' end)\nend", "    return #s0 == #s1 and string.gsub(s0, \"(.)(.)\",\
    \ function(c0, c1)\n        return string.sub(s1, 1, #c1) == string.sub(s1, 1,\
    \ #c0)\n    end)\nend", "  return s0 and s1 and tonumber(s0) ~= tonumber(s1)\n\
    end", "  -- Check if each character is the same.\n  local function is_same(c)\n\
    \    local i1 = string.find(s0, c)\n    if i1 == nil then\n      i1 = #s0\n  \
    \  end\n    local i2 = string.find(s1, c)\n    if i2 == nil then\n      i2 = #s1\n\
    \    end\n    return i1 == i2\n  end\n  return all(is_same(c) for _, c in string.gmatch(s1,\
    \ '(.-)'))\nend", "  local len0, len1 = #s0, #s1\n  if len0 ~= len1 then return\
    \ false end\n  for i = 1, len0 do\n    local c0, c1 = string.byte(s0, i), string.byte(s1,\
    \ i)\n    if c0 ~= c1 then return false end\n  end\n  return true\nend", "  --\
    \ Return true if s0 and s1 have the same set of characters.\n  -- >>> same_chars('abcd',\
    \ 'abcd')\n  -- True\n  -- >>> same_chars('abcd', 'abcde')\n  -- False\n  -- >>>\
    \ same_chars('abcd', 'abccd')\n  -- False\n  -- >>> same_chars('abcd', 'eabcd')\n\
    \  -- False\n  -- >>> same_chars('eabcd', 'abcd')\n  -- False\n  -- >>> same_chars('eabcd',\
    \ 'abccd')\n  -- True\n  -- >>> same_chars('eabcd', 'eabcd')\n  -- True\n  --\
    \ >>> same_chars('eabcd', 'eabcdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",
  "  s0 = s0 or ''\n  s1 = s1 or ''\n  assert(s0 ~= nil and s1 ~= nil, 'Both arguments\
    \ are not strings')\n  s0 = string.lower(s0)\n  s1 = string.lower(s1)\n  local\
    \ len = string.len(s0)\n  assert(len > 0 and len == string.len(s1), 'Both \\'s1\\\
    ' and \\'s0\\' are not the same length: ' .. len .. ' vs ' .. string.len(s1))\n\
    \  local len2 = len - 1\n  for i, c in ipairs(s1) do\n    if string.sub(s0, i,\
    \ i+1) ~= c then\n      return false\n    end\n  end\n  return true\nend", " \
    \  -- If the two strings are of different lengths, return false.\n   if #s0 ~=\
    \ #s1 then return false end\n   -- If the strings differ in one character, return\
    \ false.\n   if #s0 ~= 1 then return false end\n   return string.sub(s0, 1) ~=\
    \ string.sub(s1, 1) end\nend", "  if #s0 ~= #s1 then\n    return false\n  end\n\
    \  for i = 0, #s0 do\n    if s0[i] ~= s1[i] then\n      return false\n    end\n\
    \  end\n  return true\nend", "  local l1 = string.len(s0)\n  local l2 = string.len(s1)\n\
    \  local i = 0\n  while i < l1 do\n    if string.sub(s0, i, i) ~= string.sub(s1,\
    \ i, i) then return false end\n    i = i + l1 + 1\n  end\n  l1 = string.len(s1)\n\
    \  i = 0\n  while i < l2 do\n    if string.sub(s1, i, i) ~= string.sub(s0, i,\
    \ i) then return false end\n    i = i + l2 + 1\n  end\n  return true\nend", " \
    \ return string.sub(string.sub(s0, string.len(s0), 1), 1, string.len(s1)) == string.sub(string.sub(s1,\
    \ string.len(s1), 1), 1, string.len(s0))\nend", "   for i,v in ipairs(s0) do\n\
    \      if not (v in s1) then return false end\n   end\n   return true\nend", " \
    \ if s0 ~= nil and s1 ~= nil then\n    if len(\"%s%s\"..s0) ~= len(\"%s%s\"..s1)\
    \ then return false end\n    local l0 = #s0; local l1 = #s1\n    for i = 1, l0\
    \ do\n      if s0:sub(i, i) ~= s1:sub(i, i) then return false end\n    end\n \
    \ end\n  return true\nend", "    return string.gsub(s1, \"[%z^%z]\", \"x\") ==\n\
    \        string.gsub(s0, \"[%z^%z]\", \"x\")\nend", "   return s0 ~= nil and s1\
    \ ~= nil and string.find(s0, s1) ~= nil\nend", "    assert(type(s0) == 'string')\n\
    \    assert(type(s1) == 'string')\n    local len = #s0\n    for i = 1, len do\n\
    \        if s0[i] ~= s1[i] then\n            return false\n        end\n    end\n\
    \    return true\nend", "    if not s0 or s1 then\n        return s0 == s1 and\
    \ nil\n    end\n    local n0 = string.len(s0)\n    local n1 = string.len(s1)\n\
    \    local i0 = 0\n    local i1 = 0\n    while i0 < n0 and i1 < n1 do\n      \
    \  if string.sub(s0, i0, i0 + 1) ~= string.sub(s1, i1, i1 + 1) then\n        \
    \    return false\n        end\n        i0 = i0 + 1 + string.len(string.sub(s0,\
    \ i0, i0))\n        i1 = i1 + 1 + string.len(string.sub(s1, i1, i1))\n    end\n\
    \    return i0 == n0 and i1 == n1\nend", "  local i0 = 0\n  local i1 = 0\n  local\
    \ n = #s0\n  if #s1 ~= n then return false end\n  for i2 = 1, n do\n    if string.sub(s0,\
    \ i0, i0+1) ~= string.sub(s1, i1, i1+1) then return false end\n    i0 = i0 + 1;\n\
    \    i1 = i1 + 1;\n  end\n  return true\nend", "  return string.gsub(s0, unpack('(.)%W*',\
    \ s1), '\\1') ~= string.gsub(s1, unpack('(.)%W*', s0), '\\1')\nend", "    if string.len(s0)\
    \ > string.len(s1) then\n        return s0, false\n    end\n    if string.len(s0)\
    \ < string.len(s1) then\n        return s1, false\n    end\n    for i = 1, string.len(s0)\
    \ do\n        if string.sub(s0, i, i) ~= string.sub(s1, i, i) then return false,\
    \ false end\n    end\n    return true, true\nend", "  if s0 ~= s1 then\n    return\
    \ false\n  end\n  local l0 = #s0\n  local l1 = #s1\n  local s0_char = s0\n  for\
    \ i = 0, l0 - 1 do\n    local c = s0_char:sub(i, i)\n    if not c:match('['..s0..']')\
    \ then\n      return false\n    end\n  end\n  for j = 1, l1 - 1 do\n    if not\
    \ s1:sub(i, i) or s1:sub(i, i):match('['..s1..']') then\n      return false\n\
    \    end\n  end\n  return true\nend", "  return #s0 ~= #s1 and all(s0, s1) or\
    \ s1 == s2\nend", "  local len0 = #s0\n  local len1 = #s1\n  local minlen = len0\n\
    \  if len0 < len1 then\n    minlen = len1\n  end\n  for i = 1, minlen do\n   \
    \ if not p0(s0[i]) or not p1(s1[i - 1])\n    then\n      return false\n    end\n\
    \  end\n  return true\nend", "  local c = {}\n  for i = 0, #s0 do\n    c[i] =\
    \ s0[i]\n  end\n  for i = 0, #s1 do\n    if c[i] ~= s1[i] then\n      return false\n\
    \    end\n  end\n  return true\nend", "  s0, s1 = string.gsub(s0, \"%a\", string.char(0xff)),\
    \ string.gsub(s1, \"%a\", string.char(0xff))\n  local l0 = string.len(s0)\n  local\
    \ l1 = string.len(s1)\n  if l0 ~= l1 then return false end\n  l0 = string.len(s0)\n\
    \  l1 = string.len(s1)\n  local o0 = 1\n  local o1 = 0\n  for i=1, l0 do\n   \
    \ local o2 = string.byte(s0, o0, l0)\n    local o3 = string.byte(s1, o1, l1)\n\
    \    if o2 ~= o3 then return false end\n    o0, o1 = o1 + 1, o1 + 1\n  end\n \
    \ local o2 = string.byte(s0, o0, l0)\n  local o3 = string.byte(s1, o1, l1)\n \
    \ if o2 ~= o3 then return false end\n  return true\nend", "  local s0_len = #s0\n\
    \  local s1_len = #s1\n  local n\n  for n = 1, s0_len do\n    if s0[n] ~= s1[n]\
    \ then return false end\n  end\n  for n = s0_len, 1, -1 do\n    if s0[n] ~= s1[n]\
    \ then return false end\n  end\n  return true\nend", "    local p = {}\n    for\
    \ i, c in ipairs(s0) do\n        p[c] = p[c] or 0\n        p[c] += 1\n    end\n\
    \    for i, c in ipairs(s1) do\n        p[c] = p[c] or 0\n        p[c] -= 1\n\
    \    end\n    return p == {}\nend", "   for i=1, #s0, 1 do\n      for j=1, #s1,\
    \ 1 do\n         if s0[i]~=s1[j] then return false end\n      end\n   end\n  \
    \ return true\nend", "    local chars = s0:gsub(\"(.)\", function(c) return c:lower()\
    \ end)\n    return #chars == #s1 and chars[1] == s1[1]\nend", "   if #s0 ~= #s1\
    \ then return false end\n   local i = 0\n   while i < #s0 and i < #s1 do\n   \
    \   if s0[i] ~= s1[i] then return false end\n      i = i + 1\n   end\n   return\
    \ true\nend", "  for i = 1, #s0 do\n    if string.sub(s0, i, i) ~= string.sub(s1,\
    \ i, i) then return false end\n  end\n  return true\nend", "  return (not s0 or\
    \ s1 ~= nil) and (#s0 < #s1)\nend", "  if #s0 ~= #s1 then return false end\n \
    \ local last_char = {}\n  for i = 0, #s0 do last_char[s0[i]] = 1 end\n  for i\
    \ = 0, #s1 do if not last_char[s1[i]] then return false end end\n  return true\n\
    end", "  if #s0 ~= #s1 then return false end\n  for i = 0, #s0 do\n    if s0[i]\
    \ ~= s1[i] then return false end\n  end\n  return true\nend", "  if s0 ~= nil\
    \ and s1 ~= nil then\n    local len1, len2 = #s0, #s1\n    for i = 1, len1 do\n\
    \      if s0[i] ~= s1[i] then\n        return false\n      end\n    end\n    return\
    \ len1 == len2\n  else\n    return false\n  end\nend", "  return s0 and s1 and\n\
    \    (string.sub(s0, #s0 + 1, #s1) == string.sub(s1, #s0 + 1, #s1)) or\n    (not\
    \ s0 and s1 and not string.sub(s0, #s0 + 1, #s1) and not string.sub(s1, #s1 +\
    \ 1, #s0))\nend", "   local n0, s0 = string.len(s0), string.gsub(string.lower(s0),\
    \ '(%a+)', '%1')\n   local n1, s1 = string.len(s1), string.gsub(string.lower(s1),\
    \ '(%a+)', '%1')\n   return n0 == n1 and s0 == s1\nend", "    local c0 = string.gsub(s0,\
    \ '^.', '')\n    local c1 = string.gsub(s1, '^.', '')\n    return c0 ~= c1 and\
    \ string.sub(s1, 1, #c0) == string.sub(s0, 1, #c1)\nend", "  -- For short strings\
    \ use string comparision\n  if #s0 < #s1 then\n    return #s0 == #s1\n      and\
    \ all(i == j or s1[i] == s2[j] for i, j in ipairs(s0) do\n               if i\
    \ == #s0 then\n                 return true)\n               else\n          \
    \       return s1[i] == s2[j])\n               end\n           end\n  end\n  --\
    \ Otherwise sort strings lexicographically\n  local l0, l1 = #s0, #s1\n  local\
    \ cmp, i", "  assert(type(s0) == 'string')\n  assert(type(s1) == 'string')\n \
    \ assert(len0(s0) == len0(s1))\n  for i = 1,len0(s0) do\n    if s0[i] ~= s1[i]\
    \ then\n      return false\n    end\n  end\n  return true\nend", "  for i, c0\
    \ in ipairs(s0) do\n    local n1 = string.len(s1)\n    for j, c1 in ipairs(s1)\
    \ do\n      if c0 ~= c1 then\n        return false\n      end\n    end\n  end\n\
    \  return true\nend", "    local s01 = \"\"\n    local i0 = 0\n    local i1 =\
    \ 0\n    for i0 = 1,#s0,1 do -- find longest common prefix\n        if s0[i0]\
    \ ~= s1[i1] then break end\n        i1 = i1 + 1\n    end\n    if i0 == #s0 or\
    \ i1 == #s1 then return false end\n    for i0 = 1,#s1,1 do -- check remaining\
    \ characters\n        if s0[i0] ~= s1[i1] then break end\n        i0 = i0 + 1\n\
    \        i1 = i1 + 1\n    end\n    return true\nend", "    local function char(x,\
    \ y) return x:sub(1,y-1) end\n    local i0, i1, i2, i3, i4, i5, i6, i7, i8, i9\
    \ = 1, 1, 2, 4, 8, 12, 16, 19, 22\n    local l0, l1 = 0, 0\n    local m, n = 0,\
    \ 0\n    for i0 = 1, #s0, 1 do\n        i1, l1 = l1, char(s0, i0)\n        if\
    \ l0 ~= i1 then return false end\n        if i1 == 0 then break end\n        m\
    \ = m * 26 + l0 - i0\n    end\n    for i0, i1 = 1, #s1, 1 do\n        i2, l2 =\
    \ l2, char(s1, i0)\n        if l1 ~= i2 then return false end\n        if i2 ==\
    \ 0 then break end\n        n = n * 26 + l1 - i2\n    end\n    return m == n\n\
    end", "  if s0 == nil or s1 == nil then\n    return false\n  end\n  local l0 =\
    \ #s0\n  local l1 = #s1\n  local n = 0\n  for i = 1, l0 do\n    local i0 = string.sub(s0,\
    \ i, i)\n    local i1 = string.sub(s1, i, i)\n    local c = string.char(i0)\n\
    \    if c ~= string.char(i1) then\n      return false\n    end\n    n += 1\n \
    \ end\n  return n == l1\nend", "  return s0 and s1 and\n    s0 ~= nil and s1 ~=\
    \ nil and\n    s0 ~= s1 and #s1 == #s0 and s0 ~= \"\" and s1 ~= \"\"\nend", " \
    \ return s0 and s1 and s0 and s1 and s0 ~= s1 and\n    -- Strip common prefix\
    \ from s0 & s1\n    s0 .. s1\nend", "  local n0 = #s0\n  local n1 = #s1\n  local\
    \ diff = 0\n  for i = 1, n0 do\n    if string.sub(s0, i, i) ~= string.sub(s1,\
    \ i, i) then\n      return false\n    end\n    diff = diff + 1\n  end\n  return\
    \ diff == n0\nend", "  if s1 ~= '' and s1 ~= '' then return (s0:sub(1,#s0)) ==\
    \ (s1:sub(1,#s1)) end\n  return true\nend", "  s0 = s0 -- Copy string\n  s1 =\
    \ s1 -- Copy string\n  for i=1,#s0 do -- Check each character in s0 with all characters\
    \ in s1\n    if not s0[i]:find(s1[i]) then return false end\n  end\n  return true\n\
    end", "  local i = 0\n  local j = 1\n  local k = 0\n  local l = 1\n  local m =\
    \ #s0 + #s1 + 1\n  local n = #s0 + #s1 - 1\n  local chars = {}\n  local i0 = 0\n\
    \  local i1 = 0\n  repeat\n    chars[k] = s0[i0]\n    i0 = i0 + 1\n    chars[k]\
    \ = s1[j1]\n    j1 = j1 + 1\n    k = k + 1\n  until k > 0 and i0 >= m or j1 >=\
    \ n or s0[i0] == s1[j1]\n  -- return i0 > m or j1 >= n and i0 == m or s0[i0] ==\
    \ s1[j1]\n  return #chars == 0\nend", "  -- For now, just check that the strings\
    \ contain the same\n  -- number of characters.\n  return #s0 == #s1\nend", " \
    \ -- TODO: Remove this line once it's been verified.\n  return #s0 and #s1 ==\
    \ #s0\nend", "  assert(s0 and s1)\n  local i = 0\n  for _ in pairs(s0) do\n  \
    \  i = i + 1\n    if i >= #s1 then\n      return false\n    end\n    if s0[_]\
    \ ~= s1[_] then\n      return false\n    end\n  end\n  return true\nend", "  local\
    \ l0 = #s0\n  local l1 = #s1\n  for i = 1, l0 do\n    if not string.sub(s0, i,\
    \ i) then\n      return false\n    end\n  end\n  for i = 1, l1 do\n    if not\
    \ string.sub(s1, i, i) then\n      return false\n    end\n  end\n  return true\n\
    end", "  local i = string.find(s0, s1)\n  if i == nil then return false end\n\
    \  s0 = string.sub(s0, i, #s0)\n  s1 = string.sub(s1, i, #s1)\n  for i = 1, string.len(s1)\
    \ do\n    if string.sub(s1, i, i) == s0 then\n      return true\n    end\n  end\n\
    \  return false\nend", "  return s0 and s1 and #s1 == #s0 and all(#s0 == #s0,\
    \ s1 == s0)\nend", "  -- Find the number of words in each string.\n  local s0w,\
    \ s1w = #s0, #s1\n  -- Check if the length of the strings is equal.\n  if s0w\
    \ ~= s1w then\n    return false\n  else\n    -- Find the number of unique letters\
    \ in each string.\n    local s0c, s1c = {}, {}\n    for i = 1, s0w do\n      local\
    \ c = string.sub(s0, i, i)\n      if c ~= nil then\n        -- Create a unique\
    \ set for the current letter of string.\n        if c0[c] == nil then\n      \
    \    c0[c] = true\n        else\n          -- If the current letter has already\
    \ been added to the\n          -- unique set, then add it to the second string.\n\
    \          -- This avoids the situation of multiple unique letters\n         \
    \ -- sharing the same set in the first string.\n          c0[c] = c0[c] and c1[c]\
    \ == nil or c0[c] or c1[c]\n        end\n      end\n    end\n    local ok, c1c\
    \ = false, {}\n    for i = 1, s1w do\n      local c = string.sub(s1, i, i)\n \
    \     if c ~= nil then\n        -- Get the current unique set for the current\
    \ letter of\n        -- string.\n        local c0 = c0[c]\n        if c0 == nil\
    \ then\n          -- If the current letter of the second string does not have\n\
    \          -- a unique set, then return false.\n          return false\n     \
    \   elseif c0 == false then\n          -- If the current letter of the second\
    \ string has a unique\n          -- set and it is false, then return false.\n\
    \          return false\n        else\n          -- If current letter of the second\
    \ string has a unique\n          -- set, then check if the current unique set\
    \ is a subset of\n          -- the current unique set for the second string.\n\
    \          if c1c ~= nil then\n            ok = ok and c1c\n          else\n \
    \           ok = true\n            c1c = c1c\n          end\n        end\n   \
    \   end\n    end\n    ok = ok and c1c\n    return ok\n  end\nend", "    local\
    \ t0 = s0:lower()\n    local t1 = s1:lower()\n    local l0, l1 = #t0, #t1\n  \
    \  if l0 == l1 then\n        for i = 1, l0 do\n            if t0 ~= t1 then return\
    \ false end\n            t0 = t0:sub(i-1)\n            t1 = t1:sub(i-1)\n    \
    \    end\n        return true\n    end\n    return false\nend", "  if len == 0\
    \ then\n    return len == len0\n  elseif len == len0 then\n    return s0 ~= s1\n\
    \  else\n    local d0 = #s0\n    local d1 = #s1\n    if d0 ~= d1 then\n      return\
    \ false\n    end\n    for i = 1, d0 do\n      if s0 ~= s1[i] then\n        return\
    \ false\n      end\n    end\n    return true\n  end\nend", "  if #s0 ~= #s1 then\
    \ return false end\n  for i, v in ipairs(s0) do\n    if v ~= s1[i] then return\
    \ false end\n  end\n  return true\nend", "  return string.sub(s1, 1, #s1)==string.sub(s0,\
    \ 1, #s0)\nend", "    local n = #s0 and #s1 and 0\n    if n ~= 0 then\n      \
    \  for i = 1, n do\n            if s0[i] ~= s1[i] then return false end\n    \
    \    end\n        return true\n    end\n    return false\nend", "    local count\
    \ = 0\n    local s0_lower = s0:lower()\n    local s1_lower = s1:lower()\n    for\
    \ index, c in ipairs(s0_lower) do\n        if c ~= s1_lower[index] then\n    \
    \        count = count + 1\n        end\n    end\n    return count >= length(s0)\n\
    end", "  local i0, i1 = 0, 0\n  local n0 = #s0\n  local n1 = #s1\n  while i1 <\
    \ n1 and i0 < n0 do\n    if s0[i0] ~= s1[i1] then\n      return false\n    end\n\
    \    i0, i1 = i1 + 1, i1 + 1\n  end\n  return i0 == n0 and i1 == n1\nend", " \
    \  if #s0 ~= #s1 then\n      return false\n   end\n   for i = 1, #s0 do\n    \
    \  if s0.sub(i, i) ~= s1.sub(i, i) then\n         return false\n      end\n  \
    \ end\n   return true\nend", "  -- The common characters between the two strings.\n\
    \  -- e.g. 'ae'\n  local chars0, chars1 = {}, {}\n  for i0, c0 in ipairs(s0) do\n\
    \    chars0[c0] = 1\n  end\n  for i1, c1 in ipairs(s1) do\n    chars1[c1] = 1\n\
    \  end\n  for k in pairs(chars0) do\n    if chars0[k] and chars1[k] then\n   \
    \   -- The characters are the same.\n      -- Leave the other characters untouched.\n\
    \      return false\n    end\n  end\n  return true\nend", "  assert(type(s0) ==\
    \ 'string')\n  assert(type(s1) == 'string')\n  local len = #s0\n  for i = 1, len\
    \ do\n    if s0[i] ~= s1[i] then return false end\n  end\n  return true\nend",
  "  -- Check if two strings has the same number of characters.\n  if #s0 ~= #s1 then\
    \ return false end\n  -- Check if two strings has the same number of characters.\n\
    \  if #s0 ~= #(unpack(s0)) then return false end\n  -- Check whether the strings\
    \ has same number of characters.\n  for _, i in ipairs(unpack(s0)) do\n    --\
    \ Check if each character has the same number in each string.\n    if s0[i] ~=\
    \ s1[i] then return false end\n  end\n  return true\nend", "   if #s0 ~= #s1 then\
    \ return false end\n   for i = 1, #s0 do\n      if string.sub(s0, i, i) ~= string.sub(s1,\
    \ i, i) then return false end\n   end\n   return true\nend", "  if s0 ~= nil and\
    \ s1 ~= nil then\n    local len0 = #s0\n    local len1 = #s1\n    if len0 == len1\
    \ then\n      -- both strings are same length\n      local i0\n      local i1\n\
    \      for i0, i1 in ipairs(string.gmatch(s0, '(.-)([^%s]+)$'))do\n        if\
    \ s0[i0]:byte() == s1[i1]:byte() then\n          -- same chars in both strings\n\
    \        else\n          -- diff chars in both strings\n          return false\n\
    \        end\n      end\n    end\n  end\n  return true\nend", "  -- Compare each\
    \ pair of characters in s0 and s1. If they are the same, \n  -- return true, otherwise\
    \ false.\n  local i0 = 0\n  local i1 = 0\n  local i0len = #s0\n  local i1len =\
    \ #s1\n  while i0 < i0len and i1 < i1len do\n    local c0 = string.sub(s0, i0,\
    \ i0)\n    local c1 = string.sub(s1, i1, i1)\n    if c0 == c1 then return true\
    \ end\n    i0 = i0 + 1\n    i1 = i1 + 1\n  end\n  return false \nend", "  if s0\
    \ ~= nil then\n    if s1 ~= nil then\n      if string.sub(s0, 1) == string.sub(s1,\
    \ 1) then return true end\n    end\n  end\n  return false\nend", "  return s0\
    \ and s1 and #s0 == #s1 and\n  (s0 == '' or s0 == s1) or\n  (s0 == '0' or s1 ==\
    \ '') or\n  ('0' == s0 or s1 == s0) or\n  s0 == s1 or\n  s0 ~= tostring(s1) or\n\
    \  (not s0 and\n   not s1 and\n   not tostring(s0) and\n   not tostring(s1))\n\
    end", "  local i0, j0, o0 = unpack(unpack(s0))\n  local i1, j1, o1 = unpack(unpack(s1))\n\
    \  -- print(\"i0, j0, o0\", i0, j0, o0)\n  -- print(\"i1, j1, o1\", i1, j1, o1)\n\
    \  for i = i0, i1 do\n    for j = j0, j1 do\n      if o0[i] == o1[i] then\n  \
    \      return 0\n      end\n    end\n  end\n  return 1\nend", "  if #s0 ~= #s1\
    \ then return false end\n  for i = 0, #s0 do\n    if s0[i] ~= s1[i] then return\
    \ false end\n  end\n  return true\nend", "    if s0 and s1 then\n        return\
    \ s0 ~= s1 and s0:sub(1, #s0):sub(1, #s1) ~= s1:sub(1, #s1)\n    end\nend", " \
    \ local t0 = { }\n  local t1 = { }\n  for c1, c2 in ipairs(s0) do\n    table.insert(t0,\
    \ c1)\n    table.insert(t1, c2)\n  end\n  for c1, c2 in ipairs(s1) do\n    local\
    \ c3 = table.remove(t0)\n    local c4 = table.remove(t1)\n    if c3 ~= c4 then\n\
    \      return false\n    end\n  end\n  return true\nend", "    local l0 = #s0\n\
    \    local l1 = #s1\n    if l0 ~= l1 then return false end\n    for i = 1, l0\
    \ do\n        if s0[i] ~= s1[i] then return false end\n    end\n    return true\n\
    end", "    return #s0 ~= #s1 and\n        table.iteri(function(i, c)\n       \
    \     return s0:sub(i, i) == s1:sub(i, i) ~= c\n        end, string.new(s0) ..\
    \ string.new(s1))\nend", "   -- Check for same characters.\n   if #s0 ~= #s1 then\n\
    \      -- Different number of characters.\n      return false\n   end\n   -- Check\
    \ for same characters in same order.\n   return #s0 < #s1 and #s0 < #s0 and s0\
    \ ~= s1\nend", "    return s0 and s1 and\n      (type(s0) == 'string' and type(s1)\
    \ == 'string') and\n      string.gsub(string.gsub(s0, '%s', \"\"), '%s', \"\"\
    ) == string.gsub(string.gsub(s1, '%s', \"\"), '%s', \"\")\nend", "  if #s0 ~=\
    \ #s1 then return false end\n  local function _same_chars(i, j)\n    local p0\
    \ = p0[i]\n    local p1 = p1[j]\n    for k, v in ipairs(p0) do\n      if not p1[k]\
    \ then return false end\n      if p0 ~= p1 then return false end\n    end\n  \
    \  for k, v in ipairs(p1) do\n      if not p0[k] then return false end\n     \
    \ if p0 ~= p1 then return false end\n    end\n    return true\n  end\n  local\
    \ p0 = string.gsub(s0, \"(.)(.)\", _same_chars)\n  local p1 = string.gsub(s1,\
    \ \"(.)(.)\", _same_chars)\n  return p0 == p1\nend", "   assert(s0 and s1)\n \
    \  local len = #s0\n   if len == 0 or len == #s1 then\n      return true\n   end\n\
    \   local i0 = 0\n   local i1 = len\n   while i0 < len and i1 < len do\n     \
    \ if string.sub(s0, i0, i1) ~= string.sub(s1, i0, i1) then\n         return false\n\
    \      end\n      i0 = i0 + 1\n      i1 = i1 + 1\n   end\n   return true\nend",
  "  local len = #s0 - 1\n  for i=1, len do\n    if not s0[len + i] == s1[len + i]\
    \ then return false end\n  end\n  return true\nend", "  local n0 = #s0 - 1\n \
    \ local n1 = #s1 - 1\n  for i = 0, n0 do\n    if s0:sub(i, i+1) ~= s1:sub(i, i+1)\
    \ then return false end\n  end\n  return true\nend", "  for i = 1, #s0, 1 do\n\
    \    if s0[i] ~= s1[i] then return false end\n  end\n  return true\nend", "  if\
    \ s0 ~= nil and s1 ~= nil and #s0 ~= #s1 then return false end\n  local sz0 =\
    \ #s0\n  local sz1 = #s1\n  for i = 1, sz0 do\n    if string.sub(s0, i, i) ~=\
    \ string.sub(s1, i, i) then return false end\n  end\n  return true\nend", "  local\
    \ n1, n2 = 0, 0\n  for _, c0, c1 in s0, s1 do\n    if c0 ~= c1 then\n      if\
    \ n1 == 0 then\n        n1 = c0 - 'a'\n      else\n        n2 = c0 - 'a'\n   \
    \   end\n    end\n  end\n  if n1 ~= n2 then\n    return false\n  else\n    return\
    \ true\n  end\nend", "  return string.sub(s0, string.len(s0), string.len(s1))\
    \ == string.sub(s1, string.len(s1), string.len(s0)) and s1\nend", "   for i=1,#s0\
    \ do\n      local l0 = string.len(s0[i])\n      local l1 = string.len(s1[i])\n\
    \      if l0 ~= l1 then\n         return false\n      end\n   end\n   return true\n\
    end", "  local n = #s0 - 1\n  local m = #s1 - 1\n  while n >= 0 and m >= 0 and\
    \ s0:sub(n, n) == s1:sub(0, m) do\n    n, m = n, m - 1\n  end\n  return n == 0\
    \ and m == 0\nend", "    -- The code below is a port of C code found on the internet.\n\
    \    -- See http://www.pdos.net/2010/08/18/c-version-c-string-compare-performance/\n\
    \    local c0, c1, i = 0, 0, 0\n    local p0, p1 = {}, {}\n    while c0 < #s0\
    \ or c1 < #s1 do\n        local c_i = (c0 < #s0 and s0 or \"\"):byte(c1)\n   \
    \     if c_i ~= '\\0' then\n            p0[c0] = (p0[c0] or 0) + (p1[c1] or 0)\n\
    \            p1[c_i] = (c_i == '\\0' and 1 or 0) + p1[c_i]\n        end\n    \
    \    c0, c1 = c1 + 1, c0 + 1\n    end\n    -- Special characters in the second\
    \ string are ignored\n    -- because it is already checked in the previous step\n\
    \    if p1 ~= nil then\n        local equal = true\n        for i = 1, #p0 do\n\
    \            equal = equal and (p0[i] ~= p1[i] or p1[c1] == 0)\n        end\n\
    \        return equal\n    else\n        return true\n    end\nend", "    for\
    \ i=1, #s0, 1 do\n        if s0[i] ~= s1[i] then\n            return false\n \
    \       end\n    end\n    return true\nend", "   for i,c1 in ipairs(s0) do\n \
    \     -- Check if one char is the same as the next char.\n      -- If so, continue\
    \ to the next character.\n      -- Otherwise, return false if we have a mismatch.\n\
    \      if s1:sub(i,i) ~= c1 then return false end\n   end\n   -- If we made it\
    \ here, they match.\n   return true\nend", "  local i0 = 0\n  local i1 = 0\n \
    \ local i2 = 0\n  while i0 < #s0 and i1 < #s1 do\n    local c0 = string.sub(s0,\
    \ i0, i0 + 1)\n    local c1 = string.sub(s1, i1, i1 + 1)\n    if c0 ~= c1 then\n\
    \      return false\n    end\n    i0 = i0 + 1\n    i1 = i1 + 1\n    i2 = i2 +\
    \ 1\n  end\n  return i0 == #s0 and i1 == #s1\nend", "\ts0 = s0 or ''\n\ts1 = s1\
    \ or ''\n\tfor i, v1 in ipairs(s0) do\n\t\tlocal v2 = s1\n\t\tif v1 and v2 then\n\
    \t\t\tlocal size = #v1 -- v1 may be a string\n\t\t\tif size ~= #v2 then\n\t\t\t\
    \treturn false\n\t\t\tend\n\t\t\tfor i, v2 in ipairs(v2) do\n\t\t\t\tif v1[i]\
    \ ~= v2 then\n\t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\
    \treturn true\nend", "  return #s0 and #s1 == #s0 and s0 ~= s1\nend", "    local\
    \ m0 = {}\n    local m1 = {}\n    for i = 0, #s0 do m0[#m0 + 1] = '' end\n   \
    \ for i = 0, #s1 do m1[#m1 + 1] = '' end\n    local l0 = #m0\n    local l1 = #m1\n\
    \    while l0 < l1 do\n        local i = l0\n        while i < l0 do\n       \
    \     m0[i] = m1[i]\n            i = i + 1\n        end\n        l0 = l0 + 1\n\
    \    end\n    for i = l0, 0 do\n        if m0[i] ~= '' then\n            return\
    \ false\n        end\n    end\n    return true\nend", "  assert(type(s0) == 'string'\
    \ and type(s1) == 'string')\n  local l0, l1 = #s0, #s1\n  if l0 ~= l1 then\n \
    \   return false\n  end\n  for i = 0, l0 do\n    if string.sub(s0, i, i) ~= string.sub(s1,\
    \ i, i) then\n      return false\n    end\n  end\n  return true\nend", "  -- Make\
    \ sure that the same number of characters appear in both strings.\n  assert(#s1\
    \ == #s0)\n  for i = 1, #s0 do\n    local c = s0[i]\n    local j = #s1 - 1\n \
    \   while j ~= i and s1[j] == c do\n      j = j - 1\n    end\n    if j ~= i then\n\
    \      return false\n    end\n  end\n  return true\nend", "    local s0_len =\
    \ #s0\n    local s1_len = #s1\n    if s0_len > s1_len then\n        return false\n\
    \    end\n    for i = 1, s0_len do\n        if s0_len == 0 and s1 then\n     \
    \       return true\n        end\n        if s0[i] ~= s1[i] then\n           \
    \ return false\n        end\n    end\n    return true\nend", "    local len0 =\
    \ string.len(s0)\n    local len1 = string.len(s1)\n    if len0 ~= len1 then return\
    \ false end\n    for i = 1, len0 do\n        local v0 = string.sub(s0, i, i)\n\
    \        local v1 = string.sub(s1, i, i)\n        if not v0 then break end\n \
    \       if not v1 then break end\n        if not v0 ~= v1 then return false end\n\
    \    end\n    return true\nend", "  -- The algorithm is based on the algorithm\
    \ described by William Rushing:\n  -- http://dev.lagunitz.de/publications/thesis.html#TheThesis\n\
    \  local s0len = string.len(s0)\n  local s1len = string.len(s1)\n  if s0len ==\
    \ 0 or s1len == 0 then return false end\n  -- Test whether we can find a substring\
    \ which matches s0 from start to end\n  -- without actually doing any searching.\n\
    \  local start\n  local end\n  for start = 1, s0len + 1 do\n    for end = (start\
    \ < s1len) and s1len do\n      if string.sub(s1, start, end) == s0 then break\
    \ end\n    end\n    if end == s1len then return true end\n  end\n  return false\n\
    end", "    if s0 and s1 then\n        for i=1, #s0 do\n            if string.sub(s0,\
    \ i, #s1) == string.sub(s1, i, #s0) then\n                return true\n      \
    \      end\n        end\n    end\n    return false\nend", "  if type(s0) == 'table'\
    \ and type(s1) == 'table' then\n    for _ = 1, #s0 do\n      if s1[_] ~= s0[_]\
    \ then\n        return false\n      end\n    end\n    return true\n  else\n  \
    \  return s0 ~= s1\n  end\nend", "  -- If the characters are the same, return\
    \ true.\n  if 0 == #s0 then return s1 == s0 end\n  if 0 == #s1 then return false\
    \ end\n  -- Make sure both characters are strings.\n  s0 = tostring(s0)\n  s1\
    \ = tostring(s1)\n  -- If both characters are the same length and the first characters\
    \ are the same, return true.\n  if #s0 == #s1 then return s0 == s1 end\n  -- Make\
    \ sure both characters are strings.\n  s0 = tostring(s0)\n  s1 = tostring(s1)\n\
    \  -- If the first characters are the same, compare the other characters.\n  return\
    \ s0 == s1 and #s1 == #s0\nend", "  for i, c in ipairs(s0) do\n    if c ~= s1[i]\
    \ then return false end\n  end\n  return true\nend", "   assert(type(s0) ~= 'table'\
    \ and type(s1) ~= 'table')\n   for _, c in ipairs(s0) do\n      assert(type(s1)\
    \ ~= 'table' or type(s1[c]) ~= 'table')\n      if not (s1[c] == s0[c]) then return\
    \ false end\n   end\n   return true\nend", "    local s0_len = #s0\n    local\
    \ s1_len = #s1\n    if s0_len == 0 or s1_len == 0 then\n        return true\n\
    \    end\n    return not not s0_len ~= s1_len or string.gsub(s0, \"[^\" ..\n \
    \           string.char(#s0 - 1) .. \"]\", \"\") ~= string.gsub(s1, \"[^\" ..\n\
    \            string.char(#s1 - 1) .. \"]\", \"\")\nend", "  if type(s0) ~= 'string'\
    \ or type(s1) ~= 'string' then return false end\n  s0 = string.lower(s0)\n  s1\
    \ = string.lower(s1)\n  return string.find(s0, s1) == nil\nend", "  if #s0 ~=\
    \ #s1 then\n    return false\n  end\n  for i=1, #s0, 1 do\n    if s0[i] ~= s1[i]\
    \ then\n      return false\n    end\n  end\n  return true\nend", "  if #s0 ~=\
    \ #s1 then\n    return false\n  end\n  local i = 0\n  while i < #s0 do\n    if\
    \ s0[i] ~= s1[i] then\n      return false\n    end\n    i = i + 1\n  end\n  return\
    \ true\nend", "  local len = #s0 and #s1 or 0\n  -- We compare two strings as\
    \ if they were one string with two characters.\n  -- If len is 0 or 1, strings\
    \ are equal, so return true.\n  return len > 0 and len == 1 or len == 0\nend",
  "    local l1 = #s0\n    local l2 = #s1\n    if l1 ~= l2 then return false end\n\
    \    for i=1, l1 do\n        if s0[i] ~= s1[i] then return false end\n    end\n\
    \    return true\nend", "   if s1 == nil then return false end\n   if s0 == nil\
    \ then return false end\n   if #s0 ~= #s1 then return false end\n   for i=1, #s0,\
    \ 1 do\n      if s0[i] ~= s1[i] then return false end\n   end\n   return true\n\
    end", "   return string.sub(s0, string.len(s0)-1, string.len(s1))==string.sub(s1,\
    \ string.len(s1)-1, string.len(s0))\nend", "  if #s0 ~= #s1 then return false\
    \ end\n  local last_char = s1[1]\n  for _, c in ipairs(s0) do\n    if c ~= last_char\
    \ then return false end\n    last_char = c\n  end\n  return true\nend", "  local\
    \ len0 = #s0\n  local len1 = #s1\n  if len0 ~= len1 then\n    return false\n \
    \ elseif len0 == 0 then\n    return true\n  else\n    local i = 1\n    while i\
    \ <= len0 and i <= len1 do\n      if s0 ~= s1\n      and s0 ~= '\\x00'\n     \
    \ and s0 ~= '\\x20'\n      and s0 ~= '\\uD800'\n      and s0 ~= '\\uDBFF'\n  \
    \    and s0 ~= '\\uDFFF'\n      and s0 ~= s1 then\n        return false\n    \
    \  else\n        i = i + 1\n      end\n    end\n  end\nend", "    local i0\n \
    \   local i1\n    for i0, s0 in ipairs(s0) do\n        local l0\n        for i1,\
    \ s1 in ipairs(s1) do\n            if s0 ~= s1 then return false end\n       \
    \ end\n    end\n    return true\nend", "  assert(#s0 and #s1)\n  for i = 1, #s0,\
    \ 1 do\n    if s0[i] ~= s1[i] then\n      return false\n    end\n  end\n  return\
    \ true\nend", "  -- Check each character of s0 and s1.\n  for i=1, #s0 do\n  \
    \  -- If s1 contains character s0[i], they cannot be same.\n    if find(s1, string.sub(s0,\
    \ i, i)) == nil then\n      return false\n    end\n  end", "    local n = #s0\
    \ - 1\n    local m = #s1 - 1\n    local j = 1\n    while j <= n or j <= m do\n\
    \        if j == 1 then\n            if s0[j] == s1[n - j] then\n            \
    \    j = j + 1\n            else\n                return false\n            end\n\
    \        elseif s0[j] == s1[n - j] or s0[j] == s1[m - j] then\n            j =\
    \ j + 1\n        else\n            return false\n        end\n    end\n    return\
    \ true\nend", "  local len0 = #s0\n  local len1 = #s1\n  for i = 1, len0, 1 do\n\
    \    if not string.sub(s0, i, len1) == string.sub(s1, i, len1) then return false\
    \ end\n  end\n  return len0 == len1\nend", "  local len = #s0 and #s1 or 0\n \
    \ if len == 0 then return false end\n  if len == 1 then return #s0 == #s1 end\n\
    \  for i=1,len do\n    if s0[i] ~= s1[i] then return false end\n  end\n  return\
    \ true\nend", "  local len = length(s0) and length(s1)\n  return len and s0 %\
    \ len == s1 % len\nend", "    if s0 == nil or s1 == nil then\n        return false\n\
    \    end\n    return tonumber(s0) ~= tonumber(s1) or #s0 ~= #s1\nend", "  s0 =\
    \ s0 or ''\n  s1 = s1 or ''\n  return (#s1 == #s0 and #s0 == #s1):byte() == 0\n\
    end", "  if #s0 ~= #s1 then\n    return false\n  end\n  for i, c in ipairs(s0)\
    \ do\n    if c ~= s1[i] then\n      return false\n    end\n  end\n  return true\n\
    end", "  if s0 ~= nil and s1 ~= nil and #s0 < #s1 then\n    return #s1 == #s0\n\
    \  else\n    return false\n  end\nend", "\t-- Make sure we never deal with an\
    \ empty string.\n\tif s0 ~= '' then s0 = s0:gsub('%s+$', '') end\n\tif s1 ~= ''\
    \ then s1 = s1:gsub('%s+$', '') end\n\t-- Check for equality of strings.\n\tif\
    \ s0 ~= s1 then\n\t\t-- Check individual characters.\n\t\tfor i, s1 in pairs(s1)\
    \ do\n\t\t\tif s0 ~= s1 then\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\t\treturn\
    \ true\n\telse\n\t\treturn false\n\tend\nend", "  s0, s1 = tostring(s0), tostring(s1)\n\
    \  local num_matches = count_chars(s0, s1)\n  return num_matches == count_chars(s0,\
    \ s0, true) and\n         num_matches == count_chars(s1, s1, true)\nend", "  \
    \  local c = 1\n    local i = 0\n    while i < #s0 and i < #s1 and s0:sub(i, i)\
    \ == s1:sub(i, i) do\n        c = c * 26\n        i=i+1\n    end\n    return c\
    \ == 1\nend", "  return tonumber(tostring(s0)) ~= tonumber(tostring(s1))\nend\n\
    return {\n  is_same_chars = same_chars\n}\nend", "    local s0_len = #s0\n   \
    \ if s0_len == 0 then\n        return s1 == nil\n    end\n    local s1_len = #s1\n\
    \    if s1_len == 0 then\n        return s1 == nil\n    end\n    if s0_len < s1_len\
    \ then\n        return s1 == nil\n    end\n    local char_map = {}\n    for i\
    \ = 1, s0_len do\n        local j = s0_len - i - 1\n        local char = s0[j]\n\
    \        if char_map[char] == nil then\n            char_map[char] = 1\n     \
    \   else\n            char_map[char] = char_map[char] + 1\n        end\n    end\n\
    \    for i = 1, s1_len do\n        local char = s1[i]\n        if char_map[char]\
    \ == nil then\n            return false\n        end\n    end\n    return true\n\
    end", "  -- Check each character in s0, and see if it is in s1.\n  -- Return true\
    \ if the set of characters in s0 and s1 are identical.\n  for i, c in ipairs(s0)\
    \ do\n    -- If the character is not in s1, return false\n    if not (c in s1)\
    \ then return false end\n    -- If the character is found in s1, increment the\
    \ count\n    local n1 = #s1[c]\n    local n2 = #s0[c]\n    local n = n1 + n2\n\
    \    if not n1 then n1 = 1 end\n    if not n2 then n2 = 1 end\n    -- Check if\
    \ they are the same character\n    if not (n1 == n2) then\n      return false\n\
    \    end\n  end\n  return true\nend", "  local len0 = #s0 and #s0 and #s0 or 0\n\
    \  local len1 = #s1 and #s1 and #s1 or 0\n  return len0 == len1 and (len0 ~= 0\
    \ and #s0 == #s1 and (s0 == s1 or string.find(s0, s1) == nil))\nend", "    if\
    \ s0 == nil or s1 == nil then\n        return false\n    end\n    local s0_c =\
    \ s0:bytes()\n    local s1_c = s1:bytes()\n    if #s0_c == 0 and #s1_c == 0 then\n\
    \        return true\n    end\n    if #s0_c == 0 and #s1_c > 0 then\n        return\
    \ false\n    end\n    if #s0_c == 0 and #s1_c < 0 then\n        return true\n\
    \    end\n    if #s0_c == 0 and #s1_c ~= 0 then\n        return false\n    end\n\
    \    if #s0_c == 0 and #s1_c < 0 or #s1_c == 0 then\n        return false\n  \
    \  end\n    if #s1_c == 0 and #s0_c == 0 then\n        return true\n    end\n\
    \    if #s1_c == 0 and #s0_c == 0 then\n        return true\n    end\n    if #s1_c\
    \ ~= 0 and #s0_c == 0 then\n        return false\n    end\n    if #s1_c ~= 0 and\
    \ #s0_c == 0 then\n        return false\n    end\n    if #s1_c ~= 0 and #s0_c\
    \ == 0 then\n        return false\n    end\n    local equal = true\n    for i\
    \ = 0, #s0_c-1 do\n        if s0_c[i] ~= s1_c[i] then\n            equal = false\n\
    \            break\n        end\n    end\n    return equal\nend", "  local len0\
    \ = #s0 and #s0 or 1\n  local len1 = #s1 and #s1 or 1\n  local diff = 0\n  local\
    \ i = 0\n  local i1 = 0\n  while i < len0 and i1 < len1 do\n    diff = diff..(string.sub(s0,\
    \ i, i)..string.sub(s1, i1, i1))\n    i = i + 1\n    i1 = i1 + 1\n  end\n  return\
    \ len0 == len1 and diff ~= ''\nend", "  -- Special case: empty string.\n  if s0\
    \ == nil or s1 == nil then\n    return true\n  end\n  -- Special case: two empty\
    \ strings.\n  if s0 == \"\" and s1 == \"\" then\n    return true\n  end\n  --\
    \ Special case: only one empty string.\n  if s0 == \"\" and s1 == \"\" then\n\
    \    return true\n  end\n  -- Special case: two non-empty strings.\n  if s0 ~=\
    \ nil and s1 ~= nil and #s0 ~= 0 and #s1 ~= 0 then\n    -- Special case: both\
    \ strings empty.\n    if #s0 == 0 and #s1 == 0 then\n      return true\n    end\n\
    \    -- Special case: same number of characters.\n    if #s0 ~= #s1 then\n   \
    \   return false\n    end\n    -- Special case: same characters.\n    return s0:sub(1,\
    \ #s0) == s1:sub(1, #s1)\n  end\n  return false\nend", "  local len0 = #s0\n \
    \ if len0 == 0 then return false end\n  local len1 = #s1\n  if len1 == 0 then\
    \ return false end\n  local n = 0\n  while len0 > 1 or len1 > 1 or n >= len0 or\
    \ n >= len1 do\n    if n >= len0 and s0:sub(1,1) == s1:sub(1,1) then\n      n\
    \ = n + 1 -- Skip the repetitions\n      s0 = s0:sub(2)\n      s1 = s1:sub(2)\n\
    \    else\n      n = n + 1 -- Skip the rest\n      s0 = s0:sub(1)\n      s1 =\
    \ s1:sub(1)\n    end\n  end\n  return n == len0 and s0 == s1\nend", "    if #s0\
    \ ~= #s1 then\n        return false\n    end\n    if #s0 < #s1 then\n        for\
    \ i = 1, #s0 do\n            if s0[i] ~= s1[i] then\n                return false\n\
    \            end\n        end\n        return true\n    end\n    if #s0 > #s1\
    \ then\n        for i = 1, #s1 do\n            if s0[i] ~= s1[i] then\n      \
    \          return false\n            end\n        end\n        return true\n \
    \   end\n    return true\nend", "  -- This can be done faster by sorting both\
    \ strings and comparing the character\n  -- by character but this is simpler\n\
    \  for i = 0, #s0 do\n    if s0[i] ~= s1[i] then return false end\n  end\n  return\
    \ true\nend", "  if #s0 ~= #s1 then\n    return false\n  end\n  local i = 0\n\
    \  local j = 0\n  while i < #s0 and j < #s1 do\n    if string.sub(s0, i, i+1)\
    \ ~= string.sub(s1, j, j+1) then\n      return false\n    end\n    i = i + 1\n\
    \    j = j + 1\n  end\n  if i == #s0 then\n    return true\n  end\n  if j == #s1\
    \ then\n    return true\n  end\n  return false\nend", "  assert(type(s0) == 'string'\
    \ and type(s1) == 'string')\n  return #s0 ~= #s1 and #s0 ~= 0 and\n    string.gsub(string.gsub(s0,\
    \ '(.)', function(x)\n      return string.sub(s1, 0, #x - 1)\n    end), '(.)',\
    \ function(x)\n      return string.sub(s1, #s0 + 1, #x - 1)\n    end) == string.gsub(string.gsub(s1,\
    \ '(.)', function(x)\n      return string.sub(s1, #s1 + 1, #x - 1)\n    end),\
    \ '(.)', function(x)\n      return string.sub(s0, #s0 + 1, #x - 1)\n    end)\n\
    end", "  if s0 ~= nil and s1 ~= nil then\n    local len = #s0 - 1\n    if len\
    \ == 0 then\n      return true\n    end\n    local i\n    if len % 2 ~= 0 then\n\
    \      for i = 1, (len / 2), 2 do\n        if s0[i] ~= s1[i] then\n          return\
    \ false\n        end\n      end\n      return true\n    end\n    local len = len\
    \ / 2\n    if len == 0 then\n      return true\n    end\n    for i = 1, len do\n\
    \      if s0[i] ~= s1[i] then\n        return false\n      end\n    end\n    return\
    \ true\n  end\n  return false\nend", "  if s0 ~= nil and s1 ~= nil then\n    if\
    \ s0 ~= nil then\n      local len0 = #s0\n      if len0 > 0 and len0 < 256 then\n\
    \        return s0 == s1\n      end\n    end\n    if s1 ~= nil then\n      local\
    \ len1 = #s1\n      if len1 > 0 and len1 < 256 then\n        return s0 == s1\n\
    \      end\n    end\n  end\n  return false\nend", "    local len0 = #s0\n    local\
    \ len1 = #s1\n    if len0 ~= len1 then return false end\n    if len0 == 0 then\
    \ return true end\n    for i = 1, len0 do\n        if string.sub(s0, i, i) ~=\
    \ string.sub(s1, i, i) then return false end\n    end\n    return true\nend",
  "  local l0, l1 = #s0, #s1\n  for i = 1, l0, 1 do\n    if s0[i] ~= s1[i] then return\
    \ false end\n  end\n  return true\nend", "    if type(s0) ~= 'string' or type(s1)\
    \ ~= 'string' then\n        error('string expected')\n    end\n    local num_chars\
    \ = #s0 - 1\n    if num_chars == 0 then\n        return true\n    end\n    if\
    \ num_chars < 0 then\n        return false\n    end\n    local max_chars = #s1\
    \ + 1\n    if max_chars == 0 then\n        return true\n    end\n    if max_chars\
    \ < 0 then\n        return false\n    end\n    for i = 1, num_chars do\n     \
    \   local char = s0[i]\n        if s1[i] ~= char then\n            return false\n\
    \        end\n    end\n    return true\nend", "    assert(s0 ~= nil, 's0 ~= nil')\n\
    \    assert(s1 ~= nil, 's1 ~= nil')\n    if s0 == nil then\n        return true\n\
    \    elseif s1 == nil then\n        return false\n    end\n    local len0, len1\
    \ = #s0, #s1\n    if len0 ~= len1 then\n        return false\n    end\n    for\
    \ i = 1, len0 do\n        if string.sub(s0, i, i) ~= string.sub(s1, i, i) then\n\
    \            return false\n        end\n    end\n    return true\nend", "  local\
    \ i = string.find(s0, s1, '', true)\n  if i == nil then\n    return false\n  end\n\
    \  -- If the two strings are different lengths, they're not the same chars.\n\
    \  if string.len(s0) ~= string.len(s1) then\n    return false\n  end\n  -- Iterate\
    \ over the first string and check each character.\n  -- If the character doesn't\
    \ exist, they're not the same chars.\n  for i=1, #s1 do\n    if s0[i] ~= s1[i]\
    \ then\n      return false\n    end\n  end\n  return true\nend", "    local i0=0,\
    \ i1=0, c1=0, c2=0\n    local l0, l1 = #s0, #s1\n    if l0 ~= l1 then\n      \
    \  while i0 < l0 and i1 < l1 do\n            if s0[i0] == s1[i1] then\n      \
    \          i0, i1, c1, c2 = i0 + 1, i1 + 1, c1 + 1, c2 + 1\n            else\n\
    \                local j = i0\n                local k = i1\n                --\
    \ Exit if the character is the same.\n                if c1 == c2 and s0:sub(i,i)\
    \ == s1:sub(j,j) then\n                    return true\n                end\n\
    \                -- Exit if the character is the same.\n                if c1\
    \ > c2 then\n                    i0, i1, c1, c2 = i0, i1, c1, c2 + 1\n       \
    \             -- If the characters are the same or one is the end of the string.\n\
    \                    if i1 == l1 or s0:sub(i0,i) == s1:sub(j,j) then\n       \
    \                 return true\n                    end\n                -- If\
    \ the characters are the same or one is the end of the string.\n             \
    \   else\n                    i0, i1, c1, c2 = i1, i1 + 1, c1 + 1, c2 + 1\n  \
    \                  -- If the characters are the same or one is the end of the\
    \ string.\n                    if i0 == l0 or s0:sub(i,i) == s1:sub(k,k) then\n\
    \                        return true\n                    end\n              \
    \  end\n            end\n        end\n    end\n    -- If characters are the same\
    \ up to the end of the string.\n    return i0 == l0 or s1 == s0 or s0:sub(i,i)\
    \ == s1\nend", "  local m0 = {}\n  local m1 = {}\n  for i0, c0 in ipairs(s0) do\n\
    \    m0[c0] = 1\n  end\n  for i1, c1 in ipairs(s1) do\n    m1[c1] = 1\n  end\n\
    \  for c0, _ in pairs(m0) do\n    for c1, _ in pairs(m1) do\n      if c0 == c1\
    \ then\n        return true\n      end\n    end\n  end\n  return false\nend",
  "  for _, c in ipairs(s0) do\n    local _, _, _, s0_i = string.find(s0, c, 1)\n\
    \    if s0_i == nil then return false end\n    local _, s1_i, _, _ = string.find(s1,\
    \ c, 1)\n    if s1_i == nil then return false end\n    if s1_i < s0_i then return\
    \ false end\n  end\n  for _, c in ipairs(s1) do\n    local _, s0_i, _, _ = string.find(s0,\
    \ c, 1)\n    if s0_i == nil then return false end\n    local _, s1_i, _, _ = string.find(s1,\
    \ c, 1)\n    if s1_i == nil then return false end\n    if s1_i < s0_i then return\
    \ false end\n  end\n  return true\nend", "  local i0, i1 = 0, 0\n  for i0 = 1,\
    \ #s0, 1 do if s0:sub(i0, i0+1):lower() ~= s1:sub(i1, i1+1):lower() then return\
    \ false end end\n  for i1 = 1, #s1, 1 do if s1:sub(i1, i1+1):lower() ~= s0:sub(i0,\
    \ i0+1):lower() then return false end end\n  return true\nend", "    if #s0 ~=\
    \ #s1 then return false end\n    local d = {}\n    for i=1,#s0 do\n        d[s0[i]]\
    \ = true\n    end\n    for i=1,#s1 do\n        if d[s1[i]] == nil then return\
    \ false end\n    end\n    return true\nend", "   local t0 = s0 or ''\n   local\
    \ t1 = s1 or ''\n   return t0 and t1 and #s0 == #t1 and all(sub(s0, t1)) end\n\
    end", "  -- First, find the last character of the string that is a letter\n  --\
    \ and not a number or character.\n  local l0 = string.len(s0)\n  while l0 > 0\
    \ and string.sub(s0, l0, 1) ~= '' do\n    l0 = l0 - 1\n  end\n  -- If no letters\
    \ are found, then the two strings are of equal length and can not be equal.\n\
    \  if l0 == 0 then\n    return true\n  end\n  local l1 = string.len(s1)\n  while\
    \ l1 > 0 and string.sub(s1, l1, 1) ~= '' do\n    l1 = l1 - 1\n  end\n  if l1 ==\
    \ 0 then\n    return true\n  end\n  -- Now that we have established that both\
    \ strings are of equal length, compare the characters at each position.\n  for\
    \ i = 1, l0 do\n    local n0 = string.sub(s0, i, i)\n    local n1 = string.sub(s1,\
    \ i, i)\n    if n0 ~= n1 then\n      return false\n    end\n  end\n  return true\n\
    end", "  local len = s0 and #s0 or 0\n  return len == len and string.sub(tostring(s0),\
    \ 1, len) == string.sub(tostring(s1), 1, len)\nend", "    local t0, t1 = {}, {}\n\
    \    for w in s0, s1 do\n        t0[#t0 + 1] = w\n    end\n    for i=1, #t0 do\n\
    \        if t0[i] ~= t1[i] then\n            return false\n        end\n    end\n\
    \    return true\nend", "  if #s0 ~= #s1 then\n    return false\n  else\n    for\
    \ i=1, #s0 do\n      if s0[i] ~= s1[i] then\n        return false\n      end\n\
    \    end\n    return true\n  end\nend", "    if s0 and s1 and #s1 == #s0 then\n\
    \        for i = 1, #s1 do\n            if s0:sub(i, i) ~= s1:sub(i, i) then return\
    \ false end\n        end\n        return true\n    elseif s0 == nil or s1 == nil\
    \ then return false end\n    return false\nend", "   local s0_c = string.gsub(s0,\
    \ '.', '') -- replace all . with empty char\n   local s1_c = string.gsub(s1, '.',\
    \ '')\n   return s0_c ~= s1_c\nend", "  local n = #s0 >= 0 and #s1 >= 0\n  if\
    \ n == 0 then\n    return s1\n  elseif n ~= #s0 then return false end\n  for i,\
    \ s0_char, _ in ipairs(s0) do\n    local s1_char = s1[i]\n    if s0_char ~= s1_char\
    \ then return false end\n  end\n  return true\nend", "  -- This should never be\
    \ called with same strings.\n  assert(#s0 == #s1)\n  for i = 1, #s0 do\n    if\
    \ s0[i] ~= s1[i] then\n      return false\n    end\n  end\n  return true\nend",
  "  return 0 == #s0 and 0 == #s1 and s1 == s0 or s0 == s1 and s0 ~= '' or s1 ~= ''\
    \ and s0 ~= s1\nend", "  local i, i0, i1, s0 = unpack(s0, 1, #s0)\n  local j1,\
    \ j0, j1 = unpack(s1, 1, #s1)\n  local l0 = #s0\n  local l1 = #s1\n  for i = i0,\
    \ i1 do\n    if not (s0[i] == s1[(i + j1 - j0) % l0]) then return false end\n\
    \  end\n  return true\nend", "   if #s0 ~= #s1 then return false end\n   local\
    \ n = #s0\n   for i = 1,n do\n      if s0[i] ~= s1[i] then return false end\n\
    \   end\n   return true\nend", "\t-- Find indices of characters in both strings.\n\
    \tlocal function char_indices(s)\n\t\tlocal i, j = 1, 1\n\t\tlocal c = {}\n\t\t\
    for ch in s:gmatch('(.)') do table.insert(c, ch) end\n\t\treturn setmetatable({},\
    \ {\n\t\t\t__index = function(t, k)\n\t\t\t\treturn c[k]\n\t\t\tend\n\t\t})\n\t\
    end", "    assert(s0 and s1 and s0:len() == s1:len())\n    local same\n    for\
    \ i=1, #s0 do\n        local v0 = s0[i]\n        local v1 = s1[i]\n        local\
    \ l0 = v0 and v0:len()\n        local l1 = v1 and v1:len()\n        if l0 ~= l1\
    \ then\n            return false\n        end\n        if v0 ~= v1 then\n    \
    \        local ok = true\n            for j=1, #v0 do\n                if not\
    \ same[v0][j] then ok = false end\n                same[v0][j] = true\n      \
    \      end\n            for j=1, #v1 do\n                if not same[v1[j]] then\
    \ ok = false end\n                same[v1[j]] = true\n            end\n      \
    \      if ok then\n                local i0\n                for i=1, #same do\n\
    \                    same[i] = true\n                end\n                ok =\
    \ not same[#same]\n            end\n            if not ok then\n             \
    \   return false\n            end\n        end\n    end\n    return true\nend",
  "  local n0 = string.len(s0)\n  local n1 = string.len(s1)\n  if n0 ~= n1 then return\
    \ false end\n  local t = 0\n  while n0 > 0 do\n    local i0\n    if n0 > 1 then\n\
    \      i0 = string.find(s0, s0, t)\n    end\n    if i0 == nil then return false\
    \ end\n    local i1\n    if n1 > 1 then\n      i1 = string.find(s1, s1, t)\n \
    \   end\n    if i1 == nil then return false end\n    if i0 ~= i1 then return false\
    \ end\n    t, t = t + 1, t + 1\n    n0, n1 = n1 - 1, n0 - 1\n  end\n  return true\n\
    end", "    if s1 == nil or s0 == nil then\n        return s1 == s0\n    end\n\
    \    -- Strip trailing whitespace.\n    s0 = string.gsub(s0, rex_ws$, '')\n  \
    \  s1 = string.gsub(s1, rex_ws$, '')\n    -- Strip whitespace at the beginning\
    \ and end.\n    s0 = string.gsub(s0, rex_ws, '')\n    s1 = string.gsub(s1, rex_ws,\
    \ '')\n    -- Check if the characters are different.\n    if string.sub(string.lower(s0),\
    \ 1, 1) ~= string.sub(string.lower(s1), 1, 1) then\n        return false\n   \
    \ end\n    -- If all characters are different, then compare every pair of characters.\n\
    \    if string.find(s0, s1) then\n        return true\n    end\n    return false\n\
    end", "  -- This implementation is based on the \"Algorithms for Unicode Matching\"\
    \ by James Kirchhoff\n  -- http://www.unicode.org/reports/tr29/#Algorithm", " \
    \   return string.sub(string.lower(s0), 1, 1) ~= string.sub(string.lower(s1),\
    \ 1, 1)\nend", "  local w = string.format('%s', '%s')\n  for i, v in ipairs(s0)\
    \ do\n    if not w:sub(1,#w)==v:sub(1,#v) then\n      return false\n    end\n\
    \  end\n  for i, v in ipairs(s1) do\n    if not w:sub(1,#w)==v:sub(1,#v) then\n\
    \      return false\n    end\n  end\n  return true\nend", "  local n0, n1 = #s0,\
    \ #s1\n  if n0 ~= n1 then return false end\n  for i = 1, n0 do\n    if s0:sub(i,\
    \ i) ~= s1:sub(i, i) then return false end\n  end\n  return true\nend", "  if\
    \ s0 and s1 then\n    if type(s0) == 'table' then\n      -- both tables have the\
    \ same length\n      -- return the equality of all the chars\n      -- in the\
    \ string\n      if type(s1) == 'table' then\n        if #s0 ~= #s1 then\n    \
    \      return false\n        end\n        local s0, s1 = s0, s1\n      end\n \
    \     -- return true if all chars match from s0 to s1\n      -- chars match if\
    \ all the chars in the string are in s0\n      return all(map(i8check, s0, s1))\n\
    \    end\n    -- if s1 is a string just return the equality of s0 and s1\n   \
    \ return s0 == s1\n  end\n  -- if s0 is a string and s1 a table or nil\n  -- return\
    \ false if the lengths don't match\n  return #s0 == 0 and #s1 == 0\nend", "  \
    \ if #s0 ~= #s1 then\n      return false\n   end\n   return all(map(function(x,i)\n\
    \      return x == s0:sub(2 * i, 2 * i + 2)\n   end, s1))\nend", "   local i\n\
    \   for i = 1, #s0, 1 do\n      if string.sub(s0, i, i) ~= string.sub(s1, i, i)\
    \ then return false end\n   end\n   return true\nend", "   if #s0 ~= #s1 then\n\
    \      return false\n   end\n   local pos1 = 0\n   local pos2 = 0\n   for pos1\
    \ = 1, #s0 do\n      local char = string.sub({}, pos1, pos1)\n      local char2\
    \ = string.sub({}, pos2, pos2)\n      if char == char2 then\n         pos2 = pos2\
    \ + 1\n      else\n         return false\n      end\n   end\n   return true\n\
    end", "\ts0 = s0 or ''\n\ts1 = s1 or ''\n\tif s0 ~= s1 then\n\t\tlocal n = #s0\
    \ - 1\n\t\tif n == 0 then\n\t\t\tn = #s1 - 1\n\t\tend\n\t\tfor i = 1, n do\n\t\
    \t\tlocal i0 = s0[i]\n\t\t\tlocal i1 = s1[i]\n\t\t\tif i0 ~= i1 then\n\t\t\t\t\
    return false\n\t\t\tend\n\t\tend\n\t\treturn true\n\tend\n\treturn false\nend",
  "    if #s0 ~= #s1 then\n        return false\n    end\n    for i = 0, #s0 do\n\
    \        if s0[i] ~= s1[i] then\n            return false\n        end\n    end\n\
    \    return true\nend", "  local sz0 = string.len(s0)\n  local sz1 = string.len(s1)\n\
    \  local len = min(sz0, sz1)\n  for i = 0, len-1 do\n    if string.sub(s0, i,\
    \ i) ~= string.sub(s1, i, i) then return false end\n  end\n  return sz0 == len\n\
    end", "  for i, c in ipairs(s0) do\n    if c ~= s1[i] then\n      return false\n\
    \    end\n  end\n  return true\nend", "\tlocal i = 1, #s0\n\tlocal j = 1\n\twhile\
    \ i <= #s1 do\n\t\tif s0[i] ~= s1[j] then return false end\n\t\ti = i + 1\n\t\t\
    j = j + 1\n\t\tif j > #s1 then return true end\n\tend\n\treturn true\nend", " \
    \   local i = 0\n    for c1, c2 in pairs(s1) do\n        if s0:sub(i, i) ~= c1\
    \ then\n            return false\n        end\n        i = i + 1\n    end\n  \
    \  return true\nend", "   return s0 and s1 and\n      #s0 == #s1 and\n      s0:sub(1,\
    \ #s1):sub(-1) == s1:sub(1, #s0)\nend", "  if #s0 ~= #s1 then return false end\n\
    \  for i, c in pairs(s0) do\n    if c ~= s1[i] then return false end\n  end\n\
    \  return true\nend", "  if s0 and s1 then\n    s0 = s0:lower()\n    s1 = s1:lower()\n\
    \    for idx, ch0 in ipairs(s0) do\n      for idx, ch1 in ipairs(s1) do\n    \
    \    if ch0 ~= ch1 then\n          return false\n        end\n      end\n    end\n\
    \    return true\n  else\n    return false\n  end\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
