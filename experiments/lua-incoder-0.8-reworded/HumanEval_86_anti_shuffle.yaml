name: HumanEval_86_anti_shuffle
language: lua
prompt: "-- Write a function that takes a string and returns an ordered version of\
  \ it.\n-- Ordered version of string, is a string where all words (separated by space)\n\
  -- are replaced by a new word where all the characters arranged in\n-- ascending\
  \ order based on ascii value.\n-- Note: You should keep the order of words and blank\
  \ spaces in the sentence.\n-- For example:\n-- >>> anti_shuffle('Hi')\n-- 'Hi'\n\
  -- >>> anti_shuffle('hello')\n-- 'ehllo'\n-- >>> anti_shuffle('Hello World!!!')\n\
  -- 'Hello !!!Wdlor'\nlocal function anti_shuffle(s)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = anti_shuffle\n\
  \    lu.assertEquals(candidate('Hi'), 'Hi')\n    lu.assertEquals(candidate('hello'),\
  \ 'ehllo')\n    lu.assertEquals(candidate('number'), 'bemnru')\n    lu.assertEquals(candidate('abcd'),\
  \ 'abcd')\n    lu.assertEquals(candidate('Hello World!!!'), 'Hello !!!Wdlor')\n\
  \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('Hi. My name\
  \ is Mister Robot. How are you?'), '.Hi My aemn is Meirst .Rboot How aer ?ouy')\n\
  end\n\nos.exit(lu.LuaUnit.run())"
completions: ['   -- Write code here', "\t-- Write your code here\n\t\n\tlocal sorted_string\
    \ = #s\n\tlocal result = ''\n\t\n\t-- Start by converting the string to an array\n\
    \t-- A for loop here will loop through each letter in the string\n\t-- If it's\
    \ not a space, add it to the result array\n\t-- Else, add a space before the letter\
    \ and continue\n\tfor i,letter in pairs(s) do\n\t\tif letter ~= ' ' then\n\t\t\
    \tresult = result .. letter\n\t\telse\n\t\t\tresult = result .. ' '\n\t\tend\n\
    \tend\n\t\n\t-- After the for loop has finished, sort the result array\n\t-- This\
    \ should be done in-place, no need to make a copy of it\n\tfor _, letter in pairs(result)\
    \ do\n\t\ttable.insert(sorted_string, letter)\n\tend\n\t\n\treturn string.sub(sorted_string,\
    \ 1, #s)\nend", "  local result = s\n  local pat = ' +'\n  while true do\n   \
    \ local i = #result\n    for j = 1, #s do\n      if string.find(result, pat, nil,\
    \ true) then\n        local _, index = string.find(result, pat, nil, true)\n \
    \       local c = string.sub(result, index, index)\n        local n = string.len(c)\n\
    \        local x = string.byte(c)\n        if x > 127 then\n          local z\
    \ = string.byte(string.sub(c, n - 1, n))\n          local t = string.byte(string.sub(c,\
    \ n - 1, n - 1))\n          local _, _, index = string.find(result, pat, nil,\
    \ true)\n          result = string.sub(result, 1, index) .. string.sub(c, 1, z\
    \ - 1) .. string.sub(result, index + 1, index) .. string.sub(result, index, index\
    \ + 1) .. t\n        else\n          result = string.sub(result, 1, index + 1)\
    \ .. string.sub(c, n, n)\n        end\n        break\n      end\n    end\n  end\n\
    \  return result\nend", "  -- Your code here!\n  local newString = \"\"\n  for\
    \ i = 1, #s do\n    local letter = string.sub(s, i, i)\n    if letter == \" \"\
    \ then\n      newString = newString .. letter\n    else\n      local pos = string.find(letter,\
    \ string.char(32), true)\n      if pos > 0 then\n        local newLetter = string.sub(letter,\
    \ 1, pos - 1)\n        local restLetter = string.sub(letter, pos + 1)\n      \
    \  local newPos = string.find(newLetter, string.char(32), true)\n        if newPos\
    \ == #newLetter then\n          newString = newString .. newLetter\n        else\n\
    \          newString = newString .. string.char(32) + newLetter\n          newString\
    \ = newString .. restLetter\n        end\n      else\n        newString = newString\
    \ .. letter\n      end\n    end\n  end\n  return newString\nend", "  return s:gsub('%(%(%w+)(%w+))',\
    \ function(s)\n    local ws = s:match(/(%w+)(%w+)/)\n    return ws[1] .. ws[2]\n\
    \  end)\nend", "  local t = {}\n  for w in s:gmatch'([^ ]*)' do table.insert(t,#w)\
    \ end\n  table.sort(t)\n  return table.concat(t, ' ', 1)\nend", "    -- Write\
    \ your code here\n  local words = {}\n  local index = 1\n  local length = string.len(s)\n\
    \  local length2 = string.len(s)-1\n  for i = 1,length2 do\n    table.insert(words,string.sub(s,index,i+1))\n\
    \    index = index+1\n  end\n  for i = 1,length do\n    if i ~= length2 then\n\
    \      if string.sub(s,i,i+1)~=string.sub(s,i,i+1) then\n        table.insert(words,string.sub(s,i,i+1))\n\
    \      end\n    end\n  end\n  s=table.concat(words)\n  return s\nend", "    --\
    \ Write your solution here\n    local new_str = ''\n    local num_char = 0\n \
    \   for i = 1, #s do\n        -- Find ascii value of current character\n     \
    \   local char = string.sub(s,i,i)\n        local char_ord = string.byte(char):byte()\n\
    \        -- Append character with ascii value in ascending order\n        new_str\
    \ = new_str .. string.char(char_ord)\n        num_char = num_char + 1\n      \
    \  if num_char == #s then\n            new_str = new_str .. string.char(char_ord\
    \ + 1)\n        end\n    end\n    return new_str\nend", "\t-- Write your code\
    \ here.\n\t-- We have done this before. But here we are breaking the string into\
    \ words.\n\tlocal words = string.gsub(s, '([^ ]+)', function(x)\n\t\treturn x\n\
    \tend)\n\t-- Then we sort the words, then we join them with blank spaces.\n\t\
    -- We are using the sort function which gives us an array of sorted elements of\
    \ a string.\n\t-- We then use the join function to put them back in the string.\n\
    \treturn table.concat(words, ' ')\nend", "  -- Write code here.\nend", "  -- Create\
    \ a copy of s\n  s = s:gsub(' ', ' ')\n  s = s:gsub('.', '')\n  s = s:gsub(',',\
    \ '')\n  s = s:gsub('!', '')\n  s = s:gsub('?', ' ')\n  s = s:gsub(' ?', '')\n\
    \  s = s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n \
    \ s = s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n  s\
    \ = s:gsub('  ', ' ')\n  s = s:gsub(' ', ' ')\n  s = s:gsub('  ', ' ')\n  s =\
    \ s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('\
    \  ', ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub(' ', ' ')\n  s = s:gsub(' ',\
    \ ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('  ', '\
    \ ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n\
    \  s = s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n \
    \ s = s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n  s\
    \ = s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n  s =\
    \ s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('\
    \  ', ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub(' \
    \ ', ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('  ',\
    \ ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('  ', '\
    \ ')\n  s = s:gsub('  ', ' ')\n  s = s:gsub('", "  local words = s:gmatch(\"([%s]+)\"\
    ):gmatch(\"([^%s]+)\"):gmatch(\"(%S+)\")\n  local new_words = {}\n  for _, word\
    \ in pairs(words) do\n    table.insert(new_words, word:gsub(\"%s\",\"%A\")) --\
    \ convert all the characters to ascii\n  end\n  return table.concat(new_words,\"\
    \ \")\nend", "  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ',\
    \ '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n\
    \  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s =\
    \ s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub('\
    \ ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n\
    \  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s =\
    \ s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub('\
    \ ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n\
    \  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s =\
    \ s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub('\
    \ ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n\
    \  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s =\
    \ s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub('\
    \ ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n\
    \  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s =\
    \ s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub('\
    \ ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n  s = s:gsub(' ', '*')\n\
    \  s = s:gsub(' ', '*')", "  -- Write your code here\n  local n = {}\n  for i\
    \ = 1, #s do\n    local c = string.byte(s[i])\n    local n = string.byte(s[i -\
    \ 1])\n    if c > n then\n      table.insert(n, s[i])\n    elseif c == n then\n\
    \      table.remove(s, i - 1)\n    end\n  end\n  return table.concat(s)\nend",
  "  -- TODO: Implement me!\n  return s\nend", "\t-- your code\n\t-- Note: the function\
    \ should return an ordered string.\nend", "  -- Write your function here\n  local\
    \ result = \"\"\n  for i=1,#s do\n    local c = string.char(string.byte(s,i))\n\
    \    if c==' ' or c=='\\t' then\n      result = result .. c\n    else\n      local\
    \ letter = string.byte(s,i)\n      local alpha = string.char(tonumber(letter))\n\
    \      result = result .. alpha\n    end\n  end\n  return result\nend", "  local\
    \ t = {}\n  for w in s:gmatch('([A-Za-z]+) ?') do\n    table.insert(t, w)\n  end\n\
    \  table.sort(t)\n  return table.concat(t, ' ')\nend", "  s = s:gsub(' ', ' '):gsub('%w',\
    \ '%d'):gsub('%d', '%w'):gsub('%d', \" \"):gsub('%d+', '%d'):gsub('%d*', '%d'):gsub('%d?',\
    \ '%d'):gsub('%d+?', '%d'):gsub('%d*?', '%d'):gsub('%d?', '%d'):gsub('%d+?', '%d'):gsub('%d*?',\
    \ '%d'):gsub('%d?', '%d'):gsub('%d+?', '%d'):gsub('%d*?', '%d'):gsub('%d?', '%d'):gsub('%d+?',\
    \ '%d'):gsub('%d*?', '%d'):gsub('%d?', '%d'):gsub('%d+?', '%d'):gsub('%d*?', '%d'):gsub('%d?',\
    \ '%d'):gsub('%d+?', '%d'):gsub('%d*?', '%d'):gsub('%d?', '%d'):gsub('%d+?', '%d'):gsub('%d*?',\
    \ '%d'):gsub('%d?', '%d'):gsub('%d+?', '%d'):gsub('%d*?', '%d'):gsub('%d?', '%d'):gsub('%d+?',\
    \ '%d'):gsub('%d*?', '%d'):gsub('%d?', '%d'):gsub('%d+?', '%d'):gsub('%d*?', '%d'):gsub('%d?',\
    \ '%d'):gsub('%d+?', '%d'):gsub('%d*?', '%d'):gsub('%d?', '%d'):gsub('%d+?', '%d'):gsub('%d*?',\
    \ '%d'):gsub('%d?', '%d'):gsub('%d+?', '%d'):gsub('%d*?', '%d'):gsub('%d?', '%d'):gsub('%d+?',\
    \ '%d'):gsub('%d*?', '%d'):gsub('%d?', '%d'):gsub('%d+?', '%d'):gsub('%d*?', '%d'):gsub('%d?',\
    \ '%d'):gsub('%d+?', '%d'):gsub('%d*?', '%d'):gsub('%d?', '%d'):gsub('%d+?', '%d'):gsub('%d*?',\
    \ '%d'):gsub('%d?', '%d'):gsub('%d+?', '%d'):gsub('%d*?', '%d'):gsub('%d?', '%d'):gsub('%d+?',\
    \ '%d'):gsub('%d*?', '%d'):gsub('%d?', '%d'):gsub('%d+?', '%d'):gsub('%d*?', '%d'):gsub('%d?',\
    \ '", "  return string.gsub(s, \" \", function (w)\n    local s = \"\"\n    for\
    \ i = #w, 1, -1 do\n      s = s .. string.char(string.byte(w, i) - 32)\n    end\n\
    \    return s\n  end)\nend", "    local i, k, result = {}, {}, {}\n    for i,\
    \ k in pairs(s:gmatch('(%S+)%s*([%w$]+)%s*')), 2 do\n        result[#result+1]\
    \ = k\n    end\n    for i = #result, 1, -1 do\n        result[i], result[#result]\
    \ = result[#result], result[i]\n    end\n    return table.concat(result)\nend",
  "  local new_string = \"\"\n  for c in string.gmatch(s, \"([^ ]*)\") do\n    local\
    \ num = tonumber(c)\n    if num then\n      -- We don't need to worry about negative\
    \ ascii characters as we\n      -- know that ascii values for all characters are\
    \ in ascending order\n      local offset = num - 65\n      local alphabet = \"\
    abcdefghijklmnopqrstuvwxyz\"\n      new_string = new_string .. alphabet:sub(offset,\
    \ offset+1)\n    else\n      new_string = new_string .. c\n    end\n  end\n  return\
    \ new_string\nend", "  -- Write code here\n  local words = s:gsub(' ', '').gsub('\
    \ ', ' ')\n  local words = words:gsub('.', function(c) return string.char(tonumber(c)\
    \ - 96) end)\n  return s\nend", '  -- Write code here', "  local i, j, k, p, q,\
    \ r, ss, se\n  -- Write your code here\n  local charTable = {\n    {97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114},\n\
    \    {65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90},\n\
    \    {48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90},\n\
    \    {32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90}\n\
    \  }\n  j = 1\n  ss = ''\n  se = ''\n  for i = 1, #s do\n    ss = ss .. s[i -\
    \ 1]\n  end\n  q = 1\n  r = 1\n  while j < #s do\n    q = q + 1\n    p = j\n \
    \   while p < #s do\n      qq = r\n      while qq < #charTable[1] do\n       \
    \ local cc = charTable[1][qq]\n        if s[p] == cc then\n          r = qq +\
    \ 1\n          break\n        end\n        qq = qq + 1\n      end\n      r = 1\n\
    \      se = se .. s[p]\n      p = p + 1\n    end", "    local words = string.gmatch(s,\
    \ \"[%w]+\")\n    local shuffled_words = {}\n    local blanks_count = count_blanks(s)\n\
    \    table.sort(words)\n    for _, word in ipairs(words) do\n        local words_with_blanks\
    \ = {}\n        for i = 1, blanks_count do\n            words_with_blanks[i] =\
    \ word\n        end\n        table.insert(shuffled_words, words_with_blanks)\n\
    \    end\n    table.sort(shuffled_words)\n    return table.concat(shuffled_words,\
    \ \" \")\nend", "    local out = ''\n    for w in s:gmatch('(%S+)') do\n     \
    \   local t = {}\n        for i = 1, #w do t[#t + 1] = string.char(math.floor((#w\
    \ + i - 1) / 26)) end\n        local n = #t\n        for i = 1, #w do t[#t + 1]\
    \ = string.sub(w,i,i) end\n        out = out .. t[math.random(n)]\n    end\n \
    \   return out\nend", "  local new_s = ''\n  for w in s:gmatch'([^%s]+)'  do\n\
    \    local new_w = w:gsub('%d%d%d%d%d%d%d', '%!d')\n    new_s = new_s .. new_w\n\
    \  end\n  return new_s\nend", "    -- Preprocess\n    local list = s:gsub(' ',\
    \ '').toLowerCase():gsub('[^ ]+', '')\n    local listArr = list:gmatch'([^ ]+)'\n\
    \    local listSorted", "  local out = \"\"\n  -- Replace all spaces with newlines\n\
    \  s = s:gsub('([^ ]+)', '\\n')\n  -- Iterate over string words\n  for w in string.gmatch(s,\
    \ '([^\\n]+)') do\n    -- Convert to ascii value using tonumber()\n    local new_word\
    \ = w:gsub('%d+', function(a) return tonumber(a) end)\n    -- Sort based on ascii\
    \ value\n    table.sort(new_word)\n    -- Append the new word to the output\n\
    \    out = out .. new_word[1] .. w\n  end\n  return out\nend", "  local result\
    \ = ''\n  for w in s:gmatch(\"([^ ]*)\"..rep) do\n    local c = string.char(tonumber(w))\n\
    \    if c ~= ' ' and c ~= '\\t' then\n      result = result .. c\n    end\n  end\n\
    \  return result\nend", "  local words = s:gsub(' ', ' '):gsub(' ', ' '):gsub('\
    \ ', ' ')\n  local new_words = {}\n  for i=1, #words do\n    local index = string.len(words[i])\n\
    \    local letter = string.sub(s, index, index + 1)\n    local new_letter = string.char(\n\
    \      ((string.len(letter) + 2) / string.len(words[i])) * string.byte(letter)\n\
    \    )\n    new_words[i] = new_letter\n  end\n  return table.concat(new_words,\
    \ '')\nend", "  local alphabet = {}\n  for i = 1, #s do\n    table.insert(alphabet,\
    \ string.char(string.byte(s,i)))\n  end\n  table.sort(alphabet, function(a,b)\
    \ return string.byte(a,a) < string.byte(b,b) end)\n  return table.concat(alphabet)\n\
    end", "  -- Your code goes here!\n  -- Input parameter s is string that needs\
    \ to be shuffled\n  -- Return an empty string if s is nil or empty.\n  -- Return\
    \ empty string if string s is nil or empty.\n  if not s then\n    return ''\n\
    \  end", "\t-- Write your solution here\n\tlocal t = {}\n\tfor i = 1, #s do\n\t\
    \tlocal c = string.sub(s,i,i)\n\t\tif t then\n\t\t\tfor j = 1, #t do\n\t\t\t\t\
    if t[j] ~= c then\n\t\t\t\t\ttable.insert(t,c)\n\t\t\t\t\tbreak\n\t\t\t\tend\n\
    \t\t\tend\n\t\telse\n\t\t\ttable.insert(t,c)\n\t\tend\n\tend\n\t\n\tt = table.concat(t,\
    \ \" \")\n\t\n\treturn t\nend", "  local i = 0\n  -- Create a list with ascii\
    \ values of chars\n  local chars = { ' ', '!', '\"', '#', '$', '%', '&', '\\'',\
    \ '(', ')', '*', '+', ',', '-', '.', '/',\n                  '0', '1', '2', '3',\
    \ '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>',\n                  '?',\
    \ '@', '[', '\\\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\n \
    \                 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\
    \ 't', 'u', 'v',\n                  'w', 'x', 'y', 'z', '{', '|', '}', '~'}\n\
    \  -- Create a list with all possible combinations of words and spaces\n  local\
    \ words = { ' ', '!', '\"', '#', '$', '%', '&', '\\'', '(', ')', '*', '+', ',',\
    \ '-',\n                  '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8',\
    \ '9', ':', ';',\n                  '<', '=', '>', '?', '@', '[', '\\\\', ']',\
    \ '^', '_', '`', 'a', 'b', 'c', 'd',\n                  'e', 'f', 'g', 'h', 'i',\
    \ 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\n                  't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~'}\n  -- Create a list with all possible\
    \ combinations without spaces\n  local words_nospace = { ' ', '!', '\"', '#',\
    \ '$', '%', '&', '\\'', '(', ')', '*', '+',\n                         '-', ';',\
    \ '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8',\n                   \
    \      '9', ':', '<', '=', '>', '?', '@', '[', '\\\\', ']', '^', '_', '`', 'a',\n\
    \                         'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n',\n                         'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z', '{', '|',\n                         '}', '~'}\n  -- Loop\
    \ while there are words to shuffle\n  while i < #words do\n    -- Create a table\
    \ for new words and spaces\n    local words_list = { }\n    local spaces_list\
    \ = { }\n    -- Loop through words array to find combination\n    for j = 1, #words\
    \ do\n      if j == 1 then\n        -- If word is blank space then store it in\
    \ spaces list\n        spaces_list[#spaces_list+1] = words[j]\n      elseif j\
    \ > 1 then\n        -- If word is not blank space then store it in words list\n\
    \        words_list[#words_list+1]", "    local new_s = ''\n    local last_word_idx\
    \ = 1\n    local word_idx\n    local cur_char_idx = 0\n    for word_idx, word\
    \ in ipairs(s:gmatch'([^ ]+)')do\n        -- if the character before this word\
    \ is larger than the character after the word\n        -- then we replace the\
    \ word with new_word\n        if cur_char_idx > word_idx-1 then\n            new_s\
    \ = new_s .. new_word .. ' ' .. word\n            last_word_idx = word_idx + 1\n\
    \        else\n            new_s = new_s .. word .. ' ' .. new_word\n        \
    \    last_word_idx = word_idx\n        end\n        cur_char_idx = word_idx\n\
    \        new_word = ' '\n    end\n    new_s = new_s .. new_word\n    return new_s\n\
    end", "    local i, count = 1, 0\n    local output = ''\n    while i < #s do\n\
    \        count = count + 1\n        local letter = string.sub(s,i,i+1)\n     \
    \   local ascii = string.byte(letter)\n        if ascii == 0 then\n          \
    \  i = i + 1\n        else\n            if ascii == 255 then\n               \
    \ i = i + 1\n            else\n                -- find the word that has the highest\
    \ ascii value\n                local i = 1\n                local found = false\n\
    \                while not found and i < #s do\n                    i = i + 1\n\
    \                    letter = string.sub(s,i,i+1)\n                    ascii =\
    \ string.byte(letter)\n                    if ascii == 0 then\n              \
    \          found = true\n                    else\n                        if\
    \ ascii > ascii then\n                            ascii, i = ascii, i\n      \
    \                  else\n                            ascii, i = ascii, i - 1\n\
    \                        end\n                    end\n                end\n \
    \               -- replace the word with the highest ascii value\n           \
    \     local word_start = i - 1\n                local new_word = string.sub(s,word_start\
    \ + 1,word_start + count)\n                -- append the new word and replace\
    \ the old word with the empty string\n                output = output .. new_word\
    \ .. letter\n                s = string.sub(s,word_start + 1,word_start + count)\n\
    \            end\n        end\n    end\n    return output\nend", "    local words\
    \ = {}\n    for w in string.gmatch(s, '%w+') do\n        words[#words + 1] = '#'..w\n\
    \    end\n    table.sort(words)\n    return table.concat(words, ' ')\nend", " \
    \ -- Split the string to an array and sort it.\n  -- We use a list because it\
    \ allows us to use index-based access.\n  local list = {}\n  for w in string.gmatch(s,\
    \ '%w+') do\n    list[#list + 1] = w\n  end\n  table.sort(list)", "  -- Write\
    \ your code in function 'anti_shuffle'\n  -- Function anti_shuffle should return\
    \ a string\n  -- that represents the result of shuffling\n  -- a string of upper\
    \ or lower letters.\n  -- The order of letters in the string is unchanged.\n \
    \ -- The function should accept one parameter, a string s\n  -- containing one\
    \ or more words and return one string\n  -- containing one or more words where\
    \ the order of letters is shuffled.\n  -- Do not print or return the result of\
    \ this function.\n  -- In case of error, print 'Error!' and return nil.\n  --\
    \ Example:\n  -- >>> anti_shuffle('hello world')\n  -- 'ehllo world'\n  -- >>>\
    \ anti_shuffle('ABC')\n  -- 'CBA'\n  -- >>> anti_shuffle('HI')\n  -- 'HI'\n  --\
    \ >>> anti_shuffle('Error!')\n  -- 'Error!'\n  local new_s = \"\"\n  for i = 1,#s\
    \ do\n    local c = string.sub(s,i,i)\n    local new_c = string.char(96+string.byte(c))\n\
    \    local new_i = i\n    for j = i+1,#s do\n      if string.sub(s,j,j) == c then\n\
    \        new_i = j\n      end\n    end\n    new_s = new_s .. new_c .. string.sub(s,new_i,i)\n\
    \  end\n  return new_s\nend", "    -- YOUR CODE HERE\n    return s\nend", "  local\
    \ words = s:gsub('[ ]+', ' ')\n  local sorted_words = words[words:gmatch('([^\
    \ ]+)'):gsort()]\n  -- Reverse the order since sort returns ascending order\n\
    \  return sorted_words:reverse():gsub('([^ ]+)', '\\1 ')\nend", "  s = s:gsub('\
    \ ', function()\n    local n = {}\n    for i = 1, #s do\n      n[string.char(i)]\
    \ = true\n    end\n    table.sort(n)\n    return table.concat(n, '')\n  end)\n\
    \  return s\nend", "  -- Write your code here\n  return s\nend", "  -- your code\
    \ goes here\n  -- return s\n  return s:gsub( function(c)\n    local a\n    if\
    \ #c > 1 then\n      a = string.char(c)\n    else\n      a = ''\n    end\n   \
    \ return a:byte(1, #a) + a:byte(#a + 1, #a) + a:byte(2 * #a, #a) + a:byte(3 *\
    \ #a, #a) + a:byte(4 * #a, #a) + a:byte(5 * #a, #a) + a:byte(6 * #a, #a) + a:byte(7\
    \ * #a, #a)\n  end)\nend\n</cell>\n<text>\nProblem 4\nPlease write a function\
    \ named is_palindrome that takes a string as input. Given a string that only contains\
    \ letters, digits and spaces, write a function which returns True if the string\
    \ is palindrome and False otherwise.\nHint: The function is_palindrome should\
    \ be able to handle both uppercase and lowercase letters.", "  local words = s.Words()\n\
    \  local n = #words\n  local i = 0\n  while i < n do\n    i = i + 1\n    local\
    \ x = words[i]\n    words[i] = words[n-1]\n    words[n-1] = x\n  end\n  return\
    \ table.concat(words)\nend", "  return s:gsub(' ', function(s) return string.char(math.random(65,\
    \ 90)) end)\nend", "  return s:gsub(' ', function()\n    local buffer = {}\n \
    \   for w in string.gmatch(s, '([^ ]+)') do\n      table.insert(buffer, tonumber(string.char(tonumber(w)\
    \ or 65)))\n    end\n    return table.concat(buffer)\n  end)\nend\n</cell>\n<text>\n\
    Problem 3\nWrite a function to check whether a string is a valid phone number\
    \ or not.", "  -- Create an empty list to store words and ascii values.\n  local\
    \ words = {}", "  -- write code here\n  s = s:gsub(' ', function(x)\n    return\
    \ string.char(tonumber(x) + 96) end\n  ) -- convert all space characters to ascii\
    \ value 96\n  -- sort alphabetically\n  s = s:gsub(' ', ' ')\n  s = s.split('\
    \ ')\n  s = table.sort(s)\n  -- join sorted array back into string\n  s = table.concat(s)\n\
    \  return s\nend", "  local t = {}\n  local i = 0\n  for c in s:gmatch '[%a%d]+'\
    \ do\n    table.insert(t,c)\n    i = i+1\n    if i == #s then\n      i = 1\n \
    \   end\n  end\n  s = table.concat(t)\n  for i = #s:gmatch '[%a%d]+' do\n    table.insert(s,'a')\n\
    \  end\n  return s\nend", "   local w\n   for w in string.gmatch(s, '%w+') do\n\
    \      if string.find(s, w) == nil then\n         return s\n      end\n      local\
    \ t = nil\n      for i = 1, #w do\n         local c = w:sub(i, i)\n         t\
    \ = t .. string.char((#c + 1) - #string.find(s, w))\n      end\n      return string.sub(w,\
    \ 1, #w-1) .. t\n   end\n   return s\nend", "  -- Write your solution here.\n\
    \  -- Return the anti_shuffle function result.\n  return s\nend", "  -- Write\
    \ your solution here\n  -- You may copy the code below to solve this problem\n\
    \  -- Do not change the order of the words and blank spaces\n  local t = {\n \
    \   ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n\
    \    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n\
    \    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n\
    \    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n\
    \    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n\
    \    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n\
    \    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n\
    \    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n\
    \    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n\
    \    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n\
    \    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n\
    \    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n\
    \    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n\
    \    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n\
    \    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ' ',\n    ",
  "\t-- Your code here\n\treturn s\nend", "  local words = s:gmatch('([^ ]+)') --\
    \ split the string in words\n  local new_words = {}\n  local i = 1\n  while i\
    \ <= #words do\n    local char = words[i]\n    local j = 1\n    while j <= #words\
    \ do\n      -- if jth character is in i position, swap it with the jth character\
    \ in the jth position\n      if char == words[j] then\n        local tmp = words[j]\n\
    \        words[j] = words[i]\n        words[i] = tmp\n      end\n      j = j +\
    \ 1\n    end\n    i = i + 1\n  end\n  return table.concat(words, ' ')\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThe question is about anti-shuffling, not shuffle.\
    \ Your function does not work for anti-shuffling e.g. `anti_shuffle(\"Hello\"\
    )` should return `\"Heeoll\"`, not `\"olleH\"`\n<|/ c |>\n<| c |>\nOops my bad.\
    \ Corrected my answer. Thanks for pointing it out\n<|/ c |>\n<| c |>\nYour function\
    \ works, but it is very slow (I believe that it can work within 100ms, but it\
    \ is really slow). On my machine it takes ~10sec.\n<|/ c |>\n<| c |>\nYes, I have\
    \ tested it on `Hi world!!!` and it took ~6ms for me. Can you check on `Hi world!!!`,\
    \ it should return `Hi world!!!` on `Hi world!!!` after anti-shuffling\n<|/ c\
    \ |>\n<| c |>\nThanks so much. It works perfectly! I really appreciate your help.\n\
    <|/ c |>\n<| a |>\nThis implementation is about 30% faster, and it also handles\
    \ case where input string contains punctuation characters.\n<code>", "  local\
    \ new_s = ''\n  for i = 1, #s do\n    local n = string.len(string.sub(s,i,i))\n\
    \    if n > 1 then\n      local a = 0\n      for j = 1, n do\n        if string.sub(s,i,i+j)\
    \ ~= ' ' then\n          a = a + 1\n        end\n      end\n      if a == 1 then\n\
    \        local w = string.sub(s,i,i+n)\n        new_s = new_s .. w\n      else\n\
    \        local w = string.sub(s,i,i+n-1)\n        new_s = new_s .. w .. string.sub(s,i+n+1,i)\n\
    \      end\n    else\n      new_s = new_s .. string.sub(s,i,i)\n    end\n  end\n\
    \  return new_s\nend", "  local chars = {}\n  for c in s:gmatch('%c') do table.insert(chars,\
    \ c) end\n  table.sort(chars, function(a,b) return string.byte(a) <  string.byte(b)\
    \ end)\n  return table.concat(chars, ' ')\nend", "\tlocal t = {}\n\tlocal l =\
    \ {}\n\tlocal i = 0\n\tlocal lj = 1\n\tfor c in string.gmatch(s, '%S+') do\n\t\
    \tif i == 0 then\n\t\t\tt[lj] = c\n\t\t\tl[lj] = 0\n\t\telse\n\t\t\tif l[lj] <\
    \ #c + 1 then\n\t\t\t\tt[lj] = c\n\t\t\t\tl[lj] = #c + 1 -- keep track of word's\
    \ length\n\t\t\telse\n\t\t\t\tl[lj] = l[lj] -- move on to next word\n\t\t\tend\n\
    \t\tend\n\t\ti = i + 1\n\tend\n\tfor i = 1, #t do\n\t\ts = string.gsub(s, t[i],\
    \ t[#t])\n\tend\n\treturn s\nend", "  local new_words = {}\n  -- Split sentence\
    \ into words.\n  for i = 1, #s do\n    table.insert(new_words, string.sub(s, i,\
    \ i+1):lower())\n  end\n  -- Make new_words to an array.\n  new_words = new_words[1]",
  "    local new_string=''\n    local i=0\n    local word_cnt=0\n    local prev=0\n\
    \    for i=1,#s,1 do\n        word_cnt=#(s:sub(i,i))\n        if word_cnt > 1\
    \ then\n            local word=s:sub(i,i+1)\n            new_string=new_string..word\n\
    \            word_cnt=word_cnt-1\n        end\n        if word_cnt>1 then\n  \
    \          local word=s:sub(i,i+1)\n            local new_char=string.char(#new_string+#word-1,#word+#new_string)\n\
    \            new_string=new_string..new_char\n            i=i+1\n        end\n\
    \    end\n    return new_string\nend", "   local words = s:gsub(' ', ' '):gsub('\
    \ ', ' ')\n   local result = {}\n   for _, word in ipairs(words) do\n      table.insert(result,\
    \ word)\n   end\n   return table.concat(result, ' ')\nend", "  local words = s:gmatch(\"\
    %w+%s*\") -- Get all the words in the string\n  if #words ~= 0 then\n    local\
    \ word_count = #words -- Get the number of words\n    local word_count2 = #s --\
    \ Get the length of the string\n    local output = '' -- Set the output to empty\
    \ string\n    for i=1,word_count do\n      local j = math.random(word_count2)\
    \ -- Get the random index\n      output = output .. words[i] .. words[j] -- Swap\
    \ the two words in the sentence\n      words[i] = words[j] -- Replace the word\
    \ at random index with blank space\n      words[j] = ' '\n    end\n    return\
    \ output -- Return the modified string\n  end\n  return s\nend", "   local pattern\
    \ = \"[%a]+\" -- Matches one or more letters (case insensitive).\n   local substitute\
    \ = \"$1\" -- Replace each letter with the first letter, ie 'H' -> 'H'\n   return\
    \ s:gsub(pattern, substitute)\nend", "    -- Your code here\n    local ans=\"\"\
    \n    for i=1,#s do\n        local w=s[i]\n        for j=1,#w do\n           \
    \ local v=w:byte(j)\n            if v ~= 32 then\n                v=v-32\n   \
    \         end\n            ans=ans..string.char(v)\n        end\n        ans=ans~\"\
    \ \"\n    end\n    return ans\nend", "    local new_s = ''\n    local words =\
    \ string.gmatch(s, '.+?') -- split words by space\n    local length = #s\n   \
    \ for i = 1,#words do\n        local c = string.sub(words, i, i)\n        local\
    \ pos = 1\n        while pos < length do\n            local next_c = string.sub(words,\
    \ i, pos+1)\n            pos = pos + 1\n            if next_c > c then\n     \
    \           new_s = new_s..c -- replace char in the original string\n        \
    \        c = next_c\n            else\n                new_s = new_s..next_c --\
    \ append the char in the original string\n                break\n            end\n\
    \        end\n    end\n    return new_s\nend", "    return table.sort(s, function(a,\
    \ b)\n        local ai, bi = tonumber(a), tonumber(b)\n        if ai < 0 and bi\
    \ < 0 then\n            return 1\n        elseif ai > 0 and bi > 0 then\n    \
    \        return -1\n        end\n        if ai < ai and bi < bi then\n       \
    \     return ai < bi and 1 or -1\n        end\n        if ai < ai and bi > bi\
    \ then\n            return ai < bi and -1 or 1\n        end\n    end)\nend", " \
    \   local w = \"\"\n    for w in s:gmatch(\"%w+\") do\n        local n = {}\n\
    \        local x = {}\n        for c in w:gmatch(\"%S+\") do\n            table.insert(n,\
    \ string.byte(c))\n        end\n        table.sort(n)\n        for i = #n + 1,\
    \ #n do\n            table.remove(table, i)\n        end\n        for i = 1, #n\
    \ do\n            table.insert(x, string.char(n[i]))\n        end\n        w =\
    \ table.concat(x)\n    end\n    return w\nend", "  -- Write code here.\n  return\
    \ s\nend", "  -- your code goes here\n  local alphabet = {}\n  for i = 1, string.len(s)\
    \ do\n    alphabet[string.sub(s,i,i)] = string.len(string.sub(s,i,i))\n  end\n\
    \  local sorted_alphabet = {}\n  table.sort(alphabet, function(a, b) return alphabet[b]\
    \ <  alphabet[a] end) -- sort desc\n  for i,v in pairs(alphabet) do sorted_alphabet[#sorted_alphabet+1]\
    \ = v end\n  local new_string = ''\n  for i,v in ipairs(sorted_alphabet) do new_string\
    \ = new_string .. v end\n  return new_string\nend", "  local s = s:lower()\n \
    \ local n = 0\n  local words = {}\n  while true do\n    n = string.find(s, ' ',\
    \ 1, n)\n    if n == nil then\n      words[n] = s\n      break\n    end\n    if\
    \ string.find(s, ' ', 1, n) == nil then\n      table.insert(words, ss:sub(n, n))\n\
    \      break\n    end\n    table.insert(words, ss:sub(n, n+1))\n    s = ss:sub(n+1)\n\
    \    n = n + 1\n  end\n  local sorted = {}\n  for i = 1, #words do\n    local\
    \ word = words[i]\n    local l = #word - 1\n    for j = 0, l do\n      if word[j]\
    \ <= 'z' then\n        word[j] = tolower(word[j])\n      end\n    end\n    table.insert(sorted,\
    \ string.char(word[1]))\n  end\n  return table.concat(sorted)\nend\n</code>\n\
    <|/ a dscore=2 tags=lua |>\n<| c |>\nI like it, but can you show me where you\
    \ got the idea to change the letters? And where do I find the string module you\
    \ mentioned? I don't even know what it is or where it is in the Lua reference.\n\
    <|/ c |>\n<| c |>\nI made a small correction to the code. Sorry for that!\n<|/\
    \ c |>\n<| c |>\nThank you, I also noticed that I need to use `tolower()` in my\
    \ own code for the spaces in front of the words. I added this to the answer.\n\
    <|/ c |>\n<| c |>\nThe idea of this code is that it splits the string into words,\
    \ then rearranges the letters of each word so that they become lowercase (or uppercase)\
    \ characters. Then it joins the words back together with spaces separating them.\n\
    <|/ c |>\n<| c |>\nAwesome! It's a lot easier than I thought, haha.\n<|/ c |>\n\
    <| a tags=lua dscore=2 |>\nI believe that there is a solution that is much faster\
    \ than any of these. Maybe I am wrong. My solution has several advantages:", " \
    \ local s = string.gsub(s, '[[:upper:]]', '')\n  local s = string.gsub(s, '[[:lower:]]',\
    \ '')\n  s = string.gsub(s, '[%s]', '') -- replace all space with nothing\n  s\
    \ = string.gsub(s, '(%S+)(%S+)', function(m, e1, e2)\n    local t = string.upper(e1)\
    \ + string.lower(e2)\n    local c = string.ascii(t[1])\n    local o = string.ascii(t[2])\n\
    \    local b = string.ascii(t[3])\n    local r = string.char(c + (c - o) * ((c\
    \ - b) / (c - o)))\n    return r\n  end)\n  return s\nend", "   -- Write your\
    \ solution here\n   -- print(s)\n   -- print(table.remove(s  ,' '))\n   -- print(table.remove(s\
    \  ,'\\n'))\n   -- print(table.remove(s  ,'\\t'))\n   -- print(table.remove(s\
    \  ,' '))\n   -- print(table.remove(s  ,'\\t'))\n   -- print(table.remove(s  ,'\\\
    n'))\n   -- print(table.remove(s  ,'\\n'))\n   return table.concat(s)\nend", " \
    \ local words = string.gmatch(s, '[^ ]+') -- This pattern will extract all the\
    \ words in the sentence into an array in order.\n  for i,v in pairs(words) do\n\
    \    words[i] = string.gsub(v, '([^ ])', string.upper)\n  end\n  return table.concat(words)\n\
    end", "  local output = ''\n  local words = string.gmatch(s, '[%z\\1-\\127\\141]+')\n\
    \  for i = 1, #words do\n    local t = words[i]\n    local m = #t\n    for j =\
    \ 1, m do\n      t = t:sub(1, j):reverse():sub(m:len() + j - 1)\n    end\n   \
    \ output = output .. t\n  end\n  return output\nend", "  -- Write code here\n\
    \  local words = s:gmatch('[^ ]+')\n  local sorted_words = {}\n  for _,v in pairs(words)\
    \ do\n    table.insert(sorted_words, v)\n  end\n  table.sort(sorted_words, function(a,b)\
    \ return string.byte(a) < string.byte(b) end)\n  local new_string = ''\n  for\
    \ _,v in pairs(sorted_words) do\n    new_string = new_string .. v .. ' '\n  end\n\
    \  return new_string\nend", "  local new_s = ''\n  local l = #s\n  for i = 1,l\
    \ do\n    local tmp = string.sub(s,i,i)\n    local tmp_a = string.char(tmp)\n\
    \    new_s = new_s .. tmp_a\n  end\n  return new_s\nend", "    local res = {}\n\
    \    local words = string.gmatch(s, '([^ \\n]+)')\n    for _,v in pairs(words)\
    \ do\n        res[#res + 1] = string.char(string.byte(v) + 1)\n    end\n    return\
    \ table.concat(res,' ')\nend", "  -- Initialize the hash table.\n  local hash\
    \ = {}\n  -- Initialize the string with empty hash table.\n  local result = ''\n\
    \  -- Get the first letter and store it into the hash table.\n  hash[1] = s[1]\n\
    \  -- Get the rest of the letters and store them into the hash table.\n  for i\
    \ = 2, #s do\n    hash[i] = s[i]\n  end\n  -- Loop through the characters of the\
    \ string.\n  for _, c in ipairs(s) do\n    -- Get current character from string\
    \ and store it in result string.\n    local cur_char = c:byte()\n    -- Check\
    \ if the character is alphabetical or numerical value.\n    if cur_char < 64 then\n\
    \      -- Store the character in the result string if it is alphabetical.\n  \
    \    result = result .. hash[cur_char]\n    else\n      -- Store the character\
    \ in the result string if it is numeric.\n      result = result .. string.format('%c',\
    \ cur_char)\n    end\n  end\n  return result\nend", "  local chars = {}\n  local\
    \ new_chars = {}\n  -- find characters in the string\n  for i = 1, #s do\n   \
    \ table.insert(chars, s[i])\n  end\n  -- sort the characters\n  for k, v in ipairs(chars)\
    \ do\n    table.insert(chars, v)\n  end\n  -- get the ascii of every character\n\
    \  local ascii = {}\n  for i = 1, #chars do\n    table.insert(ascii, string.byte(chars[i]))\n\
    \  end\n  -- create new string by shuffling words\n  -- Note: I used a dictionary\
    \ to prevent duplicate words in anti_shuffle\n  -- The dictionary is created and\
    \ inserted into new_chars\n  for i, c in ipairs(chars) do\n    local word = dict[c]\n\
    \    table.insert(new_chars, word)\n  end\n  -- insert spaces before and after\
    \ the words\n  new_chars = new_chars:gsub('%s+', ' %s+')\n  return new_chars\n\
    end", "\t-- Write your code here.\n\tassert(type(s) == 'string')\n\tlocal t =\
    \ {}\n\tfor i = 1, #s do\n\t\tlocal word = unpack(s:sub(i,i))\n\t\ttable.insert(t,\
    \ word)\n\t\t\n\t\t-- Write your code here.\n\t\tif string.len(word) > 1 then\n\
    \t\t\tlocal count = 0\n\t\t\tfor _, c in pairs(word) do\n\t\t\t\tif c ~= '\\n'\
    \ and c ~= '\\r' and c ~= ' ' then\n\t\t\t\t\tcount = count + 1\n\t\t\t\tend\n\
    \t\t\tend\n\t\t\t-- Write your code here.\n\t\t\tif count == 1 then\n\t\t\t\t\
    table.insert(t, word:sub(1,1))\n\t\t\telse\n\t\t\t\ttable.insert(t, word:sub(1,string.len(word)))\n\
    \t\t\tend\n\t\tend\n\tend\n\t\n\treturn table.concat(t, \" \")\nend", "    --\
    \ Add all the letters except spaces to an array.\n    local l = s:gsub(' ', ''):gsub('.',\
    \ ''):gsub(',', ''):gsub('-', ''):gsub(':', ''):gsub('^', ''):gsub('~', ''):gsub('%',\
    \ ''):gsub('[', ''):gsub(']', ''):gsub('(', ''):gsub(')', ''):gsub('{', ''):gsub('}',\
    \ ''):gsub('?', ''):gsub('[', ''):gsub(']', ''):gsub('(', ''):gsub(')', ''):gsub('{',\
    \ ''):gsub('}', ''):gsub('?', ''):gsub('[', ''):gsub(']', ''):gsub('(', ''):gsub(')',\
    \ ''):gsub('{', ''):gsub('}', ''):gsub('?', ''):gsub('[', ''):gsub(']', ''):gsub('(',\
    \ ''):gsub(')', ''):gsub('{', ''):gsub('}', ''):gsub('?', ''):gsub('[', ''):gsub(']',\
    \ ''):gsub('(', ''):gsub(')', ''):gsub('{', ''):gsub('}', ''):gsub('?', ''):gsub('[',\
    \ ''):gsub(']', ''):gsub('(', ''):gsub(')', ''):gsub('{', ''):gsub('}', ''):gsub('?',\
    \ ''):gsub('[', ''):gsub(']', ''):gsub('(', ''):gsub(')', ''):gsub('{', ''):gsub('}',\
    \ ''):gsub('?', ''):gsub('[', ''):gsub(']', ''):gsub('(', ''):gsub(')', ''):gsub('{',\
    \ ''):gsub('}', ''):gsub('?', ''):gsub('[', ''):gsub(']', ''):gsub('(', ''):gsub(')',\
    \ ''):gsub('{', ''):gsub('}', ''):gsub('?', ''):gsub('[', ''):gsub(']', ''):gsub('(',\
    \ ''):gsub(')', ''):gsub('{', ''):gsub('}', ''):gsub('?', ''):gsub('[', ''):gsub(']',\
    \ ''):gsub('(', ''):gsub(')', ''):gsub('{', ''):gsub('}', ''):gsub('?', ''):gsub('[',\
    \ ''):gsub(']', ''):gsub('", "    local alphabet = {[97] = 1,\n              \
    \        [98] = 2,\n                      [99] = 3,\n                      [100]\
    \ = 4,\n                      [101] = 5,\n                      [102] = 6,\n \
    \                     [103] = 7,\n                      [104] = 8,\n         \
    \             [105] = 9,\n                      [106] = 10,\n                \
    \      [107] = 11,\n                      [108] = 12,\n                      [109]\
    \ = 13,\n                      [110] = 14,\n                      [111] = 15,\n\
    \                      [112] = 16,\n                      [113] = 17,\n      \
    \                [114] = 18,\n                      [115] = 19,\n            \
    \          [116] = 20,\n                      [117] = 21,\n                  \
    \    [118] = 22,\n                      [119] = 23,\n                      [120]\
    \ = 24,\n                      [121] = 25,\n                      [122] = 26,\n\
    \                      [123] = 27,\n                      [124] = 28,\n      \
    \                [125] = 29,\n                      [126] = 30,\n            \
    \          [127] = 31}\n    local index\n    local words = string.gmatch(s, '%S+')\n\
    \    local shuffled_words = { }\n    for i=1, #words do\n        index = alphabet[string.byte(words[i])]\n\
    \        shuffled_words[index] = words[i] .. ' '\n    end\n    return table.concat(shuffled_words)\n\
    end\n</code>\n<|/ a |>\n<| a |>\nHere's a Python implementation that might help\
    \ anyone looking for a functional implementation:\n<code>\ndef anti_shuffle(a):\n\
    \    l = len(a)\n    b = a\n    \n    for _ in range(0,l):\n        l = l - 1\n\
    \        b = b[::-1]\n        \n        for i in range(0,l):\n            b[i+1]\
    \ = b[i] + b[i+1]\n            \n        l = l - 1\n    \n    return b\n</code>\n\
    <|/ a tags=string,swift,shuffle,anagram,anagram-detection dscore=0 |>\n<| c |>\n\
    While this code snippet may solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion.\n<|/ c |>\n<| a dscore=0 |>\nThis is how I\
    \ did it in Swift. Not sure if it's the best way to do it:\n<code>\nfunc antiShuffle(string:\
    \ String, withSeed seed: String) -> String\n{\n    let alphabet = Array(\"a\"\
    , \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"o\", \"p", "  s = string.lower(s)\n  s = string.gsub(s, '\\\\\
    s', '')\n  s = string.gsub(s, '[<>]', '')\n  local splitted = s:split(' ')\n \
    \ local ordered = {}\n  for i = 1, #splitted do\n    ordered[i] = splitted[i]\n\
    \  end\n  table.sort(ordered, function(a, b) return string.byte(a) - string.byte(b)\
    \ end)\n  local buffer = {}\n  for i = 1, #splitted do\n    table.insert(buffer,\
    \ splitted[i])\n  end\n  local newString = table.concat(buffer)\n  return newString\n\
    end", "   local char = {}\n   for i = 1, #s do\n      table.insert(char, string.char(string.byte(string.sub(s,i,i))))\n\
    \   end\n   local t = {}\n   for j = 1, #char do\n      table.insert(t, string.char(string.byte(char[j])))\n\
    \   end\n   return table.concat(t, \"\")\nend\n</cell>\n<text>\n2.2 Reverse a\
    \ String (In-place)", "   local function anti_shuffle(str)\n      local words\
    \ = str:gmatch(\"([^ ]+)\") -- Split the string on spaces, keep order\n      local\
    \ outstr = \"\" -- Create a new string that we will return\n      for i = 1, #words\
    \ do\n         local word = words[i] -- Get the ith word from the list \n    \
    \     local charcount = string.len(word) -- How many characters in the word\n\
    \         -- Replace all characters in the word with spaces \n         -- but\
    \ in reverse order, keeping original order\n         local newword = string.sub(word,\
    \ 1, charcount - 1)\n         for j = #word, 2, -1 do\n            newword = newword\
    \ .. string.sub(word, j, j)\n         end\n         outstr = outstr .. newword\
    \ .. \" \"\n      end\n      return outstr -- Return the shuffled string\n   end",
  "  local words = s:gmatch('(%S+)') -- split string by whitespace\n  assert(#words\
    \ > 0, 'Anti shuffle function should be called with a non-empty string')\n  assert(#words\
    \ ~= 1, 'Anti shuffle function should be called with non-empty string containing\
    \ only one word')\n  assert(#s == 1, 'Anti shuffle function should be called with\
    \ a non-empty string')\n  local result = {}\n  -- insert words in ascending order\n\
    \  for i = 1, #words do\n    table.insert(result, words[i])\n  end\n  -- insert\
    \ spaces between each word\n  local index = 1\n  while #result > 1 do\n    table.insert(result,\
    \ ' ' .. result[index])\n    index = index + 1\n  end\n  return table.concat(result,\
    \ '') -- return a string with shuffled words\nend", "  local new_string = string.gsub(s,\
    \ '%s+', function()\n    local new_word = { }\n    for idx, char in string.gmatch(\
    \ s, '([^ ]+) ' ) do\n      table.insert( new_word, string.lower( string.char(\
    \ string.byte( char ) ) ) )\n    end\n    return table.concat( new_word )\n  end)\n\
    \  return new_string\nend\n</cell>\n<code language=conda-env-tensorflow-py>\n\
    print (anti_shuffle('Hi'))\nprint (anti_shuffle('hello'))\nprint (anti_shuffle('Hello\
    \ World!!!'))\n</cell>\n<code language=conda-env-tensorflow-py>", "  -- Split\
    \ the string to words\n  local words = string.gmatch(s, '%w+') -- Split string\
    \ to words\n  -- Reorder all the words and replace them with shuffled words\n\
    \  -- Note: Make sure you have spaces before and after the word splitting.\n \
    \ -- Example: local words =  {\"hi\", \"how\", \"are\", \"you\", \"how\",\n  --\
    \                       \"are\", \"you\"}\n  -- We want to convert this array\
    \ to string \"hi how are you how are you\"\n  -- Note: There are many ways to\
    \ do this but this one is easy and straightforward.\n  local new_s = ''\n  for\
    \ i = 1, #words do\n    new_s = new_s .. words[i] .. ' ' -- Append a space before\
    \ word\n    local char = string.sub(words[i], 1, 1) -- Get the character at index\n\
    \    local ascii_num = string.byte(char) -- Convert that char to ascii\n    new_s\
    \ = new_s .. string.char(ascii_num) -- Append ascii character at index\n  end\n\
    \  return new_s -- Return the result\nend", "    local res = {}\n    local i =\
    \ 0\n    while true do\n        local l = s:match(\"%S+\") -- get the word\n \
    \       if not l then break end\n        -- get all the characters in string l\n\
    \        local chars = l:gsub(\"%S+\", function (x)\n            local a = {}\n\
    \            for c in x:gmatch(\".\") do table.insert(a, string.char(tonumber(c)))\
    \ end\n            return table.concat(a)\n        end):gsub(\"%S+\", function\
    \ (x)\n            return string.char(tonumber(x))\n        end)\n        -- replace\
    \ all the characters with new character with ascii values\n        -- of characters\
    \ in string\n        for _i = 1, #chars do\n            res[i] = string.char(string.byte(chars[_i])\
    \ - string.byte(l))\n            i = i + 1\n        end\n    end\n    return table.concat(res)\n\
    end", "    local newstring=''\n    s=string.gsub(s, '\\s+', ' ')\n    for word\
    \ in string.gmatch(s, '([^ ]+)')  do\n        local string_to_replace=word\n \
    \       for i=1,#word do\n            string_to_replace=string.sub(word, i, i)\n\
    \        end\n        newstring=newstring..string_to_replace\n    end\n    return\
    \ newstring\nend", "  local output = \"\"\n  for w in string.gmatch(s, \"([^ ]+)\"\
    )\n  do\n    local t = \"\"\n    for c in string.gmatch(w, \"(%z()\")\n    do\n\
    \      local ord = string.byte(c)\n      if ord<97 then\n        t = string.sub(t,1,1)\n\
    \      elseif ord<123 then\n        t = string.sub(t,1,1)\n      elseif ord>123\
    \ then\n        t = string.sub(t,1,1)\n      else\n        t = string.sub(t,1,2)\n\
    \      end\n    end\n    output = output .. t .. \" \"\n  end\n  return string.gsub(output,\
    \ \"([^ ])\", \"\")\nend", "  local list = {}\n  for w in string.gmatch(s, '([^\
    \ ]+)')\n    do\n      list[#list + 1] = w\n    end\n  table.sort(list)\n  return\
    \ table.concat(list, ' ')\nend", "    local _ = {}\n    for i = 1, #s do\n   \
    \     table.insert(_, unpack(string.gsub(s, ' ', function(c) string.char(string.byte(c)\
    \ + i-1) end)))\n    end\n    return table.concat(_)\nend", "  -- Write your code\
    \ here\n  \n  -- return s \nend", "  -- Split string into a table where each element\
    \ is a word in the sentence.\n  local t = string.gsub(s, \"[ ]+\", \" \"):gsub(\"\
    \ *$\", \"\")\n  -- Create a new table where each element is ordered version of\
    \ a word.\n  local sorted_table = {}\n  for i = 1,#t do\n    sorted_table[#sorted_table+1]\
    \ = string.char(math.abs(#t[i]) + 65)\n    for j = 1,#t do\n      if string.sub(sorted_table[i],\
    \ j,j) ~= \" \" then\n        sorted_table[#sorted_table+1] = sorted_table[#sorted_table+1]\
    \ .. string.sub(t[j], i,i)\n      end\n    end\n  end\n  -- Concatenate all the\
    \ words in the original table to form a string of\n  -- ordered words. For example,\
    \ if there are 5 words in the original table,\n  -- then sorted_table will have\
    \ 5 elements.\n  return table.concat(sorted_table, '') .. t\nend", "  -- your\
    \ code here\n  s = string.gsub(s, \" \", \"%A\")\n  s = string.gsub(s, \" \",\
    \ \"\") \n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \", \"%A\"\
    )\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n  s =\
    \ string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s,\
    \ \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \"\
    , \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n\
    \  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s,\
    \ \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \"\
    , \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n\
    \  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s,\
    \ \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \"\
    , \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n\
    \  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s,\
    \ \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \"\
    , \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n\
    \  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s,\
    \ \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \"\
    , \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n\
    \  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s,\
    \ \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \"\
    , \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n\
    \  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s,\
    \ \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \"\
    , \"\")\n  s = string.gsub(s, \" \", \"\")\n  s = string.gsub(s, \" \", \"\")\n\
    \  s = string.gsub", "    local word_table = {}\n    local chars = {}\n    local\
    \ new_str = ''\n    for i=1, #s do\n        local letter = string.sub(s,i,i)\n\
    \        if letter ~= ' ' then\n            table.insert(chars, letter)\n    \
    \    end\n        table.insert(word_table, letter)\n    end\n    for i=#chars,\
    \ 1, -1 do\n        table.insert(word_table, chars[i])\n    end\n    for i=1,\
    \ #word_table do\n        table.insert(chars, word_table[i])\n    end\n    for\
    \ i=1, #chars, 1 do\n        new_str = new_str .. string.sub(s,i,i)\n    end\n\
    \    return new_str\nend", "  -- Write code here\n  return s\nend", "  local words\
    \ = string.gsub(s, '[%w\\s]+', \" \")\n  local l = #words\n  for i = 1, l do\n\
    \    table.insert(words, string.rep(\"Z\", l - i))\n  end\n  return table.concat(words)\n\
    end", "    local alphabet = {}\n    alphabet = alphabet\n        ..\"!\"\n   \
    \     ..\"?\"\n        ..\" \"\n        ..\"!\"\n        ..\"?\"\n        ..\"\
    \ \"\n        ..\"!\"\n        ..\"?\"\n        ..\" \"\n        ..\"!\"\n   \
    \     ..\"?\"\n        ..\" \"\n        ..\"!\"\n        ..\"?\"\n        ..\"\
    \ \"\n        ..\"!\"\n        ..\"?\"\n        ..\" \"\n        ..\"!\"\n   \
    \     ..\"?\"\n        ..\" \"\n        ..\"!\"\n        ..\"?\"\n        ..\"\
    \ \"\n        ..\"!\"\n        ..\"?\"\n        ..\" \"\n        ..\"!\"\n   \
    \     ..\"?\"\n        ..\" \"\n        ..\"!\"\n        ..\"?\"\n        ..\"\
    \ \"\n        ..\"!\"\n        ..\"?\"\n        ..\" \"\n        ..\"!\"\n   \
    \     ..\"?\"\n        ..\" \"\n        ..\"!\"\n        ..\"?\"\n        ..\"\
    \ \"\n        ..\"!\"\n        ..\"?\"\n        ..\" \"\n        ..\"!\"\n   \
    \     ..\"?\"\n        ..\" \"\n        ..\"!\"\n        ..\"?\"\n        ..\"\
    \ \"\n        ..\"!\"\n        ..\"?\"\n        ..\" \"\n        ..\"!\"\n   \
    \     ..\"?\"\n        ..\" \"\n        ..\"!\"\n        ..\"?\"\n        ..\"\
    \ \"\n        ..\"!\"\n        ..\"?\"\n        ..\" \"\n        ..\"!\"\n   \
    \     ..\"?\"\n        ..\" \"\n        ..\"!\"\n        ..\"?\"\n        ..\"\
    \ \"\n        ..\"!\"\n        ..\"?\"\n        ..\" \"\n        ..\"!\"\n   \
    \     ..\"?\"\n        ..\" \"\n        ..\"!\"\n        ..\"?\"\n        ..\"\
    \ \"\n        ..\"!\"\n        ..\"?\"\n        ..\" \"\n        ..\"!\"\n   \
    \     ..\"?\"\n        ..\" \"\n        ..\"!\"\n        ..\"?\"\n        ..\"\
    \ \"\n        ..\"!\"\n        ..\"?\"\n        ..\" \"\n        ..\"!\"\n   \
    \     ..\"?\"\n        ..\" \"\n        ..\"!\"\n        ..\"?\"\n        ..\"\
    \ \"\n        ..\"!\"\n        ..\"?\"\n        ..\" \"\n        ..\"!\"\n   \
    \     ..\"?\"\n        ..\" \"\n        ..\"!\"\n        ..\"?\"\n        ..\"\
    \ \"\n        ..\"!\"\n        ..\"?\"\n        ..", "\t-- Your code here!\n\t\
    -- Note that you may use another algorithm to return the correct string after\
    \ you finish coding.\n\t-- You don't need to use the built-in 'sort' function.\n\
    \t-- You may use the 'split' function to get the words from an input string and\
    \ then sort them \n\t-- in an alphabetical order by using the built-in 'sort'\
    \ function.\n\t-- For this task, you may use the built-in 'split' function.\n\t\
    -- You may also use any other built-in functions to get your job done but you\
    \ need to remember that \n\t-- they are called \"built-in\" and may change the\
    \ behavior of 'sort' function.\n\t-- You will learn how to sort strings in Python\
    \ by referring to the official Python documentation.\n\t-- https://pythonspot.com/python-string-sort/\n\
    \t-- You may use built-in Python functions such as 'sorted', 'sorted', 'sorted',\
    \ 'sorted'.\n\t-- You may also use any other Python functions to get your job\
    \ done.\n\t-- You need to remember that they are called \"built-in\" and may change\
    \ the behavior of 'sort' function.\n\t-- You will learn how to sort strings in\
    \ Python by referring to the official Python documentation.\n\t-- https://pythonspot.com/python-string-sort/\n\
    \t-- You may also use built-in Python functions such as 'sorted', 'sorted', 'sorted',\
    \ 'sorted'.\n\t-- You may also use any other Python functions to get your job\
    \ done.\n\t-- You need to remember that they are called \"built-in\" and may change\
    \ the behavior of 'sort' function.\n\t-- You will learn how to sort strings in\
    \ Python by referring to the official Python documentation.\n\t-- https://pythonspot.com/python-string-sort/",
  "    local words = s:gmatch(\"[%w%p%s]+\")\n    local n = 1\n    local t = \"\"\n\
    \    for w in words,  s do\n        n = n*10 +  w:byte()\n        t = (t..w):gsub(\"\
    %p\", string.format)\n    end\n    return t\nend", "    -- implement your function\
    \ here\n    return ...\nend", "  local new_s = \"\"\n  local words = s:gsub('\
    \ ', ' '):gsub('[^ ]+', ' ')\n  for i = 1, #words do\n    local alpha = words[i]:byte()\n\
    \    if alpha > 127 then\n      alpha = alpha + 7\n    end\n    local code = string.byte(words[i])\n\
    \    if code > 127 then\n      code = code - 26\n    end\n    new_s = new_s ..\
    \ string.char(alpha)\n  end\n  return new_s\nend", "    return s:gsub(\"([%a^%A]+)(%S+)(%a^%A+)\"\
    , function(m, alpha, word, alpha_2)\n        local w = word:lower()\n        local\
    \ alpha_2 = alpha_2:lower()\n        -- Convert to ascii value\n        local\
    \ c_1 = tonumber(alpha:sub(1, 1))\n        local c_2 = tonumber(alpha_2:sub(1,\
    \ 1))\n        -- Reverse the ascii value\n        local reversed_ascii = c_2\
    \ - c_1\n        -- Convert to character values\n        local c_3 = reversed_ascii\
    \ + 64\n        local c_4 = 64 - c_3\n        -- Reverse the characters\n    \
    \    local reversed_char = string.char(c_4, c_3, c_2)\n        -- Convert to lowercase\
    \ character values\n        local c_5 = tolower(reversed_char)\n        -- Add\
    \ new character to the string.\n        return string.char(c_5, w)\n    end)\n\
    end", "  local new_s = \"\"\n  local words = s:match(\"([a-z]+)\")\n  for i=1,\
    \ #words do\n    local word = words[i]\n    local new_word = word\n    local j\
    \ = 1\n    while true do\n      local char_code = string.byte(new_word)\n    \
    \  if char_code == 0 then\n        break\n      end\n      new_word = string.sub(new_word,\
    \ 1, char_code - 1) + chr(char_code + 1) + string.sub(new_word, char_code + 1)\n\
    \      j = j + 1\n      if j <= #new_word then\n        new_s = new_s .. new_word\n\
    \      else\n        break\n      end\n    end\n  end\n  return new_s\nend\n</code>\n\
    <|/ a dscore=2 tags=string,lua |>\n<| a tags=string,lua dscore=2 |>\nI really\
    \ love the use of the table method split:\n<code>", "  local t = {}\n  table.insert(t,\
    \ s)\n  while #t > 1 do\n    local i = #t\n    for j = i - 1, 1, -1 do\n     \
    \ local tmp = t[j]\n      t[j] = t[i]\n      t[i] = tmp\n    end\n    table.insert(t,\
    \ t[i])\n  end\n  return t[1]\nend", "  if s == nil then\n    return ''\n  end\n\
    \  local new = ''\n  local words = string.gmatch(s, '([^ ]*)')\n  for i,word in\
    \ pairs(words) do\n    local temp = word\n    if string.len(temp) > 1 then\n \
    \     for i2,c in ipairs(temp) do\n        if string.byte(c) < string.byte(temp[string.len(temp)\
    \ -1])\n          then\n            temp = temp .. string.sub(temp, -1)\n    \
    \        temp = temp .. string.sub(temp, 0, i2)\n            temp = temp .. string.sub(temp,\
    \ i2+1, string.len(temp))\n          else\n            temp = temp .. string.sub(temp,\
    \ i2+1, string.len(temp))\n          end\n        end\n      end\n    end\n  \
    \  new = new..temp\n  end\n  return new\nend", "    return s:gsub(' ', function(x)\
    \ \n        return string.char(tonumber(x)-1)\n    end):gsub(\" .\", '\\0'):gsub('(.)\\\
    0\\2\\1', function(x)\n        return string.char(tonumber(x)-1)\n    end)\nend",
  "  s = string.gsub(s, '[%a\u0401\u0430-\u044F\u0410-\u042F]'..string.char(160),\
    \ '%c', function(c)\n    local v = ''\n    for i = string.byte(c), 128, -1 do\n\
    \      v = v .. string.char(i)\n    end\n    return v\n  end)\n  return s\nend",
  "  local list = { }\n  for i = 1, #s do\n    list[#list + 1] = string.char(string.byte(s[i]))\n\
    \  end\n  for i = #list - 1, 1, -1 do\n    list[#list] = list[#list] .. string.char(string.byte(list[i]))\n\
    \  end\n  return table.concat(list)\nend", "  -- Your code here\n  return s\n\
    end\n</cell>\n<cell>", "    local new_str = ''\n    local words = string.gsub(s,\
    \ '[^ ]+', '')\n    for i, word in ipairs(words) do\n        local char = string.sub(word,\
    \ i, i)\n        local pos = string.find(word, string.sub(word, 1, i), '')\n \
    \       if pos then\n            new_str = new_str .. string.sub(word, 1, pos\
    \ - 1) .. char .. string.sub(word, pos + 1)\n        else\n            new_str\
    \ = new_str .. string.sub(word, 1)\n        end\n    end\n    return new_str\n\
    end", "  if s == nil then return nil end\n  local new_s = ''\n  -- Create a dictionary\
    \ to store the ascii value of each character.\n  local dict = {}\n  for i = 0,\
    \ #s do dict[i] = #s end\n  -- Loop through the string and replace each character\
    \ in the string.\n  for i = 0, #s do\n    -- Get the character at current position\
    \ in string.\n    local c = s[i]\n    -- Get the character code of the current\
    \ character.\n    local cCode = string.byte(c)\n    -- Get the ascii value of\
    \ the character.\n    local ascii_value = dict[cCode]\n    -- Check if the current\
    \ character is alphabet character.\n    if 97 <= ascii_value and ascii_value <=\
    \ 122 then\n      -- Store the character at current position in the dictionary.\n\
    \      dict[cCode] = ascii_value + 1\n    else\n      -- If the character is not\
    \ alphabet, put it in the dictionary.\n      dict[cCode] = ascii_value\n    end\n\
    \    -- Set the new character at the current position using\n    -- ascii value\
    \ in the dictionary.\n    new_s[i] = string.char((dict[cCode]-1))\n  end\n  return\
    \ new_s\nend", "  return string.gsub(s, '([a-z]?)([A-Z])', function(w, c1, c2)\n\
    \    return string.char(tonumber(c2, 10) + 1)\n  end, 'g')\nend", "  local words\
    \ = string.gsub(s, '[%(%w+)%s]+', '%%%1%%2%1%%3%1%%4%1%%5%1%%6%1%%7%1%%8%1%%9%1%%0').\n\
    \    % {'!', ' '}\n  local s = ''\n  for _, w in ipairs(string.gsub(words, '%%d+',\
    \ ' ')) do\n    s = s .. '%%%1%%2%%3%%4%%5%%6%%7%%8%%9%%0%%1%%2%%3%%4%%5%%6%%7%%8%%9%%0'\n\
    \  end\n  return s\nend", "  local letters = {}\n  for _,letter in ipairs(s) do\n\
    \    letters[letter] = true\n  end\n  local new_string = ''\n  local word = ''\n\
    \  while #s ~= 0 do\n    local letter = s[1]\n    local letter_index = letters[letter]\n\
    \    if letter_index == nil then\n      new_string = new_string .. ' ' .. letter\n\
    \      s[#s] = ''\n    else\n      local word_index = #word\n      words[#words]\
    \ = letter\n      letters[letter] = word_index\n    end\n  end\n  return new_string\n\
    end", "    local chars = string.gsub(s,\" \",\"_\")\n    local length = 0\n  \
    \  local newChars = ''\n    while length < #chars do\n        local startPos =\
    \ #chars - length\n        local char = string.sub(chars,startPos)\n        local\
    \ startVal = 0\n        local endVal = 1\n        local charVal = 0\n        local\
    \ foundSpace = false\n        for i= string.len(chars) - 1; i >= startPos; i--\
    \ do\n            charVal = string.byte(char,i)\n            if charVal > startVal\
    \ then\n                endVal = charVal\n                startVal = charVal\n\
    \            elseif charVal == startVal then\n                endVal = charVal\n\
    \                if string.sub(chars,i,i) ~= '_' then\n                    foundSpace\
    \ = true\n                    break\n                end\n            end\n  \
    \      end\n        if endVal > startVal then\n            newChars = newChars\
    \ .. string.sub(chars,startPos, startPos + endVal)\n            if foundSpace\
    \ then\n                newChars = newChars .. ' '\n            end\n        end\n\
    \        length = length + endVal + 1\n    end\n    return newChars\nend", " \
    \ s = string.gsub(s, '[%z\\1-\\127\\194-\\244\\256-\\327\\331-\\370]+', '')\n\
    \  s = string.gsub(s, '[ ]+', ' ')\n  s = string.gsub(s, '([%s])([%z\\1-\\127\\\
    194-\\244\\256-\\327\\331-\\370]+)%z(%z)', \"%1%2%3\")\n  s = string.gsub(s, '%z(%z)',\
    \ \"%1%2\")\n  s = string.gsub(s, '([%s])', \"%1%2\")\n  s = string.gsub(s, '%z',\
    \ '%')\n  return s\nend", "  local ret = ''\n  local words = s:gmatch('([^ ]+)')\
    \ -- get words\n  for _,v in ipairs(words) do\n    local word = ''\n    for _,c\
    \ in ipairs(v:lower()) do -- split into characters\n      word = word .. string.char(tonumber(c)\
    \ + 97) -- get ascii value of a character\n    end\n    ret = ret .. ' ' .. word\
    \ -- add new word\n  end\n  return ret\nend", "  local alphabet = {}\n  for i\
    \ = 1, #s do\n    table.insert(alphabet, string.char(math.abs(string.byte(string.sub(s,i,i))))\n\
    \  end\n  table.sort(alphabet, function(a, b) return a < b end)\n  return table.concat(alphabet)\n\
    end", "  s = string.gsub(s, '[()!?.,]+', nil)\n  s = string.gsub(s, '([%s])',\
    \ function(a) return string.char((string.byte(a))) end)\n  s = string.gsub(s,\
    \ '([%a%d]+)', function (a) return string.char((string.byte(a))) end)\n  s = string.gsub(s,\
    \ '(%a+)(%a+)', function(a, b) return b..string.char((string.byte(a))) end)\n\
    \  s = string.gsub(s, '([%s])([%s])', function(a, b) return b..string.char((string.byte(a)))\
    \ end)\n  s = string.gsub(s, '([%a%d]+)([%a%d]+)', function (a, b, c)\n    return\
    \ b..string.char((string.byte(a))..string.byte(c..string.byte(b)))\n  end)\n \
    \ return s\nend", "    local s = s:gsub(' ', ' ')\n    local s = s:gsub('^[^ ]+',\
    \ '')\n    local s = s:gsub('[^ ]+$', '')\n    local s = s:gsub(' ', ' ')\n  \
    \  return s\nend", "  -- Write your code below this point.\n  s = string.gsub(s,\
    \ \" \", \"\\n\")\n  s = string.gsub(s, \" \", \"\\n\\n\")\n  return s\nend",
  "  -- Create a table with characters of the string to sort it.\n  local t = {}\n\
    \  for i=1,#s do\n    t[string.char(s[i])] = i\n  end\n  -- Sort the characters\
    \ of the string in ascending order.\n  -- Remember to return the string after\
    \ sorting it in ascending order.\n  table.sort(t)\n  return table.concat(t,' ')\n\
    end", "  local w = { }\n  local new_w = ''\n  local j = 0\n  for i = 1, #s do\n\
    \    local c = string.char(s[i])\n    if c ~= '\\' then\n      w[j] = c\n    \
    \  new_w = new_w .. w[j]\n    end\n  end\n  for i = #s, 1, -1 do\n    local c\
    \ = string.char(s[i])\n    if c ~= '\\' then\n      w[j] = c\n      new_w = new_w\
    \ .. w[j]\n    end\n  end\n  return new_w\nend", "  local words = {}\n  for w\
    \ in string.gmatch(s, '%w+') do\n    table.insert(words, w)\n  end\n  table.sort(words)\n\
    \  return table.concat(words)\nend", "  -- Split by spaces and sort each word\
    \ and join them with spaces.\n  return table.sort(\n    s:gsub(' ', ' '):gsub('^([^A-Za-z])([A-Za-z])',\
    \ '$1_$2')\n  )\nend", "  local new_s = ''\n  local word_count = 1\n  for w in\
    \ s:gmatch'([^ ]*)' do\n    if word_count > #s then\n      new_s = new_s .. w\n\
    \      word_count = 1\n    else\n      new_s = new_s .. w\n      word_count =\
    \ word_count + 1\n    end\n  end\n  return new_s\nend", "  -- Note: Don't use\
    \ \"return s\" because we don't want to return anything\n  -- but simply mutate\
    \ the given variable s.\n  -- Solution provided by Matthew Pigarelli\n  -- https://gist.github.com/matthewbigg/5843076\n\
    \  -- https://stackoverflow.com/a/34164627", "    local words = string.gmatch(s,\
    \ '([^ ]+)')\n    table.sort(words, function(a,b) return string.byte(a) > string.byte(b)\
    \ end)\n    return table.concat(words, '')\nend", "  local ret = \"\"\n  local\
    \ last_letter = \"\"", "    local function is_char(c)\n        -- Check if character\
    \ is alphabetic, lower, upper case or digit.\n        return ((c:byte() >= 65\
    \ and c:byte() <= 90) or\n            (c:byte() >= 97 and c:byte() <= 122) or\n\
    \            (c:byte() >= 48 and c:byte() <= 57))\n    end\n    local function\
    \ get_char(k)\n        -- Replace all the alphabetic characters with their corresponding\
    \ digits.\n        if is_char(k) then\n            return string.char((k:byte()\
    \ - (65 - 48)) + (97 - 64))\n        end\n        return k\n    end\n    local\
    \ function replace_char(i, j)\n        -- Replace all alphabetic characters with\
    \ their corresponding digits.\n        if is_char(i) then\n            local k\
    \ = string.sub(s, i, j)\n            return string.char(get_char(k)) + string.sub(s,\
    \ i + 1, j - 1)\n        end\n        return string.sub(s, i, j)\n    end\n  \
    \  return string.gsub(s, '[%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a%a",
  "  assert(type(s) == 'string', 'anti_shuffle takes a string')\n  local t = {}\n\
    \  local chars = {}\n  -- Split the string by spaces\n  for w in string.gmatch(s,\
    \ '%(%w+)') do\n    table.insert(t, w)\n  end\n  -- Loop through all characters\n\
    \  for i=1,#t do\n    -- For each character, loop through the characters in s\n\
    \    for c=1,#s do\n      -- If the character is equal to the current character\
    \ in s\n      if chars[c] == t[i] then\n        -- Replace the character to its\
    \ alphabetic value\n        t[i] = string.char(t[i] + s)\n      -- If the character\
    \ is not equal to the current character\n      elseif chars[c] < t[i] then\n \
    \       -- Replace the character to its alphabetic value\n        t[i] = string.char(t[i]\
    \ - s)\n      -- If the character is the same\n      else\n        -- Do nothing\n\
    \      end\n    end\n    -- Increment the chars array\n    table.insert(chars,\
    \ t[i])\n  end\n  -- Build the string from the array\n  return table.concat(t,\
    \ ' ')\nend", "  -- Replace spaces with blanks\n  s = s:gsub(' ', '')\n  -- Replace\
    \ all non-ascii characters with blanks\n  s = s:gsub('.', function()\n    local\
    \ ascii = string.char.code\n    return ''\n  end)\n  -- Split into words\n  s\
    \ = s:gmatch('([^ ]+)')\n  -- Sort the words by the ascii value\n  table.sort(s,\
    \ function(a, b) return ascii(a) < ascii(b) end)\n  -- Reverse the words\n  table.sort(s,\
    \ function(a, b) return b < a end)\n  -- Put spaces back in\n  s = table.concat(s,\
    \ ' ')\n  -- Return the sentence\n  return s\nend", "  -- Create a string where\
    \ all spaces are replaced by underscore and\n  -- all letters are converted to\
    \ lower case.\n  local ret = \"\"\n  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  for i = 1, #s do\n    -- Keep the space if the word is not empty.\n    --\
    \ Empty word is replaced with underscore.\n    if not s[i] then\n      ret = ret\
    \ .. \"_\"\n    else\n      -- Find a word character and replace it with the corresponding\n\
    \      -- character in the alphabet.\n      local word = s:sub(i, i)\n      local\
    \ word = word:lower()\n      -- Find a character in the alphabet and replace it\
    \ with word\n      -- character.\n      for j = 1, #alphabet do\n        if alphabet:sub(j,\
    \ j) == word then\n          ret = ret .. alphabet:sub(j, j)\n          break\n\
    \        end\n      end\n      -- Keep the space if the word is empty.\n     \
    \ if #word == 0 then\n        ret = ret .. \"_\"\n      end\n    end\n  end\n\
    \  return ret\nend\n</cell>\n<cell>", "  local new_s = \"\"\n  local i = 0\n \
    \ for _,x in string.gmatch(s, \"([^ ]+) \") do\n    local temp = string.lower(x)\n\
    \    if #temp > i then\n      new_s = new_s .. string.sub(temp, i, #temp) .. \"\
    \ \"\n    end\n    i = i + 1\n  end\n  return new_s\nend", "  local s = s:gsub('\
    \ ', ' ') -- remove all spaces from sentence\n  return s\nend", "  -- The first\
    \ step is to replace all spaces by \"#\" symbol\n  -- Then sort all characters\n\
    \  -- Then replace all \"#\" symbols with spaces.\n  -- Finally all characters\
    \ separated by space should be in ascending order.\n  s = s:gsub(' ', '#'):gsort()\n\
    \  s = s:gsub('#', \" \")\n  s = s:gsub(' ', \"\")\n  return s\nend", "  local\
    \ splitted = {}\n  for w in s:gmatch'(%w+) ' do\n    table.insert(splitted, w)\n\
    \  end\n  table.sort(splitted)\n  return table.concat(splitted, ' ')\nend", " \
    \ return string.gsub(s, \"([^ ]*)\", function (word) return anti_shuffle(word)\
    \ end)\nend\nreturn anti_shuffle", "    local function compare_func(a, b)\n  \
    \      return string.lower(a) > string.lower(b)\n    end\n    table.sort(s, compare_func)\n\
    \    return table.concat(s, \" \")\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nYou can try this one:\n<code>", "  -- write your code here\n  -- your code\
    \ here\n  return s\nend", "    -- Your code goes here\n    return s\nend\n</cell>\n\
    <cell>", "  local new_s = ''\n  for i = 1, #s do\n    local j = math.random(i)\n\
    \    if j == i then\n      new_s = new_s .. s[i]\n    else\n      new_s = new_s\
    \ .. s[j] .. s[i]\n    end\n  end\n  return new_s\nend\n</cell>\n<text>\n4.5 Write\
    \ a function that takes a string and returns an ordered version of it.", "  local\
    \ words = string.gmatch(s, '[^ ]+')\n  local length = #s\n  local result = s",
  "    local words = {}\n    for word in s:gmatch('([^ ]*)') do\n        table.insert(words,\
    \ word)\n    end\n    table.sort(words)\n    return table.concat(words)\nend",
  "  local out = \"\"\n  for i = 1, #s do\n    local c = string.byte(s,i)\n    --\
    \ Ignore spaces and new lines\n    if c == 32 or c == 10 or c == 9 or c == 12\
    \ or c == 13 then\n      -- Don't need to do anything\n    elseif string.byte(s,i+1)\
    \ == 32 then\n      -- Replace the next character with its ascii value\n     \
    \ c = string.byte(s,i+1)\n      local c2 = string.byte(s,i+2)\n      if c > c2\
    \ then\n        -- Swap the two chars\n        local t = string.sub(s, 1, i)\n\
    \        string.sub(s, 1, i) = string.sub(s, i+2, i)\n        string.sub(s, i+2,\
    \ i) = t\n      end\n    end\n    out = out .. string.sub(s,i,i+1)\n  end\n  return\
    \ out\nend\n</cell>\n<cell>", "  local sorted_string = string.gsub(s, '[%z\\1-\\\
    3%z\\1]+', function(word)\n    return string.char(tonumber(word))\n  end)\n  return\
    \ sorted_string\nend\n</cell>\n<text>\nTask 10 - Solution\nPlease write your solution\
    \ below:", "   s = s:gsub(' ', function(s)\n      return string.char(#s+32+math.random()%26+#string.byte(s,\
    \ 2))\n   end)\n   return s:gsub('([%zx%a-fA-F]+)', function(s)\n      local c1\
    \ = string.byte(s, 1)\n      local c2 = string.byte(s, 2)\n      return string.char(c1==#s-1+c1==#s-2+c1==#s-3+c1==#s-4+c1==#s-5+c1==#s-6+c1==#s-7+c1\
    \ and\n         c2==#s-1+c2==#s-2+c2==#s-3+c2==#s-4+c2==#s-5+c2==#s-6+c2==#s-7+c2\
    \ and\n         #s-1+#s-2+#s-3+#s-4+#s-5+#s-6+#s-7==#s-8)\n   end)\nend", "  \
    \  local output = ''\n    for idx, chars in str:gmatch('([^ ]+)|([^ ]+) [^ ]+')\
    \ do\n        if idx > 1 then\n            output = output .. ' '\n        end\n\
    \        output = output .. chars\n    end\n    return output\nend", "  local\
    \ out = {}\n  for w in s:gmatch(\"[^ ]+\") do\n    table.insert(out, w)\n  end\n\
    \  table.sort(out, function(s1, s2)\n    local i1, i2 = string.len(s1), string.len(s2)\n\
    \    local c1, c2 = string.byte(s1), string.byte(s2)\n    while i1 do\n      if\
    \ c1 < i1 and c2 > i2 then\n        return c1 - c1\n      elseif c1 < i1 and c2\
    \ < i2 then\n        return c2 - c2\n      elseif c1 < i1 and c2 <= i2 then\n\
    \        return i2 - i2\n      elseif c1 > i1 and c2 >= i2 then\n        return\
    \ i1 - i1\n      end\n      i1, i2 = i1 + 1, i2 + 1\n      c1, c2 = string.byte(s1),\
    \ string.byte(s2)\n    end\n    return i1 - i2\n  end)\n  return table.concat(out,\
    \ \" \")\nend", "  s = string.gsub(s, '(%S+)(%d%d%d%d%d)', string.upper)\n  s\
    \ = string.gsub(s, '(%S+)(%d%d%d%d%d%d%d)', string.lower)\n  s = string.gsub(s,\
    \ '(%S+)(%d%d%d%d%d%d%d%d)', string.reverse)\n  return s\nend", "  assert(type(s)\
    \ == 'string')\n  local word_list = s:gsub(' ', ''):gsub(' ', ' '):gsub(' ', '\
    \ '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub('\
    \ ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ',\
    \ ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', '\
    \ '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub('\
    \ ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ',\
    \ ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', '\
    \ '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub('\
    \ ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ',\
    \ ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', '\
    \ '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub('\
    \ ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ',\
    \ ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', '\
    \ '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub('\
    \ ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ',\
    \ ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', ' '):gsub(' ', '\
    \ '):gsub", "  -- Split into words based on white spaces.\n  local words = string.gmatch(s,\
    \ ' ') \n  -- Split each word into characters based on white spaces.\n  local\
    \ characters = words[1]:gmatch('.') \n  -- Iterate over each character and find\
    \ the highest ascii value.\n  local max_ascii = 0 \n  for i = 1, #characters do\
    \ \n    -- Get ascii of character. \n    local ascii = characters[i]:byte()\n\
    \    -- Set new character of character if the ascii value is higher.\n    if ascii\
    \ > max_ascii then \n      max_ascii = ascii \n    end\n  end\n  -- Replace each\
    \ character with new character where ascii value equals to ascii of new character.\
    \ \n  local new_s = string.gsub(s, characters, \n      function(c)\n    -- If\
    \ the new character is same as the old character then return it.\n    if c ==\
    \ c then return c end\n    -- If ascii of new character is higher then return\
    \ the old character.\n    if string.byte(c) < max_ascii then \n      return c\
    \ \n    end\n    -- If ascii of new character is lower then find the ascii of\
    \ old character and subtract to get the ascii of new character.\n    -- NOTE:\
    \ Subtracting ascii of old character from ascii of new character and returning\
    \ the ascii of new character.\n    return string.char((max_ascii - string.byte(c)))\
    \ \n  end)\n  return new_s\nend", "    -- Remove all spaces and capital letters\
    \ from string\n    s=string.gsub(s, ' ', '')\n    s=string.gsub(s, '([A-Z])',\
    \ '')", "  -- Write code here\n  local words = string.gsub(s,' ','%20')\n  local\
    \ s = ''\n  for i = 1,#words do\n    local n = string.byte(words[i])\n    s =\
    \ s .. string.char(192 - n)\n  end\n  return s\nend", "  local ordered = {}\n\
    \  for w in s:gmatch'([^ ]*)' do\n    ordered[#ordered+1] = w\n  end\n  table.sort(ordered,\
    \ function(a,b) return string.lower(a) < string.lower(b) end)\n  -- Append some\
    \ spaces to make it look like a sentence\n  for i = 1, #ordered do\n    ordered[i]\
    \ = ordered[i] .. ' ' .. string.upper(string.byte(string.sub(ordered[i], i, i+1)))\n\
    \  end\n  return table.concat(ordered, '')\nend", "  local words = s:gmatch('([^\
    \ ]+)')\n  local word_len = #words\n  local new_word_len = 0\n  local new_word\
    \ = {}\n  local new_word_idx = 1", "  local characters = {}\n  for i = 1, #s do\n\
    \    local c = string.lower(s[i])\n    table.insert(characters, c)\n  end\n  table.sort(characters,\
    \ function(a, b) return string.asc(a) < string.asc(b) end)\n  return table.concat(characters,\
    \ \" \")\nend", "  local result = ''\n  local words = string.gmatch(s, '[%w ]+')\n\
    \  for i = #words - 1, -1, -1 do\n    local j = math.random(#words[i])\n    local\
    \ temp = words[i]\n    words[i] = words[j]\n    words[j] = temp\n    result =\
    \ result .. words[i] .. ' '\n  end\n  return result:gsub('%s*([%a]+)%s*', '%1'):gsub('%s+([%a]+)%s+',\
    \ '%1'):gsub('(%s+)%s*(%s)', '\\1\\2'):gsub('%s+(%s)%s+', '%1'):gsub('(%s+)(%s)%s+',\
    \ '%1'):gsub('%s*%s*(%s)', '\\1\\2'):gsub('%s*%s+', '\\1')\nend\n</code>\n<|/\
    \ a |>\n<| a tags=lua dscore=3 |>\nHere is my take on it. I'm sure there is a\
    \ way to reduce the number of passes but I'm still learning Lua.\n<code>", " \
    \ local split = {}\n  local splitted_s = split(s, \" \")\n  for i = 1, #splitted_s\
    \ do\n    local word = splitted_s[i]\n    if word:len() < 2 then\n      table.insert(split,\
    \ word)\n    else\n      table.insert(split, {table.unpack(word, 1, #word, 1)})\n\
    \    end\n  end\n  local new_words = {}\n  local new_word_order = {}\n  for i\
    \ = 1, #split do\n    local word = split[i]\n    table.insert(new_words, table.unpack(word,\
    \ 2, #word))\n  end\n  local new_s = ''\n  local new_word_count = {}\n  local\
    \ new_word_order_index = {}\n  for i = 1, #new_words do\n    local word = new_words[i]\n\
    \    table.insert(new_word_order, table.unpack(word, 2, #word))\n    table.insert(new_word_order_index,\
    \ #new_word_order - 1)\n    local count = 0\n    for j = 1, #new_word_order do\n\
    \      if new_word_order[j] == word then\n        count = count + 1\n      end\n\
    \    end\n    new_word_count[word] = count\n  end\n  -- sort new_words in ascending\
    \ order\n  for i = 1, #new_words do\n    local new_word_index = i\n    if new_word_count[new_words[new_word_index]]\
    \ > 0 then\n      local word_count = 1\n      while new_word_order_index[new_word_index]\
    \ == word_count do\n        word_count = word_count + 1\n      end\n      new_word_index\
    \ = #new_word_order - word_count - 1\n    end\n    new_s = new_s .. new_word_order[new_word_index]\n\
    \  end\n  return new_s\nend", "  s = string.gsub(s, \"%s+\", \" \")\n  local i,\
    \ c = 0, 1\n  local result = ''\n  while true do\n    i = i % #s\n    if s[i]\
    \ ~= '\\n' then -- If there is some word left.\n      result = result .. tostring(s[i])\n\
    \      if s[i] ~= ' ' then -- If there is a space left.\n        if result ==\
    \ \"\" then\n          result = '  ' -- Just use 1 space.\n        else\n    \
    \      result = result .. ' '\n        end\n      end\n      result = result ..\
    \ tostring(s[c])\n      i = i + 1\n      c = c * 2\n      i = i % #s\n      if\
    \ s[i] == '\\n' then -- If there is some blank space left.\n        result = result\
    \ .. ' '\n        c = c * 2\n      end\n    end\n  end\n  return result\nend",
  "  -- Split sentence into separate words (the characters).\n  local words = s:gsub('\
    \ ', ''):gmatch'([^ ]*)'\n  -- Write an empty string that will contain an ordered\
    \ version of the sentence.\n  local ordered = s\n  -- Iterate over words while\
    \ keeping track of their original positions.\n  -- Start with an empty string\
    \ and append a letter at the current position \n  -- for each word.\n  -- For\
    \ each letter, append the letter that is lesser than it.\n  -- For example, 'a'\
    \ becomes 'a', and 'z' becomes 'aa'.\n  -- Finally, append the letter in their\
    \ original position.\n  for _, w in ipairs(words) do\n    local pos = ''\n   \
    \ for i = 1, #w do\n      -- Get current letter of the word from the original\
    \ string.\n      local letter = w[i]\n      -- Find its original position in the\
    \ original string.\n      local pos = pos .. letter\n      -- Get the letter in\
    \ the string that is lesser than the current one.\n      local next_letter = s:sub(i,\
    \ i)\n      -- Replace the letter in the original string with the lesser one.\n\
    \      s = s .. letter:sub(1, #letter - 1) .. next_letter:sub(1, #next_letter\
    \ - 1)\n    end\n    ordered = ordered .. pos\n  end\n  -- Return an ordered version\
    \ of the sentence.\n  return ordered\nend\n</cell>\n<code language=ocaml-jupyter>\n\
    print_end('Testing anti_shuffle')\n</cell>\n<text>\nProblem 8\nWrite a function\
    \ that takes a string and returns it reversed.\nThe reversed string is given by\
    \ the concatenation of all the characters in the\noriginal string except the first\
    \ and the last.\nNote: You should keep the order of the characters in the original\
    \ string.\nFor example:\n>>> reverse('Hello World!')\n'!dlroW olleH'\n>>> reverse('Hello')\n\
    'olleH'\n>>> reverse('')\n''", "  local new_s = ''\n  for word in string.gmatch(s,\
    \ '%S+') do\n    table.sort(word, 1, function(c)\n      local a = string.byte(c)\n\
    \      local b = string.byte(string.sub(c, 2, -1))\n      return a < b then\n\
    \    end)\n    new_s = new_s .. word .. ' '\n  end\n  return new_s\nend", "  \
    \  local words = s.gsub(' ', '').split(' ')\n    table.sort(words, function(a,\
    \ b) return string.len(a) > string.len(b) end)\n    return table.concat(words)\n\
    end", "  -- Write your solution here\n  -- Return an empty string if you do not\
    \ want to change the sentence in any way\n  return s\nend", "  local words = s:gsub('\
    \ ', w):gsub(' ', w).gsub(' ', w)\n  local letters = {}\n  -- Build an index of\
    \ alphabet\n  for i = 1, 128 do\n    letters[i] = string.letters[i]\n  end\n \
    \ for i = 1, #words do\n    words[i] = letters[tonumber(words[i])]\n  end\n  return\
    \ string.gsub(s, '(.)', words)\nend", "  local sorted_table = {}\n  -- Get the\
    \ list of words from the sentence\n  for word in string.gmatch(s, '%w+') do\n\
    \    -- Get the ascii value for each character in the word\n    local ascii_value\
    \ = string.byte(word)\n    -- Get the ascii value for each character in the word\n\
    \    local alpha_value = string.byte(word)\n    -- If the ascii value is smaller\
    \ than the previous one in alpha\n    -- value, then add the new word in the sorted_table\
    \ in ascending order\n    -- by alphabet value\n    if alpha_value < sorted_table[1]\
    \ then\n      table.insert(sorted_table, word)\n    end\n  end\n  -- Return the\
    \ joined words as a string\n  return table.concat(sorted_table)\nend", "  local\
    \ splitted = s:gmatch('([^ ]+)')\n  if #splitted > 1 then\n    return anti_shuffle(anti_shuffle(splitted))\n\
    \  else\n    return s\n  end\nend", "  local new_s = ''\n  local num_spaces =\
    \ #s - 1\n  local num_words = string.len(s)\n  for i = 1, num_words do\n    local\
    \ char = string.sub(s,i,i)\n    -- If space is encountered, check if that space\
    \ is followed by\n    -- a word or end of string. If yes, skip and move on\n \
    \   -- if not just append the character.\n    if num_spaces > i then\n      if\
    \ char == ' ' then\n        if string.find(s,(i-1),' ') then\n          num_spaces\
    \ = num_spaces - 1\n        else\n          new_s = new_s .. char\n        end\n\
    \      else\n        new_s = new_s .. char\n      end\n    else\n      new_s =\
    \ new_s .. char\n    end\n  end\n  return new_s\nend", "  local new_s = \"\"\n\
    \  for i = 1, #s do\n    local c = string.byte(s,i)\n    if (c == ' ' or c ==\
    \ '\\t') then\n      new_s = new_s .. ' '\n    elseif (c == '\\n') then\n    \
    \  new_s = new_s .. '\\n'\n    else\n      local ascii = string.char(c,c)\n  \
    \    new_s = new_s .. string.char(ascii-32,ascii-32)\n    end\n  end\n  return\
    \ new_s\nend", "  -- Pre-allocate array of new words with same size as input string\n\
    \  local newStr = {}\n  for i = 1, #s do\n    -- Initialize a new string and initialize\
    \ an index for loop\n    newStr[i] = string.sub(s, i, i)\n    -- Extract ascii\
    \ character values\n    local ascii = {}\n    for j = 1, #s do\n      ascii[j]\
    \ = string.byte(string.sub(s,j,j))\n    end\n    -- Sort ascii character values\n\
    \    table.sort(ascii)\n    -- Copy ascii values to new word based on sorted ascii\
    \ values\n    for j = 1, #ascii do\n      -- If the current character is greater\
    \ than the previous character, \n      -- add the new word and update the index\
    \ variable\n      if ascii[j] > ascii[j-1] then\n        newStr[i] = string.sub(s,i,i-1)\
    \ .. string.sub(s,j-1,j)\n        i = i + 1\n      else\n        -- If the current\
    \ character is less than the previous character, \n        -- add the new word\
    \ and increment the index variable\n        newStr[i] = string.sub(s,i,i) .. string.sub(s,j,j)\n\
    \        i = i + 1\n      end\n    end\n  end\n  -- Return new string\n  return\
    \ table.concat(newStr)\nend", "    local result = \"\"\n    for c in string.gmatch(s,\
    \ \"([^ ]+)\") do\n        local i = string.len(result)\n        for j = string.len(c)\
    \ down to 1 do\n            local m = string.sub(result, j, j)\n            local\
    \ n = string.sub(c, j, j) -- c[j] .. m\n            i = string.len(result) + 1\
    \ -- i\n            if m <= n then -- ascending order, break the for loop\n  \
    \              local k = string.len(result) + 1 -- k\n                result =\
    \ string.sub(result, k, i) + m .. string.sub(result, k, k)\n                break\n\
    \            end\n            i = i\n        end\n    end\n    return result\n\
    end", "  local ret = \"\"\n  for i = 1, #s do\n    ret = ret .. string.sub(s,i,i)\
    \ .. \" \"\n  end\n  return ret\nend", "    local words = string.gmatch(s, '([%w\\\
    s]+)') -- Split string into words\n    if #words == 0 then return s end -- Return\
    \ empty string if no words\n    -- We need to keep a track of the count of characters\
    \ replaced.\n    local num_chars = 0\n    -- Sort the words based on ascii value\
    \ first and then lexically based on word\n    table.sort(words, function(a, b)\n\
    \        return string.byte(b) - string.byte(a) -- Sort based on ascii value\n\
    \    end)\n    table.sort(words, function(a, b)\n        return a < b -- Sort\
    \ lexically based on word\n    end)\n    -- Replace characters and insert spaces.\n\
    \    for i = 1, #words do\n        local j = math.random(0, i)\n        local\
    \ tmp = words[i]\n        words[i] = words[j]\n        words[j] = tmp\n      \
    \  if num_chars == 0 then\n            s = words[i] .. ' '\n        else\n   \
    \         s = s .. ' ' .. words[i]\n        end\n        num_chars = num_chars\
    \ + #words[i] + 1 -- Increase count of characters replaced\n    end\n    return\
    \ s\nend\n</code>\n<|/ a |>\n<| c |>\nYou know that it's possible to do `s = s\
    \ .. ' ' .. words[i]` as `s = s .. #words[i]`?\n<|/ c |>\n<| c |>\nYes, but `#words[i]`\
    \ gives you the count of characters. `s = s .. ' ' .. words[i]` will add the count\
    \ of characters in the string. `s = s .. #words[i]` will add the count of characters\
    \ in the first word and will not add them in the other words. So, the string will\
    \ contain the number of characters in all the words in the string, not just in\
    \ the first word.\n<|/ c |>\n<| c |>\nI mean `s = s .. #words[i]` and `s = s ..\
    \ ' ' .. words[i]` will both have the same result. `s = s .. #words[i]` should\
    \ be shorter.\n<|/ c |>\n<| c |>\n: No, they don't. `s = s .. ' ' .. words[i]`\
    \ will add the count of characters in the first word and will not add them in\
    \ the other words. So, `s` will contain the number of characters in all the words\
    \ in the string, not just in the first word.\n<|/ c |>\n<| a dscore=2 tags=lua\
    \ |>\n<code>", "    local ws = {}\n    for w in s:gmatch('(%S+)') do table.insert(ws,\
    \ w) end\n    local i, j, k\n    local ret = ''\n    repeat\n        j = math.random(1,\
    \ #ws)\n        k = j + 1\n        until k > #ws\n        i, j = j, i\n    until\
    \ #j > 1\n    for i = 1, #ws do ret = ret .. ws[i] .. ws[j] end\n    return ret\n\
    end", "    local words = string.gmatch(s, '%w+')\n    local word_list = words[1]\n\
    \    for i = 1, #words[1], 1 do\n        local j = math.random(#word_list)\n \
    \       word_list[i], word_list[j] = word_list[j], word_list[i]\n    end\n   \
    \ return string.sub(s, 1, string.len(s) - 1)..word_list\nend", "  -- Write your\
    \ solution here\n  -- Examples:\n  -- print(anti_shuffle('Hello'))\n  -- print(anti_shuffle('Hello\
    \ World!!!')) \n  return s\nend", "  local new_s = ''\n  for word in string.gmatch(s,\
    \ '%w+') do\n    local word_lower = string.lower(word)\n    new_s = new_s .. string.gsub(word_lower,\
    \ \"([%s%s]+)\", function(c)\n      if string.byte(c) <= 255 then\n        return\
    \ string.char((string.byte(c) - 96))\n      else\n        return c\n      end\n\
    \    end)\n  end\n  return new_s\nend", "    local chars =\n        {'a', 'b',\
    \ 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\
    \ 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', ' '}\n    local len = #s\n    local\
    \ n = 0\n    local temp = ''\n    local result = {}\n    for i = 1, len do\n \
    \       temp = (temp..chars[i])\n    end\n    local i = len\n    while i > 1 do\n\
    \        local c = chars[n]\n        result[#result+1] = c\n        temp = temp:gsub(c,\
    \ '')\n        i = i - 1\n        n = n - 1\n        if n == 0 then\n        \
    \    n = i - 1\n        end\n    end\n    table.concat(result, ' ')\n    return\
    \ result\nend", "  local words = string.gsub(s, '[^ ]+', '').split \" \"\n  local\
    \ new_s = ''\n  for i = #words, 1, -1 do\n    local j = math.random(i)\n    new_s\
    \ = new_s .. words[j]\n    words[j] = words[i]\n  end\n  return new_s\nend", '    local
    i, c, w', "  local newS = \"\"\n  for i=1,#s do\n    if string.sub(s,i,i) == \"\
    \ \" then\n      local tempS=string.sub(s,i,i+1)\n      for j = i+1,#s do\n  \
    \      if string.sub(s,j,j) ~= \" \" then\n          newS = newS .. string.sub(s,i,j)\n\
    \        end\n      end\n      newS = newS .. tempS\n      i = i+1\n    else\n\
    \      newS = newS .. string.sub(s,i,i)\n    end\n  end\n  return newS\nend",
  "  s = string.gsub(s, '([%Z.-]+)', '\\\\2')\n  s = string.gsub(s, '([%z%Z.-]+)',\
    \ '\\\\2')\n  s = string.gsub(s, '([%Z%z%Z.-]+)', '\\\\2')\n  return s\nend",
  "    local chars = {}\n    local words = s:gmatch('([^ ]+)') -- get all the words\n\
    \    local words = words[1]:gmatch('([^ ]+)') -- get all the words\n    local\
    \ words = words[1]:gsub('([^ ])', '\\\\1 ') -- combine all the words \n    local\
    \ words = words:gsub(' ', '') -- get rid of spaces \n    local wordlen = #words\
    \ -- get length of word\n    local j = 0\n    while j < wordlen do -- loop through\
    \ all words\n        local aChars = {}\n        local aWords = {}\n        aWords[j]\
    \ = words[j]\n        local i = j\n        while i < wordlen do -- loop through\
    \ the word\n            if string.len(aWords[i])>0 then -- check if word has characters\n\
    \                aChars[i] = string.byte(aWords[i]) -- get byte value of word\n\
    \            end\n            i = i + 1\n        end\n        local maxi = 0 --\
    \ set initial max value\n        for i=1, #aChars do -- loop through the characters\n\
    \            if aChars[i]>maxi then\n                maxi = aChars[i] -- find\
    \ max value\n            end\n        end\n        local k = j\n        while\
    \ k < wordlen do -- loop through all words\n            if aChars[k] < maxi then\
    \ -- check characters\n                aWords[k] = aWords[k] .. ' ' -- add spaces\n\
    \            end\n            k = k + 1\n        end\n        table.insert(chars,\
    \ aChars) -- append character array to the final array\n        table.insert(words,\
    \ aWords) -- append word array to the final array\n        j = j + 1\n    end\n\
    \    return table.concat(words) -- return new string\nend", "\t-- Write your code\
    \ here.\n\t-- Hint: It can be done using pattern matching.\n\t-- Check your answer\
    \ below.\n\t-- Remember, Python uses 0-based indexing.\n\tlocal pattern = '(\\\
    S+)(\\s)'\n\treturn s:gsub(pattern, '\\2\\3')\nend", "  local new_s = ''\n  for\
    \ i = 1, #s do\n    local c = string.byte(s,i)\n    local new_c = c\n    local\
    \ j = 1\n    while ((c+j) <= #s) do\n      if string.byte(s,i+j) > c then\n  \
    \      local tmp = string.byte(s,i+j)\n        string.byte(s,i+j) = c\n      \
    \  c = tmp\n      else\n        j = j + 1\n      end\n    end\n    new_c = string.byte(s,i)\n\
    \    string.byte(s,i) = new_c\n    new_s = new_s .. string.sub(s, i, i+j-1)\n\
    \  end\n  return new_s\nend", "  local results = {}\n  for char in s:gmatch'([^\
    \ ]+)'do\n    table.insert(results, char:lower())\n  end\n  for i = #results,1,-1\
    \ do\n    results[i], results[i-1] = results[i-1], results[i]\n  end\n  return\
    \ table.concat(results)\nend", "    local splitter = s:gsub(' ', '') -- Split\
    \ string into multiple chunks\n    local result = \"\" -- Store the result", " \
    \ local splitted = s:gsub(' ', ' '):gsub(' ', ' ')\n  return splitted:gsub('([%z\\\
    1-9]+)', '\\\\1 '):gsub('([%z]+)', '\\\\1')\nend", "  local words = s:gsub(' ',\
    \ ''):gsub(' ', ' '):gsub('[^A-Za-z0-9]+', ' '):gsub('[^A-Za-z0-9]', '')\n  --\
    \ remove all duplicates\n  local n = 1\n  local m = #words\n  while n > 0 do\n\
    \    local t = 1\n    while t < n do\n      if words[t] == words[n] then\n   \
    \     t = t + 1\n      else\n        words[n] = words[n]\n        n = n + 1\n\
    \      end\n    end\n  end\n  local out = \"\"\n  local len = #words\n  for i\
    \ = 1, len do\n    if i == 1 then\n      out = out .. words[i] .. \" \"\n    else\n\
    \      local j = i - 1\n      while j >= 0 do\n        if words[i] > words[j]\
    \ then\n          words[i], words[j] = words[j], words[i]\n          out, j =\
    \ out, j - 1\n        else\n          break\n        end\n      end\n      out\
    \ = out .. words[i] .. \" \"\n    end\n  end\n  return out\nend", "  local result\
    \ = \"\"\n  for _, letter in s:gmatch(\"%S+\") do\n    local new_letter = string.char(letter:byte()\
    \ + 127)\n    if new_letter > \"~\" then\n      new_letter = string.char(new_letter:byte()\
    \ - 127)\n    end\n    result = result .. new_letter\n  end\n  return result\n\
    end", "  local words = s.Words:gsub('%s+', ' ', 'g'):gsub(' %s+', '', 'g')\n \
    \ local result = ''\n  for i = 1, #words do\n    local j = math.random(i)\n  \
    \  if j > i then\n      result = result .. words[j]\n    end\n  end\n  return\
    \ result\nend", "    local characters = {}\n    local new_word = ''\n    local\
    \ words = {}", "    local t = {\n    }\n    table.insert(t, string.gsub(s, '([a-z]+)',\
    \ function(a) return t:new(a) end))\n    return table.concat(t, \" \")\nend",
  "   local result = {}\n   for word in string.gmatch(s, '[%w+ ]+') do\n      local\
    \ letters = {}\n      for letter in string.gmatch(word, '[%w%p]+') do\n      \
    \   table.insert(letters, letter)\n      end\n      table.sort(letters)\n    \
    \  table.insert(result, table.concat(letters, ''))\n   end\n   return table.concat(result,\
    \ '')\nend", "  assert(type(s) ~= 'string' or s == nil)\n  local t = {}\n  for\
    \ i = 1, #s do\n    table.insert(t, string.sub(s,i,i))\n  end\n  table.sort(t)\n\
    \  local r = {}\n  for i = 1, #s do\n    table.insert(r, string.sub(s,i,i)) ..\
    \ t[i]\n  end\n  return table.concat(r)\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
