name: HumanEval_112_reverse_delete
language: lua
prompt: "-- Task\n-- We are given two strings s and c, you have to deleted all the\
  \ characters in s that are equal to any character in c\n-- then check if the result\
  \ string is palindrome.\n-- A string is called palindrome if it reads the same backward\
  \ as forward.\n-- You should return a table containing the result string and true/false\
  \ for the check.\n-- Example\n-- >>> reverse_delete('abcde', 'ae')\n-- {'bcd', false}\n\
  -- >>> reverse_delete('abcdef', 'b')\n-- {'acdef', false}\n-- >>> reverse_delete('abcdedcba',\
  \ 'ab')\n-- {'cdedc', true}\nlocal function reverse_delete(s, c)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = reverse_delete\n\
  \    lu.assertEquals(candidate('abcde', 'ae'), {'bcd', false})\n    lu.assertEquals(candidate('abcdef',\
  \ 'b'), {'acdef', false})\n    lu.assertEquals(candidate('abcdedcba', 'ab'), {'cdedc',\
  \ true})\n    lu.assertEquals(candidate('dwik', 'w'), {'dik', false})\n    lu.assertEquals(candidate('a',\
  \ 'a'), {'', true})\n    lu.assertEquals(candidate('abcdedcba', ''), {'abcdedcba',\
  \ true})\n    lu.assertEquals(candidate('abcdedcba', 'v'), {'abcdedcba', true})\n\
  \    lu.assertEquals(candidate('vabba', 'v'), {'abba', true})\n    lu.assertEquals(candidate('mamma',\
  \ 'mia'), {'', true})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  assert(type(s) == 'string' and type(c) == 'string')", "  local results\
    \ = {}\n  for i=1,#s do\n    if s[i] == c then results[i] = s:sub(i) end\n  end\n\
    \  if table.concat(results) = s then return results end\n  return results\nend",
  "\tlocal table = {}\n\tlocal index = 0\n\tlocal length = #s\n\tlocal newString =\
    \ \"\"\n\tlocal newTable = {}\n\tlocal newStringTemp = \"\"", "  local function\
    \ find(i)\n    local j\n    if s[i] == c[1] then\n      j = 1\n      while j <=\
    \ i do\n        if s[i+j] == c[2] then\n          j = j + 1\n        else\n  \
    \        return false\n        end\n      end\n      return true\n    else\n \
    \     j = i\n      while j <= #s - i do\n        if s[j+i] == c[2] then\n    \
    \      j = j + 1\n        else\n          return false\n        end\n      end\n\
    \      return true\n    end\n  end\n  local result = {}\n  local i = 0\n  while\
    \ i < #s do\n    if find(i) then\n      result[#result +1] = s[i]\n      i = i\
    \ + 1\n    end\n  end\n  return result\nend", "   -- If s is the empty string,\
    \ return an empty string and true.\n   if not s or s == c then\n      return {\
    \ s = \"\", result = true }\n   end", "\t-- Your code here\n\tlocal ans = {c,\
    \ false}\n\tfor i, ch in ipairs(s) do\n\t\tif ch == c then\n\t\t\tans[#ans + 1]\
    \ = c\n\t\tend\n\tend\n\treturn ans\nend", "  if c==\"\" then\n    return {'',\
    \ true}\n  end\n  local l={}\n  local l2={}\n  local result=\"\"\n  for i=1,#s\
    \ do\n    l[i]=true\n    if s[i]==c then\n      l2={}\n      for j=i,#s do\n \
    \       if l[j] and s[j]~=c then\n          table.insert(l2,j)\n        end\n\
    \      end\n      if #l2==1 then\n        l2[1]=false\n      end\n      for j=1,#l2\
    \ do\n        table.insert(l, l2[j])\n      end\n    end\n    table.insert(result,s[i])\n\
    \  end\n  if #result==1 then\n    table.insert(result, false)\n  end\n  return\
    \ { result, false }\nend", "  -- base cases\n  if #s < 1 or #c < 1 then return\
    \ {{}, false} end\n  if s[1] ~= c then return {{}, false} end", "   -- Create\
    \ a table for storing the result\n   local result = {}", "  if #s <= 1 then return\
    \ {s, true} end\n  local t = {}\n  for i = #s - 1 do\n    local p = s[i]\n   \
    \ for j = 1, #c do\n      if p == c[j] then\n        t... = p\n        break\n\
    \      end\n    end\n  end\n  local result = table.concat(t)\n  if #result ==\
    \ #s then\n    return {result, true}\n  else\n    return {result, false}\n  end\n\
    end", "    local results = {}\n    local str = \"\"\n    local isPalindrome =\
    \ true\n    for i,c in ipairs(s) do\n        str = str .. c\n    end\n    for\
    \ i,c in ipairs(c) do\n        if str == s:reverse() then\n            results[i]\
    \ = str:reverse()\n            str = str:reverse()\n            isPalindrome =\
    \ false\n        end\n    end\n    results[#results] = str:reverse()\n    return\
    \ results,isPalindrome\nend", "  local result = {}\n  local i, j, k, start, length,\
    \ flag = 1, #s, 0, false\n  while i < j do\n    local current = s[i]\n    local\
    \ char = s[i - 1]\n    if char == current then\n      k = k - 1\n      i = i -\
    \ 1\n      if k == 0 then\n        result[i - 1] = current\n        flag = true\n\
    \      else\n        flag = false\n        break\n      end\n    else\n      k\
    \ = k + 1\n      j = j - 1\n      result[i - 1] = current\n      i = 1\n    end\n\
    \  end\n  return result, flag\nend", "\tc = c\n\t\t:gsub('(.)', function(e)\n\t\
    \t\tif c then\n\t\t\t\tif e == c then\n\t\t\t\t\tc = nil\n\t\t\t\telse\n\t\t\t\
    \t\tc = c .. e\n\t\t\t\tend\n\t\t\tend\n\t\tend)\n\t\t:gsub('%{%d+}', function(x)\n\
    \t\t\tif x then\n\t\t\t\tx = tostring(x) + x\n\t\t\tend\n\t\tend)\n\t\t:gsub('(%{%d+})',\
    \ '%2')\n\t\t:gsub('%{%d+}', '\\\\%2')\n\t\n\tif c then\n\t\tc = c\n\t\t\t:gsub('%2',\
    \ function()\n\t\t\t\treturn string.sub(string.len(s) - string.len(c:reverse())\
    \ + 1, 1)\n\t\t\tend)\n\t\t\t:gsub('\\\\%2', '%{%d+}')\n\telse\n\t\tc = s:reverse()\n\
    \tend", "\tlocal reverse = { }\n\tlocal reverse_index = 1\n\trepeat\n\t\treverse[reverse_index]\
    \ = s[reverse_index]\n\t\treverse_index = reverse_index + 1\n\tuntil reverse_index\
    \ <= #s\n\tfor index = reverse_index - 1, reverse_index - 1, -1 do\n\t\tif reverse[index]\
    \ == c\n\t\t\tthen\n\t\t\tbreak\n\t\telse\n\t\t\treverse[index] = reverse[reverse_index]\n\
    \t\tend\n\tend\n\tif reverse_index == #s\n\t\tthen\n\t\treturn { reverse, true\
    \ }\n\telse\n\t\treturn { reverse, false }\n\tend\nend", "  -- O(n) time\n  local\
    \ t = {}\n  for i = #s, 1, -1 do\n    table.insert(t, string.sub(s, i, i))\n \
    \ end\n  -- O(n) time and O(n) space\n  for i = #s, 1, -1 do\n    if s[i] ~= c\
    \ then\n      t[#t + 1] = s[i]\n    end\n  end\n  -- O(n) time and O(1) space\n\
    \  local j = 1\n  for i = #t, 1, -1 do\n    if t[j] ~= t[i] then\n      j = 1\n\
    \    else\n      j = j + 1\n    end\n  end\n  table.insert(t, nil)\n  local p\n\
    \  -- O(n) time and O(1) space\n  for i = #t, 1, -1 do\n    if p == nil then\n\
    \      p = t[i]\n    else\n      if t[i] ~= p then\n        table.insert(t, nil)\n\
    \        -- O(n) time and O(1) space\n        return\n      else\n        p =\
    \ nil\n      end\n    end\n  end\n  table.insert(t, nil)\n  -- O(n) time and O(1)\
    \ space\n  local isPalindrome = true\n  for i = #t, 1, -1 do\n    if t[i] ~= nil\
    \ then\n      isPalindrome = false\n    end\n  end\n  return { result, isPalindrome\
    \ }\nend", "    local t = {}\n    for i = 1, #s do\n        if s[i] == c then\n\
    \            t[#t + 1] = s[i]\n        end\n    end\n    if #t == 0 then\n   \
    \     return {s, true}\n    else\n        return {t[#t], false}\n    end\nend",
  "    local t = {}\n    for i, v in pairs(s) do\n        local ok = true\n      \
    \  for _, c in pairs(c) do\n            if v == c then\n                ok = false\n\
    \                break\n            end\n        end\n        if ok then\n   \
    \         t[i] = v\n        end\n    end\n    table.sort(t)\n    table.sort(t)\n\
    \    local last = t[#t]\n    for i = #t, 1, -1 do\n        if t[i] ~= last then\n\
    \            return { t[i], false }\n        end\n    end\n    return { t[1],\
    \ true }\nend", "  -- The reverse of a string is the same string but in reverse.\n\
    \  return s:gsub(c, function(x) return reverse(x, c) end)\nend", "  -- We don't\
    \ need to search for the character 'c' since it won't be equal to anything in\
    \ the string.\n  -- We only need to check for equality, because we delete everything\
    \ in the string before we check anything.\n  -- Therefore, we start at the last\
    \ character in the string and work backwards.\n  -- When we hit a character that\
    \ isn't equal to c, we delete everything before the character and check if it's\
    \ equal to c.\n  -- If it's not, the character is deleted.\n  -- If it is, it's\
    \ deleted, and the loop continues.\n  -- Therefore, if we hit the beginning or\
    \ end of the string, then the string is not a palindrome.\n  local result = {}\n\
    \  local i = 0\n  for i = #s - 1, i, -1 do\n    -- If we hit the beginning or\
    \ end of the string, then the string is not a palindrome.\n    if not s[i] then\n\
    \      result[#result + 1] = false\n      break\n    end\n    -- If we find that\
    \ the character in the string is not equal to c, then we keep deleting everything\
    \ before that character.\n    if s[i] ~= c then\n      result[i] = s[i]\n    else\n\
    \      -- We don't want to delete the character itself.\n      result[i] = nil\n\
    \    end\n  end\n  return result\nend", "  local res = {}\n  for i = 1, #s do\n\
    \    if s[i] == c then\n      table.insert(res, s[i])\n    elseif s[i] ~= c then\n\
    \      table.insert(res, string.rep(s[i], #s))\n    end\n  end\n  if #res == 0\
    \ then\n    return {c, true}\n  elseif #res == 1 then\n    return {table.concat(res,\
    \ \"\"), false}\n  end\n  table.insert(res, table.concat(res[#res], \"\"))\n \
    \ return res\nend", "  local p = {}\n  for i = 1, #s - 1 do\n    if string.sub(s,i,i)\
    \ == c then\n      p[#p + 1] = string.sub(s,i,i)\n      i = i + 1\n    end\n \
    \ end\n  table.sort(p)\n  if #p == 0 then\n    return {s, false}\n  end\n  local\
    \ r = {s[#p + 1], true}\n  table.insert(p, #p - 1)\n  while #p > 1 do\n    local\
    \ nxt = table.unpack(p,1,#p)\n    if string.sub(r[1],1,#nxt) == nxt then\n   \
    \   table.insert(p, nxt + 1)\n    end\n  end\n  return r\nend", "  local t = {}\n\
    \  for i = 1, #s - 1 do\n    if s[i] == c then\n      if t[#t+1] == s[i] then\
    \ t[#t+1] = nil end\n    else\n      t[#t+1] = s[i]\n    end\n  end\n  if #t >\
    \ 0 and t[#t] == s[#s] then\n    return t, 'true'\n  else\n    return t, 'false'\n\
    \  end\nend", "  local results = {}\n  local last_char = s[#s]\n  local index\
    \ = 1\n  while index <= #s do\n    if s[index] == last_char then\n      last_char\
    \ = s[(index - 1) + (#s) - 1]\n      index = index + 1\n    elseif index > 1 then\n\
    \      results[#results + 1] = s[index - 1]\n      results[#results + 1] = s[index\
    \ - 2]\n      results[#results + 1] = s[index]\n    end\n  end\n  results[#results\
    \ + 1] = s[index]\n  results[#results + 1] = last_char\n  return results\nend",
  "   local str = {}\n   for i = 1, #s do\n      if s[i] == c then\n         table.insert(str,\
    \ s[i])\n      else\n         table.insert(str, s[i])\n      end\n   end\n   return\
    \ { table.concat(str, \"\"), true }\nend", "  local i\n  local l\n  local result\
    \ = {}\n  l = 0\n  i = #s\n  while i > 0 do\n    i = i - 1\n    if s[i] ~= c then\n\
    \      result[#result + 1] = s[i]\n      l = l + 1\n    end\n  end\n  result[l]\
    \ = '\\0'\n  if l == 0 then\n    return result\n  end\n  l = l - 1\n  result[#result\
    \ + 1] = '\\0'\n  if l == 0 then\n    return result\n  end\n  return result\n\
    end", "   -- If the string is empty, then we know it is not a palindrome\n   if\
    \ #s == 0 then return {}, false end\n   -- If the last character of the string\
    \ is equal to our target character, then we know the string is a palindrome\n\
    \   if s[#s-1] == c then return { s .. '', true } end\n   -- Create an empty temporary\
    \ string with the first character and append it to the temporary string\n   local\
    \ temp_string = s\n   temp_string = temp_string .. c\n   -- For each character\
    \ after the last character in the string\n   for i = #s-2 to 1 do\n      -- If\
    \ the character in the temporary string is a palindrome, then we know it is not\
    \ a palindrome\n      if temp_string:sub(i) == reverse_delete(temp_string, c:reverse())\
    \ then\n         return { temp_string, false }\n      end\n   end\n   return {\
    \ temp_string, false }\nend", "  if s == nil then return end\n  local result =\
    \ {}\n  local pos = 0\n  local deleted = false\n  local deleted_size = #c\n  if\
    \ c == \"\\0\" then\n    deleted = true\n  end\n  while pos ~= #s do\n    local\
    \ chr = s[pos]\n    if chr == c then\n      pos = pos + 1\n      if not deleted\
    \ then\n        table.insert(result, chr)\n      end\n      if #result < deleted_size\
    \ then\n        deleted = false\n      end\n    else\n      if deleted then\n\
    \        deleted = false\n      else\n        pos = pos - 1\n      end\n    end\n\
    \  end\n  if deleted then\n    table.insert(result, s[#s])\n  end\n  return result\n\
    end", "    if #s < 1 then return { s, false } end\n    local i, i1, result\n \
    \   i, i1 = 1, #s\n    while i < i1 do\n        result = not i\n        if s:sub(i,\
    \ i) == c then\n            result = result and false\n        end\n        i\
    \ = i + 1\n        if i < i1 then result = result and true end\n    end\n    return\
    \ { s:sub(1, i), result }\nend", "    -- Create a table to store the result.\n\
    \    local ans = {}\n    -- Create a counter to store how many character is deleted.\n\
    \    local c = 0\n    -- For every character in string.\n    for ch in string.gmatch(s,\
    \ '%a') do\n        -- If the character is equal to any character in c.\n    \
    \    if ch == c then\n            -- Increment the counter by one.\n         \
    \   c = c + 1\n        else\n            -- If the character is not equal to any\
    \ character in c, delete the character in s and add it into ans.\n           \
    \ s = string.rep(s, 1, c - 1)\n            ans[#ans + 1] = ch\n            --Increment\
    \ the counter.\n            c = 1\n        end\n    end\n    -- Return the table.\n\
    \    return ans\nend", "  local result = {}\n  local i = 0\n  while i <= #s do\n\
    \    local j = 0\n    while j <= #c do\n      if s[i]:sub(i, i) == c[j]:sub(j,\
    \ j) then\n        result[#result+1] = s[i]:sub(i, i)\n      else\n        j =\
    \ j + 1\n      end\n    end\n    i = i + 1\n  end\n  if result[#result] == s[#s]\
    \ then\n    return { reverse(result), true }\n  else\n    return { reverse(result),\
    \ false }\n  end\nend", "    local result = {s=s, deleted={}}\n    for i,c in\
    \ ipairs(s) do\n        table.insert(result.deleted, c)\n    end\n    local len\
    \ = #s\n    if len > 0 then\n        local i = 0\n        while i < len do\n \
    \           if s[i] == c then\n                len = len - 1\n            else\n\
    \                i = i + 1\n            end\n        end\n    end\n    if len\
    \ > 0 then\n        result.s = result.s .. result.deleted\n    end\n    return\
    \ result\nend", "   local l = {}\n   for i = 1, #s do\n      if s[i] == c then\
    \ table.insert(l, s[i]) else table.insert(l, '') end\n   end\n   local rv = table.concat(l)\n\
    \   if s == rv then\n      return {'', true}\n   else\n      return {'', false}\n\
    \   end\nend", "  local r = {}\n  for i = 1, #s do\n    local j = i - 1\n    while\
    \ j ~= 0 and string.sub(s,i,j) == string.sub(s,j,i) do\n      j = j - 1\n    end\n\
    \    if string.sub(s,i,i) == c then\n      table.insert(r, string.sub(s,i,i))\n\
    \    end\n  end\n  if #r == 0 and string.sub(s,1,1) == string.sub(s,#s,1) then\n\
    \    return {'', false}\n  end\n  return {'{'..table.concat(r,''..','..'}'), true}\n\
    end", "\t-- check if the character exist\n\tif c==nil then\n\t\treturn s\n\telse\n\
    \t\t-- the string to delete\n\t\tlocal s=s\n\t\t-- The character to delete\n\t\
    \tlocal c=c\n\t\t-- The string to check\n\t\tlocal s=s\n\t\t-- The character to\
    \ check\n\t\tlocal c=c\n\t\t-- The result string\n\t\tlocal s=s\n\t\t-- The character\
    \ to delete\n\t\tlocal c=c\n\t\t-- The result string\n\t\tlocal s=s\n\t\t-- The\
    \ character to delete\n\t\tlocal c=c\n\t\t-- The result string\n\t\tlocal s=s\n\
    \t\t-- The character to delete\n\t\tlocal c=c\n\t\t-- The result string\n\t\t\
    local s=s\n\t\t-- The character to delete\n\t\tlocal c=c\n\t\t-- The result string\n\
    \t\tlocal s=s\n\t\t-- The character to delete\n\t\tlocal c=c\n\t\t-- The result\
    \ string\n\t\tlocal s=s\n\t\t-- The character to delete\n\t\tlocal c=c\n\t\t--\
    \ The result string\n\t\tlocal s=s\n\t\t-- The character to delete\n\t\tlocal\
    \ c=c\n\t\t-- The result string\n\t\tlocal s=s\n\t\t-- The character to delete\n\
    \t\tlocal c=c\n\t\t-- The result string\n\t\tlocal s=s\n\t\t-- The character to\
    \ delete\n\t\tlocal c=c\n\t\t-- The result string\n\t\tlocal s=s\n\t\t-- The character\
    \ to delete\n\t\tlocal c=c\n\t\t-- The result string\n\t\tlocal s=s\n\t\t-- The\
    \ character to delete\n\t\tlocal c=c\n\t\t-- The result string\n\t\tlocal s=s\n\
    \t\t-- The character to delete\n\t\tlocal c=c\n\t\t-- The result string\n\t\t\
    local s=s\n\t\t-- The character to delete\n\t\tlocal c=c\n\t\t-- The result string\n\
    \t\tlocal s=s\n\t\t-- The character to delete\n\t\tlocal c=c\n\t\t-- The result\
    \ string\n\t\tlocal s=s\n\t\t-- The character to delete\n\t\tlocal c=c\n\t\t--\
    \ The result string\n\t\tlocal s=s\n\t\t-- The character to delete\n\t\tlocal\
    \ c=c\n\t\t-- The result string\n\t\tlocal s=s\n\t\t-- The character to delete\n\
    \t\tlocal c=c\n\t\t-- The result string\n\t\tlocal s=s\n\t\t-- The character to\
    \ delete\n\t\tlocal c=c\n\t\t-- The result string\n\t\tlocal s=s\n\t\t-- The character\
    \ to delete\n\t\tlocal c=c\n\t\t-- The result string\n\t\tlocal s=s", "  local\
    \ reverse = {[false] = true, [1] = true, [2] = true, [3] = true}\n  local result\
    \ = {s, false}\n  local i = 0\n  for i = 1, #s - #c + 1 do\n    local j = i -\
    \ 1\n    if reverse[string.sub(s, i, j)] == true then\n      reverse[string.sub(s,\
    \ j, i)] = false\n      result[#result+1] = string.sub(s, j, i)\n    end\n  end\n\
    \  return result\nend", "  local res={}\n  local pos\n  local last\n  for pos=1,#s\
    \ do\n    local current=sub(s, pos-1, pos)\n    if current == c then\n      last=pos-1\n\
    \    elseif current ~= c then\n      if last ~= nil then\n        res[last]=current\n\
    \        last=nil\n      else\n        res[#res+1]=current\n      end\n    end\n\
    \  end\n  if last ~= nil then\n    res[last]=c\n  end\n  return res\nend", " \
    \ local t = {}\n  local i = 0\n  while true do\n    if s[i] ~= c then\n      t[#t\
    \ + 1] = s[i]\n    end\n    i = i + 1\n    if i == #s then break end\n  end\n\
    \  if #t == 0 then\n    return { s, false }\n  end\n  table.sort(t, function(x,\
    \ y)\n    return x ~= y\n  end)\n  local reversed = {}\n  i = 0\n  while i < #t\
    \ do\n    reversed[#reversed + 1] = t[i]\n    i = i + 1\n  end\n  return { reversed,\
    \ true }\nend", "  local table = {}\n  local reversed = {}\n  -- check for c\n\
    \  table.insert(reversed, s[#s])\n  if #s < 1 then return table, true end\n  for\
    \ i = #s, 1, -1 do\n    if s[i] == c then\n      table.insert(reversed, s[i])\n\
    \    else\n      table.insert(reversed, s[i])\n    end\n  end\n  table.insert(table,\
    \ s[#s])\n  return reverse_delete_recursive(s, c, table), true\nend", "\t-- We\
    \ are just going to reverse the string.\n\ts = string.gsub(s, '[' .. c .. ']',\
    \ '')\n\treturn s\nend", "\tif c == '' then\n\t\treturn { s, false }\n\tend",
  "\t-- start with the empty string\n\tlocal out = {}\n\t-- first check if s contains\
    \ c\n\tif string.sub(s, 1, #c + 1) ~= c then\n\t\treturn out, false\n\tend\n\t\
    -- delete all c characters in s\n\tfor i = 1, #s do\n\t\tif string.sub(s, i, i)\
    \ ~= c then\n\t\t\t-- append the rest of the string\n\t\t\ttable.insert(out, string.sub(s,\
    \ 1, i - 1))\n\t\tend\n\tend\n\t-- check if the new string is the same backwards\
    \ as forward\n\t-- if it is, the string is palindrome\n\t-- if not, the string\
    \ is reversed backwards\n\tlocal reversed = out:reverse()\n\tlocal result\n\t\
    if reversed == s then\n\t\t-- reverse the whole string backwards\n\t\tresult =\
    \ out:reverse()\n\telse\n\t\t-- reverse only the characters before and after c\n\
    \t\t-- reverse the whole string\n\t\tresult = out:reverse():sub(1, #out - #out\
    \ + 1):reverse()\n\tend\n\treturn result, true\nend", '   if #c > #s then return
    {s, false} end', "    local result = {}\n    local start = 0\n    local end =\
    \ 0\n    local i = 1\n    while i <= #s and #s > 0 do\n        if s[i] == c then\n\
    \            table.insert(result, s[i])\n            i = i + 1\n        else\n\
    \            i = i + 1\n        end\n    end", "  -- Check for empty string.\n\
    \  if s == '' then return {''} end\n  -- Check for one character string.\n  if\
    \ #s == 1 then return {s} end\n  -- Make a copy of the original string.\n  local\
    \ reverse = s:reverse()\n  -- Get the index of the character to be deleted.\n\
    \  local index = reverse == s and 1 or #reverse + 1\n  -- Get the remaining string.\n\
    \  local result = reverse:sub(0, index-1)\n  -- Check whether the string is palindrome.\n\
    \  if result == s then return {result, true} end\n  -- Check if the string is\
    \ a palindrome.\n  local tail = reverse:sub(-index-1)\n  if tail == s then return\
    \ {result, true} end\n  -- Check if the string is not palindrome.\n  local tailReverse\
    \ = tail:reverse()\n  if tailReverse == s then return {result, false} end\n  --\
    \ Check if the string is a palindrome for both halves.\n  local tailTail = tailReverse:sub(-index-1)\n\
    \  if tailTail == s then return {result, true} end\n  -- If the string is not\
    \ a palindrome, but contains only one character, check if the string is palindrome.\n\
    \  if #tail == 1 then return {tail, false} end\n  -- If the string is not a palindrome\
    \ and contains two characters, check if it is a palindrome for the first half\n\
    \  -- or the last half.\n  if #tail == 2 and tail:sub(1, 1) == tail:sub((#tail-1),\
    \ 1)\n  then return {tail:sub(1, (#tail-1)), false} end\n  -- If the string is\
    \ not a palindrome and contains three or more characters, check if the string\
    \ is palindrome.\n  if #tail > 3 then return {tail, false} end\n  -- If the string\
    \ is not a palindrome, return error.\n  error('String is not a palindrome for\
    \ both halves.')\nend", "  -- first we count the occurence for each character\
    \ in the string\n  local count_table = {}\n  for i=1, #s do\n    table.insert(count_table,\
    \ s[i])\n  end\n  for i=1, #c do\n    table.insert(count_table, c[i])\n  end",
  "\ts = s:lower()\n\tc = c or ''\n\tlocal res = {}\n\tfor i = 1, #s do\n\t\tres[#res+1]\
    \ = s\n\tend\n\tlocal lens = #res\n\ttable.sort(res)\n\tlocal j = 1\n\twhile j<=lens\
    \ do\n\t\tif res[j] == c then\n\t\t\tj = j+1\n\t\telse\n\t\t\tres[j:lens]=nil\n\
    \t\t\tj=1\n\t\t\tlens=lens-1\n\t\tend\n\tend\n\t--j=1 while j<=lens do -- this\
    \ was used but breaks the loop\n\t--\tif res[j] == c then\n\t--\t\tj = j+1\n\t\
    --\telse\n\t--\t\tres[j:lens]=nil\n\t--\t\tj=1\n\t--\t\tlens=lens-1\n\t--\tend\n\
    \t--end\n\tif j==lens then\n\t\treturn {table.concat(res, \"\"), true}\n\telse\n\
    \t\treturn {table.concat(res, \"\"), false}\n\tend\nend", "\t-- Time Complexity:\
    \ O(n), where n = length of s\n\t-- Space Complexity: O(1)\n\tlocal result = {}\n\
    \tlocal is_palindrome = false\n\t-- The outer loop will be running until either\
    \ s is empty, or c is empty\n\t-- So the inner loop will run until we either get\
    \ to an empty string or the end of c\n\t-- We are checking if each character is\
    \ equal to its index position in c and if so\n\t-- we append the character to\
    \ the resultant string and set the flag to true.\n\tfor i = 1, #s do\n\t\tif s[i]\
    \ == c[i] then\n\t\t\ttable.insert(result, s[i])\n\t\t\tis_palindrome = true\n\
    \t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\treturn { result = table.concat(result),\
    \ is_palindrome = is_palindrome }\nend", "\t-- Keep track of the number of characters\
    \ deleted.\n\t-- If this number is greater than the total number of\n\t-- characters\
    \ in the string, then it is obviously a palindrome.\n\t-- In that case, return\
    \ the string.\n\tlocal deletions = 0\n\t-- The string we are checking.\n\tlocal\
    \ check = \"\"\n\t-- Keep track of the characters in the current string and whether\
    \ they are equal to a character\n\t-- in the current string we are checking.\n\
    \tlocal cur, check_eq = false\n\t-- Keep track of the current characters in the\
    \ string we are checking\n\tlocal cur_string = \"\"\n\t-- The current string we\
    \ are checking\n\tlocal check_string = \"\"\n\t-- The length of s\n\tlocal s_len\
    \ = #s\n\t-- Iterate over all of the characters in s\n\tfor i = 1, s_len do\n\t\
    \t-- Add the character to the current string we are checking.\n\t\tcheck_string\
    \ = check_string .. s[i]\n\t\t-- If this is equal to the character we are checking,\
    \ add it to the current string we are checking.\n\t\tcheck_eq = check_eq or  (s[i]\
    \ == c)\n\t\t-- If this character is equal to the character we are checking, add\
    \ the current string we are checking to the\n\t\t-- current string we are checking.\n\
    \t\tif s[i] == c and check_eq then\n\t\t\tcheck_string = check_string .. check_string\n\
    \t\telseif s[i] == c then\n\t\t\t-- If we reach the end of the string, add the\
    \ characters to the current string we are checking.\n\t\t\tif i == s_len-1 then\n\
    \t\t\t\tcheck_string = check_string .. check_string\n\t\t\tend\n\t\tend\n\tend\n\
    \t-- If the number of characters in the current string we are checking is equal\
    \ to the length of s, we are a palindrome.\n\tif #check_string == s_len then\n\
    \t\t-- Add the current string we are checking to the check string.\n\t\tcheck\
    \ = check .. check_string\n\t\t-- If the number of characters deleted is equal\
    \ to the total number of characters in the string, we are\n\t\t-- a palindrome.\n\
    \t\tif deletions == s_len then\n\t\t\treturn check, false\n\t\telse\n\t\t\treturn\
    \ check, true\n\t\tend\n\tend\n\t-- If we have not reached the end of the string,\
    \ increment the number of deletions.\n\t-- If the number of characters deleted\
    \ is equal to the total number of characters in the string, we are\n\t-- a palindrome.\n\
    \tif check_string ~= \"\" then\n\t\tdeletions = deletions + 1\n\tend\n\t-- If\
    \ the number of characters deleted is greater than the total number of characters\
    \ in the string, we are\n\t-- not yet at a palindrome.\n\tif deletions > s_len\
    \ then\n\t\treturn \"\", false\n\tend\n\t-- Keep track of the number of characters\
    \ that are equal to the current character\n\t-- in the current string we are check",
  "   if #s == 0 then\n      return {}\n   elseif #c > #s then\n      return {s, false}\n\
    \   else\n      local lt = {}\n      for i = #s, 1, -1 do\n         lt[i] = string.reverse(s[i-1:i])\n\
    \      end\n      local rt = reverse_delete(lt[#lt], c)\n      if rt[#rt] ~= ''\
    \ then\n         local t = rt.reverse()\n         t[#t] = 'true'\n         return\
    \ {rt, t}\n      else\n         return {s, false}\n      end\n   end\nend", "\t\
    -- check if the string is palindrome\n\tlocal ret={}\n\tfor i,v in ipairs(s) do\n\
    \t\tif v==c then\n\t\t\t-- delete character and check if its palindrome\n\t\t\t\
    ret[i]=table.remove(s, i)\n\t\t\tlocal pal_str=\"\"\n\t\t\tfor i2,v2 in ipairs(ret)\
    \ do\n\t\t\t\tpal_str=pal_str..v2\n\t\t\tend\n\t\t\tif pal_str==ret[#ret] then\n\
    \t\t\t\tret[#ret]=nil\n\t\t\t\treturn ret\n\t\t\tend\n\t\tend\n\tend\n\t-- if\
    \ palindrome is not palindrome, return false\n\treturn ret\nend", "  -- Your code\
    \ here\nend", "  -- Base case\n  if #s == 0 then\n    return {s, true}\n  end\n\
    \  -- Base cases\n  if c == s[#s] then\n    return reverse_delete(s[#s]..'', c)\n\
    \  end\n  -- Deleting the character at the last position\n  -- We are at the last\
    \ position\n  local tail = s[#s]:sub(1,#s-1)\n  -- Deleting the character to remove\n\
    \  -- The character is at the first position\n  local head = s:sub(1,1)\n  --\
    \ We have found a palindrome\n  -- The tail is equal to head\n  -- We are at the\
    \ end of the string\n  if head == tail then\n    return reverse_delete(s[#s-1]..'',\
    \ c..head)\n  else\n    -- Reverse the string and delete it\n    local new_s =\
    \ reverse(s):sub(1,#s-1) .. new_c\n    return reverse_delete(new_s, new_c)\n \
    \ end\nend", "  local results = {}\n  local index = #s\n  while index > 0 do\n\
    \    local c = string.sub(s, index-1, index)\n    results[#results + 1] = string.sub(s,\
    \ index, index)\n    index = index - 1\n  end\n  table.sort(results)\n  local\
    \ i = #results - 1\n  while i ~= 0 do\n    if string.sub(results[i], #results[i]\
    \ - 1, #results[i]) == c then\n      table.remove(results, i)\n    end\n    i\
    \ = i - 1\n  end\n  return results\nend", "\t-- base case\n\tif s == nil then\n\
    \t\treturn {s, false}\n\tend\n\t-- check if the first char is equal to c\n\tif\
    \ s ~= c then\n\t\tlocal _, rev, rev_len = reverse_delete(s, c)\n\t\treturn {rev,\
    \ true}\n\tend\n\t-- delete the character if equal\n\tlocal _, s, rest_len = reverse_delete(s[1:],\
    \ c)\n\treturn {s, true}\nend", "   -- Reverse string and compare\n   local str_new\
    \ = s:reverse()\n   if str_new == s then\n      return {}, true\n   end\n   --\
    \ Remove all characters from str_new that are not equal to c\n   for i = 1, str_new:len()\
    \ do\n      if str_new:sub(i, i) == c then\n         str_new = str_new:sub(0,\
    \ i-1):sub(i+1)\n         break\n      end\n   end\n   if str_new:len() > 0 then\n\
    \      return { str_new, false }, true\n   else\n      return {}, false\n   end\n\
    end", "\tlocal result\n\tlocal flag", "\tlocal start\n\tif #s < 2 then\n\t\treturn\
    \ {s, true}\n\telse\n\t\tstart = 1\n\tend", "  local ans = s\n  local deleted\
    \ = { }\n  for i = 1, #s do\n    if s[i] = c then\n      table.insert(deleted,\
    \ i)\n    end\n  end\n  if #deleted > 0 then\n    local result = reverse_delete(table.concat(deleted,\
    \ 1), c)\n    table.insert(ans, result[1], result[2])\n  end\n  return { ans,\
    \ #ans == #s }\nend", "    if c == '' then return {s, false} end\n    local result\
    \ = reverse_delete(s, '')\n    local start = 1\n    for i = #c, 1, -1 do\n   \
    \     if s[i:sub(1,i)] == c then\n            start = start + i\n        end\n\
    \    end\n    local stop = #s - 1\n    if start > stop then\n        result[#result\
    \ + 1] = ''\n        return nil\n    end\n    result[#result + 1] = s[start:stop]\n\
    \    return result\nend", "  -- We are given two strings s and c, you have to\
    \ deleted all the characters in s that are equal to any character in c\n  -- then\
    \ check if the result string is palindrome.\n  -- A string is called palindrome\
    \ if it reads the same backward as forward.\n  -- You should return a table containing\
    \ the result string and true/false for the check.\n  -- Example\n  -- >>> reverse_delete('abcde',\
    \ 'ae')\n  -- {'bcd', false}\n  -- >>> reverse_delete('abcdef', 'b')\n  -- {'acdef',\
    \ false}\n  -- >>> reverse_delete('abcdedcba', 'ab')\n  -- {'cdedc', true}", " \
    \  local l=#s\n   local r=#s\n   while l<=r\n      if s[l] == c then\n       \
    \  s[l]=nil\n         r=r-1\n      else\n         l=l-1\n      end\n   end\n \
    \  return s\nend", "    if #s == 0 then\n        table.insert(result, false)\n\
    \    elseif #c < 0 then\n        table.insert(result, false)\n    elseif #s >\
    \ #c then\n        table.insert(result, false)\n    else\n        if s[#s] ~=\
    \ c then\n            table.insert(result, false)\n        else\n            local\
    \ new_s = string.copy(s)\n            local pos = 1\n            while pos < #s\
    \ do\n                if s[pos] == c then\n                    table.insert(result,\
    \ string.copy(new_s, 1, pos - 1))\n                    table.insert(result, string.copy(new_s,\
    \ pos + 1, #new_s))\n                else\n                    pos = pos + 1\n\
    \                end\n            end\n        end\n    end\n    return { result\
    \ = result,\n             palindrome = #result == 0,\n         }\nend", "\tlocal\
    \ reversed = { }\n\tfor i=1, #s do\n\t\tlocal pos = 1\n\t\twhile pos < #c and\
    \ s[i] ~= c[pos] do\n\t\t\tpos = pos + 1\n\t\tend\n\t\ttable.insert(reversed,\
    \ s[i])\n\tend", "  -- First check if there is a match at all\n  if c == \"0\"\
    \ then\n    -- Return false because there is no match to start with\n    return\
    \ false\n  end", "  if c then\n    return reverse_delete(s, c:byte()) == {s[c:byte()],\
    \ true}\n  else\n    local reverse = s:reverse()\n    local result = {}\n    for\
    \ i = #reverse, -1, -1 do\n      result[i] = reverse[i]\n    end\n    return table.concat(result)\
    \ == s and result\n  end\nend", "   assert(type(c) ~= 'string')\n   assert(type(''..\
    \ c .. '') == 'string')\n   assert(c == '' or c == nil or #c > 0)\n   local p\
    \ = ''\n   local result = {}\n   for c in s:gmatch('%S') do\n      p = p  .. c\n\
    \   end\n   if p == s then\n      table.insert(result, false)\n      return result\n\
    \   end\n   p = ''\n   local found = false\n   for c in s:gmatch('%S') do\n  \
    \    if not found and p == c then\n         table.insert(result, true)\n     \
    \    found = true\n      elseif found and p == c then\n         table.insert(result,\
    \ false)\n         found = false\n      else\n         p = p .. c\n      end\n\
    \   end\n   table.insert(result, found)\n   return result\nend", "   -- We need\
    \ an auxiliary function because we need to delete characters\n   -- from the string\
    \ we are checking\n   return function(t, k)\n      local result = s\n      for\
    \ i = 0, #t do\n         -- This loop is used to delete the character in the string\
    \ we are checking\n         -- from the string we are comparing to\n         if\
    \ t[i] == c then\n            k = k - 1\n         else\n            result = result\
    \ .. t[i]\n         end\n      end\n      return result, k == 0\n   end\nend",
  "  local results = {}\n  local is_palindrome = true\n  -- find all occurences of\
    \ c in s\n  for i = 1, #s do\n    if s[i] == c then\n      -- if we found c and\
    \ it's at the first occurence, add it to a result string and mark it a palindrome\n\
    \      local new_string = table.concat(s..(c):reverse())\n      table.insert(results,\
    \ new_string)\n      is_palindrome = true\n    else\n      -- if we didn't find\
    \ the current character, mark the result string as not palindrome\n      is_palindrome\
    \ = false\n    end\n  end\n  return { table.concat(results) , is_palindrome }\n\
    end", "\tlocal table = {s, c}\n\ttable.sort(function(a, b) return string.len(a)\
    \ < string.len(b) end)\n\ttable.insert(table, table.unpack(table.delete(s, c)))\n\
    \treturn table\nend", "  local function helper(s, c, result, i)\n    if i >= #s\
    \ then\n      if result then\n        return {result, true}\n      else\n    \
    \    return {result, false}\n      end\n    end\n    local result = false\n  \
    \  for j = i, #s do\n      if s[i] ~= c then\n        if s[i] ~= s[j] then\n \
    \         result = true\n          break\n        end\n      end\n    end\n  \
    \  if result then\n      helper(s, c, result, i + 1)\n    end\n  end\n  helper(s,\
    \ c, true, 0)\nend", "    local res = {}\n    for i = #s, 1, -1 do\n        if\
    \ s[i] == c then return nil, false end\n        table.insert(res, s[i])\n    end\n\
    \    return table.concat(res), true\nend", "   local res = {}\n   local is_palindrome\
    \ = true", "   if #s < 1 then\n      return { s = s, c = c }\n   end", "\tlocal\
    \ table = {}\n\tfor i = 1,#s,1 do\n\t\tif s[i] == c then\n\t\t\ttable[i] = table[i+1]\n\
    \t\t\ttable[i+1] = s[i]\n\t\tend\n\tend\n\tif table.len == #s then\n\t\ttable.len\
    \ = #s\n\t\treturn table, true\n\telse\n\t\treturn table, false\n\tend\nend",
  "\tassert(type(c) ~= 'table')\n\tassert(#s == #c)\n\tlocal result = {}\n\tlocal\
    \ i = 0\n\tlocal result = {}\n\tlocal j = #s\n\twhile i <= j do\n\t\tif s[i] ==\
    \ c[i] then\n\t\t\ttable.insert(result, s[i])\n\t\t\ti = i + 1\n\t\telse\n\t\t\
    \tj = j - 1\n\t\tend\n\tend\n\ttable.insert(result, s[#s])\n\tlocal bool = true\n\
    \tlocal i = 0\n\tlocal j = #s\n\twhile i <= j do\n\t\tif s[i] != c[i] then\n\t\
    \t\tbool = false\n\t\t\tbreak\n\t\tend\n\t\ti = i + 1\n\tend\n\tlocal bool = false\n\
    \treturn { result, reverse and bool }\nend", "\tlocal table = {}\n\tlocal c1 =\
    \ 1\n\tlocal c2 = 1\n\tlocal result = ''\n\twhile c1 ~= #s and c2 ~= 0 do\n\t\t\
    if s[c1] == c then\n\t\t\t-- Deleting character\n\t\t\tresult = result .. s[c1]\n\
    \t\t\tc2 = c2 + 1\n\t\telseif s[c2] ~= c then\n\t\t\t-- Not deleting character\n\
    \t\t\tc1 = c1 + 1\n\t\telse\n\t\t\t-- Deleting character\n\t\t\tresult = result\
    \ .. s[c1]\n\t\t\ttable.insert(table, reverse_delete(result, c))\n\t\t\ttable\
    \ = {}\n\t\t\tresult = result .. s[c1]\n\t\t\tc1 = c1 + 1\n\t\t\tc2 = c2 + 1\n\
    \t\tend\n\tend\n\tif #s > 0 and c2 ~= 0 then\n\t\ttable.insert(table, reverse_delete(result,\
    \ c))\n\tend\n\treturn result, #table > 0 and table[1] == true\nend", "    local\
    \ result = {}\n    if s == nil then\n        return result\n    end", "\tlocal\
    \ t = {}\n\tlocal last = 0\n\tfor i = 1, #s do\n\t\tlocal found = string.reverse(s:sub(last,\
    \ i)) == s\n\t\ttable.insert(t, s:sub(last, i or 1)) or last = i + 1\n\t\tif found\
    \ then\n\t\t\tif last == i then\n\t\t\t\tfound = false\n\t\t\tend\n\t\telse\n\t\
    \t\tlast = i\n\t\tend\n\t\tt[#t + 1] = found\n\tend\n\treturn t\nend", "  local\
    \ i, r, c, last, results = {}, {}, {}, {}, {}\n  for i = 1, #s do\n    last =\
    \ s[i]\n    for c = 1, #c do\n      r[#r+1] = last == c\n      last = last:sub(c)\n\
    \    end\n  end\n  for i = #r + 1, 1 do\n    results[#results+1] = r[i]\n  end\n\
    \  return results\nend", "  -- TODO: check for invalid input / invalid input length\n\
    \  -- TODO: check for repeated characters\n  assert(s:len() >= 1)\n  assert(c:len()\
    \ >= 1)\n  local ans = {s = {} or ''}\n  for i = #s, 1, -1 do\n    ans[#ans +\
    \ 1] = c\n    local k = i\n    if s:sub(1, i) ~= c:sub(1, i) then\n      k = k\
    \ + 1\n    end\n    ans[k] = s:sub(i, i)\n  end\n  return ans\nend", "  local\
    \ i = 0\n  local cs = c\n  local reverse = { }\n  while s[i] do\n    reverse[#reverse+1]\
    \ = s[i]\n    i = i + 1\n  end\n  reverse[#reverse+1] = '\\0'\n  i = #reverse",
  "  assert(s ~= nil, 's is nil')\n  assert(c ~= nil, 'c is nil')", "\t-- check if\
    \ any character in string is equal to any character in c\n\tlocal r = {s=s, c=c}\n\
    \tfor _, c in pairs(c) do\n\t\t-- loop through every character in string and check\
    \ if they are equal to any character in c\n\t\t-- if they are equal we will remove\
    \ them by replacing them with an empty string\n\t\tr.s = r.s:gsub(c, \"\")\n\t\
    end\n\treturn r\nend", "\tlocal reverse = {}\n\tfor c in s:gmatch(\"[%z^%Z]\"\
    ) do\n\t\treverse[c] = true\n\tend\n\tlocal p = s:find(c)\n\twhile p do\n\t\t\
    s[p] = nil\n\t\tp = s:find(c, p + 1)\n\tend\n\tlocal rev_s = reverse[s]\n\treturn\
    \ {s = rev_s, rev_s == s}   -- return original string\nend", "\t-- Base case:\
    \ if the string is empty, just return the empty string.\n\tif not s or not c then\n\
    \t\treturn {s, 'true'}", "    local t = {}\n    local result = true\n    for i\
    \ = 0, #s do\n        if s[i]:sub(1, #c) == c then\n            table.insert(t,\
    \ s[i])\n        else\n            result = false\n        end\n    end\n    if\
    \ result == true then\n        table.insert(t, s[#s])\n    end\n    return { result\
    \ = result, table = t }\nend", "\tlocal result = {}\n\tlocal start = 1\n\tlocal\
    \ i = 0\n\tlocal is_deleted = false\n\tlocal s = s:gsub(c) -- remove c from s\n\
    \twhile s do\n\t\ti = i + 1\n\t\tif start+i >= #s then -- we have removed all\
    \ the characters from s\n\t\t\ttable.insert(result, s[start]); -- add the remaining\
    \ to result\n\t\t\tif s == s[#s] then\n\t\t\t\tis_deleted = true\n\t\t\tend\n\t\
    \t\tbreak\n\t\tend\n\t\tif s[start] == s[i] then\n\t\t\tstart = start + 1\n\t\t\
    else\n\t\t\tis_deleted = true\n\t\tend\n\tend\n\treturn {'{'..table.concat(result,\
    \ \"\")..'}', is_deleted}\nend", "  if s == '' or c == '' then\n    return {}\n\
    \  end\n  local lenS = #s\n  local lenC = #c\n  local result = ''\n  local i =\
    \ 1\n  local reversed = {}\n  local last = ''\n  local index\n  while i <= lenS\
    \ do\n    index = (lenS - i) + 1 -- add 1 to end index to avoid index out of bound\n\
    \    last = c:sub(i, lenC)\n    local removed = s:sub(i, index)\n    if removed\
    \ ~= last then\n      result = result .. removed\n      reversed[removed] = true\n\
    \    end\n    i = i + 1\n  end\n  return { result = result, isPalindrome = #result\
    \ == lenC }\nend", "  -- Base case\n  if #s <= 0 then return {s, true} end", "\t\
    local result = {}\n\tlocal ok = true -- We need to check if s is palindrome\n\t\
    -- We will traverse the string from both end\n\tfor i=#s-1,1,-1 do\n\t\tif s[i]~=c\
    \ then\n\t\t\t-- The string is not palindrome or is not of right length, we are\
    \ done\n\t\t\tok = false\n\t\t\tbreak\n\t\tend\n\tend\n\tif ok then\n\t\t-- The\
    \ string can be made palindrome, now we just have to delete it\n\t\tlocal t =\
    \ {}\n\t\tfor i=#s,1,-1 do\n\t\t\ttable.insert(t, s[i])\n\t\tend\n\t\ttable.insert(result,\
    \ table.concat(t, \"\"))\n\tend\n\treturn { table.concat(result, \"\"), ok }\n\
    end", "\tlocal a = {}\n\tfor char in string.gmatch(s, '[^'..c..'a]+') do\n\t\t\
    a[#a+1] = char\n\tend\n\tlocal reverse = a[#a]\n\tfor i = #a, 1, -1 do\n\t\treverse\
    \ = reverse..a[i-1]\n\tend\n\treturn reverse, a==reverse\nend\nreturn reverse_delete",
  "  if #s ~= 0 then\n    local rev_s = reverse(s)\n    if rev_s == s then\n     \
    \ return {s, false}\n    end\n  else\n    return {s, true}\n  end\n  local result\
    \ = {s, false}\n  for i = 1, #c do\n    if s[i]:find(c[i]) == 1 then\n      if\
    \ result[1] == s then\n        result[2] = true\n      else\n        result[2]\
    \ = false\n      end\n      -- break\n    end\n  end\n  -- print(result)\n  return\
    \ result\nend", "  s = string.gsub(s, \"%c\", c)\n  local new_s = s\n  local is_reverse\
    \ = s:reverse():find(c) == nil\n  s = s:gsub(\"%c\", \"\")\n  if s == new_s then\n\
    \    return { new_s, is_reverse }\n  else\n    return reverse_delete(new_s, c)\n\
    \  end\nend", "\tlocal function helper(s, c)\n\t\tlocal a = {}\n\t\tlocal r =\
    \ \"\"\n\t\tfor i = 1, #s do\n\t\t\tif s[i] == c then\n\t\t\t\tr = r..s[i]\n\t\
    \t\telse\n\t\t\t\ta[#a+1] = s[i]\n\t\t\tend\n\t\tend\n\t\treturn r, a\n\tend\n\
    \tlocal a, b = helper(s, c)\n\tlocal t = {}\n\tt[#t+1] = b[#b]\n\tt[#t+1] = a[#a]\n\
    \treturn t\nend", "\t-- Check base cases\n\tif s == c then return { s, true }\
    \ end\n\t-- Check base case\n\tif s == nil then return { nil, false } end\n\t\
    -- Check base case\n\tif c == nil then return { s, false } end\n\t-- Check if\
    \ s contains c\n\tlocal srev = reverse_delete(s, c)\n\t-- Check if the reverse\
    \ of s contains c\n\tlocal crev = reverse_delete(c, c) -- c = 'c'\n\t-- Check\
    \ if a is a prefix of b\n\tlocal a_rev = reverse_delete(s, srev[1]) -- s = 'as'\n\
    \t-- Check if b is a prefix of a\n\tlocal b_rev = reverse_delete(srev[1], s) --\
    \ s = 'as'\n\t-- Check if the reverse of a is a prefix of the reverse of b\n\t\
    local a_rev_rev = reverse_delete(srev[1], c) -- s = 'a'\n\t-- Check if the reverse\
    \ of b is a prefix of the reverse of a\n\tlocal b_rev_rev = reverse_delete(srev[1],\
    \ c) -- s = 'a'\n\t-- Check if a is a prefix of b\n\tlocal a_rev_rev_b_rev = reverse_delete(srev[1],\
    \ c) -- s = 'a'\n\t-- Check if b is a prefix of a\n\tlocal b_rev_rev_b_rev = reverse_delete(srev[1],\
    \ c) -- s = 'a'\n\t-- Check if a is a prefix of b\n\tlocal a_rev_rev_b_rev_b_rev\
    \ = reverse_delete(srev[1], c) -- s = 'a'\n\t-- Check if b is a prefix of a\n\t\
    local b_rev_rev_b_rev_b_rev = reverse_delete(srev[1], c) -- s = 'a'\n\t-- Check\
    \ if a is a prefix of b\n\tlocal a_rev_rev_b_rev_b_rev_b_rev_b_rev = reverse_delete(srev[1],\
    \ c) -- s = 'a'\n\t-- Check if b is a prefix of a\n\tlocal b_rev_rev_b_rev_b_rev_b_rev_b_rev\
    \ = reverse_delete(srev[1], c) -- s = 'a'\n\t-- Check if a is a prefix of b\n\t\
    local a_rev_rev_b_rev_b_rev_b_rev_b_rev_b_rev_rev = reverse_delete(srev[1], c)\
    \ -- s = 'a'\n\t-- Check if b is a prefix of a\n\tlocal b_rev_rev_b_rev_b_rev_b_rev_b_rev_b_rev_b_rev\
    \ = reverse_delete(srev[1], c) -- s = 'a'\n\t-- Check if a is a prefix of b\n\t\
    local a_rev_rev_b_rev_b_re", "    local news = ''\n    for i = 1, #s do\n    \
    \    if s[i] == c then\n            news = news .. s[i]\n        end\n    end\n\
    \    if news == s then\n        return { news, true }\n    else\n        return\
    \ { news, false }\n    end\nend", "  -- TODO: Implement this function\nend", " \
    \ local res, check = false\n  for i = 1, #s do\n    if s[i] == c then\n      res\
    \ = string.gsub(s, '^' .. i .. '$', '') -- remove first i\n      if res == s then\
    \ -- if the first i match to the last i return original string\n        return\
    \ { s, check }\n      elseif res == reverse then -- if i match to the first i\
    \ reverse the string\n        local new_s = string.gsub(s, '^' .. i .. '$', reverse)\
    \ -- replace with first i reverse\n        local new_check = check and check and\
    \ (not check or reverse ~= '' or reverse ~= new_s) -- return true if the reverse\
    \ is true\n        return { new_s, new_check }\n      else\n        -- otherwise\
    \ just remove the first i\n        local new_s = string.gsub(s, '^' .. i .. '$',\
    \ '')\n        local new_check = check and check and (not check or reverse ~=\
    \ '' or reverse ~= new_s)\n        return { new_s, new_check }\n      end\n  \
    \  end\n  end\n  return { res, check }\nend", "\tlocal ans = {} -- To store the\
    \ result string and whether the result is palindrome.\n\t\n\t-- Find the first\
    \ character (starting from right to left) which is not equal to c\n\tlocal i =\
    \ #s - 1\n\twhile i > 0 and s[i]:match(c) do\n\t\ti = i - 1\n\tend\n\t\n\t-- Iterate\
    \ from left to right in string, deleting each character when found equal to c\n\
    \tfor i = 1, #s do\n\t\tif s[i]:match(c) then\n\t\t\ts[i] = nil\n\t\tend\n\tend\n\
    \t\n\t-- Check if all characters are deleted from the string\n\tif #s - 1 == i\
    \ then\n\t\tans.result = s\n\t\tans.isPalindrome = true\n\telse\n\t\tans.result\
    \ = s\n\t\tans.isPalindrome = false\n\tend\n\treturn ans\nend", "    if not (type(s)\
    \ == 'string' and\n            type(c) == 'string') then\n        return nil,\
    \ false, false, false, false\n    end\n    local i, j = 0, #s\n    local result\
    \ = '', false\n    while i <= j do\n        if s[i] == c then\n            s =\
    \ s:sub(#c-1, #s)\n            j = i - 1\n        else\n            if s[i] >\
    \ c then\n                j = j - 1\n            else\n                i = i +\
    \ 1\n            end\n        end\n        if i == j then\n            result\
    \ = result .. s[i]\n        end\n    end\n    result = result:reverse()\n    if\
    \ result == s then\n        -- Palindrome\n        return result, true\n    else\n\
    \        -- Not Palindrome\n        return nil, false\n    end\nend", "    local\
    \ result = {}\n    local flag = true\n    for i=1, #s do\n        if s[i] == c\
    \ then\n            flag = false\n        end\n    end\n    if flag then\n   \
    \     for i=1, #s do\n            table.insert(result, s[i])\n        end\n  \
    \  end\n    return {result, flag}\nend", "  -- We need to reverse the string and\
    \ find all the characters that are in s to be deleted. Then we compare the result\
    \ string to the original string\n  -- If the result string is equal to the original\
    \ string, the string is palindrome. Otherwise not.\n  -- We could also start from\
    \ the other end if the characters being deleted are in the beginning or end\n\
    \  -- and the strings are equal.\n  local function reverse(s, start, end)\n  \
    \  local ret = ''\n    for i = start, end do\n      ret = ret .. s[i - 1]\n  \
    \  end\n    return ret\n  end", "  if #s < 1 or #c < 1 then return {\"\", false}\
    \ end\n  local start, end = 1, #s-1\n  while start < end do\n    if s[start] ==\
    \ c[1] then\n      start = start + 1\n    else\n      if s[start] == c[2] then\n\
    \        start = start + 2\n      else\n        start = start + 1\n      end\n\
    \    end\n  end\n  if s[start] == c[1] then return {s[start+1], true} else return\
    \ {s[start], false} end\nend", "\t-- If s has only one character, return it.\n\
    \tif #s < 1 then return {}, true\n\tend\n\t\n\t-- If c has only one character,\
    \ return it.\n\tif #c < 1 then return {}, true\n\tend\n\t\n\t-- Check s.\n\tlocal\
    \ result = {}\n\tfor i = #s - 1, 1, -1 do\n\t\ttable.insert(result, s[i])\n\t\t\
    if s[i] == c[1] then\n\t\t\ttable.remove(s, i)\n\t\t\tbreak\n\t\tend\n\tend\n\t\
    \n\t-- Check c again.\n\tif #s > 0 then\n\t\tfor i = #c, 1, -1 do\n\t\t\tif s[i]\
    \ ~= c[1] then\n\t\t\t\ttable.remove(s, i)\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\
    \tend\n\t\n\t-- If s has only 1 character, return it.\n\tif #s > 1 then\n\t\t\
    return {}, false\n\tend\n\t\n\treturn result, true\nend", "\tassert(type(s) ==\
    \ 'string')\n\tassert(type(c) == 'string')\n\tlocal result\n\tlocal i = #s\n\t\
    while i >= 1 do\n\t\tif s[i] == c then\n\t\t\ti = i - 1\n\t\telse\n\t\t\tresult\
    \ = result .. s[i]\n\t\t\ti = i - 1\n\t\tend\n\tend\n\tif i == 0 then\n\t\tresult\
    \ = '' -- To avoid 'nil' result\n\tend\n\treturn { result, i == 0 }\nend", " \
    \  -- The algorithm is pretty simple: start from the end, and swap with the one\
    \ you find first\n   local t = {}\n   local i = 0\n   -- swap the element at the\
    \ end of t with the one at the beginning\n   while i < #s do\n      if s[i] ~=\
    \ c then\n         table.insert(t, s[i])\n      end\n      i = i + 1\n   end\n\
    \   -- Now check that we ended up with the correct string\n   if i ~= #s then\n\
    \      -- This means that our string ended up being longer than the original string\
    \ - not possible\n      -- The reason for this is that when we reach the end,\
    \ we are missing some characters, so we can't\n      -- reverse them without losing\
    \ at least 1 character.\n      table.insert(t, s[i])\n   end\n   -- Now we have\
    \ to reverse the string\n   table.sort(t)\n   -- We should now have found the\
    \ correct string to delete\n   -- The loop should be done backwards, because we\
    \ started with the last element\n   -- The loop should be done backwards, because\
    \ we started with the last element\n   local r = {}\n   local i = #t\n   while\
    \ i > 0 do\n      table.insert(r, t[i])\n      i = i - 1\n   end\n   -- return\
    \ the string and true/false for the check\n   return r, true\nend", "  if #s <\
    \ #c then\n    if s ~= string.reverse(string.gsub(c, 1, s)) then\n      return\
    \ {'', false}\n    else\n      local reversed = reverse_delete(string.reverse(s),\
    \ c)\n      if not reversed then\n        return {'', false}\n      else\n   \
    \     return { reversed, true }\n      end\n    end\n  else\n    return { s, true\
    \ }\n  end\nend", "  -- base case\n  assert(not c or s:match('(.-?)' .. c .. '(.-?)'))\n\
    \  if #s == 0 then return { s, true } else return { s, false }\n  -- recursive\
    \ case\n  local rest = reverse_delete(s:sub(1, #s - 1), c:sub(1, #c))\n  if rest[1]\
    \ == rest[2] then return { rest[1], false } else return { rest[1], true }\nend",
  "  assert(#c ~= 0, \"c must be a string and have at least one character\")\n  local\
    \ result = {}\n  for i = #s - 1, 1, -1 do\n    if s[i] == c then\n      table.remove(s,\
    \ i)\n      if #s == 0 then\n        table.insert(result, s)\n      end\n    end\n\
    \  end\n  if #s == 0 then\n    table.insert(result, s)\n  end\n  return result\n\
    end", "  -- base case\n  if #s < 1 then return {'', true} end", "\tlocal is_palindrome\
    \ = {}\n\tfor i = 1, #s do\n\t\tif s[i] ~= c then\n\t\t\t-- if s[i] ~= c then\n\
    \t\t\t\tis_palindrome[#is_palindrome+1] = s[i]\n\t\t\t-- end\n\t\telse\n\t\t\t\
    -- if s[i] == c then\n\t\t\t\t-- for each index in reverse of s\n\t\t\t\t\tfor\
    \ j = #s-1-i, 1, -1 do\n\t\t\t\t\t\tif s[j] ~= c then\n\t\t\t\t\t\t\tis_palindrome[#is_palindrome+1]\
    \ = s[j]\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t-- end\n\t\t\t\t-- break\n\t\
    \t\t-- end\n\t\tend\n\tend\n\treturn is_palindrome, is_palindrome:reverse() ~=\
    \ is_palindrome\nend", "    local t = {}\n    for i = 1, #s do\n        if s[i]\
    \ == c then\n            table.insert(t, s:sub(1, i))\n        end\n    end\n\
    \    return t, #t == #s or #s == 0\nend\n</cell>\n<text>\nExercise\nWrite a function\
    \ that deletes all the characters in s that are equal to any character in c from\
    \ the middle of the string. Then, check if the result string is palindrome. Print\
    \ the result string and true/false to the console.", "    local result = {}\n\
    \    local i = 1\n    local j = 1\n    while i <= #s do\n        if s[i]:sub(1,\
    \ 1) ~= c then\n            result[j] = s[i]\n            i = i + 1\n        \
    \    j = j + 1\n        else\n            i = i + 1\n        end\n    end\n  \
    \  result[j] = s[i]\n    result[1] = result[1]:sub(2)\n    return { result, true\
    \ }\nend", "\tlocal n = 0\n\twhile n <= #s - 1 do\n\t\tlocal c = s[n]\n\t\tn =\
    \ n + 1\n\t\tfor i = #c , 1, -1 do\n\t\t\tif c == c[i] then\n\t\t\t\ts[n] = c\n\
    \t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend", "  local results = {}\n  local i =\
    \ 0\n  while i < #s do\n    local index = #s + 1\n    local char = s[i]\n    while\
    \ index > 0 and s[index] == char do\n      index = index - 1\n    end\n    index\
    \ = index + 1\n    if index < #c then\n      local ok = true\n      for j = #c\
    \ + 1, #s do\n        if index == j then\n          ok = false\n        end\n\
    \      end\n      if ok then\n        results[i] = results[i] .. c[j]\n      end\n\
    \    end\n    i = i + 1\n  end\n  return table.concat(results)\nend", "  local\
    \ function remove_char(c)\n    return s:sub(1, #s)..c\n  end\n  local function\
    \ compare_c(c)\n    return c == reverse_delete(remove_char(c), c:reverse())\n\
    \  end\n  local function compare(s)\n    return s:sub(1, #s) == s:reverse()\n\
    \  end\n  local result = {}\n  for i = 1, #s do\n    for j = 1, #c do\n      if\
    \ compare_c(c[j]) then\n        if compare(remove_char(c[j])) then\n         \
    \ table.insert(result, remove_char(c[j]))\n        end\n      end\n    end\n \
    \ end\n  return result\nend", "    local res, ans = false, false\n    local _s\
    \ = s\n    local _s = string.reverse(_s)\n    local _char = c\n    local function\
    \ check()\n        if _s == _char then\n            if ans then\n            \
    \    res = true\n            else\n                res = false\n            end\n\
    \        end\n    end\n    check()\n    check()\n    check()\n    check()\n  \
    \  check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n    check()\n    check()\n    check()\n    check()\n    check()\n\
    \    check()\n", "  local result = {}\n  local start = #s\n  local i = start -\
    \ 1\n  while i > 0 do\n    local char = s[i]\n    if char == c then\n      i =\
    \ i - 1\n      if i <= 0 then\n        result[#result+1] = s:sub(1, start-1)\n\
    \        result[#result+1] = true\n      else\n        start = i - 1\n      end\n\
    \    else\n      result[#result+1] = char\n    end\n  end\n  result[#result+1]\
    \ = s:sub(1, start-1)\n  result[#result+1] = false\n  return result\nend", " \
    \ local news = {}\n  for i = 1, #s do\n    local c = s:sub(i, i)\n    if c ==\
    \ c then news[#news+1] = c end\n  end\n  if #news == 0 or news[#news-1] == c then\
    \ return {'', true} end\n  local result = ''\n  local first = true\n  for i =\
    \ 1, #news do\n    if first then\n      result = result .. news[i]\n      first\
    \ = false\n    else\n      result = result .. c\n    end\n  end\n  return { result\
    \ = result, false = false }\nend", "    local i, j = 0, 0\n    local result =\
    \ {}\n    while i <= #s and j <= #c do\n        if s[i] == c[j] then\n       \
    \     i = i + 1\n            j = j + 1\n        else\n            result[#result\
    \ + 1] = s[i]\n        end\n    end\n    if i == #s then\n        result[#result\
    \ + 1] = s[i]\n    end\n    if i == #c then\n        result[#result + 1] = c[j]\n\
    \    end\n    return { result = table.concat(result), check = s == table.concat(result)\
    \ }\nend", "  -- Check for empty string.\n  if #s == 0 then return {s, true} end",
  "  -- Reverse the string\n  local reverse = \"\"\n  for i=#s, 1, -1 do\n    reverse\
    \ = reverse .. s:sub(i, i)\n  end", "  -- We use a table to store the result\n\
    \  local result = {}\n  local cindex = 1\n  -- We need to store the current char\
    \ in order to\n  -- avoid deleting it later if it was equal to c\n  local current_char\
    \ = s[1]\n  while cindex <= #s do\n    -- If this char is equal to the current\
    \ char\n    -- in s then we need to remove it from the string\n    if s[cindex]\
    \ == current_char then\n      -- Then we delete the character\n      table.insert(result,\
    \ s[cindex])\n      -- And advance the index\n      cindex = cindex + 1\n    else\n\
    \      -- Otherwise we copy the current char and we advance\n      -- index\n\
    \      local new_char = current_char\n      table.insert(result, new_char)\n \
    \     cindex = cindex + 1\n      -- And we update the current char\n      current_char\
    \ = s[cindex]\n    end\n  end\n  -- Finally, we check if the string is equal to\
    \ its reverse\n  -- order or not\n  if table[#result] == s[#result] then\n   \
    \ result.is_palindrome = false\n  else\n    result.is_palindrome = true\n  end\n\
    \  -- Return the result\n  return result\nend", "  local result\n  local slen\n\
    \  slen = #s\n  repeat\n    if slen > 0 then\n      local t = #result[#result]\n\
    \      t = (t == #s and t) or t - 1 -- reverse\n      table.insert(result, s)\n\
    \      s = t\n    end\n    if #s == 0 then\n      result = {}\n      break\n \
    \   end\n    local i = 1\n    local c = c\n    while i <= #c do\n      if s[i]\
    \ != c[i] then\n        break\n      end\n      i = i + 1\n    end\n    if i ==\
    \ #c then\n      result = {}\n      break\n    end\n    i = i - 1\n  until i >=\
    \ 1\n  if #result == 1 and string.len(result[#result]) == slen then\n    result\
    \ = {}\n  end\n  return result, string.len(result) == slen\nend", "  if c == nil\
    \ then\n    error(\"Can't delete from an empty string\")\n  end\n  if #s ~= 1\
    \ then\n    return s\n  elseif s == c then\n    return s, true\n  else\n    local\
    \ t = reverse_delete(s:sub(1,#s), reverse_delete(s:sub(#s,#s), c))\n    if t[1]\
    \ and t[2] then\n      return t\n    else\n      return nil\n    end\n  end\n\
    end", "  -- We will remove characters that are equal to c in s\n  -- And check\
    \ if s is equal to s reversed\n  -- For example s = 'abcde' and c = 'a' so s will\
    \ become 'bcde'\n  -- We will have to remove 'bcde' from s to get the result\n\
    \  local result = {s, false}\n  for i = 1, #s do\n    if s[i] == c then\n    \
    \  result.s = result.s .. s:sub(i, i - 1)\n      result.c = true\n    end\n  end\n\
    \  -- We will check if result is palindrome or not\n  return result\nend", " \
    \ assert(type(s) == 'string' and type(c) == 'string', 'reverse_delete(): s must\
    \ be string')\n  assert(#s < 2 and #c > 1, 'reverse_delete(): s must have more\
    \ or equal 2 chars and c must have more than 1 char')\n  local lc = #c\n  local\
    \ result = {}\n  local index\n  for i = 1, #s do\n    if s[i] == c then\n    \
    \  index = i + 1\n      while index < #s and s[index] == c do\n        index =\
    \ index + 1\n      end\n      result[index] = s[i]\n      if index + 1 == #s then\
    \ break end\n      result[index + 1] = s[#s]\n    end\n  end\n  if #result ==\
    \ 0 then return result end\n  for i = #result - 1, 1, -1 do\n    if result[i]\
    \ ~= result[i + 1] then\n      return result\n    end\n  end\n  return nil, false\n\
    end", "  -- Find the length of s\n  local l1 = 1\n  local l2 = 1\n  while true\
    \ do\n    l1 = l1 + 1\n    l2 = l2 + 1\n    if l2 == #s then\n      if s == \"\
    \" then\n        return { \"\", true }\n      end\n      break\n    end\n    local\
    \ t1 = s:sub(l1,l2)\n    local t2 = c:sub(l1,l2)\n    if t1 == t2 then\n     \
    \ l2 = l2 + 1\n      l1 = l1 + 1\n    else\n      break\n    end\n  end", "\t\
    if #s == 0 then\n\t\treturn {s, 'true'}\n\telse\n\t\tlocal r = {s, false}\n\t\t\
    for i = #c, 0, -1 do\n\t\t\tif not r[i] then\n\t\t\t\tr[i] = s[#s-i-1]\n\t\t\t\
    \tbreak\n\t\t\tend\n\t\tend\n\t\twhile #r > 1 do\n\t\t\tr[r] = false\n\t\t\tr\
    \ = reverse_delete(r[1], c)\n\t\tend\n\t\treturn r\n\tend\nend", "    local t\
    \ = {}\n    for i = #s, 1, -1 do\n        if s[i] ~= c then\n            t[#t\
    \ + 1] = s[i]\n        else\n            local last = t[#t]\n            if last\
    \ == s then\n                return t\n            else\n                return\
    \ {last, true}\n            end\n        end\n    end\nend", "  local result =\
    \ '', true\n  for _,c in pairs(s) do\n    if c == c then\n      result = result\
    \ .. c\n    else\n      result = result .. c\n      break\n    end\n  end\n  return\
    \ { result, result == reverse }\nend", "  local i, j = #s, 0\n  while i > 0 do\n\
    \    if s[i] == c then\n      i = i - 1\n      j = j + 1\n    else\n      i--\n\
    \    end\n  end\n  if i == 0 and j == j then\n    return { s, true }\n  else\n\
    \    return { s, false }\n  end\nend", "  local result = {}\n  local is_palindrome\
    \ = true\n  for i = 1, #s do\n    if s[i] == c then\n      table.insert(result,\
    \ s[i])\n    else\n      is_palindrome = false\n    end\n  end", "    local p\
    \ = {}\n    for i = #s, 1, -1 do\n        if s[i] == c then\n            s[i]\
    \ = #s\n        end\n        if s[i] == #s then\n            table.insert(p, s)\n\
    \        end\n    end\n    return p, #s == #p and p == s\nend", "  local ans =\
    \ {s=s, palindrome=true}\n  local i, j = #s, 0\n  while i < j do\n    if s[i]\
    \ == c\n      or s[i]:sub(1,1) ~= c\n      or s[i]:sub(#s-1) == c\n      or s[i]\
    \ == c:sub(1,1)\n    then\n      j = i\n    else\n      ans = {ans.s, ans.palindrome}\n\
    \    end\n    i = i + 1\n  end\n  return ans\nend", "  assert(type(c) ~= 'string'\
    \ or c:len() >= 1, 'c must be a non-empty string')\n  assert(type(s) ~= 'string'\
    \ or s:len() >= 1, 's must be a non-empty string')\n  -- assert(c:len() > 0 and\
    \ c:len() <= s, 'c must be shorter than s and shorter than or equal to zero')",
  "  -- Check if string is empty, return empty string\n  if s == nil then\n    return\
    \ {s, false}\n  end\n  -- Reverse string, delete all equals characters\n  local\
    \ rev\n  if c then\n    rev = s:reverse()\n    rev = rev:gsub(c, '')\n  else\n\
    \    rev = s:reverse()\n  end\n  -- Compare strings\n  if rev == s then\n    return\
    \ {s, true}\n  else\n    return {rev, false}\n  end\nend", "  local result = {}\n\
    \  local i\n  for i = 1, #s do\n    if s[i] != c then break end\n    table.insert(result,\
    \ s[#s])\n  end\n  table.insert(result, true, true)\n  if #result == #s then\n\
    \    return { s, false }\n  end\n  local i\n  for i = #result - 1, 1, -1 do\n\
    \    if result[i] then\n      local j = #s - 1\n      for k = i + 1, #result do\n\
    \        if result[k] then\n          result[k] = false\n          result[j] =\
    \ true\n          break\n        end\n      end\n    end\n  end\n  return { table.concat(result),\
    \ true }\nend", "  local table = {}\n  local last_c = 0\n  -- check if there is\
    \ a character in s that is equal to any character in c\n  -- if there is not,\
    \ return empty table\n  if not (s:sub(1, #c) == c:sub(1, #c)) then\n    return\
    \ table\n  end\n  for i = #s do\n    table.insert(table, string.sub(s, last_c,\
    \ i))\n    last_c = i\n  end\n  if last_c < #s then\n    table.insert(table, string.sub(s,\
    \ last_c, #s))\n  end\n  return table\nend", "\tassert(type(s) == 'string', 'reverse\
    \ delete requires a string as first argument')\n\tassert(type(c) == 'string',\
    \ 'reverse delete requires a string as second argument')\n\t\n\tlocal result =\
    \ {s = s, c = c, done = false}\n\t\n\twhile true do\n\t\tlocal resultString =\
    \ '' -- To save the result\n\t\t\n\t\tfor i = 1, #s do -- For each character of\
    \ the string\n\t\t\tif result.done then break end\n\t\t\t\n\t\t\tif s[i] == result.c\
    \ then -- If we are in the character of the string\n\t\t\t\tresultString = resultString\
    \ .. s[i] -- Then copy the character\n\t\t\t\t\n\t\t\t\tif s[i+1] == result.c\
    \ then -- If we are at the end of the string\n\t\t\t\t\tresult.done = true --\
    \ Break\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t\n\t\tif resultString\
    \ == result.s then -- If string was reversed\n\t\t\ttable.insert(result, resultString,\
    \ true) -- Then we add the new character as result and true\n\t\telse\n\t\t\t\
    table.insert(result, resultString, false) -- Otherwise we add the new character\
    \ as result and false\n\t\tend\n\tend\n\t\n\treturn result\nend", "\tassert(type(s)\
    \ == 'string', 'The given string is not a string')\n\tassert(type(c) == 'string',\
    \ 'The given string is not a string')\n\tlocal results = {}\n\tlocal i = #s\n\t\
    while i do\n\t\tif s[i - 1] == c then\n\t\t\tlocal delete = i - 1\n\t\t\twhile\
    \ delete > 0 do\n\t\t\t\ts = s:sub(1,delete - 1)\n\t\t\t\ti = i - 1\n\t\t\t\t\
    delete = delete - 1\n\t\t\tend\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\tif s:sub(1,#s)\
    \ ~= s then\n\t\tresults['s'] = s\n\t\tresults['false'] = false\n\telse\n\t\t\
    results['s'] = s\n\t\tresults['true'] = true\n\tend\n\treturn results\nend", " \
    \ -- We create a list to store the result\n  local ret = {}\n  -- We go through\
    \ the string s\n  for i = #s, 1, -1 do\n    -- We delete the character c and check\
    \ if it is equal to any character in s\n    if s[i] == c then ret[#ret+1] = s[i]\
    \ end\n  end\n  -- The string s is now palindrome, if it does not end in a \"\
    c\"\n  if #ret > 1 and ret[#ret] == c then ret[#ret] = '' end\n  return ret\n\
    end", "  local function pall(dst, src, n, c)\n    local count = 0\n    while n\
    \ do\n      if src == c then\n        dst[count] = src\n        count = count\
    \ + 1\n      else\n        dst[count] = src\n        count = count + 1\n     \
    \ end\n      n = n - 1\n    end\n  end\n  local n = 1\n  local t = {}\n  if s\
    \ ~= c then\n    pall(t, s, n, c)\n    pall(t, c, n, s)\n    local k = #t\n  \
    \  while k do\n      n = k\n      t = t[n - 1]\n      k = k - 1\n    end\n  end\n\
    \  return { t = t, r = s == t[#t] and true or false }\nend", "\t-- We traverse\
    \ the string and delete from start to end any character that appears in the c\n\
    \tlocal function remove()\n\t\t-- Keep track of the current position\n\t\tlocal\
    \ pos = 1\n\t\t-- Keep going until we hit the end\n\t\twhile pos < #s do\n\t\t\
    \t-- If the current character appears in the c then we delete it\n\t\t\tif s[pos]\
    \ == c then\n\t\t\t\t-- Remove from the string\n\t\t\t\ts:remove(pos)\n\t\t\t\t\
    -- Keep track of the remaining length\n\t\t\t\tpos = pos - 1\n\t\t\t-- If we hit\
    \ the end then we need to stop\n\t\t\telseif pos == #s then\n\t\t\t\t-- Return\
    \ what we have so far\n\t\t\t\treturn s\n\t\t\t-- Otherwise, increment the position\n\
    \t\t\telse\n\t\t\t\tpos = pos + 1\n\t\t\tend\n\t\tend\n\tend\n\t-- If c is a number\
    \ then convert to a string\n\tif type(c) ~= 'number' then\n\t\tc = tostring(c)\n\
    \tend\n\t-- If c is 0 then stop\n\tif c == '0' then\n\t\treturn {s, false}\n\t\
    end\n\t-- If s is empty then stop\n\tif not s then\n\t\treturn {s, false}\n\t\
    end\n\t-- Create an empty string to be returned\n\tlocal newS = ''\n\t-- Remove\
    \ all characters that are equal to a in c\n\tfor i = 1, #s do\n\t\tif s[i] ==\
    \ c then\n\t\t\tnewS = newS..s[i]\n\t\tend\n\tend\n\t-- If there are characters\
    \ left then we need to remove them from s since we are deleting them\n\tif #s\
    \ > 0 then\n\t\ts = newS\n\tend\n\t-- We know that s is non-empty since we checked\
    \ before this loop\n\t-- Loop through the string\n\tlocal result = {}\n\tfor i\
    \ = 1, #s do\n\t\t-- Check if the current character is equal to the next character\n\
    \t\t-- and if so, remove it\n\t\tif s[i] == s[i+1] then\n\t\t\tlocal j = i - 1\n\
    \t\t\twhile j > 0 do\n\t\t\t\t-- If the current character is the same as the one\
    \ just removed then we delete\n\t\t\t\tif s[j] == s[i] then\n\t\t\t\t\t-- Remove\
    \ character from s\n\t\t\t\t\ts:remove(j)\n\t\t\t\t\t-- Keep track of the remaining\
    \ length\n\t\t\t\t\tj = j - 1\n\t\t\t\t-- If there are no characters left we stop\n\
    \t\t\t\telseif j == #s then\n\t\t\t\t\tbreak\n\t\t\t\t-- Otherwise, decrement\
    \ the index\n\t\t\t\telse\n\t\t\t\t\tj = j - 1\n\t\t\t\tend\n\t\t\tend\n\t\t\t\
    -- Check if the result is palindrome\n\t\t\tlocal newResult = remove()\n\t\t\t\
    if newResult[1] == newS then\n\t\t\t\ttable.insert(result, {newResult[1], true})\n\
    \t\t\telse\n\t\t\t\t", "   -- assert( s ~= '' and c ~= '' and c ~= '' and c ~=\
    \ '' and c ~= '' and c ~= '' and c ~= '', 'all inputs should not be empty' )\n\
    \   -- assert( s == '' or (#s == '1' and #c == 0), 'The length of s must be equal\
    \ to the number of characters and c must be equal to the number of characters\
    \ ')", "  local p = {}\n  for i = 1, #s do\n    p[i] = false\n  end\n  for i =\
    \ 1, #c do\n    p[c[i]] = true\n  end\n  local result = {}\n  for i = #s, 1, -1\
    \ do\n    if p[i] then\n      table.insert(result, s[i])\n    end\n  end\n  if\
    \ #result == 1 then\n    return result[1], true\n  end\n  if #result == 0 then\n\
    \    return nil, false\n  end\n  return result, false\nend", "  -- Write your\
    \ code here\n  local result = {s, true}\n  -- We use a reverse iterator to find\
    \ the first occurence of c in s\n  for i = #s, 1, -1 do\n    -- if we are at the\
    \ start of a string\n    if i == 1 then\n      -- we copy the contents and replace\
    \ s with the first occurence of a c\n      result[1] = s:sub(i, 1)\n      s =\
    \ c:sub(1, 1)\n    else\n      -- we continue to copy the contents from the last\
    \ occurence of a c to the end\n      result[i] = s:sub(i, i - 1)\n    end\n  \
    \  -- we check if s is a palindrome\n    -- if we are at the end we check if the\
    \ length is equal to the string length\n    if s == c and #result == #s then\n\
    \      result[2] = true\n    end\n  end\n  return result\nend", "  assert(type(s)\
    \ == 'string')\n  assert(type(c) == 'string')\n  local result = {}\n  local i\
    \ = 0\n  repeat\n    local next_char = string.sub(s,i,i)\n    table.insert(result,\
    \ next_char)\n    i = i + 1\n  until next_char == c\n  local len = #result\n \
    \ if len == 0 then\n    return { s, true }\n  end\n  local reverse = \"\"\n  while\
    \ len > 1 do\n    table.insert(reverse, string.sub(result,len-1,len))\n    len\
    \ = len - 1\n  end\n  if reverse == s then\n    return { reverse, true}\n  end\n\
    \  table.insert(reverse, result[len])\n  return { reverse, false }\nend", "  local\
    \ result = {}\n  local resultString = \"\"\n  -- We start by deleting all the\
    \ characters in s that match any character in c\n  for i = 1, #s do\n    for j\
    \ = 1, #c do\n      if s[i] == c[j] then\n        resultString = resultString\
    \ .. s[i]\n      end\n    end\n  end\n  -- Now, we check if the string is the\
    \ same backwards as forward\n  if #resultString == #s then\n    table.insert(result,\
    \ resultString)\n  end\n  return result\nend", "   assert(type(c) ~= 'string'\
    \ or #c <= 1, 'The string c must be non-empty and have length>=1')\n   local newstr\
    \ = {}\n   for _, c in ipairs(s) do\n      if c == c then\n         newstr:add(c)\n\
    \      else\n         newstr:add(c)\n         if not (string.find(s, c, 1) then\n\
    \            newstr:add(' ')\n         end\n      end\n   end\n   if #newstr ~=\
    \ #s or newstr:reverse() ~= s then\n      return {newstr, false}\n   else\n  \
    \    return {s, true}\n   end\nend", "  -- base case\n  if s == c then\n    return\
    \ {'', true}\n  end\n  -- recursive case\n  local newS = string.gsub(s, '[^' ..\
    \ c .. ']', '')\n  local newC = string.gsub(c, '[^' .. s .. ']', '')\n  if newS\
    \ ~= newC then\n    local newS = reverse_delete(newS, newC)\n    if newS[1] ==\
    \ newC then\n      return {newS..newS[1], true}\n    else\n      return {newS..newS[1],\
    \ false}\n    end\n  end\n  -- base case\n  return {'', false}\nend", "\tlocal\
    \ result = {}\n\tlocal i = 0\n\tlocal j = #s", "  -- Base condition\n  if s ==\
    \ nil then return nil, false end\n  if #s == 0 then return s, true end", "   \
    \ local ts = {}\n    local i = 1\n    while i <= #s do\n        local j = #c\n\
    \        while j <= #s do\n            if s[i:len(s) - 1] == c[j:len(s) - 1] then\n\
    \                j = 0\n            else\n                break\n            end\n\
    \        end\n        ts[i] = s[i:len(s) - 1]\n        i = i + 1\n    end\n  \
    \  return { ts[i], i == #s }\nend", "  local function reverse(str)\n    local\
    \ reversed_str = \"\"\n    for i = 1, #str do\n      reversed_str = reversed_str\
    \ .. str:sub(i, i)\n    end\n    return reversed_str\n  end", "\t-- Return value\
    \ should contain\n\t-- - new string -- if palindrome was found\n\t-- - boolean\
    \ -- if it is a palindrome\n\t\n\t-- Initialize return value\n\tlocal result =\
    \ {}\n\t\n\t-- Check if string is empty\n\tif s == nil then\n\t\treturn result\n\
    \tend", "\t-- Base case\n\t-- If there are no c in s, return empty table\n\t--\
    \ If there are more characters in s than c in s\n\t-- Then return empty table\n\
    \t-- If there is only one character in s\n\t-- then return the string and true\n\
    \t-- Else return table with only the last character in s and true\n\tif #s <=\
    \ 0 or #c > #s then\n\t\treturn {}, false\n\tend", "  -- Build a dictionary for\
    \ s\n  local dict = {}\n  for i = 1, #s do\n    dict[s[i]] = true\n  end\n  --\
    \ Check each character in s\n  local result\n  local check = true\n  while check\
    \ do\n    -- Remove current character from dictionary\n    dict[c] = false\n \
    \   -- Delete from string\n    local new_string = string.gsub(s, '^%s*(.-)%s*$',\
    \ unpack(dict))\n    -- If no character, return false\n    if not new_string then\n\
    \      check = false\n      result = false\n      break\n    end\n    -- Compare\
    \ with result\n    local cmp = s == new_string\n    result = cmp and cmp\n   \
    \ check = cmp\n  end\n  return result, result\nend", "  local result\n  local\
    \ i = 0\n  while i <= #s do\n    i = i+1\n    if s[i] == c then\n      result\
    \ = (table.insert(result, table.del(s, i)) and result)\n    end\n  end\n  return\
    \ result\nend", "  -- start with the base case\n  if(s == c) then return {'',\
    \ true} end\n  local result = {}\n  \n  -- now add the recursive case in all substring\
    \ starting from position 1\n  for i = 1, #s do\n    -- add the character at position\
    \ if it's not in the 'c'\n    if (not (s[i] = c)) then result[i] = s[i] end\n\
    \    -- now check if all the characters in the substring are equal to the character\
    \ at position\n    -- if so break and add it to the result\n    for j = 1, #c\
    \ do\n      if s[i] != c[j] then break end\n      result[i] = c\n    end\n  end",
  "    local t = {}\n    for i = 1, #s do\n        if s[i] == c then\n           \
    \ table.insert(t, s[i]:sub(1, -1))\n        else\n            table.insert(t,\
    \ s[i])\n        end\n    end\n    if table.concat(t) == s then\n        return\
    \ t\n    end\n    return nil\nend", "\t-- check if c is in s\n\tif s[#s-1] ==\
    \ c then\n\t\t-- remove c and reverse s\n\t\ts = reverse(s, #s-1)\n\t\treturn\
    \ {s, true}\n\tend\n\t-- check if s is palindrome\n\tlocal i = 1\n\tlocal j =\
    \ #s\n\twhile i < j do\n\t\tif s[i] != s[#s-i] then\n\t\t\tj = j-1\n\t\t\tbreak\n\
    \t\telse\n\t\t\ti = i+1\n\t\tend\n\tend\n\t-- check if c is palindrome\n\tlocal\
    \ i = 1\n\tlocal j = #s\n\twhile i < j do\n\t\tif s[i] != s[#s-i] then\n\t\t\t\
    i = i+1\n\t\t\tbreak\n\t\telse\n\t\t\tj = j-1\n\t\tend\n\tend\n\t-- remove c from\
    \ s and reverse s\n\ts = reverse(s, j)\n\treturn {s, false}\nend", "    if s ==\
    \ nil or c == nil then\n        return {nil, false}\n    end", "    local res\
    \ = {}\n    for i = #s-1, 1, -1 do\n        res[i] = s[i] == c and nil or s[i]\n\
    \    end\n    return { result = table.concat(res), is_palindrome = false }\nend",
  "    -- TODO: Write a function that removes all the characters in s that are equal\
    \ to any character in c\n    -- (Hint: Use string substring and string length\
    \ to find all matching substrings)\n    -- TODO: Check if the new string is palindrome\
    \ (Hint: Check if the first and last character of the\n    --       new string\
    \ are the same as the last and first character of the original string).\n    --\
    \ TODO: Return a table containing the result string and true/false for the check.\n\
    end", "\tlocal result = {}\n\tlocal start = 0\n\tlocal len = 0\n\twhile start\
    \ < #s do\n\t\tlocal found = false\n\t\tfor i = start, #s - 1 do\n\t\t\tif s[i]\
    \ == c then\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tif found\
    \ then\n\t\t\tresult[#result + 1] = s[start, i - 1]\n\t\t\tlen = (len - 1) + 1\n\
    \t\tend\n\t\tstart = start + 2\n\tend\n\tresult[#result + 1] = s[start, #s]\n\t\
    len = (len - 1) + 1\n\treturn result, len == #s\nend", "   if #s < 1 then\n  \
    \    return {}\n   end\n   if #c < 1 then\n      return {'', #s == 0 and true\
    \ or false}\n   end\n   local result = '', deleted = {}, i = 0, j = #s\n   while\
    \ i < j do\n      local c = s[i]\n      local t = c\n      i = (i + 1) % #s\n\
    \      j = (j - 1) % #s\n      if c == c[i] and #deleted == 0 then\n         deleted\
    \ = true\n      else\n         result = result .. t\n      end\n   end\n   return\
    \ {'' .. result .. c, #deleted == 0 and true or false}\nend", "\t-- Time Complexity\
    \ : O(n) where n is the length of s\n\t-- Space Complexity : O(1) \n\tlocal result\
    \ = {}\n\tlocal i, j, k = 0, #s - 1, 0\n\twhile i <= k do\n\t\tif s[i] == c then\n\
    \t\t\tj = 1\n\t\t\twhile j <= k do\n\t\t\t\ts[j] = s[j]\n\t\t\t\tj = j + 1\n\t\
    \t\tend\n\t\t\ts[k] = nil\n\t\telse\n\t\t\ti = i + 1\n\t\tend\n\t\tif i == k then\n\
    \t\t\tif k > 1 then\n\t\t\t\ttable.insert(result, s[k])\n\t\t\tend\n\t\t\tbreak\n\
    \t\tend\n\t\tk = k - 1\n\tend\n\tif i == k then\n\t\tif k > 1 then\n\t\t\ttable.insert(result,\
    \ s[k])\n\t\tend\n\t\tresult[1] = true\n\tend\n\treturn result\nend", "  -- Create\
    \ a table to store the result and the check result\n  local t = {\"\", false}\n\
    \  -- Iterate through the string and check characters\n  for i = 1, #s do\n  \
    \  if s[i] == c then\n      -- Delete character and check palindrome again\n \
    \     s = s:gsub(s, function(c) return c:sub(1, #c) end)\n      -- Check the character\
    \ again\n      t[1] = t[1] and reverse_delete(s, c)\n    else\n      -- Check\
    \ if character is deleted\n      t[1] = t[1] and s[i]\n    end\n  end\n  return\
    \ t\nend", "    local results = {}\n    for i = #s-1,1,-1 do\n        local temp\
    \ = s[i]\n        if temp == c then\n            table.remove(results, i)\n  \
    \      else\n            table.remove(results, i)\n        end\n    end\n    if\
    \ #results == 0 then\n        return {s, false}\n    else\n        return {table.reverse(results,\
    \ 1, #results-1, 1), true}\n    end\nend\n</cell>\n<text>\nProblem 3\nGiven two\
    \ strings, a and b, where b is a permutation of a, the function should return\
    \ true if b is a permutation of a.", "\tif #s < 0 then return nil end\n\tif #c\
    \ < 0 then return nil end\n\tif #c > #s then return nil end\n\tlocal out = {'',\
    \ false}\n\tlocal index = 0\n\twhile index < #s do\n\t\tif s[index] == c then\n\
    \t\t\tindex = (index + 1) % #s\n\t\telse\n\t\t\tlocal tmp = string.sub(s, index,\
    \ index)\n\t\t\tif #tmp == 0 then -- string reverse\n\t\t\t\tif #out == 0 then\
    \ -- check palindrome\n\t\t\t\t\tif s == reverse(out[1]) then -- check forward\n\
    \t\t\t\t\t\ttable.insert(out, tmp, true)\n\t\t\t\t\telse\n\t\t\t\t\t\ttable.insert(out,\
    \ tmp, false)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\ttable.insert(out,\
    \ tmp, true)\n\t\t\tend\n\t\tend\n\tend\n\treturn out\nend", "\treturn {s = s:gsub(c,''):reverse():gsub('',''),\
    \ true}\nend", "   local ans = { s = s, c = c }\n   if #s < 1 then return end\n\
    \   if #c < 1 then return end\n   if #s == 1 then return { s = s, c = c, result\
    \ = s }\n   end\n   local i = 1\n   while i <= #s do\n      if s[i] == c then\n\
    \         s = delete_string(s, i, 1)\n         i = i + 1\n      elseif s[i] ==\
    \ c then\n         s = delete_string(s, i, 1)\n         i = i + 1\n      else\n\
    \         i = i + 1\n      end\n   end\n   if s == s then\n      ans.result =\
    \ s\n      ans.c = c\n      return ans\n   end\nend", "\t-- We go through the\
    \ string and if c is found, we remove it from the string and move the iterator\
    \ to the begining of the string.\n\t-- We do this until the iterator reaches the\
    \ end of the string.\n\t-- The function returns all the characters removed and\
    \ the result string\n\tlocal newS = \"\"\n\tlocal i = 1\n\twhile i <= #s do\n\t\
    \t-- If the current character is not c we add it to the new string and continue\n\
    \t\tif s[i] != c then\n\t\t\tnewS = newS..s[i]\n\t\t\ti = i + 1\n\t\tend\n\t\t\
    -- If we are at the end, we stop\n\t\tif i == #s then\n\t\t\tbreak\n\t\tend\n\t\
    \t-- We need to go back to the beginning to add the next character\n\t\ti = i\
    \ - 1\n\tend\n\t-- We need to check if the last character was c or not\n\tif i\
    \ ~= #s then\n\t\treturn newS\n\telse\n\t\treturn newS, true\n\tend\nend", " \
    \ local result = {}\n  local lenS = 0\n  local lenC = 0\n  local i = 0\n  local\
    \ j = lenS\n  while i <= j do\n    lenC = lenC + 1 -- count of characters\n  \
    \  local char = s[i]\n    if char == c then\n      i = i + 1\n    else\n     \
    \ result[j+1] = char\n      j = j - 1\n    end\n  end\n  if lenS == lenC then\n\
    \    table.insert(result, s[lenS])\n  end\n  return { result = table.concat(result),\
    \ isPalindrome = lenS == lenC }\nend", "  local result = {}\n  local index = 1\n\
    \  while index - 1 do\n    local temp, index = s:sub(1, index-1), index-1\n  \
    \  result[index] = temp\n  end\n  local index = index\n  while index <= #s do\n\
    \    local temp, index = s:sub(1, index), index-1\n    if result[index] == c then\n\
    \      result[index] = ''\n    else\n      table.insert(result, result[index])\n\
    \    end\n  end\n  return result, true\nend", "  if c == nil then\n    c = '*'\n\
    \  end", "  s = s:gsub('%c+', c)\n  s = s:gsub('%(.)', function(x)\n    if #x\
    \ < #c then return x end\n    return ''\n  end)\n  local t = {}\n  repeat\n  \
    \  t[#t+1] = s:sub(1, #s)\n    s = s:sub(2)\n  until #s == 0\n  return table.concat(t,\
    \ s), t[#t] == t[#t-1]\nend", "  local n = {}\n  for _, v in ipairs(s) do n[v]\
    \ = true end\n  local m = {}\n  for _,v in ipairs(c) do m[v] = true end\n  local\
    \ rev_s = reverse(s), n = n, rev_s = rev_s\n  for _, v in ipairs(s) do\n    if\
    \ not n[v] then return nil, false end\n    m[v] = nil\n  end\n  local ok = true\n\
    \  for _, v in ipairs(rev_s) do\n    if not m[v] then ok = false end\n  end\n\
    \  return rev_s, ok\nend", "    local i, j = 1, #s\n    while i <= j do\n    \
    \    if s[i] == c then\n            s = s..s..string.sub(s, i+1)\n           \
    \ i = i-1\n        elseif s[j] == c then\n            j = j-1\n        else\n\
    \            i = i-1\n            j = j-1\n        end\n    end\n    if s[i+1]\
    \ ~= c then\n        s = s..string.sub(s, 1, i+1)\n        return {}, false\n\
    \    end\n    return { s, true }, true\nend", "  -- Initialize our result and\
    \ result variable.\n  local result = {s = s, check = false}", "    local i = 0\n\
    \    local j = 1\n    local result = {}\n    local length = #s\n    while i <=\
    \ length and j <= length do\n        if s[i] == c[j] then\n            i = i +\
    \ 1\n            j = j + 1\n        else\n            if i ~= j then\n       \
    \         result[#result + 1] = s[i]\n            end\n            i = i + 1\n\
    \            j = j + 1\n        end\n    end\n    if i ~= length then\n      \
    \  result[#result + 1] = s[i]\n    end\n    return string.reverse(table.concat(result)),\
    \ true\nend", "    -- Write your code here\n    \n    local res = {}\n    for\
    \ i, v in pairs(s) do\n        if v == c then\n            table.insert(res, v)\n\
    \        else\n            table.insert(res, v)\n        end\n    end\n    if\
    \ table.concat(res) == s then\n        return { s, true }\n    else\n        return\
    \ { s, false }\n    end\nend", "  -- Base case\n  if #s > #c then\n    return\
    \ {s, false}\n  end\n  -- Recursive case\n  local firstChar, secondChar = s[1],\
    \ s[2]\n  if firstChar == secondChar then\n    return {reverse_delete(s[2:], c),\
    \ true}\n  elseif firstChar == c then\n    return {reverse_delete(s[1:], c), false}\n\
    \  else\n    return {reverse_delete(s, c), false}\n  end\nend", "  local ts =\
    \ {}\n  local i = -1\n  local l = #s\n  while l > 0 do\n    i = i + 1\n    if\
    \ s[i] ~= c then\n      ts[#ts + 1] = s[i]\n    end\n    if i == l then\n    \
    \  break\n    end\n  end\n  return { ts[#ts - 1] == c and ts[#ts], true }\nend",
  "    local result = {s = s, c = c}\n    local deleted_chars = {}\n    for i = 1,\
    \ #s do\n        local char = s[i]\n        if char == c.1 then\n            table.insert(deleted_chars,\
    \ i)\n        elseif char == c.2 then\n            if #deleted_chars == 0 then\n\
    \                result.s = result.s[#result.s]:sub(1, #result.s)\n          \
    \      result.c = result.c:sub(1, #result.c)\n            else\n             \
    \   result.s = result.s[#deleted_chars]:sub(1, #result.s)\n                result.c\
    \ = result.c[#deleted_chars]:sub(1, #result.c)\n            end\n        else\n\
    \            if #deleted_chars == 0 then\n                result.s = result.s[#result.s]:sub(1,\
    \ #result.s)\n                result.c = result.c\n            else\n        \
    \        result.s = result.s[#deleted_chars]:sub(1, #result.s)\n             \
    \   result.c = result.c[#deleted_chars]\n            end\n        end\n    end\n\
    \    if #deleted_chars > 0 then\n        result.s = result.s[#deleted_chars]:sub(1,\
    \ #result.s)\n        result.c = result.c[#deleted_chars]\n    end\n    if #s..1\
    \ ~= #result.s then result.result = false end\n    return result\nend", "    local\
    \ i, j = 1, #s\n    local res = {}\n    while i <= j do\n        if s[i-1] ==\
    \ c then\n            i = i - 1\n        else\n            table.insert(res, s[i-1])\n\
    \            i = i + 1\n        end\n    end\n    return { res, i==j }\nend",
  "\t-- Initialize a table and store result in it\n\tlocal table = {}\n\t-- A simple\
    \ check to know if a string is a palindrome\n\tlocal function is_palindrome(s)\n\
    \t\t-- If string is not a palindrome, return false\n\t\tif not s then\n\t\t\t\
    return false\n\t\tend\n\t\t-- Initialize an empty string\n\t\tlocal t = ''\n\t\
    \t-- For each character in string\n\t\tfor _, c in ipairs(s) do\n\t\t\t-- Add\
    \ character to a temporary string\n\t\t\tt = t .. c\n\t\t\t-- Check if the character\
    \ in string is a palindrome\n\t\t\tif not string.sub(s, 1, c - 1) then return\
    \ false end\n\t\tend\n\t\t-- If the temp string is equal to the original string,\
    \ return true\n\t\treturn t == s\n\tend\n\t-- A simple check to know if a string\
    \ is a palindrome\n\tif is_palindrome(s) then table.insert(table, s) end\n\t--\
    \ Iterating over a string and deleting characters which are not a palindrome\n\
    \tfor _, c in ipairs(s) do\n\t\tif not is_palindrome(s.sub(c, c + 1)) then\n\t\
    \t\t-- Delete the character\n\t\t\ts = s.sub(0, c) .. s.sub(c+1)\n\t\t\ttable.insert(table,\
    \ s)\n\t\tend\n\tend\n\treturn table, not is_palindrome(s)\nend", "    if c then\n\
    \        local i = #s\n        while i do\n            i = i - 1\n           \
    \ if s[i] ~= c then\n                break\n            end\n        end\n   \
    \     if i then\n            local j = #s\n            while j do\n          \
    \      j = j - 1\n                if s[j] ~= s[i] then\n                    break\n\
    \                end\n            end\n            if j == #s then\n         \
    \       s = s .. c\n            else\n                s = s..c .. s[i]\n     \
    \       end\n        end\n    end\n    return s\nend", "  -- base case\n  if s\
    \ == c then\n    return {\"a\", true}\n  end\n  local first, last = s:find(c),\
    \ s:find(c, \"e\")\n  if first == nil then\n    return {s, false}\n  end\n  local\
    \ result = s:sub(first + 1, last)\n  if result ~= s then\n    return {result,\
    \ true}\n  end\n  return reverse_delete(s:sub(first + 1), c)\nend", "\tlocal ans\
    \ = { }\n\tfor _,c in ipairs(s) do\n\t\tif not s[#s]:match(c) then\n\t\t\tans[#ans+1]\
    \ = c\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\tans[#ans] == '' and ans[#ans+1]\
    \ ~= '' and ans[#ans+1] = ans[#ans]\n\tans[#ans] = true\n\treturn ans\nend", " \
    \ local res = {}\n  for i = 1,#s do\n    if s[i] == c then\n      table.insert(res,table.remove(s,i))\n\
    \    else\n      table.insert(res, s[i])\n    end\n  end\n  return res, table.includes(res,\
    \ s[#s])\nend", "\tlocal start = 0 -- start at 0 as the string starts at 1 by\
    \ default\n\tlocal start2 -- start at 0 as the string starts at 1 by default\n\
    \tlocal result = {}\n\tlocal char_count = #s -- length of the string\n\tlocal\
    \ reversed = string.gsub(string.gsub(s, '', c), '', c)\n\twhile start < char_count\
    \ do\n\t\tlocal char = s[start]\n\t\t-- check for characters equal to c\n\t\t\
    if char == c then\n\t\t\t-- delete it\n\t\t\tresult[start] = '\\0'\n\t\telse\n\
    \t\t\t-- insert it\n\t\t\tresult[start + 1] = char\n\t\tend\n\t\tstart = start\
    \ + 1 -- increment the start index\n\tend\n\t-- check backwards\n\tstart2 = char_count\
    \ + 1 -- start at the end\n\twhile start2 < char_count do\n\t\tlocal char = s[start2]\n\
    \t\tif char == c then\n\t\t\t-- delete it\n\t\t\tresult[start2] = '\\0'\n\t\t\
    else\n\t\t\t-- insert it\n\t\t\tresult[start2 + 1] = char\n\t\tend\n\t\tstart2\
    \ = start2 + 1 -- increment the start index\n\tend\n\t-- check forwards\n\tstart2\
    \ = char_count + 1 -- start at the end\n\twhile start2 > 1 do\n\t\tlocal char\
    \ = s[start2]\n\t\tif char == c then\n\t\t\t-- delete it\n\t\t\tresult[start2]\
    \ = '\\0'\n\t\telse\n\t\t\t-- insert it\n\t\t\tresult[start2 - 1] = char\n\t\t\
    end\n\t\tstart2 = start2 - 1 -- decrement the start index\n\tend\n\treturn result\n\
    end", "  local tt = {}\n  local rev = s:reverse()\n  rev = rev:gsub(c, '')\n \
    \ if rev:len() == s:len() then\n    table.insert(tt, rev, 'true')\n  else\n  \
    \  table.insert(tt, rev, 'false')\n  end\n  return tt\nend", "   -- We assume\
    \ that s is palindrome\n   -- We assume that c is not equal to any char in s\n\
    \   -- We assume that c is not equal to any char in s\n   -- We assume that c\
    \ is not equal to any char in s\n   if #s > 0 then\n      local newS = s\n   \
    \   local newC = c\n      for i = #s, 1, -1 do\n         local _new = string.sub(newS,\
    \ i, i)\n         newS = string.gsub(newS, _new, newC)\n         if newS == s\
    \ then\n            return { newS, true }\n         else\n            newC = string.sub(newS,\
    \ i, i)\n         end\n      end\n      return { s, false }\n   else\n      return\
    \ { s, false }\n   end\nend", "  local result = {}\n  local i, j = 0, 0\n  while\
    \ i <= #s - 1 do\n    if s[i] ~= c then\n      result[#result + 1] = s[i]\n  \
    \  end\n    i = i + 1\n  end\n  i = i - 1\n  while j <= #result do\n    if result[j]\
    \ != s[i] then\n      return { result[j] = result[j], false = true }\n    end\n\
    \    j = j + 1\n  end\n  return { result[j] = result[j], true = false }\nend",
  "\t-- TODO: add some error checking\n\t\n\t-- we reverse the string and keep only\
    \ those that are equal to the deleted characters\n\tlocal p = ''\n\tfor i, v in\
    \ pairs(s) do\n\t\tif v == c then p = p .. v end\n\tend\n\t\n\t-- check if string\
    \ is a palindrome (string reads the same  backward as forward)\n\tif p == s then\n\
    \t\treturn {p, true}\n\telse\n\t\treturn {p, false}\n\tend\nend", "  local table\
    \ = {s=s, c=c, result={}, check=true}\n  for c in s do\n    table.check = (table.check\
    \ and c ~= table.c) or not string.sub(s, 1, #c - 1)\n    table.result[#table.result\
    \ + 1] = c\n    table.s = table.s[#table.s .. 1]\n  end\n  return table\nend",
  "\tlocal ans = {}\n\tfor i = 1, #s do\n\t\tif s[i] == c then\n\t\t\ttable.insert(ans,\
    \ s[i]:reverse())\n\t\telse\n\t\t\ttable.insert(ans, s[i])\n\t\tend\n\tend\n\t\
    if ans[#ans] ~= \"\" then\n\t\treturn {ans[#ans], true}\n\telse\n\t\treturn {ans[#ans],\
    \ false}\n\tend\nend", "\tlocal t = {}\n\tfor i,v in ipairs(s) do\n\t\tif v ==\
    \ c then\n\t\t\ttable.insert(t, v)\n\t\tend\n\tend\n\tif #t == 0 then\n\t\treturn\
    \ {s, false}\n\tend\n\tlocal reverse = table.reverse(t)\n\tlocal res = reverse[1]\n\
    \tfor i=2,#t do\n\t\tres = res .. reverse[i]\n\tend\n\treturn {res, true}\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
