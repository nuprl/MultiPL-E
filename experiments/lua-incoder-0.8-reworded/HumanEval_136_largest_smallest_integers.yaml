name: HumanEval_136_largest_smallest_integers
language: lua
prompt: "-- Create a function that returns a table (a, b), where 'a' is\n-- the largest\
  \ of negative integers, and 'b' is the smallest\n-- of positive integers in a table.\n\
  -- If there is no negative or positive integers, return them as None.\n-- Examples:\n\
  -- >>> largest_smallest_integers({2, 4, 1, 3, 5, 7})\n-- {None, 1}\n-- >>> largest_smallest_integers({})\n\
  -- {None, None}\n-- >>> largest_smallest_integers({0})\n-- {None, None}\nlocal function\
  \ largest_smallest_integers(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = largest_smallest_integers\n\
  \    lu.assertEquals(candidate({2, 4, 1, 3, 5, 7}), {None, 1})\n    lu.assertEquals(candidate({2,\
  \ 4, 1, 3, 5, 7, 0}), {None, 1})\n    lu.assertEquals(candidate({1, 3, 2, 4, 5,\
  \ 6, -2}), {-2, 1})\n    lu.assertEquals(candidate({4, 5, 3, 6, 2, 7, -7}), {-7,\
  \ 2})\n    lu.assertEquals(candidate({7, 3, 8, 4, 9, 2, 5, -9}), {-9, 2})\n    lu.assertEquals(candidate({}),\
  \ {None, None})\n    lu.assertEquals(candidate({0}), {None, None})\n    lu.assertEquals(candidate({-1,\
  \ -3, -5, -6}), {-1, None})\n    lu.assertEquals(candidate({-1, -3, -5, -6, 0}),\
  \ {-1, None})\n    lu.assertEquals(candidate({-6, -4, -4, -3, 1}), {-3, 1})\n  \
  \  lu.assertEquals(candidate({-6, -4, -4, -3, -100, 1}), {-3, 1})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if #lst == 0 then\n    return {nil, 0}\n  else\n    local biggest\
    \ = lst[1]\n    local smallgest = lst[1]\n    for i = 2, #lst do\n      if lst[i]\
    \ > biggest then\n        biggest = lst[i]\n      elseif lst[i] < smallgest then\n\
    \        smallgest = lst[i]\n      end\n    end\n    return {biggest, smallgest}\n\
    \  end\nend", "  local pos = nil\n  local neg = {}\n  for _, v in ipairs(lst)\
    \ do\n    if v < 0 then\n      table.insert(neg, v)\n    else\n      if pos ==\
    \ nil or pos < v then\n        pos = v\n      end\n    end\n  end\n  local pos2\
    \ = nil\n  local neg2 = {}\n  for _, v in ipairs(neg) do\n    if v > 0 then\n\
    \      table.insert(neg2, v)\n    else\n      if pos2 == nil or pos2 < v then\n\
    \        pos2 = v\n      end\n    end\n  end\n  if pos2 ~= nil and pos2 ~= neg2\
    \ then\n    pos = pos2\n  end\n  if neg2 ~= nil and neg2 ~= pos then\n    neg\
    \ = neg2\n  end\n  if pos == nil or neg == nil then\n    return {nil, nil}\n \
    \ end\n  pos = pos + 1\n  neg = -neg - 1\n  return {pos, neg}\nend", "  local\
    \ biggest = nil\n  local smallest = nil\n  for _, value in ipairs(lst) do\n  \
    \  if value > biggest then\n      biggest = value\n    elseif value < smallest\
    \ then\n      smallest = value\n    end\n  end\n  if biggest ~= nil and smallest\
    \ ~= nil then\n    return {biggest, smallest}\n  else\n    return {biggest, smallest,\
    \ nil}\n  end\nend", "  local negatives = {}\n  local positives = {}", "  if lst:len()\
    \ == 0 then\n    return nil, nil\n  end\n  local small = {}\n  local largest =\
    \ {}\n  local neg = 0\n  local pos = 0\n  for i, v in ipairs(lst) do\n    if v:isnegative()\
    \ then\n      largest[i] = v\n      neg = v\n    elseif v:ispositive() then\n\
    \      small[i] = v\n      pos = v\n    else\n      -- no positive and no negative\
    \ integers\n      largest[i] = nil\n      small[i] = nil\n    end\n  end\n  --\
    \ if there is no negative integer, return None\n  if neg == 0 then\n    return\
    \ nil, nil\n  end\n  -- return largest or smallest negative integer\n  return\
    \ largest, small\nend", "  if lst ~= nil then\n    local big = nil\n    local\
    \ small = nil\n    local largest = nil\n    local smallest = nil\n    for i =\
    \ 1, #lst do\n      local elem = lst[i]\n      if elem > 0 then\n        big =\
    \ elem if big == nil or big > elem end\n        small = elem if small == nil or\
    \ small < elem end\n      else\n        big = elem if big == nil or big < elem\
    \ end\n        small = elem if small == nil or small > elem end\n      end\n \
    \   end\n    if big == nil then\n      big = small\n      big = big + 1 -- To\
    \ be safe, make sure big has a non-zero value\n      small = small - 1 -- To be\
    \ safe, make sure small has a non-zero value\n      largest = big\n      smallest\
    \ = small\n    end\n    if small ~= nil then\n      largest = big\n      smallest\
    \ = small\n    end\n  end\n  return {largest, smallest}\nend", "  if #lst == 0\
    \ then\n    return {nil, 0}\n  end\n  local largest = nil\n  local smallest =\
    \ nil\n  local i = 1\n  for i = 1, #lst do\n    if tonumber(lst[i]) ~= nil then\n\
    \      if largest == nil then\n        largest = i\n      elseif largest < i then\n\
    \        largest = i\n      end\n      if smallest == nil then\n        smallest\
    \ = i\n      elseif smallest > i then\n        smallest = i\n      end\n    end\n\
    \  end\n  if smallest ~= nil and smallest == i then\n    smallest = nil\n  end\n\
    \  if largest ~= nil and largest == i then\n    largest = nil\n  end\n  return\
    \ {smallest, largest}\nend", "  if #lst == 0 then\n    return {None, None}\n \
    \ end\n  local smallest = lst[1]\n  local largest = lst[1]\n  for i = 2, #lst\
    \ do\n    if lst[i] < smallest then\n      smallest = lst[i]\n    end\n    if\
    \ lst[i] > largest then\n      largest = lst[i]\n    end\n  end\n  return {smallest,\
    \ largest}\nend", "  if lst:is_empty() then\n    return nil\n  else\n    local\
    \ largest = nil\n    local smallest = nil\n    for _, x in ipairs(lst) do\n  \
    \    if largest == nil then\n        largest = x\n      else\n        if x < smallest\
    \ then\n          largest = x\n        else\n          smallest = x\n        end\n\
    \      end\n    end\n    if smallest ~= nil then\n      smallest = nil\n    else\n\
    \      smallest = largest\n    end\n    return largest, smallest\n  end\nend",
  "  if #lst > 0 then\n    local m = math.max(lst[1], lst[2])\n    for _, val in ipairs(lst)\
    \ do\n      if val > m then m = val end\n    end\n    return m, m\n  end\n  return\
    \ None, None\nend", "  if lst == nil then\n    return {None, None}\n  end\n  local\
    \ min = -math.infinity\n  local max = 0\n  for _, v in ipairs(lst) do\n    if\
    \ v <= min then\n      min = v\n    end\n    if v >= max then\n      max = v\n\
    \    end\n  end\n  return {min, max}\nend", "  if #lst == 0 then\n    return {None}\n\
    \  end\n  local largest, smallest = lst[1], lst[1]\n  for i = 2, #lst do\n   \
    \ if lst[i] > largest then\n      largest = lst[i]\n    end\n    if lst[i] < smallest\
    \ then\n      smallest = lst[i]\n    end\n  end\n  if largest == smallest then\n\
    \    return {largest, largest}\n  else\n    return {largest, smallest}\n  end\n\
    end", "  local largest, smallest = nil, nil\n  local n = #lst\n  for i = 1, n\
    \ do\n    local val = lst[i]\n    if val < smallest then\n      largest = val\n\
    \      smallest = val\n    elseif val > largest then\n      largest = val\n  \
    \  end\n  end\n  if smallest == nil then\n    return largest\n  else\n    return\
    \ {largest, smallest}\n  end\nend", "  if #lst == 0 then\n    return {nil, 0}\n\
    \  end\n  local largest, smallest = nil, 0\n  for i = 1, #lst do\n    local value\
    \ = lst[i]\n    if value < 0 then\n      if largest == nil then\n        largest\
    \ = value\n      else\n        if value > largest then\n          largest = value\n\
    \        end\n      end\n    elseif value <= smallest then\n      smallest = value\n\
    \    end\n  end\n  return {largest, smallest}\nend", "  local largest = nil\n\
    \  local smallest = nil", "  local biggest = nil\n  local smallest = nil\n  for\
    \ i = 1, #lst do\n    if lst[i] > 0 and lst[i] < biggest then\n      biggest =\
    \ lst[i]\n    else if lst[i] < 0 and lst[i] > smallest then\n      smallest =\
    \ lst[i]\n    end\n  end\n  if biggest == nil and smallest == nil then\n    return\
    \ nil\n  elseif biggest == nil then\n    return {smallest, nil}\n  elseif smallest\
    \ == nil then\n    return {nil, biggest}\n  else\n    return {biggest, smallest}\n\
    \  end\nend", "  if #lst == 0 then\n    return { None, None }\n  end", "  local\
    \ function helper(pos, max)\n    pos = pos or 0\n    max = max or 0\n    if max\
    \ > pos then\n      helper(pos + 1, max)\n    end\n    if max < pos then\n   \
    \   return nil, pos\n    end\n    return max, pos\n  end\n  return helper(0, #lst)\n\
    end", "  if not lst then\n    return nil\n  end", "  local max_value = nil\n \
    \ local min_value = nil\n  for _, value in ipairs(lst) do\n    if max_value ==\
    \ nil then\n      max_value = value\n      min_value = value\n    else\n     \
    \ if value < max_value then\n        max_value = value\n      else\n        min_value\
    \ = value\n      end\n    end\n  end\n  if max_value == nil and min_value == nil\
    \ then\n    return nil\n  end\n  return max_value, min_value\nend", "  -- Base\
    \ case\n  if not lst[1] then\n    return nil, nil\n  end\n  if lst[1] <= 0 then\n\
    \    return nil, lst[1]\n  end", "  local smallest, largest = nil, 0\n  for _,\
    \ item in ipairs(lst) do\n    smallest, largest = item < smallest and item or\
    \ smallest, item > largest and item or largest\n  end\n  return {smallest, largest}\n\
    end", "  -- The empty list has no largest and smallest integers.\n  if #lst ==\
    \ 0 then\n    return {nil, nil}", "  local smallest, largest = lst.minmax_by(function(n)\
    \ return n end)\n  if smallest == nil then return nil, nil else return smallest,\
    \ largest end\nend", "  local function is_negative(value)\n    if value == nil\
    \ then\n      -- This is necessary because nil isn't ordered.\n      -- If you're\
    \ getting \"attempt to compare two nil values\" errors,\n      -- you may want\
    \ to add a return value for this case.\n      return false\n    end\n    -- TODO:\
    \ this could be optimized to run in linear time by sorting.\n    return value\
    \ < 0\n  end\n  local is_positive\n  if #lst > 0 then\n    local smallest, largest\
    \ = nil, 0\n    for _, value in ipairs(lst) do\n      if is_negative(value) then\n\
    \        if not smallest or value < smallest then\n          smallest = value\n\
    \        end\n      elseif is_positive(value) then\n        if not largest or\
    \ value > largest then\n          largest = value\n        end\n      else\n \
    \       return nil\n      end\n    end\n    return smallest, largest\n  else\n\
    \    return nil, nil\n  end\nend", '  local smallest, largest = lst[1][1], lst[2][1]',
  "    local largest, smallest, max_int, min_int = nil, nil, 0, nil\n    for _, _\
    \ in ipairs(lst) do\n        if largest == nil or _ < smallest then\n        \
    \    largest, smallest = _, 0\n            max_int, min_int = 0, 0\n        end\n\
    \        if _ > largest then\n            largest, _\n        end\n        if\
    \ _ < smallest then\n            smallest, _\n        end\n        max_int, min_int\
    \ = max_int, min_int\n    end\n    return largest, smallest, max_int, min_int\n\
    end", "    local min_value = nil\n    local max_value = nil\n    for _, value\
    \ in ipairs(lst) do\n        if min_value == nil then\n            min_value =\
    \ value\n            max_value = value\n        else\n            if value < min_value\
    \ then\n                min_value = value\n            else\n                max_value\
    \ = value\n            end\n        end\n    end\n    if min_value == nil then\n\
    \        return {nil, min_value}\n    else\n        return {min_value, max_value}\n\
    \    end\nend", "  if #lst == 0 then\n    return nil\n  end\n  local largest =\
    \ tonumber(lst[1])\n  local smallest = tonumber(lst[1])\n  for i = 2, #lst, 1\
    \ do\n    local elem = tonumber(lst[i])\n    if elem > largest then\n      largest\
    \ = elem\n    end\n    if elem < smallest then\n      smallest = elem\n    end\n\
    \  end\n  return largest, smallest\nend", "  if lst:is_empty() then\n    return\
    \ {None, None}\n  end\n  local largest = nil\n  local smallest = nil\n  local\
    \ x = lst:sort()\n  if x:is_empty() then\n    return {None, None}\n  end\n  local\
    \ last = x[1]\n  for i = 2, x:len() do\n    if x[i] > last then\n      largest\
    \ = x\n      smallest = i\n    end\n    last = x[i]\n  end\n  if largest ~= nil\
    \ then\n    return {largest, smallest}\n  end\n  return {nil, 0}\nend", "  local\
    \ min = nil\n  local max = nil\n  local result = {}\n  for i=1,#lst do\n    if\
    \ tonumber(lst[i]) < tonumber(lst[min]) or tonumber(lst[i]) > tonumber(lst[max])\
    \ then\n      if min then result[#result] = {min = min, max = max} end\n     \
    \ min = i\n      max = i\n    elseif tonumber(lst[i]) == tonumber(lst[min]) then\n\
    \      min = i\n    elseif tonumber(lst[i]) == tonumber(lst[max]) then\n     \
    \ max = i\n    end\n  end\n  if min then result[#result] = {min = min, max = max}\
    \ end\n  return result\nend", "  -- Sort the list from largest to smallest\n \
    \ -- Note: this assumes the list is nonempty\n  -- See https://en.wikipedia.org/wiki/Selection_algorithm\n\
    \  -- @returns list with largest integers and smallest integers\n  -- @returns\
    \ nil if no integers\n  lst = lst.sort(function(a, b)\n                  -- Check\
    \ for negative integers, if so, return larger\n                  -- Otherwise,\
    \ return smaller\n                  if a < 0 then\n                    b\n   \
    \               else\n                    a\n                  end\n         \
    \       end)\n  -- If no integers, return nil\n  if #lst == 0 then\n    return\
    \ nil\n  end", "    local function smaller_positive(lst, i, v)\n        if lst[i]\
    \ == nil then\n            lst[i] = v\n        else\n            if v <= 0 then\n\
    \                return nil, lst[i]\n            elseif v < lst[i] then\n    \
    \            return smaller_positive(lst, i, v)\n            end\n        end\n\
    \    end\n    local function smaller_negative(lst, i, v)\n        if lst[i] ==\
    \ nil then\n            lst[i] = v\n        else\n            if v > 0 then\n\
    \                return nil, lst[i]\n            elseif v < lst[i] then\n    \
    \            return smaller_negative(lst, i, v)\n            end\n        end\n\
    \    end\n    return smaller_negative(lst, 1, lst[1]) if #lst ~= 1 or\n      \
    \                                                          #lst[1] == 0 or\n \
    \                                                               #lst[1] < 0\n\
    end", "   if #lst < 2 then\n      return {}\n   end\n   local min_i = 1\n   local\
    \ max_i = #lst\n   for i = 2, max_i do\n      if lst[i] < lst[min_i] then\n  \
    \       min_i = i\n      elseif lst[i] > lst[max_i] then\n         max_i = i\n\
    \      end\n   end\n   if min_i == max_i then\n      return {lst[min_i]}\n   else\n\
    \      return {lst[min_i], lst[max_i]}\n   end\nend", "    local max_i, min_i\
    \ = 0, 1\n    for i, v in ipairs(lst) do\n        if v > max_i then\n        \
    \    max_i = v\n        elseif v < min_i then\n            min_i = v\n       \
    \ end\n    end\n    return max_i, min_i\nend", "  -- TODO: Improve the efficiency\
    \ of this\n  if #lst > 0 then\n    local max_val = lst[1]\n    local min_val =\
    \ lst[1]\n    for i = 2, #lst do\n      local v = lst[i]\n      if v > max_val\
    \ then\n        max_val = v\n      elseif v < min_val then\n        min_val =\
    \ v\n      end\n    end\n    return { min_val, max_val }\n  else\n    return {\
    \ nil, nil }\n  end\nend", "   local smallest\n   local largest\n   if #lst <\
    \ 1 then\n      largest = smallest\n      largest[1] = nil\n      return largest\n\
    \   end\n   largest = lst[1]\n   for i = 2, #lst do\n      if lst[i] > largest\
    \ then\n         largest = lst[i]\n      end\n   end\n   smallest = largest\n\
    \   largest[1] = nil\n   return largest\nend", "  if #lst == 0 then return {}\
    \ end\n  local max_num = -math.inf\n  local min_num = math.inf\n  for i = 1, #lst\
    \ do\n    if lst[i] > max_num then\n      max_num = lst[i]\n    elseif lst[i]\
    \ < min_num then\n      min_num = lst[i]\n    end\n  end\n  if max_num < 0 then\n\
    \    return {max_num, min_num}\n  elseif min_num > 0 then\n    return {min_num,\
    \ max_num}\n  else\n    return {max_num, max_num}\n  end\nend", "  if not lst\
    \ then\n    return nil\n  end\n  local max = lst[1]\n  local min = lst[1]\n  for\
    \ i = 2, #lst do\n    if lst[i] > max then\n      max = lst[i]\n    end\n    if\
    \ lst[i] < min then\n      min = lst[i]\n    end\n  end\n  if max ~= nil and min\
    \ ~= nil and max > 0 then\n    return {max, min}\n  end\n  return nil\nend", " \
    \ local max_val = nil\n  local min_val = nil\n  for i, v in ipairs(lst) do\n \
    \   if type(v) == 'number' then\n      if max_val == nil then\n        max_val\
    \ = v\n        min_val = v\n      else\n        if v > max_val then\n        \
    \  max_val = v\n        end\n        if v < min_val then\n          min_val =\
    \ v\n        end\n      end\n    end\n  end\n  return {\n    max_val = max_val,\n\
    \    min_val = min_val\n  }\nend", "  return function ()\n    -- The smallest\
    \ negative integer is '-inf'.\n    if lst[1] < 0 then return {'-', -inf} end",
  "  -- If there are no integers return None.\n  if not lst[#lst] then\n    return\
    \ {None, None}\n  end\n  -- If there is only one integer, return it.\n  if #lst\
    \ == 1 then\n    local v = lst[1]\n    return {v, v}\n  end\n  -- Sort the list,\
    \ largest to smallest.\n  -- NOTE: We have to reverse the list in order to iterate\
    \ it backwards.\n  table.sort(lst)\n  -- Find largest value in list and smallest\
    \ value in list.\n  local max = lst[#lst - 1]\n  local min = lst[1]\n  -- Iterate\
    \ backwards, checking each time if min has moved too much.\n  -- This is done\
    \ to avoid the corner case where min is equal to max.\n  local i = #lst\n  while\
    \ i ~= 1 do\n    i = i >> 1\n    if lst[i] < min then\n      min = lst[i]\n  \
    \  end\n    if lst[i] > max then\n      max = lst[i]\n    end\n  end\n  -- Now\
    \ return None if the max is smaller than any positive\n  -- value in the list,\
    \ and the smallest negative value if max is bigger.\n  if max < 0 then\n    return\
    \ {None, min}\n  end\n  return {max, -min}\nend", "  -- Handle empty list\n  if\
    \ not lst[1] then return {nil, 0}\n  if not lst[2] then return {0, nil}", "  \
    \  local smallest = nil\n    local largest = nil", "  if lst == nil then\n   \
    \ return nil\n  elseif #lst == 0 then\n    return { nil, nil }\n  else\n    local\
    \ max, min = nil, nil\n    for i = 1, #lst do\n      local v, ok = std.itoa(lst.values[i])\n\
    \      if ok then\n        if max and max < v then\n          max = v\n      \
    \  elseif min and min > v then\n          min = v\n        else\n          max\
    \ = v\n          min = v\n        end\n      end\n    end\n    return { max, min\
    \ }\n  end\nend", "  if lst == nil then return {nil, nil} end\n  local max = -math.huge\n\
    \  local min = 0\n  for v in lst do\n    if v > max then max = v end\n    if v\
    \ < min then min = v end\n  end\n  if max == -math.huge and min == 0 then\n  \
    \  return {nil, nil}\n  else\n    return {min, max}\n  end\nend", "  if lst[1]\
    \ < 0 and lst[2] < 0 then\n    return nil\n  elseif lst[1] < 0 then\n    return\
    \ nil, lst[1]\n  elseif lst[2] < 0 then\n    return lst[2], nil\n  end\n  return\
    \ lst[1] < lst[2] and lst or nil\nend", "  -- The max is calculated as the largest\
    \ number in the table\n  -- and the min is the smallest number in the table.\n\
    \  local max = { largest(lst, function(a)\n      if type(a) == \"number\" then\n\
    \        return a\n      else\n        return nil\n      end\n    end)\n  }\n\
    \  local min = { smallest(lst, function(a)\n      if type(a) == \"number\" then\n\
    \        return a\n      else\n        return nil\n      end\n    end)\n  }",
  "  if #lst == 0 then\n    return {None, lst[1]}\n  end\n  if #lst == 1 then\n  \
    \  return {lst[0], None}\n  end\n  local smallest = nil\n  local largest = nil\n\
    \  for i = 2, #lst do\n    if lst[i] < smallest then\n      smallest = lst[i]\n\
    \    end\n    if lst[i] > largest then\n      largest = lst[i]\n    end\n  end\n\
    \  return {smallest, largest}\nend", "  local min = nil\n  local max = nil\n \
    \ for i = 1, #lst do\n    local v = lst[i]\n    if min == nil or v < min then\n\
    \      min = v\n    end\n    if max == nil or v > max then\n      max = v\n  \
    \  end\n  end\n  if min ~= nil and max ~= nil then\n    return {min, max}\n  else\n\
    \    return nil\n  end\nend", "  if #lst < 2 then return {nil, nil} end\n  local\
    \ max = lst[1]\n  for i = 2, #lst do\n    if lst[i] > max then\n      max = lst[i]\n\
    \    end\n  end\n  local min = lst[1]\n  for i = 2, #lst do\n    if lst[i] < min\
    \ then\n      min = lst[i]\n    end\n  end\n  if min == nil and max == nil then\
    \ return {nil, nil} end\n  if min == nil then\n    return {min, max}\n  elseif\
    \ max == nil then\n    return {max, min}\n  else\n    return {min, max}\n  end\n\
    end", '  if #lst == 0 then return {None, {}} end', "    local largest_neg = {}\n\
    \    local largest_pos = {}\n    for i = 1, #lst do\n        -- If the number\
    \ is negative, add it to the 'largest_neg'\n        if lst[i] < 0 then\n     \
    \       table.insert(largest_neg, i)\n        elseif lst[i] > 0 then\n       \
    \     table.insert(largest_pos, i)\n        else\n            -- The number is\
    \ both negative and positive, so stop searching.\n            return nil\n   \
    \     end\n    end\n    -- If there were no negative or positive numbers, return\
    \ them as\n    -- None. Otherwise, return them both as {None, ...}\n    local\
    \ result = {}\n    if #largest_neg == 0 then return {} end\n    for _, index in\
    \ ipairs(largest_neg) do\n        table.insert(result, index)\n    end\n    if\
    \ #largest_pos == 0 then return {} end\n    for _, index in ipairs(largest_pos)\
    \ do\n        table.insert(result, index)\n    end\n    return result\nend", " \
    \   local negatives, positives = {}, {}\n    for i = 1, #lst do\n        if lst[i]\
    \ < 0 then\n            negatives[#negatives + 1] = lst[i]\n        else\n   \
    \         positives[#positives + 1] = lst[i]\n        end\n    end\n    if #negatives\
    \ == 0 and #positives == 0 then\n        return {None, None}\n    end\n    local\
    \ smallest, largest = negatives[1] or 0, positives[#positives] or 0\n    for i\
    \ = 2, #negatives do\n        if negatives[i] < smallest then\n            smallest\
    \ = negatives[i]\n        end\n    end\n    for i = 1, #positives do\n       \
    \ if positives[i] > largest then\n            largest = positives[i]\n       \
    \ end\n    end\n    return {smallest, largest}\nend", "  if not lst:is_table()\
    \ then return {} end\n  local max = {}\n  local min = {}\n  local res = {}\n \
    \ for i, v in ipairs(lst) do\n    if v < 0 then\n      max[i] = v\n    else\n\
    \      min[v] = i\n    end\n  end\n  for _, v in ipairs(lst) do\n    res[min[min(v,\
    \ #min)]] = max(v, max[max(v, #max)])\n  end\n  return res\nend", "  local largest\
    \ = {}\n  local smallest = {}\n  local i = 1\n  for v in lst\n  do\n    largest[#largest\
    \ + 1] = v\n    smallest[#smallest + 1] = v\n    i = i + 1\n    if i > 100 then\n\
    \      break\n    end\n  end\n  if #largest == 0 and #smallest == 0 then\n   \
    \ return {None, None}\n  end\n  for i = 2, #largest do\n    if largest[i] < 0\
    \ and smallest[i] > 0 then\n      largest[i] = largest[i] + largest[i-1]\n   \
    \   smallest[i] = smallest[i] - smallest[i-1]\n    elseif largest[i] < 0 and smallest[i]\
    \ < 0 then\n      largest[i] = largest[i] + largest[i-1]\n      smallest[i] =\
    \ smallest[i] + smallest[i-1]\n    end\n  end\n  return {largest, smallest}\n\
    end", "  local positive = {}\n  local negative = {}\n  for _, value in ipairs(lst)\
    \ do\n    if value < 0 then\n      table.insert(negative, value)\n    else\n \
    \     table.insert(positive, value)\n    end\n  end\n  if #positive > #negative\
    \ then\n    return positive\n  else\n    return negative\n  end\nend", "  local\
    \ biggest, smallest = nil, nil\n  for _, item in ipairs(lst) do\n    if item then\n\
    \      if smallest == nil or item < smallest then\n        smallest = item\n \
    \     end\n      if biggest == nil or item > biggest then\n        biggest = item\n\
    \      end\n    end\n  end\n  if smallest == nil and biggest == nil then\n   \
    \ return nil\n  elseif smallest == nil then\n    return biggest\n  else\n    return\
    \ smallest\n  end\nend", "   assert(type(lst) == \"table\")\n   local large, smallest\
    \ = nil, nil\n   for _, v in ipairs(lst) do\n      if not large or v < large then\n\
    \         largest = largest\n         smallest = smallest\n         largest =\
    \ v\n      else\n         if not smallest or v > smallest then\n            largest\
    \ = v\n         end\n      end\n   end\n   if smallest ~= nil then\n      return\
    \ largest_smallest_integers(lst)\n   end\n   return large\nend", "  local max\n\
    \  if #lst == 0 then\n    return {}\n  else\n    max = lst[1]\n    for i = 2,\
    \ #lst do\n      if lst[i] > max then\n        max = lst[i]\n      end\n    end\n\
    \    return {max, #lst}\n  end\nend", "  local max_value\n  local min_value\n\
    \  for _, value in pairs(lst) do\n    if max_value == nil then\n      max_value\
    \ = value\n    else\n      if value < min_value then\n        min_value = value\n\
    \      end\n      if value == max_value then\n        return nil\n      end\n\
    \    end\n  end\n  if max_value == nil then\n    return nil\n  end\n  if min_value\
    \ == nil then\n    return max_value\n  end\n  -- If the list is exhausted, return\
    \ largest and smallest values\n  if max_value < min_value then\n    return max_value\n\
    \  else\n    return min_value\n  end\nend", "    if lst == nil then return {nil,\
    \ 0}\n    else return max_of_min(lst, function(item) return item end) end\nend",
  "  local max_val = nil\n  local min_val = nil\n  for val in lst do\n    if val <\
    \ 0 then\n      max_val = val\n    elseif val > 0 then\n      min_val = val\n\
    \    end\n  end\n  if max_val == nil then return {nil, nil} end\n  if min_val\
    \ == nil then return {nil, max_val} end\n  return {max_val, min_val}\nend", " \
    \ if type(lst) ~= 'table' then\n    -- Must be an atomic value.\n    if type(lst)\
    \ ~= 'number' then\n      return lst\n    end\n    return { lst = {} }\n  end",
  "  -- Handle empty lists.\n  if #lst==0 then\n    return {{None, None}};\n  elseif\
    \ #lst==1 then\n    local elem = lst[1];\n    return {elem > 0 and {elem, elem}\
    \ or {None, elem}};\n  end", "  if lst == nil then\n    return {nil, nil}\n  end\n\
    \  local max_value = nil\n  local min_value = nil\n  for _, value in ipairs(lst)\
    \ do\n    if min_value == nil then\n      max_value = value\n      min_value =\
    \ value\n    elseif value < min_value then\n      min_value = value\n    end\n\
    \    if value > max_value then\n      max_value = value\n    end\n  end\n  return\
    \ {max_value, min_value}\nend", "  if #lst == 0 then\n    return {None, None}\n\
    \  end\n  local smallest = -(#lst + 1)\n  local largest = #lst\n  local middle_index\n\
    \  for middle_index = #lst / 2 do\n    if smallest > lst[middle_index] then\n\
    \      largest = middle_index - 1\n    elseif smallest < lst[middle_index] then\n\
    \      smallest = middle_index + 1\n    end\n  end\n  return {smallest, largest}\n\
    end", "  local smallest_largest = nil\n  for _, value in ipairs(lst) do\n    if\
    \ smallest_largest == nil then\n      smallest_largest = value\n    else\n   \
    \   smallest_largest = smallest_largest > value and\n                        \
    \   smallest_largest or value\n    end\n  end\n  return smallest_largest, smallest_largest\n\
    end", "  if #lst == 1 then\n    return nil, nil\n  end\n  if #lst == 2 then\n\
    \    return lst[1], lst[1]\n  end\n  local a = lst[1]\n  local b = lst[2]\n  local\
    \ largest\n  local smallest\n  for i = 2, #lst do\n    if a > lst[i] then\n  \
    \    largest, smallest = largest, a\n    elseif a < lst[i] then\n      largest,\
    \ smallest = b, smallest\n    else\n      largest, smallest = a, b\n    end\n\
    \  end\n  if largest == smallest then\n    return largest\n  end\n  return smallest,\
    \ largest\nend", "  local largest, smallest = nil, nil\n  for _, v in ipairs(lst)\
    \ do\n    if v < 0 then\n      if largest == nil then\n        largest = v\n \
    \     else\n        largest = largest\n      end\n    elseif v > 0 then\n    \
    \  if smallest == nil then\n        smallest = v\n      else\n        smallest\
    \ = smallest\n      end\n    end\n  end\n  if smallest == nil and largest == nil\
    \ then\n    return nil\n  end\n  return {largest, smallest}\nend", "  local max_value\
    \ = nil\n  local min_value = nil\n  for i, v in ipairs(lst) do\n    if v > 0 then\n\
    \      if max_value == nil then\n        max_value = v\n        min_value = v\n\
    \      else\n        if v > max_value then\n          max_value = v\n        end\n\
    \        if v < min_value then\n          min_value = v\n        end\n      end\n\
    \    end\n  end\n  if max_value == nil then\n    return {None, None}\n  end\n\
    \  -- Now return a table containing (max_value, min_value)\n  return {max_value,\
    \ min_value}\nend", "  if #lst == 0 then\n    return {None, None}\n  else\n  \
    \  local max_value = lst[1]\n    for i = 2, #lst do\n      if max_value < lst[i]\
    \ then\n        max_value = lst[i]\n      end\n    end\n    if max_value < 0 then\n\
    \      max_value = 0\n    end\n    if max_value >= 0 then\n      return {max_value,\
    \ -max_value}\n    else\n      return {None, None}\n    end\n  end\nend", "  local\
    \ largest, smallest, count = 0, math.inf, 0\n  for i = 1, #lst do\n    if lst[i]\
    \ < smallest then\n      smallest = lst[i]\n    elseif lst[i] > largest then\n\
    \      largest = lst[i]\n    end\n    count = count + 1\n    if count >= 2 then\n\
    \      break\n    end\n  end\n  if smallest == math.inf then\n    return {nil,\
    \ largest}\n  else\n    return {smallest, largest}\n  end\nend", "  if type(lst)\
    \ == \"table\" then\n    local max = lst[1]\n    local min = lst[1]\n    for i\
    \ = 2, #lst do\n      if max < lst[i] then\n        max = lst[i]\n      end\n\
    \      if min > lst[i] then\n        min = lst[i]\n      end\n    end\n    return\
    \ { max = max, min = min }\n  else\n    return { max = lst, min = lst }\n  end\n\
    end", "  local max = -math.inf\n  local min = -math.inf\n  for _, b in ipairs(lst)\
    \ do\n    if b > max then\n      max = b\n    end\n    if b < min then\n     \
    \ min = b\n    end\n  end\n  if max == math.inf or min == -math.inf then\n   \
    \ return {None, None}\n  end\n  return {{max, min}}\nend", "  -- Sort the list\
    \ so we can find the max or min.\n  -- This makes sure we find largest or smallest\
    \ numbers.\n  table.sort(lst)\n  local min = lst[1]\n  local max = lst[1]\n  for\
    \ i = 2, #lst do\n    if min > lst[i] then\n      min = lst[i]\n    end\n    if\
    \ max < lst[i] then\n      max = lst[i]\n    end\n  end\n  return min, max\nend",
  "  if not lst or #lst == 0 then\n    return {None, 1}\n  else\n    local smallest_bigger\
    \ = {}\n    local bigger = {}\n    local max_value = nil\n    for i, v in ipairs(lst)\
    \ do\n      if v > max_value then\n        bigger = {max_value = v}\n      elseif\
    \ v < max_value then\n        smallest_bigger = {max_value = v}\n      else\n\
    \        bigger[i] = v\n      end\n    end\n    return {\n      smallest = smallest_bigger,\n\
    \      largest = bigger\n    }\n  end\nend", "  if lst[1] == nil then\n    return\
    \ {nil, 0}\n  else\n    return {lst[1], math.max(lst[2], lst[3])}\n  end\nend",
  "  -- The return value is a nested table with the following shape\n  -- largest_integers\
    \ {\n  --     {negative integers, positive integers},\n  --     {negative integers,\
    \ positive integers},\n  --     ...\n  --  }\n  -- The smallest negative integer\
    \ is the smallest negative integer in\n  -- any nested table that has at least\
    \ one positive integer. The largest\n  -- positive integer is the largest positive\
    \ integer in any nested table that\n  -- has at least one negative integer. There\
    \ can be any number of nested\n  -- tables.\n  local largest_integer = nil\n \
    \ local smallest_integer = nil\n  for _, value in ipairs(lst) do\n    if value\
    \ <= 0 then\n      largest_integer = nil\n      smallest_integer = nil\n    elseif\
    \ smallest_integer ~= nil then\n      -- The smallest negative integer is the\
    \ smallest negative integer in\n      -- any nested table that has at least one\
    \ positive integer. The largest\n      -- positive integer is the largest positive\
    \ integer in any nested table\n      -- that has at least one negative integer.\
    \ There can be any number\n      -- of nested tables.\n      if value >= smallest_integer\
    \ then\n        largest_integer = nil\n        smallest_integer = nil\n      else\n\
    \        largest_integer = value\n        smallest_integer = nil\n      end\n\
    \    elseif value == 0 then\n      -- If the input list is empty, the largest\
    \ and smallest integers are\n      -- both None. No integers are negative or positive\
    \ in an empty list.\n      largest_integer = None\n      smallest_integer = None\n\
    \    else\n      -- If the input list is empty, the largest and smallest integers\
    \ are\n      -- both None. No integers are negative or positive in an empty list.\n\
    \      largest_integer = None\n      smallest_integer = value\n    end\n  end\n\
    \  if largest_integer ~= nil then\n    -- The largest positive integer is the\
    \ largest positive integer in any\n    -- nested table that has at least one negative\
    \ integer. The largest\n    -- negative integer is the largest negative integer\
    \ in any nested table\n    -- that has at least one positive integer. There can\
    \ be any number of\n    -- nested tables.\n    if smallest_integer ~= nil then\n\
    \      -- The smallest negative integer is the smallest negative integer in\n\
    \      -- any nested table that has at least one positive integer. The largest\n\
    \      -- positive integer is the largest positive integer in any nested table\n\
    \      -- that has at least one negative integer. There can be any number\n  \
    \    -- of nested tables.\n      return {smallest_integer, largest_integer}\n\
    \    else\n      -- The smallest negative integer is the smallest negative integer\
    \ in", "  -- Sort by magnitude (descending)\n  lst = lst:sort(function(a, b)\n\
    \    return b - a end\n  )\n  -- Check that the list contains at least two elements.\n\
    \  if not lst:len() >= 2 then\n    return nil\n  end\n  -- If there are two elements,\
    \ return the largest one.\n  if lst:len() == 2 then\n    return {lst:get(-1, true),\
    \ lst:get(1, true)} -- Get a negative number, and a positive number\n  end\n \
    \ -- Otherwise, find the biggest negative integer, and the smallest positive integer\
    \ in the list.\n  local neg_int, pos_int = lst:get(-1, true), lst:get(1, true)\n\
    \  -- Compare them in reverse order\n  -- If one is a positive number, and the\
    \ other is a negative number, then return the smallest of the two.\n  if pos_int\
    \ > neg_int then\n    return pos_int\n  else\n    return neg_int\n  end\nend",
  "  if #lst == 0 then\n    return {nil, 0}\n  end", "  if #lst == 0 then\n    return\
    \ {None, None}\n  end\n  local biggest = math.max( lst:gmatch(\"%d+\") )\n  local\
    \ smallest = math.min( lst:gmatch(\"%d+\") )\n  return {biggest, smallest}\nend",
  "  local min = nil\n  local max = nil\n  for i, v in ipairs(lst) do\n    if v >=\
    \ 0 then\n      if min == nil then\n        min = v\n      else\n        if v\
    \ < min then\n          min = v\n        end\n      end\n    end\n    if v < 0\
    \ then\n      if max == nil then\n        max = v\n      else\n        if v >\
    \ max then\n          max = v\n        end\n      end\n    end\n  end\n  return\
    \ min, max\nend", "  -- Find the minimum value.\n  local min_val = nil\n  if #lst\
    \ > 0 then\n    min_val = lst[1]\n    for _, val in ipairs(lst) do\n      if val\
    \ ~= min_val then\n        min_val = val\n      end\n    end\n  end", "  local\
    \ min = nil\n  local max = nil\n  for _, v in ipairs(lst) do\n    if min == nil\
    \ then\n      min = v\n      max = v\n      continue\n    end\n    if v < min\
    \ then\n      min = v\n    end\n    if v > max then\n      max = v\n    end\n\
    \  end\n  if min == nil then\n    return {None, None}\n  end\n  if max == nil\
    \ then\n    return {min, nil}\n  end\n  return {min, max}\nend", "  local function\
    \ biggest_integer(t)\n    local biggest_v = nil\n    local smallest_v = nil\n\
    \    for i, v in ipairs(t) do\n      -- Avoid comparing a number to nil.\n   \
    \   if not biggest_v then\n        biggest_v = v\n      elseif v > biggest_v then\n\
    \        biggest_v = v\n      end\n      -- Avoid comparing a number to nil.\n\
    \      if not smallest_v then\n        smallest_v = v\n      elseif v < smallest_v\
    \ then\n        smallest_v = v\n      end\n    end\n    return biggest_v, smallest_v\n\
    \  end\n  -- Avoid comparing a number to nil.\n  if not lst then\n    return nil,\
    \ nil\n  end\n  local biggest_v, smallest_v = biggest_integer(lst)\n  if biggest_v\
    \ then\n    return biggest_v, smallest_v\n  end\n  return nil, nil\nend", "  if\
    \ #lst <= 0 then return {} end\n  local min = (lst[1] < lst[2] and lst[1] or lst[2])\n\
    \  local max = (lst[1] > lst[2] and lst[1] or lst[2])\n  for i = 2, #lst do\n\
    \    local v = (lst[i] < min and lst[i] or min)\n    min = (v < max and v or max)\n\
    \    max = v\n  end\n  return {'None', max}\nend", "  local smallest = nil\n \
    \ local largest = nil", "  if #lst == 0 then\n    return {None, None}\n  elseif\
    \ #lst == 1 then\n    return {lst[1], lst[0]}\n  else\n    local pairs = table.pairs(lst)\n\
    \    local mins = {table.min(pairs, 1, function(pair)\n      return pair[1] <\
    \ 0\n    end), table.min(pairs, 2, function(pair)\n      return pair[1] < 0\n\
    \    end)} -- mins = {1, -1}\n    local maxs = {table.max(pairs, 1, function(pair)\n\
    \      return pair[1] > 0\n    end), table.max(pairs, 2, function(pair)\n    \
    \  return pair[1] > 0\n    end)} -- maxs = {4, 7}\n    local a = mins[1] or maxs[1]\n\
    \    local b = mins[2] or maxs[2]\n    return a and b and {a, b}\n  end -- end\
    \ else\nend -- end function", '  local largest, smallest = nil, nil', "  -- The\
    \ largest integer is always positive, and smaller\n  -- than any negative integer,\
    \ so set it as the largest\n  -- of negative integers, and set smaller to any\
    \ positive\n  -- integer.\n  --\n  -- (If lst is the empty list, we return {None,\
    \ None},\n  -- and do not bother calling this function recursively.)\n  --\n \
    \ -- >>> largest_smallest_integers({})\n  -- {None, None}\n  -- >>> largest_smallest_integers({1,\
    \ 2, 3})\n  -- {1, 3}\n  -- >>> largest_smallest_integers({-5, -4, -3, -2, -1,\
    \ 0, 1, 2, 3, 4})\n  -- {-5, 4}\n  -- >>> largest_smallest_integers({-7, -7})\n\
    \  -- {None, None}\n  -- >>> largest_smallest_integers({-7})\n  -- {-7}\n  --\
    \ >>> largest_smallest_integers({7, 7})\n  -- {7, 7}\n  -- >>> largest_smallest_integers({5,\
    \ -7, -7})\n  -- {7, -7}\n  -- >>> largest_smallest_integers({5, -3, -7})\n  --\
    \ {None, -7}", "  local largest, smallest = nil, nil\n  for i = 1, #lst do\n \
    \   local a = lst[i]\n    if a > largest then largest = a end\n    if a < smallest\
    \ then smallest = a end\n  end\n  return largest, smallest\nend", "  if #lst ==\
    \ 0 then\n    return {None, None}\n  end", "  if #lst == 0 then\n    return nil\n\
    \  end\n  local max_val = lst[1]\n  local min_val = lst[1]\n  for i = 2, #lst\
    \ do\n    if lst[i] > max_val then\n      max_val = lst[i]\n    end\n    if lst[i]\
    \ < min_val then\n      min_val = lst[i]\n    end\n  end\n  if max_val < min_val\
    \ then\n    return nil\n  end\n  return lst.sub(1, #lst + 1)\nend", "  if #lst\
    \ == 0 then\n    return {None, lst[1]}\n  else\n    local smallest, largest =\
    \ lst[1], lst[1]\n    for i = 2, #lst do\n      if lst[i] < smallest then\n  \
    \      smallest = lst[i]\n      end\n      if lst[i] > largest then\n        largest\
    \ = lst[i]\n      end\n    end\n    return {smallest, largest}\n  end\nend", " \
    \ if #lst == 0 then\n    return {None, None}\n  end", '  if not lst then return
    nil end', "    local positive, negative = {}, {}\n    for key, value in pairs(lst)\
    \ do\n        if value < 0 then\n            table.insert(negative, key)\n   \
    \     else\n            table.insert(positive, key)\n        end\n    end\n  \
    \  if not positive and not negative then\n        return {None, None}\n    else\n\
    \        if positive then\n            table.sort(positive)\n        end\n   \
    \     if negative then\n            table.sort(negative)\n        end\n      \
    \  return {\n            positive[#positive - 1] or None,\n            negative[#negative\
    \ - 1] or None,\n        }\n    end\nend", '  local largest, smallest = nil, nil',
  "  local negatives = {}\n  local positives = {}\n  for i = 1, #lst do\n    if lst[i]\
    \ < 0 then\n      table.insert(negatives, i)\n    else\n      table.insert(positives,\
    \ i)\n    end\n  end", "  local function get_max(lst)\n    local max = 0\n   \
    \ local max_idx\n    for i, v in ipairs(lst) do\n      if v > max then\n     \
    \   max = v\n        max_idx = i\n      end\n    end\n    return max, max_idx\n\
    \  end\n  local max, max_idx = get_max(lst)\n  local min = MAX_INT - 1, -1\n \
    \ local min_idx\n  for i, v in ipairs(lst) do\n    if v < min then\n      min\
    \ = v\n      min_idx = i\n    end\n  end\n  if min == MAX_INT then\n    return\
    \ nil\n  elseif max == 0 then\n    return { nil, -1 }\n  else\n    return { max,\
    \ min_idx }\n  end\nend\nlargest_smallest_integers.needs_input = true", "  if\
    \ lst:is_nil() then return {nil, 0}\n  elseif lst:is_number() then\n    local\
    \ smallest = lst.min\n    local largest = lst.max\n    if smallest < 0 then\n\
    \      return nil, {smallest, largest}\n    end\n    if largest > 0 then\n   \
    \   return nil, {smallest, largest}\n    end\n  end\n  local new_lst = {}\n  for\
    \ i, v in ipairs(lst) do\n    new_lst[i] = v\n  end\n  local smallest, largest\
    \ = largest_smallest_integers(new_lst)\n  return new_lst, {smallest, largest}\n\
    end", "  local max_int, min_int = nil, nil\n  for i, elem in ipairs(lst) do\n\
    \    if elem < 0 then\n      max_int = elem\n    elseif elem > 0 then\n      min_int\
    \ = elem\n    end\n  end", "  local max = nil\n  local min = nil\n  for k, v in\
    \ pairs(lst) do\n    if k == nil or v == nil then\n      max = {value = v, key\
    \ = k}\n      min = {value = v, key = k}\n    elseif v > max then\n      max =\
    \ {value = v, key = k}\n    elseif v < min then\n      min = {value = v, key =\
    \ k}\n    end\n  end\n  max = max.key -- If no negative or positive values, return\
    \ None\n  min = min.key\n  if max == min then\n    return {min = min, max = max}\n\
    \  else\n    return {min = min, max = max}\n  end\nend", "  -- if there are no\
    \ integers, return empty table\n  if not lst:isnumber() then\n    return {}\n\
    \  end\n  local largest = nil\n  local smallest = nil\n  for k, v in pairs(lst)\
    \ do\n    if v < 0 then\n      largest = k\n    elseif largest == nil then\n \
    \     smallest = v\n    elseif v > largest then\n      largest = v\n    end\n\
    \  end\n  if largest and smallest then\n    local t = {largest, smallest}\n  \
    \  return t\n  else\n    return {smallest, largest}\n  end\nend", "  if #lst <\
    \ 2 then\n    return nil\n  elseif #lst == 1 then\n    return lst\n  else\n  \
    \  -- This works by finding the maximum of the first two\n    -- numbers, then\
    \ finding the minimum of the next two\n    -- numbers, then updating the maximum.\n\
    \    -- The update works by swapping the numbers if they are out of order\n  \
    \  -- and then taking the minimum of the two.\n    local a, b, max_a = lst[1],\
    \ lst[2], lst[1]\n    local c, d, max_c = lst[2], lst[3], lst[2]\n    max_b =\
    \ max_c\n    if a < c then\n      if b < d then\n        max_b = d\n        max_c\
    \ = c\n      else\n        max_b = b\n        max_c = a\n      end\n    elseif\
    \ b < d then\n      if a < c then\n        max_b = a\n        max_c = c\n    \
    \  else\n        max_b = b\n        max_c = d\n      end\n    else\n      max_b\
    \ = b\n      max_c = d\n    end", "  local function cmp(lhs, rhs)\n    if lhs\
    \ < rhs then return -1 end\n    if lhs > rhs then return 1 end\n    return 0\n\
    \  end\n  -- Sort list, and pick out largest and smallest items.\n  -- If there\
    \ are none, return them as None.\n  local max = nil\n  local min = nil\n  table.sort(lst,\
    \ cmp)\n  if #lst > 0 then\n    max = lst[#lst]\n    min = lst[1]\n  else\n  \
    \  max = nil\n    min = nil\n  end\n  return max, min\nend", "    local smallest\
    \ = nil\n    local largest = nil\n    for i = 1, #lst do\n        local n = lst[i]\n\
    \        if n < smallest then\n            smallest = n\n        end\n       \
    \ if n > largest then\n            largest = n\n        end\n    end\n    return\
    \ smallest, largest\nend", "  local largest = nil\n  local smallest = nil\n  for\
    \ i, value in ipairs(lst) do\n    if value == nil then\n      largest = smallest\n\
    \      smallest = value\n      break\n    end\n    if value < smallest then\n\
    \      largest = value\n    elseif value > smallest then\n      smallest = value\n\
    \    end\n  end\n  return largest, smallest\nend", "  if lst == nil then\n   \
    \ return {nil, nil}\n  end", "  local smallest = -math.inf\n  local largest =\
    \ math.inf\n  for _, value in ipairs(lst) do\n    smallest, largest = math.min(smallest,\
    \ value), math.max(largest, value)\n  end\n  if smallest < math.inf and largest\
    \ > -math.inf then\n    return smallest, largest\n  end\n  return nil, nil\nend",
  '  if #lst == 0 then return {None, None} end', "  local smallest, largest = nil,\
    \ -1\n  for _, v in ipairs(lst) do\n    if v < smallest then\n      smallest =\
    \ v\n    end\n    if v > largest then\n      largest = v\n    end\n  end\n  if\
    \ smallest == nil then\n    return nil\n  end\n  return { smallest, largest }\n\
    end", "  -- Find largest and smallest in list\n  local largest, smallest = lst[1],\
    \ lst[1]\n  for i = 2, #lst do\n    if lst[i] > largest then\n      largest =\
    \ lst[i]\n    elseif lst[i] < smallest then\n      smallest = lst[i]\n    end\n\
    \  end", "  local largest, smallest = nil, nil -- The largest and smallest positive\
    \ and negative numbers in the input.\n  local maxint = 0 -- the largest integer\n\
    \  local minint = -1 -- the smallest integer\n  for i = 1, #lst do\n    -- If\
    \ this is an integer number, ignore if it's negative or zero and continue to next\
    \ number\n    -- If this is not a integer number, this must be a negative/zero\
    \ number. Set it to zero and continue\n    -- The loop stops when i reaches the\
    \ end of the list\n    -- If maxint is negative, then largest, smallest and minint\
    \ must be positive.\n    if tonumber(lst[i]) ~= nil then\n      if maxint == 0\
    \ then\n        maxint = tonumber(lst[i])\n      else\n        maxint = maxint\
    \ > tonumber(lst[i]) and maxint or tonumber(lst[i])\n      end\n      minint =\
    \ minint > tonumber(lst[i]) and minint or tonumber(lst[i])\n    end\n  end\n \
    \ if maxint > 0 then\n    -- If there are any negative integers, make largest\
    \ and smallest positive\n    largest = maxint + 1\n    smallest = minint - 1\n\
    \  else\n    -- If there are no negative integers, make largest and smallest positive\n\
    \    largest = minint + 1\n    smallest = maxint - 1\n  end\n  return largest,\
    \ smallest\nend", "  local largest_numbers = {}\n  local smallest_numbers = {}\n\
    \  -- For every positive integer:\n  for i = 1, #lst do\n    -- If the number\
    \ is negative, put it in the smallest_numbers\n    if lst[i] < 0 then\n      smallest_numbers[#smallest_numbers\
    \ + 1] = lst[i]\n    -- If the number is positive, put it in the largest_numbers\n\
    \    else\n      largest_numbers[#largest_numbers + 1] = lst[i]\n    end\n  end\n\
    \  -- Return None if no negative numbers\n  if #smallest_numbers == 0 then\n \
    \   return {None, #largest_numbers}\n  -- Return None if no positive numbers\n\
    \  elseif #largest_numbers == 0 then\n    return {#smallest_numbers, None}\n \
    \ end\n  -- Return the largest numbers\n  return {largest_numbers, smallest_numbers}\n\
    end", "  if #lst == 0 then\n    return {None, None}\n  end", "   local tbl = {}\n\
    \   local last_negative = 0\n   local last_positive = 0\n   for _, value in ipairs(lst)\
    \ do\n      if value < 0 then\n         tbl[last_negative] = value\n         last_negative\
    \ = last_negative + 1\n      else\n         tbl[last_positive] = value\n     \
    \    last_positive = last_positive + 1\n      end\n   end\n   if last_negative\
    \ > last_positive then\n      return tbl\n   else\n      local t = {}\n      local\
    \ i = 0\n      while i < last_negative do\n         t[i] = tbl[i]\n         i\
    \ = i + 1\n      end\n      i = 1\n      while i < last_positive do\n        \
    \ t[i] = tbl[i]\n         i = i + 1\n      end\n      return t\n   end\nend",
  "  if #lst < 1 then return {} end\n  local smallest_int = nil\n  local max_int =\
    \ nil\n  local pos = 1\n  for pos, value in ipairs(lst) do\n    if value < 0 then\n\
    \      if smallest_int == nil then smallest_int = pos end\n      max_int = pos\n\
    \    elseif value == 0 then\n      if smallest_int == nil then smallest_int =\
    \ pos end\n    end\n  end\n  if smallest_int ~= nil and max_int ~= nil then\n\
    \    smallest_int, max_int = max_int, smallest_int\n  else\n    smallest_int =\
    \ max_int\n  end\n  return {smallest_int, max_int}\nend", "  -- Sort the list\
    \ from largest to smallest.\n  local lst = lst.sort()", '    local min_val, max_val
    = nil, nil', "    local min_value = nil\n    local max_value = nil\n    for i,\
    \ v in pairs(lst) do\n        if min_value == nil then\n            min_value\
    \ = v\n            max_value = v\n        else\n            if v < min_value then\n\
    \                min_value = v\n            end\n            if v > max_value\
    \ then\n                max_value = v\n            end\n        end\n    end\n\
    \    if min_value == nil then\n        return {None, min_value}\n    elseif max_value\
    \ == nil then\n        return {min_value, None}\n    end\n    return {min_value,\
    \ max_value}\nend", "  if #lst < 2 then return {None} end\n  local largest = nil\n\
    \  local smallest = nil\n  for i = 1, #lst do\n    if lst[i] > largest then\n\
    \      largest = lst[i]\n    elseif lst[i] < smallest then\n      smallest = lst[i]\n\
    \    end\n  end\n  if smallest == largest then return {None} end\n  return largest,\
    \ smallest\nend", "  -- If the table is empty, return None instead of an empty\
    \ table.\n  -- This is to prevent unnecessary memory allocations.\n  if lst:len()\
    \ == 0 then\n    return {None, None}\n  end\n  local min = table.minimum(lst)\n\
    \  local max = table.maximum(lst)\n  if min < 0 and max > 0 then\n    -- If the\
    \ minimum is negative and the maximum is positive,\n    -- return that as the\
    \ largest of negative and positive integers.\n    return min\n  elseif min > 0\
    \ and max > 0 then\n    -- If the minimum is positive and the maximum is positive,\n\
    \    -- return that as the smallest of negative and positive integers.\n    return\
    \ max\n  elseif min > 0 and max < 0 then\n    -- If the minimum is negative and\
    \ the maximum is negative,\n    -- return None as the smallest of negative and\
    \ positive integers.\n    return {None, None}\n  elseif min < 0 and max < 0 then\n\
    \    -- If the minimum is positive and the maximum is negative,\n    -- return\
    \ None as the largest of negative and positive integers.\n    return {None, None}\n\
    \  end\nend", "  local is_positive, min_negative = true, false\n  for i = 1, #lst\
    \ do\n    if is_positive and lst[i] < 0 then return nil end\n    if not is_positive\
    \ and lst[i] > 0 then return nil end\n    if min_negative and lst[i] < min_negative\
    \ then min_negative = lst[i] end\n    is_positive, min_negative = false, true\n\
    \  end\n  return is_positive and min_negative or nil\nend", "  local m = nil\n\
    \  if lst == nil then return { nil, nil } end\n  for i = 1, #lst do\n    if lst[i]\
    \ > m then\n      m = lst[i]\n    end\n  end\n  return { m, lst[#lst] }\nend",
  "    local result = {}\n    for key, value in pairs(lst) do\n        if value <=\
    \ 0 or value >= 1 then\n            result[key] = nil\n        else\n        \
    \    result[key] = value\n        end\n    end\n    return result\nend\n</cell>\n\
    <cell>", "   if #lst < 1 then return {nil, 0} end\n   local big = lst[1]\n   local\
    \ small = lst[1]\n   for _, v in ipairs(lst) do\n      if v < 0 then\n       \
    \  small = v\n      elseif v > big then\n         big = v\n      end\n   end\n\
    \   return {big, small}\nend", "  if lst.size == 0 then\n    return {None, None}\n\
    \  elseif lst:isnumber() then\n    return {{-math.floor(-lst), math.ceil(lst)},\
    \ nil}\n  else\n    local result = {}\n    local max_negative = -math.floor(-lst)\
    \ + 1\n    local min_positive = math.ceil(lst)\n    for _, v in pairs(lst) do\n\
    \      local max_negative = math.max(max_negative, v)\n      local min_positive\
    \ = math.min(min_positive, v)\n      result[max_negative] = min_positive\n   \
    \ end\n    return result\n  end\nend", "    local min = 0\n    local max = 0\n\
    \    for _, value in ipairs(lst) do\n        if value ~= nil then\n          \
    \  if value < min then\n                min = value\n            elseif value\
    \ > max then\n                max = value\n            end\n        end\n    end\n\
    \    if min > max then\n        return nil, max\n    else\n        return min,\
    \ nil\n    end\nend", "  if type(lst) == \"table\" then\n    local max_val = 0\n\
    \    local min_val = math.max(1, lst[1])\n    for i = 2, #lst do\n      local\
    \ val = lst[i]\n      if val > max_val then max_val = val end\n      if val <\
    \ min_val then min_val = val end\n    end\n    if max_val == min_val then return\
    \ {} end\n    return {max_val = max_val, min_val = min_val}\n  else\n    if lst\
    \ == nil then return {} end\n    return {max_val = lst, min_val = 1}\n  end\n\
    end", "  if not lst then return {nil, nil} end\n  local largest, smallest = nil,\
    \ nil\n  for i = 1, #lst do\n    local _, val = unpack(lst:sort(function(a, b)\
    \ return a < b end))\n    if not largest or val > largest then\n      largest\
    \ = val\n    else if val < smallest then\n      smallest = val\n    end\n  end\n\
    \  if smallest == nil and largest == nil then\n    largest, smallest = None, None\n\
    \  end\n  return largest, smallest\nend", "  if #lst == 0 then\n    return {None,\
    \ None}\n  end\n  local result = {}\n  local max_negative, min_positive, n = 0,\
    \ nil, 0\n  for _, x in pairs(lst) do\n    -- Handle negative and positive integers\
    \ separately\n    if x < 0 then\n      max_negative = x or max_negative\n    else\n\
    \      min_positive = x or min_positive\n    end\n    table.insert(result, x)\n\
    \    n = n + 1\n    if n == 1 then\n      -- Return the largest negative integer\
    \ if there are no negative\n      -- or positive integers\n      if not max_negative\
    \ or max_negative < 0 then\n        return {max_negative, min_positive}\n    \
    \  end\n      -- Return the smallest positive integer if there are no negative\n\
    \      -- or positive integers\n      if not min_positive or min_positive > 0\
    \ then\n        return {min_positive, max_negative}\n      end\n    end\n  end\n\
    \  -- Return both negative and positive integers, in the appropriate order\n \
    \ if max_negative < min_positive then\n    if max_negative > min_positive then\n\
    \      return {max_negative, min_positive}\n    else\n      return {min_positive,\
    \ max_negative}\n    end\n  else\n    if max_negative > min_positive then\n  \
    \    return {min_negative, max_positive}\n    else\n      return {min_positive,\
    \ max_negative}\n    end\n  end\nend", "  if #lst == 0 then\n    return nil\n\
    \  end", "  if not lst then\n    return {None, None}\n  elseif #lst == 0 then\n\
    \    return {None, None}\n  end", "    local function find(v, t)\n        local\
    \ i = 0\n        while i < #t do\n            local k = t[i]\n            if v\
    \ == nil or k < v then\n                v = k\n            else\n            \
    \    break\n            end\n            i = i + 1\n        end\n        return\
    \ v\n    end\n    local function f()\n        local t = {}\n        local max_value,\
    \ max_index = nil, -1\n        for i = 1, #lst do\n            local v = lst[i]\n\
    \            if v >= 0 then\n                if max_value == nil or v > max_value\
    \ then\n                    max_value, max_index = v, i\n                end\n\
    \            end\n        end\n        if max_value == nil then\n            return\
    \ {nil, -1}\n        else\n            local v = {max_value}\n            insert(t,\
    \ max_index)\n            return v\n        end\n    end\n    return f()\nend",
  "  local max_pos = nil\n  local max_neg = nil\n  for i = 1, #lst do\n    if lst[i]\
    \ > 0 then\n      if max_pos == nil then\n        max_pos = i\n      else\n  \
    \      if max_pos < i then\n          max_pos = i\n        end\n      end\n  \
    \  else\n      if max_neg == nil then\n        max_neg = i\n      else\n     \
    \   if max_neg > i then\n          max_neg = i\n        end\n      end\n    end\n\
    \  end\n  \n  if max_neg ~= nil and max_pos ~= nil then\n    return { max_pos,\
    \ max_neg }\n  else\n    return nil\n  end\nend", "    if #lst == 0 then\n   \
    \     return {None, None}\n    end", "    local function check(x, y)\n       \
    \ if x < y then\n            return x\n        end\n        return y\n    end\n\
    \    local max_val\n    local min_val\n    for _, v in ipairs(lst) do\n      \
    \  if max_val == nil or v > max_val then\n            max_val = v\n        end\n\
    \        if min_val == nil or v < min_val then\n            min_val = v\n    \
    \    end\n    end\n    if max_val == nil or min_val == nil then\n        return\
    \ {nil, nil}\n    end\n    return {max_val, min_val}\nend", "  if #lst == 0 then\
    \ return {None, None} end\n  local max_i = 1\n  local min_i = 0\n  local i = 1\n\
    \  -- Find the maximum number in a list\n  while lst[i] <= 0 do\n    if i > max_i\
    \ then\n      max_i = i\n    end\n    i = i + 1\n  end\n  -- Find the minimum\
    \ number in a list\n  while lst[i] > 0 do\n    if i < min_i then\n      min_i\
    \ = i\n    end\n    i = i + 1\n  end\n  -- Return table of max and min\n  if max_i\
    \ > min_i then\n    return {max_i, min_i}\n  else\n    return {None, None}\n \
    \ end\nend", "  local max_val = nil\n  local min_val = nil\n  for _, v in ipairs(lst)\
    \ do\n    if v < 0 then\n      if max_val == nil then\n        max_val = v\n \
    \     else\n        max_val = max_val * -1\n      end\n    elseif v > 0 then\n\
    \      if min_val == nil then\n        min_val = v\n      else\n        min_val\
    \ = min_val * -1\n      end\n    end\n  end\n  return {max_val, min_val}\nend",
  "    local max_value\n    local min_value\n    for _, value in ipairs(lst) do\n\
    \        if value < 0 then\n            if min_value == nil then\n           \
    \     min_value = value\n                max_value = value\n            else\n\
    \                min_value = min_value < value ? min_value : value\n         \
    \       max_value = max_value > value ? max_value : value\n            end\n \
    \       else\n            if max_value == nil then\n                max_value\
    \ = value\n                min_value = value\n            else\n             \
    \   max_value = max_value > value ? max_value : value\n                min_value\
    \ = min_value < value ? min_value : value\n            end\n        end\n    end\n\
    \    return {max_value, min_value}\nend", "  -- Only accept lists.\n  if type(lst)\
    \ ~= 'table' then\n    return\n  end\n  -- Return one element if we have no integers,\
    \ two elements if we do, and a\n  -- table otherwise.\n  if #lst == 0 then\n \
    \   local a, b\n    if a ~= nil then\n      b = a\n      a = nil\n    else\n \
    \     b = nil\n    end\n    return {a, b}\n  end", "  if #lst == 0 then\n    return\
    \ {None, None}\n  end", "  if #lst > 0 then\n    local min = nil\n    local max\
    \ = nil\n    for _, v in pairs(lst) do\n      if v ~= nil then\n        if min\
    \ == nil or v < min then\n          min = v\n        end\n        if max == nil\
    \ or v > max then\n          max = v\n        end\n      end\n    end\n    return\
    \ {min, max}\n  else\n    return {nil, nil}\n  end\nend", "  -- Based on the implementation\
    \ at http://www.lua.org/pil/14.1.html\n  -- See also: http://wiki.lua-users.org/wiki/SortedMaps\n\
    \  local max = {}\n  local min = {}\n  for k, v in pairs(lst) do\n    local ln\
    \ = tonumber(k)\n    if ln > 0 then\n      table.insert(max, k)\n      if ln <\
    \ max then\n        table.insert(min, ln)\n      end\n    else\n      table.insert(min,\
    \ k)\n      if ln < min then\n        table.insert(max, ln)\n      end\n    end\n\
    \  end", "    local smallest, largest, pos\n    local function find_min(a, b)\n\
    \        if b < a then return b else return a end\n    end\n    for _, v in ipairs(lst)\
    \ do\n        if smallest == nil then smallest = v else if v < smallest then smallest\
    \ = v end\n        if largest == nil then largest = v else if v > largest then\
    \ largest = v end\n        if v > 0 then pos = pos + 1 end\n    end\n    if smallest\
    \ == nil then return nil end\n    return find_min(largest, smallest - 1)\nend",
  "  local largest = nil\n  local smallest = nil\n  for _, v in ipairs(lst) do\n \
    \   if v > largest then\n      largest = v\n    elseif v < smallest then\n   \
    \   smallest = v\n    end\n  end\n  if smallest == nil or largest == nil then\n\
    \    return nil, nil\n  end\n  return largest, smallest\nend", '  if lst:len()
    == 0 then return {None, None} end', "  -- If there are 0 or 1 integers, return\
    \ them as None so that the\n  -- result is a table of size 1 where that element\
    \ contains None.\n  if #lst == 1 then return { lst = lst, a = None } end\n  --\
    \ Scan the list, breaking ties with largest positive integers.\n  local max_val\
    \ = 0\n  local max_i = 1\n  local last_i = 2\n  for i = 1, #lst do\n    -- Abort\
    \ if there is no integer larger than the current value.\n    if lst[i] > max_val\
    \ then\n      max_val = lst[i]\n      max_i = last_i\n    end\n    last_i = i\n\
    \  end\n  -- Scan the list, breaking ties with smallest negative integers.\n \
    \ local min_val = -math.MAX_VALUE\n  local min_i = last_i\n  for i = 1, #lst do\n\
    \    -- Abort if there is no integer smaller than the current value.\n    if lst[i]\
    \ < min_val then\n      min_val = lst[i]\n      min_i = i\n    end\n  end\n  --\
    \ Return the largest or smallest integers.\n  return { lst = lst, a = max_i, b\
    \ = min_i }\nend", "  local max\n  local min\n  if type(lst) == 'table' then\n\
    \    max = lst[1]\n    min = lst[2]\n  elseif #lst == 0 then\n    return {None,\
    \ None}\n  else\n    max = lst[1] or lst[#lst]\n    min = lst[2] or lst[#lst]\n\
    \  end\n  local i = 1\n  for i = 2, #lst do\n    if max < lst[i] then\n      max\
    \ = lst[i]\n    end\n    if min > lst[i] then\n      min = lst[i]\n    end\n \
    \ end\n  if min < -#lst and max > #lst then\n    return {min+max/2, max}\n  end\n\
    \  if min >= -#lst and max < #lst then\n    return {min+max/2, min}\n  end\n \
    \ if max > #lst then\n    return {max, min}\n  end\nend", "  if #lst < 2 then\
    \ return {nil, -1} end\n  local largest = unpack(lst)[1]\n  local smallest = unpack(lst)[2]\n\
    \  if smallest < 0 then\n    for i = 1, #lst do\n      if largest*10+lst > smallest*10+i\
    \ then\n        largest = i\n        smallest = i\n      end\n    end\n  end\n\
    \  if smallest > largest+1 then\n    for i = 1, #lst do\n      if lst - i > largest*10\
    \ + smallest then\n        largest = i\n      end\n    end\n  end\n  if smallest\
    \ == -1 then\n    return {nil, -1}\n  end\n  return largest, smallest\nend", " \
    \ if #lst > 1 then\n    local max_negative, min_positive\n    for i=1,#lst do\n\
    \      if lst[i] > 0 then\n        local positive = lst[i]\n        if positive\
    \ > 0 then\n          max_negative = max_negative or positive\n        elseif\
    \ positive < 0 then\n          min_positive = min_positive or positive\n     \
    \   else\n          -- No positive integers\n          max_negative = nil\n  \
    \        min_positive = nil\n          break\n        end\n      end\n    end\n\
    \    return { max_negative, min_positive }\n  else\n    return { nil, nil } --\
    \ No negative or positive integers\n  end\nend", "  if type(lst) ~= 'table' then\n\
    \    return {None, None}\n  end\n  local maxima = {}\n  local minimas = {}\n \
    \ for i = 1, #lst do\n    if maxima[lst[i]] == nil then\n      maxima[lst[i]]\
    \ = i\n    elseif maxima[lst[i]] > i then\n      table.insert(minimas, maxima[lst[i]])\n\
    \      maxima[lst[i]] = i\n    end\n  end\n  if #minimas == 0 then\n    return\
    \ {None, None}\n  end\n  table.sort(minimas)\n  if #minimas == 1 then\n    return\
    \ {minimas[1], maxima[minimas[1]]}\n  end\n  local min = minimas[1]\n  local max\
    \ = maxima[min]\n  local res = {}\n  for i = 2, #minimas do\n    table.insert(res,\
    \ max)\n    max = maxima[max]\n  end\n  table.insert(res, max)\n  return res\n\
    end", "  if lst:is_empty() then\n    return {\n      nil,\n      nil,\n    }\n\
    \  else\n    if type(lst[1]) == \"number\" then\n      return {\n        lst[1],\n\
    \        lst[1],\n      }\n    else\n      return {\n        math.max(lst[1],\
    \ lst[2]),\n        math.min(lst[1], lst[2]),\n      }\n    end\n  end\nend",
  "   -- Sort the list in reverse order.\n   table.sort(lst, function(a, b) return\
    \ a > b end)", "  local function is_negative(v)\n    return (type(v) == 'number'\
    \ and v < 0)\n  end\n  local function get_min(v)\n    if is_negative(v) then return\
    \ -v end\n    return v\n  end\n  local function get_max(v)\n    if is_negative(v)\
    \ then return v end\n    return -v\n  end\n  local min_v = nil\n  local max_v\
    \ = nil\n  -- Use an iterator to avoid unbounded memory growth\n  for i, v in\
    \ ipairs(lst) do\n    -- Update 'min_v' if necessary\n    if min_v == nil or get_min(v)\
    \ < min_v then\n      min_v = v\n    end\n    -- Update 'max_v' if necessary\n\
    \    if max_v == nil or get_max(v) > max_v then\n      max_v = v\n    end\n  end\n\
    \  -- Return the smallest/largest value\n  if min_v == nil and max_v == nil then\n\
    \    return {nil, nil}\n  else\n    return {min_v, max_v}\n  end\nend", "  local\
    \ max_negative = nil\n  local min_positive = nil", "  if #lst == 0 then\n    return\
    \ {None, None}\n  end\n  local max_value = max_of_list(lst)\n  local min_value\
    \ = min_of_list(lst)\n  local result = {}\n  for _, value in ipairs(lst) do\n\
    \    table.insert(result, max_value < value < min_value or\n                 \
    \   value == max_value or value == min_value or\n                    value is\
    \ nil or value == nil)\n  end\n  return result\nend", "  -- Initialize a table\
    \ with None values.\n  local t = {}\n  for i = 1, #lst do\n    t[lst[i]] = nil\n\
    \  end\n  -- Find the largest negative number, and the smallest positive number.\n\
    \  -- Return the largest negative number, and the smallest positive number.\n\
    \  local largest = -math.max(1, #t)\n  local smallest = math.min(#t)\n  -- Return\
    \ the largest negative number and the smallest positive number.\n  return t[largest],\
    \ t[smallest]\nend", "   local positive, negative = {}, {}\n   for i = 1, #lst\
    \ do\n      if lst[i] > 0 then\n         table.insert(positive, i)\n      else\n\
    \         table.insert(negative, i)\n      end\n   end\n   if #positive < #negative\
    \ then\n      -- Return the largest negative integer.\n      return positive[#positive]\n\
    \   else\n      -- Return the smallest positive integer.\n      return negative[#negative]\n\
    \   end\nend", "  if #lst < 1 then return {} end\n  local m = lst[1]\n  for i\
    \ = 2, #lst do\n    if m < lst[i] then m = lst[i] end\n  end\n  assert(#lst ==\
    \ 1, \"The input list is not sorted\")\n  return {'None', m}\nend", "  local lst\
    \ = lst or {}\n  local min, max = nil, nil\n  for _, x in ipairs(lst) do\n   \
    \ if x >= 0 and x < min then\n      min = x\n    end\n    if x <= 0 and max ~=\
    \ nil then\n      max = x\n    end\n  end\n  if min == nil and max == nil then\n\
    \    return {nil, nil}\n  else\n    return {min, max}\n  end\nend", "  local result\
    \ = {\n      a = nil,\n      b = nil,\n  }\n  for i = 1, #lst do\n    local _,\
    \ a, b, c = unpack(lst)\n    if a < 0 then\n      result.a = a\n    elseif b <\
    \ 0 then\n      result.b = b\n    else\n      if result.a ~= nil and result.b\
    \ ~= nil and result.a > result.b then\n        result.a = result.b\n      else\n\
    \        result.b = b\n      end\n    end\n  end\n  return result\nend", "  --\
    \ Return empty table if none are defined.\n  if not lst\n  then\n    return {{},\
    \ {}}\n  end\n  -- Return empty tables if there is only one element in the list.\n\
    \  if #lst == 1\n  then\n    return {{}, {}}\n  end\n  -- If the first element\
    \ in the list is a positive integer, then we\n  -- can return it.\n  if type(lst[1])\
    \ == \"number\"\n  then\n    return {{lst[1]}, {}}\n  end\n  -- Otherwise, if\
    \ there's only negative integers in the list, then\n  -- there's no largest or\
    \ smallest integer in the list, and so return\n  -- empty tables.\n  if #lst >\
    \ 0 and all((type(lst[i]) == \"number\") and lst[i] < 0 for i = 1, #lst)\n  then\n\
    \    return {{}, {}}\n  end\n  -- If the first element in the list is a negative\
    \ integer, then we\n  -- can return it.\n  if type(lst[1]) == \"number\"\n  then\n\
    \    return {{}, {-lst[1]}}\n  end\n  -- Otherwise, if there's only positive integers\
    \ in the list, then\n  -- there's no largest or smallest integer in the list,\
    \ and so return\n  -- empty tables.\n  if #lst > 0 and all((type(lst[i]) == \"\
    number\") and lst[i] > 0 for i = 1, #lst)\n  then\n    return {{}, {}}\n  end\n\
    \  -- Finally, if there's only zero in the list, just return empty tables.\n \
    \ if #lst == 0\n  then\n    return {{}, {}}\n  end\n  -- We know there will be\
    \ negative integers or positive integers\n  -- from the previous tests.\n  --\
    \ If the smallest negative integer is less than the smallest positive\n  -- integer,\
    \ then we have a negative integer as the largest positive\n  -- integer. Otherwise,\
    \ if the smallest negative integer is greater\n  -- than the smallest positive\
    \ integer, then we have a positive\n  -- integer as the largest negative integer.\
    \ Otherwise, no integers are\n  -- negative. Finally, if there are no negative\
    \ integers, return them as\n  -- None (to indicate no largest negative integer\
    \ exists).\n  local min_neg_ind = #lst\n  local max_pos_ind = #lst\n  local min_neg\n\
    \  local max_pos\n  if #lst > 0 and lst[1] < lst[1]\n  then\n    min_neg_ind =\
    \ 1\n    min_neg = lst[1]\n  else\n    min_neg_ind = 1\n    min_neg = 0\n  end\n\
    \  if #lst > 0 and lst[#lst - 1] > lst[#lst - 1]\n  then\n    max_pos_ind = #lst\
    \ - 1\n    max_pos = lst[#lst - 1]\n  else", "  if #lst == 0 then return {} end\n\
    \  local smallest = -math.infinity\n  local largest = math.infinity\n  for k,\
    \ v in pairs(lst) do\n    if v < smallest then\n      largest = v\n    elseif\
    \ v > largest then\n      smallest = v\n    end\n  end\n  return {smallest, largest}\n\
    end", "  if #lst == 0 then return {} end\n  local smallest = nil\n  local largest\
    \ = nil\n  for i = 1, #lst do\n    if smallest==nil then\n      smallest = lst[i]\n\
    \      largest = lst[i]\n    else\n      if lst[i] < smallest then smallest =\
    \ lst[i] end\n      if lst[i] > largest then largest = lst[i] end\n    end\n \
    \ end\n  if smallest and smallest ~= 0 then\n    return {smallest, largest}\n\
    \  else\n    return {nil, largest}\n  end\nend", "  local function get_max(lst)\n\
    \    if #lst == 0 then\n      return nil\n    end\n    local max = lst[1]\n  \
    \  for i = 2, #lst do\n      if max < lst[i] then\n        max = lst[i]\n    \
    \  end\n    end\n    return max\n  end\n  local function get_min(lst)\n    if\
    \ #lst == 0 then\n      return nil\n    end\n    local min = lst[1]\n    for i\
    \ = 2, #lst do\n      if min > lst[i] then\n        min = lst[i]\n      end\n\
    \    end\n    return min\n  end", "  local result = {}\n  local first = true\n\
    \  for i = 1, #lst do\n    local value = lst[i]\n    if value < 0 then\n     \
    \ if first then\n        table.insert(result, value)\n      else\n        table.insert(result,\
    \ -value)\n      end\n    else\n      first = false\n    end\n  end\n  return\
    \ result\nend", "   if #lst == 0 then\n      return {nil, 0}\n   elseif #lst ==\
    \ 1 then\n      return {lst[1], lst[1]}\n   else\n      local negative = {}\n\
    \      local positive = {}\n      local largest = {}\n      local smallest = {}\n\
    \      for i = 1, #lst do\n         local num = lst[i]\n         if num < 0 then\n\
    \            table.insert(negative, num)\n         elseif num > 0 then\n     \
    \       table.insert(positive, num)\n         else\n            table.insert(largest,\
    \ num)\n         end\n      end\n      for i = 1, #negative do\n         local\
    \ num = negative[i]\n         if #smallest == 0 then\n            smallest = num\n\
    \         else\n            if num < smallest then\n               smallest =\
    \ num\n            end\n         end\n      end\n      for i = 1, #positive do\n\
    \         local num = positive[i]\n         if #largest == 0 then\n          \
    \  largest = num\n         else\n            if num > largest then\n         \
    \      largest = num\n            end\n         end\n      end\n      return {largest,\
    \ smallest}\n   end\nend", '  if #lst == 0 then return {nil, 0} end', "  local\
    \ min_negative = nil\n  local min_positive = nil\n  local max_negative = nil\n\
    \  local max_positive = nil\n  for i = 1, #lst do\n    local elt = lst[i]\n  \
    \  if elt < 0 then\n      min_negative = elt if min_negative == nil or min_negative\
    \ > elt end\n    elseif elt > 0 then\n      min_positive = elt if min_positive\
    \ == nil or min_positive < elt end\n    else\n      -- do nothing\n    end\n \
    \   if elt > 0 then\n      max_positive = elt if max_positive == nil or max_positive\
    \ > elt end\n    elseif elt < 0 then\n      max_negative = elt if max_negative\
    \ == nil or max_negative < elt end\n    end\n  end\n  return {\n    positive =\
    \ min_positive or max_positive,\n    negative = min_negative or max_negative\n\
    \  }\nend", "    local function is_negative(tbl)\n        for _, val in ipairs(tbl)\
    \ do\n            if val < 0 then return true end\n        end\n        return\
    \ false\n    end\n    local function is_positive(tbl)\n        for _, val in ipairs(tbl)\
    \ do\n            if val > 0 then return true end\n        end\n        return\
    \ false\n    end\n    local positives, negatives = {}, {}\n    for val in lst\
    \ do\n        if is_negative(negatives) or is_positive(positives) then\n     \
    \       table.insert(negatives, val)\n        else\n            table.insert(positives,\
    \ val)\n        end\n    end\n    if #negatives > 0 then\n        return {\n \
    \           positives = positives,\n            negatives = negatives\n      \
    \  }\n    else\n        return {\n            positives = positives,\n       \
    \     negatives = nil\n        }\n    end\nend", "  return lst\n  --[[\n    local\
    \ function largest_smallest_integers_helper(lst)\n      return function(...)\n\
    \        if lst == nil then\n          return {nil, nil}\n        end\n      \
    \  local min_i, max_i = unpack(lst)\n        if min_i < 0 or max_i > 0 then\n\
    \          lst = nil\n        else\n          lst = nil\n        end\n       \
    \ return max_i, min_i\n      end\n    end", "  if lst.size == 0 then\n    return\
    \ {None, None}\n  elseif lst.size == 1 then\n    return {lst[1], lst[0]}\n  else\n\
    \    local small, large, max = lst[1], lst[2], lst[1]\n    for _, i in ipairs(lst)\
    \ do\n      if i > max then\n        max = i\n      elseif i < small then\n  \
    \      small = i\n      else\n        large = i\n      end\n    end\n    return\
    \ {large, small}\n  end\nend", "  if #lst == 0 then\n    return {nil, 0}\n  end\n\
    \  local largest, smallest = nil, nil -- Initialize to non-nil values.\n  for\
    \ i = 1, #lst do\n    if lst[i] > largest or largest == nil then\n      largest\
    \ = lst[i]\n    end\n    if lst[i] < smallest or smallest == nil then\n      smallest\
    \ = lst[i]\n    end\n  end\n  if largest == nil then\n    return {nil, smallest}\n\
    \  end\n  if smallest == nil then\n    return {largest, nil}\n  end\n  return\
    \ {largest, smallest}\nend", "  if lst:is_empty() then\n    return {}\n  else\n\
    \    -- Sort the list, largest to smallest, to get the largest integer\n    --\
    \ and then find the smallest integer to that value.\n    local sorted_list = lst:sort()\n\
    \    local largest_integer = sorted_list[1]\n    local smallest_integer = sorted_list[-1]\n\
    \    -- If the largest integer is smaller than the smallest integer,\n    -- then\
    \ return two nil values.\n    -- This is because if there are no negative integers\
    \ or no positive\n    -- integers, there won't be a pair of values that will sort\
    \ to the same\n    -- value.\n    if largest_integer < smallest_integer then\n\
    \      return { nil, nil }\n    else\n      -- The largest integer is larger than\
    \ the smallest integer,\n      -- so the smallest integer is the largest integer.\n\
    \      return { largest_integer, smallest_integer }\n    end\n  end\nend", " \
    \ local max_int_values = {}\n  local max_int = -1\n  local min_int = nil", " \
    \ local largest = nil\n  local smallest = nil\n  for _, v in ipairs(lst) do\n\
    \    if largest == nil then\n      largest = v\n      smallest = v\n    elseif\
    \ v < smallest then\n      largest = v\n    end\n  end\n  if largest and smallest\
    \ then\n    return {largest, smallest}\n  else\n    return {largest, None}\n \
    \ end\nend", "  if lst == nil then\n    return nil\n  elseif next(lst) == nil\
    \ then\n    return {None, lst[1]}\n  else\n    local first = next(lst)\n    if\
    \ first < 0 then\n      return {lst[1], first}\n    else\n      local second =\
    \ first\n      while second < lst[1] do\n        second = next(lst)\n      end\n\
    \      return {first, second}\n    end\n  end\nend", "  if #lst == 0 then\n  \
    \  return nil\n  end\n  local largest = nil\n  local smallest = nil\n  for i =\
    \ 1, #lst do\n    local value = lst[i]\n    if value < 0 then\n      if largest\
    \ == nil then\n        largest = value\n      else\n        largest, smallest\
    \ = largest, value\n      end\n    else\n      if smallest == nil then\n     \
    \   smallest = value\n      else\n        largest, smallest = smallest, value\n\
    \      end\n    end\n  end\n  return largest, smallest\nend", "  if #lst == 0\
    \ then return {None, None} end\n  local min = lst[1]\n  local max = lst[1]\n \
    \ for i = 2, #lst do\n    if lst[i] > max then max = lst[i] end\n    if lst[i]\
    \ < min then min = lst[i] end\n  end\n  return { min = min, max = max }\nend",
  "  if next(lst) == nil then\n    return nil\n  end\n  local negative, positive =\
    \ 1, 0\n  for i = 1, #lst do\n    if lst[i] < 0 then\n      negative = negative\
    \ - 1\n    elseif lst[i] > 0 then\n      positive = positive + 1\n    end\n  end\n\
    \  return negative, positive\nend\n</cell>\n<text>\nNow we have the required function\
    \ in place, we just need to put it together with table functions to get the desired\
    \ results. In the following code example, I first create a table with numbers\
    \ and apply the largest_smallest_integers() function to the table. Then I convert\
    \ the table to JSON. The final result is stored in the variable results.", " \
    \ -- First find the smallest positive integer\n  local smallest = nil\n  for i\
    \ = 0, #lst do\n    if lst[i] < smallest then\n      smallest = lst[i]\n    end\n\
    \  end\n  -- Now find the largest negative integer\n  local largest = nil\n  for\
    \ i = 0, #lst do\n    if lst[i] > largest then\n      largest = lst[i]\n    end\n\
    \  end\n  return largest, smallest\nend", "  local result = {}\n  for _, v in\
    \ ipairs(lst) do\n    local small, large = nil, nil\n    for _, i in ipairs(lst)\
    \ do\n      if v < i and v ~= nil then\n        small = i\n      elseif v <= i\
    \ and v ~= nil then\n        large = v\n      end\n    end\n    result[#result\
    \ + 1] = large or small\n  end\n  return result\nend", "  if lst:size() == 0 then\n\
    \    return {None, None}\n  end", "  if #lst == 0 then\n    return {None, None}\n\
    \  end", "  local result = {}\n  for i = 1,#lst do\n    if lst[i] < 0 then\n \
    \     result[#result+1] = nil\n    elseif lst[i] > 0 then\n      result[#result+1]\
    \ = lst[i]\n    end\n  end\n  if #result == 0 then\n    result[1] = nil\n  end\n\
    \  return result\nend", "  if not lst then\n    return nil\n  end\n  local max_integer\
    \ = lst.max_integer or nil\n  local min_integer = lst.min_integer or nil\n  local\
    \ result = {}\n  for i = 1, #lst do\n    if max_integer >= lst[i] then\n     \
    \ table.insert(result, lst[i])\n    else\n      table.insert(result, max_integer)\n\
    \      table.insert(result, min_integer)\n    end\n  end\n  table.insert(result,\
    \ max_integer)\n  table.insert(result, min_integer)\n  return result\nend", " \
    \ if #lst == 0 then\n    return {None, None}\n  end\n  local min_int = #lst\n\
    \  for i = 1, #lst do\n    if lst[i] > min_int then\n      min_int = lst[i]\n\
    \    end\n  end\n  return {min_int, max_int}\nend", '  local smallest, largest
    = nil, nil', "  if not lst then\n    return {None, None}\n  end", "  local smallest_int\n\
    \  local max_int\n  for _, item in ipairs(lst) do\n    if item > max_int then\
    \ max_int = item end\n    if item < smallest_int then smallest_int = item end\n\
    \  end\n  if smallest_int ~= nil and max_int ~= nil then\n    return {smallest_int,\
    \ max_int}\n  else\n    return {nil, nil}\n  end\nend", "  if not lst then return\
    \ {} end\n  if type(lst) == \"table\" then\n    if #lst > 0 then\n      local\
    \ m = math.max(unpack(lst))\n      local n = math.min(unpack(lst))\n      local\
    \ result = {}\n      for i = 1, #lst do\n        local v = lst[i]\n        if\
    \ v < m then\n          result[i] = v\n        elseif v > n then\n          result[i]\
    \ = v\n        end\n      end\n      return result\n    end\n  end\nend", "  if\
    \ #lst <= 0 then\n    return nil\n  end", "    local max_negative, min_positive\
    \ = nil, nil\n    for _, x in ipairs(lst) do\n        if x < 0 then\n        \
    \    if max_negative == nil then\n                max_negative = x\n         \
    \   else\n                max_negative = max_negative..x\n            end\n  \
    \      else\n            if min_positive == nil then\n                min_positive\
    \ = x\n            else\n                min_positive = min_positive..x\n    \
    \        end\n        end\n    end\n    if max_negative ~= nil and min_positive\
    \ ~= nil then\n        return {max_negative, min_positive}\n    end\n    return\
    \ {None, None}\nend", "  if #lst == 0 then\n    return {None, None}\n  else\n\
    \    local max_value = nil\n    local min_value = nil\n    local i = 0\n    for\
    \ k, v in pairs(lst) do\n      if k ~= nil then\n        if max_value == nil or\
    \ v > max_value then\n          max_value, min_value = v, k\n        end\n   \
    \   end\n      i = i + 1\n    end\n    if i == 0 then\n      return {None, None}\n\
    \    end\n  end\nend", "   if #lst == 0 then\n      return {None, None}\n   end\n\
    \   local max_val\n   local min_val\n   local max_i\n   local min_i\n   for i\
    \ = 1, #lst do\n      if max_val == nil then\n         max_val = lst[i]\n    \
    \     max_i = i\n      else\n         if lst[i] > max_val then\n            max_val\
    \ = lst[i]\n            max_i = i\n         end\n      end\n      if min_val ==\
    \ nil then\n         min_val = lst[i]\n         min_i = i\n      else\n      \
    \   if lst[i] < min_val then\n            min_val = lst[i]\n            min_i\
    \ = i\n         end\n      end\n   end\n   return {max_i, min_i}\nend", "  if\
    \ not lst then\n    return {None, None}\n  end", "  local max_num, is_max = nil,\
    \ false\n  local min_num, is_min = nil, false\n  for k, v in ipairs(lst) do\n\
    \    if v > 0 then\n      if not is_max then\n        is_max = true\n        max_num\
    \ = v\n      elseif v > max_num then\n        max_num = v\n      end\n    else\n\
    \      if not is_min then\n        is_min = true\n        min_num = v\n      elseif\
    \ v < min_num then\n        min_num = v\n      end\n    end\n  end\n  if is_max\
    \ then\n    return nil, min_num\n  elseif is_min then\n    return nil, max_num\n\
    \  else\n    return {max_num, min_num}\n  end\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
