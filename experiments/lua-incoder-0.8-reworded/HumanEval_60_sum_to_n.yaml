name: HumanEval_60_sum_to_n
language: lua
prompt: "-- sum_to_n is a function that sums numbers from 1 to n.\n-- >>> sum_to_n(30)\n\
  -- 465\n-- >>> sum_to_n(100)\n-- 5050\n-- >>> sum_to_n(5)\n-- 15\n-- >>> sum_to_n(10)\n\
  -- 55\n-- >>> sum_to_n(1)\n-- 1\nlocal function sum_to_n(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sum_to_n\n\
  \    lu.assertEquals(candidate(1), 1)\n    lu.assertEquals(candidate(6), 21)\n \
  \   lu.assertEquals(candidate(11), 66)\n    lu.assertEquals(candidate(30), 465)\n\
  \    lu.assertEquals(candidate(100), 5050)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if n == 1 then return 1 end\n  return n + sum_to_n(n - 1)\nend",
  "  if n == 0 then return 1 end\n  local n1 = n\n  local n2 = 1\n  while n1 ~= 0\
    \ do\n    n1, n2 = n2, n1 + n2\n  end\n  return n2\nend\n</cell>\n<text>\n\u0417\
    \u0430\u0434\u0430\u043D\u0438\u0435 #2\n\u0414\u0430\u043D \u0442\u0435\u043A\
    \u0441\u0442, \u043A\u043E\u0442\u043E\u0440\u044B\u0439 \u0441\u043E\u0434\u0435\
    \u0440\u0436\u0438\u0442 \u0441\u043B\u043E\u0432\u043E \u0442\u0440\u0451\u0445\
    \u043C\u0435\u0440\u043D\u043E\u0433\u043E \u0440\u0430\u0441\u043F\u043B\u043E\
    \u044F\u043D\u0438\u044F. \u0421\u043B\u043E\u0432\u043E \u0442\u0440\u0451\u0445\
    \u043C\u0435\u0440\u043D\u043E\u0433\u043E \u0440\u0430\u0441\u043F\u043B\u043E\
    \u044F\u043D\u0438\u044F \u0437\u0430\u0434\u0430\u0451\u0442\u0441\u044F \u0441\
    \u043B\u0435\u0434\u0443\u044E\u0449\u0438\u043C \u043E\u0431\u0440\u0430\u0437\
    \u043E\u043C: \u043A\u043E\u0440\u043F\u0443\u0441 (\u043A\u043E\u043F\u0435\u0439\
    \u043A\u0430) \u043C\u0435\u043D\u044F\u0435\u0442\u0441\u044F \u0441\u043B\u043E\
    \u0432\u043E \u0438 \u0442\u043E\u0436\u0435 \u0441\u043B\u043E\u0432\u043E. \u041F\
    \u0435\u0440\u0435\u0432\u043E\u0434\u0438\u0442\u0441\u044F \u043D\u0430 \u0431\
    \u0443\u043A\u0432\u0443 \u0442\u0440\u0451\u0445\u043C\u0435\u0440\u043D\u043E\
    \u0433\u043E \u0440\u0430\u0441\u043F\u043B\u043E\u044F\u043D\u0438\u044F. \u0412\
    \u0435\u0440\u043D\u0438\u0442\u0435\u0441\u044C, \u0447\u0442\u043E \u0432\u0441\
    \u0435 \u0440\u0430\u0431\u043E\u0442\u0430\u0435\u0442 \u0443\u0441\u043F\u0435\
    \u0448\u043D\u043E, \u0438 \u0432\u044B\u0432\u0435\u0434\u0438\u0442\u0435 \u0431\
    \u0443\u043A\u0432\u0443 \u0442\u0440\u0451\u0445\u043C\u0435\u0440\u043D\u043E\
    \u0433\u043E \u0440\u0430\u0441\u043F\u043B\u043E\u044F\u043D\u0438\u044F.", " \
    \ if n <= 1 then return n\n  else\n    -- if n > 1 then we need to get sum of\
    \ numbers from 2 to n-1\n    -- this can be easily achieved by using sum_to_n(n-1)\
    \ function\n    -- but then we get to the heart of the matter\n    -- here we\
    \ are summing all the numbers from 1 to n except for one\n    -- (n-1) which is\
    \ n*(n+1)/2\n    -- e.g. if n = 7 then (n-1)*(n+1)/2 = 21\n    -- therefore we\
    \ have to sum all the numbers except for n and (n-1)\n    -- e.g. sum_to_n(6)\
    \ = 24 + 3\n    --\n    -- now we come to the heart of the matter as to why this\
    \ is correct\n    -- this is because of two reasons\n    -- 1. This is the case\
    \ if n is even and we have to add up all the numbers\n    -- except for one (n-1)\n\
    \    -- 2. This is the case if n is odd and we have to add up all the numbers\n\
    \    -- except for one (n-1)\n    -- therefore we return (n-1)*(n-1)/2\n    --\n\
    \    -- so if n is even then (n-1)*(n-1)/2 = 2*(n-1)\n    -- if n is odd then\
    \ (n-1)*(n-1)/2 = 2*(n-1)+1\n    --\n    -- therefore we get\n    -- if n is even\
    \ then (n-1)*(n-1)/2 = 2*(n-1)+1\n    -- if n is odd then (n-1)*(n-1)/2 = 2*(n-1)+2\n\
    \    --\n    -- therefore the answer is 2*(n-1)+1 = n-1\n    --\n    -- this is\
    \ just a little trick I learned in high school so I am not\n    -- sure if this\
    \ is the best way to explain this concept to you guys\n    -- feel free to comment\
    \ and let me know\n    -- but for now this is the best way I know\n    return\
    \ sum_to_n(n-1) + n-1\n  end\nend", "  if n == 0 then\n    error(\"n must be positive\"\
    )\n  end\n  local result = 0\n  for i = 1,n do\n    local n = i\n    local count\
    \ = 1\n    while n > 1 do\n      n = n-1\n      count = count + 1\n    end\n \
    \   if i == 1 then\n      result = count * (count-1)\n    end\n  end\n  return\
    \ result\nend", "  return math.floor(n * math.log(n, 2)) + math.floor(n / math.log(n,\
    \ 2))\nend", "    local total = 1\n    for i = 2, n do\n        total = total\
    \ + i\n    end\n    return total\nend", "  if n < 0 then\n    error('n must be\
    \ non-negative')\n  end\n  return math.pow(math.e, n)\nend", "  return math.ceil(math.log(n,\
    \ 2)) + 1 or n\nend", "\tif n <= 0 then\n\t\treturn 1\n\tend\n\tlocal s = 0\n\t\
    while n > 0 do\n\t\ts = s + 1\n\t\tn = n - 1\n\tend\n\treturn s\nend", "  if n\
    \ < 0 then error(\"n cannot be negative\") end\n  if n == 0 then return 0 end\n\
    \  local count = 0\n  repeat\n    count = count + 1\n  until n > count\n  return\
    \ count\nend", "    local s = 1;\n    for i = 1, n do\n        s = s + i;\n  \
    \  end\n    return s;\nend", "    if n == 0 then\n        return 1\n    end\n\
    \    if n < 0 then\n        error(\"integer argument expected, got \" .. tostring(n))\n\
    \    end\n    local function inner_sum(n)\n        if n == 1 then\n          \
    \  return 1\n        else\n            return n + inner_sum(n-1)\n        end\n\
    \    end\n    return inner_sum(n) + inner_sum(n-1)\nend", "  n = n or 0\n  return\
    \ function(...)\n    local a, b = ...\n    if a ~= nil then\n      return a +\
    \ sum_to_n(n-1) + b\n    elseif b ~= nil then\n      return a + sum_to_n(n-1)\
    \ + b\n    end\n    return a\n  end\nend\n</code>\nAnd then:\n<code>", "  local\
    \ s = 0\n  repeat\n    s = s + 1\n  until not n or s > n\n  return s\nend", " \
    \ -- The result is guaranteed to be less than or equal to n.\n  -- Think about\
    \ it: you could have a faster algorithm that produced the right result \n  --\
    \ without actually summing up all the numbers. \n  -- So this is actually an optimization\
    \ applied to the algorithm, not an explicit \n  -- requirement.\n  -- The return\
    \ value is guaranteed to be less than or equal to n.", "  -- sum the first n natural\
    \ numbers\n  -- e.g. sum_to_n(3) = 1 + 2 + 3\n  -- e.g. sum_to_n(100) = 1 + 2\
    \ + 3 + ... + 100\n  return math.floor(math.pow(n, n + 1) / 2.0)\nend", "  if\
    \ n < 1 then return 1 end\n  return n + sum_to_n(n-1)\nend", "\tlocal s = sum_to_n_impl(n)\n\
    \treturn function(n)\n\t\treturn s()\n\tend\nend", "  -- If n is negative, return\
    \ 1 instead of 0.\n  if n < 0 then return 1 end\n  \n  -- Compute the sum of the\
    \ numbers 1 through n.\n  local function sum(n)\n    if n == 0 then return 0 end\n\
    \    \n    -- Return the sum of the numbers from 1 to n.\n    return n + sum(n-1)\n\
    \  end\n  \n  -- Return the sum of the numbers from 1 to n.\n  return sum(n)\n\
    end", "  if n == 1 then\n    return 1\n  end\n  local n1 = n - 1\n  local sum\
    \ = 0\n  for i = 1, n1 do\n    sum = sum + i\n  end\n  return sum\nend\n</cell>\n\
    <text>\nExercise 10: Recursive functions\nWrite a function that, given a string,\
    \ returns a new string. The new string is the concatenation of all the letters\
    \ in the string.\nFor example, if the input string is \"hello\", the returned\
    \ string should be \"hheelllloo\".", "  local nn = n or 0\n  local sum = 0\n \
    \ for i = 1, n do\n    sum = sum + i\n  end\n  return sum\nend", "  if n < 1 then\
    \ return 0 end\n  local sum = 1\n  for i = 1, n do\n    sum = sum + i\n  end\n\
    \  return sum\nend", "  return math.floor(math.pow(math.floor(n), 2)) + 1\nend",
  "  return math.floor(math.pow(10, math.floor(math.log10(n)) + 1)) * (n - 1) + 1\n\
    end", "  if n > 0 then\n    return n + sum_to_n(n - 1)\n  end\n  return 1\nend",
  "  -- base case\n  if n == 1 then\n    return 1\n  end", "  if n <= 1 then\n   \
    \ return 1\n  end\n  return 1 + sum_to_n(n-1)\nend", "\tif n == 0 then\n\t\treturn\
    \ 1\n\tend", "  if n == 1 then return 1 end\n  return n * sum_to_n(n - 1)\nend",
  "  -- Return 0 if n < 1.\n  return 0 when n < 1 else math.ceil(math.log(n, 2)) +\
    \ sum_to_n(n-1)\nend", "  return n and math.floor(math.pow(10, math.log10(n))\
    \ - math.pow(10, math.log10(math.pow(10, n))) / math.pow(10, n))\nend", "    if\
    \ n <= 1 then\n        return 1\n    end\n    if n % 2 == 0 then\n        return\
    \ sum_to_n(n - 1) + sum_to_n(n - 2)\n    else\n        return sum_to_n(n - 1)\n\
    \    end\nend", "  return math.floor(n / 2) + math.floor((n - math.floor(n / 2))\
    \ / 2)\nend", "  if n == 0 then\n    return 1\n  else\n    return 1 + sum_to_n(n\
    \ - 1)\n  end\nend", "    local function helper(n, acc)\n        if n <= 0 then\n\
    \            return acc\n        else\n            return helper(n - 1, acc +\
    \ 1)\n        end\n    end\n    return helper(n, 0)\nend", "    if n == 1 then\
    \ return 1 end\n    local x = 0\n    for i = 1, n do\n        x = x + i\n    end\n\
    \    return x\nend", "  local sum = 0\n  for i = 1, n do\n    sum = sum + i\n\
    \  end\n  return sum\nend", "  return function()\n    local s = 0 and 1 or 0\n\
    \    local i = 1\n    while i <= n do\n      i = i + 2\n      s = s + i\n    end\n\
    \    return s\n  end\nend", "  -- If n is less than or equal to one, return 1.\n\
    \  return n <= 1 and 1 or n * sum_to_n(n - 1)\nend\n</cell>\n<text>\nExercise:\
    \ Using your sum_to_n function, write a function that checks if a number is divisible\
    \ by 3.", "    if n == 1 then return 1 end\n    return n + sum_to_n(n - 1)\nend",
  "  if n == 1 then\n    return 1\n  else\n    return n + sum_to_n(n - 1)\n  end\n\
    end", "  local s, t\n  if n == 1 then\n    s, t = 1, 1\n  elseif n == 0 then\n\
    \    return 0\n  else\n    s, t = n, 0\n  end\n  local i\n  for i = 2, s do\n\
    \    t = t + i\n  end\n  return t\nend", "  if n < 1 then\n    return 0\n  else\n\
    \    return n + sum_to_n(n - 1)\n  end\nend", "  if n == 1 then\n    return 1\n\
    \  else\n    return n * sum_to_n(n-1)\n  end\nend", "    if n < 0 then\n     \
    \   return 0\n    end\n    \n    local sum = 0\n    for i = 1, n do\n        sum\
    \ = sum + i\n    end\n    return sum\nend", "\tlocal i = 0\n\tlocal sum = 0\n\t\
    while i < n do\n\t\tsum = sum + i\n\t\ti = i + 1\n\tend\n\treturn sum\nend", " \
    \ return math.floor(math.exp2(math.log10(1 + math.pow(2, n - 1))))\nend", "  return\
    \ n + sum_to_n(n-1)\nend\n</cell>\n<text>\nsum_to_n is called with the argument\
    \ 30, which returns 465.\nLet's call it again, this time with the argument 100:",
  "  if n == 1 then return 1 else return n * sum_to_n(n - 1) end\nend", "    if n\
    \ <= 0 then\n        return 0\n    end\n    if n < 0 then\n        error(\"sum_to_n\
    \ only takes positive numbers\")\n    end", "\tlocal result = 0\n\tlocal i = -1\n\
    \twhile i < n do\n\t\tresult = result + i\n\t\ti = i + 1\n\tend\n\treturn result\n\
    end", "  local s = 0.0\n  for _ = 1, n do\n    s = s + 1\n  end\n  return s\n\
    end", "  if n == 1 then\n    return 1\n  end\n  if n <= 0 then\n    return 0\n\
    \  end\n  return n + sum_to_n(n - 1)\nend", "\tlocal sum = 0\n\tfor i = 1, n do\n\
    \t\tsum = sum + i\n\tend\n\treturn sum\nend", "\tif n < 1 then return 1 end\n\t\
    local n1 = n\n\tlocal n2 = 1\n\tlocal n3 = n\n\tlocal n4 = 1\n\twhile n1 <= n4\
    \ do\n\t\tn2 = n2 + 1\n\t\tn3 = n3 * n\n\t\tn4 = n4 + 1\n\tend\n\treturn n2\n\
    end", "  if n == 0 then\n    return 0\n  end\n  local sum = 0\n  local limit =\
    \ #sum_to_n(n) + 1\n  for i = 1, limit do\n    sum = sum + i\n  end\n  return\
    \ sum\nend\n</code>\n<|/ a |>\n<| a dscore=1 tags=haskell,functional-programming\
    \ |>\n<code>\nimport Data.List", "    return function()\n        local n = n +\
    \ 1\n        if n <= 0 or math.floor(n) ~= n then\n            return nil\n  \
    \      else\n            return n\n        end\n    end\nend", "  local sum =\
    \ 0\n  for i = 1, n do\n    sum = sum + i\n  end\n  return sum\nend", "  local\
    \ sum = 0\n  for i = 1, n do\n    sum = sum + i\n  end\n  return sum\nend", " \
    \   return math.max(math.floor(math.pow(math.exp(n) - 1, 2)) + 1, n)\nend", " \
    \ if n == 1 then return 1 end\n  return n*(n-1)/2\nend", "  if n <= 0 then\n \
    \   return 0\n  end", "    return math.floor(math.pow(n, 1 / 3) - 2)\nend", " \
    \ if n == 1 then\n    return 1\n  else\n    return n * sum_to_n(n - 1)\n  end\n\
    end", "  if n <= 0 then\n    return 1\n  else\n    local sum\n    for i = 1, n\
    \ do\n      sum = sum + i\n    end\n    return sum\n  end\nend", "    local sum\
    \ = 0\n    for i=1,n do\n        sum=sum+i\n    end\n    return sum\nend", " \
    \ -- The sum is computed using an algorithm that uses successive approximations:\n\
    \  --\n  --     let mu be the largest number less than or equal to n (the starting\
    \ value).\n  --     let mu be the largest number less than or equal to n (the\
    \ starting value).\n  --     while mu < n, mu += mu\n  --     mu is the sum of\
    \ the two largest numbers less than or equal to n.\n  --\n  --     To find the\
    \ sum of an arithmetic progression, just add the first two terms\n  --     together,\
    \ then repeatedly multiply the two sums by the difference between them,\n  --\
    \     and add that product to the total. The two terms are sum_to_n(n) and n.\n\
    \  --\n  --     Let mu be the largest number less than or equal to n (the starting\
    \ value).\n  --     let mu be the largest number less than or equal to n (the\
    \ starting value).\n  --     mu += n\n  --     while mu < n, mu += mu\n  --\n\
    \  --     mu is the sum of the two largest numbers less than or equal to n.\n\
    \  --\n  --     Return the sum mu.\n  --\n  --     Implementing sum_to_n is more\
    \ complicated than just adding a few terms to\n  --     the running sum until\
    \ it's large enough; it involves doubling up the\n  --     difference between\
    \ two numbers until it's large enough.\n  --\n  --     It takes about O(log n)\
    \ multiplications to do the summation, so it's not\n  --     terribly efficient.\
    \ But it is at least asymptotically efficient.\n  --\n  -- The code below uses\
    \ successive approximations to add the first two terms as\n  -- sum_to_n(3), then\
    \ doubles the difference and adds it to sum_to_n(4) until mu\n  -- is large enough.\
    \ After that, it uses successive approximations to add the\n  -- remaining terms,\
    \ doubling the difference until mu is large enough, and so on.\n  -- The second\
    \ half of the loop can therefore be omitted.\n  -- The code is left as an exercise\
    \ for the reader.\n  if n <= 0 then return 1 end\n  -- The first term is the sum\
    \ of the first two terms of sum_to_n.\n  local mu = sum_to_n(n)\n  -- The second\
    \ term is the sum of the remainder of sum_to_n divided by two.\n  mu = mu + sum_to_n(n\
    \ / 2)\n  -- Add two successive approximations of sum_to_n until mu is large enough.\n\
    \  while mu < n do\n    mu = mu + sum_to_n(2 * mu)\n  end\n", "  if n < 1 then\n\
    \    return n\n  else\n    return sum_to_n(n-1) + n\n  end\nend", "  if n < 1\
    \ then\n    return 0\n  elseif n == 1 then\n    return 1\n  else\n    return n\
    \ + sum_to_n(n - 1)\n  end\nend", "  return math.min(math.max(n, 1), math.pow(2,\
    \ 32))\nend", "  local i = 0\n  local s = 0\n  while i <= n do\n    s = s + i\n\
    \    i = i + 1\n  end\n  return s\nend", "  return function () \n    return 1\
    \ + sum_to_n(n-1)()\n  end\nend", "    local s = 0\n    for i = 1, n do s = s\
    \ + i end\n    return s\nend", "  if n <= 0 then return 0 end\n  if n == 1 then\
    \ return 1 end\n  return n*(n+1)/2\nend", "  return math.sum(map(i, sequence(math.max(0,\
    \ n - 1))))\nend\n</cell>\n<cell>", "  if n <= 0 then\n    return 0\n  end\n \
    \ return n + sum_to_n(n - 1)\nend", "  if n == 0 then\n    return 0\n  elseif\
    \ n == 1 then\n    return 1\n  end\n  return n * sum_to_n(n - 1)\nend\n</cell>\n\
    <text>\nLet's try it out!", "  return n and (n + sum_to_n(n - 1))\nend", "\tlocal\
    \ s = tonumber(os.date(\"*t\"))\n\tlocal f = ((n - 1) / n) + 1\n\tlocal i = 1\n\
    \twhile i <= f do\n\t\tlocal n = i + 1\n\t\tlocal f0 = ((n - 1) / n) + 1\n\t\t\
    local f1 = ((n - 1) / n) + 1\n\t\ts = s + i\n\t\ti = i + 1\n\tend\n\treturn s\n\
    end", "  return (n * n) + 1\nend", "  local acc = 0\n  for i = 1, n do\n    acc\
    \ = acc + i\n  end\n  return acc\nend", "  if n <= 0 then return 1 end\n  return\
    \ n * sum_to_n(n - 1)\nend", "  return math.floor(math.pow(10, math.log10(n))\
    \ + math.log(n))\nend\nreturn sum_to_n\n\"\"\"", "    local s = 0\n    while n\
    \ > 0 do\n        s = s + n\n        n = n - 1\n    end\n    return s\nend", "\t\
    -- Initialize total\n\tlocal total = 0\n\t\n\t-- Perform the loop\n\tfor i = 1,\
    \ n do\n\t\t-- Add the next number to the total\n\t\ttotal = total + i\n\tend",
  "  return math.floor(n / 2) + math.mod(n, 2)\nend\n</cell>\n<cell>", "  return math.ceil(n/10)\
    \ * 10\nend", "  return function(x)\n    if x ~= nil then\n      return x + sum_to_n(n-1)(x)\n\
    \    end\n  end\nend\nreturn sum_to_n(math.max(0,n))(n) + 1;", "  if n < 0 then\n\
    \    error('sum_to_n only accepts non-negative integers')\n  end\n  return math.floor((n\
    \ + 1):div(10) + 1)\nend", "  if n <= 0 then\n    return 0\n  else\n    local\
    \ i = 0\n    local s = 0\n    while i < n do\n      s = s + i\n      i = i + 1\n\
    \    end\n    return s\n  end\nend", "  return math.floor(math.ceil(math.log(n,\
    \ 2)) + 1)\nend", "  return math.min(n,math.floor(n/2) + 1)\nend", "    return\
    \ math.floor( math.pow( 10, n ) ) * ( math.pow(10, n) - math.pow(10, n - 1) )\
    \ / math.pow( 10, n - 1 )\nend", "    local s = 0\n    for i = 1, n do\n     \
    \   s = s + i\n    end\n    return s\nend", "  if n <= 1 then\n    return 1\n\
    \  end", "  return math.pow(math.exp(n), 1.0 / n)\nend", "  return tonumber(ffi.string(gw_lib.sum_to_n_string(n,\
    \ ffi.new(\"char *\", [1]))))\nend\nreturn sum_to_n", "  if n == 0 then\n    return\
    \ 1\n  else\n    return n + sum_to_n(n - 1)\n  end\nend", "  if n > 0 then\n \
    \   return n + sum_to_n(n - 1)\n  end\nend", "  return math.floor(n * (math.log(n)\
    \ + math.log(2) - math.log(n))) + math.pow(n, 2) -- The + math.pow(n, 2) is for\
    \ rounding\nend", "    if n < 1 then return 1 end\n    return n * sum_to_n(n -\
    \ 1)\nend", "  if n == 0 then\n    return 0\n  elseif n == 1 then\n    return\
    \ 1\n  else\n    return n + sum_to_n(n - 1)\n  end\nend", "  if n < 0 then\n \
    \   n = 0\n  elseif n > 1000 then\n    n = 1000\n  end\n  local ns = n - 1\n \
    \ return function(t)\n    return t^3 * ns / (t + 1) + 1\n  end\nend", "  local\
    \ s = \"\"\n  for i = 1, n do\n    s = s .. tostring(i) .. \" \"\n  end\n  return\
    \ s\nend", "  if n == 1 then\n    return 1\n  end\n  return n + sum_to_n(n - 1)\n\
    end", "  local i = 0\n  while i <= n do\n    -- Add i to sum\n    sum = sum +\
    \ i\n    -- Add i to n\n    n = n - 1\n    -- If n is 0, break and return the\
    \ sum\n    if n == 0 then\n      break\n    end\n    -- If i is 0, set i to one\n\
    \    if i == 0 then\n      i = 100000000\n    end\n  end\n  return sum\nend",
  "  local s = 0\n  for i = 1, n do\n    s = s + i\n  end\n  return s\nend", "  if\
    \ n == 1 then\n    return 1\n  end\n  return n * sum_to_n(n - 1)\nend", "  if\
    \ n > 0 then\n    return n + sum_to_n(n - 1)\n  end\n  return n\nend", "  local\
    \ sum = 0\n  for _ = 1, n do\n    sum = sum + math.random()\n  end\n  return sum\n\
    end", "   local s = 0\n   if n > 0 then\n      for i = 1, n do\n         s = s\
    \ + i\n      end\n   end\n   return s\nend", "  local function helper()\n    if\
    \ n <= 1 then return n end\n    return helper() + helper(n - 1)\n  end\n  return\
    \ helper()\nend", "    local total = 0\n    for i = 1, n do\n        total = total\
    \ + i\n    end\n    return total\nend", "  if n <= 0 then\n    return 0\n  end\n\
    \  if n == 2 then\n    return 1\n  end\n  if n == 1 then\n    return 1\n  end\n\
    \  return n + sum_to_n(n - 2)\nend", "  if n <= 0 then return 0 end\n  if n ==\
    \ 1 then return 1 end\n  return n + sum_to_n(n - 1)\nend", "\tlocal n = 1\n\t\
    while n <= n do\n\t\tn = n + n\n\tend\n\treturn n\nend", "  if n < 0 then return\
    \ 0 end\n  return n * (n + 1) / 2\nend", "    if n < 1 then return 1 end\n   \
    \ local function add_and_sum(n)\n        local s = sum_to_n(n-1)\n        return\
    \ s + n\n    end\n    return add_and_sum(n)\nend", "  if n == 0 then\n    return\
    \ 1\n  else\n    return n + sum_to_n(n-1)\n  end\nend", "  local n = 1\n  local\
    \ total = 0\n  while n <= n do\n    total = total + n\n    n = n + 1\n  end\n\
    \  return total\nend", "  if n == 0 then\n    return 1\n  else\n    return n +\
    \ sum_to_n(n - 1)\n  end\nend", "  return math.floor((n - (n % 2 == 0 and 1 or\
    \ 2))/2) * 3\nend", "  -- Haskell has lazy evaluation, so we need to force evaluation\
    \ of the sum here.\n  return n and math.floor(math.pow(math.floor(n), n))\nend",
  "  local sum = 0\n  for i = 1, n do\n    sum = sum + i\n  end\n  return sum\nend",
  "  local sum = 0\n  for i = 1, n do\n    sum = sum + i\n  end\n  return sum\nend",
  "  local s = 0 -- initialize sum\n  while n > 0 do\n    s, n = s, s + 1 -- increment\
    \ sum\n  end\n  return s\nend", "  local s = \"\"\n  repeat\n    s = string.rep(\"\
    1..\", n-1) + s -- Add numbers from 1 to n to s.\n    -- When n = 10, s = 11..\n\
    \  until string.sub(s,-1,-1) ~= \"..\"\n  -- Return the sum of the digits in the\
    \ string.\n  return tonumber(s)\nend", "    if n < 0 then\n        return 0\n\
    \    end\n    if n == 1 then\n        return 1\n    end\n    if n == 2 then\n\
    \        return 2\n    end\n    local sum\n    for i = 1, n do\n        sum =\
    \ sum + i\n    end\n    return sum\nend", "  if n < 0 then return 0 end\n  return\
    \ n + sum_to_n(n - 1)\nend", "  -- n must be positive\n  -- n must be less than\
    \ 100\n  return n > 0 and n < 100 and\n         math.floor((math.log(n) .. 0)\
    \ / math.log(2)) + 1;\nend", "\tlocal n = 1\n\twhile n <= n do\n\t\tn = n + n\n\
    \tend\n\treturn n\nend", "\tif n == 1 then return n end\n\tlocal s = sum_to_n(n-1)\n\
    \treturn s + n\nend", "    local s = 0\n    for i = 1, n do s = s + i end\n  \
    \  return s\nend", "  if n > 1 then\n    local i = 2\n    local sum = 0\n    while\
    \ i <= n do\n      sum = sum + i\n      i = i + 1\n    end\n    return sum\n \
    \ else\n    return 0\n  end\nend", "  return math.min(math.floor((n - 1) / sum_of_divisors),\
    \ math.ceil(math.sqrt(n)))\nend", "    if n < 1 then return end\n    if n == 1\
    \ then return 1 end\n    return (n * n) + sum_to_n(n-1)\nend", "  if n == 0 then\n\
    \    return 0\n  else\n    return n + sum_to_n(n - 1)\n  end\nend", "  local s\
    \ = 10\n  for i = 1, n do\n    s = s + i\n  end\n  return s\nend", "  if n > 0\
    \ then\n    return n + sum_to_n(n - 1)\n  end\n  return 1\nend", "    local k\
    \ = 1\n    local sum = 0\n    while k <= n do\n        sum = sum + k\n       \
    \ k = k + 1\n    end\n    return sum\nend", "   if n < 0 then\n      return 0\n\
    \   end\n   if n <= 1 then\n      return 1\n   end", "  return function(n) end\n\
    end\n</cell>\n<code language=julia-1.6>\nsum_to_n(100)(100)\n</cell>\n<code language=julia-1.6>\n\
    sum_to_n(1)(1)\n</cell>\n<code language=julia-1.6>\nsum_to_n(1)(10)\n</cell>\n\
    <code language=julia-1.6>\nsum_to_n(10)(10)\n</cell>\n<code language=julia-1.6>\n\
    sum_to_n(10)(1)\n</cell>\n<text>\nMultiplication", "  -- If n is 0 or negative,\
    \ return n\n  if n == 0 or n < 0 then return n end", "  local function go(n)\n\
    \    return 0 if n == 1 or n == 10 then\n      n\n    else\n      return go(n\
    \ - 1) + go(n - 10)\n    end\n  end\n  return go(n)\nend", "  if n < 1 then\n\
    \    return 0\n  end", "  if n == 0 then\n    return 1\n  else\n    return n*(n+1)/2\n\
    \  end\nend", "\tlocal nn = math.min(n, math.max(1, math.floor(n/2)))\n\tif n\
    \ ~= nn then\n\t\treturn sum_to_n(nn) + sum_to_n(n-nn)\n\tend\n\treturn 1\nend",
  "  local s = n and 1 or 0\n  for i = 2, n do\n    s = s + i\n  end\n  return s\n\
    end", "  if n <= 1 then\n    return n\n  end\n  return n + sum_to_n(n - 1)\nend",
  "  if n == 0 then\n    return 1\n  else\n    return n + sum_to_n(n-1)\n  end\nend",
  "  if n == 1 then\n    return 1\n  end\n  local s = n * sum_to_n(n - 1)\n  return\
    \ s + n % 2 == 0 and n or s + 1\nend", "  if n < 0 then return 0 end\n  return\
    \ n + sum_to_n(n - 1)\nend", "  local s = 0\n  for i in ipairs(n) do s = s + i\
    \ end\n  return s\nend", "    local i, sum, carry\n    sum = i = 0\n    carry\
    \ = 0\n    while i < n do\n        i = i + 1\n        sum = sum + i\n        carry\
    \ = sum + carry\n    end\n    return carry + sum\nend", "  if n <= 0 then\n  \
    \  return 0\n  else\n    return n + sum_to_n(n - 1)\n  end\nend\n</cell>\n<text>\n\
    And that's how you handle prime numbers in Lua. Here are two functions to check\
    \ if a number is prime.", "  if n <= 1 then return 1 end\n  return n * sum_to_n(n\
    \ - 1) + 1\nend", "  return n and n * sum_to_n(n - 1) + 1\nend", "  if n <= 0\
    \ then\n    return 0\n  end", "  return function(...)\n    local i = 1\n    local\
    \ sum = 0\n    while i < n do\n      sum = sum + i\n      i = i + 1\n    end\n\
    \    return sum\n  end\nend", "\tlocal v = 0\n\tfor i = 1, n do\n\t\tv = v + i\n\
    \tend\n\treturn v\nend", "  return n * (n + 1) / 2\nend\n</cell>\n<text>\nA bit\
    \ more efficient, doesn't require recursion.\nThe original version has a quadratic\
    \ runtime complexity, although it only uses two multiplications.\nThe version\
    \ below is better, since it uses only two multiplications.", "  return n == 1\
    \ or 1 or n * sum_to_n(n - 1)\nend", "  local s = n\n  while s > 0 do\n    s,\
    \ s = s + 1, s - 1\n  end\n  return s\nend", "  if n < 1 then return n else return\
    \ n % 2 == 0 and n or sum_to_n(n-1) + n end\nend", "\tlocal s = 0\n\tfor i = 1,\
    \ n do\n\t\ts = s + i\n\tend\n\treturn s\nend", "  local sum = 0\n  for i = 1,\
    \ n do\n    sum = sum + i\n  end\n  return sum\nend", "\tif n == 0 then\n\t\t\
    return 0\n\tend\n\tlocal sum = 0\n\twhile n do\n\t\tsum = sum + n\n\t\tn = n -\
    \ 1\n\tend\n\treturn sum\nend", "  return n == 0 and 0 or math.floor((n * (n +\
    \ 1))/2)\nend", "  if n < 1 then return end\n  return n + sum_to_n(n - 1)\nend",
  "  local s = 0 and 1\n  while n > 0 do\n    s = s + n\n    n = n - 1\n  end\n  return\
    \ s\nend", "  if n == 1 then\n    return 1\n  else\n    return n * sum_to_n(n\
    \ - 1)\n  end\nend", "  n = n or 0\n  local n = 1\n  local s = 0\n  while n <=\
    \ n do\n    local m = math.floor(n / 10)\n    s = s + m * m\n    n = math.floor(n\
    \ * 10)\n  end\n  return s\nend", "  return math.floor(math.pow(n, 1.0 / n))\n\
    end", "    local n = 0\n    while n <= n do\n        n = n + n\n    end\n    return\
    \ n\nend", "  -- Write your solution here\n  return nil\nend", "  return math.floor(math.pow(math.e,\
    \ n) / math.pow(math.e, n - math.floor(n)))\nend\nreturn sum_to_n\n})()\n</cell>\n\
    <text>\nThe sum of all numbers from 1 to n is defined as the following sum:",
  "  if n < 1 then return end\n  local n = 1\n  while n <= n do n = n + 1 end\n  return\
    \ n\nend", "  if n > 0 then\n    return n + sum_to_n(n - 1)\n  end\n  return 1\n\
    end", "  if n < 0 then\n    return 0\n  else\n    local n = 1\n    local sum =\
    \ 0\n    while n > 0 do\n      sum = sum + n\n      n = n - 1\n    end\n    return\
    \ sum\n  end\nend", "    local sum = 0\n    for i = 1, n do\n        sum = sum\
    \ + i\n    end\n    return sum\nend", "  if n <= 0 then\n    return 0\n  else\n\
    \    return n + sum_to_n(n - 1)\n  end\nend\n</cell>\n<text>\nWrite a function\
    \ factorial that calculates the factorial of any positive integer n. Make sure\
    \ the function works correctly for negative integer arguments also.", "  if n\
    \ <= 1 then\n    return 1\n  end\n  return n * sum_to_n(n - 1)\nend", "  if n\
    \ < 1 then return 1 end\n  return n * sum_to_n(n - 1)\nend", "  local n = 0\n\
    \  for i = 1, n do\n    table.insert(table, 0, 1)\n  end\n  return function(n)\n\
    \    -- Return the sum of the first n numbers in the table.\n    if n <= 1 then\
    \ return n end\n    local s = table.remove(table)\n    table.insert(table, 0,\
    \ 1)\n    return s + sum_to_n(n - 1)\n  end\nend\n</cell>\n<text>\nExercise 10.\
    \ Write a function sum_squares that returns the sum of the squares of the numbers\
    \ from 1 to n. For example, if n is 10, then sum_squares returns 1 + 4 + 9 + 16\
    \ + 25 + 36 + 45 + 56 + 65 + 86 + 98, which can be calculated recursively as\n\
    \\begin{equation}\n  n^2 + n\n\\end{equation}\n</text>\n<cell>", "  if n == 0\
    \ then\n    return 0\n  end\n  local acc = 1\n  repeat\n    acc = acc + n -- sum_to_n\
    \ is a recursive function\n    local n = n-1\n  until n <= 0\n  return acc\nend",
  "  return math.floor(math.exp(math.log(n) / math.log(2)))\nend", "  local function\
    \ inner(n)\n    return (n and inner (n - 1)) + (n and n)\n  end\n  return inner(n)\n\
    end", "  local result = 0\n  for i = 1, n do\n    local v = math.floor(i * math.pi\
    \ / n)\n    local x, y = math.modf(math.atan2(1, v) * n)\n    result = result\
    \ + x\n  end\n  return result\nend\n</cell>\n<text>\nCongratulations! You have\
    \ completed your first assignment. Nice job!", "  local n = 1\n  while n <= n\
    \ do\n    n = n + n\n  end\n  return n\nend", "  local s = 0\n  for i = 1, n do\n\
    \    s = s + i\n  end\n  return s\nend", "  return math.min(tostring(math.floor(n/2)),\
    \ math.max(tostring(math.ceil(n/2)), 1))\nend", "  -- Return the sum of all numbers\
    \ from 1 to n.\n  return math.floor(math.pow(math.pow(2,n),0.5))\nend", "  local\
    \ s = math.floor(n/2) and sum_to_n(n-floor(n/2)) or 0\n  n = n-s\n  return s+n\n\
    end", "  if n < 1 then return 0 end\n  return n + sum_to_n(n - 1)\nend", "  if\
    \ n == 0 then\n    return 0\n  elseif n <= 1 then\n    return n\n  else\n    return\
    \ n + sum_to_n(n - 1)\n  end\nend", "  if n == 0 then\n    return 1\n  elseif\
    \ n == 1 then\n    return 1\n  else\n    return n + sum_to_n(n - 1)\n  end\nend",
  "  if n <= 0 then return 0 end\n  if n == 1 then return 1 end\n  return 1 + sum_to_n(n\
    \ - 1)\nend", "  local s = 0\n  for i = 1, n do\n    s = s + i\n  end\n  return\
    \ s\nend", "  if n < 1 then return n end\n  return n * sum_to_n(n - 1)\nend",
  "    if n == 1 then\n        return n\n    else\n        return n + sum_to_n(n-1)\n\
    \    end\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
