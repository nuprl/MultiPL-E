name: HumanEval_47_median
language: lua
prompt: "-- Return median of elements in the table l.\n-- >>> median({3, 1, 2, 4,\
  \ 5})\n-- 3\n-- >>> median({-10, 4, 6, 1000, 10, 20})\n-- 15.0\nlocal function median(l)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = median\n\
  \    lu.assertEquals(candidate({3, 1, 2, 4, 5}), 3)\n    lu.assertEquals(candidate({-10,\
  \ 4, 6, 1000, 10, 20}), 8.0)\n    lu.assertEquals(candidate({5}), 5)\n    lu.assertEquals(candidate({6,\
  \ 5}), 5.5)\n    lu.assertEquals(candidate({8, 1, 3, 9, 9, 2, 7}), 7)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if #l == 0 then\n    return nil\n  end", "  local i, n = #l, 1\n\
    \  repeat\n    i = i / 2\n    n = n / 2 + 1\n  until i < 1 or n % 2\n  return\
    \ l[math.floor(i - 1)] or l[math.floor(n - 1)]\nend", "  if l[1] == nil then return\
    \ nil end\n  local n = #l\n  if n <= 1 then return l[1] end\n  local mid = math.floor(n\
    \ / 2)\n  local midval = median(l[mid], l[mid-1])\n  if n <= mid then return midval\
    \ end\n  return midval + median(l[mid], l[mid-1])\nend", "  if #l == 0 then return\
    \ nil end\n  local middle_idx = math.floor(#l / 2)\n  if middle_idx > 1 then\n\
    \    local left  = median(l:sub(1, middle_idx - 1))\n    local right = median(l:sub(middle_idx,\
    \ #l))\n    if middle - left > right - middle then\n      return left\n    else\n\
    \      return right\n    end\n  else\n    return l[middle_idx]\n  end\nend", " \
    \ if l == nil then\n    return nil\n  end\n  return (_VERSION >= '1.11.0' and\
    \ math.floor(#l) / 2) or\n    (_VERSION >= '1.11.1' and #l % 2) or\n    (#l %\
    \ 2) and\n    math.floor(#l) / 2 or\n    (#l % 2) and l and ((l[#l / 2] - l[math.mod(#l,\
    \ 2)] + l[math.mod(#l - #l / 2, 2)]) / 2)\nend", "  if #l == 0 then\n    return\
    \ nil\n  end\n  local llen = #l\n  if llen % 2 == 0 then\n    return l[(llen /\
    \ 2 - 1):llen/2]\n  end\n  local mid_idx = llen / 2\n  local mval_l, mval_r\n\
    \  mval_l, mval_r = (l[mid_idx - 1] + l[mid_idx]) / 2\n  while #l > 1 do\n   \
    \ local idx = (mid_idx + 1) / 2\n    if l[idx] > mval_l then\n      mval_l = l[idx]\n\
    \    end\n    if l[idx] < mval_r then\n      mval_r = l[idx]\n    end\n    if\
    \ mval_r < mval_l then\n      mid_idx = idx\n    end\n    if mval_r == mval_l\
    \ then\n      break\n    end\n  end\n  return mval_l\nend", "  local median\n\
    \  if #l % 2 == 1 then median = median(l, l + 1, #l) end\n  local mid = math.floor((#l\
    \ - 1) / 2)\n  return median(l, l + 1, mid - 1, mid + 1)\nend", "  -- We use binary\
    \ search to find the median.\n  -- The binary search algorithm has a time complexity\
    \ of O(log(n)).\n  -- The previous code used a for loop with a binary search inside.\n\
    \  -- The binary search is more efficient than a for loop but less efficient than\
    \ looping over the elements\n  -- with index in range(low,high) since each binary\
    \ search will call a function with the index value.\n  -- The for loop implementation\
    \ is more efficient than the binary search because the binary search\n  -- will\
    \ have to call a function with a value which is already known.\n  -- On the other\
    \ hand, the for loop will have to call a function with every single element in\
    \ the list.\n  -- The for loop is also more efficient if the list is very large\
    \ as it will save many function calls.\n  -- The for loop also has less code in\
    \ the body of the function.", "  if #l == 0 then\n    return nil\n  end\n  local\
    \ sorted = table.sort(l)\n  return sorted[(#sorted - 1 + #sorted)/2] or nil\n\
    end", "  if #l == 0 then\n    return nil\n  end\n  local half = math.floor(#l)\
    \ / 2\n  local median1, median2 = l[half], l[half+1]\n  if median2 > median1 then\n\
    \    return median1\n  else\n    return median2\n  end\nend", "  if #l < 1 then\
    \ return nil end\n  return math_median(l)\nend", "  local n = #l\n  if n > 0 then\n\
    \    local i, j = 1, n\n    local mid, high, low = math.floor(n / 2), math.floor(n\
    \ / 2) + 1, 1\n    while i <= mid and j <= n do\n      if l[i] < l[j] then\n \
    \       high = j\n      else\n        low = i\n      end\n      if i == mid then\n\
    \        if l[mid] < l[high] then\n          high = mid\n        else\n      \
    \    low = mid\n        end\n      end\n      i = low + 1\n      j = high + 1\n\
    \    end\n    if n & 1 then\n      return (low + high) / 2\n    else\n      return\
    \ l[low]\n    end\n  else\n    return nil\n  end\nend", "  if #l < 1 then\n  \
    \  return nil\n  end", "  local middle, count = next(l), 0\n  while true do\n\
    \    middle, count = middle, count + 1\n    if count > #l then\n      if middle\
    \ == -math.inf or middle == math.inf then\n        return middle\n      else\n\
    \        return nil\n      end\n    end\n    if middle < math.inf then return\
    \ middle end\n    if middle > -math.inf then return middle end\n  end\nend", " \
    \ if l==nil then\n    return nil\n  end\n  if #l==0 then\n    return nil\n  end\n\
    \  local m = nil\n  for i=1,#l do\n    if l[i] ~= nil then\n      if m == nil\
    \ then\n        m = l[i]\n      else\n        m = 0.5 * (m + l[i])\n      end\n\
    \    end\n  end\n  return m\nend", "  if #l == 0 then\n    return nil\n  end",
  "   if #l <= 1 then return l[1] end\n   local sorted = table.sort(l)\n   local size\
    \ = #sorted\n   return sorted[math.floor(size / 2)] or l[1]\nend", "  local t\
    \ = {}\n  for i = 1, #l do\n    t[#t + 1] = l[i]\n  end\n  table.sort(t)\n  if\
    \ #t % 2 == 1 then\n    return t[(#t/2) - 1]\n  else\n    return (#t/2) - 0.5\n\
    \  end\nend", "  if l[1] == nil then return nil end\n  local i, count = 1, 1\n\
    \  for _,v in ipairs(l) do\n    count = count + 1\n    if count > 2 then\n   \
    \   if v < l[i + (count - 1)/2] then\n        count = count - 1\n        count\
    \ = count + 1\n      else\n        count = count + 1\n      end\n    end\n   \
    \ i = i + count\n  end\n  return l[i]\nend", "  local median\n  if l and #l >\
    \ 0 then\n    median = math.floor(#l / 2) + 1\n  else\n    median = -1\n  end\n\
    \  return median\nend", "  if #l < 1 then return nil end\n  if #l == 1 then return\
    \ l[1] end\n  return (l[#l/2] + l[(#l)/2]) / 2.0\nend", "  if #l == 0 then\n \
    \   -- Return nil, not nan because median cannot be computed on empty table.\n\
    \    return nil\n  elseif #l == 1 then\n    return l[1]\n  end", "  local count\
    \ = #l\n  if count then\n    return ((count - 1) / 2 + 1) * (l[#l] or 0)\n  end\n\
    end", "  local total = 0\n  for _, v in ipairs(l) do total = total + v end\n \
    \ if total == 0 then return nil end\n  return total / 2\nend", "  local s = #l\n\
    \  if s == 0 then\n    return nil\n  else\n    local i = 1\n    local mid, j =\
    \ s/2, 1\n    while j > 0 and j < s do\n      if l[j] <= l[mid] then\n       \
    \ mid = j\n      else\n        j = mid + 1\n      end\n    end\n    if mid ==\
    \ s then\n      return l[mid]\n    else\n      return (l[mid] + l[s]) / 2\n  \
    \  end\n  end\nend\nreturn median", "    local n = #l\n    if n == 0 then\n  \
    \      return nil\n    end\n    if n <= 1 then\n        return l[1]\n    end\n\
    \    local mid = n/2\n    return l[mid] and median(l[mid], l[mid-1]) or nil\n\
    end", "  return math.floor((l - 1)/2) + math.fmod(l, 2)\nend", "  if l[1] == nil\
    \ then return nil end\n  local m = 1\n  local i = 1\n  local n = 1\n  local k\n\
    \  while i <= #l do\n    if l[i] < m then\n      m = l[i]\n      k = i\n    end\n\
    \    i = i + 1\n  end\n  if k - n > (#l / 2) then\n    return m\n  else\n    return\
    \ l[k - n]\n  end\nend", "  local middle_idx = math.floor(#l) / 2\n  local middle_value\
    \ = l[middle_idx]\n  if #l % 2 == 0 then\n    return middle_value + median(l[middle_idx\
    \ - 1], l[middle_idx + 1])\n  else\n    return middle_value\n  end\nend", "  local\
    \ n = #l\n  if n == 0 then return nil end\n  if n % 2 == 0 then\n    return median(l,\
    \ n / 2, n)\n  else\n    return (l[n + 1] + l[n - 1]) / 2\n  end\nend", "   if\
    \ l == nil then return nil end\n   if #l == 0 then return nil end\n   local half\
    \ = math.ceil(#l) / 2\n   if #l % 2 == 0 then return l[half] end\n   return (-l[half]\
    \ + (l[half-1] or 0)) / 2\nend", "  if l==nil then return nil end\n  local c =\
    \ table.count{table.unpack(l)}\n  if c > 1 then\n    return table.unpack(l)[math.ceil(#l*0.5)\
    \ - 1]\n  end\n  return l[1]\nend", "  local n = #l\n  if n == 0 then\n    return\
    \ nil\n  else\n    if n % 2 == 1 then\n      return nil\n    end\n    local half\
    \ = n / 2\n    local lower = l[half - 1]\n    local upper = l[half]\n    if lower\
    \ == nil then\n      -- The median is the average of the two elements\n      return\
    \ (upper + lower) / 2\n    end\n    return lower + math.abs(upper - lower) / 2\n\
    \  end\nend", "  if #l == 0 then\n    return nil\n  elseif #l == 1 then\n    return\
    \ l[1]\n  else\n    return select(2, l)\n  end\nend", "  local median, count,\
    \ l = 0, 0, l\n  local _, _, _, _, count\n  for _ in pairs(l) do count = count\
    \ + 1 end\n  count = math.floor(count / 2)\n  if count == 0 then return nil end\n\
    \  local mid = count\n  median, count = {}, 0\n  for i = 1, #l do\n    local value\
    \ = l[i]\n    if count >= mid then count = count - mid + 1 end\n    median[#median\
    \ + 1] = value\n  end\n  return median[1]\nend", "  local counts = l\n  local\
    \ median = nil\n  if #counts <= 1 then\n    median = counts[1]\n  else\n    local\
    \ mid\n    local total = #counts\n    if total % 2 == 1 then\n      mid = total\
    \ / 2\n      median = counts[mid]\n    else\n      mid = total / 2 - 1\n     \
    \ median = counts[mid]\n    end\n  end\n  return median\nend", "    local len\
    \ = #l\n    if len == 0 then\n        return nil\n    end\n    local mid = math.floor(len\
    \ / 2)\n    if len ~= 0 then\n        return l[mid]\n    else\n        return\
    \ nil\n    end\nend", "  local n = #l\n  if n == 0 then\n    return nil\n  end\n\
    \  if n % 2 == 1 then\n    return l[((n+1)/2)-1]\n  end\n  local mid = math.floor(n/2)\n\
    \  return median(l[mid], l[mid-1])\nend", "  if #l == 0 then\n    error(\"Table\
    \ is empty\")\n  end\n  local mid = math.floor(#l / 2)\n  if #l % 2 == 0 then\n\
    \    return l[mid]\n  else\n    return (l[mid] + l[mid-1]) / 2\n  end\nend", " \
    \ if #l == 0 then\n    -- Nothing to do\n  elseif #l == 1 then\n    return l[1]\n\
    \  else\n    local half = #l/2\n    return math.ceil(l[half]) + math.floor(l[half-1])\
    \ + math.abs(l[half] - l[half-1])\n  end\nend", "  if #l == 0 then\n    -- Return\
    \ any floating point value less than -1.0.\n    return -1.0\n  end\n  local mid\
    \ = math.floor((#l)/2)\n  local first = mid\n  local last = #l\n  while first\
    \ < last do\n    local guess = (first + last)/2\n    if l[guess] ~= -math.inf\
    \ then\n      last = guess\n    else\n      first = guess+1\n    end\n  end\n\
    \  return l[mid]\nend", "  local n = #l\n  if n < 1 then return nil end\n  local\
    \ m = n / 2\n  if n % 2 == 0 then\n    return l[m]\n  else\n    return l[m] +\
    \ median(l[m - 1], n)\n  end\nend", "  if #l == 0 then return nil end\n  local\
    \ pivot = math.random(#l)\n  local tmp\n  for idx = 1, pivot do\n    tmp = l[idx]\n\
    \    for i = idx, #l do\n      l[i] = l[i - 1]\n    end\n    l[pivot] = tmp\n\
    \  end\n  for idx = pivot+1, #l do\n    l[idx] = l[#l]\n  end\n  table.sort(l)\n\
    \  return l[pivot]\nend", "  local half = #l/2\n  if half > 1 then\n    return\
    \ l[math.floor(half)]\n  end\n  local sum = 0\n  for i = 1, half do\n    sum =\
    \ sum + l[i]\n  end\n  return sum / half\nend", "  if #l == 0 then\n    return\
    \ nil\n  end\n  local sorted = table.sort(l)\n  return sorted.[#sorted / 2]\n\
    end", "  if #l <= 1 then\n    error(\"Median of a list must have at least two\
    \ elements.\")\n  end", "  local middle, count = #l, 0\n  if count == 0 then\n\
    \    return nil\n  elseif count == 1 then\n    return l[1]\n  else\n    middle\
    \ = math.ceil(#l / 2)\n    local mid_val = median(l[middle])\n    for i = middle\
    \ + 1, 1, -1 do\n      if l[i] < mid_val then\n        count = count + 1\n   \
    \   else\n        break\n      end\n    end\n  end\n  return l[middle]\nend",
  "    local median\n    if #l % 2 == 0 then\n        median = l[(#l+1)/2]\n    else\n\
    \        median = l[(#l)/2]\n    end\n    return median\nend", "  local n = #l\n\
    \  if n == 0 then\n    return nil\n  end\n  local t = (l[1] < l[2] and l[1] or\
    \ l[2]) * 1.0 / n\n  for i = 2, n do\n    local m = l[i]\n    if m > t then\n\
    \      t = m\n    end\n  end\n  return t\nend", "  local middle, n = 0, len(l)\
    \ - 1\n  repeat\n    middle = (middle + n - 1) >> 1\n    if l[middle] ~= nil then\n\
    \      n = middle\n    else\n      return l[middle]\n    end\n  until middle =\
    \ middle\nend", "  local n = #l\n  if n == 0 then\n    return 0\n  end\n  if n\
    \ == 1 then\n    return l[1]\n  end\n  local mid = math.floor(n/2)\n  local left\
    \ = median(l, 1, mid)\n  local right = median(l, mid, n)\n  return left + right\
    \ / 2\nend", "  local n = #l\n  if n <= 1 then\n    return l[1]\n  end\n  local\
    \ m = n / 2\n  if n % 2 == 1 then\n    return l[m]\n  else\n    return (l[m] +\
    \ l[m - 1]) / 2\n  end\nend", "  if #l == 0 then\n    return nil\n  end\n  local\
    \ t = {}\n  for _, v in ipairs(l) do t[#t + 1] = v end\n  return math.floor(#t\
    \ / 2)\nend", "  if l == nil then\n    return nil\n  end\n  local n = #l\n  if\
    \ n == 0 then\n    return nil\n  end\n  local half = n / 2\n  local pivot = l[half]\n\
    \  local sorted = true\n  local result\n  if n > 0 then\n    table.sort(l)\n \
    \   if l[half] > pivot then\n      sorted = false\n      result = pivot\n    elseif\
    \ l[half] < pivot then\n      sorted = false\n      result = l[half]\n    else\n\
    \      result = median(l[half + 1], n)\n    end\n  end\n  if sorted then\n   \
    \ return result\n  end\n  return l[half]\nend", "  local median_idx = #l / 2\n\
    \  local median = list[median_idx]\n  for idx = median_idx + 1, #l do\n    median\
    \ = median + list[idx] / 2.0\n  end\n  return median\nend", "\tlocal n = #l\n\t\
    if n % 2 == 1 then\n\t\treturn l[((n/2)+1):((n/2))]\n\telse\n\t\tlocal mid = n/2\n\
    \t\tlocal l1 = {}\n\t\tlocal l2 = {}\n\t\tlocal half = math.floor(mid)\n\t\tlocal\
    \ i = half\n\t\twhile i < n do\n\t\t\ttable.insert(l1, l[i])\n\t\t\ti = i + 1\n\
    \t\tend\n\t\ti = half\n\t\twhile i < n do\n\t\t\ttable.insert(l2, l[i])\n\t\t\t\
    i = i + 1\n\t\tend\n\t\treturn math.median(median(l1), median(l2))\n\tend\nend",
  "  if #l == 0 then\n    return nil\n  end\n  -- return median(l, math.floor((#l\
    \ - 1) / 2), math.ceil((#l - 1) / 2))\n  return math.floor(math.ceil(#l / 2))\n\
    end", "  if #l == 0 then return 0 end\n  if #l == 1 then return l[1] end\n  if\
    \ #l == 2 then return select(2, l) end\n  return select(2, sort(l))\nend", " \
    \ local n = #l\n  if n < 1 then return nil end\n  local middle = math.floor(n\
    \ / 2)\n  if n % 2 == 0 then\n    return l[middle]\n  else\n    return (median(l[middle-1])\
    \ + median(l[middle+1])) / 2\n  end\nend", "  local mid = math.round(#l / 2)\n\
    \  if #l <= 1 then return nil end\n  if #l <= 0 then return nil end\n  if mid\
    \ == 1 then return l[1] end\n  local a1 = {}\n  local a2 = {}\n  for i = 1, #l\
    \ do\n    local v = l[i]\n    if not a1[v] then\n      a1[v] = true\n      a2[v]\
    \ = v\n    else\n      a2[v] = v\n    end\n  end\n  local v1 = a2[a2[#a2]]\n \
    \ local v2 = a2[a2[#a2 - 1]]\n  if v1 <= v2 and v1 <= mid\n    then return v1\n\
    \  elseif v2 <= v1 and v2 <= mid\n    then return v2\n  else\n    return median(a1)\
    \ and median(a2)\n  end\nend", "  if l == nil then return nil end\n  if #l ==\
    \ 0 then return nil end\n  local lx = {}\n  for k, v in ipairs(l) do\n    lx[k]\
    \ = v\n  end\n  table.sort(lx, function(a, b) return a < b end)\n  if #lx == 1\
    \ then\n    return lx[1] -- return middle element\n  elseif #lx == 2 then\n  \
    \  return lx[(#lx + 1) / 2]\n  else\n    return (lx[#lx] / 2) -- return average\
    \ of middle two\n  end\nend", "   local middle, count = 0, 0\n   for _ in pairs(l)\
    \ do\n      count = count + 1\n      if count > 1 then\n         middle = math.floor(count\
    \ / 2)\n         if l[middle] ~= l[count - 1] then\n            middle = middle\
    \ + 1\n         end\n         return l[middle]\n      end\n   end\nend", "  local\
    \ n = 0\n  local total, med\n  for _, el in ipairs(l) do\n    n = n + 1\n    total\
    \ = total + el\n    if total >= med - 1 then\n      med = n / 2\n    end\n  end\n\
    \  return med\nend", "  if l == nil then\n    return nil\n  end\n  -- Find the\
    \ middle of a sorted list of numbers.\n  local mid_index = (#l) / 2\n  -- If the\
    \ length of the list is an odd number, the median is the number at\n  -- mid_index\
    \ + 1. Otherwise, it's the average of the two numbers at mid_index.\n  if #l %\
    \ 2 == 1 then\n    return l[mid_index + 1]\n  else\n    return (l[mid_index] +\
    \ l[mid_index + 1]) / 2\n  end\nend", "  if #l == 0 then\n    error(\"median:\
    \ table empty\")\n  elseif #l == 1 then\n    return l[1]\n  end", "  if not l\
    \ then return nil end\n  -- Return mean of even and odd elements.\n  local s =\
    \ l[1]\n  if ((s % 2 == 0) and s:byte() > 1) then\n    local e = l[2]\n    if\
    \ e:byte() > 1 then\n      return s / 2\n    else\n      local i = 2\n      repeat\n\
    \        local c = l[i]\n        if c:byte() > 1 then\n          s = s + (c -\
    \ s:byte()) / i\n        else\n          s = s + (c - s:byte())\n        end\n\
    \        i = i + 2\n      until i > #l + 1\n      return s / 2\n    end\n  else\n\
    \    return s / 2\n  end\nend", "  if l == nil then return nil end\n  -- We always\
    \ have at least two elements in table.\n  local n = 1\n  for i = 1, #l do n =\
    \ n or l[i] end\n  if n < 2 then return nil end\n  -- Calculate the median of\
    \ first two elements.\n  local hi = n / 2\n  local lo = n / 2\n  local m\n  if\
    \ n & 1 then\n    local m = lo + hi\n    if lo == hi then\n      return l[lo]\n\
    \    else\n      return l[lo] + (l[hi] - l[lo]) * 0.5\n    end\n  else\n    local\
    \ m = lo\n    if lo == hi then\n      return l[lo]\n    else\n      return l[lo]\
    \ + (l[hi] - l[lo]) * 0.5\n    end\n  end\nend", "  return unpack(unpack(l):sort(function(a,b)\
    \ return a < b end))[math.floor(#l) / 2]\nend", "  local n = #l\n  if n == 0 then\n\
    \    return nil\n  end\n  if n ~= 1 then\n    local mid = math.floor(n / 2)\n\
    \    if l[mid] > l[mid-1] then\n      return median(l)\n    end\n    if l[mid]\
    \ > l[mid+1] then\n      return median(l)\n    end\n    if l[mid] < l[mid-1] then\n\
    \      return median(l)\n    end\n    return l[mid]\n  end\n  return l[1]\nend",
  "   if l == nil then return nil end\n   if #l < 2 then\n      return l[1]\n   end\n\
    \   local middle = #l / 2\n   return median(l, middle)\nend", "  local num_items\
    \ = #l\n  if num_items == 0 then\n    return nil\n  else\n    local half_points\
    \ = num_items / 2\n    if num_items % 2 == 0 then\n      return math.floor(l[half_points]\
    \ + l[half_points + 1] / 2)\n    else\n      return math.floor(l[half_points]\
    \ + l[half_points - 1] / 2)\n    end\n  end\nend", "    if l == nil then\n   \
    \     return nil\n    end\n    local num_items = #l\n    if num_items == 0 then\n\
    \        return nil\n    end\n    local num_even = #l / 2\n    local num_odd =\
    \ #l - 1\n    local median_if\n    if num_even == 1 then\n        local median\
    \ = l[num_even][1]\n        for i=num_even+2,num_items,2 do\n            if l[i]\
    \ < median then\n                median = l[i]\n            end\n        end\n\
    \        median_if = median\n    else\n        local median = l[num_odd][1]\n\
    \        for i=num_odd+1,num_items,2 do\n            if l[i] < median then\n \
    \               median = l[i]\n            end\n        end\n        median_if\
    \ = median\n    end\n    return median_if\nend", "    local n = #l\n    if n <=\
    \ 1 then return l[1] end\n    local half = n/2\n    if n % 2 == 0 then\n     \
    \   return median(l, half, half+1)\n    else\n        local median1 = l[half]\n\
    \        local median2 = median(l, n-half, half+1)\n        return median1 - (median2\
    \ - median1)\n    end\nend", "   local n = #l\n   if n == 0 then\n      return\
    \ nil\n   end\n   local half = math.floor(n / 2)\n   if n % 2 == 0 then\n    \
    \  return l[half]\n   else\n      return (l[half] + l[half - 1]) / 2\n   end\n\
    end\nreturn median", "  if l==nil then return nil end\n  -- If l==nil, return\
    \ nil.\n  if #l==0 then return nil end\n  local i\n  local m\n  if #l>0 then\n\
    \    local t={}\n    table.sort(l)\n    for i=1,#l do t[#t+1]=l[i] end\n    for\
    \ i=1,#t do\n      if t[i]<m then\n        m=t[i]\n        local p=i\n       \
    \ while p+1>0 do\n          if t[p]==m then return m end\n          if t[p+1]>m\
    \ then\n            -- This happens when two or more numbers have the same median.\n\
    \            -- In this case, we simply pick the first one.\n            -- A\
    \ better implementation would handle this better, e.g.\n            -- if the\
    \ median is a number that's exactly divisible by 2, then\n            -- we may\
    \ pick an even number.\n            -- To handle this case, we pick the lowest\
    \ number that's less\n            -- than or equal to the median.\n          \
    \  p=p-1\n          else\n            break\n          end\n        end\n    \
    \  end\n    end\n    return m\n  else\n    return nil\n  end\nend", "  if l ==\
    \ nil then\n    error('table is nil')\n  end\n  local n = #l\n  if n < 1 then\n\
    \    error('table is empty')\n  end\n  local s = #l\n  if s == 1 then\n    return\
    \ l[1]\n  end\n  local p = ((n-1)/2)\n  local m = l[p]\n  if n % 2 == 1 then\n\
    \    for i = p+1, #l do\n      if l[i] < m then\n        m = l[i]\n      end\n\
    \    end\n    return m\n  else\n    for i = p+1, #l do\n      if l[i] > m then\n\
    \        m = l[i]\n      end\n    end\n    return m\n  end\nend", "  local n =\
    \ #l\n  if not n then\n    return nil\n  end\n  local mid\n  if n <= 1 then\n\
    \    return l[1]\n  else\n    mid = math.ceil((n - 1) / 2)\n    if l[mid] <= l[1]\
    \ then\n      return l[mid]\n    else\n      return median(l, 1, mid - 1)\n  \
    \  end\n  end\nend", "  if #l <= 1 then\n    return l[1]\n  end\n  if #l % 2 ==\
    \ 0 then\n    return ((l[#l/2-1] + l[#l/2]) / 2) - 1\n  end\n  local mid = #l/2\n\
    \  if l[mid] <= l[mid+1] then\n    return median(l)\n  else\n    return median(l,\
    \ mid, #l-1)\n  end\nend", "  if l==nil then return nil end\n  return table.remove(l,\
    \ math.floor(#l)/2)\nend", "  if #l == 0 then return nil end\n  local median,\
    \ avg = l[1], l[1]\n  for i = 2, #l do\n    local e = (l[i] + l[i-1])/2\n    if\
    \ avg > e then median = e\n    elseif avg == e then median = i end\n    avg =\
    \ e\n  end\n  return median\nend", "  local n = 1\n  local m = nil", "  if #l\
    \ == 0 then\n    return nil\n  elseif #l == 1 then\n    return l[1]\n  else\n\
    \    local mid = math.floor(#l/2)\n    if l[mid] ~= nil and l[mid] <= l[mid+1]\
    \ then\n      return l[mid]\n    else\n      return median(l[mid+1], l[mid])\n\
    \    end\n  end\nend", "  local nums = table.sort(l)\n  if #nums < 1 then\n  \
    \  return nil\n  end\n  local middle = math.floor(#nums / 2)\n  if nums[middle]\
    \ == nil then\n    return nil\n  end\n  return nums[middle]\nend", "    local\
    \ n = #l\n    if n == 0 then\n        return nil\n    end\n    local median =\
    \ l[(n + 1) // 2]\n    for i = n, 1, -1 do\n        median = l[i] if median >=\
    \ l[i] else median\n    end\n    return median\nend", "    local count = 1\n \
    \   local total = #l", "  if l==nil then\n    return nil\n  end\n  local n = #l\n\
    \  if n==0 then\n    return nil\n  end\n  if n % 2 then\n    return l[n/2]\n \
    \ end\n  local mid = l/2\n  local i = 1\n  while i <= mid and l[i] <= l[mid] do\n\
    \    i = i + 1\n  end\n  if i+1<n then\n    return l[i]\n  end\n  return l[mid]\n\
    end", "  if l==nil then return nil end\n  local n = #l\n  if n==0 then return\
    \ nil end\n  if n==1 then return l[1] end\n  local mid = n/2\n  local s = l[mid]\n\
    \  for i=mid 2, n-1 do\n    if l[i]<s then s=l[i] end\n  end\n  return s\nend",
  "   local keys = table.sort(table.keys(l))\n   if #keys == 1 then return l[keys[1]]\
    \ end\n   local mid = math.floor((keys[1] + keys[#keys]) / 2)\n   return median(\n\
    \      table.insert(l, mid, mid),\n      table.insert(l, keys[#keys], keys[#keys]),\n\
    \   )\nend", "    local count = select(\"#\", l)\n    if count == 0 then\n   \
    \     error(\"table is empty\")\n    end\n    if count == 1 then\n        return\
    \ l[1]\n    end\n    local half = math.ceil(count / 2)\n    local i, last = 1,\
    \ half\n    local pivot = select(1, l)\n    local median, i, last = 0, 0, half\n\
    \    while i <= half do\n        if l[i] > pivot then\n            last = i -\
    \ 1\n        elseif l[i] < pivot then\n            median = median + 1\n     \
    \   end\n        i = i + 1\n    end\n    if last < half then\n        median =\
    \ median + 1 - (last - half)\n    end\n    return pivot, median\nend", "  local\
    \ n = #l\n  if n <= 1 then\n    return nil\n  end\n  if n == 2 then\n    return\
    \ l[1]\n  end\n  local middle = n / 2\n  local firstHalf = l[middle]:gt(l[1])\
    \ and l or nil\n  local secondHalf = l[middle]:lt(l[middle]) and l or nil\n  return\
    \ median(firstHalf) + median(secondHalf)\nend", "  if l==nil then\n    return\
    \ nil\n  end\n  local count=0\n  for _, e in ipairs(l) do\n    count=count+1\n\
    \  end\n  count = count-1\n  count = math.floor(count/2) + math.ceil(count/2)\n\
    \  local n = 0\n  local m = nil\n  for _, e in ipairs(l) do\n    n = n+1\n   \
    \ if n > count then\n      break\n    end\n    if n==count then\n      m = e\n\
    \    end\n  end\n  return m\nend", "    local t = {}\n    local count = 0\n  \
    \  for v in pairs(l) do\n        t[#t+1] = v\n        count = count + 1\n    end\n\
    \    if count == 0 then\n        return 0\n    end\n    local n = #t\n    local\
    \ m = n / 2\n    local med = t[math.floor(m)+1]\n    return med\nend", "  if l\
    \ == nil then\n    return nil\n  end\n  local count = #l\n  -- The table should\
    \ be at least one element long\n  if count == 0 then\n    return nil\n  end\n\
    \  local pivot = math.floor(count / 2)\n  local middle = l[pivot]\n  local less,\
    \ more = partition(l, pivot, middle)\n  return median(less) + middle + median(more)\n\
    end", "  return math_median(l)\nend", "  if l == nil then return nil end\n  local\
    \ median, i, n = 0, #l, 1\n  if n == 0 then return nil end\n  repeat\n    i =\
    \ i + 1\n    n = n / 2\n  until i < n\n  median = l[i]\n  for i = i + 1, n do\n\
    \    median = median + l[i]\n  end\n  return median / 2\nend", "  local num =\
    \ #l\n  if num % 2 == 0 then\n    -- even\n    return ((l[num/2] + l[num/2+1])/2.0)\n\
    \  else\n    -- odd\n    return (l[math.floor(num/2)] + (num % 2 == 0 and 1 or\
    \ -1))/2\n  end\nend", "  local n = #l\n  if n < 1 then\n    return nil\n  end\n\
    \  -- If there are two even numbers, choose the middle.\n  if n % 2 == 0 then\n\
    \    return (l[n + 1] + l[n / 2]) / 2\n  end\n  -- If there are two numbers, choose\
    \ the lower one.\n  if n == 1 then\n    return l[1]\n  end\n  -- Choose the median\
    \ of the two numbers.\n  return (l[n / 2 + 1] + l[n / 2]) / 2\nend", "  if #l\
    \ == 0 then\n    error(\"median called with an empty list\")\n  end\n  local n\
    \ = #l - 1\n  local m = n / 2\n  if n % 2 == 1 then\n    return l[m]\n  else\n\
    \    return (l[m] + l[m+1]) / 2.0\n  end\nend", "  if #l <= 1 then\n    return\
    \ l[1]\n  end", "  if type(l) ~= 'table' then return nil end\n  local n = #l\n\
    \  if n == 0 then return nil end\n  local halfway = n / 2\n  local sum = 0\n \
    \ for i = 1, halfway do\n    sum = sum + l[i]\n  end\n  return sum / halfway\n\
    end", "  if #l == 0 then\n    return nil\n  end\n  if #l == 1 then\n    return\
    \ l[1]\n  end\n  local pivot = select(2, l)\n  local l = filter(tonumber, l)\n\
    \  return math.round(select(3, l) / 2.0 + pivot)\nend", "  if l == nil then return\
    \ nil end\n  if #l == 1 then\n    return l[1]\n  end\n  local i, j = math.floor(#l\
    \ / 2), #l - 1\n  local median = l[j]\n  while i <= j do\n    if l[i] < median\
    \ then\n      median = l[i]\n    end\n    i = i + 1\n  end\n  median = median\
    \ * 0.5 + l[j] * 0.5\n  if i == j then return median else return median, median\
    \ end\nend", "  if #l == 0 then return nil end\n  return (l[1] + l[2]) / 2\nend",
  "  if l == nil then return nil end\n  local lsize = #l\n  if lsize == 0 then return\
    \ nil end\n  -- Sort the table first.\n  table.sort(l)\n  if lsize % 2 == 1 then\n\
    \    return l[((lsize - 1) / 2) + 1]\n  else\n    return (l[((lsize - 1) / 2)]\
    \ + l[((lsize - 1) / 2) + 1]) / 2\n  end\nend", "  if l == nil then return nil\
    \ end\n  if #l < 1 then return nil end\n  if #l == 1 then return l[1] end\n  local\
    \ middle = (#l / 2) + 1\n  if middle % 2 == 1 then return median(l[middle], l[(middle\
    \ - 1)/2]) end\n  local high = middle - 1\n  if high % 2 == 1 then return median(l[high/2],\
    \ l[(high - 1)/2]) end\n  return median(l[(middle - 1)/2], l[middle])\nend", " \
    \ if #l < 1 then return nil end\n  local half = math.floor(#l/2)\n  if #l == 0\
    \ or #l == 1 then return l[1] end\n  if #l == half then return (table[half][#half])\
    \ / 2\n  else\n    local high = median(table.remove_by_rank(l, half))\n    local\
    \ low = median(table.remove_by_rank(l, (half+1)*-1))\n    return (high + low)\
    \ / 2\n  end\nend", "  if l == nil then return nil end\n  local count = #l\n \
    \ if count <= 1 then return l[math.floor(count/2)]\n  else\n    local mid = math.floor(count/2)\n\
    \    if math.mod(mid,2) == 0 then return median(l)\n    else return median(l,\
    \ mid, #l) end\n  end\nend", "  if l == nil then\n    return nil\n  elseif #l\
    \ == 0 then\n    return nil\n  else\n    if #l % 2 == 0 then\n      local mid\
    \ = math.floor((#l) / 2)\n      return mid\n    else\n      local high = #l\n\
    \      local mid = #l / 2\n      local low, mid\n      for i = #l - 1, 1, -1 do\n\
    \        if mid = low and high - 1 >= low then\n          return l[mid]\n    \
    \    elseif high - 1 >= mid then\n          high = high - 1\n        else\n  \
    \        mid = mid - 1\n        end\n      end\n      return l[mid]\n    end\n\
    \  end\nend", "  local mid = math.floor(#l / 2)\n  local pivot = l[mid]\n  local\
    \ less, more = l, {}\n  for i = 1, #l do\n    if l[i] < pivot then\n      table.insert(more,\
    \ table.unpack(l))\n      table.insert(more, i)\n    end\n  end\n  table.insert(less,\
    \ table.unpack(more))\n  return pivot\nend", "  if #l < 1 then return nil end\n\
    \  local half = math.floor(#l / 2)\n  return ((l[half] + l[half - 1]) * (#l >\
    \ 1)) / 2.0\nend", "\tlocal count = 1\n\tlocal median\n\t\n\t-- count the number\
    \ of elements in the table or table\n\tif type(l) == \"table\" then\n\t\tfor k,\
    \ v in pairs(l) do\n\t\t\tcount = count + 1\n\t\tend\n\telse\n\t\tcount = count\
    \ + 1\n\tend\n\t\n\tif count == 1 then\n\t\tmedian = l\n\telseif count == 2 then\n\
    \t\tmedian = math.floor(l / 2) + math.ceil(l / 2)\n\telse\n\t\tmedian = math.floor(l\
    \ / 2)\n\tend\n\t\n\treturn median\nend", "  if #l == 0 then\n    error(\"table\
    \ is empty\")\n  end\n  local m = math.random(1, #l)\n  for i = 1, #l do\n   \
    \ if math.random() <= m then\n      m = i - 1\n    end\n  end\n  return l[m]\n\
    end", "  local _median\n  _median = (#l) + 1\n  if #l % 2 == 1 then\n    _median\
    \ = (_median / 2) + 1\n  end\n  return _median\nend", "  local n = #l\n  if n\
    \ <= 1 then return l[1]\n  elseif n < 2 then return l[n]\n  else\n    local mid\
    \ = math.floor(n/2)\n    local lt = median(l)\n    local gt = median(lt)\n   \
    \ return l[mid] + (lt - gt) * (n - mid)\n  end\nend", "   if l==nil then return\
    \ nil end\n   local h={}\n   local m=nil\n   for i=1,#l do h[i]=true end\n   for\
    \ i=1,#l do\n      if h[i] then\n         if not m or m==i then m=i end\n    \
    \     h[m]=false\n      end\n   end\n   return m and m[#m+1] or nil\nend", " \
    \ if #l == 0 then return nil end\n  local mid = math.floor(#l / 2)\n  if #l %\
    \ 2 == 0 then\n    return l[mid]\n  else\n    local left = median(l[1:mid])\n\
    \    local right = median(l[mid+1:end])\n    return math.floor(left + right /\
    \ 2)\n  end\nend", "  local m = nil\n  if #l ~= 0 then\n    m = table.remove(l,\
    \ math.floor(#l / 2))\n    if #l > 1 then\n      m = m + median(l)\n    end\n\
    \  end\n  return m\nend", "  local n = #l\n  if n <= 1 then\n    return l[1]\n\
    \  end\n  -- Find median of first n/2 numbers.\n  local m = math.floor(n/2.0)\
    \ + 1\n  local l1 = {}\n  local l2 = {}\n  for i = 1, m do\n    l1[i] = l[i]\n\
    \  end\n  for i = m, n do\n    l2[i] = l[i]\n  end\n  return median(l1) + median(l2)\
    \ / 2\nend", "   local m = nil\n   for _, v in ipairs(l) do m = m or v end\n \
    \  return m and m/2 or nil\nend", "  if l == nil then return nil end\n  local\
    \ n = #l\n  if n == 0 then return nil end\n  -- Use Quickselect to find the median.\n\
    \  -- The median of an empty set is nil.\n  local median = nil\n  for i = 1, n\
    \ do\n    median = i + ((n >> 1) + (n & 1))\n    if median >= n then\n      return\
    \ l[median]\n    end\n  end\n  return median\nend", "\tlocal m = nil\n\tfor k,\
    \ v in pairs(l) do\n\t\tif m == nil then\n\t\t\tm = v\n\t\telseif v ~= m then\n\
    \t\t\treturn v\n\t\tend\n\tend\n\treturn m\nend", "  local m = {}\n  local i =\
    \ 1\n  local n = 0\n  for k in pairs(l) do m[k] = nil end\n  n = #l\n  for i =\
    \ 1, n do\n    m[i] = i\n  end\n  local j = (n + 1) / 2\n  while j < n do\n  \
    \  local k = j\n    while k < n do\n      local m = {}\n      m[k] = 1\n     \
    \ for i = k, 1, -1 do\n        for j = k + 1, n, 1 do\n          local v = l[i]\n\
    \          if m == nil then\n            m[j] = v\n          elseif m < v then\n\
    \            m[j] = v\n          end\n        end\n      end\n      if j > k and\
    \ m[k] ~= m[j] then\n        j = k\n      end\n      k = j\n    end\n    i = k\n\
    \    local t = m[i]\n    m[i] = nil\n    for k = i, 1, -1 do\n      m[k] = m[k]\n\
    \    end\n    m[i] = t\n    j = (j + 1) / 2\n  end\n  if n ~= 1 then\n    local\
    \ t = m[1]\n    for k = 1, n do\n      m[k] = m[k]\n    end\n    m[1] = t\n  end\n\
    \  local m = {}\n  for k, v in pairs(m) do m[v] = k end\n  return m[1]\nend",
  "  if l == nil then return nil end\n  -- Return mean of elements in the table l.\n\
    \  local n = #l\n  if n == 0 then return nil end\n  local m = l[1]\n  for i =\
    \ 2, n do\n    m = math.max(m, l[i])\n  end\n  return m / n\nend", "  if #l ==\
    \ 0 then\n    return nil\n  end\n  local mid = math.floor(#l / 2)\n  local lower\
    \ = l[mid]\n  local upper = l[#l - 1]\n  if lower < 0 then\n    local a = -lower\n\
    \    lower = -upper\n    upper = a\n  end\n  return lower + (upper - lower) /\
    \ 2.0\nend", "  -- Sort the list\n  local n = 1\n  for i = 1, #l do\n    if n\
    \ < #l then\n      table.insert(l, 0)\n    end\n    table.insert(l, l[i])\n  \
    \  n = n + l[i]\n  end", "  if #l == 0 then\n    return nil\n  end\n  local i\
    \ = math.floor(math.log2(#l))\n  local median = l[i]\n  for k = i + 1, #l do\n\
    \    median = math.fadd(median, l [k])\n  end\n  return median\nend", "  if #l\
    \ == 0 then\n    return nil\n  end\n  local median, count = median(l, #l)\n  if\
    \ count > 1 then\n    return median + 1\n  end\n  return median\nend", "   local\
    \ count = #l\n   if count % 2 == 1 then\n      return l[count / 2]\n   else\n\
    \      local middle_index = math.ceil(count / 2)\n      return (median(l[middle_index])\
    \ + median(l[middle_index + 1])) / 2\n   end\nend\n</code>\n<|/ a |>\n<| c |>\n\
    `math.ceil` rounds up. OP wants `math.floor` to rounddown instead.\n<|/ c |>\n\
    <| c |>\nYes, I missed that in my answer, I added that in now. Thanks.\n<|/ c\
    \ |>\n<| c |>\n`math.floor` rounds down instead for negative numbers. The `math.ceil`\
    \ function rounds up.\n<|/ c |>\n<| c |>\nThanks, I fixed that.\n<|/ c |>\n<|\
    \ c |>\nThe complexity for large lists is `O(n^2)`.  It is undesirable to use\
    \ this approach in real code.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  if l==nil\
    \ then return nil end\n  if l==1 then return 1 end\n  local half = math.floor(#l/2)\n\
    \  if half*2 == #l then return l[half] end\n  local mid = half+1\n  local x0 =\
    \ median(l:sub(1,half))\n  local x1 = median(l:sub(half,#l))\n  if x0 > x1 then\n\
    \    return x0\n  else\n    return x1\n  end\nend", "  if #l == 0 then\n    error(\"\
    median() called on empty list.\")\n  end\n  local mid = math.floor(#l / 2)\n \
    \ if #l % 2 == 0 then\n    return l[mid]\n  else\n    local m = median(l, mid\
    \ + 1)\n    if #l % 2 == 1 then\n      return (m + l[mid]) / 2\n    else\n   \
    \   return (m + l[mid]) / 2 + l[mid+1]\n    end\n  end\nend", "  if #l == 0 then\n\
    \    return nil\n  end\n  local s = table.remove(l, (#l) / 2)\n  local mid = #l\
    \ / 2\n  while mid > 1 and table[mid-1] < s do\n    mid = mid/2\n  end\n  if mid\
    \ == 1 then\n    return s\n  end\n  if mid % 2 == 0 then\n    return median(table.unpack(l,\
    \ 1, mid))\n  else\n    return median(table.unpack(l, mid+1, #l))\n  end\nend",
  "  local n = #l\n  if n == 0 then\n    return nil\n  end", "  local n = 1\n  local\
    \ median\n  if #l > 0 then\n    -- We want the median of \"n\" elements, \n  \
    \  -- not the \"n+1\" element since we\n    -- want to put that to the left.\n\
    \    -- So we calculate the median as\n    -- a weighted arithmetic mean.\n  \
    \  median = math.abs(((n - 1) * n + 1) /\n                     ((n - 1) * n +\
    \ n + 1))\n  else\n    -- If the table is empty, we just return the empty value.\n\
    \    median = nil\n  end\n  if type(median) ~= 'number' then\n    error('median:\
    \ not a number')\n  end\n  return median\nend", "  local n = #l\n  if not n then\
    \ return nil end\n  if n % 2 == 1 then -- odd number\n    return l[((n+1)/2)-1]\n\
    \  else\n    local mid = n/2\n    local low = median(l[mid-1])\n    local high\
    \ = median(l[mid])\n    return low + (high-low)*0.5\n  end\nend", "  if l==nil\
    \ then return 0 end\n  local mid = math.floor((#l+1)/2)\n  if mid==1 then return\
    \ l[mid] end\n  if mid==2 then return (median(l[1]) + median(l[2]))/2\n  end\n\
    \  return median(median(l[mid]-l[mid-1]), median(l[mid-1]-l[mid]))\nend", "  if\
    \ #l == 0 then\n    return nil\n  else\n    local half = math.floor(#l / 2)\n\
    \    local i = half + 1\n    local m = l[i]\n    for j = i + 1, #l do\n      if\
    \ l[j] < m then\n        m = l[j]\n      end\n    end\n    return m\n  end\nend",
  "  local n = #l\n  if n < 2 then\n    return l[1]\n  end\n  local mid = n / 2\n\
    \  local i, j = mid, mid", "  if not (type(l) == 'table') then\n    error(['toyz.median:\
    \ expected a table as argument 1, got ' .. type(l)])\n  end\n  if #l < 0 then\n\
    \    error('toyz.median: cannot calculate median of negative arrays')\n  end\n\
    \  if #l == 0 then\n    error('toyz.median: cannot calculate median of empty arrays')\n\
    \  end\n  if #l == 1 then\n    return l[1]\n  end\n  local pivot = (#l-1)/2\n\
    \  if #l % 2 == 1 then\n    return l[pivot]\n  end\n  local a = median(l[1:pivot])\n\
    \  local b = median(l[pivot+1:end])\n  return math.floor(math.abs(a + b) / 2)\n\
    end", "  local n = #l\n  if n == 0 then return 0 end\n  local median\n  if n %\
    \ 2 == 0 then\n    median = l[((n - 1) / 2)] + (l[((n - 1) / 2)] + l[(((n - 1)\
    \ / 2) + 1)]) / 2\n  else\n    median = l[((n - 1) / 2)]\n  end\n  return median\n\
    end", "    if type(l) ~= 'table' then\n        return nil\n    end\n    local\
    \ len = #l\n    if len == 0 then\n        return nil\n    end\n    local halflen\
    \ = math.floor(len / 2)\n    local median1 = l[halflen]\n    local median2 = l[halflen\
    \ - 1]\n    if median1 ~= median2 then\n        return median1 \n    else\n  \
    \      return median1 + (len % 2 == 0 and 1 or -1)\n    end\nend", "  local num\
    \ = #l\n  if not num then return nil end\n  if num % 2 == 1 then -- even\n   \
    \ local mid = math.floor((num - 1) / 2)\n    return median(l[mid]) and median(l[mid])\
    \ or median(l[num - 1])\n  else -- odd\n    local mid = math.floor((num - 1) /\
    \ 2) + 1\n    return median(l[mid]) and median(l[mid]) or median(l[num - 1])\n\
    \  end\nend", "  local count = math.floor(#l / 2)\n  if #l % 2 ~= 0 then\n   \
    \ count = count + 1\n  end\n  return table.sort(l)[count]\nend", "  local _, count\
    \ = select(2, luaL_getn(l, 1))\n  if count % 2 == 1 then return nil end\n  local\
    \ middle = count / 2\n  local median = nil\n  for i=1, count do\n    median =\
    \ middle + (middle - math.floor((middle + 1) / 2))\n    if median == l then\n\
    \      return l[middle]\n    end\n  end\n  return median\nend", "  if l==nil then\n\
    \    return nil\n  end\n  local n = #l\n  if n==0 then\n    return nil\n  end\n\
    \  local half = math.ceil(n / 2)\n  if n < 10 then\n    return l[half]\n  end\n\
    \  local l1 = {}\n  local l2 = {}\n  for i=half,1,-1 do\n    l1[i] = l[i]\n  end\n\
    \  for i=1,n do\n    l2[i] = l[i - half]\n  end\n  local sum1 = 0.0\n  local sum2\
    \ = 0.0\n  local count = 0\n  for i=1,n do\n    sum1 = sum1 + l1[i]\n    sum2\
    \ = sum2 + l2[i]\n    count = count + 1\n  end\n  if count==0 then\n    return\
    \ nil\n  end\n  local m = sum2 / count\n  local count = 0\n  for i=1,n do\n  \
    \  sum1 = sum1 - l1[i]\n    sum2 = sum2 - l2[i]\n    count = count + 1\n  end\n\
    \  return m / count\nend", "   local half = math.floor((#l+1)/2)\n   return l[half]\
    \ or l[half-1]\nend", "  if #l == 0 then\n    return nil\n  end\n  local n = 1\n\
    \  local m = table.remove(l, 1)\n  for i = #l + 1, 1 do\n    if table.remove(l,\
    \ i) < m then\n      n = i\n      m = table.remove(l, i)\n    end\n  end\n  return\
    \ m\nend", "  if #l == 0 then\n    -- Empty tables are special (median of empty\
    \ list is NaN)\n    return NaN\n  elseif #l == 1 then\n    return l[1]\n  end",
  "  if #l == 0 then return nil end\n  local idx = 1\n  local median = l[1]\n  for\
    \ i = 2, #l do\n    if l[i] < median then\n      idx = i\n      median = l[idx]\n\
    \    end\n  end\n  return median\nend", "  if l==nil then\n    return nil\n  end\n\
    \  local m = math.random()\n  local i = #l\n  while i>0 do\n    m = m + (l[i]/i)\n\
    \    i = i-1\n  end\n  if m%2==0 then\n    return m\n  else\n    return m+l[math.floor((#l+1)/2)]\n\
    \  end\nend", "  local count, sum = 0, 0\n  for _, v in ipairs(l) do\n    count\
    \ = count + 1\n    sum = sum + v\n  end\n  return sum / count\nend", "  if #l\
    \ == 0 then\n    return nil\n  end\n  local last = l[1]\n  local m = #l - 1\n\
    \  for i = 2, m do\n    last = l[i]\n    if last < l[i - 1] then\n      return\
    \ last\n    end\n  end\n  return last\nend", "  if #l == 0 then\n    error(\"\
    median of empty list\")\n  end\n  if #l == 1 then\n    return l[1]\n  end\n  local\
    \ mid_idx = #l/2\n  if mid_idx == 1 then\n    local val = l[mid_idx]\n    if val\
    \ == 0 then\n      error(\"median of empty list\")\n    else\n      return val\n\
    \    end\n  end\n  if l[mid_idx] ~= nil then\n    return median(l[mid_idx], l[mid_idx-1])\n\
    \  end\n  local mid = median(l[mid_idx-1], l[mid_idx])\n  if l[mid_idx-1] ~= nil\
    \ then\n    return mid\n  end\n  return mid\nend", "  if #l <= 1 then return l[1]\
    \ end\n  local t = l [#l/2]\n  local i = #l - 1\n  while i >= 1 do\n    t = t\
    \ + (l[i] + (l[i] * 1.0 / 2))\n    i = i - 1\n  end\n  return t\nend", "  if #l\
    \ == 0 then\n    return nil\n  end\n  local mid = math.ceil(#l / 2)\n  if #l >\
    \ 2 and mid*2 < #l then\n    return median(l, mid)\n  end\n  return l[mid]\nend",
  "  if #l == 0 then\n    return nil\n  end", "  if not (type(t) == \"table\") then\n\
    \    error({\n      message = \"median expects a table as argument\",\n      call\
    \ = \"median\"\n    })\n  end", "  if l == nil then return nil end\n  local n\
    \ = #l\n  if n == 1 then\n    return l[1]\n  end\n  local half = math.floor(n\
    \ / 2)\n  if half == n then\n    return l[1]\n  else\n    local med = nil\n  \
    \  for i = 1, half do\n      local value = l[i]\n      if med == nil or value\
    \ < med then\n        med = value\n      end\n    end\n    if half == (n / 2)\
    \ then\n      med = med\n    else\n      local small = median(l, 1, half - 1)\n\
    \      if small == nil then return nil end\n      local large = median(l, half\
    \ + 1, n)\n      if large == nil then return nil end\n      return (med + large)\
    \ / 2\n    end\n  end\nend", "  if #l == 0 then\n    -- Special case of a 1-element\
    \ list.\n    return 0\n  end\n  local mid = math.floor(#l/2)\n  if #l % 2 == 1\
    \ then\n    local med = mid\n    if l[mid+1] < l[mid] then\n      med = mid +\
    \ 1\n    end\n    if med == mid then\n      -- If the median is odd, return the\
    \ middle element.\n      return l[mid]\n    else\n      -- If the median is even,\
    \ return the middle element.\n      return (l[med + 1] + l[med]) / 2\n    end\n\
    \  else\n    local low = mid\n    local high = mid\n    if l[mid] <= l[mid+1]\
    \ then\n      low = mid+1\n    end\n    if l[mid] < l[mid+1] then\n      high\
    \ = mid+1\n    end\n    if low == high then\n      -- If the range is even, return\
    \ the middle element.\n      return l[mid]\n    else\n      -- If the range is\
    \ odd, return the middle element.\n      return (l[low] + l[high]) / 2\n    end\n\
    \  end\nend", "  if l==nil then return nil end\n  local n, s = 0, {}\n  for _,\
    \ v in ipairs(l) do s[n] = v end\n  n = n - 1\n  if n%2 == 0 then return s[n/2]\
    \ / 2.0 end\n  local mid = math.floor(n/2)\n  return s[mid - 1] + s[mid]/2\nend",
  "  if #l == 0 then\n    return nil\n  end\n  local n = #l\n  if n % 2 == 0 then\n\
    \    return l[n / 2]\n  elseif n % 2 == 1 then\n    return (l[n / 2] + l[n / 2\
    \ - 1]) / 2\n  end\nend", "  if l==nil then return nil end\n  local _len = #l\n\
    \  local _middle = _len/2\n  if _len%2 then\n    return l[_middle]\n  else\n \
    \   return (l[_middle] + l[_middle-1])/2\n  end\nend", "  local median = nil\n\
    \  if l[1] and l[2] then\n    median = l[1] + l[2] / 2\n  elseif #l == 1 then\n\
    \    median = l[1]\n  else\n    median = #l / 2\n    for _, v in ipairs(l) do\n\
    \      median = median + v / 2\n    end\n  end\n  return median\nend", "  if #l\
    \ == 0 then return nil end\n  local last = nil\n  local mid = #l / 2\n  for i\
    \ = 1, mid do\n    if l[i] ~= last then\n      last = l[i]\n    end\n  end\n \
    \ return last + median(mid, l)\nend", "  local n = #l\n  if n <= 1 then return\
    \ l[1] end\n  if n == 2 then\n    local m = math.abs(l[1] - l[2])\n    if m >=\
    \ MARGIN then return m end\n  end\n  -- Odd size\n  local m = n / 2\n  local lower\
    \ = 1\n  local upper = m + 1\n  while lower <= upper do\n    -- Test if middle\
    \ element is in the right position\n    local pos = math.floor((lower + upper)\
    \ / 2)\n    local val = l[pos]\n    local m2 = math.abs(val - l[pos - 1])\n  \
    \  if m2 >= MARGIN then\n      upper = pos - 1\n    else\n      lower = pos +\
    \ 1\n    end\n  end\n  -- Return average of middle two elements\n  local middle\
    \ = l[lower, upper]\n  return middle / (lower + upper)\nend", "  return math.sort(l):gsub(\"\
    (%d%d?%d?%d?%d?)(%d%d?%d?%d?%d?)\",\n    function(x)\n      if x % 2 == 1 then\
    \ return x end\n      return (x/2) % 5 + 1\n    end)[1]:gsub(\"(%d%d?%d?%d?%d?)(%d%d?%d?%d?%d?)\"\
    ,\n    function(x)\n      if x % 2 == 1 then return x end\n      return (x/2)\
    \ % 5 + 1\n    end)[2]\nend", "    local n = #l\n    if n < 1 then\n        return\
    \ nil\n    end\n    if n % 2 == 1 then\n        return l[(n - 1) / 2]\n    end\n\
    \    local half = math.floor(n / 2)\n    local lower = median {\n        l = l,\n\
    \        i = 1,\n    }\n    local upper = median {\n        l = l,\n        i\
    \ = half,\n    }\n    return (lower + upper) / 2.0\nend", "  local middle, count\
    \ = 0, 1\n  local function increment() \n    middle = math.floor(count / 2)\n\
    \    count = count % 2\n  end \n  l.sort(function(a, b) return a < b end) \n \
    \ repeat\n    increment()\n  until count == 0 or middle == count\n  return middle\n\
    end", "  local n = #l\n  if n ~= 0 then\n    local i, m = math.modf(n / 2.0)\n\
    \    if m == 0 then\n      return l[i]\n    else\n      return l[i - 1] + 0.5\
    \ * (l[i] - l[i - 1])\n    end\n  end\nend", "   local m = nil\n   if #l > 1 then\n\
    \      m = ((l[#l][1] + l[#l][#l]) / 2.0):round()\n      for i = #l - 1, 1, -1\
    \ do\n         if l[i][#l] >= m then\n            m = l[i][#l]\n         else\n\
    \            break\n         end\n      end\n   end\n   return m\nend", "  local\
    \ n = #l\n  if n == 0 then return nil end\n  local mid = math.floor(n / 2)\n \
    \ if n % 2 == 0 then\n    return l[mid]\n  else\n    return median(l, mid + 1,\
    \ n - 1)\n  end\nend", "  local n = #l\n  if n == 0 then\n    return nil\n  end\n\
    \  local h = (n - 1) / 2\n  local med = table[h]\n  for i = 1, n do\n    if table[i\
    \ + h] < med then\n      med = table[i + h]\n    end\n  end\n  return med\nend",
  "  if #l == 0 then return nil end\n  local mid = math.floor(#l/2)\n  if mid == 0\
    \ then return l[mid] end\n  local high = mid\n  local low = mid\n  while low <\
    \ #l and l[low] < l[high] do\n    high = low + 1\n  end\n  while high > 1 and\
    \ l[high] == l[high-1] do\n    high = high - 1\n  end\n  -- In [low, high) order\
    \ find median.\n  local median = l[low]\n  for i = low, high-1 do\n    median\
    \ = median + l[i]\n  end\n  median = median / 2\n  return median\nend", "  local\
    \ n = #l\n  if n == 0 then return nil end\n  local m = math.floor(n / 2) + 1\n\
    \  if n % 2 == 1 then\n    return l[m]\n  end\n  local lo, mi, hi = (m-1) * 2,\
    \ m * 2, m * 3\n  for i = lo, hi  do\n    local m = i + m\n    if m <= n then\n\
    \      if m % 2 == 0 then return l[m] end\n      if l ~= l[m] then return l[m]\
    \ end\n    end\n  end\n  return l[m]\nend", "  local sorted = l.sorted()\n  if\
    \ #sorted == 0 then\n    return nil\n  end\n  return sorted[#sorted / 2]\nend",
  "  if l==nil then\n    return nil\n  end", '  local median, n', "  local keys =\
    \ table.sort(table.keys(l))\n  if #keys == 1 then\n    return l[keys[1]]\n  end\n\
    \  local index = #l / 2\n  local lower = keys[index]\n  local upper = keys[index\
    \ + 1]\n  local value = nil\n  if lower:isnumber() and upper:isnumber() then\n\
    \    value = math.fmod(lower + math.fmod((upper - lower), 2), 2)\n  else\n   \
    \ value = median(lower)\n  end\n  if value == nil then\n    return median(upper)\n\
    \  end\n  return value\nend", "  local median = nil\n  if l == nil then return\
    \ nil end\n  local n, m = #l, 1\n  if n % 2 == 0 then\n    median = l[n / 2]\n\
    \    for i = 1, n / 2 do\n      local j = ((i + 1) % n) + 1\n      median = (median\
    \ + l[j]) / 2\n    end\n  else\n    median = l[n / 2]\n    for i = 1, n / 2 do\n\
    \      local j = (i + 1) % n\n      median = (median + l[j]) / 2\n    end\n  end\n\
    \  return median\nend", "    local l = {...l}\n    local n, m = #l, 0\n    if\
    \ n <= 1 then\n        return l[1]\n    end\n    local m = n / 2\n    local left,\
    \ right = 1, n - 1\n    while left <= right do\n        if l[m] > l[right] then\n\
    \            right = m\n        else\n            left = m\n        end\n    \
    \    m = n / 2\n    end\n    if n == 1 or l[m] <= l[right] then\n        return\
    \ l[m]\n    else\n        return l[right]\n    end\nend", "  if l==nil then\n\
    \    return nil\n  elseif #l==1 then\n    return l[1]\n  else\n    local mid =\
    \ #l / 2\n    local half = median(l[1:mid])\n    return half+l[mid] if (half +\
    \ l[mid]) % 2 == 0 then\n      return half\n    else\n      return half + l[mid]\n\
    \    end\n  end\nend", "  local n = #l\n  if n < 1 then return nil end\n  -- Find\
    \ pivot using binary search.\n  local pivot, i = math.floor(n / 2), 1\n  while\
    \ i <= n do\n    if l[i] < l[pivot] then pivot, i = i, i + 1 end\n    i = i +\
    \ 1\n  end\n  -- If n is not an exact multiple of the pivot then recurse.\n  if\
    \ n % pivot == 0 then return median(l)\n  elseif pivot == 0 then return l[pivot]\
    \ end\n  -- Divide l into two parts.\n  local pivoted = l[pivot]\n  l[pivot],\
    \ l[n - 1] = l[n - 1], l[pivot]\n  -- Find the median.\n  -- Divide l into three\
    \ parts.\n  -- Recurse.\n  local pivoted2, i = 1, 1\n  while i <= n do\n    if\
    \ l[i] < pivoted then pivoted2, i = i, i + 1 end\n    i = i + 1\n  end\n  -- Return\
    \ the middle value.\n  return pivoted + pivoted2\nend", "  if not l then return\
    \ nil end\n  local n = #l\n  if n <= 1 then return l[1] end\n  if n % 2 == 0 then\n\
    \    local i = math.floor(n / 2)\n    if n % 2 == 1 then\n      return (l[i] +\
    \ l[i+1])/2\n    end\n    local low = median(l[i..n-1])\n    local high = median(l[1..i])\
    \ \n    return (high + low) / 2\n  end\n  local i = math.floor(n / 2)\n  return\
    \ l[i]\nend", "  local nums = {}\n  for k, v in pairs(l) do\n    nums[k] = nums[k]\
    \ or v\n  end\n  return math.floor((nums[#nums] - nums[#nums]./5 + nums[#nums]./5)\
    \ / 2)\nend", "  local middle = #l / 2\n  if middle % 2 == 0 then return (l[middle]\
    \ + l[middle - 1]) / 2\n  else return l[middle]\n  end\nend", "    local n = #l\n\
    \    if n < 1 then return nil end\n    if n <= 2 then return l[1] end\n    local\
    \ mid = math.floor(n/2)\n    return median(l[mid-1], l[mid]) if mid > 1 then\n\
    \        return median(l[mid-1], l[mid-1]) -- Median = (L[2*mid - 1] + L[2*mid])/2\n\
    \    end\n    return l[mid]\nend", "  local n = #l\n  if n == 0 then return nil\
    \ end\n  local mid = n/2\n  if n % 2 == 0 then\n    return mid\n  else\n    return\
    \ median(l[mid..n])\n  end\nend", "  local total\n  if #l == 0 then\n    return\
    \ nil\n  elseif #l == 1 then\n    total = l[1]\n  else\n    total = l[1]\n   \
    \ for i = 2, #l do\n      total = total + l[i] / (i - 1)\n    end\n  end\n  return\
    \ total\nend", "  if #l == 0 then\n    return nil\n  end", "  if #l == 0 then\n\
    \    return nil\n  else\n    local mid_index = math.floor(#l / 2)\n    if mid_index\
    \ == 0 then\n      return l[mid_index][1]\n    else\n      return (l[mid_index][1]+l[mid_index+1][1])\
    \ / 2\n    end\n  end\nend", "  local median = 0\n  local count = 0", "  if #l\
    \ == 0 then\n    return nil\n  end\n  local last = math.floor(#l / 2)\n  if #l\
    \ % 2 == 0 then\n    return l[last]\n  else\n    return ((l[last - 1] + l[last])\
    \ / 2)\n  end\nend", "  return _median.default(l, l.N)\nend", "  -- If l is empty,\
    \ return nil.\n  if not l then return nil end", "  local median = {}\n  for _,v\
    \ in ipairs(l) do\n    table.insert(median, v)\n  end\n  return table.median(median)\n\
    end", "  local n = #l\n  local sorted = {}\n  local i, j, v\n  for i = 1, n do\n\
    \    v = l[i]\n    if v < 0 then v = -v end\n    sorted[#sorted+1] = v\n  end\n\
    \  n = #sorted\n  local mid = n/2\n  local l1 = sorted\n  local l2 = {}\n  for\
    \ i = 1, n do\n    if i < mid then\n      l2[i] = sorted[i]\n    else\n      l2[i]\
    \ = sorted[mid]\n      mid = math.floor((n-1)/2)\n    end\n  end\n  local j\n\
    \  local count = 0\n  for i = 1, n do\n    if l1[#l1] == l2[i] then\n      count\
    \ = count + 1\n    end\n  end\n  return count / 2\nend", "  if #l == 0 then\n\
    \    return nil\n  end", "  if #l == 0 then return nil end\n  local middle = math.floor(#l/2)\n\
    \  if middle == 1 then return l[middle] end\n  local i1, i2 = middle-1, middle+1\n\
    \  local v1 = median(l[i1]) or nil\n  local v2 = median(l[i2]) or nil\n  return\
    \ (v1 + v2) / 2.0\nend", "  if l == nil then return nil end\n  local n = #l\n\
    \  if n % 2 == 1 then return l[((n + 1) / 2) - 1] end\n  local half = math.floor((n\
    \ + 1.0) / 2)\n  return median(l[half], l[half + 1])\nend", "  if l[1] == nil\
    \ then\n    error(\"median requires non-empty list.\", 2)\n  end\n  local middle\
    \ = (#l) + 1\n  if middle % 2 ~= 0 then\n    middle = middle - 1\n  end\n  local\
    \ half = math.floor(middle / 2)\n  if #l == 0 then\n    return nil\n  end\n  local\
    \ pivot\n  if half > 1 then\n    pivot = l[half]\n  else\n    pivot = l[middle\
    \ - 1]\n  end\n  local i\n  for i = middle - 1, 1, -1 do\n    if l[i] <= pivot\
    \ then\n      l[i - 1] = l[i]\n      l[i] = pivot\n      break\n    end\n  end\n\
    \  return l[1]\nend", '  if #l < 1 then return nil end']
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
