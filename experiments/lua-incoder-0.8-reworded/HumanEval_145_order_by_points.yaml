name: HumanEval_145_order_by_points
language: lua
prompt: "-- Write a function which sorts the given table of integers\n-- in ascending\
  \ order according to the sum of their digits.\n-- Note: if there are several items\
  \ with similar sum of their digits,\n-- order them based on their index in original\
  \ table.\n-- For example:\n-- >>> order_by_points({1, 11, -1, -11, -12})\n-- {-1,\
  \ -11, 1, -12, 11}\n-- >>> order_by_points({})\n-- {}\nlocal function order_by_points(nums)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = order_by_points\n\
  \    lu.assertEquals(candidate({1, 11, -1, -11, -12}), {-1, -11, 1, -12, 11})\n\
  \    lu.assertEquals(candidate({1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
  \ 3, 56, 0, 46}), {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457})\n\
  \    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, -11,\
  \ -32, 43, 54, -98, 2, -3}), {-3, -32, -98, -11, 1, 2, 43, 54})\n    lu.assertEquals(candidate({1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}), {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9})\n    lu.assertEquals(candidate({0,\
  \ 6, 6, -76, -21, 23, 4}), {-76, -21, 0, 4, 23, 6, 6})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if #nums <= 1 then return nums end\n  local i = 1\n  local table\
    \ = {}\n  local tmp = 0\n  while i <= #nums do\n    if i == 1 then\n      table.insert(tmp,\
    \ nums[i])\n      tmp = 1\n    else\n      tmp = 10 * tmp + nums[i]\n      if\
    \ tmp > 0 then\n        table.insert(tmp, nums[i])\n      end\n    end\n    i\
    \ = i + 1\n  end\n  table.sort(function(a,b) return a + b - tmp end)\n  return\
    \ table\nend", '  if #nums < 1 then return end', "  if not nums then return end\n\
    \  local maxs = terralib.newlist()\n  local total = 0\n  for k, v in pairs(nums)\
    \ do\n    total = total + v\n    maxs:insert(v)\n  end\n  table.sort(maxs, function(a,\
    \ b)\n    return tostring(a + b)\n  end)\n  return maxs\nend", "  local sorted_nums\
    \ = {}\n  for i, v in pairs(nums) do\n    sorted_nums[#sorted_nums+1] = i\n  end\n\
    \  table.sort(sorted_nums)\n  local num_to_order = {}\n  local index_to_order\
    \ = {}\n  local prev_v = 0\n  for _, index in ipairs(sorted_nums) do\n    if prev_v\
    \ ~= v then\n      num_to_order[prev_v] = true\n      index_to_order[prev_v] =\
    \ index_to_order[prev_v] or {}\n    end\n    index_to_order[prev_v] = index_to_order[prev_v]\
    \ or {}\n    local new_key = string.format(\"%0d\", index-1)\n    index_to_order[prev_v][#index_to_order[prev_v]+1]\
    \ = new_key\n    num_to_order[v] = new_key\n    prev_v = v\n  end\n  return num_to_order,\
    \ index_to_order\nend", "  local ts = #nums\n  if ts == 0 then\n    return {}\n\
    \  end\n  -- Make copy of original table\n  -- In case nums is sorted, copying\
    \ won't change the original one.\n  local copy = {}\n  copy[#copy+1] = nums[ts]\n\
    \  for i = ts - 1, 1, -1 do\n    local sum = 0\n    for j = i-1, 0, -1 do\n  \
    \    sum = sum + nums[j] * math.pow(10, j-1)\n    end\n    if sum > copy[#copy]\
    \ then\n      copy[#copy+1] = sum\n    end\n  end\n  return copy\nend", "  local\
    \ sorted = {}\n  for i = 1, #nums do\n    local digits = num:to_i()\n    table.insert(sorted,\
    \ 0)\n    for j = 1, digits do\n      table.insert(sorted, num:to_i())\n    end\n\
    \  end\n  return table.sort(sorted)\nend", "  -- write your code here\n  local\
    \ tt = {}\n  for _, v in pairs(nums) do\n    if v ~= nil then\n      tt[v] = tt\
    \ [v] or v\n    end\n  end\n  local maxsum = 0\n  local ordered = {}\n  for i\
    \ = 2, #tt do\n    local sum = 0\n    for j = 1, #tt do\n      if i == j then\n\
    \        sum = sum + tt[j]\n      else\n        sum = sum + tt [i] * tt [j]\n\
    \      end\n    end\n    if sum > maxsum then\n      maxsum = sum\n      ordered\
    \ = {}\n    end\n    ordered[i] = tt[i]\n  end\n  for i = 1, #tt do\n    ordered[#ordered\
    \ + 1] = tt[i]\n  end\n  return ordered\nend", "  local n = #nums\n  if n == 0\
    \ then return { }\n  -- find the sum of the numbers' digits\n  local sum = 0\n\
    \  for i = 1, n do\n    sum = sum + nums[i]\n  end\n  -- find each numbers' position\n\
    \  local pos = { }\n  local i = 0\n  while i < n do\n    -- find the sum of the\
    \ numbers' digits minus the numbers' index\n    local tmp = sum - i\n    -- if\
    \ no other numbers' sum has same digits with numbers' index,\n    -- put the numbers'\
    \ index at the end\n    if tmp == 0 then\n      table.insert(pos, i)\n      i\
    \ = n\n      break\n    end\n    -- else if there are two numbers' sums has same\
    \ digits with numbers' index,\n    -- put numbers' index between these two numbers\n\
    \    local j = i\n    repeat\n      local tmp = sum - j\n      if tmp == 0 then\n\
    \        table.insert(pos, j)\n        i = j + 1\n        break\n      end\n \
    \     j = j + 1\n    until j == i\n  end\n  -- order the numbers\n  table.sort(pos,\
    \ function(a, b) return nums[a] < nums[b] end)\n  -- rearrange the numbers' index\n\
    \  for i, v in pairs(pos) do nums[i] = v end\n  return nums\nend", "  local order\
    \ = {}\n  for i = 0, #nums do\n    local digits = {}\n    for j = 1, 10 do\n \
    \     table.insert(digits, nums[i]%10*10 + nums[i]/10)\n      nums[i] = nums[i]/10\n\
    \    end\n    local sum = table_sum(digits)\n    if sum == 0 then\n      table.insert(order,\
    \ i)\n    else\n      for j = 0, #order do\n        if sum - digits[order[j]]\
    \ > 0 then\n          table.insert(order, j)\n          break\n        end\n \
    \     end\n    end\n  end\n  return order\nend", "  local table = {}\n  for i,\
    \ v in ipairs(nums) do\n    table.insert(v, i)\n  end\n  table.sort(function (a,\
    \ b)\n    return table[a] + table[b]\n  end)\n  return table.unpack(nums)\nend",
  '    if nums == nil then return nums end', "    local function by_sum(num)\n   \
    \     local sum = 0\n        for i = 1, 9 do\n            sum = sum + num:sub(i,\
    \ i)\n        end\n        return sum\n    end\n    local nums_and_indexes = {}\n\
    \    for k, v in pairs(nums) do\n        if v ~= 0 then\n            table.insert(nums_and_indexes,\
    \ {v, k})\n        end\n    end\n    return table.sort(nums_and_indexes, by_sum)\n\
    end", "  local total = 0\n  local nums_sorted = {}", "  if #nums == 0 then\n \
    \   return nums\n  end\n  local ordered = {}\n  local index = {}\n  local sums\
    \ = {}\n  for i = 1, #nums do\n    local value = nums[i]\n    local digits = math.floor(math.abs(value))\n\
    \    local sum = digits\n    sums[digits] = sum\n    index[sum] = i\n    ordered[sum]\
    \ = i\n  end\n  local min_sum = math.min(table.sort(sums))\n  for _, sum in ipairs(sums)\
    \ do\n    if sum == min_sum then\n      table.sort(ordered, function (a, b)\n\
    \        return index[a] < index[b] or #index[a] == #index[b]\n      end)\n  \
    \  else\n      table.sort(ordered, function (a, b)\n        return index[a] <=\
    \ index[b] and index[a] > index[b] and index[a] < #index[a]\n      end)\n    end\n\
    \  end\n  return ordered\nend", "  local sorted = {}\n  local sorted_index = {}\n\
    \  local digits = {}\n  for _, v in ipairs(nums) do\n    local digit = math.floor(v\
    \ / 10)\n    table.insert(digits, digit)\n    sorted[digit] = true\n    sorted_index[digit]\
    \ = true\n  end\n  local current_sorted = true\n  while current_sorted do\n  \
    \  current_sorted = false\n    for _, v in ipairs(sorted) do\n      if not v then\n\
    \        local min_digit\n        for _, d in ipairs(digits) do\n          min_digit\
    \ = d or math.min(min_digit, d)\n        end\n        table.insert(sorted, min_digit)\n\
    \        current_sorted = true\n      end\n    end\n  end\n  return sorted_index\n\
    end", "  local keys = {}\n  local key\n  for key, value in pairs(nums) do\n  \
    \  local num = tonumber(key)\n    if not num then\n      table.insert(keys, key)\n\
    \    else\n      local digits = {}\n      for i = 0, 9 do\n        digits[i] =\
    \ tonumber(string.format('%d', num % 10))\n        num = num div 10\n      end\n\
    \      table.insert(keys, tonumber(table.concat(digits, '')))\n    end\n  end\n\
    \  table.sort(keys)\n  local sorted_nums = {}\n  local sorted_key\n  for _, sorted_key\
    \ in ipairs(keys) do\n    sorted_nums[sorted_key] = nums[sorted_key]\n  end\n\
    \  table.sort(sorted_nums)\n  return sorted_nums\nend", "  local n = #nums\n \
    \ local output = {}\n  local keys = {}", "  local ordered = {}\n  for i = 1, #nums\
    \ do\n    local num = nums[i]\n    if num ~= 0 then\n      ordered[#ordered +\
    \ 1] = (#ordered + 1) * num\n    end\n  end\n  table.sort(ordered, function(a,\
    \ b) return ordered[a] - ordered[b] end)\n  for i = 1, #nums do\n    nums[i] =\
    \ ordered[i]\n  end\n  return nums\nend", "   if #nums == 0 then return nums\n\
    \   local numlist = table.concat(nums)\n   numlist[1] = numlist[1] + numlist[1]\n\
    \   return numlist\nend\nreturn order_by_points", "   if nums == nil then\n  \
    \    return nil\n   end", "  if #nums < 2 then return end\n  local sum\n  for\
    \ _, v in ipairs(nums) do\n    if not sum then sum = v end\n    sum = sum + v\n\
    \  end\n  local sorted\n  for i=1, #nums do\n    local k = i\n    local j = i\n\
    \    while j > 0 and k > 0 and sum >= nums[k] and sum <= nums[j] do\n      if\
    \ sum == nums[k] then\n        sorted = table.insert(sorted, k)\n      else\n\
    \        sorted = table.insert(sorted, j)\n      end\n      k = k - 1\n      j\
    \ = j - 1\n    end\n  end\n  return sorted\nend", "  local num_map = {}\n  local\
    \ num_set = {0}\n  for i = 1, #nums do\n    local num_sum = string.format('%010d',\
    \ nums[i])\n    -- Create num_map[num_sum] if it doesn't exist\n    if not num_map[num_sum]\
    \ then\n      num_map[num_sum] = {i = i, nums = {}}\n    else\n      -- Add num\
    \ to num_sum's nums\n      num_map[num_sum].nums[#num_map[num_sum].nums + 1] =\
    \ nums[i]\n    end\n    -- Add num to num_set\n    -- nums[i] = nums[i] is not\
    \ used, but num_set is\n    -- in order to keep track of duplicated numbers\n\
    \    -- if same sum appears several times.\n    table.insert(num_set, nums[i])\n\
    \  end\n  -- Remove duplicate nums and sort them\n  local sorted_nums = {}\n \
    \ for num_sum, pairs in pairs(num_map) do\n    local nums = pairs.nums\n    --\
    \ if nums has same sum as others, sort them based on\n    -- their index in original\
    \ table\n    if #nums == 1 then\n      sorted_nums[num_sum] = nums[pairs.i]\n\
    \      num_set[pairs.i] = nil\n      -- Remove duplicated nums\n      local i\
    \ = 1\n      while #nums > i do\n        local v = nums[i]\n        table.insert(sorted_nums,\
    \ v)\n        num_set[v] = nil\n        -- Remove duplicated nums\n        if\
    \ num_set[v] == nil then\n          table.remove(nums, i)\n          i = i - 1\n\
    \        else\n          i = i + 1\n        end\n      end\n    else\n      --\
    \ Remove duplicated nums\n      local i = 1\n      while #nums > i do\n      \
    \  local v = nums[i]\n        table.insert(sorted_nums, v)\n        num_set[v]\
    \ = nil\n        if num_set[v] == nil then\n          table.remove(nums, i)\n\
    \          i = i - 1\n        else\n          i = i + 1\n        end\n      end\n\
    \    end\n  end\n  -- Return sorted table\n  return sorted_nums\nend", "  local\
    \ table = {}\n  for i, num in ipairs(nums) do\n    table[i] = num\n  end\n  table.sort(function(a,\
    \ b) return a + b - a end)\n  return table\nend", "    local map = {}\n    for\
    \ i = 1, #nums do\n        local sum = 0\n        for j = 1, 10 do\n         \
    \   sum = sum + nums[i][j]\n        end\n        table.insert(map, sum)\n    end\n\
    \    table.sort(map)\n    local ans = {}\n    for i = 1, #nums do\n        table.insert(ans,\
    \ nums[map[i]])\n    end\n    return ans\nend", "    if #nums == 0 then return\
    \ nums end\n    -- Sort nums by their sum of their digits.\n    nums = nums:map(function(x)\
    \ return tonumber(string.sub(tostring(x), 1, #x)):reverse() end)\n    local sums\
    \ = nums:map(function(x) return #x end)\n    for i = 1, #sums do\n        for\
    \ j = i, #sums do\n            if sums[j] == sums[i] then\n                sums[j],\
    \ sums[i] = sums[i], sums[j]\n                nums[j], nums[i] = nums[i], nums[j]\n\
    \            end\n        end\n    end\n    -- Sort the numbers based on their\
    \ sum.\n    return nums:map(function(x) return sums[#sums - 1] - x end):reverse()\n\
    end", "   local function cmp(x, y) \n      -- Find sum of digits first, then compare\
    \ them.\n      local xs = x:gmatch(\"(%d*)\") \n      local ys = y:gmatch(\"(%d*)\"\
    ) \n      local xsuf = 0 \n      for i = 0, x#-1 do\n         xsuf = xsuf + tonumber(xs[i])\n\
    \      end\n      local ysuf = 0 \n      for i = 0, y#-1 do\n         ysuf = ysuf\
    \ + tonumber(ys[i])\n      end\n      if xsuf > ysuf then\n         return 1\n\
    \      elseif xsuf < ysuf then\n         return -1\n      else\n         return\
    \ 0\n      end\n   end", "  local function sum(nums)\n    local sum = 0\n    for\
    \ i = 1, #nums do\n      sum = sum + tonumber(tostring(nums[i])):byte()\n    end\n\
    \    return sum\n  end\n  local keys = {}\n  local num\n  for _, num in ipairs(nums)\
    \ do\n    if nums[num] == num then\n      table.insert(keys, num)\n    end\n \
    \ end\n  table.sort(keys, function(a, b) return sum(b) - sum(a) end)\n  local\
    \ ret = {}\n  for _, k in ipairs(keys) do\n    ret[k] = nums[k]\n  end\n  return\
    \ ret\nend", "    local nums_sorted = {}\n    for idx, val in ipairs(nums) do\n\
    \        local digit = math.floor(math.log(val) / math.log(10) + 1)\n        --\
    \ We don't need to worry about comparing negative numbers.\n        -- If the\
    \ number is negative, comparing it to 0 will give 0.\n        -- If the number\
    \ is positive, comparing it to 0 will give 0.\n        -- So we don't have to\
    \ worry about that here.\n        table.insert(nums_sorted, idx + (digit or 0))\n\
    \    end\n    -- sort numbers in ascending order\n    for idx, val in ipairs(nums_sorted)\
    \ do\n        table.insert(nums_sorted, val)\n    end\n    return nums_sorted\n\
    end", "  local nums_len = #nums\n  if nums_len == 0 then return {} end\n  local\
    \ digits = {}\n  local max_digit = #nums\n  for i = 1, max_digit do\n    digits[i]\
    \ = 0\n    for j = i, max_digit do\n      digits[i] = digits[i] + nums[j] % 10\n\
    \      nums[j] = nums[j] / 10\n    end\n  end\n  local sorted = {}\n  for _, v\
    \ in ipairs(digits) do\n    table.insert(sorted, v)\n  end\n  table.sort(sorted)\n\
    \  local keys = {}\n  for i = 1, #sorted do\n    table.insert(keys, sorted[i])\n\
    \  end\n  return keys\nend", "  if #nums == 0 then return nums end\n  local sum\
    \ = 0\n  local ordered = {}\n  for i = 1, #nums do\n    sum = sum + nums[i]\n\
    \    ordered[sum] = nums[i]\n  end\n  table.sort(ordered, function(a, b)\n   \
    \ return a - b\n  end)\n  -- Sort by original order in table\n  local i = 1\n\
    \  for k, v in pairs(ordered) do\n    nums[i] = v\n    i = i + 1\n  end\n  return\
    \ nums\nend", "  local nums_sorted = {}\n  local nums_len = {}", "    local s\
    \ = sum(nums)\n    if s == 0 then\n        return {}\n    end\n    local t = {}\n\
    \    for idx, v in ipairs(nums) do\n        t[s + v] = idx\n    end\n    return\
    \ t\nend", "  local nums_sorted = {}\n  local min_digits = nil\n  local max_digits\
    \ = nil\n  for i, num in ipairs(nums) do\n    local digits = math.floor(math.log(num))\n\
    \    local total_digits = digits + min_digits\n    if total_digits < min_digits\
    \ then\n      min_digits = total_digits\n    end\n    if total_digits > max_digits\
    \ then\n      max_digits = total_digits\n    end\n    if nums_sorted[total_digits]\
    \ then\n      nums_sorted[total_digits] = nums_sorted[total_digits] + 1\n    else\n\
    \      nums_sorted[total_digits] = num\n    end\n  end\n  local nums_sorted =\
    \ table.sort(nums_sorted)\n  for i, num in ipairs(nums_sorted) do\n    nums[i]\
    \ = num\n  end\n  if max_digits == min_digits then\n    table.sort(nums)\n  end\n\
    end", "   -- Write your code here\n   \nend", "  local nums_sorted = {}\n  local\
    \ nums_size = #nums\n  for idx = 1, nums_size do\n    local num = nums[idx]\n\
    \    local sum_digits = 0\n    for i = 1, 9 do\n      sum_digits = sum_digits\
    \ + math.floor((num - math.floor(num))*math.pow(10, i))\n    end\n    local order\
    \ = sum_digits - math.floor(sum_digits)\n    if nums_sorted[order] then\n    \
    \  order = 1\n    end\n    nums_sorted[order] = num\n  end\n  table.sort(nums_sorted)\n\
    \  return nums_sorted\nend", "  if #nums == 0 then\n    return {}\n  end\n  local\
    \ last_sum = 0\n  local order = {}\n  for i = 1, #nums do\n    local sum = tonumber(string.format('%g',\
    \ nums[i])) or 0\n    if last_sum < sum then\n      table.insert(order, i)\n \
    \   end\n    last_sum = sum\n  end\n  table.sort(order)\n  local res = {}\n  local\
    \ last_index = 1\n  for i = 1, #nums do\n    if i == 1 then\n      res[i] = nums[order[i]]\n\
    \    elseif order[i - 1] > i then\n      res[i] = nums[order[i - 1]]\n    end\n\
    \  end\n  local index = last_index + 1\n  while last_index > 1 do\n    local last\
    \ = res[last_index]\n    res[last_index] = res[index]\n    res[index] = last\n\
    \    last_index = last_index - 1\n  end\n  return res\nend", "  local sorted =\
    \ {}\n  for i, v in ipairs(nums) do\n    if sorted[v] ~= nil then\n      table.insert(sorted[v],\
    \ i)\n      sorted[v] = sorted[v]\n      continue\n    end\n    local digits =\
    \ 0\n    local tmp = {}\n    for ch in v:gmatch(\"%d*\") do\n      digits = digits\
    \ + ch\n      tmp[#tmp + 1] = ch\n    end\n    local tmp = table.sort(tmp, function(a,\
    \ b)\n      return digits - tonumber(b) - tonumber(a)\n    end)\n    for j = 1,\
    \ #tmp do\n      sorted[v + j] = tmp[j]\n    end\n  end\n  return sorted\nend",
  "  if #nums == 0 then\n    return {}\n  end", "  local result = {}\n  for i = 1,\
    \ #nums do\n    local sum = 0\n    for j = 1, 10 do\n      sum = (sum + nums[i][j])\
    \ % 10\n    end\n    result[sum] = result[sum] or {}\n    result[sum][#result[sum]\
    \ + 1] = i\n  end\n  return result\nend", "  local nums_sorted = {}\n  for i =\
    \ 1, #nums do\n    local key = ''\n    local sum = 0\n    for j = 1, 10 do\n \
    \     sum = sum + nums[i][j] % 10\n      key = key .. nums[i][j] .. '-'\n    end\n\
    \    table.insert(nums_sorted, {sum, key})\n  end\n  table.sort(nums_sorted, function(a,\
    \ b) return a[1] > b[1] end)\n  return nums_sorted\nend", "  if #nums == 0 then\n\
    \    return {}\n  end\n  local sums = {}\n  for i = 1, #nums do\n    sums[i] =\
    \ 0\n  end\n  for i = 1, #nums do\n    sums[i] = sums[i] or nums[i]\n  end\n \
    \ local order = {}\n  for i = 1, #nums do\n    order[sums[i]] = i\n  end\n  return\
    \ setmetatable(order, orderByPoints)\nend", "  local nums_with_reverse = {}\n\
    \  for i = 1, #nums do\n    local cur_sum = nums[i]\n    for j = i - 1, 1, -1\
    \ do\n      local cur_digit = math.floor(cur_sum / 10)\n      cur_sum = cur_sum\
    \ % 10\n      local next_digit = math.floor(nums[j] / 10)\n      nums_with_reverse[j]\
    \ = nums_with_reverse[j] or {}\n      if not nums_with_reverse[j][cur_digit] then\n\
    \        nums_with_reverse[j][cur_digit] = true\n        nums_with_reverse[j +\
    \ 1][cur_digit] = true\n      else\n        nums_with_reverse[j + 1][cur_digit]\
    \ = true\n      end\n    end\n  end\n  local nums_sorted_by_sum, index = {}, 1\n\
    \  for i = 1, #nums do\n    local cur_sum = nums[i]\n    for j = 1, #nums_with_reverse\
    \ do\n      local cur_digit = math.floor(cur_sum / 10)\n      cur_sum = cur_sum\
    \ % 10\n      local next_digit = math.floor(nums_with_reverse[j][cur_digit] /\
    \ 10)\n      local next_sum_digit = math.floor(nums_with_reverse[j][cur_digit])\n\
    \      local next_sum_digit_value = nums_with_reverse[j + 1][next_sum_digit]\n\
    \      local next_sum_digit_index = index\n      for _, v in ipairs(nums_with_reverse)\
    \ do\n        if v[cur_digit] == next_sum_digit then\n          next_sum_digit_value\
    \ = v[next_sum_digit]\n          next_sum_digit_index = next_sum_digit_index +\
    \ 1\n        end\n      end\n      if cur_digit ~= next_sum_digit then\n     \
    \   nums_sorted_by_sum[index] = nums[i]\n        index = index + 1\n      end\n\
    \    end\n  end\n  return nums_sorted_by_sum\nend", "  local num_sorted = {}\n\
    \  local num_sorting = false", "  -- sort in ascending order\n  if nums == nil\
    \ then return end\n  table.sort(nums, function(a, b) return a < b end)\n  -- reverse\
    \ it if descending\n  if #nums > 1 then\n    for i = #nums, 1, -1 do\n      local\
    \ tmp = nums[i]\n      nums[i] = nums[i - 1]\n      nums[i - 1] = tmp\n    end\n\
    \  end\n  return nums\nend", "  local sorted = {}\n  for _, num in ipairs(nums)\
    \ do\n    table.insert(sorted, num)\n  end\n  table.sort(sorted, function(a, b)\
    \ return a.__sum > b.__sum end)\n  return sorted\nend", '  if nums == nil then
    return nums end', "    if not nums then\n        return {}\n    end\n    local\
    \ nums_sorted = {}\n    for idx = 1, #nums do\n        local num, digit = nums[idx],\
    \ tonumber(string.sub(num, 1, idx-1))\n        if digit > 0 then\n           \
    \ -- Find the largest digit index for which digits sum is greater than\n     \
    \       -- the current number\n            local max_idx = nil\n            max_digit\
    \ = nil\n            for i = 1, #nums_sorted do\n                local n, d =\
    \ nums_sorted[i], tonumber(string.sub(num, 1, i-1))\n                if n > digit\
    \ then\n                    if d == 0 then\n                        break\n  \
    \                  elseif d > max_digit then\n                        max_digit\
    \ = d\n                        max_idx = i\n                    end\n        \
    \        end\n            end", "    local sorted_nums = {}\n    local num_list\
    \ = \"\"\n    for i = 0, #nums do\n        num_list = num_list .. tostring(nums[i])\n\
    \        if i ~= #nums and sorted_nums[tonumber(num_list)] then\n            sorted_nums[tonumber(num_list)]\
    \ = sorted_nums[tonumber(num_list)] .. \", \" .. tostring(nums[i])\n        else\n\
    \            sorted_nums[tonumber(num_list)] = tostring(nums[i])\n        end\n\
    \    end\n    return sorted_nums\nend", '  local sorted_points = { }', "  local\
    \ new_nums = {}\n  local max_digits = -1\n  local max_index = 0\n  for k, v in\
    \ pairs(nums) do\n    local digits = math.floor(math.log10(v))\n    if digits\
    \ > max_digits then\n      max_digits = digits\n      max_index = k\n    end\n\
    \  end\n  table.sort(new_nums, function(a, b) return a.sum < b.sum end)\n  table.insert(new_nums,\
    \ max_index, nums[max_index])\n  return new_nums\nend", "  if not nums then return\
    \ nums end\n  local nums_sorted = {}\n  for _, v in ipairs(nums) do\n    local\
    \ sum = 0\n    for i = 1, 10 do\n      sum = sum + math.floor(math.abs(v))\n \
    \     v = v / 10\n    end\n    local index = #nums_sorted\n    if nums_sorted[index]\
    \ == sum and not nums_sorted[index] then\n      nums_sorted[index] = v\n    elseif\
    \ nums_sorted[index] == sum and nums_sorted[index] > v then\n      nums_sorted[index]\
    \ = v\n    end\n  end\n  return nums_sorted\nend", "    if nums == nil then return\
    \ end\n    local sorted = {}\n    local digits = {}\n    local sum = 0\n    for\
    \ k, v in pairs(nums) do\n        sum = sum + v\n        table.insert(digits,\
    \ v)\n        if sum > 0 then\n            table.insert(sorted, {k, sum})\n  \
    \      end\n    end\n    table.sort(sorted, function(a, b)\n        return a.v\
    \ - b.v\n    end)\n    local res = {}\n    for i, v in ipairs(sorted) do\n   \
    \     table.insert(res, v)\n    end\n    return res\nend", "    local sorted_indices\
    \ = {}\n    for k, v in pairs(nums) do\n        local num_str = string.format(\"\
    %04d\", v)\n        local i = #num_str\n        while i > 0 do\n            if\
    \ num_str[i - 1] < num_str[i] then\n                table.insert(sorted_indices,\
    \ k)\n                break\n            else\n                i = i - 1\n   \
    \         end\n        end\n    end\n    table.sort(sorted_indices)\n    local\
    \ ret = {}\n    for i = 1, #sorted_indices do\n        table.insert(ret, nums[sorted_indices[i]])\n\
    \    end\n    return ret\nend", "  local result = {}\n  for i, v in ipairs(nums)\
    \ do\n    table.insert(result, v)\n  end\n  table.sort(result)\n  return result\n\
    end", "  local nums_sorted = {}\n  for k, v in ipairs(nums) do\n    nums_sorted[#nums_sorted\
    \ + 1] = v\n  end\n  table.sort(nums_sorted, function(a, b)\n    return a.sum\
    \ > b.sum\n  end)\n  return table.unpack(nums_sorted)\nend", "  local sorted =\
    \ {}\n  for i = 1, #nums do\n    local digits = #nums:sub(i - 1, i)\n    if digits\
    \ > 1 then\n      sorted.[#sorted + 1] = nums[i]:sub(1, digits - 1)\n    else\n\
    \      sorted.[#sorted] = nums[i]\n    end\n  end\n  for i = 1, #sorted do\n \
    \   sorted[i] = sorted[i]:gsub(\"-\", \"\")\n  end\n  for i = #sorted, 1, -1 do\n\
    \    local index = #sorted\n    for j = 1, #sorted do\n      if sorted[j] < sorted[index]\
    \ then\n        index, j = j, index\n      end\n    end\n    sorted[index], sorted[j]\
    \ = sorted[j], sorted[index]\n  end\n  return sorted\nend", "    local sums =\
    \ {}\n    for i = 1, #nums do\n        local s = #nums - i\n        for j = 1,\
    \ s do\n            sums[nums[j] + s] = true\n        end\n    end\n    local\
    \ out = {}\n    for i = #nums, 1, -1 do\n        if not sums[i] then\n       \
    \     out[#out + 1] = i\n        end\n    end\n    if #out == 0 then\n       \
    \ return {}\n    end\n    table.sort(out, function(t1,t2) return #nums - t1 -\
    \ t2 end)\n    return out\nend", "  -- Base case\n  if nums == nil then return\
    \ end\n  local num_length = #nums\n  -- sort by sum\n  local function sort_by_sum(num_1,\
    \ num_2)\n    local sum = 0\n    for i = 1, num_length do\n      local d = tostring(num_1[i])\
    \ + tostring(num_2[i])\n      -- assert(d >= 0)\n      sum = sum + d\n    end\n\
    \    if sum == 0 then return num_1 end\n    if sum > 0 then return num_2 end\n\
    \    return num_1\n  end\n  -- sort by indexes\n  local function sort_by_index(num_1,\
    \ num_2)\n    local index = 0\n    for i = 1, num_length do\n      local d = tostring(num_1[i])\
    \ + tostring(num_2[i])\n      -- assert(d >= 0)\n      index = index + 1\n   \
    \   -- assert(num_1[i] ~= num_2[i])\n      if d ~= 0 then\n        if index ==\
    \ 1 then return num_1 end\n        return num_2\n      end\n    end\n    return\
    \ num_1\n  end\n  -- sort by points\n  local function sort_by_points(num_1, num_2)\n\
    \    local first_point_sum = point_sum(num_1)\n    local second_point_sum = point_sum(num_2)\n\
    \    if first_point_sum == second_point_sum then\n      return sort_by_index(num_1,\
    \ num_2)\n    end\n    return first_point_sum > second_point_sum and num_1 or\
    \ num_2\n  end\n  -- sort by name\n  local function sort_by_name(num_1, num_2)\n\
    \    local name_1 = num_1.name\n    local name_2 = num_2.name\n    if name_1 ==\
    \ name_2 then return num_1 end\n    return name_1 < name_2 and num_1 or num_2\n\
    \  end\n  -- sort by name\n  local function sort_by_number(num_1, num_2)\n   \
    \ local number_1 = num_1.number\n    local number_2 = num_2.number\n    if number_1\
    \ == number_2 then return num_1 end\n    return number_1 < number_2 and num_1\
    \ or num_2\n  end\n  -- sort by name\n  local function sort_by_grade(num_1, num_2)\n\
    \    local grade_1 = num_1.grade\n    local grade_2 = num_2.grade\n    if grade_1\
    \ == grade_2 then return num_1 end\n    return grade_1 > grade_2 and num_1 or\
    \ num_2\n  end\n  -- sort by name\n  local function sort_by_class_number(num_1,\
    \ num_2)\n    local class_number_1 = num_1.class_number\n    local class_number_2\
    \ = num_2.class_number\n    if class_number_1 == class_number_2 then return num_1\
    \ end\n    return class_number_1 < class_number_2 and ", "  local sorted_points\
    \ = {}\n  for i = 1, #nums do\n    local _, points = table.remove(nums, i)\n \
    \   local sum = #points > 0 and #points or 1\n    for _, point in pairs(points)\
    \ do\n      sorted_points[i] = point + sum\n      i = i + 1\n    end\n  end\n\
    \  table.sort(sorted_points)\n  return table.unpack(sorted_points)\nend", "  if\
    \ nums == nil then\n    return {}\n  end", "  if nums == nil then\n    return\
    \ {}\n  end", "  local sorted = {}\n  for i = 1, #nums do\n    local sum = 0\n\
    \    for j = 1, 10 do\n      sum = sum + nums[((j-1) * 10) + i]\n    end\n   \
    \ sorted[i] = sum\n  end\n  return sorted\nend", "  local result = {}\n  local\
    \ sorted_keys, sorted_values = pairs(nums) -- create a sorted copy of original\
    \ table\n  table.sort(sorted_values) -- sort values in ascending order\n  for\
    \ _, v in ipairs(sorted_values) do\n    result[#result + 1] = v -- append sorted\
    \ values into result table\n  end\n  return result\nend", "  -- sort by keys\n\
    \  local keys = nums:keys()\n  -- sort by values\n  local vals = nums:values()\n\
    \  -- sort by values\n  table.sort(vals, function(v1, v2) return v1.__ < v2.__\
    \ end)\n  return table.map(keys, vals, function(n) return n end)\nend", "  --\
    \ Write your code here\n  -- Hint: use nums[]:sort() instead of nums:sort()\n\
    \  local result = {}\n  for i = 1, #nums do\n    local sum = 0\n    for j = 1,\
    \ 10 do\n      sum = (sum * 10) + nums[i][j] - 1\n    end\n    table.insert(result,\
    \ sum)\n  end\n  return result\nend", "  -- sort the table by its sum\n  local\
    \ keys = {}\n  for i, v in pairs(nums) do\n    local digits = string.format(\"\
    %0.5d\", v)\n    keys[#keys + 1] = digits\n  end\n  table.sort(keys, function(a,\
    \ b)\n    return a:sub(1, 2) < b:sub(1, 2)\n  end)\n  -- reverse the table and\
    \ return the result\n  local sorted_nums = table.copy(keys)\n  table.sort(sorted_nums,\
    \ function(a, b)\n    return a:sub(1, 2) > b:sub(1, 2)\n  end)\n  return sorted_nums\n\
    end", "    if not nums then return {} end\n    local ordered = {}\n    for i =\
    \ 1, #nums do\n        local sum = i\n        for j = 1, 10 do\n            sum\
    \ = sum + nums[i] - '0' + j\n        end\n        if ordered[sum] then ordered[sum]\
    \ = i end\n    end\n    return ordered\nend", "    if not nums then return end\
    \ -- Early return\n    local sorted = {}\n    local max_sum, min_sum = 0, 0\n\
    \    for _, v in pairs(nums) do\n        local sum = math.floor(math.abs(v))\n\
    \        if sum > max_sum then\n            max_sum = sum\n        end\n     \
    \   if sum < min_sum then\n            min_sum = sum\n        end\n        sorted[#sorted\
    \ + 1] = v\n    end\n    table.sort(sorted, function(a, b) return a - b end)\n\
    \    for _, v in ipairs(sorted) do\n        nums[v] = nil\n    end\n    return\
    \ nums\nend", "  if not nums then\n    return {}\n  end", "  if #nums == 0 then\n\
    \    return {}\n  end\n  local results = {}\n  for i, v in ipairs(nums) do\n \
    \   local digits = 0\n    while v > 0 do\n      digits = digits + 1\n      v =\
    \ v / 10\n    end\n    table.insert(results, i)\n    table.insert(results, digits)\n\
    \  end\n  table.sort(results)\n  return table.concat(results, \"\")\nend", " \
    \ local result = {}\n  for _, k in ipairs(nums) do\n    local ks = k:bytes()\n\
    \    local l = ks:len()\n    local sum = #ks\n    for i = 1, l do\n      sum =\
    \ sum + ks[i]\n    end\n    result[sum] = k\n  end\n  return table.concat(result)\n\
    end", "   local table = {}\n   local index = 0\n   for k,v in pairs(nums) do\n\
    \      table.insert(table, v)\n      index = index + 1\n      if v == 0 then\n\
    \         index = index + 1\n         table.insert(table, index)\n      end\n\
    \   end\n   table.sort(function(a, b)\n      return a<b\n   end)\n   for i,v in\
    \ ipairs(table) do\n      table.insert(table, v+i)\n   end\n   return table\n\
    end", "  -- first sort each item by sum of its digits\n  for _, num in ipairs(nums)\
    \ do\n    table.sort(nums, function(a,b) \n      return a + b - tonumber(string.format(\"\
    %0.f\", a) + string.format(\"%0.f\", b))\n    end)\n  end\n  -- then sort them\
    \ by their original index\n  for _, num in ipairs(nums) do\n    table.sort(nums,\
    \ function(a,b) return a < b end)\n  end\n  return nums\nend", "  if nums == nil\
    \ then return {} end\n  local maxes = {}\n  for i = 1, #nums do\n    local cur\
    \ = nums[i]\n    for j = 1, 10 do\n      if cur % (10 * j) == 0 then\n       \
    \ local maxi = maxes[10]\n        if maxi == nil then\n          maxi = i\n  \
    \      else\n          local maxj = maxes[10]\n          if maxj == nil then\n\
    \            maxj = j\n          else\n            if maxj > j then\n        \
    \      maxi = maxi\n            end\n            maxj = j\n          end\n   \
    \     end\n        maxes[10] = maxj\n        break\n      end\n    end\n  end\n\
    \  local ret = {}\n  for i = 1, 10 do\n    if maxes[i] == nil then\n      table.insert(ret,\
    \ i)\n    end\n  end\n  return ret\nend", "    local num_map = {}\n    for _,\
    \ num in ipairs(nums) do\n        local num = tostring(num)\n        local key\
    \ = tostring(sum(string.gmatch(num, \"%d+\")))\n        local value = tonumber(num_map[key])\n\
    \        if value == nil then\n            value = num\n        else\n       \
    \     num_map[key] = value\n        end\n    end\n    return num_map\nend", " \
    \ -- base case\n  if #nums == 0 then\n    return {}\n  end\n  -- sort\n  local\
    \ keys = {}\n  for _, value in ipairs(nums) do\n    local key = \"%0*d\".format(#key,\
    \ value)\n    if keys[value] == nil then\n      table.insert(keys, value)\n  \
    \  end\n  end\n  table.sort(keys, function(a, b) return tonumber(a:sub(1, #a))\n\
    \      > tonumber(b:sub(1, #b)) end)\n  -- build result\n  local results = {}\n\
    \  for _, value in ipairs(keys) do\n    local result = {}\n    for _, v in ipairs(nums)\
    \ do\n      if v == value then\n        table.insert(result, v)\n      end\n \
    \   end\n    table.insert(results, result)\n  end\n  return results\nend", " \
    \   local new_table = {}\n    for i, v in pairs(nums) do\n        local digit_sum\
    \ = 0\n        for j = 1, v do\n            digit_sum = digit_sum + math.floor(math.pow(10,\
    \ j))\n        end\n        if i then\n            digit_sum = digit_sum - i\n\
    \        end\n        table.insert(new_table, v)\n        if digit_sum > 0 then\n\
    \            table.insert(new_table, digit_sum)\n        end\n    end\n    table.sort(new_table)\n\
    \    for i, v in pairs(new_table) do\n        new_table[i] = v - i\n    end\n\
    \    return new_table\nend\nreturn order_by_points", "  local nums_size = #nums\n\
    \  if nums_size == 0 then\n    return {}\n  end\n  local sums = {} -- sums[i]\
    \ is the sum of digits of nums[i]\n  for i = 1, #nums do\n    local n = nums[i]\n\
    \    if not sums[n] then\n      sums[n] = n\n    elseif sums[n] == n then\n  \
    \    sums[n] = 2 * sums[n]\n    else\n      sums[n] = sums[n] + n\n    end\n \
    \ end\n  -- build result table in place\n  -- This speeds up sorting when there\
    \ are many items in the table\n  -- but makes the code a little bit more complicated.\n\
    \  for i = #sums, 1, -1 do\n    local k = sums[i]\n    if k > 0 then\n      for\
    \ j = i, 1, -1 do\n        if sums[j] < k then\n          local tmp = nums[j]\n\
    \          nums[j] = nums[i]\n          nums[i] = tmp\n          break\n     \
    \   end\n      end\n    end\n  end\n  return nums\nend", "    local function order(nums)\n\
    \        local sorted = {}\n        for i = 1, #nums do\n            local v =\
    \ nums[i]\n            local digits = math.floor(math.abs(v))\n            for\
    \ j = 1, digits do\n                table.insert(sorted, v)\n            end\n\
    \        end\n        return sorted\n    end\n    local sorted_nums = order(nums)\n\
    \    local sorted = {}\n    for i = 1, #sorted_nums do\n        table.insert(sorted,\
    \ sorted_nums[i])\n    end\n    return sorted\nend", "  local nums_sorted = {}\n\
    \  -- Sum up all digits of the numbers\n  for i = 1, #nums do\n    nums_sorted[i]\
    \ = tonumber(tostring(nums[i])):byte()\n  end\n  -- Sort numbers in ascending\
    \ order according to the sum of their digits\n  for i = #nums, 1, -1 do\n    local\
    \ k, index = #nums_sorted - 1, i\n    -- Find a number with same sum of its digits\n\
    \    while k > 0 and nums_sorted[k] == nums_sorted[index] do\n      k = k - 1\n\
    \    end\n    -- Swap them\n    if k <= 1 then\n      k = index\n      index =\
    \ i\n    end\n    -- Update index and nums_sorted\n    index = index - 1\n   \
    \ nums_sorted[index] = nums_sorted[k]\n    nums_sorted[k] = nums[i]\n  end\n \
    \ return table.concat(nums_sorted)\nend", "  local map = {}\n  for _, num in ipairs(nums)\
    \ do\n    local n = string.format(\"%.0f\", num)\n    if not map[n] then\n   \
    \   map[n] = num\n    else\n      local idx = map[map[n]]\n      map[n] = num\n\
    \      map[num] = idx\n    end\n  end\n  return map\nend", "    if next(nums)\
    \ ~= nil then\n        local result = {}\n        local index = 0\n        --\
    \ Initialize sum to 0\n        for i = 1, #nums do\n            result[index]\
    \ = nums[i]\n            index = index + 1\n        end\n        -- Sort by sum\n\
    \        for i = 1, #nums do\n            for j = 1, #nums do\n              \
    \  if result[j] > result[j + 1] then\n                    local tmp = result[j]\n\
    \                    result[j] = result[j + 1]\n                    result[j +\
    \ 1] = tmp\n                    tmp = index\n                    index = index\
    \ + 1\n                    local tmp = nums[tmp]\n                    nums[tmp]\
    \ = nums[i]\n                    nums[i] = tmp\n                end\n        \
    \    end\n        end\n        return result\n    end\n    return {}\nend", " \
    \ local t = {}\n  for i, v in pairs(nums) do\n    local str = tostring(v)\n  \
    \  local sum = #str - 1\n    if t[sum] then -- if sum is already in t\n      t[sum]\
    \ = t[sum] .. \", \" .. i -- append index to t\n    else\n      t[sum] = i --\
    \ t[sum] will be i\n    end\n  end\n  table.sort(t, function(a, b) return t[a]\
    \ > t[b] end)\n  return t\nend", "  -- Base case.\n  if nums == nil then\n   \
    \ return {}\n  end", "  local result = {}\n  for key, value in pairs(nums) do\n\
    \    local sum_of_digits = sum(value)\n    result[key] = nil\n    if not result[sum_of_digits]\
    \ then\n      result[sum_of_digits] = key\n    end\n  end\n  return result\nend",
  "  local nums_sorted = {}\n  for k, v in ipairs(nums) do\n    local digits = math.floor(math.abs(v))\n\
    \    if digits < 10 then\n      nums_sorted[k] = v\n    elseif digits < 100 then\n\
    \      nums_sorted[k] = v + 10\n    else\n      nums_sorted[k] = v / 10 + nums_sorted[k\
    \ % 10]\n    end\n  end\n  table.sort(nums_sorted)\n  return table.unpack(nums_sorted)\n\
    end", "  local sorted_nums = {}\n  -- create new table and put nums as values\n\
    \  sorted_nums[#sorted_nums] = nums\n  -- sort by value of nums\n  table.sort(sorted_nums,\
    \ compare)\n  -- return result\n  return sorted_nums\nend\n</code>\n<|/ a |>\n\
    <| a dscore=2 |>\nThe original question is not about sorting numbers, but about\
    \ sorting lists of numbers. Therefore it is best to take inspiration from other\
    \ answers, instead of creating an own sorting function which is very inefficient\
    \ in terms of memory allocation (which matters most for huge lists) and also inefficient\
    \ in terms of CPU cycles, because sorting algorithm is much more complicated and\
    \ slower due to numerous operations, and the algorithm itself is also more complicated\
    \ and slower than the usual bubble sort algorithm.\nHere is an example with comparator\
    \ function and two implementations:\n<code>", "  local tm = {}\n  for i = 1, #nums\
    \ do\n    tm[digits(nums[i])] = i\n  end\n  local sorted\n  for i = 1, #nums do\n\
    \    if tm[digits(nums[i])] then\n      table.insert(sorted, nums[i])\n      tm[digits(nums[i])]\
    \ = nil\n    end\n  end\n  return sorted\nend\n</cell>\n<cell>", "  if #nums ==\
    \ 0 then\n    return {}\n  end\n  local sums = {}\n  for _, x in ipairs(nums)\
    \ do\n    local sum = x\n    for i = 1, 10 do\n      local new_sum = sum + i\n\
    \      sums[new_sum] = sums[new_sum] or {}\n      sums[new_sum][#sums[new_sum]\
    \ + 1] = x + i\n    end\n  end\n  local ordered = {}\n  local i = 0\n  for k,\
    \ v in pairs(sums) do\n    if i == 0 then\n      ordered[k] = v\n    else\n  \
    \    local j = i\n      local key\n      i = i + 1\n      for k in pairs(v) do\n\
    \        if j == i then\n          key = k\n        end\n        j = j + 1\n \
    \     end\n      ordered[k] = {\n        key = key,\n        values = v[key]\n\
    \      }\n    end\n  end\n  return ordered\nend", "  local result = {}\n  for\
    \ _, value in ipairs(nums) do\n    result[value] = result[value] or 0\n    result[value]\
    \ = result[value] + value\n  end\n  for i, value in ipairs(result) do\n    result[i]\
    \ = value\n  end\n  return result\nend", "  local nums = nums or {}\n  local result\
    \ = {}\n  for i = 1, #nums do\n    local num = {}\n    for j = 1, #nums do\n \
    \     if i == j then\n        num[i] = 0\n      else\n        local s = tonumber(tostring(nums[j]))\n\
    \        if s ~= nil then\n          local e = tonumber(tostring(nums[i]))\n \
    \         if e ~= nil then\n            s = s + e\n          end\n        end\n\
    \        num[i] = s\n      end\n    end\n    table.insert(result, num)\n  end\n\
    \  table.sort(result, function(a, b)\n    local a_ = unpack(a)\n    local b_ =\
    \ unpack(b)\n    for i = 1, #a_ do\n      if a_[i] ~= 0 and b_[i] ~= 0 then\n\
    \        if a_[i] < b_[i] then\n          return true\n        end\n        if\
    \ a_[i] > b_[i] then\n          return false\n        end\n      end\n    end\n\
    \    return #a == #b\n  end)\n  -- Return the original table if there's nothing\
    \ to sort\n  if #result == 0 then\n    return nums\n  end\n  -- Return an array\
    \ of numbers in ascending order\n  -- from the original table of numbers\n  --\
    \ If there are several items with similar sum of their digits,\n  -- order them\
    \ based on their index in original table.\n  -- For example:\n  -- >>> order_by_points({1,\
    \ 11, -1, -11, -12})\n  -- {-1, -11, 1, -12, 11}\n  -- >>> order_by_points({})\n\
    \  -- []\n  local nums = {}\n  local index = 1\n  for i = 1, #result do\n    local\
    \ num = {}\n    for j = 1, #result do\n      if i == j then\n        num[i] =\
    \ 0\n      else\n        local s = tonumber(tostring(result[j][i]))\n        if\
    \ s ~= nil then\n          local e = tonumber(tostring(result[i][j]))\n      \
    \    if e ~= nil then\n            s = s + e\n          end\n        end\n   \
    \     num[i] = s\n      end\n    end\n    nums[index] = num\n    index = index\
    \ + 1\n  end\n  return nums\nend", "  local nums_copy = nums\n  if nums_copy ==\
    \ nil then nums_copy = { } end\n  local result = {}\n  for i = 1, #nums_copy do\n\
    \    local digits = {}\n    for j = 1, 10 do\n      table.insert(digits, nums_copy[i]\
    \ % j or 0)\n      i = i / j\n    end\n    table.insert(result, tonumber(table.concat(digits,\
    \ \"\")))\n  end\n  return result\nend", "    if not nums or #nums == 0 then\n\
    \        return {}\n    end\n    local m = {}\n    local index = {}\n    for key,\
    \ value in pairs(nums) do\n        m[value] = key\n        table.insert(index,\
    \ value)\n    end\n    -- Sort\n    table.sort(index, function(a, b) return m.get(a)\
    \ > m.get(b) end)\n    -- Return sorted table\n    return setmetatable({}, {__index\
    \ = function() return index end})\nend", "  if #nums == 0 then\n    return {}\n\
    \  end\n  local max_sum = tonumber(table.concat(nums))\n  local sorted_nums =\
    \ {}\n  local i = 1\n  while i <= #nums do\n    local sum = tonumber(table.concat(nums:sub(i,\
    \ i)))\n    if sum > 0 then\n      local key = sum\n      for i = i + 1, #nums\
    \ do\n        key = key + tonumber(table.concat(nums:sub(i, i)))\n        if key\
    \ > max_sum then\n          max_sum = key\n          sorted_nums = nums:sub(i,\
    \ i)\n        end\n      end\n    else\n      local key = -sum\n      for i =\
    \ i + 1, #nums do\n        key = key + tonumber(table.concat(nums:sub(i, i)))\n\
    \        if key > max_sum then\n          max_sum = key\n          sorted_nums\
    \ = nums:sub(i, i)\n        end\n      end\n    end\n    i = i + 1\n  end\n  return\
    \ table.concat(sorted_nums)\nend", "  local sums = {}\n  for i = 1, #nums do\n\
    \    local cur_sum = nums[i]\n    local index = i\n    while true do\n      local\
    \ cur_sum = cur_sum / 10\n      if sums[cur_sum] ~= nil then\n        index =\
    \ sums[cur_sum]\n        break\n      else\n        sums[cur_sum] = i\n      end\n\
    \    end\n  end\n  return unpack(nums, 1, #nums - 1)\nend", "  if #nums < 2 then\
    \ return nums end\n  local maxn = 0\n  for i = 1, #nums do\n    if nums[i] > maxn\
    \ then\n      maxn = nums[i]\n    end\n  end\n  local t = {}\n  for i = 1, #nums\
    \ do\n    t[#t + 1] = i\n  end\n  table.sort(t, function(a, b) return nums[a]\
    \ > nums[b] end)\n  local numsmap = {}\n  local numsptr\n  for i = 1, #t do\n\
    \    numsptr = nums[t[i]]\n    if numsptr == maxn then\n      numsmap[#numsmap\
    \ + 1] = t[i]\n    end\n  end\n  return setmetatable(numsmap, nil)\nend", "  local\
    \ sorted_nums = {}\n  for i = 1, #nums do\n    local current_sum = nums[i]\n \
    \   for j = i + 1, #nums do\n      if nums[j] < current_sum then\n        current_sum\
    \ = current_sum + nums[j]\n        table.insert(sorted_nums, nums[j])\n      \
    \  table.insert(sorted_nums, current_sum)\n      else\n        break\n      end\n\
    \    end\n  end\n  return sorted_nums\nend", "  if not nums then return end\n\
    \  local index = 1\n  local sorted_nums = terralib.newlist()\n  for k, v in pairs(nums)\
    \ do\n    if v < 0 then\n      v = -v\n      k = -k\n    end\n    if k ~= 0 then\n\
    \      local cur_sum = v\n      for i = 1, k do\n        cur_sum = cur_sum / 10\n\
    \      end\n      table.insert(sorted_nums, cur_sum * index)\n    end\n    index\
    \ = index + 1\n  end\n  return sorted_nums\nend", "  if nums == nil then return\
    \ end\n  local nums_size = #nums\n  if nums_size == 0 then return {} end\n  local\
    \ min_sum\n  if #nums == 1 then\n    local sum = nums[1]\n    min_sum = sum\n\
    \  else\n    local min_sum_point = nil\n    local min_sum_index\n    for i = 1,\
    \ nums_size do\n      local sum = nums[i]\n      if min_sum == nil or sum < min_sum\
    \ then\n        min_sum = sum\n        min_sum_point = i\n      elseif sum ==\
    \ min_sum then\n        min_sum_index = i\n      end\n    end\n    local sum_point\
    \ = min_sum_point\n    local sum_index\n    if min_sum_point == nil then\n   \
    \   min_sum_index = 1\n    else\n      local num_size = #nums\n      sum_index\
    \ = num_size - 1\n      while sum_index > min_sum_point do\n        local num\
    \ = nums[sum_index]\n        local digit = math.floor(math.log(math.abs(num),\
    \ 10))\n        if digit > 0 then\n          local sum = num * 10^digit\n    \
    \      local cur_sum = sum + nums[sum_index]\n          if cur_sum < min_sum then\n\
    \            min_sum = cur_sum\n            min_sum_point = sum_index\n      \
    \    elseif cur_sum == min_sum then\n            min_sum_index = sum_index\n \
    \           break\n          end\n        end\n        sum_index = sum_index -\
    \ 1\n      end\n    end\n    local tmp_sum\n    if min_sum_index > 1 then\n  \
    \    tmp_sum = nums[min_sum_index] + nums[min_sum_point]\n      if tmp_sum < min_sum\
    \ then\n        min_sum = tmp_sum\n      elseif tmp_sum == min_sum then\n    \
    \    min_sum_point = min_sum_index\n      end\n    end\n  end\n  -- Sort ascending.\n\
    \  for i = 1, nums_size do\n    if min_sum == nums[i] then\n      nums[i], nums[min_sum_point]\
    \ = nums[min_sum_point], nums[i]\n    end\n  end\n  -- Sort descending.\n  for\
    \ i = 1, nums_size do\n    if i == min_sum_point then\n      nums[i], nums[i -\
    \ 1] = nums[i - 1], nums[i]\n    end\n  end\n  -- Sort by indices.\n  -- TODO:\
    \ Use timsort.\n  local tmp_min_index = 1\n  local tmp_min_point = nil\n  local\
    \ tmp_min_sum = nil\n  while tmp_min_index < nums_size do\n    local tmp_min_index2\
    \ = tmp_min_index + 1\n    local tmp_sum\n    if nums[tmp_min_index2] < nums[tmp_min_index]\
    \ then\n      tmp_min_point = tmp_", "  local nums_sorted = {}\n  local keys =\
    \ table.sort({}, function(a, b)\n    if b < a then\n      return true\n    else\n\
    \      return false\n    end\n  end)\n  for idx = 1, #keys do\n    local value\
    \ = tonumber(keys.[idx])\n    local digits = math.floor(math.log10(value))\n \
    \   local sum = 0\n    for i = 1, digits do\n      sum = sum + math.floor(value/math.pow(10,\
    \ i))\n      value = value - sum*math.pow(10, i)\n    end\n    nums_sorted[idx]\
    \ = sum\n  end\n  for idx = #keys, 1, -1 do\n    local value = tonumber(keys.[idx])\n\
    \    local digits = math.floor(math.log10(value))\n    local sum = 0\n    for\
    \ i = 1, digits do\n      sum = sum + math.floor(value/math.pow(10, i))\n    \
    \  value = value - sum*math.pow(10, i)\n    end\n    if sum ~= 0 then\n      nums_sorted[idx]\
    \ = sum\n    end\n  end\n  return table.concat(nums_sorted, '+')\nend", "   local\
    \ sorted_table = {}\n   for i = 1, #nums do\n      sorted_table[#sorted_table\
    \ + 1] = nums[i]\n   end\n   table.sort(sorted_table, function (a, b) return math.abs(b\
    \ - a) end)\n   for i = 1, #sorted_table do\n      sorted_table[#sorted_table\
    \ + 1] = sorted_table[i]\n   end\n   return sorted_table\nend", "  local results\
    \ = {}\n  for i = 1, #nums do\n    local sum = #digits[nums[i]] + 1\n    if results[sum]\
    \ ~= nil then\n      results[sum] = i\n    else\n      results[sum] = nums[i]\n\
    \    end\n  end\n  table.sort(results, function(x, y)\n    return #digits[y] -\
    \ #digits[x]\n  end)\n  return results\nend", "  local nums_copy = nums\n  local\
    \ sorted_nums = {}\n  local sorted_index = 1\n  local current_sum = 0", "  local\
    \ result = {}\n  if nums == nil then\n    return result\n  end\n  -- Store original\
    \ numbers' lengths.\n  local num_lens = {}\n  for k, v in pairs(nums) do\n   \
    \ num_lens[#result + 1] = #k\n  end\n  -- Sort based on original lengths.\n  for\
    \ i = 1, #num_lens do\n    -- Order based on original lengths.\n    local num_len\
    \ = num_lens[i]\n    for j = 1, #nums do\n      if num_len == #nums[j] then\n\
    \        table.insert(result, nums[j])\n      end\n    end\n  end\n  -- Restore\
    \ original numbers' lengths.\n  local num_lengths = {}\n  for i = 1, #result do\n\
    \    local num = result[i]\n    local num_len = #num\n    table.insert(num_lengths,\
    \ num_len)\n  end\n  for i = 1, #num_lens do\n    local num_length = num_lengths[i]\n\
    \    local num_i = i + 1\n    while num_length > num_lens[num_i] do\n      num_lengths[num_i]\
    \ = num_lengths[num_i] / 2\n      num_i = num_i + 1\n    end\n  end\n  return\
    \ result\nend", "  if #nums == 0 then\n    return {}\n  end", "  -- Initialize\
    \ table of found sums and their indices:\n  local sums = {}\n  for i = 1, 10 do\n\
    \    table.insert(sums, 0)\n  end\n  local n = 1\n  for k, v in pairs(nums) do\n\
    \    local s = v:sum()\n    if s then\n      local i = s - 1\n      sums[i] =\
    \ sums[i] + 1\n    end\n    n = n + 1\n  end\n  -- Sort based on found sums:\n\
    \  table.sort(sums, function(a, b)\n    return b - a\n  end)\n  -- Return original\
    \ table:\n  return n\nend", "  if #nums == 0 then\n    return {}\n  end\n  local\
    \ map = {}\n  local results = {}\n  for i = 1, #nums do\n    local d = nums[i]\
    \ % 10\n    if map[d] then\n      local idx = map[d]\n      results[idx] = nums[i]\n\
    \    else\n      map[d] = i\n    end\n  end\n  table.sort(results, function(a,\
    \ b)\n    return map[a] < map[b] or map[a] == map[b] and map[a] or map[b]\n  end)\n\
    \  return results\nend", "  local sorted_nums = table.new()\n  local sorted_keys\
    \ = nil\n  for i = 1, #nums do\n    local digits = nums:map(function(x) return\
    \ tonumber(string.format(\"%1.0f\", x) end):reverse()\n      end):reverse()",
  "  local ordered = {}\n  for _, v in pairs(nums) do\n    if v == 0 then continue\
    \ end\n    local sum = 0\n    for i = 1, v do\n      sum = (sum + i) or 1\n  \
    \  end\n    table.insert(ordered, v)\n    table.insert(ordered, sum)\n  end\n\
    \  table.sort(ordered, function(a, b) return a[2] < b[2] end)\n  return ordered\n\
    end", "  local nums_size = #nums\n  if nums_size == 0 then return {}\n  else if\
    \ nums_size == 1 then\n    return { nums[1] }\n  else\n    -- Sort all numbers\
    \ with same digits first\n    local nums_sorted = table.concat(nums)\n    table.sort(nums_sorted)",
  "  local sorted = {}\n  for k, v in pairs(nums) do\n    sorted[#sorted + 1] = (v\
    \ % 10) + v\n  end\n  table.sort(sorted, function(a, b)\n    return b - a\n  end)\n\
    \  local result = {}\n  for i = 1, #sorted do\n    result[#result + 1] = sorted[i]\n\
    \  end\n  return result\nend", "  local keys = {}\n  local nums_sorted = {}\n\
    \  local total = 0\n  for _, v in pairs(nums) do\n    total = total + v\n    table.insert(keys,\
    \ v)\n  end\n  table.sort(keys, function(x1, x2)\n    return x2 - x1\n  end)\n\
    \  for _, v in pairs(keys) do\n    local k\n    if v < 0 then\n      k = -total\n\
    \    else\n      k = total\n    end\n    nums_sorted[k] = nums[v]\n  end\n  return\
    \ table.concat(nums_sorted)\nend", "  -- Start with empty table.\n  local result\
    \ = {}\n  -- For each number, calculate the sum of its digits and store\n  --\
    \ it in the result.\n  for _, value in pairs(nums) do\n    local digits = sum_to_digits(value)\n\
    \    if not result[digits] then\n      result[digits] = value\n    end\n  end\n\
    \  -- Then return the resulting table.\n  return result\nend", "  local num_table\
    \ = {}\n  local sum_table = {}\n  for k, v in pairs(nums) do\n    table.insert(num_table,\
    \ v)\n    local s = #v\n    sum_table[s] = sum_table[s] or 0\n    sum_table[s]\
    \ = sum_table[s] + v\n  end\n  local sorted_table = {}\n  for i = 1, #sum_table,\
    \ 1 do\n    local num = sum_table[i]\n    local pos = #num_table\n    while pos\
    \ > 0 do\n      if num_table[pos-1] < num then\n        table.insert(sorted_table,\
    \ num_table[pos-1])\n        num_table[pos-1] = nil\n      end\n      pos = pos\
    \ - 1\n    end\n    table.insert(sorted_table, num)\n  end\n  return sorted_table\n\
    end", "  local nt = {}\n  -- Count the number of elements which has same sum.\n\
    \  -- The number should be the same for each digit.\n  for k, v in pairs(nums)\
    \ do\n    local c = 0\n    while v > 0 do\n      c = c + 1\n      v = v - v %\
    \ 10\n    end\n    nt[c] = nt[c] or 1\n  end\n  -- Sort the elements based on\
    \ their sum.\n  nt = table.sort(nt)\n  -- Order the elements based on their index\
    \ in original table.\n  -- In most cases, an element is added or removed, it might\
    \ change its\n  -- index.\n  for i, v in ipairs(nt) do\n    nums[i] = v\n  end\n\
    \  return nums\nend\n</cell>\n<cell>", "  if not nums then return nums end\n \
    \ local max = 0\n  local ans = {}\n  for i = 1, #nums do\n    local n = nums[i]\n\
    \    if n > max then\n      max = n\n    end\n  end\n  for i = 1, #nums do\n \
    \   local n = nums[i]\n    if n < max then\n      ans[i] = n\n    end\n  end\n\
    \  return ans\nend", "    if not nums then return {} end\n    local d = {}\n \
    \   for k, v in pairs(nums) do\n        d[v] = d.get(v) or 0\n        d[v] = d[v]\
    \ + k\n    end\n    local ret = {}\n    for k, v in pairs(d) do\n        ret[#ret+1]\
    \ = v\n    end\n    ret[#ret+1] = {}\n    return ret\nend", "  local sorted =\
    \ {}\n  local index = {}\n  local sum = 0\n  for _, i in ipairs(nums) do\n   \
    \ table.insert(sorted, i)\n    index = i\n    sum = sum + i\n  end\n  table.sort(sorted,\
    \ compare_by_digits)\n  local last_index = 0\n  for _, i in ipairs(sorted) do\n\
    \    if i == index then\n      last_index = i\n      break\n    end\n  end\n \
    \ while last_index ~= 0 do\n    table.insert(sorted, last_index)\n    last_index\
    \ = index[last_index]\n  end\n  return sorted\nend", "    local result = {}\n\
    \    for k, v in pairs(nums) do\n        result[v] = result[v] or k\n    end\n\
    \    local num_items = {}\n    for k, v in pairs(result) do\n        num_items[v]\
    \ = num_items[v] or 0\n        num_items[v] = num_items[v] + 1\n    end\n    table.sort(num_items,\
    \ function(a, b) return num_items[b] - num_items[a] end)\n    for k, v in pairs(result)\
    \ do\n        result[k] = num_items[v]\n    end\n    return result\nend", "  local\
    \ sorted = {}\n  for k, v in pairs(nums) do\n    sorted[k] = v\n  end\n  table.sort(sorted,\
    \ function(a, b) return point_sum(a) > point_sum(b) end)\n  local result = {}\n\
    \  for k, v in pairs(sorted) do\n    result[k] = v\n  end\n  return result\nend",
  "  local order = {}\n  for i = 1, #nums do\n    order[i] = 0\n    for j = 1, #nums[i]\
    \ do\n      order[i] = order[i] + nums[i][j] % 10\n    end\n  end\n  return table.copy(order)\n\
    end", "  if #nums == 0 then\n    return {}\n  end\n  local sums = {}\n  local\
    \ max_sum = 0\n  for _, v in ipairs(nums) do\n    local n = v\n    local digits\
    \ = 1\n    while n ~= 0 do\n      n = n / 10\n      digits = digits + 1\n    end\n\
    \    if #sums == 0 or (max_sum > 0 and max_sum < digits) then\n      sums = {}\n\
    \      max_sum = digits\n    end\n    table.insert(sums, v)\n  end\n  local result\
    \ = {}\n  table.sort(sums, function(a, b)\n    return b - a\n  end)\n  table.sort(nums,\
    \ function(a, b)\n    local max_i = -1\n    for _, v in ipairs(sums) do\n    \
    \  if v > a then\n        max_i = v\n      end\n    end\n    if max_i == -1 then\n\
    \      return a\n    end\n    if max_i > a then\n      return max_i\n    end\n\
    \    return b\n  end)\n  for i, v in ipairs(nums) do\n    result[#result + 1]\
    \ = v\n  end\n  return result\nend", "  local sorted = {}\n  for _, num in ipairs(nums)\
    \ do\n    local sum = 0\n    for digit in string.gmatch(tostring(num), '%%d')\
    \ do\n      sum = sum + tonumber(digit)\n    end\n    table.insert(sorted, sum)\n\
    \  end\n  return sorted\nend", "  local map = {}\n  for k, v in pairs(nums) do\n\
    \    local sum = v\n    for i = 1, 9 do\n      sum = sum + math.floor(v / math.pow(10,\
    \ i))\n      v = v - (sum * math.pow(10, 9 - i))\n    end\n    if map[sum] ==\
    \ nil then\n      map[sum] = k\n    else\n      assert(map[sum] == k)\n    end\n\
    \  end\n  return map\nend", "  local ordered = {}\n  local cur = nil\n  for i\
    \ = 1, #nums do\n    if cur == nil then\n      cur = nums[i]\n    elseif nums[i\
    \ - 1] + nums[i] + cur ~= 0 then\n      table.insert(ordered, cur)\n      cur\
    \ = nums[i]\n    else\n      cur = nums[i]\n    end\n  end\n  table.insert(ordered,\
    \ cur)\n  return ordered\nend", "  if type(nums) ~= 'table' then return nums end\n\
    \  local nums_copy = table.copy(nums)\n  local results = {}\n  for i = 1, #nums_copy\
    \ do\n    local n = tonumber(string.format(\"%g\", nums_copy[i]))\n    if n ==\
    \ nil then break end\n    local sum = 0\n    for j = 1, 10 do\n      if j == n\
    \ then break end\n      sum = sum + j\n    end\n    table.insert(results, sum)\n\
    \  end\n  return results\nend", "  local ans = {}\n  for i = 1, #nums do\n   \
    \ local sum = 0\n    for j = 1, 10 do\n      sum = (sum * 10) + nums[i] - j\n\
    \    end\n    table.insert(ans, sum)\n  end\n  table.sort(ans, function(a, b)\
    \ return a < b end)\n  for i = 1, #ans do\n    nums[i] = ans[i]\n  end\n  return\
    \ ans\nend", "  local nums_sorted = {}\n  local index_of_largest_summed = 0\n\
    \  local number_of_digits = 1\n  local largest_summed = 0\n  for i = 1, #nums\
    \ do\n    local n = nums[i]\n    local summed = 0\n    for j = 1, #n do\n    \
    \  summed = summed + ((j-1) * tonumber(string.format(\"%.\" .. number_of_digits\
    \ .. \"d\", tonumber(string.sub(n, 1, j)))) * (j-1))\n    end\n    local index_of_summed\
    \ = #nums_sorted\n    if index_of_summed > index_of_largest_summed then\n    \
    \  index_of_largest_summed = index_of_summed\n    end\n    nums_sorted[#nums_sorted+1]\
    \ = summed\n    largest_summed = largest_summed + summed\n    number_of_digits\
    \ = number_of_digits + 1\n  end\n  for i = 1, #nums_sorted do\n    if largest_summed\
    \ < nums_sorted[i] then\n      table.insert(nums_sorted, i, nums[i])\n      index_of_largest_summed\
    \ = i\n    end\n  end\n  return nums_sorted\nend", "  if #nums == 0 then return\
    \ nums end\n  local function aux(tab, sum, max)\n    if sum >= max then return\
    \ tab end\n    local index = #tab + 1\n    tab[index] = sum % 10\n    sum = sum\
    \ / 10\n    aux(tab, sum, max)\n  end\n  return aux(nums, 0, #nums)\nend", " \
    \ -- If the table is empty, return an empty table.\n  if not nums then\n    return\
    \ {}\n  end\n  -- If the table is one item, return it.\n  if #nums == 1 then\n\
    \    return {[nums[1]]}\n  end\n  -- Find the largest item whose sum is zero.\n\
    \  local max_sum = 0\n  local max_index = nil\n  for i, v in ipairs(nums) do\n\
    \    -- If the current item is zero, ignore it.\n    if v == 0 then\n      continue\n\
    \    end\n    -- Otherwise, find the maximum item whose sum is zero.\n    local\
    \ tmp_sum = 0\n    for j = 1, #nums do\n      tmp_sum = tmp_sum + j\n      if\
    \ tmp_sum > v then\n        break\n      end\n    end\n    -- If the maximum is\
    \ found and its index is the same as current item,\n    -- then update max_sum\
    \ and max_index.\n    if tmp_sum == v then\n      if max_index == nil then\n \
    \       max_sum = v\n        max_index = i\n      else\n        if v > max_sum\
    \ then\n          max_sum = v\n          max_index = i\n        end\n      end\n\
    \    end\n  end\n  -- If the maximum sum is zero, just return an empty table.\n\
    \  if max_sum == 0 then\n    return {}\n  end\n  -- Swap the max_index with last\
    \ item.\n  local swap_index = #nums - 1\n  nums[swap_index], nums[max_index] =\
    \ nums[max_index], nums[swap_index]\n  -- Sort the remaining items with decreasing\
    \ sum of their digits.\n  local results = {}\n  for i = 1, #nums - 1 do\n    local\
    \ index = i\n    while index > 0 do\n      local last_digit = nums[index]\n  \
    \    local last_digit_sum = 0\n      local last_sum_index = index - 1\n      while\
    \ last_sum_index >= 0 do\n        local digit_sum = last_digit_sum + nums[last_sum_index]\n\
    \        if digit_sum > last_digit then\n          last_digit = digit_sum\n  \
    \        last_sum_index = last_sum_index - 1\n        else\n          break\n\
    \        end\n      end\n      if last_digit < 0 then\n        break\n      end\n\
    \      table.insert(results, last_digit)\n      index = last_sum_index + 1\n \
    \   end\n  end\n  -- Reverse the table.\n  for i = #results - 1, 1, -1 do\n  \
    \  table.reverse(nums, i, #nums)\n  end\n  return results\nend", "  if #nums <\
    \ 2 then\n    return {}\n  end\n  local result = {}\n  for i = #nums, 1, -1 do\n\
    \    local sum = 0\n    for j = i, 1, -1 do\n      sum = sum + nums[j] % 10\n\
    \      nums[j] = nums[j] / 10\n    end\n    table.insert(result, sum)\n  end\n\
    \  table.sort(result)\n  for i = #nums, 1, -1 do\n    nums[i] = result[i]\n  end\n\
    \  return result\nend", "  if #nums == 0 then\n    return {}\n  end\n  local nums_copy\
    \ = nums\n  local index = 1\n  local index2 = 0\n  local keys = {}\n  -- Store\
    \ the keys in `keys`\n  while index < #nums_copy do\n    local n = nums_copy[index]\n\
    \    if n < 10 then\n      table.insert(keys, n)\n    else\n      local nums2\
    \ = nums_copy[index2]\n      local key = tonumber(string.format(\"%.1f\", n))\n\
    \      local key2 = tonumber(string.format(\"%.1f\", nums2))\n      if key ~=\
    \ key2 then\n        table.insert(keys, key)\n        table.insert(keys, key2)\n\
    \      end\n    end\n    index = index + 1\n    index2 = index2 + 1\n  end\n \
    \ -- Sort `keys`\n  table.sort(keys)\n  -- Get sorted sums\n  local sums = setmetatable({},\
    \ { __index = function() return 0 end })\n  for i = 1, #keys do\n    sums[tonumber(string.format(\"\
    %.1f\", keys[i]))] = sums[tonumber(string.format(\"%.1f\", keys[i]))] + tonumber(string.format(\"\
    %d\", i))\n  end\n  -- Return original table with sorted values\n  local sortedNums\
    \ = {}\n  for i = 1, #nums_copy do\n    sortedNums[#sortedNums + 1] = tonumber(string.format(\"\
    %.1f\", nums_copy[i]))\n  end\n  table.sort(sortedNums)\n  local sortedSums =\
    \ {}\n  for i = 1, #sums do\n    sortedSums[#sortedSums + 1] = tonumber(string.format(\"\
    %.1f\", sums[i]))\n  end\n  table.sort(sortedSums)\n  local sortedIndex = 1\n\
    \  local sortedSum = 0\n  -- Go through the sums, find corresponding index, and\
    \ place the value\n  -- at `sortedIndex`\n  for i = 1, #sums do\n    sortedIndex\
    \ = sortedIndex + sortedSums[i] - sortedSum\n  end\n  for i = 1, #nums_copy do\n\
    \    sortedNums[sortedIndex + 1] = tonumber(string.format(\"%.1f\", nums_copy[i]))\n\
    \  end\n  return sortedNums\nend\n</cell>\n<cell>", "  if not nums then return\
    \ end\n  local sums = {}\n  for i = 1, #nums do\n    local sum = sums[i-1] or\
    \ 0\n    sum = sum + nums[i]\n    sums[i] = sum\n  end\n  table.sort(sums)\n \
    \ local result = {}\n  for i = 1, #nums do\n    result[#result+1] = nums[sums[i]]\n\
    \  end\n  return result\nend", "  local sorted_nums = {}\n  for _, num in ipairs(nums)\
    \ do\n    sorted_nums[num] = nums[num]\n  end\n  table.sort(sorted_nums, function(a,\
    \ b)\n    return (a - b)\n  end)\n  return sorted_nums\nend", "  local sortedIndex\
    \ = {}\n  for i = 1, #nums do\n    sortedIndex[nums[i]] = i\n  end", "    local\
    \ num_keys = {}\n    for k, v in pairs(nums) do\n        local sum = 0\n     \
    \   for i = 0, 9 do\n            sum = sum + tostring(k:sub(1, i)) * tonumber(v:sub(1,\
    \ i))\n        end\n        num_keys[sum] = num_keys[sum] or {}\n        num_keys[sum][k]\
    \ = v\n    end\n    local num_keys = sort(num_keys, \"asc\")\n    local result\
    \ = {}\n    for _, k in ipairs(num_keys) do\n        for k, v in pairs(k) do\n\
    \            result[k] = v\n        end\n    end\n    return result\nend", " \
    \ local sorted_indices = {}\n  local sorted_nums = {}\n  local sorted_sum_of_digits\
    \ = {}\n  local sorted_num_digits = {}\n  local sorted_sum_of_digits_reverse =\
    \ {}\n  local sorted_num_digits_reverse = {}\n  local num_digits = 0\n  local\
    \ sum_of_digits = 0\n  local num_points_without_duplicates = 0\n  for _, num in\
    \ pairs(nums) do\n    if num_digits == 0 then\n      num_digits = math.floor(math.log(num))\n\
    \      sum_of_digits = 0\n    end\n    sum_of_digits = sum_of_digits + num\n \
    \ end\n  local point = 0\n  for _, num in pairs(nums) do\n    if point < num_digits\
    \ then\n      sorted_num_digits[point] = num\n      point = point + 1\n    elseif\
    \ point == num_digits then\n      sorted_num_digits[point] = num\n      sorted_sum_of_digits[point]\
    \ = sum_of_digits\n      point = point + 1\n      sum_of_digits = 0\n    end\n\
    \  end\n  for i = 1, num_digits do\n    sorted_num_digits[num_digits + i] = -1\n\
    \    sorted_sum_of_digits[num_digits + i] = -math.pow(10, num_digits - i - 1)\n\
    \  end\n  for i = 1, num_digits do\n    sorted_num_digits_reverse[num_digits +\
    \ i] = i\n    sorted_sum_of_digits_reverse[num_digits + i] = -math.pow(10, num_digits\
    \ - i - 1)\n  end\n  for point = num_digits + 1, num_digits + #sorted_num_digits\
    \ do\n    local num_in_sorted_list = false\n    for _, num in pairs(sorted_num_digits[point])\
    \ do\n      if num_in_sorted_list then\n        sorted_sum_of_digits[point] =\
    \ sorted_sum_of_digits[point] + num\n      else\n        sorted_nums[point] =\
    \ num\n        sorted_indices[point] = i\n        sorted_sum_of_digits[point]\
    \ = sorted_sum_of_digits[point] + num\n        num_in_sorted_list = true\n   \
    \   end\n    end\n  end\n  for point = num_digits + 1, num_digits + #sorted_num_digits\
    \ do\n    local num_in_sorted_list = false\n    for _, num in pairs(sorted_num_digits[point])\
    \ do\n      if num_in_sorted_list then\n        sorted_sum_of_digits_reverse[point]\
    \ = sorted_sum_of_digits_reverse[point] + num\n      else\n        sorted_nums[point]\
    \ = num\n        sorted_indices[point] = i\n        sorted_sum_of_digits_reverse[point]\
    \ = sorted_sum_of_digits_reverse[point] + num\n        num_in_sorted_list = true\n\
    \      end\n    end\n  end\n  sorted_indices[1] = 1\n  sorted_indices[", "  if\
    \ nums == nil then return end\n  local nums = {}\n  for k, v in pairs(nums) do\n\
    \    table.insert(nums, v)\n  end\n  table.sort(nums, function(a, b)\n    return\
    \ (a + b) - (a + b)\n  end)\n  local output = {}\n  local index = 1\n  for _,\
    \ v in ipairs(nums) do\n    output[index] = v\n    index = index + 1\n  end\n\
    \  return output\nend", "  if not nums then return end\n  local t = {}\n  for\
    \ i, v in ipairs(nums) do\n    local s = v\n    for j = 1, #v do\n      s = s\
    \ + tostring(v[j])\n    end\n    table.insert(t, s)\n  end\n  table.sort(t)\n\
    \  local r = {{}}\n  for i, v in ipairs(t) do\n    table.insert(r, v)\n  end\n\
    \  return r\nend", "  -- We make a copy of nums because otherwise we will change\
    \ its order.\n  local sorted_nums = {}\n  for i = 1, #nums do\n    local key =\
    \ sum_to_key(nums[i])\n    if not sorted_nums[key] then\n      sorted_nums[key]\
    \ = i\n    else\n      -- Sort based on index in the original list.\n      --\
    \ This is important because we want -1's to be ordered last.\n      sorted_nums[key]\
    \ = i\n    end\n  end", "  local sums = terralib.newlist()\n  for i = 1, #nums\
    \ do\n    local value = nums[i]\n    local sum = 0\n    for j = 1, #value do\n\
    \      sum = sum + math.floor((value[j] - 48) * math.pow(10, j))\n    end\n  \
    \  sums[i] = sum\n  end", "  if nums == nil then\n    return {}\n  end\n  local\
    \ total = 0\n  local result = {}\n  for _, v in ipairs(nums) do\n    total = total\
    \ + v\n    result[total] = v\n  end\n  return table.sort(result)\nend", "  if\
    \ not nums then\n    return {}\n  end\n  local sorted_table = {}\n  for i, v in\
    \ ipairs(nums) do\n    if i > 1 then\n      local _, prev_v = unpack(sorted_table)\n\
    \      if prev_v then\n        local _, next_v = unpack(sorted_table)\n      \
    \  if prev_v + v ~= next_v then\n          table.insert(sorted_table, v)\n   \
    \     end\n      end\n    end\n    table.insert(sorted_table, v)\n  end\n  return\
    \ sorted_table\nend", "  if #nums == 0 then return end\n  if #nums > 1 then\n\
    \    return table.sort(nums, function()\n      return table.sort(#nums, function()\n\
    \        local sum = 0\n        for _ in pairs(nums) do sum = sum + tonumber(string.sub(tostring(_),\
    \ 1, 1)) end\n        return sum\n      end)\n    end)\n  end\n  local item =\
    \ nums[1]\n  table.sort(nums, function()\n    local sum = 0\n    for _ in pairs(nums)\
    \ do sum = sum + tonumber(string.sub(tostring(_), 1, 1)) end\n    return sum >\
    \ tonumber(tostring(item))\n  end)\n  return item\nend", "  local t = {}\n  for\
    \ i, v in ipairs(nums) do\n    t[v] = (t[v] or 0) + i\n  end\n  table.sort(t)\n\
    \  for i, v in ipairs(nums) do\n    nums[i] = t[v]\n  end\n  return nums\nend",
  "  if next(nums) == nil then\n    return {}\n  end\n  local t = {}\n  for k, v in\
    \ pairs(nums) do\n    local num_str = table.concat(map(string.todigits, split(v,\
    \ '')))\n    local key = num_str\n    local sum = 0\n    for i = 1, #num_str do\n\
    \      sum = sum + tonumber(num_str:sub(i, i))\n    end\n    if sum > 0 then\n\
    \      key = key .. '-' .. sum\n    end\n    t[#t + 1] = key\n  end\n  table.sort(t,\
    \ function(t1, t2)\n    local num_str1 = table.concat(map(string.todigits, split(t1,\
    \ '-')))\n    local num_str2 = table.concat(map(string.todigits, split(t2, '-')))\n\
    \    local same = num_str1 == num_str2\n    local diff = 0\n    for i = 1, #num_str1\
    \ do\n      if tonumber(num_str1:sub(i, i)) ~= tonumber(num_str2:sub(i, i)) then\n\
    \        same = false\n        break\n      end\n    end\n    if same then\n \
    \     diff = t1 - t2\n    end\n    return diff\n  end)\n  return t\nend", "  local\
    \ points = {}\n  local max_sum = 0\n  for i = 1, #nums do\n    local p = nums[i]\n\
    \    points[i] = p\n    if max_sum ~= 0 then\n      local diff = p - max_sum\n\
    \      if diff ~= 0 then\n        points[i] = points[#points] + diff + 1\n   \
    \   end\n    end\n    max_sum = max_sum + p\n  end\n  table.sort(points, function(a,\
    \ b)\n    return a < b\n  end)\n  return points\nend", "  local nums_with_points\
    \ = {}\n  for i = 1, #nums do\n    local nums_element = nums[i]\n    local sum_of_digits\
    \ = math.floor(nums_element % 10) + math.floor(nums_element / 10)\n    table.insert(nums_with_points,\
    \ nums[i])\n    if nums_with_points[#nums_with_points+1] == sum_of_digits then\n\
    \      table.sort(nums_with_points, function(a, b) return a == b end)\n      table.insert(nums_with_points,\
    \ nums[#nums_with_points+1])\n    end\n  end\n  table.sort(nums_with_points, function(a,\
    \ b) return a == b end)\n  return nums_with_points\nend", "  if #nums == 0 then\n\
    \    return {}\n  else\n    local sums = {}\n    for _, value in pairs(nums) do\n\
    \      local digits = math.floor(value / 10)\n      if not sums[digits] then\n\
    \        sums[digits] = {}\n      end\n      sums[digits][\"+\"] = value % 10\n\
    \    end\n    local sorted_sums = terralib.newlist()\n    local total_sum = terralib.newsymbol(uint64)\n\
    \    for digit, sum in pairs(sums) do\n      sum:map(function(n) return n * 10\
    \ end)\n      if #sum == 0 then\n        terralib.attrstore(sum, total_sum, true,\
    \ false)\n      else\n        local index_of_min = terralib.newsymbol(uint64)\n\
    \        local total_sum_of_min = terralib.newsymbol(uint64)\n        local index_of_largest_min\
    \ = terralib.newsymbol(uint64)\n        local index_of_largest_max = terralib.newsymbol(uint64)\n\
    \        local index_of_min = terralib.newsymbol(uint64)\n        local index_of_max\
    \ = terralib.newsymbol(uint64)\n        local total_sum_of_max = terralib.newsymbol(uint64)\n\
    \        local num_items = terralib.newsymbol(uint64)\n        local items = terralib.newsymbol(uint64)\n\
    \        sum:map(function(n) return n * 10 end)\n        sum:map(function(n) index_of_min:settype(n)\
    \ end)\n        sum:map(function(n) total_sum_of_min:settype(n) end)\n       \
    \ local sum_of_largest_min = terralib.newsymbol(uint64)\n        local sum_of_largest_max\
    \ = terralib.newsymbol(uint64)\n        local i = terralib.newsymbol(uint64)\n\
    \        local j = terralib.newsymbol(uint64)\n        sum:map(function(n) sum_of_largest_min:settype(n)\
    \ end)\n        sum:map(function(n) sum_of_largest_max:settype(n) end)\n     \
    \   sum:map(function(n) num_items:settype(n) end)\n        items:map(function(n)\
    \ index_of_min:settype(n) end)\n        items:map(function(n) index_of_max:settype(n)\
    \ end)\n        items:map(function(n) total_sum_of_min:settype(n) end)\n     \
    \   items:map(function(n) total_sum_of_max:settype(n) end)\n        sum:map(function(n)\
    \ index_of_largest_min:settype", '  if not nums then return {} end', "  if #nums\
    \ == 0 then\n    return {}\n  end\n  local sums = {}\n  for i, v in ipairs(nums)\
    \ do\n    local digits = {}\n    for j = 1, math.floor(math.log10(v)) do\n   \
    \   table.insert(digits, v)\n      v = v / 10\n    end\n    local sum = table.sum(digits)\n\
    \    if sum == v then\n      sums[i] = sum\n    else\n      table.sort(digits,\
    \ function(a, b)\n        return sums[a] - sums[b]\n      end)\n      sums[i]\
    \ = sums[#digits]\n    end\n  end\n  local order = {}\n  for i, v in ipairs(nums)\
    \ do\n    order[sums[v]] = v\n  end\n  return order\nend", "   local result =\
    \ {}\n   for _, num in ipairs(nums) do\n      local sum = math.floor(num)\n  \
    \    if sum > 0 and sum < 10 then\n         table.insert(result, sum)\n      end\n\
    \   end\n   return result\nend", "  if not nums then return end -- Nothing to\
    \ sort\n  local sorted_nums = {}\n  -- Find the sum of all digits in original\
    \ table first\n  for i=1,#nums do\n    local cur_sum = nums[i]\n    for j=1,(#nums\
    \ - i) do\n      cur_sum = cur_sum + nums[j + i]\n    end\n    sorted_nums[cur_sum]\
    \ = sorted_nums[cur_sum] or {}\n    sorted_nums[cur_sum][#sorted_nums[cur_sum]\
    \ + 1] = nums[i]\n  end\n  -- Find the sum of each digit in sorted table\n  for\
    \ i=1,#sorted_nums do\n    sorted_nums[i] = {}\n    for j=1,#sorted_nums[i] do\n\
    \      sorted_nums[i][j] = (sorted_nums[i][j] or 0) + sorted_nums[i][j + 1]\n\
    \    end\n  end\n  -- Sort the table\n  table.sort(sorted_nums)\n  -- Return result\n\
    \  local result = {}\n  for i=1,#sorted_nums do\n    table.insert(result, sorted_nums[i][#sorted_nums[i]\
    \ - 1])\n  end\n  return result\nend", '  local sorted = {}', "  local sorted_keys\
    \ = table.sort(\n    table.concat(tonumber(nums)),\n    function (x) return x+0\
    \ end,\n    function (a, b) return a > b end,\n  )\n  return table.reduce(\n \
    \   sorted_keys,\n    function (res, val, idx)\n      -- Return `res` when `idx`\
    \ is in `res` already.\n      if type(res[val]) == \"table\" then\n        return\
    \ res[val]\n      end\n      local digits = tonumber(math.floor(math.abs(val)))\n\
    \      if res and digits > res[1] then\n        res[2] = idx\n        return res\n\
    \      end\n      return { digits + 0, res, idx }\n    end,\n    {0, {}, 0}\n\
    \  )[2]\nend", "  local sorted_table = table.copy(nums)\n  -- Sort by keys\n \
    \ table.sort(sorted_table, function(x, y)\n    return compare(sum(x), sum(y))\n\
    \  end)\n  -- Sort by values\n  for i = 1, #sorted_table do\n    local v = sorted_table[i]\n\
    \    sorted_table[i] = sorted_table[i + #sorted_table]\n    sorted_table[i + #sorted_table]\
    \ = v\n  end\n  return sorted_table\nend", "  -- Sort the given table of integers\
    \ in ascending order according to the\n  -- sum of their digits.\n  local function\
    \ cmp(x, y) -- Sort in ascending order.\n    return x + y - cmp(y, x);\n  end",
  "  if #nums <= 0 then\n    return {}\n  end\n  local table = { }\n  for i = 1, #nums\
    \ do\n    local v = nums[i]\n    if v < 0 then\n      table.insert(table, v)\n\
    \    else\n      local j = table.getn(table)\n      if j == nil then\n       \
    \ j = #table\n        table.insert(table, v)\n      else\n        j = j - 1\n\
    \      end\n      table.insert(table, j, v)\n    end\n  end\n  return table\n\
    end", "  if nums == nil then return end\n  local map = {}\n  local results = {}\n\
    \  for i=0,#nums do\n    local n = tonumber(nums[i])\n    local key = tostring(n)\n\
    \    if not map[key] then\n      table.insert(results, n)\n      map[key] = i\n\
    \    end\n  end\n  table.sort(results, function(a,b) return tonumber(tostring(a))\
    \ < tonumber(tostring(b)) end)\n  for i=1,#results do\n    table.insert(nums,\
    \ tostring(results[i]))\n  end\n  return nums\nend", "  if #nums == 0 then return\
    \ end\n  local nums_copy = nums[#nums]\n  local i = 1\n  while i < #nums do\n\
    \    local sum = 0\n    for k in i-1, i, #nums do\n      sum = sum + tonumber(string.format(\"\
    %.1f\", nums[k]))\n    end\n    if sum == 0 then\n      table.remove(nums, i)\n\
    \      i = i - 1\n    else\n      local j = i\n      while j < #nums and tonumber(string.format(\"\
    %.1f\", nums[j])) > sum do\n        j = j + 1\n      end\n      if j ~= i then\n\
    \        table.insert(nums, i, nums[j])\n        table.remove(nums, j)\n     \
    \   i = i - 1\n      end\n    end\n  end\n  return nums_copy\nend", "  local num_to_points\
    \ = {}\n  local num_to_sums = {}\n  for i, num in ipairs(nums) do\n    local digits\
    \ = math.floor(math.log(num) / math.log(10))\n    if num_to_points[digits] ==\
    \ nil then\n      num_to_points[digits] = {}\n      num_to_sums[digits] = num\n\
    \    elseif num_to_points[digits][num] ~= nil then\n      local i\n      num_to_points[digits]\
    \ = {}\n      for i, v in ipairs(num_to_points[digits]) do\n        if v > num\
    \ then\n          num_to_points[digits][i] = v\n          break\n        end\n\
    \      end\n    end\n    local sums = num_to_points[digits]\n    local current_sum\
    \ = sums[num] + num\n    local key\n    for key, value in pairs(sums) do\n   \
    \   if current_sum > value then\n        sums[key] = current_sum - value\n   \
    \     break\n      end\n    end\n    if num_to_points[digits] == nil then\n  \
    \    num_to_points[digits] = {num}\n      num_to_sums[digits] = num\n    elseif\
    \ num_to_points[digits][num] == nil then\n      num_to_points[digits] = {}\n \
    \     num_to_sums[digits] = num\n      num_to_points[digits][num] = num\n    end\n\
    \  end\n  local nums_sorted = {}\n  local num_to_sums\n  for i, num in ipairs(num_to_sums)\
    \ do\n    if nums_sorted[i] == nil then\n      nums_sorted[i] = num\n    else\n\
    \      local new_digits = math.floor(math.log(num) / math.log(10))\n      if num_to_points[new_digits]\
    \ == nil then\n        nums_sorted[i] = num\n      else\n        local current_sum\
    \ = num_to_sums[num] + num\n        for _, key in pairs(num_to_points[new_digits])\
    \ do\n          if current_sum > key then\n            num_to_points[new_digits][key]\
    \ = current_sum - key\n            break\n          end\n        end\n       \
    \ local keys = sort(num_to_points[new_digits], function(a, b) return a < b end)\n\
    \        for _, key in ipairs(keys) do\n          if nums_sorted[i] < num then\n\
    \            nums_sorted[i] = num\n            num_to_sums[num] = key\n      \
    \      break\n          end\n        end\n      end\n    end\n  end\n  return\
    \ table.concat(nums_sorted)\nend", "  local sorted\n  if #nums == 0 then return\
    \ {} end", "  local table = {}\n  for k, v in pairs(nums) do\n    table[k] = v\n\
    \  end\n  table.sort(function(a, b)\n    local a_digits = string.format(\"%0d\"\
    , a)\n    local b_digits = string.format(\"%0d\", b)\n    local sum_digits = string.format(\"\
    %0d\", a_digits + b_digits)\n    return sum_digits > 0 and sum_digits < 10\n \
    \   or b_digits > 0 and b_digits < 10\n    or a_digits > 0 and a_digits < 10\n\
    \    or b < a and b > a\n  end)\n  local output = {}\n  for k, v in pairs(table)\
    \ do\n    output[k] = v\n  end\n  return output\nend", "  local result = {}\n\
    \  for i = 1, #nums do\n    local sum = 0\n    for j = 1, 10 do\n      sum = sum\
    \ + nums[i]:digit(j) * math.pow(10, j - 1)\n    end\n    result[sum] = nums[i]\n\
    \  end\n  table.sort(result)\n  return result\nend", "  local nums_copy = nums\n\
    \  if not nums then\n    return {}\n  end\n  -- Write your code here\n  local\
    \ map = {}\n  local keys = terralib.newlist()\n  local max_sum, max_index = 0,\
    \ -1\n  for i = 1, #nums_copy do\n    local sum = 0\n    for j = 1, 10 do\n  \
    \    local d = tonumber(string.sub(tostring(nums_copy[i]), j, j))\n      sum =\
    \ sum + d * d\n    end\n    map[sum] = map[sum] or i\n    if sum > max_sum then\n\
    \      max_sum = sum\n      max_index = i\n    end\n  end\n  -- Sort the original\
    \ table\n  for i = 1, #nums_copy do\n    if i == max_index then\n      table.insert(keys,\
    \ i)\n      break\n    end\n    table.insert(keys, i)\n  end\n  return keys\n\
    end", "  local nums_sorted = {}\n  local n = 1\n  for _, num in ipairs(nums) do\n\
    \    local digit_sum = 0\n    repeat\n      digit_sum = digit_sum + math.floor(num\
    \ / pow(n, digit_sum))\n    until num == 0 or math.floor(num / pow(n, digit_sum))\
    \ ~= num\n    table.insert(nums_sorted, num)\n    table.insert(nums_sorted, n\
    \ - digit_sum)\n    n = n * 10\n  end\n  table.sort(nums_sorted, function(a, b)\
    \ return a > b end)\n  local new_nums = {}\n  for i = 1, #nums_sorted do\n   \
    \ table.insert(new_nums, nums_sorted[i])\n  end\n  return new_nums\nend", "  local\
    \ table = {}\n  for i=1,#nums do\n    local num = nums[i]\n    local sum = 0\n\
    \    for j=1,#nums do\n      local tmp_sum = sum + nums[j]\n      if tmp_sum ==\
    \ 0 then\n        table.insert(table, num)\n        break\n      end\n      sum\
    \ = tmp_sum\n    end\n    if #table > 1 then\n      table.insert(table, num)\n\
    \    end\n  end\n  return table\nend", "  local total = 0\n  local num_map = {}\n\
    \  for _, num in pairs(nums) do\n    local digits = math.floor(math.log(num) /\
    \ math.log(10))\n    if num_map[digits] then\n      num_map[digits]:add(num)\n\
    \    else\n      num_map[digits] = terralib.newlist()\n      num_map[digits]:add(num)\n\
    \    end\n    total = total + num\n  end\n  local new_nums = {}\n  for _, digits\
    \ in pairs(num_map) do\n    local num = terralib.newlist()\n    for _, v in pairs(digits)\
    \ do\n      num = num + v\n    end\n    new_nums[#new_nums + 1] = num\n  end\n\
    \  new_nums:sort(function(a, b) return a < b end)\n  return new_nums\nend", " \
    \ local t = {}\n  for k, v in pairs(nums) do\n    t[sum_of_digits(k)] = nums[k]\n\
    \  end\n  return t\nend", "   -- Write your sorting code here\nend", "  local\
    \ num_table, num_sums = {}, 0\n  local index\n  for index, v in ipairs(nums) do\n\
    \    num_sums = num_sums + v\n    num_table[index] = num_sums\n  end\n  num_table.sort(function(a,\
    \ b)\n    if a == b then\n      return a < b\n    end\n    return num_table[b]\
    \ - num_table[a]\n  end)\n  for _, v in ipairs(num_table) do\n    nums[v] = nil\n\
    \  end\n  return num_table\nend", "  -- Initialize a dict to hold sorted nums.\n\
    \  local sorted_nums = {}\n  for i = 1, #nums do\n    sorted_nums[i] = 0\n  end\n\
    \  -- Initialize a dict to hold original index\n  local unsorted_nums = {}\n \
    \ for i = 1, #nums do\n    unsorted_nums[#sorted_nums + 1] = i\n  end\n  -- Sum\
    \ nums\n  for i = 1, #nums do\n    sorted_nums[nums[i]] = i\n  end\n  -- Sort\
    \ the dict\n  table.sort(sorted_nums)\n  -- Build unsorted_nums\n  for i = 1,\
    \ #sorted_nums do\n    unsorted_nums[i] = sorted_nums[i]\n  end\n  -- Return the\
    \ result\n  return unsorted_nums\nend", "    local sorted_nums = {}\n    local\
    \ total = 0\n    for k,v in pairs(nums) do\n        total = total + v\n      \
    \  sorted_nums[v] = k\n    end\n    table.sort(sorted_nums)\n    local sorted_nums_copy\
    \ = {}\n    local i = 1\n    for k, v in pairs(sorted_nums) do\n        sorted_nums_copy[k]\
    \ = i\n        i = i + 1\n    end\n    return sorted_nums_copy\nend", "  local\
    \ max_sum = nil\n  if nums then\n    local sorted_keys = table.sort(\n      table.sort(\n\
    \        table.sort(\n          table.sort(\n            local index = 1, len\
    \ = #nums, \n            while len > 0, do\n              local _, digit = math.modf(index\
    \ / 10)\n              index = index - (digit * 10)\n              if max_sum\
    \ == nil or (digit > 0 and max_sum < digit) then\n                max_sum = digit\n\
    \              end\n            end,\n            function(a, b)\n           \
    \   local sum_a, sum_b = #a > #b ? #a : #b, #a > #b ? #b : #a\n              if\
    \ sum_a == sum_b then\n                return a\n              else\n        \
    \        return sum_a > sum_b and a or b\n              end\n            end,\n\
    \          ),\n          function(a, b)\n            return a[1] == b[1]\n   \
    \       end,\n        ),\n        function(a, b)\n          return a[2] == b[2]\n\
    \        end,\n      ),\n      function(a, b)\n        return a[3] == b[3]\n \
    \     end,\n    )", "  local sorted_nums = {}\n  for _, num in ipairs(nums) do\n\
    \    local digits = {}\n    while num ~= 0 do\n      table.insert(digits, math.floor(num\
    \ / 10))\n      num = math.floor(num / 10)\n    end\n    table.insert(sorted_nums,\
    \ 0)\n    for _, digit in ipairs(digits) do\n      table.insert(sorted_nums, digit\
    \ + sorted_nums[#sorted_nums])\n    end\n  end\n  table.sort(sorted_nums)\n  --\
    \ Convert table of integers back to table of strings.\n  for _, num in ipairs(sorted_nums)\
    \ do\n    nums[#nums + 1] = string.format(\"%d\", num)\n  end\n  -- Return original\
    \ table\n  return nums\nend", '  if #nums == 0 then return end', "  if #nums ==\
    \ 0 then\n    return {}\n  end\n  local sum, sort = 0, {}\n  for i = 1, #nums\
    \ do\n    sum = sum + nums[i]\n    table.insert(sort, i)\n    if sum > 0 then\n\
    \      sum = 0\n    end\n  end\n  return sort\nend\n</cell>\n<text>\nNow we need\
    \ a function to print the result in a format like '123 345 456'. That is, we should\
    \ take one space for digits and print them in reverse order. Here is a simple\
    \ way to do that:", "  -- This could be done with only one pass through the table\
    \ if we\n  -- remember the length of the largest sum, but that doesn't make much\
    \ of\n  -- a difference.\n  local max = 0\n  for k, v in pairs(nums) do\n    max\
    \ = max or v\n  end", "    local t = {}\n    for k, v in ipairs(nums) do\n   \
    \     t[#t + 1] = v\n    end\n    t.sort(function(a, b) return sum(a) > sum(b)\
    \ end)\n    for i, v in ipairs(t) do\n        nums[i] = v\n    end\n    return\
    \ nums\nend", "  local result = {}\n  local sums = {}\n  for i, n in ipairs(nums)\
    \ do\n    sums[i] = 0\n    for j = 1, n do\n      sums[i] += (n and digit(n %\
    \ (10^j)) or 0)\n    end\n  end\n  for i, n in ipairs(nums) do\n    if sums[i]\
    \ ~= 0 then\n      result[i] = nums[i]\n    end\n  end\n  return result\nend",
  "  if not nums then return end -- nothing to order\n  local table = {}\n  local\
    \ digits = {}\n  local total = 0\n  for i = 1, #nums do\n    local digit = nums[i]\n\
    \    if digits.has_key(digit) then\n      digits[digit] = digits[digit] + 1\n\
    \    else\n      digits[digit] = 1\n    end\n    total = total + digit\n  end\n\
    \  local max_value = nil\n  local key\n  for digit, count in pairs(digits) do\n\
    \    if count > 1 then\n      if key == nil then\n        key = digit\n      elseif\
    \ digit > key then\n        key = digit\n      end\n    end\n  end\n  if key ==\
    \ nil then\n    key = total\n  else\n    key = total\n  end\n  table.insert(table,\
    \ 1, key)\n  local old_key, new_key\n  for i = 2, #nums do\n    local digit =\
    \ nums[i]\n    if digit == 0 then\n      -- move 0 to the end of the list\n  \
    \    table[i] = 0\n    else\n      local value = digits[digit]\n      if old_key\
    \ == nil then\n        old_key = table[i]\n      else\n        if digit == old_key\
    \ then\n          table[i] = table[i] + old_key\n        else\n          -- use\
    \ index to insert new_key\n          local index = i - 1\n          while table[index]\
    \ ~= 0 do\n            index = index - 1\n          end\n          table[index\
    \ + 1] = new_key\n        end\n      end\n      table[i] = table[i] + digit\n\
    \    end\n  end\n  return table\nend", "  if #nums == 0 then\n    return {}\n\
    \  end\n  local sums = {}\n  for i = 1, #nums do\n    local sum = math.floor(nums[i])\n\
    \    local key = sum\n    if sums[sum] == nil then\n      sums[sum] = i\n    else\n\
    \      key = sums[sum]\n    end\n    table.insert(nums, key, nums[i])\n  end\n\
    \  table.sort(nums)\n  local ret = {}\n  for i = #nums, 1, -1 do\n    ret[i -\
    \ 1] = {num = nums[i - 1]}\n  end\n  return ret\nend", "  local table = {}\n \
    \ for i = 1, #nums do\n    local point = (nums[i] and math.floor(math.log(nums[i],\
    \ 10) + 1)) or 0\n    if #table[point] == 0 then\n      table[point] = nums[i]\n\
    \    else\n      local i = 1\n      while i + 1 < #table[point] and #table[point]\
    \ - table[point] + 1 > i do\n        table[point] = table[point] - table[point]\
    \ + 1\n        table.insert(table, nums[i])\n        i = i + 1\n      end\n  \
    \    table.insert(table, nums[i])\n    end\n  end\n  return table\nend", "   \
    \ if nums == nil then\n        return {}\n    end\n    local table = {}\n    for\
    \ i=1, #nums do\n        table[i] = 0\n    end\n    for i=1, #nums do\n      \
    \  table[i] = table[i] + (nums[i] and nums[i] or 0)\n    end\n    table.sort(function(a,\
    \ b) return table[b] < table[a] end)\n    return table\nend", "   local result\
    \ = {}\n   for k, v in ipairs(nums) do\n      local new_v\n      if k == nil then\n\
    \         new_v = 0\n      else\n         new_v = v\n      end\n      local sum\
    \ = 0\n      local digits = 0\n      local num_digits = 0\n      while num_digits\
    \ < 6 do\n         local n = math.floor(v / 10)\n         local digit = v % 10\n\
    \         if sum + digit >= 10 then\n            sum = sum + digit - 10\n    \
    \     else\n            sum = sum + digit\n            num_digits = num_digits\
    \ + 1\n         end\n         if n ~= 0 then\n            v = v - n * 10\n   \
    \      end\n      end\n      if k == nil then\n         if sum >= 10 then\n  \
    \          new_v = sum + 10\n         else\n            new_v = sum\n        \
    \ end\n      else\n         new_v = sum\n      end\n      result[k] = new_v\n\
    \   end\n   return result\nend", "  -- write your code here\nend", "  local key\n\
    \  local sorted\n  local sum", '  if nums == nil then return end', "  if nums\
    \ == nil then\n    return {}\n  elseif type(nums) == 'table' then\n    -- Table\
    \ of integers\n    local table = totable(nums)\n    table.sort(function(a, b)\
    \ return tonumber(tostring(a)) < tonumber(tostring(b)) end)\n    return table\n\
    \  elseif type(nums) == 'number' then\n    -- Single integer\n    return {tonumber(tostring(nums))}\n\
    \  else\n    -- Multiple integers\n    local result = {}\n    for _, v in ipairs(nums)\
    \ do\n      table.insert(result, tonumber(tostring(v)))\n    end\n    table.sort(function(a,\
    \ b) return result[a] < result[b] end)\n    return result\n  end\nend", "  local\
    \ num_map = {}\n  for _, num in ipairs(nums) do\n    local sum_of_digits = 0\n\
    \    for _ = 1, 10 do\n      sum_of_digits = sum_of_digits + math.floor(num /\
    \ math.pow(10, _))\n      num = num % math.pow(10, _)\n    end\n    if num_map[sum_of_digits\
    \ + 1] then\n      num_map[sum_of_digits + 1] = num_map[sum_of_digits + 1] + 1\n\
    \    else\n      num_map[sum_of_digits + 1] = 1\n    end\n  end\n  local sorted_table\
    \ = {}\n  for _, num in ipairs(num_map) do\n    sorted_table[#sorted_table + 1]\
    \ = num\n  end\n  return sorted_table\nend", '  if nums == nil then return end',
  "  if #nums == 0 then return {} end\n  local keys = {}\n  local sums = {}\n  for\
    \ i = 1, #nums do\n    local sum = nums[i]:byte():reduce(function(acc, cur)\n\
    \      return acc + cur\n    end)\n    table.insert(keys, sum)\n    table.insert(sums,\
    \ sum)\n  end\n  table.sort(keys)\n  table.sort(sums)\n  local res = {}\n  for\
    \ i = 1, #sums do\n    table.insert(res, keys[i])\n  end\n  return res\nend",
  '  if #nums == 0 then return end', "    local sorted = {}\n    for key, value in\
    \ pairs(nums) do\n        sorted[value] = key\n    end\n    table.sort(sorted,\
    \ function(a, b) return a + b end)\n    return sorted\nend", "  local table =\
    \ {}\n  for i = 1, #nums do\n    table[i] = 0\n  end\n  for i = 1, #nums do\n\
    \    table[i + #nums] = i\n  end\n  table.sort(function(a, b) return table[a]\
    \ > table[b] end)\n  local result = {}\n  for i = 1, #nums do\n    result[#result\
    \ + 1] = nums[i - 1]\n  end\n  for i = 1, #table do\n    result[#result + 1] =\
    \ table[i]\n  end\n  return result\nend", "  local digits = {}\n  for k, v in\
    \ pairs(nums) do\n    digits[k] = digits[k] or 0\n    digits[k] = digits[k] +\
    \ v\n  end\n  local sorted = {}\n  local index = 1\n  table.sort(digits, function(a,\
    \ b) return a<b end)\n  for _, k in pairs(digits) do\n    sorted[index] = k\n\
    \    index = index + 1\n  end\n  return sorted\nend", "  local map = {}\n  for\
    \ k, v in pairs(nums) do\n    map[#map + 1] = k\n  end\n  return setmetatable(map,\
    \ {})\nend", "  local sorted = {}\n  for index, num in ipairs(nums) do\n    table.insert(sorted,\
    \ num)\n    table.insert(sorted, index)\n  end\n  table.sort(sorted, compare_sum)\n\
    \  return sorted\nend", "  if #nums == 0 then\n    return {}\n  else\n    -- Find\
    \ the two smallest items and sort them by their digit.\n    local smallest1, smallest2,\
    \ smallest_sum1, smallest_sum2\n    local function sum_of_digits(n)\n      local\
    \ sum = 0\n      while n > 0 do\n        sum = sum + n % 10\n        n = n / 10\n\
    \      end\n      return sum\n    end\n    smallest1, smallest2 = unpack(\n  \
    \    table.sort(\n        unpack(nums, 1, #nums),\n        function(n1, n2)\n\
    \          return sum_of_digits(n1) - sum_of_digits(n2)\n        end\n      )\n\
    \    )\n    smallest_sum1 = sum_of_digits(smallest1)\n    smallest_sum2 = sum_of_digits(smallest2)\n\
    \    -- Check if any items have the same sum of digits and sort them by\n    --\
    \ their index in original table.\n    for i = 1, #nums do\n      if sum_of_digits(nums[i])\
    \ == smallest_sum1 then\n        table.insert(nums, i)\n      end\n      if sum_of_digits(nums[i])\
    \ == smallest_sum2 then\n        table.insert(nums, i)\n      end\n    end\n \
    \   -- Return the sorted table.\n    return unpack(nums)\n  end\nend", "  local\
    \ numsTmp = setmetatable({}, {__mode = 'kv'})\n  for k, v in pairs(nums) do\n\
    \    local _, num = tostring(k), tostring(v)\n    numsTmp[num] = numsTmp[num]\
    \ + v\n  end\n  local sorted = {}\n  for k, v in pairs(numsTmp) do\n    table.insert(sorted,\
    \ k)\n  end\n  table.sort(sorted, function(k1, k2)\n    return numsTmp[k1] > numsTmp[k2]\
    \ or k1 ~= k2\n  end)\n  return sorted\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
