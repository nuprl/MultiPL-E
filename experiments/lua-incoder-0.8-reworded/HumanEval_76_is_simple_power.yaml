name: HumanEval_76_is_simple_power
language: lua
prompt: "-- Your task is to write a function that returns true if a number x is a\
  \ simple\n-- power of n and false in other cases.\n-- x is a simple power of n if\
  \ n**int=x\n-- For example:\n-- >>> is_simple_power(1, 4)\n-- true\n-- >>> is_simple_power(2,\
  \ 2)\n-- true\n-- >>> is_simple_power(8, 2)\n-- true\n-- >>> is_simple_power(3,\
  \ 2)\n-- false\n-- >>> is_simple_power(3, 1)\n-- false\n-- >>> is_simple_power(5,\
  \ 3)\n-- false\nlocal function is_simple_power(x, n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_simple_power\n\
  \    lu.assertEquals(candidate(16, 2), true)\n    lu.assertEquals(candidate(143214,\
  \ 16), false)\n    lu.assertEquals(candidate(4, 2), true)\n    lu.assertEquals(candidate(9,\
  \ 3), true)\n    lu.assertEquals(candidate(16, 4), true)\n    lu.assertEquals(candidate(24,\
  \ 2), false)\n    lu.assertEquals(candidate(128, 4), false)\n    lu.assertEquals(candidate(12,\
  \ 6), false)\n    lu.assertEquals(candidate(1, 1), true)\n    lu.assertEquals(candidate(1,\
  \ 12), true)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if x == n then return true end\n  local power = 1\n  local m = 1\n\
    \  while n > m do\n    power = power * x\n    if power < m then\n      break\n\
    \    end\n    m = m + 1\n  end\n  return n == power\nend", "  return math.sqrt(math.pow(x,\
    \ n)) == x\nend", "  if n==1 then return true end\n  if x<1 then return false\
    \ end\n  if n==0 then return false end\n  if x==1 then return true end\n  if x==n\
    \ then return true end\n  return is_simple_power(x/2, n)\nend", "  return n ==\
    \ 0 or x == 1 or is_simple_power(x / n, n)\nend", "  -- Don't use math.pow because\
    \ it doesn't handle negative exponents correctly.\n  -- Lua 5.1 does not have\
    \ a pow function that handles negative exponents\n  -- correctly.\n  --\n  --\
    \ See \"Table 3.14: Implementation Notes\" of http://www.lua.org/manual/5.1/manual.html#3.14\n\
    \  --\n  -- The definition of simple power is as follows:\n  -- x = n * n * n...\
    \ -> pow(n, x) = x ** n\n  --\n  -- When n is 1, the power function is simply\
    \ x = x\n  -- When n is 2, the power function is x = x * x\n  -- When n is 3,\
    \ the power function is x = x * x * x\n  --\n  -- The simplest possible power\
    \ function for this problem is to square the number\n  -- n times and see if the\
    \ result is equal to x.  We can do this because\n  -- the square of a number equals\
    \ the number squared:\n  -- pow(n, x) = n**2 = n ** 2 * n\n  --\n  -- When n is\
    \ even, squares are even:\n  --   pow(n, x) = n * pow(n, 2)\n  --\n  -- When n\
    \ is odd, squares are odd:\n  --   pow(n, x) = n + 2 * n\n  --\n  -- For example,\
    \ with n = 5 and x = 4, the simplest possible power\n  -- function is pow(n, 4)\
    \ = pow(5, 4) = 25 = 25 * 25 * 25\n  --\n  -- This algorithm is called \"binary\
    \ search\" because we're looking for a value\n  -- that fits within the bounds\
    \ we define, which in this case is (2, 3).\n  --\n  -- Note that a more efficient\
    \ algorithm exists.  See https://en.wikipedia.org/wiki/Binary_search\n  --\n \
    \ -- Note: If x is negative, then the nth power of n must be negative.", "  --\
    \ Write your function here!\nend", "    -- Base cases\n    if n==1 then\n    \
    \    return (x==1 and n==1)\n    elseif n==0 then\n        return (x==0 and n==1)\n\
    \    elseif n==-1 then\n        return (x==1 and n==-1)\n    else\n        if\
    \ x<0 then\n            x=-x\n            n=-n\n        end\n        -- Now test\
    \ if n is even\n        if n%2==0 then\n            return false\n        end\n\
    \        -- Now find out if we have divided the number by n\n        local i=n-1\n\
    \        while i>1 do\n            if x%i==0 then\n                return false\n\
    \            else\n                i=i-1\n            end\n        end\n     \
    \   -- If it is, return true\n        return true\n    end\nend", "   return (math.pow(math.huge,\
    \ int(x), n) == math.pow(x, n))\nend", "  return n == 1 or (n ~= x and n % x ==\
    \ 0 and n / x == x)\nend", "   -- Base case\n   if n == 1 then\n      return true\n\
    \   end\n   -- Base case\n   if n <= 0 then\n      return false\n   end\n   --\
    \ Recursive case\n   -- n is odd\n   if n % 2 == 1 then\n      local x = math.pow(n,\
    \ x)\n      -- Check x for integer type\n      if x % 1 == 0 then\n         return\
    \ true\n      else\n         return false\n      end\n   end\n   -- n is even\n\
    \   local x = math.pow(n, x)\n   -- Check x for integer type\n   return x % 1\
    \ == 0\nend", "    local power = tonumber(n)\n    local is_power = power*power==x\n\
    \    if is_power then\n        return true\n    elseif power==1 then\n       \
    \ return false\n    else\n        return is_simple_power(x, power-1)\n    end\n\
    end", "\t-- Base case\n\tif n == 1 then return true end\n\tif x == n then return\
    \ true end\n\t-- If x > n then return false\n\tif x > n then return false end\n\
    \t-- If the last digit of x is 1 then return false\n\tif x % 10 ~= 1 then return\
    \ false end\n\t-- Rest of the cases are easy\n\treturn is_simple_power(x ^ n %\
    \ 10, n / 10)\nend", "\treturn n ~= 0 and ((n**int) = x) and (n^int)\nend", " \
    \   -- Your code here\nend", "  -- Base case\n  if x == 1 then return n == 1 end\n\
    \  -- If x is a power of n then return true \n  if x == n**x then return true\
    \ end\n  -- If x is not simple power of n return false \n  return false\nend",
  "  if n==1 then return true end\n  if n==2 then return x==x end\n  if n>x and x%n==0\
    \ then return false end\n  local r = 1\n  for i=1,n do\n    r = (r*x)%n\n    if\
    \ r==0 then break end\n  end\n  return r==1\nend", "  if x == n then\n    return\
    \ true\n  else\n    if n == 1 or n < 0 then\n      return false\n    end\n   \
    \ local div = x % n\n    return is_simple_power(x, n / div) or is_simple_power(x,\
    \ n)\n  end\nend", "  if x == n then\n    return true\n  end\n  if x < n then\n\
    \    return false\n  end\n  return is_simple_power(x, n-1) or is_simple_power(x^2,\
    \ n)\nend", "    return not n and x or math.floor(x%math.pow(n, math.floor(n/2)))\
    \ == x\nend", "   local mult = 1\n   local power = 1\n   while n > 1 do\n    \
    \  mult = mult*x\n      power = power+1\n      n = n/x\n   end\n   if n == 1 then\n\
    \      return true\n   elseif mult*power == x then\n      return true\n   else\n\
    \      return false\n   end\nend", "\t--print(x, n)\n\tif n==0 then\n\t\treturn\
    \ true\n\telseif n==1 then\n\t\treturn x==n\n\telse\n\t\tlocal power=1\n\t\twhile\
    \ power<n do\n\t\t\tpower=power*2\n\t\tend\n\t\t-- print(power)\n\t\treturn x==power\n\
    \tend\nend", "  if x == 1 then\n    return n==1\n  else\n    return x == n ^ x\
    \ \n  end\nend", "  -- Write your code here\n  return true\nend", "    if x <\
    \ 0 then return false end\n    if x == 1 then return n == 1 end\n    if x % 2\
    \ == 0 then\n        return is_simple_power(x//2, n) or is_simple_power(x, n-1)\n\
    \    end\n    return false\nend", "  return x ~= 1 and x ~= x and math.fmod(x,\
    \ n) = 1\nend", "  if n == 0 then\n    return true\n  end\n  local n_ = #n and\
    \ tonumber(n) or n\n  if x == 1 then\n    return n == n_\n  else\n    return n_\
    \ * n_ == x\n  end\nend", "  if x == n then\n    return true\n  end\n  if x ==\
    \ 1 then\n    return true\n  end\n  if x == 2 then\n    return true\n  end\n \
    \ if n == 0 or x == 1 or (x ~= n and x % n) then\n    return false\n  end\n  local\
    \ d = 0\n  local k = 1\n  local a = x + 1\n  while a > n do\n    d = d + 1\n \
    \   a = a / n\n    k = k + 1\n  end\n  local b = x + 1\n  while b > n do\n   \
    \ b = b - 1\n    k = k - 1\n  end\n  if a == b then\n    return k == d\n  end\n\
    \  while a > b do\n    a = a / 2\n    k = k - 1\n  end\n  while b > a do\n   \
    \ b = b / 2\n    k = k + 1\n  end\n  return k == d\nend", "  if n>1 then\n   \
    \ -- TODO: implement this function\n  end\n  return false\nend", "  -- If the\
    \ number is 0 then it is not a simple power.\n  if x == 0 then return false end",
  "   return tonumber(x)==x and n==tonumber(x)\nend", "  -- Base case\n  if x == 1\
    \ then return true end", "  -- base case\n  if x == 1 then return n == 1 end",
  "  assert(n >= 1)\n  assert(n > 0)\n  if n == 1 then\n    return true\n  end\n \
    \ local r = 1\n  for i = 1, n do\n    r = r * x\n    if x == r then\n      return\
    \ true\n    end\n  end\n  return false\nend", "  return x % n == 0 and n > 0 and\
    \ math.floor(x/n) == math.floor(n/n)\nend", "   if x == 1 then\n      return n==1\n\
    \   elseif n == 1 then\n      return true\n   elseif n%2 == 0 then\n      return\
    \ is_simple_power(x//2, n)\n   else\n      return is_simple_power(x, n-1)\n  \
    \ end\nend", "   if n==1 then\n      return true\n   end", "   return ((x == 1)\
    \ or (x == n)) and ((n == 1) or (n % x == 0))\nend", "    local z = 1\n    for\
    \ i = 1, n do\n        z = z * x\n        if z == x then return true end\n   \
    \ end\n    return false\nend", "  return tonumber(string.format(\"%g^%d\", x,\
    \ n))==x\nend", "  if n==1 then\n    return x==1\n  else\n    return (x%n)==0\
    \ and is_simple_power(x/n, n)\n  end\nend", "    if x==1 then\n        return\
    \ true\n    elseif n==1 then\n        return x==1\n    else\n        return true\n\
    \    end\nend", "  if n == 1 then\n    return x == 1\n  elseif n == 0 then\n \
    \   return x == 0\n  elseif n % 2 == 1 then\n    return x % n == 0\n  else\n \
    \   return x ~= (x / n) * n\n  end\nend", "    if x == n then\n        return\
    \ true\n    end\n    if n == 2 then\n        return true\n    end\n    if x ==\
    \ 1 then\n        return false\n    end\n    if n % 2 == 1 then\n        return\
    \ false\n    end\n    if n % 3 == 0 then\n        return false\n    end\n    if\
    \ n % 5 == 0 then\n        return false\n    end\n    return is_simple_power(x*x,\
    \ n/2)\nend", "    local x_int = tonumber(x)\n    local n_int = tonumber(n)",
  "  if x ~= math.pow(x, n) then return false end\n  for _ = 1, n - 1 do\n    if x\
    \ == math.pow(x, n - 1) then return true end\n  end\n  return false\nend", " \
    \ if x < 1 or (n == 0 and x) or x > n then return false end\n  return x == 1:o\
    \ ** n or x == n:o ** n\nend", "  if n <= 0 then return false end\n  if x == 1\
    \ then return true end\n  if x == n then return true end\n  if x%n==0 then return\
    \ true end\n  return false\nend", "    return x == n and n or x == n*n\nend",
  "  if x == n then\n    return true\n  elseif x <= n then\n    return false\n  else\n\
    \    return is_simple_power(x, n/2)\n  end\nend", "  if x == 1 then return true\
    \ end\n  local d = (x - 1)\n  while d % n ~= 0 do\n    d /= n\n  end\n  return\
    \ d == 1\nend", "  return (x > 1 and\n          (x % n == 0 or n % x == 0)\n \
    \        )\nend", "  assert(n > 0 and n ~= 1)\n  return (x ~= 1 and (x == n or\
    \ (x%n == 0))) or (x%n == 0)\nend", "  -- Your code here\nend", "    if x == 0\
    \ then return false end\n    if n == 0 then return false end\n    if n == 1 then\
    \ return x == 1 end\n    if n <= x then return true end\n    -- n^int=x\n    local\
    \ _, p = x:div(n)\n    local q, r = x:divmod(n)\n    while r:abs() >= p do\n \
    \       q, r = q:divmod(n)\n    end\n    return r == 0\nend", "    if n < 2 then\
    \ return false\n    end\n    if x == n then return true\n    end\n    -- if n**int=x\
    \ then n=int\n    if n % 2 == 1 then return false\n    end\n    return is_simple_power(x,\
    \ n/2)\nend", "    if n == 0 then return false end\n    if n%2 == 0 then return\
    \ false; end\n    for i = 5, 1, -1 do\n        if x % i == 0 then\n          \
    \  if n == x then\n                return true\n            else\n           \
    \     return false\n            end\n        end\n    end\n    return false\n\
    end", "  return x == 0 or is_simple_power(n ^ x, n)\nend", "  if n == 0 then return\
    \ false end\n  if x == 1 then return true end\n  if n == 1 then return x==1 end\n\
    \  if n == 2 then return x==1 end\n  return n % 2 == 0 and is_simple_power(x*x,\
    \ n/2) and is_simple_power(x*x, n/2)\nend", "  -- Base cases\n  if x==1 then\n\
    \    return n==1\n  elseif x==0 then\n    return n==0\n  else\n    -- If n is\
    \ not an integer then raise it to an integer and check if x is a\n    -- simple\
    \ power of that integer.\n    local function is_power_integer(n)\n      return\
    \ math.floor(n) ~= n or x == (n*n*n)\n    end", "    if x<1 or n<1 then return\
    \ false end\n    -- Special cases for power of 1: 1**1=1 and 2**1=2\n    if n==1\
    \ then\n        if x==1 then return true end\n        return false\n    end\n\
    \    -- Special cases for power of 0: 0**1=0\n    if x==0 then return false end\n\
    \    -- A simple test case\n    if x==1 then return true end\n    -- Use binary\
    \ search to optimize the search\n    -- since x is small\n    local i = 1\n  \
    \  local p = 2\n    while p*p <= x do\n        if x%p == 0 then\n            return\
    \ false\n        elseif p*p == x then return true end\n        i = i+1\n     \
    \   p = p*2\n    end\n    return false\nend", "    -- Your code here\nend", " \
    \   return ((x % n) == 0 and (x ~= 1 or n == 1))\nend", "  -- base case\n  if\
    \ x==1 then\n    return n==1\n  -- test if x is divisible by n\n  elseif n==1\
    \ then\n    return x % n==0\n  -- test if x is a power of n\n  elseif x == n *\
    \ n then\n    return x == n * x\n  -- test if x is a power of n and x is even\
    \ and x is not prime\n  elseif x == n * n^2 then\n    return x == n * x^2 and\
    \ is_prime(x)\n  -- otherwise, return false\n  else\n    return false\n  end\n\
    end", "    -- check for n = 0\n    if n == 0 then\n        return true\n    end",
  "\t-- Base Cases\n\tif n == 1 then return true\n\tend\n\tif n == 0 then return false\n\
    \tend\n\tif n == -1 then return false\n\tend\n\t-- Simple Cases\n\tif x == 1 then\
    \ return true\n\tend\n\tif x == 0 then return false\n\tend\n\tif x == -1 then\
    \ return false\n\tend\n\t-- Special Cases\n\tif x == 2 then return true\n\tend\n\
    \tif x == 0.5 then return true\n\tend\n\tif x == 0.1 then return true\n\tend\n\
    \tif x == 0.2 then return true\n\tend\n\tif x == 0.4 then return true\n\tend\n\
    \tif x == 0.6 then return true\n\tend\n\tif x == 0.8 then return true\n\tend\n\
    \tif x == 1.1 then return true\n\tend\n\tif x == 1.2 then return true\n\tend\n\
    \tif x == 1.5 then return true\n\tend\n\tif x == 1.6 then return true\n\tend\n\
    \tif x == 1.7 then return true\n\tend\n\tif x == 2.2 then return true\n\tend\n\
    \tif x == 2.4 then return true\n\tend\n\tif x == 2.6 then return true\n\tend\n\
    \tif x == 2.8 then return true\n\tend\n\tif x == 3.2 then return true\n\tend\n\
    \tif x == 3.4 then return true\n\tend\n\tif x == 3.6 then return true\n\tend\n\
    \tif x == 3.8 then return true\n\tend\n\tif x == 4.2 then return true\n\tend\n\
    \tif x == 4.4 then return true\n\tend\n\tif x == 4.6 then return true\n\tend\n\
    \tif x == 4.8 then return true\n\tend\n\tif x == 5.2 then return true\n\tend\n\
    \tif x == 5.4 then return true\n\tend\n\tif x == 5.6 then return true\n\tend\n\
    \tif x == 5.8 then return true\n\tend\n\tif x == 6.2 then return true\n\tend\n\
    \tif x == 6.4 then return true\n\tend\n\tif x == 6.6 then return true\n\tend\n\
    \tif x == 6.8 then return true\n\tend\n\tif x == 7.2 then return true\n\tend\n\
    \tif x == 7.4 then return true\n\tend\n\tif x == 7.6 then return true\n\tend\n\
    \tif x == 7.8 then return true\n\tend\n\tif x == 8.2 then return true\n\tend\n\
    \tif x == 8.4 then return true\n\tend\n\tif x == 8.6 then return true\n\tend\n\
    \tif x == 8.8 then return ", "  if x == n then\n    return true\n  end\n  local\
    \ power, k = 0, 1\n  while power < n do\n    if power < n then\n      k = k +\
    \ 1\n    end\n    power = power ^ x\n  end\n  return k == n\nend", "   if n ==\
    \ 1 then\n      return not x\n   else\n      return (n%x == 0 or is_simple_power(x,\
    \ n-1))\n   end\nend", "  local result = 1\n  local power = x\n  local n = n\n\
    \  while n > 1 do\n    power = power * x\n    n = n - 1\n  end\n  result = power\n\
    \  return result == x\nend", "  -- Base case: n is 1\n  if n == 1 then\n    return\
    \ true\n  end", "  if n==1 then return x==1 end\n  if n>0 then\n    return is_simple_power(x^n,\
    \ n-1)\n  else\n    return is_simple_power(x^(n-1), n)\n  end\nend", "  if x<0\
    \ then return false end\n  if n==0 then return false end\n  if x==1 then return\
    \ true\n  else\n    local int=math.floor(x/n)\n    return is_simple_power(x, n-1)*n==x*n\
    \ or is_simple_power(x*n, n)\n  end\nend", "  if n < 0 then\n    return false\n\
    \  elseif n < 1 then\n    return x == 1\n  elseif x == 1 then\n    return true\n\
    \  else\n    return x == x * x\n  end\nend", "  if x > n then\n    return false\n\
    \  elseif x == n then\n    return true\n  end\n  -- We divide n by x to get the\
    \ power factor\n  local p = math.floor(n/x)\n  -- We compare the power factor\
    \ to see if x is a simple power of\n  -- n\n  local answer = is_simple_power(x,\
    \ p)\n  if p > n then\n    return answer\n  elseif p == n then\n    return true\n\
    \  end\nend", "  return (not (x == 0 or x%1 == 0 or x%1 == 1 or x == n)) and n\
    \ % x == 0 and x*x == n\nend", "  -- Base case.\n  if n <= 0 then\n    return\
    \ false\n  -- Equal powers, including n itself.\n  elseif n == 1 then\n    return\
    \ true\n  -- Other powers are a special case of is_simple_power(x, n-1).\n  elseif\
    \ x % n == 0 then\n    return is_simple_power(x / n, n-1)\n  -- Any other power\
    \ is a special case of is_simple_power(x, n-1).\n  else\n    return is_simple_power(x,\
    \ n-1)\n  end\nend", "    if n == 0 then\n        return true\n    end\n    if\
    \ n == 1 then\n        return x == 1\n    end\n    if n == 2 then\n        return\
    \ x == 2\n    end\n    if n % 2 == 0 then\n        return x ~= n and x ~= (n*x)\n\
    \    else\n        return x ~= n and x ~= (n*x)^2 and x ~= (n*x)^3\n    end\n\
    end", "    -- Base case\n    if n == 1 then\n        return true\n    end\n  \
    \  -- Recursive case\n    if x ~= 1\n    or n % 2\n    or (n % 2) == 0 and n %\
    \ 4 ~= 0 then\n        return false\n    end", "  if n == 0 then return true end\n\
    \  if n == 2 then return x == n end\n  if x <= n then return false end\n  if x\
    \ % n == 0 then return false end\n  return is_simple_power(x div n, n) or is_simple_power(x,\
    \ n-1)\nend", "  if n==1 then return true\n  elseif n==2 then return x==1\n  elseif\
    \ n<0 then return false\n  elseif n==0 then return false\n  end\n  local i=1\n\
    \  while n%2 and i<=x/n do\n    n=n/2\n    i=i+1\n  end\n  x%=n\n  return n==1\
    \ and i==x\nend", "    -- Your code here\nend", "    return (n == 1) or (x ~=\
    \ n * n)\nend", "  if x == 1 then\n    return n == 2\n  else\n    local a = x\
    \ / n\n    local b = math.floor(a)\n    local c = math.floor((a - b) * n)\n  \
    \  return c == x\n  end\nend", "  -- base case\n  if x == n then\n    return true\n\
    \  end", "  if n == 1 then return true end\n  if x ~= 1 then return false end\n\
    \  if n == 2 then return x ~= 1 end\n  local pow, exp = math.frexp(n)\n  return\
    \ x^exp == (pow^exp)\nend", "  if n <= 0 then return false end\n  if n == 1 then\
    \ return true end\n  local res = math.abs(math.pow(x, n))\n  return res == x\n\
    end", "    if n == 1 then\n        return true\n    end\n    local d = 0\n   \
    \ while d <= n do\n        if x^d == x then\n            return true\n       \
    \ end\n        d = d + 1\n    end\n    return false\nend", "    -- Base case\n\
    \    if n == 1 then\n        return true\n    end", "  -- Base case: trivial powers\n\
    \  if x == n then\n    return true\n  -- Recursive case\n  elseif n < 0 then\n\
    \    return false\n  elseif n == 0 then\n    return false\n  elseif n % 2 == 0\
    \ then\n    return is_simple_power(x / 2, n)\n  else\n    -- Find the common factor.\n\
    \    local factors = 1\n    while x > n do\n      factors = factors * 2\n    \
    \  x = x / 2\n    end\n    -- If we can't divide x by this factor, x must be a\
    \ power of n.\n    return x == n * factors\n  end\nend", "  return (x == 1 and\
    \ n ~= 1) or n == math.floor(n) or n ~= math.pow(n, x)\nend\n</cell>\n<cell>",
  "  return x >= n and x < n*n\nend", "  -- Your code here\nend", "  -- Base case\n\
    \  if n==1 then return true end\n  -- Recursive case\n  if x==0 or n==0 then return\
    \ false end\n  -- Simple case\n  if n<1 then return false end\n  -- Get exponent\
    \ part\n  local exponent = math.floor(x)\n  -- Get modulo part\n  local modulo\
    \ = x % n\n  -- Check modulo part\n  local mod_power = 0\n  while modulo ~= 0\
    \ do\n    mod_power = mod_power + 1\n    modulo = modulo mod n\n  end\n  -- Check\
    \ base power\n  if exponent == mod_power then return true end\n  return false\n\
    end", "  -- Base case\n  if n == 0 then return x ~= 0\n  -- Two cases\n  elseif\
    \ n == 1 then return x == 1\n  elseif n < 0 then\n    local i = math.abs(n)\n\
    \    local i2 = i/2\n    return is_simple_power(x, i) and is_simple_power(x, i2)\n\
    \  else\n    -- Three cases\n    local d = 1\n    local x = x * x\n    while d\
    \ <= n do\n      local x2 = x * x\n      local a = (x - x2) ~= 0\n      local\
    \ b = (x - x2 +  d) ~= 0\n      local c = (x - x2 + 2*d) ~= 0\n      local d =\
    \ d + 1\n      if not a and not b and not c then return false end\n    end\n \
    \ end\n  return true\nend", "   return n > 1 and\n      math.abs(x) >= 1 and\n\
    \      math.abs(x) < n and\n      n == math.floor(n) *\n      math.pow(math.e,\
    \ n)\nend", "    if x == n then\n        return true\n    end\n    \n    local\
    \ mult = 1\n    for i=1, n do\n        if x%mult == 0 then\n            return\
    \ false\n        end\n        mult = mult*mult \n    end\n    return true\nend",
  "\t-- Base case\n\tif x == n then\n\t\treturn true\n\tend\n\t-- Check if n is even\n\
    \tif n % 2 == 0 then\n\t\treturn is_simple_power(x, n/2)\n\tend\n\t-- Check if\
    \ n is odd\n\treturn (n % 2 == 1) ~= ((n/x) % 2)\nend", "  -- base cases\n  if\
    \ n == 1 then\n    return true\n  elseif n == 2 then\n    return x == 1\n  elseif\
    \ n == 3 then\n    return x == 1 or (x == 2 and is_simple_power(x, 2))\n  elseif\
    \ n == 4 then\n    return x == 1 or x == 2\n  elseif n == 5 then\n    return x\
    \ == 1 or x == 2 or (x == 4 or is_simple_power(x, 2))\n  end", "   if n < 1 then\n\
    \      return false\n   end\n   if x == 1 then\n      return true\n   end\n  \
    \ local last_exp = 1\n   local last_base = 1\n   if n > 1 then\n      for exp\
    \ = 1, n do\n         last_exp = exp\n         last_base = x\n         x = x *\
    \ x\n      end\n   end\n   if last_exp == n then\n      return last_base\n   else\n\
    \      return false\n   end\nend\n</cell>\n<text>\nWrite a Python function that\
    \ takes a string and checks if it contains a vowel (a, e, i, o, u).", "    --\
    \ TODO: Use math.exp instead of math.pow\n    if n == 1 then\n        return true\n\
    \    end\n    if n < 0 then\n        return false\n    end\n    if n == 1:\n \
    \       return true\n    end\n    -- The base case is trivial.\n    if x == 1\
    \ then\n        return true\n    end\n    -- The base case is trivial.\n    if\
    \ n == 0 then\n        return false\n    end\n    -- The base case is trivial.\n\
    \    if x == 0 then\n        return false\n    end\n    if n > 510 then\n    \
    \    return false\n    end\n    -- TODO: Use math.exp instead of math.pow\n  \
    \  return math.pow(x, n) == x\nend", "  return x <= n and x:gsub('%d', '^%d'):gsub('%D',\
    \ '^%d'):gsub('%', '^'):gsub('^%d', '^%d'):gsub('^%dD', '^%d'):gsub('^%d', '^%dD'):gsub('^D',\
    \ '^'):gsub('^%dD', '^%d'):gsub('^', '^%dD'):gsub('^%dD', '^%d'):gsub('^%d', '^%d'):gsub('^%dD',\
    \ '^%d'):gsub('^%dD', '^%d'):gsub('^%d^', '^%d'):gsub('^%dD^', '^%d'):gsub('^%d',\
    \ '^%d^'):gsub('^%dD^', '^%d'):gsub('^%d^', '^%d'):gsub('^%dD^', '^%d'):gsub('^%dD^',\
    \ '^%d'):gsub('^%d^%d^', '^%d'):gsub('^%dD^%d^', '^%d'):gsub('^%d^%d^', '^%d'):gsub('^%d^',\
    \ '^%d^'):gsub('^%dD^', '^%d^'):gsub('^%d^%d^', '^%d^'):gsub('^%d^%d^', '^%d^'):gsub('^%d^D^',\
    \ '^%d^'):gsub('^%d^%d^', '^%d^'):gsub('^%d^%d^', '^%d^'):gsub('^%d^', '^%d^'):gsub('^%dD^',\
    \ '^%d^'):gsub('^%d^%d^', '^%d^'):gsub('^%d^%d^', '^%d^'):gsub('^%d^D^', '^%d^'):gsub('^%d^%d^',\
    \ '^%d^'):gsub('^%d^%d^', '^%d^'):gsub('^%d^D^', '^%d^'):gsub('^%d^%d^', '^%d^'):gsub('^%d^%d^',\
    \ '^%d^'):gsub('^%d^D^', '^%d^'):gsub('^%d^%d^', '^%d^'):gsub('^%d^%d^', '^%d^'):gsub('^%d^D^',\
    \ '^%d^'):gsub('^%d^%d^', '^%d^'):gsub('^%d^%d^', '^%d^'):gsub('^%d^D^', '^%d^'):gsub('^%d^%d^',\
    \ '^%d^'):gsub('^", "  return n and ((n==1) and (x==1)) or x%n==0\nend", "   \
    \ if n == 1 then return false end\n    if n == 0 then return true end\n    if\
    \ n % 2 == 0 then\n        return is_simple_power(x^x, n-1)\n    else\n      \
    \  return is_simple_power(x^x, n/2) and x == x^(n/2)\n    end\nend", "    local\
    \ function pow_n(x, i)\n        if n <= 0 then return false end\n        if n\
    \ ~= 2^i then return false end\n        local result = x\n        while result\
    \ > 1 do\n            result, i = result/n, i+1\n        end\n        return true\n\
    \    end", "  if x == n then\n    return true\n  elseif n < 0 then\n    return\
    \ false\n  end", "  if x==1 then\n    return true\n  end\n  if n==1 then\n   \
    \ return true\n  end\n  if n==0 then\n    return false\n  end\n  if x==0 then\n\
    \    return false\n  end\n  local nint=n\n  local x=x\n  local d=1\n  while nint\
    \ ~= 0 do\n    while x<1 and nint>0 do\n      x=x*x\n      nint=nint-1\n    end\n\
    \    local remaining=x-1\n    if remaining==0 then\n      return true\n    end\n\
    \    local nint=nint-1\n    local d=d+1\n  end\n  return false\nend", "  -- Check\
    \ for simple power of powers up to n.\n  -- E.g. pow(2, 2) is not a simple power\
    \ of 2, but pow(2, 3) is and pow(2, 4) is not.\n  -- The power of 2 has only two\
    \ simple powers and two compound powers (like n^3 and n^5).\n  -- If n is a compound\
    \ power of 2 there is no simple power of it, i.e. no power of n^n exists.\n  --\
    \ Compound powers are simple powers of n that are in the form n^k or n^m^n, where\
    \ k and m\n  -- are integers >= 1.\n  -- E.g. n^3 is simple power of 3 if k =\
    \ 3 and m = 0.\n  -- n^5 is simple power of 5 if k = 3 and m = 5.\n  -- The algorithm\
    \ works in O(n^2) since we only need to check each power of n once.\n  -- The\
    \ power of n^0 is always simple power of 1.\n  -- The algorithm works for compound,\
    \ simple or compound powers.\n  -- For compound powers n^m can be rewritten as\
    \ pow(n, m), where m is an integer.\n  -- If m > 0 n^m is simple power of m if\
    \ m > 1.\n  -- If n is compound power of m then n^m is compound power of n^m,\
    \ where m > 1.\n  -- If n^m is simple power of m then n^m is simple power of n^m,\
    \ where m > 0.\n  -- If n is simple power of m then n^m is simple power of n^m,\
    \ where m <= 0.\n  -- So if n is a compound power of m and m is compound power\
    \ of n then n^m is simple power of n.\n  if x == 0 then\n    return true\n  end",
  "  if x < n then\n    return false\n  end\n  if x == 1 then\n    return true\n \
    \ end\n  if x == 2 then\n    return true\n  end\n  if x < n and x < n ^ x then\n\
    \    return false\n  end\n  return true\nend", "\tif x == 0 then\n\t\treturn true\n\
    \tend\n\tif x == 1 then\n\t\treturn false\n\tend\n\tif n == 1 then\n\t\treturn\
    \ x == (x * x)\n\tend\n\tif n >= 2 and x == (x * x) or n <= 1 and x == x * x then\n\
    \t\treturn is_simple_power(x / (x * x), n)\n\tend\n\treturn false\nend", "   \
    \ local function is_p(n, m)\n        if n == 1 then return x == m end\n      \
    \  return n % m == 0\n    end\n    if is_p(n, 1) then\n        return true\n \
    \   else\n        return is_p(n, n)\n    end\nend", "  if x<n then\n    return\
    \ false\n  else\n    local result = 1\n    local remaining = x\n    while remaining>1\
    \ do\n      local temp = remaining % n\n      if temp==0 then\n        break --\
    \ no remainder to check\n      else\n        if temp==1 then\n          result\
    \ = result*n -- found a power of n, no further checks needed\n        end\n  \
    \      remaining = remaining//n\n      end\n    end\n    return result == x\n\
    \  end\nend\n</cell>\n<text>\nNext you need to write a function that:", "  if\
    \ n == 1 then\n    return true\n  elseif n == 2 then\n    return x == 1\n  elseif\
    \ n == 3 then\n    return x == 1 or (x ~= 1 and x == 3) or (x ~= 2 and x == 5)\n\
    \  elseif n >= 4 and n <= 16 then\n    return x == 1 or (x ~= 1 and x == n) or\
    \ (x ~= 2 and x == 3*n) or (x ~= 4 and x == 5*n)\n  else\n    return false\n \
    \ end\nend", "   if n == 0 then\n      return false\n   end\n   local mult = 1\n\
    \   for _ = 1, n do\n      mult = mult*x\n   end\n   return mup(x,n) == mult\n\
    end", "    if n==1 then return true end\n    if n==0 then return false end\n \
    \   if n<0 then return false end\n    if n>20 then return false end", "  if n\
    \ == 0 then return true end\n  if n == 1 then return (x == 1) end\n  local d =\
    \ floor(log2(n))\n  local c = pow(x, d, n)\n  return c == x or (d > 0 and is_simple_power(c,\
    \ n/2))\nend", "  assert(type(x) == \"number\")\n  assert(type(n) == \"number\"\
    )", "    if n == 0 then return true\n    if n <= 0 then return false\n    if x\
    \ == 1 then return true\n    return false\nend", "  assert(type(n) == \"number\"\
    )\n  return x%n == 0 and n%x == 0\nend", "  assert(type(n) ~= 'table')\n  if n\
    \ == 0 then\n    return true\n  end\n  if n == 1 then\n    return x == 1\n  end\n\
    \  if n == 2 then\n    return x == 1\n  end\n  if x == 0 then\n    return false\n\
    \  end\n  if x == 1 then\n    return false\n  end\n  if n == -1 then\n    return\
    \ x ~= 1\n  end\n  if x == -1 then\n    return x ~= 1\n  end\n  if x > 0 and n\
    \ ~= 1 then\n    return x ~= 1 and\n           n ~= -1\n  end\n  if x < 0 and\
    \ n ~= -1 then\n    return x ~= -1 and\n           n ~= 1\n  end\n  local power\
    \ = 1\n  while n ~= 1 do\n    power *= n\n    if x ~= power then\n      return\
    \ false\n    end\n    n--\n  end\n  return true\nend", "  return (not x and n\
    \ and n == 1) or ((x and not n) or (not x and not n))\nend", "  -- The power of\
    \ n must be even\n  local pow = tonumber(n)\n  if pow ~= math.floor(pow) or pow\
    \ ~= (pow / 2) then\n    return false\n  end\n  -- Check whether the power is\
    \ equal to x exactly\n  local div = math.fmod(pow, x)\n  if div ~= 0.0 then\n\
    \    return false\n  end\n  -- Check whether the remainder is divisible by x\n\
    \  -- If n^int=x then n^int%x = 0, so x%n = 0.\n  -- So the remainder is always\
    \ divisible by x\n  local rem = math.modf(n * x / pow)[1]\n  if rem == 0 then\n\
    \    return false\n  end\n  -- Check whether the exponent is even\n  if math.fmod(pow,\
    \ 2) == 0.0 then\n    -- If yes, return true since n is simple power\n    return\
    \ true\n  end\n  -- Otherwise return false since n is not simple power\n  return\
    \ false\nend", "    -- Base cases\n    if n == 1 then\n        return true\n \
    \   end\n    if n == x then\n        return true\n    end", "    if x == 1 then\n\
    \        return true\n    end\n    if n == \"+\" then\n        return x <= 1 and\
    \ not x % 2 and not x % 4\n    end\n    if n == \"*\" then\n        return x <=\
    \ 2 and not x % 8 and not x % 16\n    end\n    if n == \"/\" then\n        return\
    \ x <= 4 and not x % 16 and not x % 32\n    end\n    if n == \"%\" then\n    \
    \    return x <= 8 and not x % 32 and not x % 64\n    end\n    return false\n\
    end", "    -- Special case 1 so that it returns true\n    if n==1 then\n     \
    \   if x==1 then\n            return true\n        else\n            return false\n\
    \        end\n    end\n    -- If x is not a simple power of n return false\n \
    \   if n~= math.floor(n) then\n        return false\n    end\n    -- If x is a\
    \ power of n return true as soon as we get to one\n    -- since a power of n must\
    \ be an integer.\n    if n==1 then\n        if x==1 then\n            return true\n\
    \        else\n            return false\n        end\n    end\n    -- Now iterate\
    \ through the numbers of n and decrementing by 1 until\n    -- we hit the base\
    \ case which is that x is a power of n and return true.\n    while n>1 do\n  \
    \      if x%n==0 then\n            return true\n        end\n        n = n-1\n\
    \    end\n    -- We have reached the base case if x is a power of n so return\
    \ false\n    return false\nend", "   return n <= x and n % x == 0 and x ~= math.pow(n,\
    \ x)\nend", "  return n==x and (n==1 or is_simple_power(x, n-1))\nend", "\tif\
    \ x == 1 then\n\t\treturn n==1\n\telseif n == 1 then\n\t\treturn true\n\telseif\
    \ n == 0 then\n\t\treturn false\n\telse\n\t\treturn ((n-1)*n*x)%x==0\n\tend\n\
    end", "  if n == 1 then\n    return x == 1\n  else\n    return x == (n * n)\n\
    \  end\nend", "  return n^int = x\nend", "  if x < 1 or x > n then return false\
    \ end\n  if n == 1 then return true end\n  return is_simple_power(x//n, n-1) ==\
    \ true and x % n == 0\nend", "  -- First, check if n is negative by comparing\
    \ to zero\n  if n < 0 then\n    return not is_simple_power(x, -n)\n  end\n  --\
    \ Check if n is a simple power of x\n  local nint = math.floor(n)\n  local xint\
    \ = math.floor(x)\n  if nint == xint then\n    return true\n  elseif nint < xint\
    \ and xint >= 1 then\n    -- n is a power of x, check if x is one too many\n \
    \   return not is_simple_power(x, xint + 1)\n  else\n    return false\n  end\n\
    end", "\tif x == n then return true end\n\tlocal nint, i = 1\n\twhile i <= n do\n\
    \t\tnint, i = i * x, nint\n\tend\n\treturn false\nend", "    if x ~= 1 then\n\
    \        return false\n    end\n    if n == 1 then\n        return true\n    end\n\
    \    local div = math.pow(n, math.floor(math.log(x, n)))\n    return div == x\n\
    end", "  if n == 0 then\n    error('n should be positive')\n  else\n    return\
    \ is_pow(x, n)\n  end\nend", "\tif n == 1 then return x == 1 end\n\t-- We use\
    \ an approximation to solve the equation (x**n) == 1 and assume n is close to\
    \ a factor\n\t-- of the number of digits in x, since otherwise we would have to\
    \ check x for divisibility by all of those digits.\n\t-- We assume x is a power\
    \ of 2 since we know that x is close to a power of 2, and that n is close to a\
    \ factor\n\t-- of the number of digits in x.\n\tlocal function approximate_division_of_digits(x,\
    \ n)\n\t\t-- The approximation is a number which satisfies the condition:\n\t\t\
    -- n**int = (x^int)^(1/int)\n\t\t-- That is, the fractional part is close to x\
    \ and the integer part is close to 1.\n\t\t-- The first few terms don't matter\
    \ since they are all constants, but the ones that\n\t\t-- matter are approximations\
    \ to the first few powers of x, and all terms are close to one another.\n\t\t\
    -- In particular, the integers close to 1 are all powers of two (2, 4 ,8, and\
    \ so on).\n\t\t-- The integer part and the fractional part will differ by at most\
    \ n, and so if we divide x by the\n\t\t-- first few powers of x where x is a power\
    \ of 2 we can expect that x^n = x, and hence that n**int = x.\n\t\t-- For large\
    \ values of x the approximation will be close to one (with some small variation).\n\
    \t\t-- We are going to compute the approximation by starting with a power of 2\
    \ of size n, and reducing\n\t\t-- that by repeated division by x. Since multiplication\
    \ by x is constant time we can just\n\t\t-- keep dividing by the same power of\
    \ x and adding each time.\n\t\t-- For example: n=3 x=8\n\t\t--   power of x of\
    \ 8: 2^3\n\t\t--   power of 1 of 8: 2^3 + 1\n\t\t--   power of 8: 2^3 + 1\n\t\t\
    --   power of 2 of 8: 2^3 + 2\n\t\t--   power of 8: 2^3 + 2\n\t\t-- We start with\
    \ 8 and reduce the power of 8 by repeatedly dividing it by x:\n\t\t-- 8 / 2^3\
    \ = 2^(1/3) = 8\n\t\t-- 8 / 2^2 = 2^1 + 2^0 = 8\n\t\t-- 8 / 2^1 = 2^0 + 2^1 =\
    \ 8\n\t\t-- 8 / 2^0 = 2^0 + 2^0 = 8\n\t\t-- We now have 2^8 and can add it to\
    \ the power of x to get the final approximation.\n\t\t-- 8^8 = 2^128 = 2^32768\
    \ = 2^", "    if n==1 then return x ~= 0 end\n    if n==2 then return x==1 end\n\
    \    return (x%n ~= 0 or x==1 or is_simple_power(x, n-1))\nend", "  return true\n\
    end", "  return x and n and (x * n) == x\nend", "  if n <= 1 then return false\
    \ end\n  return math.fmod(x, n) == 0 and (math.fmod(x, n) > 0 or is_simple_power(math.fmod(x,\
    \ n), n))\nend", "  if n==1 then\n    return true\n  end\n  if n<0 then\n    return\
    \ false\n  end\n  \n  local r = true\n  if n>1 then\n    local i = 1\n    repeat\n\
    \      r = r and is_simple_power(x, i)\n      i = i + 1\n    until not r\n  end\n\
    \  \n  if n==1 or x%n==0 then\n    return r\n  end\n  \n  return false\nend",
  "  if x ~= 1 and x ~= n then\n    return false\n  elseif n >= 1 then\n    return\
    \ is_simple_power(x*x, n)\n  else\n    return true\n  end\nend", "  return x and\
    \ ((x%n)==0 and (x/n)==n)\nend", "  -- Base case\n  if n==1 then return true end\n\
    \  -- If n is not an integral power, then it must be a non-simple\n  -- power\
    \ and we return false\n  if n>1 then\n    return false\n  end\n  -- Now check\
    \ if x can be expressed as nx\n  -- If it can, then x is a simple power of n\n\
    \  return (x*x)==n\nend", "  if x == n then return true end\n  if x < n then\n\
    \    if is_simple_power(x, n*n) then return true end\n    return false\n  end\n\
    \  for i = 2, n do\n    if is_simple_power(x, n) then return true end\n    if\
    \ x % i == 0 then return false end\n  end\n  return true\nend", "  if n==1 then\
    \ return true end\n  if x%n==0 then return true end\n  local factors=1\n  while\
    \ n%2 do\n    factors=factors+1\n    n=n/2\n  end\n  return factors*is_simple_power(x,\
    \ n-1)\nend", "  if x ~= n then\n    return false\n  end\n  if n == 1 then\n \
    \   return true\n  end\n  if x ~= 2 then\n    return false\n  end\n  if x ~= 4\
    \ then\n    return false\n  end\n  if x ~= 8 then\n    return false\n  end\n \
    \ if x ~= 16 then\n    return false\n  end\n  if x ~= 32 then\n    return false\n\
    \  end\n  if x ~= 64 then\n    return false\n  end\n  return true\nend\n</cell>\n\
    <cell>", "  assert(n >= 1)\n  assert(x <= math.pow(n, math.abs(n)))\n  return\
    \ math.pow(x, n) == x\nend", "  if n==0 then return true\n  elseif n==1 then return\
    \ x==1\n  else return (x%n)==0 and is_simple_power(x//n, n-1)\n  end\nend", " \
    \   if n == 1 then\n        return true\n    else\n        return (x%n == 0) or\
    \ ((x%n == 0) and is_simple_power(x/n, n-1))\n    end\nend", "  return (x % n\
    \ == 0) and is_simple_power(x ^ n, n)\nend", "  if x == 1 or x == n then return\
    \ true end\n  local r = math.floor(x/n)\n  if r == n then return true end\n  return\
    \ is_simple_power(r, n) and x == n * r\nend", "    -- Base case\n    if n == 0\
    \ then\n        return false\n    end\n    -- Test for integer power\n    if n\
    \ > 1 then\n        return is_simple_power(x^n, n)\n    else\n        return x\
    \ ~= n\n    end\nend", "  if n <= 1 then\n    return n == x\n  else\n    return\
    \ x % n == 0 and is_simple_power(x/n, n-1)\n  end\nend", "  if x < 1 or (n % x)\
    \ == 0 then return false end\n  return is_simple_power(x / n, n)\nend", "  if\
    \ n == 0 then\n    return true\n  elseif x % n == 0 then\n    return false\n \
    \ else\n    return is_simple_power(x//n, n) or is_simple_power(x, n-1)\n  end\n\
    end", "  local r = math.pow(x, n)\n  return r == x and (r == n or math.abs(math.floor(r)\
    \ - r) == 1)\nend", "  if x == 0 then return false end\n  if x == 1 then return\
    \ true end\n  if n > 1 then return is_simple_power(x-1) * is_simple_power(x-1)\
    \ end\n  if x == n then return true end\n  return false\nend", "    -- Base Cases\n\
    \    if n == 0 then return true end\n    if n == 1 then return x == 1 end\n  \
    \  if n % 2 == 0 then return x == x*x end", "  -- Base cases.\n  if n == 1 then\n\
    \    return x == 1\n  end\n  if n == 2 then\n    return x == n and x == n*n\n\
    \  end\n  -- More than one case.\n  return n == 0 and (x % n) == 0\nend", "  \
    \ -- write code here\nend", "  if x == 0 then\n    return false\n  elseif x >\
    \ n then\n    return true\n  elseif n == 1 then\n    return true\n  else\n   \
    \ return is_simple_power(x / n, n)\n  end\nend", "    -- Your code here\nend",
  "  if x == n then\n    return true\n  end\n  local div = math.pow(n, 2)\n  local\
    \ i = 1\n  while div > x do\n    div = math.pow(div, 2)\n    i = i + 1\n    if\
    \ i > 100 then\n      return false\n    end\n  end\n  return true\nend", "   --\
    \ Write your code here!\nend", "  if x == 1 or x == n then\n    return true\n\
    \  elseif n ~= 1 then\n    return false\n  else\n    return is_simple_power(x\
    \ % n, n-1)\n  end\nend", "   if n ~= math.floor(n) then return false end\n  \
    \ local factors = {}\n   for i=2,n do factors[i] = i end\n   return #factors ==\
    \ 0 and n ~= x and (n == x or pow(n, x, n) == x)\nend", "    return is_factorable(x)\
    \ and math.fmod(x, n)==0\nend", "  return x == n^n and n % 1 == 0 and n % 2 ~=\
    \ 0\nend", "  local ret = {x = x, n = n}\n  setmetatable(ret, {__index=function()\
    \ return self end})\n  return function(...)\n    -- get x, n\n    local _x, _n\
    \  = unpack(...)\n    -- check input\n    if type(_x)~=\"number\" or type(_n)~=\"\
    number\" then\n      error('Wrong input format for is_simple_power')\n    end\n\
    \    -- compute power\n    local ret2 = ret.n\n    while ret2 > 1 do\n      if\
    \ ret2 == x then\n        return true\n      end\n      ret2 = ret2 / ret\n  \
    \  end\n    -- compute last power\n    local ret3 = ret.n\n    while ret3 > 1\
    \ do\n      if ret3 == x then\n        return true\n      end\n      ret3 = ret3\
    \ / ret\n    end\n    return false\n  end\nend", "\t-- Your code here\nend", " \
    \ if n == 0 then return true end\n  return (x%n) == 0 and is_simple_power(x/n,\
    \ n)\nend", "  if n <= 1 then return false end\n  return x%n == 0\nend", "  return\
    \ (x % n == 0) and is_simple_power(x / n, n) or (x == 1 and n == 1) or (x == n\
    \ and x == 1) or (x == n and x == n and n == 1)\nend", "    if x == n then\n \
    \       return true\n    end\n    if x ~= math.pow(x, n) then\n        return\
    \ false\n    end\n    local divisor = 1\n    for i = 0, n-1 do\n        if n %\
    \ i == 0 then\n            divisor = i\n            break\n        end\n    end\n\
    \    for i=2,divisor-1 do\n        if x % i == 0 then\n            return false\n\
    \        end\n    end\n    return true\nend", "    if x == 1 then\n        return\
    \ true\n    end\n    if x > n then\n        return false\n    end\n    if x >\
    \ 1 then\n        return is_simple_power(n * x, n)\n    end\n    return false\n\
    end", "  -- Your code here!\nend", "   if x == 1 then\n      return true\n   end\n\
    \   if x == 0 then\n      return false\n   end\n   if n == 0 then\n      return\
    \ true\n   end\n   if n % 2 == 0 then\n      return is_simple_power(x / 2, n)\
    \ or is_simple_power(x, n)\n   else\n      return false\n   end\nend\n</cell>\n\
    <cell>", "  if x == n then return true end\n  if n < x then return false end\n\
    \  if n == x then return true end\n  if n == 0 or x == 0 then return false end\n\
    \  if x == 1 or x == n then return true end\n  if x > n then return is_simple_power(x\
    \ - n, n) end\n  return is_simple_power(x - n % x, n)\nend", "  local i = 1 --\
    \ Current power of n\n  -- To avoid repeated calls to is_simple_power(x, i),\n\
    \  -- we use a local variable.\n  local next_i = 1 -- Next power of n\n  -- The\
    \ power of n is just x to the power of next_i.\n  while next_i ~= i do\n    --\
    \ If the number is a power of n, return true.\n    -- Otherwise, return false.\n\
    \    if x%next_i == 0 then\n      return true\n    else\n      i = next_i -- Repeat\
    \ the loop\n    end\n    -- Increment next_i\n    next_i = i * n\n  end\n  return\
    \ false\nend", "  if x == 1 then\n    return true\n  end", "   if x < 1 then return\
    \ false end\n   if x == 1 then return true end\n   if x == n then return true\
    \ end\n   if n > 1 then return is_simple_power(x, n - 1) end\n   return false\n\
    end", "   if n==0 then return true end\n   if n<0 then n=-n; return false end\n\
    \   if n==1 then return (x==1) end\n   if n==2 then return (x==2) end\n   if x==x\
    \ then return true end\n   if x==1 then return false end", "    if x == n then\n\
    \        return true\n    end\n    if x > n then\n        return false\n    end\n\
    \    if n == 1 then\n        return true\n    end\n    if n == 2 then\n      \
    \  return x == math.pow(int, x)\n    end\n    -- TODO: Try to find a more efficient\
    \ way of doing this.\n    local p = 1\n    for i = 1, n do\n        p = p * x\n\
    \    end\n    return x == math.pow(int, p)\nend", "  if n == 1 then\n    return\
    \ (x == 1)\n  else\n    return (x % n == 0)\n  end\nend", "  local r = math.pow(x,\
    \ n)\n  return r == x\nend", "  return (x >= 1 and x <= n and math.pow(x, n) ==\
    \ x)\nend", "  if n==0 then\n    return true\n  end\n  if x>n then\n    return\
    \ false\n  end\n  if n==1 then\n    return true\n  end\n  if x==0 or x==1 then\n\
    \    return true\n  end\n  if x>0 then\n    local m = math.floor(math.log(x,n))\n\
    \    if m ~= n then\n      return false\n    end\n    if m==n then\n      local\
    \ p = pow(x, m+1, n)\n      if p==x and n>1 then\n        return true\n      else\n\
    \        return false\n      end\n    else\n      local s = x / (n / math.pow(n,\
    \ m))\n      if math.floor(math.log(x, n)) == m then\n        return is_simple_power(s,\
    \ n)\n      else\n        return false\n      end\n    end\n  else\n    local\
    \ m = math.floor(math.log(-x,n))\n    if m ~= n then\n      return false\n   \
    \ end\n    if m==n then\n      local p = pow(-x, m+1, n)\n      if p==-x and n>1\
    \ then\n        return true\n      else\n        return false\n      end\n   \
    \ else\n      local s = -x / (n / math.pow(n, m))\n      if math.floor(math.log(-x,\
    \ n)) == m then\n        return is_simple_power(s, n)\n      else\n        return\
    \ false\n      end\n    end\n  end\nend", "  if n == 1 then return true end\n\
    \  if x > n then return false end\n  return math.mod(x^n) == 0 and is_simple_power(x,\
    \ n-1)\nend", "  if n == 1 then return true end\n  if n < 0 or n > 1 then return\
    \ false end\n  if x == 1 then return false end\n  -- if x is power of n\n  if\
    \ x % n == 0 then\n    return is_simple_power(x, n-1)\n  else\n    return false\n\
    \  end\nend", "  if n == 0 then\n    return true\n  elseif n==1 then\n    return\
    \ x==1\n  else\n    return is_simple_power(x, n-1)\n  end\nend\n</cell>\n<text>\n\
    Next, complete the function by writing the body of the function.\nThe function\
    \ must satisfy the following conditions:", "  return (\n    x == x^n or (\n  \
    \    math.isnan(x) or math.isnan(n) or\n      x == 0 or (\n        n ~= 0 and\n\
    \        n ~= math.huge and\n        x == math.huge and\n        x == math.floor(x)\
    \ and x == math.floor(x) / x\n      )\n    )\n  )\nend", "  -- TODO: Your code\
    \ here\n  return true\nend", "  return n and ((x ~= 0) and (x ^ (n or 1)) ~= 0)\n\
    end", "   return math.sqrt(x) >= n\nend", "  if x == 1 then return true end\n\
    \  if x == 0 then return false end\n  -- The first argument must be a power of\
    \ n\n  if n ~= math.floor(n) then return false end\n  -- The second argument must\
    \ be a power of n\n  if n ~= math.floor(n) then return false end\n  -- The second\
    \ argument must be an integer\n  if x ~= x and x % 1 ~= 0 then return false end\n\
    \  -- The second argument must be even\n  if x ~= math.floor(x) and x % 2 ~= 0\
    \ then return false end\n  return true\nend", "  return x==n and n>1 and is_power(x,\
    \ n/2) or false\nend", "  -- your code here\nend", "  if x == 1 then\n    return\
    \ false\n  else\n    local power = math.pow(x, n)\n    if power*n == x then\n\
    \      return true\n    else\n      return false\n    end\n  end\nend", "   if\
    \ x < 0 then\n      return false\n   end\n   if x == 1 then\n      return true\n\
    \   end\n   if n ~= 1 then\n      return (x ~= n) and ((x % n) == 0 or is_simple_power(x\
    \ / n, n))\n   end\n   return (x ~= n) and ((x % n) == 0 or is_simple_power(x\
    \ / n, n))\nend", "  -- write your logic here\n  return true\nend", "  local y\
    \ = 1\n  for i = 1, n do\n    y=y*x\n    if y==x then return true end\n  end\n\
    \  return false\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
