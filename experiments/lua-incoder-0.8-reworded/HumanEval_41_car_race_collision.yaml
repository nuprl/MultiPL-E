name: HumanEval_41_car_race_collision
language: lua
prompt: "-- Imagine a road that's a perfectly straight infinitely long line.\n-- n\
  \ cars are driving left to right;  simultaneously, a different set of n cars\n--\
  \ are driving right to left.   The two sets of cars start out being very far from\n\
  -- each other.  All cars move in the same speed.  Two cars are said to collide\n\
  -- when a car that's moving left to right hits a car that's moving right to left.\n\
  -- However, the cars are infinitely sturdy and strong; as a result, they continue\
  \ moving\n-- in their trajectory as if they did not collide.\n-- This function outputs\
  \ the number of such collisions.\nlocal function car_race_collision(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = car_race_collision\n\
  \    lu.assertEquals(candidate(2), 4)\n    lu.assertEquals(candidate(3), 9)\n  \
  \  lu.assertEquals(candidate(4), 16)\n    lu.assertEquals(candidate(8), 64)\n  \
  \  lu.assertEquals(candidate(10), 100)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["   -- First, set up the initial list of collisions.\n   local collisions\
    \ = {}\n   -- Set up the initial list of cars.\n   local cars = {}\n   for i=1,n\
    \ do\n      local car = make_random_car()\n      table.insert(cars, car)\n   \
    \   -- Keep track of the cars in the current collision.\n      table.insert(collisions,\
    \ car)\n   end\n   -- For each pair of cars in the cars list, do the following\
    \ steps:\n   --    1) Find the first car whose speed is at least as fast as the\
    \ other car.\n   --    2) Remove the other car from the list so that it's not\
    \ considered again.\n   --    3) Append the collision number to the collision\
    \ list.\n   local collision_count = 0\n   for i=1,#cars do\n      for j=1,#cars\
    \ do\n         if cars[i].speed < cars[j].speed then\n            -- 1) Find the\
    \ first car whose speed is at least as fast as the other car.\n            local\
    \ car_with_same_speed = cars[j]\n            for k=j+1,#cars do\n            \
    \   if cars[k].speed < cars[j].speed then\n                  car_with_same_speed\
    \ = cars[k]\n                  break\n               end\n            end\n  \
    \          -- 2) Remove the other car from the list so that it's not considered\
    \ again.\n            table.insert(collisions, cars[j])\n            table.remove(cars,\
    \ j)\n            -- 3) Append the collision number to the collision list.\n \
    \           collision_count = collision_count + 1\n         end\n      end\n \
    \  end\n   return collision_count\nend", "   for i = 1, n do\n      for j = i\
    \ + 1, n do\n         if i != j then\n            local car_1 = random_car(j)\n\
    \            local car_2 = random_car(i)\n            local collide, distance\
    \ = find_collision(car_1, car_2)\n            if collide == 1 then\n         \
    \      return math.random(2, 3)\n            end\n         end\n      end\n  \
    \ end\n   return 1\nend", "   -- First, set up the grid.  A grid is represented\
    \ by a two-dimensional array:\n   --     grid[i][j]  -->  the car at cell (i,j)\
    \ collides with another car at cell (i,j+1)\n   --     grid[i][j+1] --> the car\
    \ at cell (i,j) collides with another car at cell (i+1,j)\n   --     grid[i+1][j]\
    \ --> the car at cell (i,j) collides with another car at cell (i,j-1)\n   -- \
    \    grid[i-1][j] --> the car at cell (i,j) collides with another car at cell\
    \ (i-1,j)\n   --     grid[i][j-1] --> the car at cell (i,j) collides with another\
    \ car at cell (i,j-1)\n   --     grid[i-1][j-1] --> the car at cell (i,j) collides\
    \ with another car at cell (i-1,j-1)\n   --     grid[i-1][j+1] --> the car at\
    \ cell (i,j) collides with another car at cell (i-1,j+1)\n   --     grid[i+1][j+1]\
    \ --> the car at cell (i,j) collides with another car at cell (i+1,j+1)\n   --\
    \     grid[i][j+1] --> the car at cell (i,j) collides with another car at cell\
    \ (i+1,j)\n   --\n   -- The collision function checks whether two cars are colliding,\
    \ i.e.,\n   -- whether they would collide if, instead of moving right to left,\
    \ they moved left\n   -- or right to each other.  The function outputs the number\
    \ of collisions.\n   --\n   -- The grid is built by finding the starting locations\
    \ of the two cars.\n   --\n   -- The two starting locations are picked randomly\
    \ from the set of possible\n   -- starting locations, with the exception that\
    \ a starting location might not\n   -- be actually a starting location (in which\
    \ case it will be skipped), and\n   -- it might not start on the edge of the grid\
    \ either.  Therefore, even if\n   -- there are no collisions, the output might\
    \ be zero.", "\t-- This algorithm is explained in the book, section 3.2.1\n\t\
    local counter = 0\n\tlocal max_distance = 0\n\tlocal min_distance = 0\n\tlocal\
    \ min_distance = max_distance\n\tlocal car_distances\n\tlocal i\n\t-- For each\
    \ possible pair of cars, calculate their distance\n\tfor i = 1, n do\n\t\tcar_distances[i]\
    \ = car_distance(i) * car_distance(i + n)\n\tend\n\tfor i = 1, n do\n\t\tlocal\
    \ current_distance = car_distances[i]\n\t\t-- The current distance is greater\
    \ than the maximum\n\t\t-- possible distance; so there's no collision\n\t\tif\
    \ current_distance > max_distance then\n\t\t\tcounter = counter + 1\n\t\t-- The\
    \ current distance is less than the minimum\n\t\t-- possible distance; so there's\
    \ no collision\n\t\telseif current_distance < min_distance then\n\t\t\tcounter\
    \ = counter + 1\n\t\t-- If both distances are equal, there's an intersection\n\
    \t\telseif current_distance == min_distance then\n\t\t\tcounter = counter + math.ceil(i\
    \ / n)\n\t\tend\n\tend\n\treturn counter\nend", "   -- Cars that moved left and\
    \ right near each other are considered colliding.\n   -- This does not require\
    \ any cars to move at exactly the same speed.\n   if n < 1 then return 0 end\n\
    \   if n <= 3 then return n end\n   local result = nil\n   for i = 1, n do\n \
    \     local j = (n - 1) - i\n      -- If the cars move left and right at exactly\
    \ the same speed,\n      -- they must collide.  If the cars move at different\
    \ speeds, the\n      -- collision probability is less than 1 so they may collide.\n\
    \      if ((j ~= 0) and ((j % 2) == 0)) then\n         result = 1\n         break\n\
    \      end\n   end\n   return result\nend", "  -- If there are n cars already\
    \ on a straight line, then there must be n-1 collisions.\n  -- There are infinitely\
    \ many combinations of these two situations, but they are\n  -- unavoidable because\
    \ we have no idea how many cars collide with each other.\n  --\n  -- The collision\
    \ rate increases as the amount of cars move into the situation\n  -- where two\
    \ cars are colliding.  When the cars are moving right to left,\n  -- they will\
    \ always collide with each other immediately after one another\n  -- when moving\
    \ left to right.  However, when they move right to left,\n  -- they will never\
    \ collide with each other until they start moving towards each other.\n  --\n\
    \  -- So the collision rate increases exponentially with the amount of cars\n\
    \  -- moving into this situation.  A very high collision rate indicates that the\n\
    \  -- situation happens more often than you'd expect it to, but there is no way\
    \ to\n  -- distinguish this situation from all other situations that could arise.\n\
    \  --\n  -- The exponential increases stop when only two cars collide; this situation\
    \ is\n  -- unavoidable.\n  --\n  -- In the worst case scenario, all cars move\
    \ in the same speed, and no cars collide,\n  -- then there will be n-1 collisions,\
    \ and all cars will be moving in the same speed in\n  -- exactly one place.  However,\
    \ in the best case scenario (when no cars collide),\n  -- there will be exactly\
    \ one collision, and all cars will be moving in the same\n  -- speed in the same\
    \ place.  This means that no matter how many cars move into the\n  -- situation\
    \ where no two cars collide, there will always only be one collision.\n  --\n\
    \  --   n >= 3\n  --   0 < n <= 7\n  --   n >= 1\n  --\n  -- To demonstrate this\
    \ worst case scenario, let's say that n = 3.  If we had\n  -- a car moving right-to-left,\
    \ then we could move it a total of n times, in which\n  -- we move it with collisions\
    \ occurring every 1 car.  Therefore, if we had n\n  -- of these cars moving right-to-left,\
    \ they would collide with each other at every\n  -- 1 car (i.e. no collisions).\
    \  Let's say the collision rate of the system was n\n  -- to start off.  Then,\
    \ after 1 car moves, there would be (n - 1) collisions.  Then,\n  -- as n increases,\
    \ the collision rate would increase exponentially, ", "\t-- The number of collisions.\n\
    \tlocal c = 0", "  local collisions = 0\n  for i = 1, n do\n    for j = i + 1,\
    \ n do\n      if is_collision_possible(car_x_pos(i), car_x_pos(j), car_y_pos(i),\
    \ car_y_pos(j), car_height(i),\n                              car_height(j)) then\n\
    \        collisions = collisions + 1\n      end\n    end\n  end\n  return collisions\n\
    end", "    local collisions = 0\n    for i = 1, n do\n        for j = 1, n do\n\
    \            -- The algorithm is deterministic, so the probability of each collision\n\
    \            -- is 1/n^2.\n            -- The algorithm only counts collisions\
    \ when the cars move in a straight line.\n            -- (This is sufficient to\
    \ avoid collisions altogether; it just avoids the overhead\n            -- of\
    \ storing more data.)\n            collisions = collisions + math.floor((math.random(1,\
    \ n) + math.random(1, n))/2)\n        end\n    end\n    return collisions\nend",
  "   if n <= 0 then return 0 end\n   local count = 0\n   for i = 1, n do\n      count\
    \ = count + car_race_collision(i - 1)\n      if i < n then count = count + car_race_collision(i)\
    \ end\n   end\n   return count\nend", "  -- The maximum number of cars that can\
    \ collide at the same time is 2.\n  -- This limitation prevents us from using\
    \ an O(n\xB2) algorithm.\n  -- We will iterate until we find a situation where\
    \ 2 cars collide.\n  local collisions = 0\n  while collisions < 2 do\n    -- Pick\
    \ a car to start with\n    local car_0 = random(0, n)", "   local result = 0\n\
    \   for j = 1, n do\n      for i = 1, n do\n         if (i != j) then\n      \
    \      local collision = false\n            local car_1_x = CARS[i].x\n      \
    \      local car_1_y = CARS[i].y\n            local car_2_x = CARS[j].x\n    \
    \        local car_2_y = CARS[j].y\n            local dist_1_x = car_2_x - car_1_x\n\
    \            local dist_1_y = car_2_y - car_1_y\n            if dist_1_x ~= 0\
    \ or dist_1_y ~= 0 then\n               -- We have to check for both horizontal\
    \ and vertical collisions.\n               collision = true\n               if\
    \ dist_1_x < dist_1_y then\n                  -- If car_1 has moved left of car_2,\
    \ it could potentially collide with car_2.\n                  -- This code checks\
    \ for that.\n                  if dist_1_x > 0 then\n                    -- Car_1\
    \ has moved left, and car_2 has moved right. Collision!\n                    \
    \ collision = true\n                  end\n               else\n             \
    \     -- If car_1 has moved up of car_2, it could potentially collide with car_2.\n\
    \                  -- This code checks for that.\n                  if dist_1_y\
    \ > 0 then\n                     -- Car_1 has moved up, and car_2 has moved down.\
    \ Collision!\n                     collision = true\n                  end\n \
    \              end\n               -- Check for collision with all other cars.\n\
    \               for k = 1, n do\n                  if (k ~= j) then\n        \
    \             collision = collision or car_race_collision(k)\n               \
    \   end\n               end\n            end\n            if collision then\n\
    \               -- This car is colliding, increment collision count.\n       \
    \        result = result + 1\n            end\n         end\n      end\n   end\n\
    \   return result\nend", "  -- Base case\n  if n == 1 then\n    return 0\n  end\n\
    \  -- If there are 2 or more cars in the same direction, then they will collide.\n\
    \  if n > 1 then\n    -- Find a vector pointing in the direction of the 1st car,\
    \ and\n    -- another vector pointing in the direction of the 2nd car.\n    local\
    \ v1 = get_random_direction(true)\n    local v2 = get_random_direction(true)\n\
    \    -- Calculate where they should move to.\n    local next_pos = v1 + v2\n \
    \   -- Do the movement of the cars.\n    for i=1,n do\n      -- Move the 1st car\
    \ to the new position.\n      v1 = v1 + next_pos\n      -- Move the 2nd car to\
    \ the new position.\n      v2 = v2 - next_pos\n      -- Collision happens if the\
    \ cars overlap by more than half the width.\n      if v1 + v2 < 0 then\n     \
    \   return 1\n      end\n      -- Set the new position for the 2nd car.\n    \
    \  next_pos = v1 + v2\n    end\n    -- If the cars don't overlap, return 0.\n\
    \    return 0\n  end\n  return 0\nend", "  -- The distance between two cars is\
    \ given by the absolute value of their velocities.\n  -- (A car is said to collide\
    \ with itself a collision if its velocity is both zero and\n  -- its right angle\
    \ is greater than 180 degrees.)\n  local collision_sum = 0\n  for i = 1, n do\n\
    \    local right_angle = math.rad(i * 2 * math.pi / n)\n    local left_angle =\
    \ math.rad(i * 2 * math.pi / n - math.pi / 2)\n    local abs_right = abs(math.rad(i\
    \ * 2 * math.pi / n) - right_angle)\n    local abs_left = abs(math.rad(i * 2 *\
    \ math.pi / n - math.pi / 2) - left_angle)\n    if abs_right > 180 then\n    \
    \  collision_sum = collision_sum + 1\n    end\n    if abs_left > 180 then\n  \
    \    collision_sum = collision_sum + 1\n    end\n  end\n  return collision_sum\n\
    end", "   for i = 1, n do\n      for j = i + 1, n do\n         if car_collision(i,\
    \ j) then\n            return true\n         end\n      end\n   end\n   return\
    \ false\nend", "   local collided = 0\n   for i = 1, n do\n      for j = 1, n\
    \ do\n         if i != j then\n            local left_car = i\n            local\
    \ right_car = j\n            local left_speed = right_speed = 1\n            local\
    \ left_pos = left_car_pos = right_car_pos = 0\n            local left_time = left_car_time\
    \ = right_car_time = 0\n            local left_distance = right_distance = 20\n\
    \            local left_time = left_time = left_distance\n            local right_time\
    \ = right_time = right_distance\n            local left_distance_to_left = left_distance\n\
    \            local right_distance_to_left = right_distance\n            local\
    \ left_distance_to_right = left_distance\n            local right_distance_to_right\
    \ = right_distance", "  -- If n is a power of two, then we know that the input\
    \ is a power of two.\n  -- We need only check if n was originally a power of two.\n\
    \  if (n and log2(base2.log2(n))) ~= n then\n    return nil\n  end\n  -- We initialize\
    \ an 's' array with the first n slots filled with 'nil'.\n  local s = table.fill(true,\
    \ n, nil)\n  -- We initialize a 'c' array with n slots with 'nil'.\n  local c\
    \ = table.fill(true, n, nil)\n  -- We initialize a 'collided' array to 'nil'.\n\
    \  local collided = nil\n  -- We'll use an \"i index\" to iterate over the 's'\
    \ table.\n  local i = 1\n  -- The 'collided' array will hold whether a car in\
    \ slot i collides with a car in slot i.\n  local collided\n  -- While there are\
    \ cars still to move left to right...\n  while i ~= n do\n    -- We reset the\
    \ collided array at the start of each round.\n    -- It will be reset to nil after\
    \ the first round.\n    collided = nil\n    -- We move the 'collided' array from\
    \ slot i to slot i + 1.\n    -- It contains whether a car in slot i collides with\
    \ a car in slot i.\n    for j = 1, i do\n      collided = {collided, c[j]}\n \
    \   end\n    -- We increment the 'i' index.\n    i = i + 1\n    -- If the 'collided'\
    \ array has a non-nil value in slot i, then that slot c[i]\n    -- is a collision.\n\
    \    if (collided and collided[i]) then\n      -- We increment 'collided' array\
    \ slot i to nil.\n      collided[i] = nil\n      -- We increment 'c' array slot\
    \ i to nil.\n      c[i] = nil\n      -- We subtract 1 from 'n' to move 'n' cars\
    \ back left until a collision occurs\n      -- or we move 'n' cars back right\
    \ until a collision occurs.\n      if n ~= 1 then\n        -- While there are\
    \ cars still to move left to right...\n        while n ~= 1 do\n          -- We\
    \ decrement 'n'.\n          n = n - 1\n          -- We move 'c' array slot i to\
    \ slot i + 1.\n          c[i + 1] = c[i]\n          -- If 'collided' array slot\
    \ i has a non-nil value in slot i, then that slot c[i]\n          -- is a collision.\n\
    \          if (collided and collided", '    local collisions = 0', "  local car_race_collisions\
    \ = 0\n  local car_collisions = 0\n  local car_collision_times = {}\n  local car_collision_speeds\
    \ = {}\n  for i = 1, n do\n    -- A car's velocity at collision time t is\n  \
    \  --  (car_collision_speeds[t] + car_collision_speeds[t - 1]) / 2 * t\n    --\
    \  or car_collision_speeds[t] / 2 * t\n    local collision_time = car_collision_times[i\
    \ - 1]\n    if car_collision_times[i - 1] == 0 then\n      -- At time 0, no cars\
    \ collided.\n      collision_speed = 0\n    else\n      -- At time t, car_collision_speeds[t]\
    \ is the speed of the car at time t\n      -- and car_collision_speeds[t - 1]\
    \ is the speed of the car at time t - 1\n      collision_speed = (car_collision_speeds[i\
    \ - 1] + car_collision_speeds[i - 1]) / 2 * i\n    end\n    if collision_speed\
    \ == 0 then\n      -- The car has reached a stationary point.\n      -- We should\
    \ just continue on with the same speed until it comes to a stop.\n      car_collision_speeds[i\
    \ - 1] = 0\n    else\n      -- We have a speed at collision time t.\n      --\
    \ We need to find the time at which the speed reaches 0 as fast as possible.\n\
    \      -- To do this, we simply look at all the cars whose speed is above zero.\n\
    \      -- If we can do this, then the collision time is simply the time at which\
    \ we find\n      -- the car whose speed is above zero.\n      local collision_time\
    \ = collision_speed - car_collision_speeds[i - 1]\n      -- We also need to keep\
    \ track of the speed at collision time 0, which is 0.\n      -- That will allow\
    \ us to find the collision speed at collision time t.\n      local collision_speed\
    \ = 0\n      for j = 1, n do\n        if car_collision_speeds[j - 1] > 0 then\n\
    \          -- We found a car whose speed is above zero.\n          -- We should\
    \ continue the trajectory from that car until we reach a stop.\n          local\
    \ collision_speed = (car_collision_speeds[j - 1] + car_collision_speeds[j - 1])\
    \ / 2 * j\n          break\n        end\n      end\n    end\n    -- Now that we\
    \ have the speed at collision time t, we can simply use it to calculate\n    --\
    \ where the next collision will be.\n    -- This collision will be made at the\
    \ speed at collision time t or faster,\n    -- and the collision time will be\
    \ t - 1.", "  local count = 1\n  for i = 1, n do\n    -- The race continues until\
    \ we encounter a collision between the rightmost car\n    -- and the first car.\n\
    \    while true do\n      local rightmost_car = max_index(vector_direction_right(n))\n\
    \      if rightmost_car == 1 then\n        return count\n      end", "   -- Initialize\
    \ collision count\n   local collisions = 0\n   for i = 1, n do\n      for j =\
    \ 1, n do\n         if i == j then\n            continue\n         end\n     \
    \    -- If we are not at the right spot for the second car\n         if car_is_right_spot(i,\
    \ j) then\n            -- If we are not at an intersection\n            if not\
    \ car_intersect(i, j) then\n               -- Increment collision count\n    \
    \           collisions = collisions + 1\n               break\n            end\n\
    \         end\n      end\n   end\n   -- Return collision count\n   return collisions\n\
    end", "  local num_collisions = 0\n  for _=1,n do\n    for i = 1,n do\n      local\
    \ j = 1\n      local x_left = cars_x_left[i]\n      local x_right = cars_x_right[i]\n\
    \      local y_left = cars_y_left[i]\n      local y_right = cars_y_right[i]\n\
    \      while j<=n do\n        -- Check for collision between a car that started\
    \ on the left and one that\n        -- started on the right.\n        local xx_left\
    \ = cars_x[j-1]\n        local yy_left = cars_y[j-1]\n        local xx_right =\
    \ cars_x[j]\n        local yy_right = cars_y[j]\n        if xx_left==x_left and\
    \ yy_left==y_left and\n           xx_right==x_right and yy_right==y_right then\n\
    \          -- Collision between a cars that started in the left and right directions\n\
    \          -- -- This will be a collision only if the speed of the car is different\n\
    \          -- -- because the cars collide\n          local speed = (math.abs((xx_left\
    \ - xx_right)/(x_left - x_right))*\n                         (math.abs((y_left\
    \ - yy_right)/(y_left - y_right))+\n                          math.abs((y_right\
    \ - yy_left)/(y_right - y_left))+\n                          math.abs((xx_left\
    \ - xx_right)/(\n                              (x_left - x_right)/(xx_left - xx_right)))))\n\
    \          if speed > max_speed then\n            num_collisions = num_collisions\
    \ + 1\n          end\n          break\n        end\n        j = j + 1\n      end\n\
    \    end\n  end\n  return num_collisions\nend", "    local count = 0\n    local\
    \ x0 = math.random(100, 350)\n    local y0 = math.random(100, 350)\n    for i=1,n\
    \ do\n        local x = x0 + math.cos((i-1)*2*math.pi)/n\n        local y = y0\
    \ + math.sin((i-1)*2*math.pi)/n\n        if car_collision_test(x, y, x0-10, y0-10)\
    \ then\n            count = count+1\n        end\n    end\n    return count\n\
    end", "   -- Initialize the collision counter as an array of integers.\n   --\
    \ Initialize each collision counter element to zero.\n   local collision_counter\
    \ = {}\n   for i=1, n do\n      collision_counter[i] = 0\n   end", "   -- First,\
    \ find the distance between the two cars.\n   local distance = 0\n   for j = 0,\
    \ n - 1 do\n      distance = distance + cars[j].x - cars[j + 1].x\n   end", '  local
    collisions = 0', "  -- If there are no more cars left to collide with, we're done.\n\
    \  if n <= 0 then\n    return 0\n  end\n  -- Otherwise, we will count the collisions.\n\
    \  local collisions = 0\n  local max_collisions = math.floor((n-1) * math.sqrt(2/n))\n\
    \  local x0 = math.random(1, max_collisions)\n  local y1 = math.random(1, max_collisions)\n\
    \  local x2 = math.random(1, max_collisions)\n  local y2 = math.random(1, max_collisions)\n\
    \  -- Count the number of collisions while moving right to left.\n  local collide_right\
    \ = False\n  local collide_left  = False\n  while x0 > x1 or y0 > y2 do\n    --\
    \ Pick a random car that's colliding with the one we're moving left.\n    if collide_left\
    \ then\n      local x3 = math.random(1, max_collisions)\n      local y3 = math.random(1,\
    \ max_collisions)\n      -- Check that the two cars collide.\n      if ((x0 >\
    \ x3) or (y0 > y3)) then\n        -- Pick a random car to collide with the one\
    \ we're moving right.\n        local x4 = math.random(1, max_collisions)\n   \
    \     local y4 = math.random(1, max_collisions)\n        -- Check that the two\
    \ cars collide.\n        if ((x0 > x4) or (y0 > y4)) then\n          -- No collisions.\n\
    \          break\n        else\n          -- Reset the collision counter.\n  \
    \        collisions = 0\n          -- Move the colliding car to the same location\
    \ as the other car.\n          x0, y0, x1, y1, x2, y2 = x3, y3, x3, y3, x4, y4\n\
    \          -- We've found a collision.\n          collide_right  = true\n    \
    \      collide_left   = true\n        end\n      else\n        -- No collisions.\n\
    \        break\n      end\n    else\n      -- No collisions.\n      break\n  \
    \  end\n  end\n  -- Count the number of collisions while moving left to right.\n\
    \  collide_right  = false\n  collide_left   = false\n  while x0 < x1 or y0 < y2\
    \ do\n    -- Pick a random car that's colliding with the one we're moving right.\n\
    \    if collide_right then\n      local x3 = math.random(1, max_collisions)\n\
    \      local y3 = math.random(1, max_collisions)\n      -- Check that the two\
    \ cars collide.\n      if ((x0 < x3) or (y0 < y3)) then\n        -- Pick a random\
    \ car to collide with the one we're moving left.\n        local x4 = math.random(1, ",
  "    local collided = 0\n    local collide_i = 0\n    local collide_j = 1\n    local\
    \ max_i = n\n    local max_j = 1\n    local i = 1\n    local j = 1\n    -- If\
    \ there are not exactly n cars in the line, there are not enough cars in the\n\
    \    -- line to collide.\n    if n == 1 then\n        return 0\n    end\n    while\
    \ i <= max_i do\n        local car_i = i - 1\n        local car_j = i\n      \
    \  while j <= max_j do\n            local car_j = j - 1\n            local car_i_x\
    \ = car_i - car_j\n            local car_i_y = car_j - car_i\n            local\
    \ car_j_x = i - car_j\n            local car_j_y = j - car_i\n            local\
    \ distance = (car_i_x * car_i_x) + (car_i_y * car_i_y) + (car_j_x * car_j_x) +\
    \ (car_j_y * car_j_y)\n            if distance <= 1 then\n                local\
    \ i_collided = i_collided + 1\n                if car_j == car_i then\n      \
    \              -- Cars in the same line can never collide because they will always\n\
    \                    -- hit each other at the center of the line.\n          \
    \          collided = collided + 1\n                else\n                   \
    \ -- If the cars don't collide, they will collide when they meet.\n          \
    \          --\n                    -- Imagine a road that's a perfectly straight\
    \ infinitely long line.\n                    -- n cars are driving left to right;\
    \  simultaneously, a different set of n cars\n                    -- are driving\
    \ right to left.   The two sets of cars start out being very far from\n      \
    \              -- each other.  All cars move in the same speed.  Two cars are\
    \ said to collide\n                    -- when a car that's moving left to right\
    \ hits a car that's moving right to left.\n                    -- However, the\
    \ cars are infinitely sturdy and strong; as a result, they continue moving\n \
    \                   -- in their trajectory as if they did not collide.\n     \
    \               --\n                    -- This function outputs the number of\
    \ such collisions.\n                    --\n                    collided = collided\
    \ + ((car_i_y < car_j_y) * car_i_y + (car_i_y > car_j_y) * car_j_y + (car_i_x\
    \ < car_j_x) * car_i_x + (car_i_x > car_j_x) * car_j_x)\n                end\n\
    \            end\n            j = j + 1\n        end\n        i = i + 1\n    end\n\
    \    return collided\nend", "\tlocal collisions = 0\n\tlocal n = n or 1\n\tfor\
    \ i = 1, n do\n\t\tlocal c1 = math.random(1, n)\n\t\tlocal c2 = math.random(1,\
    \ n)\n\t\tlocal collides = false\n\t\tif c1 >= c2 then\n\t\t\tcollides = true\n\
    \t\telseif c1 < c2 then\n\t\t\tfor j = c1, c2 do\n\t\t\t\tif car_collision(i,\
    \ j) then\n\t\t\t\t\tcollides = true\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\t\
    for j = c2, c1 do\n\t\t\t\tif car_collision(i, j) then\n\t\t\t\t\tcollides = true\n\
    \t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif not collides then\n\t\t\tcollisions =\
    \ collisions + 1\n\t\tend\n\tend\n\treturn collisions\nend", "   local collisions\
    \ = 0\n   for i = 1, n do\n      for j = 1, n do\n         if i >= j then\n  \
    \          local left_speed = left_car_speed(i)\n            local right_speed\
    \ = right_car_speed(j)\n            local speed = car_speed(i)\n            if\
    \ left_speed ~= right_speed then\n               local delta_speed = left_speed\
    \ - right_speed\n               if abs(delta_speed) < race_speed then\n      \
    \            collisions = collisions + 1\n               end\n            end\n\
    \         end\n      end\n   end\n   return collisions\nend", "  local count =\
    \ 0\n  -- Simulate n cars moving left to right\n  local start = os.clock()\n \
    \ for i = 1, n do\n    local v = vector(-math.random() * 2, math.random() * 2)\n\
    \    local dx = math.random() * 50\n    local dy = math.random() * 50\n    v:add(vector(-dx,\
    \ -dy))\n    local r = vector(0, math.random())\n    while r:length() > 0 do\n\
    \      r:normalize()\n      r:mul(math.sqrt(1 + math.random()))\n    end\n   \
    \ local t1 = os.clock()\n    local r, v = race(v)\n    local t2 = os.clock()\n\
    \    if t2 - t1 < 0.2 then\n      break\n    end\n  end\n  count = count + 1\n\
    \  -- Simulate n cars moving right to left\n  start = os.clock()\n  for i = 1,\
    \ n do\n    local v = vector(-math.random() * 2, math.random() * 2)\n    local\
    \ dx = math.random() * 50\n    local dy = math.random() * 50\n    v:add(vector(-dx,\
    \ -dy))\n    local r = vector(0, math.random())\n    while r:length() > 0 do\n\
    \      r:normalize()\n      r:mul(math.sqrt(1 + math.random()))\n    end\n   \
    \ local t1 = os.clock()\n    local r, v = race(v)\n    local t2 = os.clock()\n\
    \    if t2 - t1 < 0.2 then\n      break\n    end\n  end\n  count = count + 1\n\
    \  -- Simulate n cars moving left to right and right to left.\n  -- We need to\
    \ make sure that the cars don't collide with themselves.\n  start = os.clock()\n\
    \  for i = 1, n do\n    local v = vector(-math.random() * 2, math.random() * 2)\n\
    \    local dx = math.random() * 50\n    local dy = math.random() * 50\n    v:add(vector(-dx,\
    \ -dy))\n    local r = vector(0, math.random())\n    while r:length() > 0 do\n\
    \      r:normalize()\n      r:mul(math.sqrt(1 + math.random()))\n    end\n   \
    \ local t1 = os.clock()\n    local r, v = race(v)\n    local t2 = os.clock()\n\
    \    if t2 - t1 < 0.2 then\n      break\n    end\n  end\n  count = count + 1\n\
    \  -- Simulate n cars moving right to left and left to right\n  start = os.clock()\n\
    \  for i = 1, n do\n    local v = vector(-math.random() * 2, math.random() * 2)\n\
    \    local dx = math.random() * 50\n    local dy = math.random() * 50\n    v:add(vector(-dx,\
    \ -dy))\n    local r = ", "    local collisions = 0\n    local car_race_x = torch.range(1,\
    \ n+1)\n    local car_race_y = torch.range(1, n+1)\n    local collision_x = torch.zeros(1,\
    \ n+1)\n    local collision_y = torch.zeros(1, n+1)\n    for i = 1, n do\n   \
    \     -- Collision with previous cars\n        if i - 1 ~= 1 then\n          \
    \  for j = 1, n do\n                if collision_y[j] == 1 then\n            \
    \        collision_y[j] = collision_x[j] * 2\n                    collisions =\
    \ 1\n                end\n            end\n        end\n        -- Collision with\
    \ current cars\n        if i ~= 1 then\n            for j = 1, n do\n        \
    \        if collision_x[j] == 1 then\n                    collision_x[j] = collision_y[j]\
    \ * 2\n                    collisions = 1\n                end\n            end\n\
    \        end\n        -- Collision with next cars\n        if i + 1 ~= n then\n\
    \            for j = 1, n do\n                if collision_x[j] == 1 then\n  \
    \                  collision_x[j] = collision_y[j] * 2\n                    collisions\
    \ = 1\n                end\n            end\n        end\n    end\n    return\
    \ collisions\nend", "  local collided = 0\n  local n\n  local car_x, car_y\n \
    \ local next_car_x, next_car_y\n  local speed\n  -- n > 0\n  while n > 0 do\n\
    \    speed = speed * speed\n    -- n is even\n    local i\n    for i = 2, n do\n\
    \      -- i is even\n      speed = speed * speed\n      -- n is odd\n      local\
    \ j\n      for j = 1, n do\n        -- j is odd\n        local collision_x = car_x\
    \ + speed * ((i - 1) / (n - 1))\n        local collision_y = car_y + speed * (j\
    \ / n)\n        if collision_x > next_car_x then\n          collided = collided\
    \ + 1\n        elseif collision_x < next_car_x then\n          collided = collided\
    \ + 1\n        elseif collision_y > next_car_y then\n          collided = collided\
    \ + 1\n        elseif collision_y < next_car_y then\n          collided = collided\
    \ + 1\n        end\n      end\n    end\n    -- n is odd\n    local k\n    for\
    \ k = 1, n do\n      -- k is odd\n      speed = speed * speed\n      -- n is even\n\
    \      local j\n      for j = 1, n do\n        -- j is even\n        local collision_x\
    \ = car_x + speed * (k / (n - 1))\n        local collision_y = car_y + speed *\
    \ (j / n)\n        if collision_x > next_car_x then\n          collided = collided\
    \ + 1\n        elseif collision_x < next_car_x then\n          collided = collided\
    \ + 1\n        elseif collision_y > next_car_y then\n          collided = collided\
    \ + 1\n        elseif collision_y < next_car_y then\n          collided = collided\
    \ + 1\n        end\n      end\n    end\n    -- n is even\n    local i\n    for\
    \ i = 2, n do\n      -- i is even\n      speed = speed * speed\n      -- n is\
    \ odd\n      local j\n      for j = 1, n do\n        -- j is odd\n        local\
    \ collision_x = car_x + speed * ((i + 1) / (n - 1))\n        local collision_y\
    \ = car_y + speed * (j / n)\n        if collision_x > next_car_x then\n      \
    \    collided = collided + 1\n        elseif collision_x < next_car_x then\n \
    \         collided = collided + 1\n        elseif collision_y > next_car_y then\n\
    \          collided = collided + 1\n        elseif collision_y < next_car", " \
    \   local car1 = random_car()\n    local car2 = random_car()\n    local car3 =\
    \ random_car()\n    local car4 = random_car()\n    local car5 = random_car()\n\
    \    local car6 = random_car()\n    local car7 = random_car()\n    local car8\
    \ = random_car()\n    local car9 = random_car()\n    local car10 = random_car()\n\
    \    local car11 = random_car()\n    local car12 = random_car()\n    local car13\
    \ = random_car()\n    local car14 = random_car()\n    local car15 = random_car()\n\
    \    local car16 = random_car()\n    local car17 = random_car()\n    local car18\
    \ = random_car()\n    local car19 = random_car()\n    local car20 = random_car()",
  '   if n <= 1 then return 1 end', "  local collisions = 0\n  for i = 1, n do\n \
    \   for j = i + 1, n do\n      local collision_vect = vector_add(vehicle_state.position,\
    \ car_speed)\n      local intersection_vect = vector_subtract(vehicle_state.position,\
    \ car_speed)\n      local dist = vector_length(intersection_vect)\n      if dist\
    \ < collision_vect_threshold then\n        collisions = collisions + 1\n     \
    \   break\n      end\n    end\n  end\n  return collisions\nend", '   local num_collisions
    = 0', "    -- The line between the two centers contains n straight lines (not\
    \ counting the diagonal)\n    local line = Line()\n    line.origin = Vector3(0,0,0)\n\
    \    line.destination = Vector3(0,0,0)", "  -- Calculate the acceleration vector\
    \ of the first car.\n  local acceleration_vector = car_speed_vector(1)", "   --\
    \ the number of collisions.\n   local count = 0\n   -- one car has moved left\
    \ to right.\n   local leftright = true\n   -- one car has moved right to left.\n\
    \   local rightleft = false", "  local i = 1\n  local count = 0\n  repeat\n  \
    \  local left_car = i - n % 2\n    local right_car = i + 1 % 2\n    local left_line\
    \ = road_line[left_car]\n    local right_line = road_line[right_car]\n    local\
    \ left_speed = road_speed[left_car]\n    local right_speed = road_speed[right_car]\n\
    \    local collision_speed\n    -- if they have the same speed (which they shouldn't)\
    \ they never collide.\n    if left_speed == right_speed then\n      collision_speed\
    \ = 0\n    else\n      collision_speed = right_speed - left_speed\n    end\n \
    \   -- collision happens if they have different speeds.\n    if collision_speed\
    \ > 0 then\n      count = count + 1\n    end\n    i = i + 1\n  until i < n\n \
    \ return count\nend", "   -- If we're already at a collision, we're done.\n  \
    \ if n <= 0 then\n      return 0\n   end", "   -- The cars can collide with each\
    \ other if they are moving right to left in the same speed and opposite.\n   --\
    \ So we'll need to compute collision distances between each pair of cars going\
    \ left to right.\n   -- We'll use the same collision distance formula as we did\
    \ in the previous lesson\n   -- (http://cslibrary.stanford.edu/110/intersection.html)",
  "  local collisions = 0\n  -- A set of cars being racing with each other in a straight\
    \ line.\n  for i = 1, n do\n    local xa = i * math.cos(math.rad(math.pi/n))\n\
    \    local ya = i * math.sin(math.rad(math.pi/n))\n    local xb = xa + math.cos(math.rad(math.pi/n))\n\
    \    local yb = ya + math.sin(math.rad(math.pi/n))\n    local xc = xb - math.cos(math.rad(math.pi/n))\n\
    \    local yc = yb - math.sin(math.rad(math.pi/n))\n    local xd = -xa + math.cos(math.rad(math.pi/n))\n\
    \    local yd = -ya + math.sin(math.rad(math.pi/n))\n    local xe = xd - math.cos(math.rad(math.pi/n))\n\
    \    local ye = yd - math.sin(math.rad(math.pi/n))\n    local x1 = xa + math.cos(math.rad(math.pi/n))\n\
    \    local y1 = ya + math.sin(math.rad(math.pi/n))\n    local x2 = xb - math.cos(math.rad(math.pi/n))\n\
    \    local y2 = yb - math.sin(math.rad(math.pi/n))\n    local x3 = xd - math.cos(math.rad(math.pi/n))\n\
    \    local y3 = yd - math.sin(math.rad(math.pi/n))\n    local x4 = xe + math.cos(math.rad(math.pi/n))\n\
    \    local y4 = ye + math.sin(math.rad(math.pi/n))\n    local x5 = xc - math.cos(math.rad(math.pi/n))\n\
    \    local y5 = yc - math.sin(math.rad(math.pi/n))\n    local x6 = xb + math.cos(math.rad(math.pi/n))\n\
    \    local y6 = yb + math.sin(math.rad(math.pi/n))\n    local x7 = xd + math.cos(math.rad(math.pi/n))\n\
    \    local y7 = yd + math.sin(math.rad(math.pi/n))\n    local x8 = xe - math.cos(math.rad(math.pi/n))\n\
    \    local y8 = ye - math.sin(math.rad(math.pi/n))\n    local x9 = xc - math.cos(math.rad(math.pi/n))\n\
    \    local y9 = yc - math.sin(math.rad(math.pi/n))\n    local x10 = xb + math.cos(math.rad(math.pi/n))\n\
    \    local y10 = yb + math.sin(math.rad(math.pi/n))\n    local x11 = xd + math.cos(math.rad(math.pi/n))\n\
    \    local y11 = yd + math.sin(math.rad(math.pi/n))\n    local x12 = xe + math.cos(math.rad(math.pi/n))\n",
  "  local count = 0\n  -- This loop takes forever; but we could do better by adding\
    \ up the distances\n  -- for each car against every other car and then comparing\
    \ the distances,\n  -- and returning the minimum distance for each collision.\n\
    \  for i=1, n do\n    local car_race_distance = i\n    -- This loop takes forever;\
    \ but we could do better by adding up the distances\n    -- for each car against\
    \ every other car and then comparing the distances,\n    -- and returning the\
    \ minimum distance for each collision.\n    for j=1, n do\n      if i == j then\n\
    \        -- If the cars are the same car, don't count it as a collision.\n   \
    \     continue\n      end\n      local car_race_collision_distance = i - j\n \
    \     -- If the cars don't collide, add up their distance and compare it\n   \
    \   -- to every other car.\n      if car_race_collision_distance < car_race_distance\
    \ then\n        car_race_distance = car_race_collision_distance\n      end\n \
    \   end\n    -- If the cars don't collide, add up their distance and compare it\n\
    \    -- to every other car.\n    if car_race_distance > 0 then\n      count =\
    \ count + 1\n    end\n  end\n  return count\nend", "  local count = 0\n  local\
    \ max_x = math.random(0.0, 2.0 * math.pi)\n  local min_x = math.random(math.pi\
    \ - math.pi * .1, math.pi)\n  for _, _, _, _, _ in pairs(cars) do\n    -- Only\
    \ collide with a car that hasn't already moved past this point\n    local x_dist\
    \ = car.x - car.xPrev\n    if x_dist >= min_x then\n      -- Only collide with\
    \ cars that have collided previously\n      if car.collided then\n        if car.collided\
    \ == true then\n          -- Only collide with cars that have been previously\
    \ collided\n          -- (the way we detect collisions)\n          local next_x\
    \ = math.random(0.0, 2.0 * math.pi)\n          local next_x_dist = car.x + car.speed\n\
    \          if x_dist < next_x_dist then\n            count = count + 1\n     \
    \       -- Only collide with cars that are close enough (within 1 radian)\n  \
    \          local collide_speed = car.collideSpeed\n            if math.abs(x_dist\
    \ - next_x_dist) < collide_speed then\n              car.collided = false\n  \
    \            if car.collided_again == false then\n                car.collided_again\
    \ = true\n              end\n            end\n          end\n        else\n  \
    \        -- Collide with cars that haven't collided yet\n          car.collided\
    \ = true\n        end\n      else\n        -- Collide with cars that have not\
    \ collided yet\n        car.collided = true\n        car.collided_again = false\n\
    \      end\n      car.xPrev = car.x\n    end\n  end\n  return count\nend", " \
    \   local colls = 0\n    for i = 1, n do\n        for j = 1, n do\n          \
    \  if j == i then\n                colls = colls+1\n            end\n        end\n\
    \    end\n    return colls\nend", "  -- Base case: There are no collisions because\
    \ n is 0 or 1.\n  if n == 0 or n == 1 then\n    return 0\n  end", "  local count\
    \ = 0\n  local last_collision = 0\n  local last_time = 0", "   local count_cars\
    \ = 0\n   for i=1,n do\n      for j=i+1,n do\n         if car_racing_collision(j,i)\
    \ == true then\n            count_cars = count_cars + 1\n         end\n      end\n\
    \   end\n   return count_cars\nend", "  local collision = 0\n  for i = 1, n do\n\
    \    local car1 = i\n    local collision = collision + find_collision(i, n - 1,\
    \ car_race_car)\n  end\n  return collision\nend", "    assert(n > 0)\n    local\
    \ collisions = 0\n    for i=1,n do\n        for j=1,n do\n            local race_car_1\
    \ = i\n            local race_car_2 = j\n            local race_car_3 = j+1\n\
    \            local race_car_4 = i+1\n            if race_car_1 ~= race_car_2 then\n\
    \                if race_car_1 ~= race_car_3 then\n                    if race_car_1\
    \ ~= race_car_4 then\n                        if race_car_2 ~= race_car_3 then\n\
    \                            if race_car_2 ~= race_car_4 then\n              \
    \                  collisions = collisions + 1\n                            end\n\
    \                        end\n                    end\n                end\n \
    \           end\n        end\n    end\n    return collisions\nend", "   local\
    \ collisions = 0\n   local x\n   local y\n   local speed\n   local speed2", " \
    \ -- The set of all possible combinations of race cars that collide with each\
    \ other.\n  -- It is a string that looks like\n  --    (car 1 hitting car 2) or\n\
    \  --    (car 2 hitting car 1) or\n  --    (car 1 hitting car 1)\n  --  or just\
    \ a single (car 1 hitting car 1).\n  --\n  --  We want to\n  --  1) Scan the entire\
    \ list of possible collisions once\n  --  2) For each collision, check whether\
    \ it involves one of the race cars\n  --  3) If it involves one of the race cars,\
    \ we add the collision to the list.\n  --\n  -- The naive implementation (below)\
    \ does not work; it has a time complexity of\n  -- O(n!), and so runs very slowly.\
    \  However, we can improve the time complexity\n  -- substantially by taking advantage\
    \ of the fact that car_collision returns\n  -- the number of race cars that collide.\n\
    \  local collisions = 0\n  for i = 1, n do\n    local hit = false\n    for j =\
    \ 1, n do\n      if car_collision(i, j) then\n        hit = true\n        break\n\
    \      end\n    end\n    if hit then\n      collisions = collisions + 1\n    end\n\
    \  end\n  return collisions\nend", "   local collisions = 0\n   for i=1, n do\n\
    \      local j = (i-1) % n\n      if car_race_collision(j, i-1) then\n       \
    \  collisions = collisions + 1\n      end\n   end\n   return collisions\nend",
  "  local collide = 0\n  local collisions = 0\n  local c\n  repeat\n    -- Move the\
    \ cars until they collide\n    local move = c", "    --[[\n    Calculate the total\
    \ movement speed, and if the two cars are colliding.\n    Assumes no penetration.\n\
    \    --]]\n    local total_speed = math.abs(car_speed_left(n))\n    local collided\
    \ = 0\n    for i = 1, n do\n        if car_speed_right(i) < total_speed and car_speed_left(i)\
    \ > total_speed then\n            collided = collided + 1\n        end\n    end\n\
    \    return collided\nend", "   local collisions = 0\n   for i = 1, n do\n   \
    \   for j = i + 1, n do\n         -- Find angle between cars (in radians)\n  \
    \       local a1, b1, c1 = math.rad(cars[i].x), math.rad(cars[i].y), math.rad(cars[i].speed)\n\
    \         local a2, b2, c2 = math.rad(cars[j].x), math.rad(cars[j].y), math.rad(cars[j].speed)\n\
    \         local d1, d2 = a1 - a2, b1 - b2\n         -- Calculate distance between\
    \ cars (in inches)\n         local d1 = math.floor(d1 * 165)\n         local d2\
    \ = math.floor(d2 * 165)\n         -- Calculate angle between cars (in degrees)\n\
    \         local angle1 = math.atan2(d1, d2)\n         local angle2 = math.atan2(-d1,\
    \ d2)\n         -- Calculate angle between centers (in degrees)\n         local\
    \ angle3 = math.atan2(b1 - cars[i].x, a1 - cars[i].y)\n         local angle4 =\
    \ math.atan2(b2 - cars[j].x, a2 - cars[j].y)\n         -- If both cars are moving\
    \ in the same direction, then they will collide\n         if (angle1 == angle2)\
    \ then\n            -- The distance between the centers\n            local dist\
    \ = (b1 - b2) * math.cos((angle1 + angle2) * math.pi / 180)\n            -- Calculate\
    \ the distance between the centers\n            local dist = dist / math.sqrt((b1\
    \ - b2)^2 + (a1 - a2)^2)\n            -- If the distance is smaller than the distance\
    \ between centers, then\n            -- they will collide\n            if dist\
    \ < dist then\n               -- If they collide in the same direction, then we\
    \ consider the\n               -- collision occurring.\n               if angle3\
    \ == angle4 then\n                  collisions = collisions + 1\n            \
    \   else\n                  collisions = collisions\n               end\n    \
    \        end\n         end\n      end\n   end\n   return collisions\nend", " \
    \ -- The idea is to start off by assuming that every pair of cars collides.\n\
    \  -- Then, we simulate *every* possible trajectory and count the number of\n\
    \  -- collisions.  We are guaranteed that no car will ever collide with itself\n\
    \  -- (unless it moves right to left).\n  -- The function argument represents\
    \ the number of steps to simulate.\n  -- The function argument can also be an\
    \ optional argument whose default value\n  -- can be set to 0.", "   -- n is the\
    \ number of cars in the first set\n   -- x is the current speed of one car\n \
    \  -- y is the speed of the other car\n   -- n is even\n   local x\n   local y\n\
    \   if n % 2 ~= 0 then\n      return nil\n   end\n   local i = 1\n   -- The two\
    \ cars are initially going left at same speed\n   x = n / 2\n   y = n / 2\n  \
    \ -- Iterate until both cars have reached same speed\n   while x <= y do\n   \
    \   -- Assume that they will not collide at the very beginning\n      local collide\
    \ = false\n      -- Iterate until one car has reached same speed as the other\
    \ one\n      while not collide do\n         -- Assume that one car will collide\
    \ at the very beginning\n         collide = true\n         -- Iterate until one\
    \ car has reached same speed as the other one\n         while collide do\n   \
    \         -- Move the other car right in same speed as this one\n            local\
    \ d = x - y\n            y = y + (d * d) -- The distance between this car and\
    \ the other\n            -- If the other car has hit this one, it is said to collide\n\
    \            if y <= 0 then\n               collide = false\n            end\n\
    \         end\n         x = x + (n * x) -- Move the other car in same speed as\
    \ this one\n         -- If the other car has hit this one, it is said to collide\n\
    \         if x <= 0 then\n            collide = false\n         end\n      end\n\
    \      x = x + (n * x) -- Move the other car in same speed as this one\n     \
    \ -- If the other car has hit this one, it is said to collide\n      if x <= 0\
    \ then\n         collide = false\n      end\n      -- The two cars are now going\
    \ right with same speed\n      y = n / 2\n   end\n   return i\nend", '    local
    collisions = 0', "  -- Initialize variables\n  local x = 0\n  local y = 0\n  local\
    \ speed = 0\n  local speed2 = 0\n  local collided = false\n  local collisions\
    \ = 0\n  local total = 0\n  local i = 0\n  local j = 0\n  local lastCar = null\n\
    \  local endOfRace = false\n  -- While the car is not at the end of race\n  while\
    \ true do\n    -- Check if we ran out of cars\n    if endOfRace then\n      --\
    \ If we ran out of cars and we still have no collisions, then return 0\n     \
    \ if collisions == 0 then\n        return 0\n      else\n        return collisions\n\
    \      end\n    end\n    -- Get the cars\n    local cars = table.get(n, i)\n \
    \   -- Check if we reached the end of race because we have no more cars\n    if\
    \ cars == nil then\n      endOfRace = true\n    else\n      -- Increment the amount\
    \ of collisions\n      collisions = collisions + 1\n      -- Check each car for\
    \ collisions\n      for j = 1, #cars do\n        if cars[j] ~= lastCar then\n\
    \          -- Get the current car\n          local currentCar = cars[j]\n    \
    \      -- Get the last car\n          local lastCar = lastCar\n          -- Check\
    \ if it is the same car and if so, then increase the collision count\n       \
    \   if currentCar == lastCar then\n            collisions = collisions + 1\n \
    \         -- Check if it has a speed that is less than the current car's speed\n\
    \          elseif currentCar.speed > lastCar.speed then\n            -- Get the\
    \ last car's speed\n            speed2 = lastCar.speed\n            -- Check if\
    \ it has a speed that is less than the current car's speed\n            if speed2\
    \ < currentCar.speed then\n              speed2 = currentCar.speed\n         \
    \   end\n            -- Check if it has a speed that is less than the current\
    \ car's speed\n            if speed2 ~= 0 then\n              -- Set the new speed\
    \ to the last car's speed\n              speed = speed2\n            end\n   \
    \       -- Set the current car's speed equal to the last car's speed\n       \
    \   else\n            speed = lastCar.speed\n          end\n          -- Get the\
    \ distance between the current car and the last car\n          local distance\
    \ = speed * distanceBetweenCars(cars[j], lastCar)\n          -- If the distance\
    \ between the current car and the last car exceeds the limit\n          -- then\
    \ consider it a collision\n          if distance > limit then\n            --\
    \ Set the collisions count to 0\n            collisions = 0\n            -- Set\
    \ the end of a race\n            endOfRace = true\n          end\n          --\
    \ If ", "    local count = 0\n    local collisions = false\n    while n >= 1 do\n\
    \        collisions = true\n        for i = 1, n do\n            -- car_x is the\
    \ x coordinate of the left-most car in the next round.\n            -- car_y is\
    \ the y coordinate of the left-most car in the next round.\n            local\
    \ car_x, car_y = get_car_coords(i - 1)\n            local car_x_next, car_y_next\
    \ = get_car_coords(i)", "  local collisions = 0\n  local max_x = 0\n  local min_x\
    \ = n\n  local max_y = 0\n  local min_y = n\n  local max_z = 0\n  local min_z\
    \ = n", '    local collisions = 0', "   local collisions = 0\n   for i = 1, n\
    \ do\n      local car_one\n      local car_two\n      for j = 1, n do\n      \
    \   if i == j then\n            collisions = collisions + 1\n            break\n\
    \         end\n         if j <= i then\n            car_one = car_one\n      \
    \      car_two = car_two\n         end\n      end\n      local collided = false\n\
    \      local min_distance = math.inf\n      local car_one_x = car_one['x']\n \
    \     local car_one_y = car_one['y']\n      local car_two_x = car_two['x']\n \
    \     local car_two_y = car_two['y']\n      for j = 1, n do\n         if i ==\
    \ j then\n            continue\n         end\n         if j <= i then\n      \
    \      local distance = math.sqrt((car_one_x - car_two_x) *\n                \
    \     (car_one_x - car_two_x) + (car_one_y - car_two_y) *\n                  \
    \   (car_one_y - car_two_y))\n            if distance < min_distance then\n  \
    \             min_distance = distance\n               car_one_x = car_one['x']\n\
    \               car_one_y = car_one['y']\n               car_two_x = car_two['x']\n\
    \               car_two_y = car_two['y']\n               collided = true\n   \
    \            break\n            end\n         end\n      end\n      if collided\
    \ then\n         local car_one_speed = car_one['speed']\n         local car_two_speed\
    \ = car_two['speed']\n         if car_one_speed < car_two_speed then\n       \
    \     car_one['x'] = car_two['x']\n            car_one['y'] = car_two['y']\n \
    \           car_one['speed'] = car_two['speed']\n         else\n            car_two['x']\
    \ = car_one['x']\n            car_two['y'] = car_one['y']\n            car_two['speed']\
    \ = car_one['speed']\n         end\n      end\n   end\n   return collisions\n\
    end", "    local collisions = 0\n    for i=1,n do\n        if i > 1 then\n   \
    \         local c1 = i - 1\n            local c2 = i\n            local c3 = i\
    \ - 1\n            while c3 > 1 do\n                local d1 = c3 - 1\n      \
    \          local d2 = c3\n                local d3 = c3 - 1\n                while\
    \ d3 > 1 do\n                    local d4 = d3 - 1\n                    collisions\
    \ = collisions +\n                        (math.abs(c1-d1) < math.abs(c2-d2) and\n\
    \                         math.abs(c1-d3) < math.abs(c2-d4))\n               \
    \     d4 = d3\n                    d3 = d3 - 1\n                end\n        \
    \        d2 = c3\n                c3 = c3 - 1\n            end\n            c2\
    \ = i\n        end\n        if i == 1 then\n            local d1 = i\n       \
    \     local d2 = i - 1\n            while d2 > 1 do\n                local d3\
    \ = d2 - 1\n                collisions = collisions +\n                    (math.abs(c1-d1)\
    \ < math.abs(c2-d3))\n                d3 = d2 - 1\n                d2 = d3\n \
    \           end\n        end\n    end\n    return collisions\nend", '    local
    num_collisions = 0', "    local i = 1\n    local j = 1\n    local collide = 0\n\
    \    while i < n do\n        if j > n then\n            j = 1\n        end\n \
    \       if math.abs(CarRacer(i,j)) == math.abs(CarRacer(j,i)) then\n         \
    \   collide = collide + 1\n        end\n        i = i + 1\n        j = j + 1\n\
    \    end\n    return collide\nend", "   local collisions = 0\n   for i = 1,n do\n\
    \      for j = 1,n do\n         if i >= j then\n            local xDiff = abs(i-j)\n\
    \            local yDiff = abs(n-xDiff)\n            if xDiff > yDiff then\n \
    \              collisions = collisions + 1\n            end\n         end\n  \
    \    end\n   end\n   return collisions\nend", "\t-- The car that collides with\
    \ the first car has index 1, and the second\n\t-- car has index 2.  We already\
    \ know that each colliding car has a\n\t-- positive index.  We also know the total\
    \ distance covered is n, so\n\t-- we can just divide the number of collisions\
    \ by n.\n\treturn n / 2.0\nend", "   assert(n >= 2)\n   local count = 0\n   for\
    \ x = 1, #race do\n      for y = x + 1, #race do\n         local v0 = race[x -\
    \ 1]\n         local v1 = race[y]\n         local v2 = race[y + 1]\n         local\
    \ v3 = race[x - 1]\n         local v4 = race[y]\n         local v5 = race[y +\
    \ 1]\n         if v0 == v1 or v0 == v2 or v0 == v3 then\n            if v1 ==\
    \ v2 or v1 == v3 then\n               if v0 == v3 then\n                  if v1\
    \ == v4 then\n                     if v1 == v5 then\n                        count\
    \ = count + 1\n                     end\n                  end\n             \
    \  end\n            end\n         end\n      end\n   end\n   return count\nend",
  "   for i = 1, n do\n      for j = 1, n do\n         local v1 = car_pos(i)\n   \
    \      local v2 = car_pos(j)\n         if v1 ~= v2 and v1:distance(v2) > 1 then\n\
    \            return 1\n         end\n      end\n   end\n   return 0\nend\n</cell>\n\
    <cell>", "   local collision_count = 0\n   for i=1,n do\n      for j=1,n do\n\
    \         if i+j > n then\n            return collision_count\n         end\n\
    \         local i1 = i - 1\n         local j1 = j - 1\n         local i2 = i +\
    \ 1\n         local j2 = j + 1\n         if i == n or j == n then\n          \
    \  -- if i1 or j1 or i2 or j2 then\n            --     return collision_count\n\
    \            -- end\n         end\n         if i1 < j1 or i1 > j2 then\n     \
    \       collision_count = collision_count + 1\n         end\n      end\n   end\n\
    \   return collision_count\nend", "   -- the set of cars is represented as a binary\
    \ number (i.e. the set contains 2^n numbers)\n   -- and each number corresponds\
    \ to a car id.\n   -- the number 0 corresponds to the \"car 1\" in the above diagram.\n\
    \   -- car id 0 corresponds to the \"car 1\" in this diagram.\n   -- the number\
    \ 1 corresponds to the \"car 2\" in this diagram\n   -- the number 2 corresponds\
    \ to the \"car 3\" in this diagram\n   -- the number 3 corresponds to the \"car\
    \ 4\" in this diagram\n   -- the number 4 corresponds to the \"car 5\" in this\
    \ diagram", "   -- This function is slightly different than the above, where car_race_collision\n\
    \   -- is called only once for every race car pair (i,j) where i < j.\n   -- As\
    \ an example of a function that actually calls car_race_collision\n   -- n times,\
    \ here's a function that calls car_race_collision 4 times:\n   -- local n = car_race_collision(4)\n\
    \   -- It returns 4 as the answer.  That's because in the above function, the\n\
    \   -- two calls to car_race_collision are independent.  That is, each of them\
    \ returns\n   -- the same integer n as the input.  The same is true for car_race_collision.\n\
    \   -- However, in the function below, both calls to car_race_collision are in\
    \ fact related\n   -- to each other.  Therefore, the function below calls car_race_collision\
    \ 4 times.", "  local car_race_collisions = 0\n  for j = 1, n do\n    local car_race_collisions\
    \ = car_race_collisions + 1\n    local car_race_collisions = car_race_collisions\
    \ + 1\n    local car_race_collisions = car_race_collisions + 1\n    local car_race_collisions\
    \ = car_race_collisions + 1\n    local car_race_collisions = car_race_collisions\
    \ + 1\n  end\n  return car_race_collisions\nend", "   local collisions = 0\n \
    \  for i=1,n do\n      for j=1,n do\n         if i==j then collisions = collisions\
    \ + 1 end\n         if i<j and j<=n then collisions = collisions + 1 end\n   \
    \      if i>j and i<n then collisions = collisions + 1 end\n      end\n   end\n\
    \   return collisions\nend", "  -- Start with the first car always colliding.\n\
    \  local num_colliding = 0", "  -- The total number of collisions is 0.\n  --\
    \ Initialize collisions with zero.\n  local collisions = 0", "   assert(n ~= nil\
    \ and n > 0)\n   local collisions = 0\n   for i = 1, n do\n      for j = i + 1,\
    \ n do\n         local left_speed = car.left_speed\n         local right_speed\
    \ = car.right_speed\n         local left_speed2 = left_speed * left_speed\n  \
    \       local right_speed2 = right_speed * right_speed\n         local left_speed3\
    \ = left_speed * left_speed\n         local right_speed3 = right_speed * right_speed\n\
    \         local left_speed4 = left_speed * left_speed\n         local right_speed4\
    \ = right_speed * right_speed\n         local left_speed5 = left_speed * left_speed\n\
    \         local right_speed5 = right_speed * right_speed\n         local left_speed6\
    \ = left_speed * left_speed\n         local right_speed6 = right_speed * right_speed\n\
    \         local left_speed7 = left_speed * left_speed\n         local right_speed7\
    \ = right_speed * right_speed\n         local left_speed8 = left_speed * left_speed\n\
    \         local right_speed8 = right_speed * right_speed\n         local left_speed9\
    \ = left_speed * left_speed\n         local right_speed9 = right_speed * right_speed\n\
    \         local left_speed10 = left_speed * left_speed\n         local right_speed10\
    \ = right_speed * right_speed\n         local left_speed11 = left_speed * left_speed\n\
    \         local right_speed11 = right_speed * right_speed\n         local left_speed12\
    \ = left_speed * left_speed\n         local right_speed12 = right_speed * right_speed\n\
    \         local left_speed13 = left_speed * left_speed\n         local right_speed13\
    \ = right_speed * right_speed\n         local left_speed14 = left_speed * left_speed\n\
    \         local right_speed14 = right_speed * right_speed\n         local left_speed15\
    \ = left_speed * left_speed\n         local right_speed15 = right_speed * right_speed\n\
    \         local left_speed16 = left_speed * left_speed\n         local right_speed16\
    \ = right_speed * right_speed\n         local left_speed17 = left_speed * left_speed\n\
    \         local right_speed17 = right_speed * right_speed\n         local left_speed18\
    \ = left_speed * left_speed\n         local right_speed18 = right_speed * right_speed\n\
    \         local left_speed19 = left_speed * left_speed\n         local right_speed19\
    \ = right_speed * right_speed\n         local left_speed20 = left_speed * left_speed\n\
    \         local right_speed20 = right_speed * right_speed\n         local left_speed21\
    \ = left_speed * left_speed\n         local right_speed21 = right_speed * right_speed\n\
    \         local left_speed22", "  if n <= 0 then return 0 end\n  local c = 0\n\
    \  local x = -1000\n  local y = -1000\n  for i = 1, n do\n    local x1 = x + rand(0,\
    \ 100)\n    local y1 = y + rand(0, 100)\n    local x2 = x - rand(0, 100)\n   \
    \ local y2 = y - rand(0, 100)\n    if x1 >= x and x1 <= x2 and\n       y1 >= y\
    \ and y1 <= y2 then\n      c = c + 1\n    end\n    x, y, _ = x1,y1,0\n  end\n\
    \  return c\nend", "  -- Initialize variables involved in the collision test.\n\
    \  local collisions = 0\n  local cars_speed = 2 * pi / n\n  -- Set the initial\
    \ conditions for the left and right trajectories.\n  local left_left_x = -pi\n\
    \  local left_left_y = 1\n  local left_right_x = -pi\n  local left_right_y = 1\n\
    \  local right_left_x = -pi\n  local right_left_y = 1\n  local right_right_x =\
    \ pi\n  local right_right_y = 1\n  -- Iterate through the infinite line.\n  while\
    \ true do\n    -- Update the position of the two trajectories.\n    local left_x\
    \ = left_left_x + cars_speed\n    local left_y = left_left_y + cars_speed\n  \
    \  local right_x = left_right_x + cars_speed\n    local right_y = left_right_y\
    \ + cars_speed\n    -- If the left trajectory hits the right trajectory, increment\
    \ the number of\n    -- collisions.\n    if left_x == right_x then\n      collisions\
    \ = collisions + 1\n      -- Set a new initial conditions for the right trajectory.\n\
    \      left_right_x = right_right_x\n      left_right_y = right_right_y\n    \
    \  right_right_x = right_x\n      right_right_y = right_y\n      break\n    end\n\
    \    -- If the right trajectory hits the left trajectory, increment the number\n\
    \    -- of collisions.\n    if right_x == left_x then\n      collisions = collisions\
    \ + 1\n      -- Set a new initial conditions for the left trajectory.\n      left_left_x\
    \ = left_x\n      left_left_y = left_y\n      right_left_x = right_x\n      right_left_y\
    \ = right_y\n      break\n    end\n    -- Otherwise, the trajectories do not collide.\n\
    \    left_left_x = left_x\n    left_left_y = left_y\n    left_right_x = right_x\n\
    \    left_right_y = right_y\n  end\n  return collisions\nend", "  local count\
    \ = 0\n  for i=1, n do\n    if i % 2 == 0 then\n      -- Driver 1 cars are moving\
    \ left to right.\n      if i < n then\n        -- Driver 2 cars are moving right\
    \ to left.\n        if ((i + 1) % n) == 0 then\n          count = count + 1\n\
    \        end\n      end\n    else\n      -- Driver 1 cars are moving right to\
    \ left.\n      if i ~= n then\n        -- Driver 2 cars are moving left to right.\n\
    \        if ((i - 1) % n) == 0 then\n          count = count + 1\n        end\n\
    \      end\n    end\n  end\n  return count\nend", "   local collisions = 0\n \
    \  local race_length = math.floor(race_length / n)\n   local car_count = 1\n \
    \  for i = 1, n do\n      -- car_count is the number of cars moving in their infinite\
    \ trajectory.\n      -- The speed is constant.\n      local car_speed = race_length\
    \ * car_count\n      local car_left = car_speed * i\n      local car_right = car_speed\
    \ * (i + 1)\n      -- The car moving left to right is hitting the car moving right\
    \ to left.\n      -- This happens when the x coordinate of the cars collide.\n\
    \      if math.abs(car_left - car_right) < 2 * car_speed then\n         collisions\
    \ = collisions + 1\n      end\n      car_count = car_count + 1\n   end\n   return\
    \ collisions\nend", "  local collisions = 0\n  local speed = SPEED_INCREMENT\n\
    \  local i = 1\n  for i = 2, n do\n    for j = 1, i do\n      local car_x = math.random(0.0,\
    \ (2.0 * speed) - 1.0)\n      local car_y = math.random(0.0, (2.0 * speed) - 1.0)\n\
    \      local car_speed = speed * math.random(0.5, 2.0) - 0.5\n      local car_race_car_collide\
    \ = race_car_collide(car_x, car_y, car_speed)\n      local car_race_car_collide\
    \ = car_race_car_collide\n      if car_race_car_collide then\n        collisions\
    \ = collisions + 1\n      end\n    end\n    speed = speed * 0.5\n  end\n  return\
    \ collisions\nend", "   for i = 1, n do\n      for j = 1, n do\n         local\
    \ xc = (j - 1 - (n + 1) % 2) / (2 * n) + 1\n         local yc = i - 1 - (n + 1)\
    \ % 2\n         local collisions = detect_collision(\n            get_angle(rover_cars.cars[i],\
    \ rover_cars.cars[j]),\n            xc, yc)\n         if collisions > 0 then\n\
    \            return collisions\n         end\n      end\n   end\n   return 0\n\
    end", "  if n == 1 then\n    return 1\n  else\n    local i = 1\n    local collisions\
    \ = 0\n    while i <= n do\n      local j = i - 1\n      if j % 2 ~= 0 then\n\
    \        local car_i = i + 1\n        local car_j = j + 1\n        local car_speed\
    \ = 0\n        local car_speed = 0\n        if car_i <= n and car_j <= n then\n\
    \          local car_x = car_x0[car_i]\n          local car_y = car_y0[car_i]\n\
    \          local car_x_left = car_x0[car_j]\n          local car_y_left = car_y0[car_j]\n\
    \          local car_speed = car_speed0[car_i]\n          local car_speed_left\
    \ = car_speed0[car_j]\n          local collision_distance = math.abs(car_x - car_x_left)\
    \ + math.abs(car_y - car_y_left)\n          if collision_distance > max_collision_distance\
    \ then\n            collisions = collisions + 1\n          end\n          local\
    \ car_direction = math.atan2(car_y_left - car_y, car_x_left - car_x)\n       \
    \   local car_angle = car_direction - car_angle0[car_i]\n          local car_angle_left\
    \ = car_direction - car_angle0[car_j]\n          local car_speed = (car_speed\
    \ + (car_speed * car_speed) / (1 + math.pow((car_speed - car_speed_left) / (max_collision_distance\
    \ - collision_distance), 2)) * math.sin(car_angle)) / (1 + math.pow((car_speed\
    \ - car_speed_left) / (max_collision_distance - collision_distance), 2))\n   \
    \       local car_angle_left = car_angle_left + car_speed\n          local car_speed_left\
    \ = (car_speed_left + (car_speed * car_speed) / (1 + math.pow((car_speed - car_speed_left)\
    \ / (max_collision_distance - collision_distance), 2)) * math.sin(car_angle_left))\
    \ / (1 + math.pow((car_speed - car_speed_left) / (max_collision_distance - collision_distance),\
    \ 2))\n        end\n      end\n      i = i + 1\n    end\n    return collisions\n\
    \  end\nend", "\tlocal collisions = 0\n\t-- We need to test whether two cars collide\
    \ with each other.\n\t-- A collision occurs when two cars collide with each other\
    \ in the same direction.\n\tfor i = 1, n do\n\t\t-- The first car we're considering.\n\
    \t\tlocal car1 = i - 1\n\t\t-- The last car we're considering.\n\t\tlocal car2\
    \ = n\n\t\t-- One of the cars we've already considered collides with the other\
    \ car.\n\t\tlocal collides_with = i\n\t\twhile collides_with >= 1 do\n\t\t\t--\
    \ The other car we've already considered collides with the first car.\n\t\t\t\
    local collides_with2 = collides_with - 1\n\t\t\t-- The vector from car1 to car2.\n\
    \t\t\tlocal vx = cars[car1].x - cars[car2].x\n\t\t\tlocal vy = cars[car1].y -\
    \ cars[car2].y\n\t\t\tlocal distance = math.sqrt(vx * vx + vy * vy)\n\t\t\tlocal\
    \ direction_of_vx = vx / distance\n\t\t\tlocal direction_of_vy = vy / distance\n\
    \t\t\tif math.abs(vx - vy) < 0.1 then\n\t\t\t\t-- If vx and vy are exactly the\
    \ same, this means that the cars have\n\t\t\t\t-- exactly the same speed.  The\
    \ second car is moving more right to left\n\t\t\t\t-- than the first car; therefore,\
    \ it can't possibly collide with the first\n\t\t\t\t-- car.\n\t\t\t\tbreak\n\t\
    \t\telseif direction_of_vx < 0 and direction_of_vy >= 0 then\n\t\t\t\t-- If the\
    \ cars are moving right to left, then the second car is going to\n\t\t\t\t-- hit\
    \ the cars in front of it.  Therefore, this car is colliding with the\n\t\t\t\t\
    -- car in front of it.\n\t\t\t\tcollisions = collisions + 1\n\t\t\t\tbreak\n\t\
    \t\telseif direction_of_vx < 0 and direction_of_vy < 0 then\n\t\t\t\t-- If the\
    \ cars are moving right to left, then the first car is going to\n\t\t\t\t-- hit\
    \ the cars in front of it.  Therefore, this car is colliding with the\n\t\t\t\t\
    -- car in front of it.\n\t\t\t\tcollisions = collisions + 1\n\t\t\t\tbreak\n\t\
    \t\telseif direction_of_vx >= 0 and direction_of_vy < 0 then\n\t\t\t\t-- If the\
    \ cars are moving left to right, then the second car is going to\n\t\t\t\t-- hit\
    \ the cars in front of it.  Therefore, this car is colliding with the\n\t\t\t\t\
    -- car in front of it.\n\t\t\t\tcollisions = collisions + 1\n\t\t\t\tbreak\n\t\
    \t\telseif direction_of_vx >= 0 and direction_of_vy ", "   assert( n > 0 )\n \
    \  local count = 0\n   local i = 1\n   while i <= n do\n      for j = 1, n do\n\
    \         if j == i then\n            --  Cars i and j collide.\n            return\
    \ count + 1\n         end\n      end\n      count = count + 1\n      i = i + 1\n\
    \   end\n   return 0\nend", "  -- The first car is car number 1, the second is\
    \ car number 2, etc.\n  local car_1, car_2 = 1, 2\n  -- The first car is allowed\
    \ to change lanes.\n  local allow_lanes = true\n  -- The number of cars in the\
    \ first lane.\n  local cars_in_first_lane = 0\n  -- The number of cars in the\
    \ second lane.\n  local cars_in_second_lane = 0\n  -- The amount of time to wait\
    \ between cars.\n  local wait = 0.01\n  -- The amount of time to wait for cars\
    \ to collide.\n  local wait_collide = 0.01\n  -- The number of cars colliding.\n\
    \  local car_collisions = 0", "    local collisions = 0\n    for i = 1, n do\n\
    \        for j = 1, n do\n            local xd = math.abs(cars[i].x - cars[j].x)\n\
    \            local yd = math.abs(cars[i].y - cars[j].y)\n            if xd >=\
    \ 1 and yd >= 1 then\n                collisions = collisions + 1\n          \
    \  end\n        end\n    end\n    return collisions\nend", "  local collision\
    \ = 0\n  for i = 1, n do\n    for j = i + 1, n do\n      if i==j then\n      \
    \  continue\n      end\n      local dx_r = car_x_coords[i]-car_x_coords[j]\n \
    \     local dy_r = car_y_coords[i]-car_y_coords[j]\n      local dx_l = car_x_coords[j]-car_x_coords[i]\n\
    \      local dy_l = car_y_coords[j]-car_y_coords[i]\n      local dist = math.sqrt(dx_r*dx_r+dy_r*dy_r+dx_l*dx_l+dy_l*dy_l)\n\
    \      -- Ignore cars with no collision\n      if dist > 0 then\n        collision\
    \ = collision+1\n      end\n    end\n  end\n  return collision\nend", "  -- Initialize\
    \ collision counter to zero.\n  local collisions = 0\n  -- Move both cars one\
    \ position at a time.\n  for x = -n, n do\n    for y = -n, n do\n      -- Increment\
    \ collision counter if the cars collide.\n      if car_race_collision(x, y, n)\
    \ then\n        collisions = collisions + 1\n      end\n    end\n  end\n  return\
    \ collisions\nend", "  local collided = 1\n  local max = 0\n  local min = 0\n\
    \  for i = 1, n do\n    local minx, miny = min(minx, miny), min(miny, minx)\n\
    \    local maxx, maxy = max(maxx, maxy), max(maxy, maxx)\n    if minx + miny +\
    \ maxx + maxy ~= n then\n      collided = 1\n      break\n    end\n  end\n  if\
    \ collided == 0 then\n    return 0\n  end\n  if n == 1 then\n    max = min\n \
    \ else\n    max = n\n    for i = 1, n do\n      max = max + (n - i) / 2\n    end\n\
    \  end\n  local count = 0\n  for i = 1, n do\n    local minx, miny = minx, miny\n\
    \    local maxx, maxy = maxx, maxy\n    local xspeed = math.random(1, max) / max\
    \ * n\n    local yspeed = math.random(1, max) / max * n\n    local xspeed, yspeed\
    \ = math.abs(xspeed), math.abs(yspeed)\n    if xspeed == 0 then\n      xspeed\
    \ = 1\n    end\n    if yspeed == 0 then\n      yspeed = 1\n    end\n    count\
    \ = count + car_race_collision_helper(n - i, minx, miny, maxx, maxy, xspeed, yspeed)\n\
    \  end\n  return count\nend", "   local collisions = 0\n   local first_collision\
    \ = false", "  -- This loop finds all possible combinations of n-1 cars being\
    \ moved right to left.\n  for i = 1, n do\n    local left, right = n - i - 1,\
    \ n - i\n    for j = 1, left do\n      local count = 0\n      for k = 1, right\
    \ do\n        if (i == 1) and (k == 1) then\n          -- The set {left, right}\
    \ of cars has one car.\n          count = count + 1\n        else\n          --\
    \ The set {left, right} of cars has two cars.\n          count = count + car_race_collision(left)\n\
    \        end\n      end\n      -- The number of collisions is the number of different\
    \ ways these sets of cars\n      -- can be arranged into infinite loops.\n   \
    \   return count + 1\n    end\n  end\n  -- If we get here, then we haven't found\
    \ any collisions.\n  return 0\nend", "  local collision = 0\n  local left_road\
    \ = false\n  local right_road = false\n  for i=1,n do\n    if left_road == false\
    \ then\n      local left, right = car_race_collision(i)\n      collision = collision\
    \ + left - right\n      left_road = left\n      right_road = right\n    end\n\
    \    if right_road == false then\n      local left, right = car_race_collision(i+1)\n\
    \      collision = collision + right - left\n      left_road = left\n      right_road\
    \ = right\n    end\n  end\n  return collision, nil\nend\n</cell>\n<cell>", " \
    \  if n <= 1 then return 1 end\n   local m = math.ceil(n / 2)\n   local i = 1\n\
    \   while i <= n do\n      local j = 2 * i\n      if j > n then return 1 end\n\
    \      if j + 1 < n then\n         local car_a = i - m\n         local car_b =\
    \ j\n         local car_c = j + 1\n         local car_d = i - 1\n         if car_a\
    \ > 0 then\n            if car_b <= m and car_b + 1 < n then\n               local\
    \ car_d = car_b + 1\n               local car_h = i - 1\n               return\
    \ car_race_collision(m * (j - m) + car_race_collision(m * car_h))\n          \
    \  end\n         end\n         if car_b <= m and car_b + 1 < n then\n        \
    \    local car_c = j + 1\n            local car_h = i - 1\n            return\
    \ car_race_collision(m * (j - m) + car_race_collision(m * car_h))\n         end\n\
    \         if car_c == n then return car_race_collision(m * j + car_race_collision(m\
    \ * i)) end\n         if car_d == n then return car_race_collision(m * j + car_race_collision(m\
    \ * i + 1)) end\n      end\n      i = i + 1\n   end\n   return 0\nend\n</cell>\n\
    <cell>", "    local function collision(x, y)\n        if x > n then\n        \
    \    -- Collision right side.\n            return x - (n - 1) + 1\n        else\n\
    \            -- Collision left side.\n            return x + 1\n        end\n\
    \    end\n    return math.ceil(math.pow(n, 2) - 2 * math.pow(n, 3))\nend", " \
    \  local num_collisions = 0\n   for i = 1, n do\n      local left_speed = i -\
    \ 1\n      local right_speed = i\n      -- The two cars are only colliding if\
    \ moving right to left is quicker\n      -- to do than moving left to right.\n\
    \      if car_race_collision_strategy(left_speed, right_speed) == 1 then\n   \
    \      num_collisions = num_collisions + 1\n         -- The left car collided\
    \ with the right car and needs to move left\n         -- again to prevent a collision.\n\
    \         left_speed = i + 1\n         if car_race_collision_strategy(left_speed,\
    \ right_speed) == 2 then\n            num_collisions = num_collisions + 1\n  \
    \       end\n      end\n   end\n   return num_collisions\nend", "   local count\
    \ = 0\n   for i=1, n do\n      for j=1, n do\n         if i == j then\n      \
    \      continue\n         end\n         -- Find the distance between the two cars.\n\
    \         local distance = getDistance(mycar.x, mycar.y, car.x, car.y)\n     \
    \    -- Find the distance between the cars.\n         local distance1 = getDistance(car.x,\
    \ car.y, car.x + car.speed, car.y + car.speed)\n         -- Find the distance\
    \ between the cars.\n         local distance2 = getDistance(car.x + car.speed,\
    \ car.y + car.speed, car.x + car.speed, car.y + car.speed)\n         -- If any\
    \ of the distances are too small, they will collide.\n         if distance > 0.1\
    \ && distance1 < 0.1 && distance2 < 0.1 then\n            count = count + 1\n\
    \         end\n      end\n   end\n   return count\nend", "   local collisions\
    \ = 0\n   local car_1 = tonumber(car_1.x)\n   local car_2 = tonumber(car_2.x)\n\
    \   local car_3 = tonumber(car_3.x)\n   local car_4 = tonumber(car_4.x)\n   local\
    \ car_5 = tonumber(car_5.x)\n   local car_6 = tonumber(car_6.x)", "    local num_collisions\
    \ = 0\n    local car_left  = n[1]\n    local car_right = n[2]", "\tlocal i = 1\n\
    \twhile i <= n do\n\t\tif race_car_collision(i) ~= i then\n\t\t\treturn i\n\t\t\
    end\n\t\ti = i + 1\n\tend\n\treturn 0\nend", "   -- Initialize variables.\n  \
    \ local collision = 0\n   local distance = 0\n   local car_collision = 0\n   local\
    \ car_distance = 0\n   -- Initialize the first car.\n   local car_1 = initCar()\n\
    \   -- Initialize the first colliding car.\n   local car_1_collide = car_1 --\
    \ car_1 is the first car.\n   -- Initialize the second colliding car.\n   local\
    \ car_2_collide = car_1 -- car_2 is the second car.\n   -- Initialize the first\
    \ car.\n   local car_2 = initCar()\n   -- Initialize the first colliding car.\n\
    \   local car_2_collide = car_2 -- car_2 is the second car.\n   -- Initialize\
    \ the second colliding car.\n   local car_3 = initCar()\n   -- Initialize the\
    \ first colliding car.\n   local car_3_collide = car_3 -- car_3 is the third car.\n\
    \   -- Initialize a temporary vector to store the current distance.\n   local\
    \ temp_vec = Vector()\n   -- Initialize a temporary vector to store the current\
    \ distance from car_1.\n   local temp_vec_1 = Vector()\n   -- Initialize the first\
    \ colliding car.\n   local car_4_collide = car_3 -- car_4 is the fourth car.\n\
    \   -- Initialize the second colliding car.\n   local car_4_collide = car_3 --\
    \ car_4 is the fourth car.\n   -- Initialize the second colliding car.\n   local\
    \ car_5_collide = car_3 -- car_5 is the fifth car.\n   -- Initialize the second\
    \ colliding car.\n   local car_6_collide = car_3 -- car_6 is the sixth car.\n\
    \   -- Initialize the second colliding car.\n   local car_7_collide = car_3 --\
    \ car_7 is the seventh car.\n   -- Initialize the second colliding car.\n   local\
    \ car_8_collide = car_3 -- car_8 is the eighth car.\n   -- Initialize the second\
    \ colliding car.\n   local car_9_collide = car_3 -- car_9 is the ninth car.\n\
    \   -- Initialize the second colliding car.\n   local car_10_collide = car_3 --\
    \ car_10 is the tenth car.\n   -- Initialize the second colliding car.\n   local\
    \ car_11_collide = car_3 -- car_11 is the eleventh car.\n   -- Initialize the\
    \ second colliding car.", "  -- Find a collision by finding a straight line that\
    \ goes through all n cars.\n  local ncollisions = 0\n  for i = 0, n - 1 do\n \
    \   if i == n - 2 then\n      ncollisions = ncollisions + 1\n      break\n   \
    \ end\n    local c1 = i - 1\n    local c2 = i + 1\n    local c3 = i - n + 2\n\
    \    local c4 = i + n + 2\n    local d = 0\n    if c1 < c2 then d = c2 - c1 end\n\
    \    if c2 < c3 then d = c3 - c2 end\n    if c3 < c4 then d = c4 - c3 end\n  \
    \  local m = (d + d) / 2\n    local i1 = m - n + 1\n    local i2 = m + n + 1\n\
    \    local i3 = m + n\n    local i4 = m - n\n    if i1 <= i3 then ncollisions\
    \ = ncollisions + 1 end\n    if i2 <= i4 then ncollisions = ncollisions + 1 end\n\
    \  end\n  return ncollisions\nend", "  local i = 1, n\n  local collisions = 0\n\
    \  while i < n do\n    local j = i - 1\n    if collisions(i, j, n - 1) then\n\
    \      collisions = collisions + 1\n    end\n    i = i + 1\n  end\n  return collisions\n\
    end", "\tlocal collisions = 0\n\tlocal last_collision = -1\n\tlocal speed = 1\n\
    \tlocal max_speed\n\tlocal current_speed\n\tlocal collision_speed\n\tlocal car_speed\n\
    \tlocal last_car_speed\n\tlocal max_speed_index\n\tlocal speed\n\tlocal car\n\t\
    local car_speed\n\tlocal i", "   local collisions = 0\n   for i = 1, n do\n  \
    \    for j = 1, n do\n         if (i == j) then\n            collisions = collisions\
    \ + 1\n         end\n      end\n   end\n   return collisions\nend", "   -- the\
    \ first set of cars is perfectly straight; they collide immediately\n   if (n\
    \ <= 1) then\n      return 0\n   end", "  -- The function returns the number of\
    \ collisions found.\n  -- The parameter n specifies the number of cars in the\
    \ race.\n  -- Note that this value may be zero or negative.\n  -- If the number\
    \ of cars in the race is zero, return zero.\n  if n == 0 then\n    return 0\n\
    \  else\n    -- The race has n cars.\n    local race_length = n\n    local collisions\
    \ = 0\n    -- While there are cars still to be moved.\n    local car_moved = true\n\
    \    while car_moved do\n      -- Move one car in the race one at a time.\n  \
    \    -- If there are any collisions encountered, return collisions.\n      local\
    \ car_1 = car_race_car(race_length)\n      local car_2 = car_race_car(race_length)\n\
    \      local collision_1 = car_race_collision_car(car_1)\n      local collision_2\
    \ = car_race_collision_car(car_2)\n      -- The car_race_collision_car() function\
    \ returns the number of collisions.\n      -- If this value is the same as car_1,\
    \ return collisions.\n      -- If this value is the same as car_2, return collisions.\n\
    \      -- Otherwise, increment collisions by one and car_moved is false.\n   \
    \   if collision_1 ~= 0 then\n        collisions = collisions + 1\n      elseif\
    \ collision_2 ~= 0 then\n        collisions = collisions + 1\n      else\n   \
    \     -- Move the car.\n        car_race_car = car_race_car + 1\n        car_moved\
    \ = false\n      end\n    end\n    return collisions\n  end\nend", "  -- Initialize\
    \ n to be the number of possible collisions possible.\n  -- If we make n too big,\
    \ we'll need to check for a collision after every step.\n  n = n or math.huge",
  "   -- If n doesn't divide evenly into the number of cars in the race,\n   -- there's\
    \ no race to do.\n   if n % 2 == 0 then\n      -- In order to simulate an infinite\
    \ race cars start out moving at a constant speed.\n      return 0\n   end", " \
    \ local function r()\n    return math.random(1, 10000)\n  end\n  local function\
    \ f(x, y)\n    return math.abs(math.sin(r())) - math.abs(math.sin(r())) * (math.sin(r())\
    \ + math.sin(r())) * x\n  end\n  local a = 0\n  local b = 0\n  local c = 0\n \
    \ local d = 0\n  for i = 1, n do\n    local x, y = r(), r()\n    local f = f(x,\
    \ y)\n    if x < 0 then\n      a = a - 1\n    elseif x > 0 then\n      b = b -\
    \ 1\n    elseif y < 0 then\n      c = c - 1\n    elseif y > 0 then\n      d =\
    \ d - 1\n    end\n  end\n  return math.floor(n * c / ((a + b) * (c + d)))\nend",
  "\tlocal race_cars_set = Set()\n\tlocal collided_count = 0\n\tfor i = 1, n do\n\t\
    \tlocal car_collisions = false\n\t\tfor j = 1, n do\n\t\t\tlocal distance = math.abs(car.x\
    \ - cars[j].x) + math.abs(car.y - cars[j].y)\n\t\t\tlocal speed = car.speed *\
    \ cars[j].speed\n\t\t\tif distance < speed then\n\t\t\t\tcar_collisions = true\n\
    \t\t\tend\n\t\tend\n\t\tif car_collisions then\n\t\t\tcollided_count = collided_count\
    \ + 1\n\t\telse\n\t\t\trace_cars_set[#race_cars_set + 1] = car.index\n\t\tend\n\
    \tend\n\treturn collided_count\nend", "   -- A collision is said to be race here\
    \ if the intersection of the racing car's trajectory and\n   -- the other car's\
    \ trajectory is a race car itself or if they are too close or overlapping.\n \
    \  --\n   -- The race car is identified by using the function car_race_collision.\n\
    \   -- The function car_race_collision returns a list of 2 elements where the\
    \ first element is\n   -- the index of the racing car if the other car collided\
    \ with the racing car and\n   -- the second element is the index of the other\
    \ car if they collided with the racing\n   -- car.\n   --\n   -- The collision\
    \ must be within a distance of 1 meter because the distance\n   -- between the\
    \ cars is in meters.\n   --\n   -- The race car must be within 1 meter of the\
    \ other car because a car\n   -- is only considered a race car if it can move\
    \ along itself, and\n   -- therefore the distance between two cars must be less\
    \ than 1.\n   --\n   -- The function car_race_collision will output two numbers:\n\
    \   -- 1) the index of the racing car if the other car collided with the racing\
    \ car\n   -- 2) the index of the other car if they collided with the racing car.\n\
    \   --\n   -- The function car_race_collision returns nil if there is no collision.\n\
    \   --\n   -- The collision is considered a race when there is a race car within\
    \ the proximity of\n   -- the other car.\n   --\n   -- The proximity of two cars\
    \ is the distance between the cars plus their speeds.\n   --\n   -- The function\
    \ car_race_collision returns nil if n is 0 or 1\n   if n == 0 or n == 1 then\n\
    \      return nil, nil\n   end", "  -- Assume a car does not collide with itself.\n\
    \  -- The first car (i-1) is always in collision.\n  local collisions = 0", " \
    \  -- Initialize an array to store the cars\n   local cars = { }", "  -- We know\
    \ that each car is moving left to right, so for each car in n, there\n  -- will\
    \ be one collision at most.\n  -- Each car will be moving left to right for exactly\
    \ 1 tick (the time between\n  -- the left and the right edges).\n  -- Therefore,\
    \ after each tick, there will be exactly 1 collision with the next\n  -- car.\n\
    \  -- Therefore, the total number of collisions is\n  -- (n + 1) * (n + 1) / 2\
    \ = 2n^2 / 2\n  -- This is the sum of all integers n <= 2n, which is 2n^2/2.\n\
    \  -- This formula only works for n <= 50, though; for larger n, this formula\
    \ will\n  -- not hold.\n  -- Therefore, for n <= 50, we use a more stable and\
    \ computationally more accurate\n  -- formula.\n  -- The formula below is stable\
    \ for large n.", "   for _,t in ipairs(targ) do\n      local collisions = 0\n\
    \      for i = 1,n do\n         if t[i]~=nil then\n            if t[i].x ~= t[i-1].x\
    \ and t[i].y ~= t[i-1].y then\n               collisions = collisions + 1\n  \
    \          end\n         end\n      end\n      if collisions>n then\n        \
    \ return collisions\n      end\n   end\n   return 0\nend", "    local i, j = math.random(1,\
    \ n - 1), math.random(1, n - 1)\n    while i ~= j do\n        i, j = math.random(1,\
    \ n - 1), math.random(1, n - 1)\n    end\n    return n - i\nend", "  -- The two\
    \ cars that are going to collide.\n  local cars_a = terralib.newlist()\n  local\
    \ cars_b = terralib.newlist()\n  local num_collisions = 0", "  -- The function\
    \ returns a value between 1 and n inclusive.\n  local num_collisions = 0\n  for\
    \ i = 1, n do\n    local a = math.random(1, n + 1)\n    local b = math.random(1,\
    \ n + 1)\n    while a == b do\n      b = math.random(1, n + 1)\n    end\n    if\
    \ a == b then\n      num_collisions = num_collisions + 1\n    end\n  end\n  return\
    \ num_collisions\nend", "  local count = 0\n  local max_car_width = 160 -- or\
    \ something\n  local max_car_height = 80  -- or something\n  for i = 1, n do\n\
    \    local x = math.random(1, max_car_width) + max_car_width/2 -- center car is\
    \ centered\n    local y = math.random(1, max_car_height) + max_car_height/2\n\
    \    local new_car_width = math.random(0.5, max_car_width/2)\n    local new_car_height\
    \ = math.random(0.5, max_car_height/2)\n    local new_car_speed = math.random(5,\
    \ 10)\n    -- move cars in opposite directions\n    new_car_speed = -new_car_speed\n\
    \    -- if cars collide, make them move into colliding zone\n    if car_race_collision_check(x,\
    \ y, new_car_width, new_car_height, new_car_speed) then\n      x = x + max_car_width/2\n\
    \      y = y + max_car_height/2\n      new_car_width = max_car_width/2\n     \
    \ new_car_height = max_car_height/2\n      new_car_speed = math.random(5, 10)\n\
    \    end\n  end\n  count = count + 1\n  return count\nend", "    --  Describe\
    \ a road where cars go left to right\n    --  and right to left simultaneously.",
  "  local i = 1\n  local result = 0\n  local speed = 200\n  while i <= n do\n   \
    \ local c1 = speed_car(speed, i - 1)\n    local c2 = speed_car(speed, i)\n   \
    \ local collided = car_race_collided(c1, c2)\n    if not collided then result\
    \ = result + 1 end\n    speed = speed - speed\n    i = i + 2\n  end\n  return\
    \ result\nend", "   -- the two sets of cars (n x 2) are given\n   local x_set\
    \ = {}\n   local y_set = {}\n   for i=1,n do\n      x_set[i] = math.random(n-1)+1\n\
    \      y_set[i] = math.random(n-1)+1\n   end\n   local collisions = 0\n   local\
    \ x_collisions = {}\n   local y_collisions = {}\n   for i=1,n do\n      for j=1,n\
    \ do\n         local i1 = x_set[i]\n         local i2 = x_set[j]\n         local\
    \ j1 = y_set[i]\n         local j2 = y_set[j]\n         local dist1 = x_set[i1]\
    \ - x_set[j]\n         local dist2 = y_set[i2] - y_set[j2]\n         if dist1\
    \ ~= 0 and dist2 ~= 0 then\n            -- both cars driving in the same direction,\
    \ collide immediately\n            if dist1 == dist2 then\n               collisions\
    \ = collisions + 1\n               x_collisions[i] = x_collisions[i] + 1 -- increment\
    \ the count for the first car\n               y_collisions[i] = y_collisions[i]\
    \ + 1 -- increment the count for the first car\n               -- now that we've\
    \ processed the collision for the first car, stop\n               -- processing\
    \ this pair of cars\n               break\n            end\n         end\n   \
    \   end\n   end\n   return collisions, x_collisions, y_collisions\nend", "  local\
    \ cnt = 0\n  -- Start off with the rightmost car in the right.\n  for i = n -\
    \ 1, -1, -1 do\n    if in_range(car_at(i), car_at(i + 1)) then\n      -- The cars\
    \ in the right and left are colliding.\n      cnt = cnt + 1\n    end\n  end\n\
    \  return cnt\nend", "\t-- the output variable\n\tlocal collisions = nil\n\t--\
    \ The set of possible initial configurations\n\tlocal possible_inits = generate_init_configs(n)\n\
    \t-- The set of possible start positions for a race collision\n\tlocal collision_init_positions\
    \ = generate_start_positions(n, true)\n\t-- The set of possible end positions\
    \ for a race collision\n\tlocal collision_end_positions = generate_start_positions(n,\
    \ false)\n\t-- The set of all end positions ever recorded in the program\n\tlocal\
    \ positions_recorded = {}\n\t-- A set of all races that we've seen\n\tlocal races\
    \ = {}\n\t-- The set of all races that collided\n\tlocal races_collided = {}\n\
    \t-- The current set of positions we've checked\n\tlocal positions_checked = {}\n\
    \t-- The current set of collisions that we've found so far\n\tlocal collisions_checked\
    \ = {}\n\t-- The current set of initial positions we've checked\n\tlocal positions_checked2\
    \ = {}\n\t-- The current set of positions we've collided with\n\tlocal collisions_collided\
    \ = {}\n\t-- A variable that tracks how far we have been when checking collisions\n\
    \tlocal collision_distance_so_far = 0", "    local i = 1\n    while i <= n do\n\
    \        -- If the current two cars are not in collision, then the cars will never\
    \ collide.\n        if i == 1 or i == n then\n            return i\n        end",
  "  local coll_count = 0\n  for i = 1, n do\n    for j = 1, n do\n      if i < j\
    \ then\n        if car_race_is_colliding(i, j) then\n          coll_count = coll_count\
    \ + 1\n        end\n      end\n    end\n  end\n  return coll_count\nend", "  \
    \ for i = 1, n do\n      for j = 1, n do\n         if i - j == 1 then\n      \
    \      -- If n is even then no collision exists at this point\n            if\
    \ n == math.floor(n/2) and i == 1 then\n               return 0\n            end\n\
    \            if n == math.floor(n/2) and j == 1 then\n               return 0\n\
    \            end\n            if j == n - i then\n               return 0\n  \
    \          end\n            local collide_left = race_left_collision(i)\n    \
    \        local collide_right = race_right_collision(j)\n            if collide_left\
    \ or collide_right then\n               return 0\n            end\n         end\n\
    \      end\n   end\n   return n\nend", "   local count = 0\n   for x = 1, n do\n\
    \      for y = x + 1, n do\n         if check_cars(x, y) then\n            count\
    \ = count + 1\n         end\n      end\n   end\n   return count\nend", "  -- The\
    \ function assumes that n > 0.  Hence, there are n-1 cars who are\n  -- driving\
    \ left and one person is driving right.\n  -- If there are only n cars, return\
    \ n.\n  -- Otherwise, return n-1.\n  local n = n - 1\n  if n == 0 then\n    return\
    \ n\n  else\n    return n + car_race_collision(n-1)\n  end\nend", "  local collide\
    \ = 0\n  local collide_left = false\n  local collide_right = false\n  local collide_up_down\
    \ = false\n  local collide_down_up = false\n  local collide_down_right = false\n\
    \  local collide_left_right = false\n  local collide_left_left  = false\n  for\
    \ i=1,n do\n    for j=1,n do\n      if i >= j then\n        local a = math.random(100)\n\
    \        local b = math.random(100)\n        if a < 10 and a > 90 then\n     \
    \     collide = collide + 1\n          collide_left = collide_left or (j > i and\
    \ car_race_collision(j) or true)\n          collide_right = collide_right or (i\
    \ > j and car_race_collision(i) or true)\n          collide_up_down = collide_up_down\
    \ or (j > i and car_race_collision(j) and i > j and car_race_collision(i) or true)\n\
    \          collide_down_up = collide_down_up or (i > j and car_race_collision(j)\
    \ and j > i and car_race_collision(i) or true)\n          collide_down_right =\
    \ collide_down_right or (i > j and car_race_collision(i) and j > i and car_race_collision(i)\
    \ or true)\n          collide_left_right = collide_left_right or (i > j and car_race_collision(i)\
    \ and j > i and car_race_collision(i) or true)\n          collide_left_left =\
    \ collide_left_left or (j > i and car_race_collision(j) and j > i and car_race_collision(i)\
    \ or true)\n        end\n      end\n    end\n  end\n  return collide\nend", " \
    \ if n <= 0 then return 0 end\n  local collisions = 0\n  local prev_collisions\
    \ = 0\n  local prev_id = nil\n  local prev_x = nil\n  local prev_y = nil\n  for\
    \ i=1, n do\n    local id = random(#cars)\n    local x = random(cars[id].x_min,\
    \ cars[id].x_max)\n    local y = random(cars[id].y_min, cars[id].y_max)\n    if\
    \ cars[id].id == prev_id then\n      local dist = math.abs(x - prev_x) * speed\n\
    \      if dist < speed then collisions = collisions + 1 end\n      if prev_x >\
    \ x then collisions = collisions + 1 end\n    else\n      prev_collisions = prev_collisions\
    \ + 1\n      prev_id = id\n      prev_x = x\n      prev_y = y\n    end\n  end\n\
    \  return collisions\nend", "    local car_speed = 10\n    local left_speed =\
    \ 3\n    local right_speed = 3\n    local car_speeds = {left_speed, right_speed}\n\
    \    local car_distances = {2, 1}\n    local car_distances_squared = {left_speed\
    \ ^ 2, right_speed ^ 2}\n    local car_collisions = 0\n    for i = 1, n do\n \
    \       local car_x = math.random(1, 10)\n        local car_y = math.random(1,\
    \ 10)\n        if car_x == car_x then\n            car_collisions = car_collisions\
    \ + 1\n        end\n        for j = 1, car_distances_squared do\n            local\
    \ car_dist_x = car_x - car_x\n            local car_dist_y = car_y - car_y\n \
    \           if car_dist_x ^ 2 + car_dist_y ^ 2 <= car_distances_squared ^ 2 then\n\
    \                local collision_distance_squared = car_distances_squared - car_dist_x\
    \ ^ 2 - car_dist_y ^ 2\n                if collision_distance_squared <= collision_distance_squared\
    \ * collision_distance_squared then\n                    local car_speed_x = car_x\
    \ + car_speed\n                    local car_speed_y = car_y + car_speed\n   \
    \                 if car_speed_x >= 1 and car_speed_x <= 10 and car_speed_y >=\
    \ 1 and car_speed_y <= 10 then\n                        if car_speed_x == left_speed\
    \ and car_speed_y == right_speed then\n                            car_collisions\
    \ = car_collisions + 1\n                        end\n                    end\n\
    \                end\n            end\n        end\n        for j = 1, car_distances\
    \ do\n            local car_dist_x = car_x - car_x\n            local car_dist_y\
    \ = car_y - car_y\n            if car_dist_x ^ 2 + car_dist_y ^ 2 <= car_distances\
    \ ^ 2 then\n                local collision_distance_squared_x = car_distances\
    \ - car_dist_x ^ 2\n                local collision_distance_squared_y = car_distances\
    \ - car_dist_y ^ 2\n                if collision_distance_squared_x <= collision_distance_squared_x\
    \ * collision_distance_squared_x then\n                    if collision_distance_squared_y\
    \ <= collision_distance_squared_y * collision_distance_squared_y then\n      \
    \                  local car_speed_x = car_x + car_speed\n                   \
    \     local car_speed_y = car_y + car_speed\n                        if car_speed_x\
    \ >= 1 and car_speed_x <= 10 and car_speed_y >= 1 and car_speed_y <= 10 then\n\
    \                            if car_speed_x == left_speed and car_", "  local\
    \ count = 0\n  local function distance(x1, y1, x2, y2)\n    return math.abs(x2\
    \ - x1) + math.abs(y2 - y1)\n  end\n  local function collide(xy, x1, y1, x2, y2)\n\
    \    local distance = distance(x1, y1, x2, y2)\n    count = count + 1\n    local\
    \ x = xy % x\n    local y = xy / x\n    return x >= 0 and y >= 0 and x < n and\
    \ y < n and distance <= speed\n  end\n  for x = 1, n do\n    for y = 1, n do\n\
    \      local xy = x * n\n      local x1, y1 = x, y\n      local x2, y2 = x + 1,\
    \ y\n      while x2 < n and y2 < n do\n        if collide(xy, x1, y1, x2, y2)\
    \ then\n          x2 = x2 - 1\n          y2 = y2 - 1\n        else\n         \
    \ break\n        end\n      end\n    end\n  end\n  return count\nend", "   local\
    \ collisions = 0\n   for i=1, n do\n      for j=1, n do\n         if j == i then\n\
    \            continue\n         end\n         if car_race_collision_distance(i,\
    \ j, i) == 0 then\n            collisions = collisions + 1\n         end\n   \
    \      if car_race_collision_distance(j, i, n) == 0 then\n            collisions\
    \ = collisions + 1\n         end\n      end\n   end\n   return collisions\nend",
  "    local count = 0\n    for i = 1, n do\n        for j = i + 1, n do\n       \
    \     -- If cars i and j collide, increment the collision count.\n           \
    \ if car_race(i, j) then\n                count = count + 1\n            end\n\
    \        end\n    end\n    return count\nend", "   if n == 0 then\n      return\
    \ 0\n   end\n   local numcollisions = 0\n   while n ~= 0 do\n      if n % 2 ==\
    \ 0 then\n         numcollisions = numcollisions + car_race_collision(math.floor(n/2))\n\
    \      else\n         n = n - 1\n         numcollisions = numcollisions + car_race_collision(math.floor(n/2))\n\
    \      end\n   end\n   return numcollisions\nend", "\t-- Initialize colliding\
    \ to all cars.\n\tlocal colliding = {}\n\tfor i = 1, n do\n\t\tcolliding[i] =\
    \ 0\n\tend", "    -- We represent each car as a point on the line segment.  We\
    \ use two points:\n    --\n    --     p0 = the origin of the segment\n    -- \
    \    p1 = the point we're colliding with\n    --\n    -- To check for a collision,\
    \ we determine if each segment intersects with\n    -- any other, and if so, whether\
    \ they intersects with the segments they\n    -- are touching.  We need to consider\
    \ all possible line segments, because\n    -- the number of possible line segments\
    \ grows geometrically with the number of\n    -- cars, and there are many segments\
    \ that are extremely long.\n    --\n    -- The algorithm used below is a variation\
    \ of the one given in Chapter 4 of\n    -- the book Artificial Intelligence: A\
    \ Modern Approach, Second Edition, by\n    -- the great Professor Manning publication.",
  "  -- Set the initial velocities to be the same for both sets.\n  -- We don't need\
    \ very high speed or low velocity in our simulations.\n  local left_speed = 1\n\
    \  local right_speed = 1\n  local left_velocity = 0\n  local right_velocity =\
    \ 0\n  local left_collisions = 0\n  local right_collisions = 0", "  local collided\
    \ = 0\n  local c = 0\n  for i = 1, n do\n    if collision(car_race_collision_left)\
    \ then\n      c = c + 1\n    end\n    if collision(car_race_collision_right) then\n\
    \      c = c + 1\n    end\n    collided = collided + c\n  end\n  return collided\n\
    end", "   -- The collision matrix for a race car:\n   -- Cars move right to left,\
    \ collide with right neighbor to left neighbor.\n   -- Cars move left to right,\
    \ collide with left neighbor to right neighbor.\n   -- The matrix is symmetrical;\
    \ that is, the first column of the matrix is the\n   -- same as the last column.\n\
    \   local m = { -- The number of cars in the race.\n      {0,0,0,0,0},\n     \
    \ {0,n,n,n,n,0},\n      {0,n,n,n,n,0},\n      {0,n,n,n,n,0},\n      {0,n,n,n,n,0},\n\
    \   };\n   -- The collision matrix for a race car.\n   local c = { -- The number\
    \ of cars colliding.\n      {0,0,0,0,0},\n      {0,0,0,0,0},\n      {0,0,0,0,0},\n\
    \      {0,0,0,0,0},\n      {0,0,0,0,0},\n   };\n   -- Populate the collision matrix.\n\
    \   for i = 1, n do\n      for j = i + 1, n do\n         -- If the cars are moving\
    \ right to left, car_i collides with car_j.\n         if m[i][j] > 0 then\n  \
    \          -- If the cars are moving left to right, car_j collides with car_i.\n\
    \            if m[j][i] > 0 then\n               -- If the cars are moving right\
    \ to left, car_j collides with car_i.\n               if m[i][j] > m[j][i] then\n\
    \                  -- Car_i collides with car_j, add to collision matrix.\n  \
    \                c[i][j] = c[i][j] + 1;\n                  m[i][j] = 0;\n    \
    \           end\n               -- If the cars are moving left to right, car_i\
    \ collides with car_j.\n               if m[i][j] > m[j][i] then\n           \
    \       -- Car_j collides with car_i, add to collision matrix.\n             \
    \     c[j][i] = c[j][i] + 1;\n                  m[j][i] = 0;\n               end\n\
    \            end\n         end\n      end\n   end\n   -- Return the number of\
    \ collisions.\n   return c[n][n];\nend", '   local collisions = 0', "  -- Initialize\
    \ variables\n  local i = 1\n  local ncollisions = 0\n  local c1, c2, c1n, c2n\n\
    \  local b1, b2, b2n, b3\n  local r1, r2, r3\n  local d1, d2, d3\n  local r1n,\
    \ r2n, r3n\n  local v", "   local collisions = 0\n   for i=1, n do\n      local\
    \ left_car = vehicles[i]\n      for j = i + 1, n do\n         local right_car\
    \ = vehicles[j]\n         local speed = left_car.speed\n         -- If cars are\
    \ moving too fast, they will never collide.\n         if speed < race_length_scaling_factor\
    \ then\n            -- If cars are moving too slow, they will never collide.\n\
    \            if speed > race_length_scaling_factor then\n               -- If\
    \ cars are moving too fast, the race will collide.\n               if speed *\
    \ left_car.speed > speed * right_car.speed then\n                  -- If cars\
    \ are moving too slow, they will never collide.\n                  collisions\
    \ = collisions + 1\n               end\n            else\n               -- If\
    \ cars are moving too slow, they will never collide.\n               collisions\
    \ = collisions + 1\n            end\n         end\n      end\n   end\n   return\
    \ collisions\nend", "  -- Initialize return value.\n  local c = 0\n  -- Loop through\
    \ all pairs of cars.\n  for i = 1, n do\n    for j = i + 1, n do\n      -- If\
    \ i and j collide then increment c\n      if race_car_collide(i, j) then\n   \
    \     c = c + 1\n      -- If j collides with i then decrement c\n      elseif\
    \ race_car_collide(j, i) then\n        c = c - 1\n      -- If neither car collide,\
    \ increment c\n      else\n        c = c + 1\n      end\n    end\n  end\n  return\
    \ c\nend", "    if n == 1 then\n        return 1\n    end", "  local collisions\
    \ = 0\n  local last_race_direction = 0\n  local current_race_direction = 0\n \
    \ local last_speed = 0\n  local current_speed = 0\n  local last_collision_speed\
    \ = 0\n  local current_collision_speed = 0\n  for i = 1, n do\n    if last_race_direction\
    \ ~= current_race_direction then\n      last_collision_speed = math.abs(last_speed\
    \ - current_collision_speed)\n      current_collision_speed = math.abs(last_speed\
    \ - current_speed)\n      last_speed = current_speed\n      current_speed = 0\n\
    \      last_race_direction = current_race_direction\n    end\n    current_speed\
    \ = current_collision_speed * math.cos(math.deg2rad(current_race_direction))\n\
    \    last_speed = last_collision_speed + last_speed\n    last_race_direction =\
    \ current_race_direction\n    if last_speed > current_speed then\n      collisions\
    \ = collisions + 1\n    end\n    current_race_direction = (current_race_direction\
    \ + 1) % 360\n  end\n  return collisions\nend", "  -- Base cases.\n  if n == 1\
    \ then return 0 end\n  if n == 0 then return 1 end", "   -- the number of collisions\
    \ so far\n   local c = 0\n   -- simulate n cars from left to right\n   local car_left\
    \ = car_race(n)\n   -- simulate n cars from right to left\n   local car_right\
    \ = car_race(n - 1)\n   -- loop until no cars collide\n   while car_left ~= 0\
    \ and car_right ~= 0 do\n      if car_left ~= car_right then\n         -- the\
    \ cars collide\n         c = c + 1\n      end\n      -- advance the left car\n\
    \      car_left = car_race(car_left - 1)\n      -- advance the right car\n   \
    \   car_right = car_race(car_right + 1)\n   end\n   return c\nend", "  -- Write\
    \ your code here.\n  local collisions = 0\n  local cars_left = n\n  local cars_right\
    \ = n", "   local result = 0\n   for i = 1, n do\n      for j = 1, n do\n    \
    \     if i == j then\n            -- Don't count a collision if the cars are the\
    \ same car.\n            continue\n         end\n         if car_collision(cars[i],\
    \ cars[j]) then\n            -- A collision has occurred.\n            result\
    \ = result + 1\n         end\n      end\n   end\n   return result\nend", "\t--\
    \  Preconditions\n\tif n ~= nil then\n\t\t-- The parameter is a natural number.\n\
    \t\tif n >= 1 then\n\t\t\t-- n >= 1.\n\t\t\t-- The parameter is a natural number.\n\
    \t\telse\n\t\t\t-- n < 1.\n\t\t\t-- The parameter is not a natural number.\n\t\
    \t\t-- Return the special error condition value.\n\t\t\treturn 0\n\t\tend\n\t\
    else\n\t\t-- The parameter was nil.\n\t\t-- The parameter was nil.\n\t\t-- Return\
    \ the special error condition value.\n\t\treturn 0\n\tend", "\tlocal num_collisions\
    \ = 0\n\twhile n ~= 0 do\n\t\tlocal i = 1\n\t\twhile i < n do\n\t\t\t-- The cars\
    \ driving left to right hit the cars driving right to left.\n\t\t\tif detect_collision(i,\
    \ i - 1) then\n\t\t\t\tnum_collisions = num_collisions + 1\n\t\t\t\ti = i + 1\n\
    \t\t\t\tn = n - 1\n\t\t\telse\n\t\t\t\ti = i + 1\n\t\t\tend\n\t\tend\n\tend\n\t\
    return num_collisions\nend", "  -- The set of collisions is initially empty.\n\
    \  local collisions = 0\n  -- Simulate a large number of times.\n  for i = 1,\
    \ n do\n    -- Create a table of possible collisions\n    local car_collisions\
    \ = {}\n    -- Move the first car n spaces to the left.\n    for j = 1, n do\n\
    \      table.insert(car_collisions, {x = -10, y = -j})\n    end\n    -- Move the\
    \ first car n spaces to the right.\n    for j = 1, n do\n      table.insert(car_collisions,\
    \ {x = 10, y = -j})\n    end\n    -- Set the current car to collide with the first\
    \ car\n    table.insert(car_collisions, {x = 0, y = -1})\n    -- Move all the\
    \ cars in the table n spaces away from the current car\n    for _, car in ipairs(car_collisions)\
    \ do\n      table.insert(car_collisions, {x = -car.x, y = car.y})\n    end\n \
    \   -- Move all the cars in the table n spaces away from the current car\n   \
    \ for _, car in ipairs(car_collisions) do\n      table.insert(car_collisions,\
    \ {x = car.x, y = -car.x})\n    end\n    -- Move all the cars in the table n spaces\
    \ away from the current car\n    for _, car in ipairs(car_collisions) do\n   \
    \   table.insert(car_collisions, {x = -car.x, y = car.x})\n    end\n    -- Move\
    \ all the cars in the table n spaces away from the current car\n    for _, car\
    \ in ipairs(car_collisions) do\n      table.insert(car_collisions, {x = car.x,\
    \ y = -car.x})\n    end\n    -- Move all the cars in the table n spaces away from\
    \ the current car\n    for _, car in ipairs(car_collisions) do\n      table.insert(car_collisions,\
    \ {x = -car.x, y = car.x})\n    end\n    -- Move all the cars in the table n spaces\
    \ away from the current car\n    for _, car in ipairs(car_collisions) do\n   \
    \   table.insert(car_collisions, {x = car.x, y = -car.x})\n    end\n    -- Move\
    \ all the cars in the table n spaces away from the current car\n    for _, car\
    \ in ipairs(car_collisions) do\n      table.insert(car_collisions, {x = -car.x,\
    \ y = car.x})\n    end\n    -- Move all the cars in the table n spaces away from\
    \ the current car\n    for _, car in ipairs(car_collisions) do\n      table.insert(car_collisions,\
    \ {x = car.x, y = -car.x})\n    end\n    -- Move all the cars in the table n spaces ",
  "  local i\n  for i = 1, n do\n    local a = math.random(math.PI / 2, math.pi *\
    \ 3 / 2)\n    local d = math.random(math.pi / 2, 2 * math.pi)\n    local t = a\n\
    \    local count = 0\n    while t > math.pi do\n      local t2 = math.random(math.PI\
    \ / 2, math.pi * 3 / 2)\n      if t2 > t then\n        local tmp = t\n       \
    \ t = t2\n        t2 = tmp\n      end\n      count = count + 1\n    end\n    return\
    \ count\n  end\nend", "   for i=1, n do\n      -- Find the first collision.\n\
    \      for j=i+1, n do\n         -- Stop looking after a collision is found.\n\
    \         if car_race_collision_j(i) == 1 then\n            -- The collision occurs\
    \ at index j.\n            return j\n         end\n      end\n   end\n   return\
    \ 0\nend\n</cell>\n<code language=xeus-cling-cpp14>\nprint( 'car_race_collision(8)\
    \ = ' .. car_race_collision(8) )\n</cell>\n<text>\nExercise: Implement a version\
    \ of car_race_collision() that takes advantage of the fact that the cars stop\
    \ one step per time step.\nHint: You'll need to use the current frame velocity.",
  "   -- The first step is to create a list of all cars on the road,\n   -- starting\
    \ from some arbitrary car.\n   local collisions = 0\n   local car_x = 0.5 * (x[0]\
    \ - x[1])\n   local car_y = 0.5 * (y[0] - y[1])\n   local car_angle = 0.5 * (x[4]\
    \ - y[4])\n   local car_length = math.sqrt(car_x * car_x + car_y * car_y)\n  \
    \ for i = 1, n do\n      local car_x = x[i]\n      local car_y = y[i]\n      local\
    \ car_angle = y[4]\n      local car_length = math.sqrt(car_x * car_x + car_y *\
    \ car_y)\n      -- The next step is to create a list of all cars that are colliding\
    \ with car\n      -- i.\n      local collision_x = car_x - car_length * math.cos(car_angle)\n\
    \      local collision_y = car_y - car_length * math.sin(car_angle)\n      collision_x\
    \ = collision_x * math.cos(car_angle) - car_x * math.sin(car_angle)\n      collision_y\
    \ = collision_y * math.cos(car_angle) + car_y * math.sin(car_angle)\n      local\
    \ other_x = car_x - collision_x\n      local other_y = car_y - collision_y\n \
    \     if other_x * other_x + other_y * other_y < 0.5 then\n         collisions\
    \ = collisions + 1\n      end\n   end\n   return collisions\nend\n</cell>\n<text>\n\
    And finally, we have the function which determines if a car collides with a set\
    \ of cars.  In this case, we assume that a car will not collide with itself, and\
    \ we know that it is impossible for a car to collide with itself.", "  -- Based\
    \ on the following definition:\n  --     If two cars collide, the car on the left\
    \ is stronger.\n  local CollisionCount = 0\n  local carsOnRightToLeft = math.random(1,\
    \ n+1)\n  for i = 1, carsOnRightToLeft do\n    local carsOnLeftToRight = n - i\n\
    \    local carsOnLeftToRightCollisions = math.random(1, carsOnLeftToRight)\n \
    \   local carsOnLeftToRightCollisionsWithoutColliding = math.random(1, carsOnLeftToRight-1)\n\
    \    if carsOnLeftToRightCollisionsWithoutColliding ~= 0 then\n      carsOnLeftToRightCollisionsWithoutColliding\n\
    \    else\n      CollisionCount = CollisionCount + 1\n    end\n  end\n  return\
    \ CollisionCount\nend", "    local i = 0\n    local count = 1\n    while i < n\
    \ do\n        -- Set the start locations of each car\n        local x0 = car_start_locations[i]\n\
    \        local y0 = car_start_locations[i + 1]\n        local z0 = car_start_locations[i\
    \ + 2]\n        -- Set the end locations of each car\n        local x1 = car_start_locations[i\
    \ + 3]\n        local y1 = car_start_locations[i + 4]\n        local z1 = car_start_locations[i\
    \ + 5]\n        -- Set the speed of each car\n        local v0 = car_start_speeds[i]\n\
    \        local v1 = car_start_speeds[i + 1]\n        -- Set the acceleration of\
    \ each car\n        local a0 = car_start_accelerations[i]\n        local a1 =\
    \ car_start_accelerations[i + 1]\n        -- Set the initial angle of each car\n\
    \        local a0 = car_start_angles[i]\n        -- Set the initial angular velocity\
    \ of each car\n        local w0 = car_start_angular_velocity[i]\n        -- Set\
    \ the initial angular acceleration of each car\n        local w1 = car_start_angular_accelerations[i]\n\
    \        -- Set the initial angular acceleration of each car\n        local b0\
    \ = car_start_angular_accelerations[i + 1]\n        -- Calculate the angle difference\
    \ in radians between each pair of cars\n        local da = (a1 - a0) / (x1 - x0)\n\
    \        -- Calculate the angular velocity difference in radians between each\
    \ pair of cars\n        local dw = (w1 - w0) / (x1 - x0)\n        -- Calculate\
    \ the angular acceleration difference in radians between each pair of cars\n \
    \       local db = (b1 - b0) / (x1 - x0)\n        -- Find the difference in the\
    \ angle between the first pair of cars and the second pair\n        local angle\
    \ = math.atan((y1 - y0) / math.sqrt(math.pow((x1 - x0), 2) + math.pow((y1 - y0),\
    \ 2)))\n        -- Find the angle difference in degrees between the initial angle\
    \ of the first pair of cars and the final angle of the first pair of cars\n  \
    \      local delta = (angle - a0) / 180\n        -- Find the change in the angular\
    \ velocity between the initial angular velocity of the first pair of cars and\
    \ the final angular velocity of the first pair of cars\n        local delta_angular_velocity\
    \ = w0 - w1\n        -- Find the change in the angular acceleration between the\
    \ initial angular acceleration of the first pair of cars and the final angular\
    \ acceleration of the first pair of cars\n        local delta_angular_acceleration\
    \ = b0 - b1\n        -- Find the time step in which the cars are going to collide\n\
    \        local dt = delta_angular_acceleration / delta_angular_velocity / math.cos(math.rad(delta_angular_velocity))\n\
    \        -- Find the distance ", "\tlocal count = 0\n\tfor i = 2, n do\n\t\tlocal\
    \ car_1 = i - 1\n\t\tlocal car_2 = i\n\t\tlocal car_1_speed = cars[car_1].speed\n\
    \t\tlocal car_2_speed = cars[car_2].speed\n\t\tif car_1_speed > car_2_speed then\n\
    \t\t\tcars[car_2].speed = car_1_speed\n\t\telse\n\t\t\tcars[car_1].speed = car_2_speed\n\
    \t\tend\n\tend\n\tcount = #cars - 1 - count\n\tassert(count >= 0, \"Number of\
    \ collisions negative\")\n\treturn count\nend", "  local nCars = n + 1\n  local\
    \ count = 0\n  local i = 1\n  while i <= n do\n    for j = i + 1, nCars do\n \
    \     local car1 = game:GetVehiclePedIsIn(i - 1)\n      local car2 = game:GetVehiclePedIsIn(j)",
  "    local maxspeed = math.sqrt(math.sqrt(n)^2 - n)\n    local counter = 1\n   \
    \ local x\n    for x = 1, n do\n        local vx = x - 1\n        local vy = math.sin(math.rad(360\
    \ * math.atan2(vx, vx)))\n        local speed = math.sqrt(vx*vx + vy*vy)\n   \
    \     if speed > maxspeed then\n            local y\n            for y = 1, n\
    \ do\n                local vy = y - 1\n                local vx = math.sin(math.rad(360\
    \ * math.atan2(vy, vy)))\n                if vx ~= 0 then\n                  \
    \  local speed = math.sqrt(vx*vx + vy*vy)\n                    if speed > maxspeed\
    \ and speed < maxspeed + 1 then\n                        return counter\n    \
    \                end\n                end\n            end\n        end\n    \
    \    counter = counter + 1\n    end\n    return 0\nend", "  -- We will assume\
    \ that the road is perfectly straight and has no intersections\n  -- or intersections\
    \ of intersections.\n  -- We assume that the road is perfectly straight and has\
    \ no intersections\n  -- or intersections of intersections.", "   -- Create a\
    \ table of initial speeds, one for each car.\n   local car_speeds = {0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.",
  "  local collisions = 0\n  for i = 1, n do\n    local j = i - 1\n    local speed\
    \ = n * 2 + 1\n    while speed > 0 do\n      if i >= n or j >= n or speed*2 >=\
    \ j*2 then\n        break\n      end\n      if math.abs(j - i) == 2 then\n   \
    \     -- Cars collide if they're at the exact same position, but don't collide\
    \ if they're in different halves.\n        collisions = collisions + 1\n     \
    \ end\n      j = j - 1\n      speed = speed - 1\n    end\n  end\n  return collisions\n\
    end", '  local collisions = 0', "   --\n   -- The car-race collision problem consists\
    \ of finding the longest line that is\n   -- infinitely long (infinitely steep)\
    \ but still infinitely long.\n   -- Here we find this longest line.\n   --\n \
    \  -- The longest line is given in the following equation.\n   -- Let (x0,y0)\
    \ be the position of the starting car and\n   -- (x1,y1) be the position of the\
    \ ending car.\n   -- Then, the longest line is given by\n   --     x = x1 + (x0\
    \ - x1) / (y0 - y1)\n   --     y = y1 + (x0 - x1) * (y1 - y0) / (x0 - x1)\n  \
    \ --\n   -- In this example, the line is given by x1 = 0.\n   --\n   -- The cars\
    \ start in the middle, (x0,y0)\n   -- and move to (x1,y1).\n   --\n   -- The initial\
    \ state is given by\n   -- |x0| = |y1| = 1, and we start in (x1,y1).\n   --\n\
    \   -- The car race problem is to find the longest line, given by the equation\n\
    \   --     x = x1 + (x0 - x1) / (y0 - y1)\n   --     y = y1 + (x0 - x1) * (y1\
    \ - y0) / (x0 - x1)\n   --\n   -- The initial line is given by\n   --     x =\
    \ x1 + (x0 - x1) / (y0 - y1)\n   --     y = y1 + (x0 - x1) * (y1 - y0) / (x0 -\
    \ x1)\n   --\n   -- Our initial line is (x1,y1).  To solve the problem, we set\
    \ x1 = 0, y1 = 1, and\n   -- solve the equation for x.\n   -- The solution is\
    \ given by\n   --     x = x1 + (x0 - x1) / (y0 - y1)\n   --     y = y1 + (x0 -\
    \ x1) * (y1 - y0) / (x0 - x1)\n   --\n   -- Since y = 0 for x = x1,\n   --   x\
    \ = x1 + (x0 - x1) * (y1 - y0) / (x0 - x1) = y1 + (x0 - x1) * (1 - y0) / (x0 -\
    \ x1)\n   --\n   -- Therefore, solve the equation for x:\n   --     x = x1 + (x0\
    \ - x1) * (1 - y0) / (x0 - x1)\n   --\n   -- The car race problem can be solved\
    \ in one line by computing the coefficients\n   -- of the linear equation, given\
    \ by\n   --     y = (x", "  -- Base case\n  if n==1 then\n    return 0\n  end",
  "    local collided = {}\n    local num_collisions = 0\n    local i\n    for i =\
    \ 1, n do\n        local j = i\n        while j ~= 1 do\n            local collision\n\
    \            if j > 1 and i < n do\n                collision = car_race_collision(n\
    \ - i - 1)\n            end\n            if collision then\n                table.insert(collided,\
    \ {i, j})\n                num_collisions = num_collisions + 1\n            end\n\
    \            j = j - 1\n        end\n    end\n    return num_collisions\nend",
  "  if n <= 0 then return 0 end\n  local collisions = 0\n  for i=1,n do\n    local\
    \ j = n - i - 1\n    for j=1,n do\n      local x0,y0,z0,x1,y1,z1 = getpos2(i),getpos2(j),getpos2(i),getpos2(j),getpos2(j+1)\n\
    \      local dx = x1 - x0\n      local dy = y1 - y0\n      local dz = z1 - z0\n\
    \      local dist = math.sqrt(dx*dx+dy*dy+dz*dz)\n      if dist > 0.3 then\n \
    \       local nx,ny,nz = x0 + dx*0.1,y0 + dy*0.1,z0 + dz*0.1\n        if x0 <\
    \ x1 or y0 < y1 or z0 < z1 then\n          local nx,y,z = x0 + dx,y0 + dy,z0 +\
    \ dz\n          for k=1,4 do\n            local vx,vy,vz = getvel2(nx,ny,nz,k)\n\
    \            local a,b,c = vx+dx,vy+dy,vz+dz\n            if a < 0 or b < 0 or\
    \ c < 0 or a + b > dist or c + b > dist or a + c > dist or c + c > dist then\n\
    \              local a,b,c = vx,vy,vz\n              collisions = collisions +\
    \ 1\n              return collisions\n            end\n          end\n       \
    \ end\n      end\n    end\n  end\n  return collisions\nend", "  -- Initialize\
    \ variables\n  local collisions = 0\n  local n0 = n\n  local n1 = n\n  local v0\
    \ = 0.0\n  local v1 = 0.0", "   assert(n >= 1, \"Must have at least one car to\
    \ collide\")\n   local collisions = 0\n   for i = 1, #cars do\n      for j = #cars,\
    \ 1, -1 do\n         local a = cars[i]\n         local b = cars[j]\n         local\
    \ xd = b.x - a.x\n         local yd = b.y - a.y\n         local vd = xd * xd +\
    \ yd * yd\n         local dist = math.abs(xd)\n         if xd == 0 and yd == 0\
    \ and dist < n then\n            collisions = collisions + 1\n            break\n\
    \         end\n      end\n   end\n   return collisions\nend", "   -- Based on\
    \ the following pseudo-code,\n   -- let L be an n-ary tree with the root being\
    \ the starting position.\n   --     Then, for every node L has a pointer to an\
    \ n-ary tree L'\n   --     which contains all the nodes of L but in a different\
    \ order.\n   --     L' can be thought of as a new tree that starts in the starting\n\
    \   --     position and then moves toward each node of L.\n   --     For every\
    \ node n of L, the algorithm recursively calls\n   --     itself recursively to\
    \ find all nodes of L' that might collide.\n   --     For each such node, the\
    \ algorithm will check if any node in L'\n   --     could move to the same position\
    \ that n did before this node was\n   --     visited.\n   --     If so, that new\
    \ node will have a pointer to its predecessor.\n   --     The predecessor of n\
    \ will never be visited again; instead, the node\n   --     will contain a pointer\
    \ to the new node that was created by the\n   --     recursive call.\n   --  \
    \   If such a predecessor had already been visited, then that new node\n   --\
    \     will have no pointer to a predecessor; instead, the new node will have\n\
    \   --     a pointer to the predecessor of its predecessor.\n   --     If all\
    \ predecessors of n have been visited, then the nodes of L'\n   --     might collide.\n\
    \   --     If no predecessors of n have been visited, then there is no node of\
    \ L'\n   --     that could collide; instead, there is only a node n of L that\
    \ could\n   --     collide\n   --     If the new node does have a pointer to its\
    \ predecessor, then it can\n   --     collide.\n   --     If a node n in L' does\
    \ have a pointer to its predecessor, then n\n   --     will have a pointer to\
    \ its predecessor.\n   --     If all the nodes of L have been visited, then it\
    \ might collide.\n   --     If L' has reached a leaf node, then it might collide.\n\
    \   --     If L' has reached a node with a pointer to a predecessor, then it might\n\
    \   --     collide.\n   --     If a node n in L' has a pointer to a predecessor,\
    \ then n will have\n   --     a pointer to its predecessor.\n   --     If L' has\
    \ reached a leaf node, then it might collide.\n   --     ", "   local i = 1\n\
    \   local num = 0\n   while i <= n do\n      num = num + 1\n      i = i + 2\n\
    \      while i <= n do\n         if cars_left_to_right[i] ~= nil then\n      \
    \      local left_id = cars_left_to_right[i]:getID()\n            if cars_right_to_left[left_id]\
    \ ~= nil then\n               local right_id = cars_right_to_left[left_id]:getID()\n\
    \               if cars_left_to_right[i] ~= cars_right_to_left[left_id] then\n\
    \                  return num\n               end\n            end\n         end\n\
    \         i = i + 2\n      end\n   end\n   return num\nend", "    local max_x\
    \ = 0\n    local max_y = 0\n    for i=1, n do\n        local min_x = max_x\n \
    \       local min_y = max_y\n        local x = math.random(min_x, max_x)\n   \
    \     local y = math.random(min_y, max_y)\n        max_x = max_x\n        max_y\
    \ = max_y\n        if i == 1 then\n            -- Cars are at position (x, y).\n\
    \            -- Find the distance between them.\n            local d = math.sqrt(math.pow(x,\
    \ 2) - math.pow(y, 2))\n            if d > max_d then\n                max_d =\
    \ d\n                max_x = x\n                max_y = y\n            end\n \
    \       else\n            -- Cars are moving at an angular speed of speed = 1.\n\
    \            -- The motion is described by\n            -- x = x' = x0 + v * t\n\
    \            -- y = y' = y0 + v * t\n            -- where (x', y') is the new\
    \ position and v is the velocity,\n            -- both measured in radians per\
    \ second.\n            -- The acceleration is constant because it's accelerating\
    \ at constant speed.\n            -- The constant acceleration is c = 9.81 * 10^-6\
    \ m/s/s.\n            -- The final motion is then\n            -- x = x' + v *\
    \ t + 0.5 * 9.81 * (v * t^2)\n            -- y = y' + v * t + 0.5 * 9.81 * (v\
    \ * t^2)\n            local v = (i - 1) * speed\n            local c = 9.81 *\
    \ 10 * 10 * 10 * 10 * 10 * 10\n            local xt = x\n            local yt\
    \ = y\n            local xtt = xt + v * t + 0.5 * c * math.pow(v, 2)\n       \
    \     local ytt = yt + v * t + 0.5 * c * math.pow(v, 2)\n            if math.abs(xtt\
    \ - xt) < max_speed then\n                -- If xt is not too far from x, then\
    \ we have collided with x\n                max_speed = math.abs(xtt - xt)\n  \
    \              max_x = xt\n                max_y = yt\n            elseif math.abs(ytt\
    \ - yt) < max_speed then\n                -- If yt is not too far from y, then\
    \ we have collided with y\n                max_speed = math.abs(ytt - yt)\n  \
    \              max_x = xt\n                max_y = ytt\n            end\n    \
    \    end\n    end\n    return max_speed\nend", "  local count = 0\n  for i = 1,\
    \ n do\n    for j = 1, n do\n      -- First and last positions can be the same.\
    \ Skip them.\n      if i != j and cars_speed[i - 1][j] == cars_speed[i][j] and\
    \ cars_speed[i][j] == 0 then\n        count = count + 1\n      end\n    end\n\
    \  end\n  return count\nend", "    local collisions = 0\n    local i = 1\n   \
    \ local speed = 1\n    while i <= n do\n        local collisions = collisions\
    \ + 1\n        local right = math.ceil(i + speed - 1)\n        local left = i\
    \ - 1\n        local speed = math.ceil(math.sqrt(speed))\n        speed = math.floor(speed)\n\
    \        if right > n or left < 1 then break end\n        if i ~= left then\n\
    \            local x = left\n            local y = right\n            while x\
    \ > left do\n                local c = car_collision(x, y)\n                if\
    \ c[1] ~= car_collision(y, x)[1] then break end\n                x = x - c[1]\n\
    \                y = y - c[2]\n            end\n        end\n        i = i + speed\n\
    \    end\n    return collisions\nend", "   local count_left = 0\n   local count_right\
    \ = 0\n   local left_velocity = 1.\n   local right_velocity = 1.", "   local collided\
    \ = {}\n   local collisions = 0\n   for i = 0, n - 1 do\n      local next1 = i\
    \ + 1\n      if next1 > n then next1 = 1 end\n      local next2 = next1 + 1\n\
    \      if next2 > n then next2 = 1 end\n      for j = 0, n - 1 do\n         local\
    \ next3 = j + 1\n         if next3 > n then next3 = 1 end\n         local next4\
    \ = next3 + 1\n         if next4 > n then next4 = 1 end\n         for k = 0, n\
    \ - 1 do\n            local next5 = k + 1\n            if next5 > n then next5\
    \ = 1 end\n            local next6 = next5 + 1\n            if next6 > n then\
    \ next6 = 1 end\n            collisions = collisions + car_race_collision_helper(i,\
    \ j, k, n, collided)\n         end\n      end\n   end\n   return collisions\n\
    end", "   local num_collision = 0\n   for i=1, n do\n      for j=1, n do\n   \
    \      if i == j then\n            num_collision = num_collision + 1\n       \
    \  else\n            if car_race(i+1, j) == car_race(i, j+1) then\n          \
    \     num_collision = num_collision + 1\n            end\n         end\n     \
    \ end\n   end\n   return num_collision\nend", "   local count = 0\n   for i =\
    \ 1, n do\n      for j = 1, n do\n         if i == j or i == n-1 or j == n-1 then\n\
    \            count = count + 1\n         end\n      end\n   end\n   return count\n\
    end", "   -- The function first checks to see if the given number of cars collide.\n\
    \   -- If so, return the number of collisions.  If not, return 0.\n   if n >=\
    \ (#cars) then return 0 end\n   -- The initial number of collisions.\n   local\
    \ collisions = 0\n   -- The loop starts out by incrementing the speed of the cars\
    \ one at a time.\n   -- If the cars collide, then add 1 to the counter.\n   for\
    \ i=1,n do\n      -- Set the current speed of the car to its current speed and\
    \ subtract one\n      -- to adjust for the fact that we're now moving left.\n\
    \      cars[i].speed = cars[i].speed - 1\n      -- If the cars collide, then add\
    \ 1 to the counter.\n      if car_collision(cars[i]) then collisions = collisions\
    \ + 1 end\n   end\n   return collisions\nend", "    local collisions = 0\n   \
    \ local start\n    local end\n    local car_start\n    local car_end\n    local\
    \ car_distance\n    local distance\n    local car_speed\n    local speed", '  local
    num_collisions = 0', "  -- We use the same variables as in CarRacingCollision.\n\
    \  local num_collisions = 0\n  local i = 1\n  while i <= n do\n    local collide\
    \ = collision_point_of_car_race(i)\n    if collide then\n      num_collisions\
    \ = num_collisions + 1\n    end\n    i = i + 2\n  end\n  return num_collisions\n\
    end", "  -- Based on http://www.iquilezles.org/www/articles/snooker/snooker.htm\n\
    \  -- By Brian Snook\n  -- Collision Detection Method\n  -- by John Wiley & Sons,\
    \ 2003\n  -- Modifications: J. W. Maddock 2001, Mark Johnson", "   -- the two\
    \ race cars are perfectly aligned.  But we know for sure that the race cars\n\
    \   -- are moving at the opposite speeds.  So we need to detect when they collide.\n\
    \   -- The basic strategy is for each car to keep track of where it is on the\
    \ line of\n   -- its current speed and where it is on the line of its speed when\
    \ it is moving\n   -- right to left.  When it moves left to right, it can detect\
    \ the collision by\n   -- looking at the positions of both cars on the line of\
    \ their speeds.\n   --\n   -- This collision detection algorithm is from the \"\
    Hackers Delight\" book, by Jerome Kelly.\n   -- http://www.amazon.com/Hackers-Delight-Jerome-Kelly/dp/0321356683\n\
    \   --\n   -- The basic strategy is to keep a table of car positions for both\
    \ the current\n   -- speed and the speed when it is moving right to left.  When\
    \ car_race_collision is\n   -- called, it looks up the car position on the line\
    \ of its current speed.\n   -- If a collision occurs, that means two cars are\
    \ moving exactly the same distance in\n   -- the same speed, and that means they\
    \ just stopped moving, so they collided with each\n   -- other when they moved\
    \ exactly the same distance.\n   -- If no collisions occur, then they must have\
    \ moved farther apart in speed than they have\n   -- in distance.  We now have\
    \ the cars on either side of the other car on the line of its\n   -- current speed.\
    \  So we move them to that new location and let them continue moving.", "   --\
    \ The maximum allowed time between two cars that are allowed to collide.\n   local\
    \ max_time = max_car_time_for_collision\n   -- The speed at which cars are allowed\
    \ to collide.\n   local max_speed = max_car_speed_for_collision\n   -- The distance\
    \ at which cars are allowed to collide.\n   local max_dist = max_car_dist_for_collision\n\
    \   local function collision_time_function(t, a, b)\n      -- The time of collision\
    \ between cars a and b.\n      local t\n      -- The time of collision between\
    \ cars a and b.\n      local time_of_collision\n      -- The distance at which\
    \ cars stop moving when they collide.\n      local car_stop_distance\n      --\
    \ The speed at which cars stop moving when they collide.\n      local car_stop_speed\n\
    \      -- The time at which cars stop moving when they collide.\n      local car_stop_time\n\
    \      -- The total time cars are allowed to collide.\n      local total_time\n\
    \      -- The amount of time cars are allowed to collide with each other.\n  \
    \    local car_collision_distance\n      -- The amount of speed cars are allowed\
    \ to collide with each other.\n      local car_collision_speed\n      -- The amount\
    \ of time cars are allowed to collide with each other.\n      local car_collision_time\n\
    \      -- The amount of time cars are allowed to collide with each other.\n  \
    \    local car_collision_distance\n      -- The amount of speed cars are allowed\
    \ to collide with each other.\n      local car_collision_speed\n      -- The number\
    \ of times cars are allowed to collide.\n      local car_collision_attempt\n \
    \     -- The amount of time cars are allowed to collide with each other.\n   \
    \   local car_collision_distance\n      -- The amount of speed cars are allowed\
    \ to collide with each other.\n      local car_collision_speed\n      -- The number\
    \ of times cars are allowed to collide.\n      local car_collision_attempt\n \
    \     -- The amount of time cars are allowed to collide with each other.\n   \
    \   local car_collision_distance\n      -- The amount of speed cars are allowed\
    \ to collide with each other.\n      local car_collision_speed\n      -- The amount\
    \ of time cars are allowed to collide with each other.\n      local car_collision_attempt\n\
    \      -- The amount of time cars are allowed to collide with each other.\n  \
    \    local car_collision_distance\n      -- The amount of speed cars are allowed\
    \ to collide with each other.\n      local car_collision_speed\n      -- The amount\
    \ of time cars are allowed to collide with each other.\n      ", "  -- The left\
    \ and right sets of n cars are initialized to have no cars colliding.\n  local\
    \ left_set, right_set = set(), set()\n  -- The total number of cars colliding.\n\
    \  local num_cars_colliding = 0", "   -- The first line is a table of n lists,\
    \ each containing two cars.  The cars list\n   -- contains all cars in the world,\
    \ sorted by their x coordinate.\n   -- The second line is a table of n lists,\
    \ each containing two cars.  The\n   -- cars list contains all cars in the world,\
    \ sorted by their y coordinate.\n   -- The third line is a table of n lists, each\
    \ containing two cars.  The cars\n   -- list contains all cars in the world, sorted\
    \ by their x coordinate.\n   -- The fourth line is a table of n lists, each containing\
    \ two cars.  The\n   -- cars list contains all cars in the world, sorted by their\
    \ y coordinate.\n   local cars = table.replicate(n, nil)\n   local cars_sorted\
    \ = table.replicate(n, nil)\n   local cars_x = table.replicate(n, nil)\n   local\
    \ cars_y = table.replicate(n, nil)\n   \n   for x = 1, n do\n      -- Initialize\
    \ all the cars in the world into their starting x position.\n      -- The cars_sorted\
    \ table contains all the cars in the world sorted by their\n      -- x position.\n\
    \      local start_x = math.random(1, 800)\n      cars[x - 1] = start_x\n    \
    \  cars_sorted[x - 1] = start_x\n      -- Initialize all the cars in the world\
    \ into their starting y position.\n      -- The cars_sorted table contains all\
    \ the cars in the world sorted by their\n      -- y position.\n      local start_y\
    \ = math.random(1, 600)\n      cars_y[x - 1] = start_y\n      cars_sorted[x -\
    \ 1] = start_y\n   end\n   \n   for x = 1, n do\n      -- Move all the cars in\
    \ the world.\n      for y = 1, n do\n         -- Move the car in the x direction\
    \ until it collides with the other car.\n         -- This prevents cars that move\
    \ in the same direction from colliding.\n         local collided = false\n   \
    \      while not collided do\n            -- Pick a random car from which to move\
    \ and move that car.\n            local rand = math.random(1, #cars_sorted)\n\
    \            local car = cars_sorted[rand]\n            -- Move the car.\n   \
    \         cars_sorted[rand] = car + (math.random(1, #cars_sorted) - 1)\n     \
    \       -- Check if it collides with the other car.\n            if cars_sorted[rand]\
    \ == car then\n               collided = true\n            end\n         end\n\
    \         -- Move the car in the y direction until it collides with the other ",
  "  local collisions = 0\n  local last\n  for i = 1, n do\n    local collision\n\
    \    repeat\n      collision = math.random(2 * math.pi)\n    until collision >\
    \ math.pi\n    if collision < math.pi - race then\n      collisions = collisions\
    \ + 1\n      last = i\n    end\n  end\n  return collisions, last\nend", "    --\
    \ the cars racing around a track\n    local racecar1 = racecar:new()\n    racecar1:set_position({math.random(-3000,\
    \ +3000), math.random(-3000, +3000)})\n    racecar1:set_heading_deg(math.random(0,\
    \ 360))", "    local collisions = 0\n    for i = 1, n do\n        for j = n -\
    \ 1, i, -1 do\n            if car_distance(game.players[i], game.players[j]) >=\
    \ game.players[i].speed + game.players[j].speed then\n                collisions\
    \ = collisions + 1\n            end\n        end\n    end\n    return collisions\n\
    end", "    local collisions = 0\n    local i = 1\n    while i < n do\n       \
    \ local j = n - i - 1\n        if j > 1 then\n            local collision_found\
    \ = false\n            for k = j - 1; k >= 1; k = k - 1 do\n                if\
    \ car_race_collision(n + k) == n then\n                    collision_found = true\n\
    \                    collisions = collisions + 1\n                end\n      \
    \      end\n            if collision_found == false then\n                collisions\
    \ = collisions + 1\n            end\n        end\n        i = i + 1\n    end\n\
    \    return collisions\nend\n</cell>\n<cell>"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
