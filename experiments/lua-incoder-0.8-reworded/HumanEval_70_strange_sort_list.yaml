name: HumanEval_70_strange_sort_list
language: lua
prompt: "-- Given table of integers, return table in strange order.\n-- Strange sorting,\
  \ is when you start with the minimum value,\n-- then maximum of the remaining integers,\
  \ then minimum and so on.\n-- Examples:\n-- >>> strange_sort_list({1, 2, 3, 4})\n\
  -- {1, 4, 2, 3}\n-- >>> strange_sort_list({5, 5, 5, 5})\n-- {5, 5, 5, 5}\n-- >>>\
  \ strange_sort_list({})\n-- {}\nlocal function strange_sort_list(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = strange_sort_list\n\
  \    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 4, 2, 3})\n    lu.assertEquals(candidate({5,\
  \ 6, 7, 8, 9}), {5, 9, 6, 8, 7})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5}),\
  \ {1, 5, 2, 4, 3})\n    lu.assertEquals(candidate({5, 6, 7, 8, 9, 1}), {1, 9, 5,\
  \ 8, 6, 7})\n    lu.assertEquals(candidate({5, 5, 5, 5}), {5, 5, 5, 5})\n    lu.assertEquals(candidate({}),\
  \ {})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7, 8}), {1, 8, 2, 7, 3,\
  \ 6, 4, 5})\n    lu.assertEquals(candidate({0, 2, 2, 2, 5, 5, -5, -5}), {-5, 5,\
  \ -5, 5, 0, 2, 2, 2})\n    lu.assertEquals(candidate({111111}), {111111})\nend\n\
  \nos.exit(lu.LuaUnit.run())"
completions: ["  local minimum, maximum = lst[1], lst[#lst]\n  local i, j, k = 1,\
    \ #lst, 1\n  while i < j do\n    local smallest_k = minimum\n    if lst[i] ==\
    \ smallest_k then\n      smallest_k = lst[i]\n    end\n    local biggest_k = maximum\n\
    \    if lst[i] == biggest_k then\n      biggest_k = lst[i]\n    end\n    lst[i],\
    \ lst[j] = lst[j], lst[i]\n    minimum = smallest_k\n    maximum = biggest_k\n\
    \    i = i + 1\n    j = j - 1\n    k = k + 1\n  end\n  return lst\nend", "  local\
    \ sorted\n  local min = lst[1]\n  local max = lst[1]\n  for i = 2, #lst do\n \
    \   if lst[i] > max then max = lst[i] end\n    if lst[i] < min then min = lst[i]\
    \ end\n  end\n  local i = 2\n  while i <= #lst do\n    sorted = {}\n    if lst[i]\
    \ > max then\n      table.insert(sorted,lst[i])\n      table.insert(sorted,max)\n\
    \      i = i + 1\n    else\n      table.insert(sorted,min)\n      table.insert(sorted,lst[i])\n\
    \      i = i + 1\n    end\n    if i == #lst then\n      return sorted\n    end\n\
    \    if lst[i] < min then\n      table.insert(sorted,lst[i])\n      table.insert(sorted,min)\n\
    \      i = i + 1\n    end\n    if i == #lst then\n      return sorted\n    end\n\
    \  end\nend", "    local sorted_lst = {}\n    local min = lst[1]\n    local max\
    \ = lst[1]\n    for _, v in ipairs(lst) do\n        if v < min then\n        \
    \    min = v\n        end\n        if v > max then\n            max = v\n    \
    \    end\n        table.insert(sorted_lst, v)\n    end\n    table.sort(sorted_lst)\n\
    \    for i = 2, #sorted_lst do\n        sorted_lst[i] = sorted_lst[i - 1]\n  \
    \  end\n    return sorted_lst\nend", "  local i = 0\n  local j = #lst\n  local\
    \ lst2 = {}\n  local swapped\n  while j < i do\n    swapped = false\n    for index\
    \ = i, j do\n      if lst[index] < lst[index + 1] then\n        swap(i, index,\
    \ lst[index], lst[index + 1], lst2)\n        i = index + 1\n        j = index\n\
    \        swapped = true\n      end\n    end\n    if not swapped then\n      i\
    \ = i + 1\n    end\n  end\n  return lst2\nend", "    local keys = {}\n    for\
    \ _, i in pairs(lst) do\n        table.insert(keys, i)\n    end\n    table.sort(keys)\n\
    \    local out = {}\n    for _, i in pairs(keys) do\n        table.insert(out,\
    \ lst[i])\n    end\n    return out\nend", "  local sorted_lst = lst\n  -- Sort\
    \ in the following order:\n  -- 1) the minimum value\n  -- 2) the maximum value\n\
    \  -- 3) the minimum of minimum value\n  -- 4) the maximum of maximum value\n\
    \  -- 5) the maximum of minimum value\n  -- 6) the minimum of maximum value\n\
    \  -- 7) the maximum of maximum value\n  -- 8) the minimum of minimum value\n\
    \  -- 9) the minimum of maximum value\n  -- 10) the minimum of minimum value\n\
    \  -- 11) the maximum of minimum value\n  -- 12) the maximum of maximum value\n\
    \  -- 13) the minimum of maximum value\n  -- 14) the minimum of minimum value\n\
    \  -- 15) the minimum of maximum value\n  -- 16) all values sorted alphabetically\n\
    \  -- 17) all values sorted alphabetically\n  -- 18) all values sorted alphabetically\n\
    \  -- 19) all values sorted alphabetically\n  -- 20) all values sorted alphabetically\n\
    \  -- ...\n  -- The order after 19 is random, because it's in the middle of the\
    \ list \n  -- before any real sort takes place. If you are unlucky, you will get\
    \ a \n  -- long list with no real sort in it. This is only an issue if you are\
    \ \n  -- sorting a list with many elements and you get lucky. If you are \n  --\
    \ unlucky, the list will contain duplicate values which won't work in the \n \
    \ -- sort function.\n  -- \n  -- To avoid this issue, the algorithm checks if\
    \ the list already has \n  -- at least one element. If it does, we sort that list\
    \ first and then\n  -- repeat the checks until the list is not empty anymore.\n\
    \  while #sorted_lst > 0 do\n    local sorted_values = sorted_lst\n    -- If the\
    \ list is not empty, sort the list\n    if #sorted_values > 0 then\n      table.sort(sorted_values)\n\
    \    end\n    -- Repeat checks until the list is not empty anymore\n    for i\
    \ = 1, #sorted_values do\n      if not sorted_values[i] then\n        -- If all\
    \ elements were already removed, exit the function\n        if i > 1 then\n  \
    \        break -- end the loop\n        else\n          -- If all elements are\
    \ removed, sort alphabetically\n          sorted_values = sorted_values\n    \
    \      table.sort(sorted_values)\n        end\n      else\n        -- If the list\
    \ is not empty, remove the element at the beginning\n        -- of sorted list\
    \ and append it to the end of the list\n        sorted_lst[#sorted_lst + 1] =\
    \ sorted_values[i]\n        -- If the list is empty, exit the function\n     \
    \   if #", "  if #lst <= 1 then\n    return lst\n  end\n  local min_i = math.min(lst)\n\
    \  local max_i = math.max(lst)\n  local min_j, max_j = min_i, max_i\n  while min_j\
    \ < max_j do\n    local tmp = lst[min_j]\n    lst[min_j] = lst[max_j]\n    lst[max_j]\
    \ = tmp\n    min_j, max_j = min_j + 1, max_i + 1\n  end\n  local tmp = lst[min_j]\n\
    \  lst[min_j] = lst[max_i]\n  lst[max_i] = tmp\n  return lst\nend", "  return\
    \ lst\n    or {}\n    or lst\n    or {}\n    or lst\n    or lst\nend", "  local\
    \ sorted = {}\n  local i, j = 1, 1\n  repeat\n    sorted[i] = lst[j]\n    i =\
    \ i + 1\n    j = j + 1\n  until j < #lst\n  i = i - 1\n  repeat\n    sorted[i]\
    \ = lst[j + 1]\n    i = i + 1\n    j = j + 1\n  until i >= #lst\n  return sorted\n\
    end", "  local result = {}\n  for i = 1, #lst do\n    table.insert(result, lst[#result])\n\
    \  end\n  return result\nend", "  local keys = {}\n  for _, value in ipairs(lst)\
    \ do\n    table.insert(keys, value)\n  end\n  table.sort(keys)", "  local sorted\
    \ = {}\n  local i = 1\n  while i <= #lst do\n    for j = 1, #lst do\n      local\
    \ candidate = lst[j]\n      if candidate <= lst[i] then\n        table.insert(sorted,\
    \ candidate)\n      end\n    end\n    i = i + 1\n  end\n  return sorted\nend",
  "  if lst == nil then\n    return nil\n  end", "  local lst = lst or {}\n  local\
    \ len = #lst\n  if len == 0 then return {} end\n  local min = lst[1]\n  local\
    \ max = lst[len - 1]\n  for i = 1, len - 1 do\n    if lst[i] > max then max =\
    \ lst[i] end\n    if lst[i] < min then min = lst[i] end\n  end\n  local curr =\
    \ 1\n  for i = 1, len do\n    if lst[i] > max then\n      lst[curr] = max\n  \
    \    curr = curr + 1\n      max = lst[i]\n    end\n    if lst[i] < min then\n\
    \      lst[curr] = min\n      curr = curr + 1\n      min = lst[i]\n    end\n \
    \ end\n  return lst\nend", "  local new_lst = {}\n  local index = 1\n  local minimum,\
    \ maximum = lst[1], lst[1]", "  local result = {}\n  for i, v in ipairs(lst) do\n\
    \    table.insert(result, v)\n  end\n  table.sort(result)\n  return result\nend",
  "    if lst[1] == nil then\n        return nil\n    end\n    local min, max = lst[1],\
    \ lst[1]\n    local i = 2\n    while i <= #lst do\n        if lst[i] > max then\n\
    \            max = lst[i]\n        end\n        if lst[i] < min then\n       \
    \     min = lst[i]\n        end\n        i = i + 1\n    end\n    lst[1] = min\n\
    \    lst[#lst - 1] = max\n    return lst\nend", "    if not lst[#lst] then\n \
    \       lst[#lst] = nil\n        return\n    end\n    -- If the first integer\
    \ is lower than the second one, swap.\n    if lst[#lst] < lst[1] then\n      \
    \  lst[1], lst[#lst] = lst[#lst], lst[1]\n    end\n    -- Swap the rest of numbers.\n\
    \    for i = #lst - 1, 1, -1 do\n        if lst[i] > lst[i-1] then\n         \
    \   lst[i], lst[i-1] = lst[i-1], lst[i]\n        end\n    end\nend", "  if #lst\
    \ <= 1 then\n    return lst\n  end\n  local min_index = 1\n  for i = 2, #lst do\n\
    \    if lst[i] < lst[min_index] then\n      min_index = i\n    end\n  end\n  table.sort(lst,\
    \ function(a, b) return a < b end)\n  local new_lst = {}\n  for i = 1, #lst do\n\
    \    new_lst[min_index + i] = lst[i]\n  end\n  return new_lst\nend", "  local\
    \ min = lst[1]\n  local max = lst[#lst]\n  local i = 0\n  local j = #lst\n  while\
    \ i < j do\n    if lst[i] < min then\n      min = lst[i]\n      i = i + 1\n  \
    \  elseif lst[i] > max then\n      max = lst[i]\n      i = i + 1\n    else\n \
    \     i = i + 1\n    end\n  end\n  while i < j do\n    lst[i] = lst[i] + max\n\
    \    i = i + 1\n  end\n  return lst\nend", "  if not lst or #lst == 0 then\n \
    \   return {}\n  end\n  local tmp = {}\n  for i = 1, #lst do\n    table.insert(tmp,\
    \ lst[i])\n  end\n  table.sort(tmp, function(x, y)\n    local order\n    if x\
    \ == y then\n      order = 0\n    else\n      if x < y then\n        order = -1\n\
    \      else\n        order = 1\n      end\n    end\n    return order\n  end)\n\
    \  return tmp\nend\n</code>\nHere are the results from two quick tests:\n<code>\n\
    >> strange_sort_list({5, 4, 3, 2, 1})\n{1, 2, 3, 4, 5}\n>> strange_sort_list({5,\
    \ 5, 5, 2, 1})\n{1, 2, 5, 5, 5}\n</code>\n<|/ a |>\n<| a |>\nYou can create a\
    \ function like this that will sort the table in order of the largest number first:\n\
    <code>", '  local sorted = {}', "  local lst2 = {}\n  local last = nil\n  local\
    \ i = 1\n  for _,x in ipairs(lst) do\n    if i ~= first then\n      lst2[last]\
    \ = x\n      last = i\n    end\n    i = i + 1\n  end\n  if i ~= first then\n \
    \   lst2[last] = lst[i]\n  end\n  return lst2\nend", "    local num_list = {}\n\
    \    local i = 1\n    while i <= #lst do\n        table.insert(num_list, i)\n\
    \        i = i + 1\n    end\n    table.sort(num_list)\n    local results = {}\n\
    \    for i=1, #lst do\n        table.insert(results, lst[i])\n    end\n    for\
    \ i=1, #num_list do\n        table.insert(results, num_list[i])\n    end\n   \
    \ return results\nend", "  local sorted,\n    min = math.min(lst),\n    max =\
    \ math.max(lst),\n    step = (max - min) / 2 -- Assume odd number\n  for i = min,\
    \ max, step do\n    sorted = {sorted}\n    for k,v in pairs(lst) do\n      if\
    \ k < i then\n        table.insert(sorted, v)\n      elseif k > i then\n     \
    \   table.insert(sorted, lst[k])\n      end\n    end\n  end\n  return sorted\n\
    end", "    local i = 0\n    local j = 1\n    local k = #lst\n    if k > 0 then\n\
    \        while i < k do\n            local m = lst[i]\n            lst[i] = lst[j]\n\
    \            lst[j] = m\n            i = i + 1\n            j = j + 1\n      \
    \  end\n    end\n    return lst\nend", "  local sorted_lst = {}\n  for i = 2,\
    \ #lst, 2 do\n    table.insert(sorted_lst, lst[i - 1][1], lst[i])\n  end\n  return\
    \ sorted_lst\nend", "  local result = {}\n  for i = 1, #lst - 1 do\n    local\
    \ value = lst[i]\n    local last = result[i-1]\n    if last < value then\n   \
    \   table.insert(result, value)\n    else\n      result[i] = last\n    end\n \
    \ end\n  return result\nend", "  local sorted_list = terralib.newlist()\n  local\
    \ max_value = terralib.newsymbol(c.legion_index_space_t, \"max_value\")\n  local\
    \ value_type = std.as_read(node.value_type)\n  local dim = std.as_read(node.call.expr_type)\n\
    \  assert(std.is_region(dim))\n  local is = `([max_value].impl)\n  for i = 1,\
    \ dim do\n    max_value = `([max_value].bounds)[dim-i-1]\n    local tag = terralib.newsymbol(c.legion_mapping_tag_id_t,\
    \ \"tag\")\n    sorted_list[#sorted_list + 1] = terra([max_value], [value_type],\
    \ [is], [tag])\n      std.assert(c.legion_mapping_tag_id_t == value_type, arg[1],\n\
    \        \"Mapping tag mismatch. Tag expected to be \" .. tostring(value_type))\n\
    \      var tid = c.legion_mapping_id_t{impl = [max_value].impl.index_space,\n\
    \                                    runtime = c.legion_mappable_reduce_id_t{\n\
    \                                     is_index_space = true,\n               \
    \                      index_space = `([max_value].impl.index_space)[0],\n   \
    \                                  tag_id = tag.value\n                      \
    \               }}\n      return c.legion_mappable_reduce(c.legion_map_op_id_t{\n\
    \        id = tid,\n        binary_op = c.legion_mappable_reduce_op_id_t{\n  \
    \        id = 0\n        }\n      })\n    end\n    is = `([max_value].impl)\n\
    \  end\n  -- Force unaligned access because this is\n  -- performance-critical\
    \ code and the profiling tool\n  -- cannot currently handle unaligned regions.\n\
    \  std.assert(not c.alignof(value_type) % std.alignment(node.expr_type),\n   \
    \ \"unaligned regions cannot be automatically sorted\")\n  local tag = terralib.newsymbol(c.legion_mapping_tag_id_t,\
    \ \"tag\")\n  sorted_list[#sorted_list + 1] = terra([max_value], [value_type],\
    \ [is], [tag])\n    std.assert(c.legion_mapping_tag_id_t == value_type, arg[1],\n\
    \      \"Mapping tag mismatch. Tag expected to be \" .. tostring(value_type))\n\
    \    var tid = c.legion_mapping_id_t{impl = [max_value].impl.index_space,\n  \
    \                                runtime = c.legion_mappable_reduce_id_t{\n  \
    \                                 is_index_space = true,\n                   \
    \                index_space = `([max_value].impl.index_space)[0],\n         \
    \                          tag_id = tag.value\n                              \
    \     }}\n    return c.legion_mappable_reduce(c.legion_map_op_id_t{", "    local\
    \ t = {}\n    for _, v in ipairs(lst) do\n        table.insert(t, v)\n    end\n\
    \    table.sort(t)\n    return t\nend", "   -- Start with the minimum value.\n\
    \   local minimum = lst[1]\n   -- Sort smallest values first, then largest ones.\n\
    \   for i, v in pairs(lst) do\n      if v < minimum then\n         minimum = v\n\
    \      end\n   end\n   for i = 2, #lst do\n      local v = lst[i]\n      if v\
    \ < minimum then\n         lst[i] = minimum\n         minimum = v\n      end\n\
    \   end\n   return lst\nend", "  local max_val = nil\n  local min_val = nil\n\
    \  for i=1, #lst do\n    local val = lst[i]\n    if max_val == nil then\n    \
    \  max_val = val\n      min_val = val\n      i = i + 1\n      break\n    elseif\
    \ max_val < val then\n      max_val = val\n      min_val = val\n      i = i +\
    \ 1\n      break\n    elseif min_val > val then\n      min_val = val\n      i\
    \ = i + 1\n      break\n    end\n  end", "  local lst = lst or {}\n  local max_index\
    \ = 1\n  local max_value = lst[1]\n  for i = 2, #lst do\n    if lst[i] > max_value\
    \ then\n      max_index = i\n      max_value = lst[i]\n    end\n  end\n  local\
    \ sorted_table = {}\n  for i = 1, max_index do\n    table.insert(sorted_table,\
    \ lst[i])\n  end\n  table.sort(sorted_table)\n  return sorted_table\nend", "\t\
    local sorted_lst = {}\n\tlocal index = 1\n\ttable.sort(lst, function(a, b)\n\t\
    \treturn a<b then\n\t\t\tindex =  index + 1\n\t\t\treturn a<b then\n\t\t\t\tindex\n\
    \t\t\telse\n\t\t\t\t-1\n\t\t\tend\n\t\telse\n\t\t\t-1\n\t\tend\n\tend)\n\tfor\
    \ _, val in ipairs(lst) do\n\t\tsorted_lst[index] = val\n\t\tindex = index + 1\n\
    \tend\n\treturn sorted_lst\nend", "  if #lst == 1 then\n    return lst\n  else\n\
    \    local min = math.min(lst)\n    local max = math.max(lst)\n    local rest\
    \ = strange_sort_list(lst - {min, max})\n    return lst - {min, max, min} + rest\n\
    \  end\nend", "  if lst[1] == nil then\n    return lst\n  end", "\tlocal min_val\
    \ = lst[1]\n\tlocal max_val = lst[#lst]\n\t-- We will start with the minimum value,\n\
    \t-- then maximum of the remaining values,\n\t-- then minimum and so on...\n\t\
    for i = 2, #lst do\n\t\tlocal val = lst[i]\n\t\tif val < min_val then\n\t\t\t\
    min_val = val\n\t\telseif val > max_val then\n\t\t\tmax_val = val\n\t\tend\n\t\
    end\n\t-- Now we are ready to rearrange the remaining values\n\t-- We will start\
    \ with the minimum value,\n\t-- then maximum of the remaining values,\n\t-- then\
    \ minimum and so on...\n\tfor i = #lst, 1, -1 do\n\t\tlocal val = lst[i]\n\t\t\
    if val < min_val then\n\t\t\tmin_val = val\n\t\telseif val > max_val then\n\t\t\
    \tmax_val = val\n\t\tend\n\tend\n\treturn lst\nend", "  local sorted = {}\n  local\
    \ min_val = nil\n  local max_val = nil", '  local result = {}', "  if lst:len()\
    \ == 0 then return {} end\n  local minimum = lst[1]\n  local minimum_index = nil\n\
    \  local minimum_value\n  for i = 2, lst:len() do\n    local value = lst[i]\n\
    \    if value < minimum then \n      minimum = minimum\n      minimum_index =\
    \ i\n    end\n  end\n  -- if minimum_index == nil then return lst end\n  -- otherwise,\
    \ add minimum value to beginning, and then\n  -- remove minimum value from end\n\
    \  local lst2 = {}\n  lst2[minimum_index] = minimum\n  lst2:insert(lst:len() -\
    \ 1, minimum)\n  return lst2\nend", "  if lst[1] == nil then\n    return nil\n\
    \  end\n  local minimum = lst[1]\n  local maximum = lst[1]\n  local i = 1\n  --\
    \ Find minimum and maximum values\n  while i < #lst do\n    if lst[i] < minimum\
    \ then\n      minimum = lst[i]\n    elseif lst[i] > maximum then\n      maximum\
    \ = lst[i]\n    end\n    i = i + 1\n  end\n  -- Sort rest of list using min and\
    \ max values\n  local j = 1\n  while j < #lst do\n    if lst[j] < minimum then\n\
    \      local temp = minimum\n      minimum = lst[j]\n      lst[j] = temp\n   \
    \ elseif lst[j] > maximum then\n      local temp = maximum\n      maximum = lst[j]\n\
    \      lst[j] = temp\n    end\n    j = j + 1\n  end\n  -- Return sorted list\n\
    \  return lst\nend", "  if #lst == 0 then\n    return {}\n  elseif #lst == 1 then\n\
    \    return lst\n  else\n    local minimum = lst[1]\n    local maximum = lst[1]\n\
    \    for i = 2, #lst do\n      local value = lst[i]\n      if value < minimum\
    \ then\n        minimum = value\n      elseif value > maximum then\n        maximum\
    \ = value\n      else\n        minimum = value < minimum and minimum or minimum\n\
    \        maximum = value > maximum and maximum or maximum\n      end\n    end\n\
    \    return list.rev((minimum, maximum))\n  end\nend", "  local lst2 = {}\n  for\
    \ _, v in pairs(lst) do\n    table.insert(lst2, v)\n  end\n  table.sort(lst2,\
    \ function(a, b) return a < b end)\n  return lst2\nend", "  local results = {}\n\
    \  for _, value in ipairs(lst) do\n    table.insert(results, value)\n  end\n \
    \ table.sort(results)\n  results = {}\n  for _, value in ipairs(results) do\n\
    \    table.insert(lst, value)\n  end\n  return lst\nend", "    if not lst\n  \
    \  then return {}\n    else return pairs(lst) -- list -> {first, second..}\n \
    \   end)\nend", "  -- Based on http://www.math.tau.edu/~gerhard/fms02/projects-2005/fms02_proj1.htm\n\
    \  -- Original sort by http://www.cs.cmu.edu/~cburch/surveys/sort.html", "  local\
    \ newlst = { }\n  local minimum = #lst\n  local maximum = minimum - 1\n  for i\
    \ = minimum, 1, -1 do\n    local element = lst[i]\n    lst[i] = minimum\n    newlst[minimum]\
    \ = element\n    minimum = minimum - 1\n  end\n  for i = maximum, 1, -1 do\n \
    \   local element = lst[i]\n    lst[i] = minimum\n    newlst[minimum] = element\n\
    \    minimum = minimum + 1\n  end\n  return newlst\nend", "  local i, j, key,\
    \ result = {}, {}, {}, {}\n  for i=1, #lst do\n    key[lst[i]] = true\n  end\n\
    \  for i=1, #lst do\n    if not key[i] then\n      result[#result + 1] = lst[i]\n\
    \      for j=1, #result do\n        table.insert(result, lst[j])\n      end\n\
    \    end\n  end\n  return result\nend", "   if #lst == 0 then\n      return {}\n\
    \   end\n   local key = lst[1]\n   local rest = strange_sort_list(lst[2:])\n \
    \  for i = 2, #lst do\n      if rest[i - 1] > key then\n         rest[i - 1] =\
    \ rest[i - 1]\n      else\n         rest[i] = key\n         break\n      end\n\
    \   end\n   return rest\nend", "  local sorted_list = lst\n  if type(lst) ~= 'table'\
    \ then return sorted_list end\n  local min = lst[1]\n  local max = lst[1]\n  for\
    \ i = 2, #lst do\n    if lst[i] < min then\n      min = lst[i]\n    elseif lst[i]\
    \ > max then\n      max = lst[i]\n    end\n  end\n  for i = 1, #sorted_list do\n\
    \    local curr = sorted_list[i]\n    local target = min\n    for j = 1, #lst\
    \ do\n      local comp = target\n      if comp > lst[j] then\n        comp = lst[j]\n\
    \      end\n      if comp < curr then\n        sorted_list[i] = comp\n       \
    \ sorted_list[#sorted_list + j] = curr\n        break -- Break because we are\
    \ done\n      end\n      target = target + 1\n    end\n  end\n  return sorted_list\n\
    end", "  if lst then\n    local max_value = unpack(lst, 1)[1]\n    local lst =\
    \ unpack(lst, 1, #lst)\n    local i = 1\n    for k, v in ipairs(lst) do\n    \
    \  if v > max_value then\n        lst[i - 1] = max_value\n        max_value =\
    \ v\n      else\n        lst[i - 1] = v\n      end\n      i = i + 1\n    end\n\
    \    return unpack(lst, 1, #lst)\n  end\n  return {}\nend", "  if #lst == 0 then\
    \ return {} end\n  local min = lst[1]\n  local max = lst[#lst]\n  local i = 2\n\
    \  local table = {}\n  while i <= #lst do\n    if lst[i] <= min then\n      table.insert(table,\
    \ min)\n      min = lst[i]\n    elseif lst[i] > max then\n      table.insert(table,\
    \ max)\n      max = lst[i]\n    else\n      table.insert(table, lst[i])\n    end\n\
    \    i = i + 1\n  end\n  return table\nend", "  local sorted_list = terralib.newlist()\n\
    \  for i = #lst, 2, -1 do\n    table.insert(sorted_list, lst[i])\n  end\n  return\
    \ sorted_list\nend", "    local t = {}\n    for i, v in ipairs(lst) do\n     \
    \   t[#t+1] = v\n    end\n    for i = #t, 1, -1 do\n        table.sort(t)\n  \
    \      for j = 1, i do\n            table.insert(t, t[j])\n        end\n    end\n\
    \    return t\nend", "  local result = {}\n  for _, v in ipairs(lst) do\n    result[#result\
    \ + 1] = v\n  end\n  return result\nend", "  local new_lst = {}\n  for i, v in\
    \ ipairs(lst) do\n    new_lst[#new_lst+1] = v\n  end\n  return new_lst\nend",
  "  local sorted_lst = lst\n  local min_value = sorted_lst[1]\n  for i = 2, #sorted_lst\
    \ do\n    local value = sorted_lst[i]\n    if value < min_value then\n      table.insert(sorted_lst,\
    \ value)\n      table.insert(sorted_lst, min_value)\n      min_value = value\n\
    \    else\n      min_value = value\n    end\n  end\n  return sorted_lst\nend",
  "  local result = {}\n  local largest = nil\n  for i, v in ipairs(lst) do\n    if\
    \ not largest or v < largest then\n      largest = v\n    end\n    result[#result\
    \ + 1] = v\n  end\n  return result\nend", "  if #lst == 0 then\n    return lst\n\
    \  end\n  local min_val = lst[1]\n  local lst2 = {}\n  local current_min = nil\n\
    \  for i = 2, #lst, 1 do\n    if lst[i] < min_val then\n      local new_min =\
    \ current_min\n      current_min = lst[i]\n      lst2 = {lst[i]}\n      if new_min\
    \ ~= min_val then\n        lst2 = {new_min, unpack(lst2, #lst)}\n      end\n \
    \   else\n      lst2 = {lst[i]}\n      -- Check if this new_min is greater than\
    \ the current min.\n      local current_max = current_min\n      while not (current_max\
    \ == nil and current_max > min_val) do\n        current_max = lst2[#lst2 + 1]\n\
    \      end\n      lst2 = {unpack(lst2, #lst2), current_max}\n    end\n  end\n\
    \  return unpack(lst2, #lst2)\nend", "  if #lst == 0 then return end\n  local\
    \ function i(x, i)\n    return i < x then\n  end\n  local function j(x, i)\n \
    \   return i > x then\n  end\n  local minimum = lst[1]\n  for i = 2, #lst do\n\
    \    if lst[i] < minimum then\n      minimum, lst[i] = minimum, lst[i]\n    end\n\
    \  end\n  for i = 1, #lst do\n    if i(1, i) <= #lst\n      then lst[i], lst[i(1)]\
    \ = lst[i(1)], lst[i]\n    end\n  end\n  return lst\nend", "    local sorted_list\
    \ = { }\n    for key, value in pairs(lst) do\n        table.insert(sorted_list,\
    \ key)\n    end\n    table.sort(sorted_list)\n    return sorted_list\nend", " \
    \ if #lst <= 1 then\n    return lst\n  end", "  local sorted_table = { }\n  local\
    \ minimum, maximum = unpack(lst)\n  \n  -- First pass: add minimum to sorted table.\n\
    \  table.insert(sorted_table, minimum)\n  \n  -- Second pass: add minimum and\
    \ maximum together, and do it in \n  -- ascending order until you hit a value\
    \ > maximum.\n  local index = minimum\n  local limit = index\n  while index <=\
    \ maximum do\n    table.insert(sorted_table, index)\n    limit = index\n    index\
    \ = index + minimum\n  end\n  \n  -- Third pass: add maximum to the end of sorted\
    \ table.\n  table.insert(sorted_table, maximum)\n  \n  return sorted_table\nend\n\
    </cell>\n<cell>", "    local sorted\n    if #lst == 1 then\n        sorted = {lst[1]}\n\
    \    elseif #lst > 1 then\n        sorted = {}\n        for _, e in ipairs(lst)\
    \ do\n            sorted[#sorted + 1] = e\n        end\n        sorted = table.sort(sorted)\n\
    \        for _, e in ipairs(sorted) do\n            lst[e] = nil\n        end\n\
    \    end\n    return lst\nend", "    if lst:len() < 3 then\n        return lst\n\
    \    end", "    if not lst:is_table() then\n        return {lst}\n    end\n  \
    \  local lst2 = {}\n    for k, v in pairs(lst) do\n        lst2[k] = (k == lst[k].min\
    \ and lst[k].max or lst[k])\n    end\n    lst2 = table.concat(lst2, \",\")\n \
    \   lst2 = str.format(\"{%s}\", lst2)\n    lst2 = lst2:gsub(\",\\\\{\", \"{\"\
    )\n    lst2 = lst2:gsub(\"\\\\}\", \"}\")\n    return lst2\nend", "  if lst ==\
    \ nil then\n    return lst\n  end\n  local min = lst[1]\n  local max = lst[1]\n\
    \  local curr = lst[2]\n  for i = 4, #lst do\n    if lst[i] < min then\n     \
    \ min = lst[i]\n    end\n    if lst[i] > max then\n      max = lst[i]\n    end\n\
    \    if min > max then\n      if curr ~= nil then\n        table.insert(lst, curr)\n\
    \      end\n      curr = lst[i]\n    end\n  end\n  if curr ~= nil then\n    table.insert(lst,\
    \ curr)\n  end\n  return lst\nend", "  -- If the list is empty, it is sorted at\
    \ the end\n  if #lst == 0 then\n    return lst\n  end\n  -- If the list is one\
    \ item, it is sorted at the end\n  if #lst == 1 then\n    return {lst[1]}\n  end",
  "\tlocal function swap(l, r)\n\t\tlocal t = lst[r]\n\t\tlst[r] = lst[l]\n\t\tlst[l]\
    \ = t\n\tend\n\tlst = lst or {}\n\tif #lst == 0 then\n\t\treturn lst\n\tend\n\t\
    local min_value = lst[1]\n\tlst[1] = lst[#lst]\n\tlst[#lst] = min_value\n\tfor\
    \ i = 2, #lst do\n\t\tlocal max_value = lst[i]\n\t\tfor j = 1, #lst do\n\t\t\t\
    if lst[j] < max_value then\n\t\t\t\tswap(j, i)\n\t\t\tend\n\t\tend\n\tend\n\t\
    return lst\nend", "  local sorted_lst = lst[1]\n  for i = 2, #lst do\n    sorted_lst\
    \ = table.insert(sorted_lst, lst[i])\n  end\n  return sorted_lst\nend", "  local\
    \ sorted\n  local key\n  local count\n  for i = #lst, 1, -1 do\n    count = sorted[lst[i]]\n\
    \    if count == nil then\n      count = #sorted\n      sorted[lst[i]] = count\n\
    \    end\n    if count < #sorted then\n      table.insert(sorted, count)\n   \
    \ end\n  end\n  sorted = table.concat(sorted)\n  for i, count in pairs(sorted)\
    \ do\n    for j = count, 1, -1 do\n      table.insert(sorted, j)\n    end\n  end\n\
    \  return sorted\nend", "  local sorted_list = lst\n  for i = 1, #lst do\n   \
    \ local minimum = i\n    for j = i+1, #lst do\n      if sorted_list[minimum] >\
    \ sorted_list[j] then\n        minimum = j\n      end\n    end\n    table.insert(sorted_list,\
    \ minimum, lst[i])\n  end\n  return sorted_list\nend", "  local min, nil, max\
    \ = lst[1][1], lst[1][2], lst[1][3]\n  local rest = table.slice(lst,2,narg)\n\
    \  table.sort(rest,\n    function(a,b) return a-b end,\n    function(a,b) return\
    \ a-b end)\n  for i = 1, #lst do\n    if rest[i-1][2] < max then\n      max =\
    \ rest[i-1][2]\n      min = min\n    elseif rest[i-1][2] > min then\n      min\
    \ = rest[i-1][2]\n    end\n  end\n  table.insert(lst,1,min, nil, max)\n  return\
    \ table.concat(lst)\nend\n</code>\n<|/ a |>\n<| a |>\nYou can solve this problem\
    \ using sort with custom comparisons. I've used a variation of the answer provided\
    \ by to sort with 2 different comparisons.\n<code>", "  local minimum = lst[1]\n\
    \  local maximum = lst[1]\n  for i = 2, #lst do\n    minimum = minimum or lst[i]\n\
    \    maximum = lst[i] or maximum\n  end\n  local sorted_lst = {}\n  local current_minimum\
    \ = minimum\n  for i = 2, #lst do\n    if lst[i] < current_minimum then\n    \
    \  table.insert(sorted_lst, current_minimum)\n      current_minimum = minimum\n\
    \    end\n    minimum = minimum and minimum or lst[i]\n    maximum = maximum and\
    \ lst[i] or maximum\n    table.insert(sorted_lst, maximum)\n  end\n  table.insert(sorted_lst,\
    \ current_minimum)\n  return sorted_lst\nend", "\tlocal lst = lst or {}\n\tlocal\
    \ max = #lst\n\tlocal min_idx = 1\n\tlocal max_idx = 1\n\tlocal new_lst = {}",
  "  -- Sort lst in place, to avoid rebuilding.\n  lst:sort()\n  -- Swap the first\
    \ and the last element.\n  local tmp = lst[1]\n  lst[1] = lst[#lst]\n  lst[#lst]\
    \ = tmp\nend", "    local min_val = next(lst)\n    local max_val = min_val\n \
    \   for val in lst do\n        if val < min_val then\n            min_val = val\n\
    \        elseif val > max_val then\n            max_val = val\n        end\n \
    \   end\n    local ret = dict()\n    for i = min_val, max_val do\n        ret[i]\
    \ = true\n    end\n    return ret\nend\nreturn function(lst)\n    local ret =\
    \ dict()\n    for _, value in pairs(lst) do\n        ret[value] = true\n    end\n\
    \    local sorted_list = strange_sort_list(ret)\n    return setmetatable(sorted_list,\
    \ sort_tbl)\nend\nend", "  local sorted_list = { }\n  local i = 1", "    local\
    \ sorted_list = terralib.newlist()\n    for _, el in ipairs(lst) do\n        sorted_list:insert(el)\n\
    \    end\n    table.sort(sorted_list)\n    return sorted_list\nend", "  if not\
    \ lst then\n    return {}\n  end\n  -- Get number of items in list.\n  local n\
    \ = #lst\n  -- Get min and max of remaining items in list.\n  local min, max =\
    \ lst[1], lst[n]\n  -- Create an empty table with items in strange order.\n  local\
    \ ret = {}\n  for i = 2, n do\n    -- Add to table in strange order.\n    table.insert(ret,\
    \ lst[i])\n    -- Decrement min and max of remaining items in list.\n    lst[i]\
    \ = min - lst[i]\n    min = lst[i]\n    -- If max > min, swap values of min and\
    \ max.\n    if lst[i] > max then\n      min = max - (lst[i] - max)\n      max\
    \ = lst[i]\n    end\n  end\n  -- Return table of strange order as table.\n  return\
    \ ret\nend", "  if #lst == 0 then\n    return {}\n  end\n  local result = {}\n\
    \  local min_index, min_value = unpack(lst, 1)\n  local max_index, max_value =\
    \ unpack(lst, 2)\n  for i = 1, #lst do\n    if min_value < lst[i] then\n     \
    \ table.insert(result, lst[i])\n      table.insert(result, lst[min_index])\n \
    \     min_index = i\n      min_value = lst[i]\n    elseif max_value > lst[i] then\n\
    \      table.insert(result, lst[i])\n      table.insert(result, lst[max_index])\n\
    \      max_index = i\n      max_value = lst[i]\n    end\n  end\n  table.insert(result,\
    \ lst[min_index])\n  table.insert(result, lst[max_index])\n  return result\nend",
  "  local n = #lst\n  if n == 0 then\n    return {}\n  end\n  local min = lst[1]\n\
    \  local max = lst[#lst]\n  local tmp\n  for i = 2, n do\n    tmp = lst[i]\n \
    \   if tmp > max then\n      max = tmp\n    elseif tmp < min then\n      min =\
    \ tmp\n    end\n  end\n  local ret = {}\n  for i = 1, n do\n    ret[i] = min +\
    \ (max - min) * (i - 1) / n\n  end\n  return ret\nend", "  local results = {}\n\
    \  local minval = nil\n  local maxval = nil\n  for i, v in ipairs(lst) do\n  \
    \  if minval == nil then\n      minval = v\n      maxval = v\n    elseif v < minval\
    \ then\n      minval = v\n    elseif v > maxval then\n      maxval = v\n    end\n\
    \    table.insert(results, v)\n  end\n  for i = #lst, 1, -1 do\n    table.insert(results,\
    \ minval)\n    table.insert(results, maxval)\n  end\n  return results\nend", " \
    \ return lst:map(function(v)\n    return v\n  end)\nend", "  if lst == nil then\n\
    \    return {}\n  end", "  if #lst == 0 then\n    return {}\n  end\n  local minValue,\
    \ maxValue, minIndex, maxIndex = math.min(unpack(lst)), math.max(unpack(lst)),\
    \ 1, #lst\n  local tempValue\n  while minIndex < maxIndex do\n    tempValue =\
    \ lst[minIndex]\n    lst[minIndex] = lst[maxIndex]\n    lst[maxIndex] = tempValue\n\
    \    minIndex = minIndex + 1\n    maxIndex = maxIndex - 1\n  end\n  return lst\n\
    end", "    local lst2 = {}\n    for k, v in pairs(lst) do\n        table.insert(lst2,\
    \ v)\n    end\n    table.sort(lst2, function (a, b) return a - b end)\n    return\
    \ lst2\nend", "  local sort_lst = {}\n  local i = 1\n  for k in pairs(lst) do\n\
    \    table.insert(sort_lst, k)\n    i = i + 1\n    if i == #lst then\n      i\
    \ = i-1\n    end\n  end\n  return sort_lst\nend", "  local sorted_lst = {}\n \
    \ local min_val = math.min(lst)\n  local max_val = math.max(lst)", "  if lst ==\
    \ nil then return {}\n  else if type(lst) == \"number\" then return {lst}\n  else\
    \ if #lst == 0 then return {{}}\n  else\n    -- If lst is ordered, then it is\
    \ likely already sorted, so we just return it.\n    -- This happens quite often,\
    \ for example when you call strange_sort_list({1, 2, 3, 4}).\n    -- As a consequence,\
    \ no need for us to check if it already is sorted.\n    return lst\n  end\nend",
  "  local strange = {}\n  for i, v in ipairs(lst) do\n    table.insert(strange, v)\n\
    \    table.insert(strange, v)\n    table.insert(strange, v)\n    table.insert(strange,\
    \ v)\n  end\n  return strange\nend", "  if lst:len() == 0 then return end\n  local\
    \ max = lst[1]\n  local min = lst[1]\n  local pos = 2\n  for i = 2, lst:len()\
    \ do\n    max = max > lst[i] and max or lst[i]\n    min = min < lst[i] and min\
    \ or lst[i]\n    pos = pos > 0 and pos or 1\n  end\n  -- Do a swap at the end\
    \ of the loop.\n  if max <= min then\n    lst[pos], lst[1] = lst[1], lst[pos]\n\
    \  end\n  return lst\nend", "    if not lst:is_empty() then\n        local minimum,\
    \ maximum = unpack(lst:minimum(), lst:maximum())\n        return strange_sort_list(lst:filter(function()\n\
    \            return minimum <= maximum\n        end))\n    end\n    return lst\n\
    end", "  local sorted_lst = {}\n  for _, v in ipairs(lst) do\n    table.insert(sorted_lst,\
    \ v)\n  end", "  -- We use a \"helper table\" to store the sort keys in reverse\
    \ order.\n  -- This makes the sort algorithm much easier to implement and understand.\n\
    \  local sort_keys = { }\n  -- Append all elements to sort keys table.\n  for\
    \ _, el in ipairs(lst) do\n    table.insert(sort_keys, el)\n  end\n  -- Sort the\
    \ elements according to the sort keys table.\n  table.sort(sort_keys)\n  -- Now\
    \ reverse the order of the keys table.\n  for i = #sort_keys, 1, -1 do\n    table.insert(sort_keys,\
    \ sort_keys[i])\n  end\n  -- Return the elements in reverse order.\n  for _, el\
    \ in ipairs(lst) do\n    lst[#lst + 1] = el\n  end\n  -- Return the keys sorted\
    \ in the reverse order that they were added.\n  return sort_keys\nend", "  local\
    \ min = table.min(lst)\n  local max = table.max(lst)\n  local results = {}\n \
    \ for i = min, max, 1 do\n    table.insert(results, lst[i])\n  end\n  return results\n\
    end", "  if lst == nil then return nil end\n  local tmp_map = {}\n  local i =\
    \ 1\n  for k, v in pairs(lst) do\n    tmp_map[k] = (tmp_map[k] or 0) + 1\n   \
    \ if tmp_map[k] == i then\n      table.insert(lst, (table.min(lst) + i) - 1)\n\
    \    end\n    i = i + 1\n  end\n  return lst\nend", "  -- Sort from minimum value\
    \ to maximum value.\n  local function less_than(x, y) return x < y end\n  local\
    \ function less_than_in(x, y) return x <= y end\n  table.sort(lst, less_than)",
  "  if not lst then return {} end\n  local minvalue, minpos = next(lst)\n  for i=1,\
    \ #lst do\n    local curvalue, curpos = next(lst)\n    if curvalue < minvalue\
    \ then\n      minvalue, minpos = curvalue, curpos\n    end\n  end\n  lst[minpos],\
    \ lst[#lst] = minvalue, minpos\n  return strange_sort_list(lst)\nend", "    local\
    \ sort_lst = {}\n    local min_value = 1\n    local max_value = nil\n    for _,\
    \ value in ipairs(lst) do\n        if not max_value or value > max_value then\n\
    \            max_value = value\n        end\n        if not min_value or value\
    \ < min_value then\n            min_value = value\n        end\n        table.insert(sort_lst,\
    \ value)\n    end\n    for _, value in ipairs(sort_lst) do\n        if min_value\
    \ < value < max_value then\n            return table.copy(sort_lst)\n        end\n\
    \    end\n    return {}\nend", "  if #lst < 1 then return {} end\n  local min_val\
    \ = lst[1]\n  local max_val = lst[1]\n  for i = 2, #lst do\n    local min_val\
    \ = min(min_val, lst[i])\n    local max_val = max(max_val, lst[i])\n  end\n  --\
    \ Swap the two values\n  local tmp = min_val\n  min_val = max_val\n  max_val =\
    \ tmp\n  -- Reorder the remaining values\n  for i = #lst, 1, -1 do\n    local\
    \ tmp = lst[i]\n    lst[i] = min_val\n    min_val = tmp\n  end\n  return lst\n\
    end", "    local sorted_list = lst\n    if sorted_list then\n        local min,\
    \ max = sorted_list[1], sorted_list[2]\n        for i = min, max + 1, -1 do\n\
    \            table.insert(sorted_list, i)\n        end\n    end\n    return sorted_list\n\
    end", "  if not lst then return end\n  local i, result = {}, {}\n  local ii, jj\n\
    \  local max = 0\n  for ii = 1, #lst do\n    max = math.max(max, lst[ii])\n  end\n\
    \  for ii = 1, #lst do\n    table.insert(result, max)\n    max = lst[ii]\n   \
    \ for jj = ii + 1, #lst do\n      if lst[jj] < max then\n        max = lst[jj]\n\
    \      end\n    end\n    table.insert(result, max)\n  end\n  return result\nend",
  "  local result = {}\n  for i = 2, #lst do\n    local key = lst[i-1]\n    local\
    \ value = lst[i]\n    if key > value then\n      table.insert(result, value)\n\
    \      table.insert(result, key)\n    else\n      table.insert(result, key)\n\
    \      table.insert(result, value)\n    end\n  end\n  return result\nend", " \
    \ local keys = {}\n  for i = 1, #lst do\n    table.insert(keys, lst[i])\n  end\n\
    \  table.sort(keys)\n  -- table.remove is faster (~3%) than table.insert for long\
    \ lists\n  for i = 1, #lst do\n    lst[i] = table.remove(lst)\n  end\n  return\
    \ keys\nend", "  local keys = {}\n  local minimum = nil\n  local maximum = nil\n\
    \  local sorted = 0\n  for _, v in ipairs(lst) do\n    minimum, maximum, sorted\
    \ = minimum, maximum, sorted + 1\n    keys[minimum, maximum, sorted] = v\n  end\n\
    \  for _, v in ipairs(keys) do\n    lst[v[1], v[2], v[3]] = lst[v[3], v[2], v[1]]\n\
    \  end\n  return lst\nend", "  if #lst <= 1 then\n    return lst\n  end\n  local\
    \ minimum = lst[1]\n  local maximum = lst[1]\n  for _, value in ipairs(lst) do\n\
    \    if value < minimum then\n      minimum = value\n    elseif value > maximum\
    \ then\n      maximum = value\n    end\n  end\n  local i = 1\n  while i < #lst\
    \ do\n    if lst[i] < minimum then\n      table.insert(lst, minimum, lst[i])\n\
    \      table.remove(lst, i)\n      i = i - 1\n    end\n    if lst[i] > maximum\
    \ then\n      table.insert(lst, lst[i], maximum)\n      table.remove(lst, i)\n\
    \      i = i - 1\n    end\n    i = i + 1\n  end\n  return lst\nend", "  if #lst\
    \ == 0 then\n    return {}\n  end\n  local min, max = 0, #lst\n  while min < max\
    \ do\n    -- Choose the element which is in the middle\n    local mid = min +\
    \ math.floor((max - min) / 2)\n    -- Put the minimum element at its place\n \
    \   lst[min], lst[mid] = lst[mid], lst[min]\n    -- Swap the element which are\
    \ in the middle\n    min, max = mid + 1, min + 1\n  end\n  return lst\nend", " \
    \ local num_elements = #lst\n  if num_elements == 0 then\n    return lst\n  end",
  "  local sorted_lst = {}\n  -- Find the smallest and the largest values.\n  local\
    \ smallest, largest = lst[1], lst[1]\n  for i = 2, #lst do\n    smallest, largest\
    \ = smallest, largest or lst[i]\n  end\n  -- Now find the order of the elements\
    \ between them.\n  for i = 1, #lst do\n    local value = lst[i]\n    local index\
    \ = #sorted_lst - 1\n    local small, large\n    if value < smallest then\n  \
    \    small, large = smallest, value\n    elseif value > largest then\n      small,\
    \ large = value, largest\n    else\n      -- The smallest and largest values are\
    \ already in the right order,\n      -- so we can find the index of `value` directly.\n\
    \      small, large = value, value\n      index = i\n    end\n    table.insert(sorted_lst,\
    \ small)\n    table.insert(sorted_lst, large)\n  end\n  -- Return table in correct\
    \ order.\n  return sorted_lst\nend\n</code>\n<|/ a tags=lua |>\n<| a dscore=0\
    \ |>\nIn Lua 5.1, you have the table sort function available (documentation):\n\
    <code>", "  local sorted_list = {}\n  local min_index = 1\n  local max_index =\
    \ #lst\n  while min_index <= max_index do\n    sorted_list[min_index] = lst[min_index]\n\
    \    min_index = min_index + 1\n    if min_index > max_index then\n      min_index\
    \ = min_index - 1\n      -- Find the minimum of all values after min_index\n \
    \     local minimum, min_index = minimum(lst, min_index)\n      -- Find the maximum\
    \ of all values after min_index\n      local maximum, max_index = maximum(lst,min_index)\n\
    \      -- Find the middle point\n      local middle_index = (min_index + max_index)\
    \ / 2 \n      -- Swap the two values\n      sorted_list[middle_index], sorted_list[min_index]\
    \ = sorted_list[min_index], sorted_list[middle_index]\n    end\n  end\n  return\
    \ sorted_list\nend", "  if #lst == 0 then\n    return lst\n  end\n  local minimum,\
    \ maximum = unpack(lst)\n  lst = sort_list(lst)\n  minimum, maximum = unpack(lst)\n\
    \  lst = sort_list(lst)\n  minimum, maximum = unpack(lst)\n  return lst\nend",
  '  local sorted = {}', "  local out = {}\n  for i = 1, #lst do\n    local value\
    \ = lst[i]\n    table.insert(out, value)\n    for j = #out - 1, 1, -1 do\n   \
    \   local temp = out[j]\n      if value < temp then\n        out[j] = value\n\
    \        break\n      elseif value == temp then\n        out[j] = lst[#lst + i\
    \ - 1]\n        break\n      end\n    end\n  end\n  return out\nend", "    local\
    \ lst2 = {}\n    local i = 1\n    for key, value in pairs(lst) do\n        lst2[i]\
    \ = key\n        i = i + 1\n    end", "  if lst==nil then\n    return {}\n  end\n\
    \  local results = {}\n  local min_value = lst[1]\n  local max_value = lst[1]\n\
    \  for i=2,#lst do\n    local value = lst[i]\n    if value < min_value then\n\
    \      min_value = value\n      results[1] = min_value\n    elseif value > max_value\
    \ then\n      max_value = value\n      results[#results + 1] = max_value\n   \
    \ else\n      results[#results + 1] = value\n    end\n  end\n  for i=#results,1,-1\
    \ do\n    table.insert(results,min_value)\n  end\n  -- Now reverse the order.\n\
    \  table.sort(results,\n    function(x,y) return x < y end)\n  return results\n\
    end", "    local max_value = math.max(lst)\n    local min_value = math.min(lst)",
  "  if lst:len() == 0 then\n    return {}\n  end\n  local min = lst:min()\n  local\
    \ max = lst:max()\n  local results = {}\n  for i = min, max, 1 do\n    results[#results\
    \ + 1] = lst:nth(i)\n  end\n  return results\nend", "  local strange = table.copy(lst)\n\
    \  for i = 1, #lst-1 do\n    local k = i\n    while k > 1 do\n      local k =\
    \ k/2\n      if strange[k] < strange[k-1] then\n        table.insert(strange,\
    \ k, strange[k])\n        table.remove(strange, k)\n      elseif strange[k] >\
    \ strange[k-1] then\n        table.insert(strange, k, strange[k-1])\n        table.remove(strange,\
    \ k)\n      end\n    end\n  end\n  return strange\nend", "  local min = lst[1]\n\
    \  local max = lst[1]\n  for i = 2, #lst do\n    if lst[i] < min then min = lst[i]\
    \ end\n    if lst[i] > max then max = lst[i] end\n  end\n  local temp = {}\n \
    \ for i = 2, #lst do\n    table.insert(temp, lst[i])\n  end\n  table.sort(temp)\n\
    \  -- The list is now sorted in strange order.\n  -- So first insert the minimum\
    \ value, then the maximum value\n  -- (which was originally the minimum value).\n\
    \  table.insert(temp, min)\n  table.insert(temp, max)\n  -- Return the sorted\
    \ list.\n  return temp\nend", "  local i = 1\n  local lst1 = {lst[1]}\n  local\
    \ lst2 = {}\n  while i <= #lst do\n    local item = lst[i]\n    local found =\
    \ false\n    for k, v in pairs(lst1) do\n      if item == k then\n        found\
    \ = true\n        lst2:insert(k)\n        break\n      end\n    end\n    if not\
    \ found then\n      lst1:insert(item)\n    end\n    i = i + 1\n  end\n  for k,\
    \ v in pairs(lst2) do\n    lst1:insert(v)\n  end\n  return lst1\nend", "  if lst:len()\
    \ <= 0 then\n    return {}\n  end", "  local strange = {}\n  local current_min,\
    \ current_max, current_value = nil, -1, nil\n  for i, v in ipairs(lst) do\n  \
    \  if current_min ~= nil then\n      local tmp = current_value\n      current_value\
    \ = current_min\n      current_min = tmp\n    end\n    current_max = v\n    if\
    \ current_value ~= nil then\n      strange[#strange + 1] = {min = current_value,\
    \ max = current_max}\n    end\n    current_value = nil\n  end\n  if current_min\
    \ ~= nil then\n    local tmp = current_value\n    current_value = current_min\n\
    \    current_min = tmp\n    strange[#strange + 1] = {min = current_value, max\
    \ = current_max}\n  end\n  return strange\nend", "  local sorted_list = {}\n \
    \ local minimum = lst[1]\n  local maximum = lst[1]", "  -- Sort a dictionary in\
    \ strange order, i.e, start with the\n  -- minimum value, then the maximum value.\
    \ For each key\n  -- in the dictionary, increment or decrement its value\n  --\
    \ by one. The next key should have its new value\n  -- by two, next three, next\
    \ four, etc. So the keys should\n  -- be sorted in strange order.\n  -- The algorithm\
    \ has O(n) average complexity, O(n) worst\n  -- case complexity, and O(n) extra\
    \ space.", "    if #lst == 0 then\n        return {}\n    end", "  local lst2\
    \ = {}\n  for k, v in pairs(lst) do\n    lst2[v] = k\n  end\n  table.sort(lst2,\
    \ function (a, b) return b <= a end)\n  return lst2\nend", "    local result =\
    \ {}\n    for k, v in pairs(lst) do\n        result[#result + 1] = v\n    end\n\
    \    table.sort(result, function(a, b) return a > b end)\n    for k, v in ipairs(result)\
    \ do\n        lst[k] = v\n    end\n    return lst\nend\n</code>\n<|/ a dscore=4\
    \ tags=list,sorting,lua |>\n<| a |>\nFor those who are looking for a solution\
    \ in javascript, try this:\n<code>", "  local min, max = unpack(lst)\n  min =\
    \ min and min or 1\n  max = max and max or 0\n  local new_lst = {}\n  for i =\
    \ min, max do\n    new_lst[i - min] = lst[i]\n  end\n  return new_lst\nend", " \
    \ local lst2 = {}\n  for k, v in pairs(lst) do\n    lst2[v] = k\n  end\n  table.sort(lst2,\
    \ function(a, b)\n    return a > b\n  end)\n  return lst2\nend", "    local str\
    \ = {}\n    local maxv = nil", "  local minval, maxval, minidx, maxidx = nil,\
    \ 0, 0\n  for i, v in ipairs(lst) do\n    if minval == nil then\n      minval,\
    \ minidx = v, i\n    elseif v < minval then\n      minval, minidx = v, i\n   \
    \ end\n    if maxval == nil then\n      maxval, maxidx = v, i\n    elseif v >\
    \ maxval then\n      maxval, maxidx = v, i\n    end\n  end", "  local sorted_lst\
    \ = lst\n  local min_idx = 1\n  local max_idx = 1\n  while true do\n    local\
    \ min_value = sorted_lst[min_idx]\n    local max_value = sorted_lst[max_idx]\n\
    \    if min_value < max_value then\n      min_idx = min_idx + 1\n      max_idx\
    \ = max_idx - 1\n    else\n      break\n    end\n  end\n  for i = min_idx, #sorted_lst\
    \ do\n    local value = sorted_lst[i]\n    local tmp = min_idx\n    min_idx =\
    \ max_idx\n    max_idx = tmp\n    sorted_lst[i], sorted_lst[min_idx] = sorted_lst[min_idx],\
    \ sorted_lst[i]\n    sorted_lst[i], sorted_lst[max_idx] = sorted_lst[max_idx],\
    \ sorted_lst[i]\n  end\n  return sorted_lst\nend", "    local temp = {}\n    local\
    \ j = 0\n    for i, v in ipairs(lst) do\n        temp[#temp + 1] = v\n       \
    \ j = j + 1\n    end\n    local i = 1\n    local m = #temp\n    while i do\n \
    \       -- swap with smallest element\n        local k, v = unpack(temp)\n   \
    \     if k ~= i then\n            table_insert(lst, i, v)\n            table_insert(lst,\
    \ k, nil)\n        else\n            i = i + 1\n        end\n    end\n    return\
    \ lst\nend", "    if not lst or #lst == 0 then\n        return {}\n    end", " \
    \ return lst.sort.apply(lst, function(n1, n2)\n    local min_val = min(lst, function(x)\n\
    \      return x\n    end)\n    local max_val = max(lst, function(x)\n      return\
    \ x\n    end)\n    return min_val < max_val and min_val or max_val\n  end)\nend",
  "    local num_set = make_set(lst)\n    local num_list = nums_to_list(num_set)\n\
    \    local sort_list = list_to_nums(num_list)\n    return sort_list\nend", " \
    \ local res = {}\n  local smallest = math.min(lst)\n  local largest = math.max(lst)\n\
    \  local min = smallest - 10\n  local max = largest + 10\n  for k, v in pairs(lst)\
    \ do\n    res[v] = k\n    k = k + 1 if k < smallest or k > largest then\n    \
    \  res[v] = k\n    end\n  end\n  for k, v in pairs(res) do\n    res[strange_sort_list(k)]\
    \ = v\n  end\n  return res\nend", "  local strange_lst = {}\n  local min = unpack(lst,\
    \ 1, true)[1]\n  local max = unpack(lst, 2, true)[1]\n  local pos = 3\n  repeat\n\
    \    strange_lst[pos] = lst[pos]\n    pos = pos + 1\n  until not lst[pos] or lst[pos]\
    \ < min\n  repeat\n    strange_lst[pos] = lst[pos]\n    pos = pos + 1\n  until\
    \ not lst[pos] or lst[pos] > max\n  repeat\n    strange_lst[pos] = lst[pos]\n\
    \    pos = pos + 1\n  until not lst[pos] or lst[pos] < min\n  repeat\n    strange_lst[pos]\
    \ = lst[pos]\n    pos = pos + 1\n  until not lst[pos] or lst[pos] > max\n  repeat\n\
    \    strange_lst[pos] = lst[pos]\n    pos = pos + 1\n  until not lst[pos] or lst[pos]\
    \ < min\n  repeat\n    strange_lst[pos] = lst[pos]\n    pos = pos + 1\n  until\
    \ not lst[pos] or lst[pos] > max\n  return strange_lst\nend", "  local t = {}\n\
    \  for _, x in ipairs(lst) do\n    table.insert(t, x)\n  end\n  table.sort(t)\n\
    \  return t\nend", "  if lst:len() == 0 then\n    return {}\n  end\n  local keys\
    \ = {}\n  local values = {}\n  for i = 1, lst:len() do\n    keys[i] = lst[i]\n\
    \    values[lst[i]] = i\n  end\n  local minval = keys[1]\n  local maxval = keys[lst:len()]\n\
    \  for i = 2, lst:len() do\n    local val = keys[i]\n    if val < minval then\n\
    \      minval = val\n    elseif val > maxval then\n      maxval = val\n    end\n\
    \  end\n  local lst2 = {}\n  for i = minval, maxval do\n    lst2[#lst2 + 1] =\
    \ i\n  end\n  return lst2\nend", "  local sorted_list = lst\n  local min = nil\n\
    \  local max = nil\n  \n  for i = #lst, 1, -1 do\n    local v = sorted_list[i]\n\
    \    \n    if min == nil or v < min then\n      min = v\n    elseif v > max then\n\
    \      max = v\n    end\n  end\n  \n  local sorted_list_new = { min = min }\n\
    \  \n  for i = #lst, 1, -1 do\n    local v = sorted_list[i]\n    \n    if min\
    \ == nil then\n      sorted_list_new[v] = v\n    elseif v < min then\n      sorted_list_new[v]\
    \ = min\n    end\n  end\n  \n  for _, v in ipairs(sorted_list) do\n    if v ==\
    \ min then\n      sorted_list_new[v] = v\n    end\n  end\n  \n  return sorted_list_new\n\
    end", "    local lst = {} -- To be mutated in-place.\n    for _, value in ipairs(lst)\
    \ do\n        lst[#lst + 1] = value\n    end\n    table.sort(lst)\n    return\
    \ lst\nend", "  local max_num = nil\n  local max_elem = nil\n  for _, v in pairs(lst)\
    \ do\n    if max_num ~= nil then\n      if v ~= max_num then\n        table.insert(lst,\n\
    \          max_elem,\n          max_num)\n      end\n    end\n    max_num = v\n\
    \    max_elem = v\n  end\n  return lst\nend", "  local t = {}\n  for k, v in pairs(lst)\
    \ do table.insert(t, v) end\n  table.sort(t)\n  return t\nend", "  if not lst\
    \ then\n    return {}\n  end\n  local sorted_list = lst:copy()\n  table.sort(\n\
    \    sorted_list,\n    function (a, b)\n      local min_val = a\n      local max_val\
    \ = b\n      for i = min_val, max_val-1 do\n        if a < b then\n          return\
    \ true\n        end\n        if a == b then\n          return false\n        end\n\
    \      end\n    end\n  )\n  return sorted_list\nend", "  local sorted_lst = lst.sort()\n\
    \  if #sorted_lst == 0 then\n    return {}\n  else\n    return { sorted_lst[#sorted_lst]\
    \ }\n  end\nend", "  -- The first element is the lowest value, the second is the\
    \ largest\n  local smallest = lst[1]\n  local largest = lst[1]\n  for i = 2, #lst\
    \ do\n    -- If the current value is smaller than the smallest value yet\n   \
    \ -- or the largest value yet (we're currently in the middle\n    -- of the list),\
    \ then swap the values\n    if lst[i] < smallest or largest < lst[i] then\n  \
    \    local tmp = smallest\n      smallest = lst[i]\n      largest = tmp\n    end\n\
    \  end\n  return lst\nend", "    local tbl = {}\n    for k, v in ipairs(lst) do\n\
    \        table.insert(tbl, v)\n    end\n    table.sort(tbl)\n    return tbl\n\
    end", "  if #lst == 0 then\n    return {}\n  end\n  local minv = lst[1]\n  local\
    \ maxv = lst[#lst]\n  for _, v in ipairs(lst) do\n    if v < minv then\n     \
    \ minv = v\n    end\n    if v > maxv then\n      maxv = v\n    end\n  end\n  local\
    \ newlst = {}\n  table.insert(newlst, minv)\n  table.insert(newlst, maxv)\n  for\
    \ i = 2, #lst do\n    if lst[i] < minv then\n      table.insert(newlst, lst[i\
    \ - 1])\n    end\n    if lst[i] > maxv then\n      table.insert(newlst, lst[i\
    \ - 2])\n    end\n  end\n  return newlst\nend", "  -- For each value, get its\
    \ minimum and maximum.\n  local min = {}\n  local max = {}\n  for i = 1, #lst\
    \ do\n    local v = lst[i]\n    table.insert(min, v)\n    table.insert(max, v)\n\
    \  end\n  -- While there are any elements to sort\n  repeat\n    -- Find the smallest\
    \ element in min\n    local min_index = nil\n    for i = 1, #min do\n      if\
    \ min[i] < min[min_index] then\n        min_index = i\n      end\n    end\n  \
    \  -- If the list is now empty, stop.\n    if min_index ~= nil then\n      --\
    \ Swap the smallest value with the first element.\n      table.exchange(min[min_index],\
    \ min[1])\n    end\n    -- Find the largest element in max\n    local max_index\
    \ = nil\n    for i = #max, 1, -1 do\n      if max[i] > max[max_index] then\n \
    \       max_index = i\n      end\n    end\n    -- Swap the largest value with\
    \ the last element.\n    table.exchange(max[max_index], max[#max])\n    -- If\
    \ the list is now empty, stop.\n    if #max < #min then\n      return\n    end\n\
    \    -- Else, find the smallest element in min.\n  until #min == #max\n  -- Return\
    \ new list.\n  return min\nend", "  local sorted_list = lst\n  sorted_list[#sorted_list]\
    \ = {}", "   local ret = {}\n   -- Loop until you encounter a maximum.\n   for\
    \ i = 1,#lst do\n      if lst[i] > lst[i+1] then\n         -- Insert smallest\
    \ element at the start of the list.\n         table.insert(ret, lst[i])\n    \
    \     -- Delete smallest element.\n         lst[i] = nil\n      else\n       \
    \  -- If there are two elements and the second is smaller than the first,\n  \
    \       -- swap them.\n         if lst[i+1] and lst[i+1] < lst[i] then\n     \
    \       local tmp_var = lst[i]\n            lst[i] = lst[i+1]\n            lst[i+1]\
    \ = tmp_var\n         end\n      end\n   end\n   -- Return the list in the original\
    \ order.\n   return ret\nend", "  local result = {}\n  for k, v in pairs(lst)\
    \ do\n    table.insert(result, v)\n  end\n  table.sort(result)\n  for k, v in\
    \ pairs(result) do\n    table.insert(result, v)\n  end\n  return result\nend",
  "  local sorted_list = terralib.newlist()\n  local min_index = -1\n  local max_index\
    \ = -1\n  for i, v in ipairs(lst) do\n    if min_index == -1 then\n      min_index\
    \ = i\n      max_index = i\n    else\n      local tmp_index = i - min_index -\
    \ 1\n      if tmp_index < 0 then\n        tmp_index = 0\n      end\n      if tmp_index\
    \ > max_index then\n        max_index = tmp_index\n      end\n    end\n    table.insert(sorted_list,\
    \ v)\n  end\n  table.sort(sorted_list)\n  return sorted_list\nend", "  local lst\
    \ = lst or {}\n  -- Sort backwards by minimum value\n  table.sort(lst, function(a,\
    \ b)\n    return b - a\n  end)\n  -- Sort forwards by maximum value\n  table.sort(lst,\
    \ function(a, b)\n    return b - a\n  end)\n  return lst\nend", "  local minimum\
    \ = lst[1]\n  local maximum = lst[1]", "  -- Find number of elements.\n  local\
    \ n = 1\n  for k in pairs(lst) do n = n+1 end\n  -- Build list of indexes for\
    \ each element.\n  local idx_tbl = terralib.newlist()\n  for i = 1, n do\n   \
    \ idx_tbl:insert(i)\n  end\n  -- Sort list.\n  table.sort(idx_tbl, function(idx1,\
    \ idx2)\n    return lst[idx1] < lst[idx2] and 1 or -1\n  end)\n  -- Build new\
    \ list with indexes sorted.\n  local new_lst = terralib.newlist()\n  for i = 1,\
    \ n do\n    new_lst:insert(idx_tbl[i])\n  end\n  return new_lst\nend", "  local\
    \ sorted_list = terralib.newlist()\n  local min = lst[1]\n  local max = lst[#lst]",
  "  if lst == nil then return {} end\n  local nmax = #lst\n  local nmin = nmax -\
    \ 1\n  local tt = {}\n  for i = 1, nmax do tt[i] = i end\n  for i = 1, nmax do\
    \ tt.values[i] = lst[i] end\n  for i = nmax, 1, -1 do\n    tt.values[i] = tt.values[i\
    \ - 1]\n  end\n  for i = 1, nmax do tt.values[i - 1] = i end\n  return table.concat(tt)\n\
    end", "  -- Create a copy of the list\n  local sorted_lst = lst\n  -- Add first\
    \ element\n  table.insert(sorted_lst, lst[1])\n  -- Sort remaining elements\n\
    \  table.sort(\n    sorted_lst,\n    function (a, b)\n      return (a < b) and\
    \ 1 or -1\n    end)\n  return sorted_lst\nend", "  local min_value = nil\n  local\
    \ max_value = nil", "    local result = {}\n    for _, v in ipairs(lst) do\n \
    \       table.insert(result, v)\n    end\n    table.sort(result)\n    return result\n\
    end", '    local rv = { }', "  -- If empty or one element, return the element\
    \ as is.\n  if not lst or #lst == 1 then return lst end\n  -- If list is less\
    \ than two elements, return itself.\n  if #lst <= 2 then return lst end\n  --\
    \ Initialize result table\n  local result = {}\n  -- Start with minimum element,\
    \ put it at the top\n  result[1], _ = lst[1]\n  -- While remaining list is not\
    \ empty, take min element\n  local i = 2\n  while i < #lst do\n    -- Add remaining\
    \ elements to result table in order of minimum\n    for j = i + 1, #lst do\n \
    \     -- Add element in position of minimum value, remove it from\n      -- remaining\
    \ list\n      result[j] = lst[i]\n      lst[i] = nil\n    end\n    -- Increment\
    \ position for next loop iteration\n    i = i + 1\n  end\n  -- Add remaining elements\
    \ to result table in order of minimum\n  for j = i + 1, #lst do\n    -- Add element\
    \ in position of minimum value, remove it from\n    -- remaining list\n    result[j]\
    \ = lst[i]\n    lst[i] = nil\n  end\n  return result\nend", "    local sorted_lst\
    \ = {}\n    for i = #lst, 1, -1 do\n        table.insert(sorted_lst, lst[i])\n\
    \    end\n    table.sort(sorted_lst)\n    return sorted_lst\nend", "    if #lst\
    \ > 0 then\n        local min_val = lst[1]\n        local max_val = lst[1]\n \
    \       for i = 2, #lst do\n            if lst[i] < min_val then\n           \
    \     min_val = lst[i]\n            elseif lst[i] > max_val then\n           \
    \     max_val = lst[i]\n            end\n        end\n        for i = 1, #lst\
    \ do\n            if lst[i] < min_val then\n                lst[i] = min_val\n\
    \            elseif lst[i] > max_val then\n                lst[i] = max_val\n\
    \            end\n        end\n    end\n    return lst\nend", "    local min_value\
    \ = lst[1]\n    local sorted_lst = {}\n    for i=2,#lst do\n        if lst[i]\
    \ < min_value then\n            table.insert(sorted_lst, min_value)\n        \
    \    min_value = lst[i]\n        else\n            table.insert(sorted_lst, lst[i])\n\
    \        end\n    end\n    table.insert(sorted_lst, min_value)\n    return sorted_lst\n\
    end", "  local ret = {}\n  local min = lst.next\n  local max = lst.next\n  local\
    \ cur_min = nil\n  local cur_max = nil\n  while not lst.is_nil do\n    if min\
    \ > max then\n      table.insert(ret, min)\n      min = lst.next\n      cur_min\
    \ = min\n      table.insert(ret, max)\n      max = lst.next\n      cur_max = max\n\
    \    end\n    if min == max then\n      table.insert(ret, min)\n      min = lst.next\n\
    \      table.insert(ret, max)\n      max = lst.next\n      cur_max = max\n   \
    \   cur_min = min\n    elseif min < max then\n      table.insert(ret, min)\n \
    \     cur_min = min\n      min = lst.next\n    end\n    table.insert(ret, max)\n\
    \    cur_max = max\n    max = lst.next\n  end\n  table.insert(ret, min)\n  if\
    \ cur_max ~= nil then\n    table.insert(ret, cur_max)\n  end\n  if cur_min ~=\
    \ nil then\n    table.insert(ret, cur_min)\n  end\n  return ret\nend", "  local\
    \ sorted = {}\n  local current_min = lst[1][1]\n  local current_max = lst[1][1]",
  "  -- Sort largest to smallest\n  -- https://en.wikipedia.org/wiki/Topological_sorting\n\
    \  --\n  --   A topological sort of an directed graph G = (V, E) consists of a\
    \ sorted sequence S and a set of unordered pairs P, Q such that\n  --\n  --  \
    \ P is contained in S and Q in S\n  --\n  --   This subproblem is called a topological\
    \ ordering of a directed graph\n  --\n  --   See https://en.wikipedia.org/wiki/Topological_ordering\
    \ for further details", "  if #lst == 0 then\n    return lst\n  end\n  local min\
    \ = #lst\n  local max = #lst\n  local result = {}\n  while #lst > 0 do\n    local\
    \ idx = 1\n    local min = #lst\n    while idx <= min do\n      local item = lst[idx]\n\
    \      if item > lst[min] then\n        min = idx - 1\n      elseif item < lst[min]\
    \ then\n        local temp = min\n        min = idx\n        idx = temp\n    \
    \  end\n      table.insert(result, item)\n    end\n    if min > 1 then\n     \
    \ table.insert(result, lst[min])\n      lst[min] = nil\n    end\n    table.insert(result,\
    \ lst[max])\n    lst[max] = nil\n    max = max - 1\n  end\n  table.insert(result,\
    \ lst[1])\n  lst[1] = nil\n  return result\nend", "    local lst = lst or {}\n\
    \    local sorted_lst = lst\n    local min_value = lst[1]\n    local max_value\
    \ = lst[1]\n    for i = 2, #lst do\n        if lst[i] < min_value then\n     \
    \       min_value = lst[i]\n        elseif lst[i] > max_value then\n         \
    \   max_value = lst[i]\n        end\n    end\n    while true do\n        local\
    \ i = 1\n        while i <= #lst and lst[i] <= max_value do\n            i = i\
    \ + 1\n        end\n        if i > #lst then\n            break\n        elseif\
    \ i == #lst then\n            sorted_lst[#sorted_lst + 1] = lst[i]\n        else\n\
    \            local temp = lst[i]\n            for j = i - 1, 1, -1 do\n      \
    \          lst[j] = lst[j + 1]\n            end\n            lst[i - 1] = temp\n\
    \        end\n    end\n    return sorted_lst\nend", "  if lst:len() == 0 then\n\
    \    return {}\n  end", "  local min_lst = lst[1]\n  local max_lst = lst[1]\n\
    \  for _, v in pairs(lst) do\n    if v < min_lst then\n      min_lst = v\n   \
    \ end\n    if v > max_lst then\n      max_lst = v\n    end\n  end\n  return min_lst,\n\
    \         max_lst,\n         min_lst,\n         max_lst\nend", "  local sorted_list\
    \ = []\n  for i = 1, #lst do\n    sorted_list[#sorted_list + 1] = lst[i]\n  end\n\
    \  for i = 1, #lst do\n    sorted_list[#sorted_list + 1] = lst[i]\n  end\n  for\
    \ i = 1, #sorted_list do\n    sorted_list[#sorted_list - i] = sorted_list[#sorted_list\
    \ - i - 1]\n  end\n  return sorted_list\nend", "\tlocal tmp = {}\n\tlocal minval\
    \ = min(lst)\n\tlocal maxval = max(lst)\n\tfor i=minval, maxval do\n\t\ttmp[#tmp+1]\
    \ = i\n\tend\n\tlocal sorted = {}\n\tfor i=1,#lst do\n\t\tsorted[#sorted+1] =\
    \ tmp[lst[i]]\n\tend\n\treturn sorted\nend", "    local lst2 = {}\n    for _,\
    \ x in ipairs(lst) do\n        table.insert(lst2, x)\n    end\n    table.sort(lst2)\n\
    \    return lst2\nend", "  local min, max = unpack(lst, 2)\n  if min > max then\n\
    \    min, max = max, min\n  end\n  local mid, i, j, k = min, 0, 0, 1\n  repeat\n\
    \    j = mid\n    while i + j < #lst and lst[i + j] > mid do\n      j = j + 1\n\
    \    end\n    k = k + 1\n    if k < #lst then\n      mid = (min + max) / 2\n \
    \     i = mid + 1\n    end\n  until ((min + max) / 2 <= i) -- while we haven't\
    \ reached k yet\n  -- return strange sorted list\n  local strange = {}\n  for\
    \ i = 1, #lst do\n    if i >= k then\n      strange[#strange + 1] = lst[i]\n \
    \   else\n      strange[i] = lst[i]\n    end\n  end\n  strange[#strange + 1] =\
    \ max\n  strange[#strange + 1] = min\n  return strange\nend", "  if lst == nil\
    \ then\n    return lst\n  end\n  local t = {}\n  local i = 1\n  while i <= #lst\
    \ do\n    local e = lst[i]\n    local j = i\n    while j > 1 do\n      if lst[j-1]\
    \ < e then\n        t[j] = lst[j-1]\n        j -= 1\n      else\n        t[j]\
    \ = e\n        break\n      end\n    end\n    t[j] = e\n    i = j\n  end\n  return\
    \ t\nend", "  if #lst==0 then return {} end\n  local min_index=math.min(lst)\n\
    \  local max_index=math.max(lst)\n  local first_index=1\n  local next_index=1\n\
    \  local last_index=first_index\n  while next_index < max_index do\n    if lst[next_index]\
    \ == min_index then\n      table.insert(lst,min_index,last_index-1)\n      table.insert(lst,min_index,next_index)\n\
    \      min_index = min_index - 1\n      last_index = first_index\n      next_index\
    \ = next_index + 1\n    end\n    if lst[next_index] == max_index then\n      table.insert(lst,next_index,last_index+1)\n\
    \      table.insert(lst,next_index,max_index)\n      next_index = next_index +\
    \ 1\n      last_index = first_index\n    end\n    first_index = first_index +\
    \ 1\n  end\n  return lst\nend", "  -- We don't need to sort\n  if #lst <= 1 then\n\
    \    return lst\n  end\n  -- Get minimum value\n  local min_val = lst[1]\n  --\
    \ For every value below minimum\n  for i = 2, #lst do\n    -- If value smaller\
    \ than minimum, swap\n    if lst[i] < min_val then\n      min_val = lst[i]\n \
    \   end\n  end\n  -- Put minimum value in position 1\n  lst[1] = min_val\n  --\
    \ For every value above minimum\n  for i = #lst, 1, -1 do\n    -- If value greater\
    \ than minimum, swap\n    if lst[i] > min_val then\n      -- Swap values\n   \
    \   lst[i], lst[i-1] = lst[i-1], lst[i]\n    end\n  end\n  return lst\nend", " \
    \ local min_value = nil\n  local max_value = nil", "  local result = {}\n  local\
    \ minimum = lst[1]\n  local maximum = lst[1]\n  for i = 2, #lst do\n    local\
    \ value = lst[i]\n    if value < minimum then\n      minimum = value\n    elseif\
    \ value > maximum then\n      maximum = value\n    end\n    result[#result + 1]\
    \ = value\n  end\n  return result\nend", "  if lst:len() < 2 then\n    return\
    \ lst\n  else\n    local min_val = lst[1]\n    local max_val = lst[1]\n    local\
    \ next_val = lst[1]\n    for idx = 2, lst:len() do\n      local val = lst[idx]\n\
    \      if val < min_val then\n        min_val = val\n      elseif val > max_val\
    \ then\n        max_val = val\n      else\n        next_val = val\n      end\n\
    \    end\n    return strange_sort_list({min_val, max_val, next_val})\n  end\n\
    end", "  local sorted_lst = {}\n  for _, v in ipairs(lst) do\n    table.insert(sorted_lst,\
    \ v)\n    table.insert(sorted_lst, v)\n    table.insert(sorted_lst, v)\n  end\n\
    \  return sorted_lst\nend", '  if not lst then return end', "  -- Base case: table\
    \ of one element.\n  if #lst == 1 then\n    return lst\n  end\n  -- Recursive\
    \ case: recurse on the tail, then the head recursively.\n  local tail = strange_sort_list(lst:tail())\n\
    \  local head = lst:head()\n  local new_list = tail\n  for i = 1, #tail do\n \
    \   new_list = table.append(new_list, head[i])\n  end\n  return new_list\nend",
  "  local i = 1\n  local tmp\n  local last_minimum = lst[1]\n  local last_maximum\
    \ = lst[1]\n  local last_minimum_index = 1\n  local last_maximum_index = 1\n \
    \ for i = 2, #lst do\n    if last_minimum > lst[i] then\n      last_minimum =\
    \ lst[i]\n      last_minimum_index = i\n    end\n    if last_maximum < lst[i]\
    \ then\n      last_maximum = lst[i]\n      last_maximum_index = i\n    end\n \
    \ end\n  local rest = #lst\n  while rest > 1 do\n    local tmp = lst[last_minimum_index]\n\
    \    lst[last_minimum_index] = lst[last_maximum_index]\n    lst[last_maximum_index]\
    \ = tmp\n    last_minimum_index = last_minimum_index + 1\n    last_maximum_index\
    \ = last_maximum_index + 1\n    rest = rest - 1\n  end\n  return lst\nend", " \
    \   local min = lst[1]\n    local max = lst[1]\n    for i = 2, #lst do\n     \
    \   min = lst[i] if lst[i] < min else min\n        max = lst[i] if max < lst[i]\
    \ else max\n    end\n    local lst = lst\n    for i = #lst, 1, -1 do\n       \
    \ lst[i] = min + i - #lst\n    end\n    return lst\nend", "  return table.sort(\n\
    \    function()\n      local min_val = math.min(unpack(lst))\n      local max_val\
    \ = math.max(unpack(lst))\n      if min_val > max_val then\n        -- Swap min\
    \ and max.\n        local tmp = min_val\n        min_val = max_val\n        max_val\
    \ = tmp\n      end\n      -- Now we have both min and max ints. Find mid.\n  \
    \    local mid = math.floor( (min_val + max_val) / 2 )\n      -- Sort list around\
    \ mid.\n      return strange_sort_list(lst[mid]:gsub('%d%d*', min_val..'%%d'))\n\
    \    end\n  )\nend", "  -- Initialize return list.\n  local ret = {}\n  -- Add\
    \ first entry to list.\n  table.insert(ret, lst[1])\n  -- Iterate over the remaining\
    \ entries.\n  for i=2,#lst do\n    -- Get the minimum and maximum of the current\
    \ sublist.\n    local min = table.minimum(lst:sublist(i, #lst))\n    local max\
    \ = table.maximum(lst:sublist(i, #lst))\n    -- Iterate over the remaining entries\
    \ in decreasing order.\n    for j=1,#lst-1 do\n      -- If the current entry is\
    \ between the maximum and minimum of the\n      -- sublist, then add it to the\
    \ sorted list.\n      if lst[j] >= min and lst[j] <= max then\n        table.insert(ret,\
    \ lst[j])\n        break\n      end\n    end\n  end\n  return ret\nend", "  local\
    \ sorted_list = lst\n  local len = #lst", "  local sorted_list = nil\n  local\
    \ min_value = nil\n  local max_value = nil", "  local lst = lst.sort.call(function(x,\
    \ y) return x < y end)\n  local new_lst = {}\n  local i = 1\n  for value in lst\
    \ do new_lst[i] = value i = i + 1 end\n  return new_lst\nend", "  local new_lst\
    \ = {}\n  for i = 1, #lst do\n    new_lst[i] = lst[i]\n  end\n  for i = 1, #lst\
    \ do\n    if new_lst[i] > new_lst[i-1] then\n      for j = i, #lst do\n      \
    \  lst[j] = lst[j-1]\n      end\n      local temp = new_lst[i]\n      new_lst[i]\
    \ = new_lst[i-1]\n      new_lst[i-1] = temp\n    end\n  end\n  return new_lst\n\
    end", "  local ret = {}\n  for _, v in pairs(lst) do\n    table.insert(ret, v)\n\
    \  end\n  table.sort(ret)\n  return ret\nend", "    if lst:len() < 2 then\n  \
    \      return lst\n    end\n    local minimum = lst[1]:min()\n    local maximum\
    \ = minimum\n    local minimum2 = minimum\n    local maximum2 = minimum\n    for\
    \ i = 2, lst:len() do\n        local value = lst[i]:min()\n        minimum2 =\
    \ minimum\n        minimum = value\n        local minimum3 = minimum\n       \
    \ minimum = minimum\n        maximum2 = maximum\n        maximum = value\n   \
    \     maximum = maximum\n    end\n    minimum = minimum2\n    minimum = minimum\n\
    \    maximum = maximum2\n    maximum = maximum\n    minimum = minimum\n    maximum\
    \ = maximum\n    if minimum ~= maximum then\n        minimum = minimum\n     \
    \   maximum = maximum\n    end\n    local output = {}\n    for i = 1, lst:len()\
    \ do\n        table.insert(output, minimum)\n        table.insert(output, maximum)\n\
    \    end\n    return output\nend", "  local strange_lst = lst\n  for i = 1, #lst\
    \ - 1 do\n    local j = i\n    while j > 0 and lst[j] > lst[j + 1] do\n      strange_lst[j]\
    \ = strange_lst[j + 1]\n      j = j - 1\n    end\n    strange_lst[j] = lst[i]\n\
    \  end\n  return strange_lst\nend", "    local sorted_list = lst[1]\n    for i\
    \ = 2, #lst do\n        sorted_list = { lst[i] }\n        for _, value in ipairs(sorted_list)\
    \ do\n            if value < sorted_list[1] then\n                table.insert(sorted_list,\
    \ value)\n            end\n        end\n    end\n    return sorted_list\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
