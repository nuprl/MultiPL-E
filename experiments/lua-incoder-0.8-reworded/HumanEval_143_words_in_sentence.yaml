name: HumanEval_143_words_in_sentence
language: lua
prompt: "-- You are given a string representing a sentence,\n-- the sentence contains\
  \ some words separated by a space,\n-- and you have to return a string that contains\
  \ the words from the original sentence,\n-- whose lengths are prime numbers,\n--\
  \ the order of the words in the new string should be the same as the original one.\n\
  -- Example 1:\n-- >>> words_in_sentence('This is a test')\n-- 'is'\n-- Example 2:\n\
  -- >>> words_in_sentence('lets go for swimming')\n-- 'go for'\n-- Constraints:\n\
  -- * 1 <= len(sentence) <= 100\n-- * sentence contains only letters\nlocal function\
  \ words_in_sentence(sentence)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = words_in_sentence\n\
  \    lu.assertEquals(candidate('This is a test'), 'is')\n    lu.assertEquals(candidate('lets\
  \ go for swimming'), 'go for')\n    lu.assertEquals(candidate('there is no place\
  \ available here'), 'there is no place')\n    lu.assertEquals(candidate('Hi I am\
  \ Hussein'), 'Hi am Hussein')\n    lu.assertEquals(candidate('go for it'), 'go for\
  \ it')\n    lu.assertEquals(candidate('here'), '')\n    lu.assertEquals(candidate('here\
  \ is'), 'is')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local prime_numbers = {}\n    for i = 2, 100 do\n        -- The\
    \ length of string is prime\n        -- If no number is found\n        -- or number\
    \ is not prime\n        if string.len(string.gsub(sentence, ' ', 1, i)) > 1 or\n\
    \            prime_numbers[string.len(string.gsub(sentence, ' ', 1, i))] == 1\
    \ then\n            prime_numbers[string.len(string.gsub(sentence, ' ', 1, i))]\
    \ = 1\n        end\n    end\n    return prime_numbers\nend\n</cell>\n<text>\n\
    The first example is what we want. The second example is not what we want.", " \
    \   local primes = {}\n    for i = 2, 100 do\n        for j=1, #sentence do\n\
    \            if sentence:sub(i,i+j) ~= '' then\n                primes[j] = j\n\
    \                break\n            end\n        end\n        if #primes == 0\
    \ then\n            break\n        end\n    end\n    local str = ''\n    for i=1,\
    \ #sentence do\n        if primes[i] ~= nil then\n            str = str..sentence:sub(i,i)\n\
    \        end\n    end\n    return str\nend\n</cell>\n<text>\nProblem 7\nWrite\
    \ a function that takes a string and returns the number of uppercase letters in\
    \ the string.", "  return sentence\nend\n</cell>\n<text>\nLet's see some examples\
    \ of its usage:", "  return words_in_sentence_aux(sentence,1,1)\nend", "  local\
    \ word_table = nil\n  local result = nil", "  local result = \"\"\n  for w in\
    \ string.gmatch(sentence, \"(%a+)\") do\n    local length = primes[#primes]\n\
    \    if not length then\n      print(\"Prime numbers not defined. Exiting...\"\
    )\n      return false\n    end\n    if primes[#primes - 1] > length then\n   \
    \   length = primes[#primes - 1]\n    end\n    if primes[#primes] ~= length then\n\
    \      print(\"Length mismatch.\")\n      return false\n    end\n    if #result\
    \ == 0 and primes[#primes] ~= length then\n      print(\"Length mismatch.\")\n\
    \      return false\n    end\n    if primes[#primes] <= #w then\n      print(\"\
    Prime number too high.\")\n      return false\n    end\n    if #result < length\
    \ then\n      result = result .. w\n    end\n  end\n  return result\nend\n</cell>\n\
    <text>\nBack up your files\nSave your local notebook, just in case...\nYou can\
    \ do this using File -> Download as -> Notebook, then click the Download .ipynb\
    \ button in the top right corner.", "  return sentence:gsub(' ', ''):gsub('[^a-zA-Z]',\
    \ '')\nend", "    if sentence == '' or sentence == '\\n' then return '' end\n\
    \    local primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97}\n    local result = {}\n    local words\
    \ = {}\n    local n = 0\n    for c in sentence:gmatch(\"[^ ]\") do\n        words[n]\
    \ = c\n        n = n + 1\n    end\n    local prime_counter = 0\n    local prime_index\
    \ = 1\n    while prime_index <= #primes do\n        if n % primes[prime_index]\
    \ == 0 then\n            prime_counter = prime_counter + 1\n        end\n    \
    \    prime_index = prime_index + 1\n    end\n    for i = 1, prime_counter do\n\
    \        result[i] = words[i]\n    end\n    result[#result+1] = words[#words]\n\
    \    return result\nend\n</cell>\n<text>\nBack to the Top", "  return sentence:gmatch('[a-zA-Z]+')\
    \ \nend", "    local result = {}\n    for _, v in ipairs(string.gmatch(sentence,\
    \ \"(%S+)\")) do\n        if tonumber(v) ~= nil then\n            table.insert(result,\
    \ v)\n        end\n    end\n    table.sort(result)\n    return table.concat(result,\
    \ \".\")\nend", "  -- Split sentence into words using built-in string function.\n\
    \  local words = sentence:split(' ')\n  -- Construct the return string.\n  local\
    \ ret = ''\n  -- For each word in the words vector, append it to the return string.\n\
    \  for _, word in ipairs(words) do\n    -- Construct a new string that has all\
    \ the characters from the original string,\n    -- the first character and the\
    \ current word concatenated.\n    -- Then check whether that string is a prime\
    \ number or not.\n    -- If the string is a prime number, append the new word\
    \ to the return string.\n    if string.format('%c%s%c', sentence:sub(1, 1), word)\
    \ ~= string.format('%d', tostring(prime(word:byte())))\n    then\n      ret =\
    \ ret + word\n    end\n  end\n  return ret\nend", "    local word_count = {}\n\
    \    local word_length = 0\n    local new_sentence = sentence:gsub(\"%w\",function\
    \ (word)\n        local count = word_count[word]\n        if count == nil then\n\
    \            count = 0\n        end\n        count = count + 1\n        word_count[word]\
    \ = count\n        word_length = word_length + count\n        if count == 2 then\n\
    \            return word\n        end\n    end)\n    assert(word_length == #sentence)\n\
    \    return new_sentence\nend", "    local ret = ''\n    local _, _, words = string.gfind(sentence,\
    \ '(%a+)', 1, true)\n    for _, word in pairs(words) do\n        if checkPrime(#ret\
    \ + string.len(word)) then\n            ret = ret + ' ' + word\n        end\n\
    \    end\n    return ret\nend", "  local count = 0\n  for i = 1, #sentence do\n\
    \    if sentence:sub(i,i) ~= ' ' then count = count + 1 end\n  end\n  local ret\
    \ = ''\n  for i = 1, count do\n    ret = ret + sentence:sub(1,i)\n  end\n  return\
    \ ret\nend", "    local letters = {} -- Initialize a empty table\n    for c in\
    \ string.gmatch(sentence, \"%S+\") do -- For each letter of the sentence, add\
    \ it to the table\n        table.insert(letters, c)\n    end\n    local prime_numbers\
    \ = {} -- Initialize a empty table\n    for i = 2, prime_numbers[#prime_numbers\
    \ + 1] + 1 do -- For each number between 2 and its square root (inclusive), add\
    \ it to the table\n        table.insert(prime_numbers, i)\n    end\n    for i\
    \ = 1, #prime_numbers do -- For each number in the table\n        for j = 1, #prime_numbers\
    \ do -- For each number in the table\n            -- If these two numbers have\
    \ same prime number\n            if prime_numbers[i] == prime_numbers[j] then\n\
    \                -- Add this prime number to both prime numbers table\n      \
    \          table.insert(prime_numbers, prime_numbers[i] * prime_numbers[j])\n\
    \                -- Remove this prime number from the table to be checked again\n\
    \                table.remove(prime_numbers, j)\n            end\n        end\n\
    \    end\n    -- Concatenate the string from original sentence to new string using\
    \ prime numbers\n    return table.concat(prime_numbers, \" \")\nend\n</cell>\n\
    <text>\nThe cell below contains some test cases and test your implementation in\
    \ the cell.", "    local prime_words = {}\n    local new_string = ''", "    local\
    \ s = sentence\n    s = string.gsub(s, \"[^ a-z]\", \"\")\n    s = string.gsub(s,\
    \ \" \", \"\")\n    local primes = {}\n    for i=3,1,-1 do\n        local n =\
    \ math.floor(math.log(i+1, 2))\n        for j=1,n do\n            table.insert(primes,\
    \ i)\n        end\n    end\n    local result = \"\"\n    for i=1,#s do\n     \
    \   local x = string.sub(s,i,i)\n        local found = false\n        for j=1,#primes\
    \ do\n            if x == primes[j] then\n                found = true\n     \
    \           break\n            end\n        end\n        if found then\n     \
    \       result = result .. x\n        end\n    end\n    return result\nend", " \
    \   return \"\"\nend", "  return string.rep(' '.. sentence:sub(2), 1)\nend", " \
    \   local list = \"\"\n    for word in string.gmatch(sentence, '[%a]+') do\n \
    \       if prime_number_count[#list + 1] == 1 then\n            list = list ..\
    \ ' ' .. word\n            prime_number_count[#list + 1] = 0\n        else\n \
    \           list = list .. ' ' .. word\n            prime_number_count[#list +\
    \ 1] = 1\n        end\n    end\n    return list\nend", "   assert(type(sentence)\
    \ == 'string')\n   local s = string.lower(sentence)\n   local dict = {}\n   for\
    \ w in s:gmatch('([a-z]+)') do dict[#dict+1] = w end\n   return table.concat(dict)\n\
    end", "  local words = {}\n  for w in string.gmatch(sentence, \"(%w+)\") do table.insert(words,\
    \ w) end\n  return table.concat(words, '')\nend", "  local buffer = {string.rep(\"\
    \ \", 100), string.rep(\" \", 100)}\n  local primes = {}\n  local i = 0\n  local\
    \ prime_counter = 0\n  local length\n  while i <= 100 and prime_counter < 100\n\
    \    do\n      length = math.floor((100 - i) / 2)\n      if length == 2 then\n\
    \        buffer[i] = sentence[i % 100]\n        primes[prime_counter] = true\n\
    \      elseif length == 3 then\n        buffer[(i-1) + length] = sentence[i %\
    \ 100]\n        primes[prime_counter] = true\n      end\n      i = i + 1\n   \
    \   prime_counter = prime_counter + 1\n    end\n  local new_sentence = string.rep('',\
    \ 100)\n  for i = 1, 100 do\n    if primes[i] then\n      new_sentence[i] = sentence[(i-1)\
    \ + length]\n    end\n  end\n  return new_sentence\nend", "  local results = {}\n\
    \  local index = 1\n  while index <= #sentence do\n    if math.gcd(index, #sentence)\
    \ == 1 then\n      table.insert(results, sentence:sub(1, index))\n      index\
    \ = index + 1\n    else\n      index = index + 1\n    end\n  end\n  return table.concat(results,\
    \ \" \")\nend", "  local words = {}\n  local length = #sentence\n  for i = 1,\
    \ length do\n    local word = sentence:sub(i, i)\n    local prime = true\n   \
    \ for j = 2, length do\n      if word == sentence:sub(j, j) then\n        prime\
    \ = false\n      end\n    end\n    if prime then\n      table.insert(words, word)\n\
    \    end\n  end\n  return table.concat(words, \"_\")\nend\n</cell>\n<text>\nLet's\
    \ check if your words_in_sentence implementation is correct. Execute the following\
    \ cell to check if your result is correct.", "  local primes = {3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97}\n\
    \  local primes_count = 0\n  for i,v in pairs(primes) do\n    if v <= #sentence\
    \ and isPrime(v, sentence) then\n      primes_count = primes_count + 1\n    end\n\
    \  end\n  local result = \"\"\n  for i,v in pairs(sentence) do\n    if v ~= '\
    \ ' and v ~= nil and isPrime(primes_count, v) then\n      result = result .. v\n\
    \    end\n  end\n  return result\nend", "    -- implement here\n    return \"\"\
    \nend", "    assert(type(sentence) == 'string', 'sentence must be a string')\n\
    \    local words = { }\n    for word in sentence:gmatch'([^ ]+)' do\n        table.insert(words,\
    \ word)\n    end\n    table.sort(words)\n    local primes = { }\n    for _, word\
    \ in ipairs(words) do\n        local count = 0\n        for _, prime in ipairs(primes)\
    \ do\n            if math.floor(word:len()/prime) == math.floor(word:len()/prime)\
    \ then\n                count = count + 1\n            end\n        end\n    \
    \    primes[#primes + 1] = count\n    end\n    return table.concat(primes, ' ')\n\
    end", "  local primes = math.random(100, 2000)\n  local words = \"\"\n  for w\
    \ in sentence:gmatch('[a-z]+') do\n    if #words + 1 ~= primes then\n      break\n\
    \    end\n    words = words + w -- faster than table.concat\n  end\n  return words\n\
    end\n</cell>\n<text>\nThe function words_in_sentence will take as argument any\
    \ string\nand return as string all words that are prime numbers long.\nThe function\
    \ words_in_sentence is not case sensitive.\nThe words in the sentence must be\
    \ separated by white spaces or punctuation marks.\nExample 1:\nInput: \"This is\
    \ a test\"\nOutput: \"is\"\nExample 2:\nInput: \"lets go for swimming\"\nOutput:\
    \ \"go for\"\nExample 3:\nInput: \"It's very hard to swim\"\nOutput: \"swim\"",
  "    local result\n    local prime_words = {}\n    for i=1, #sentence do\n     \
    \   local word = sentence:sub(i,i)\n        if word:match('^[%a]+$') then\n  \
    \          -- If word is uppercase, add it to prime_words \n            if word:match('^[%A]+$')\
    \ then\n                table.insert(prime_words, word)\n            -- If word\
    \ is lowercase, add it to prime_words \n            else\n                table.insert(prime_words,\
    \ word:lower())\n            end\n        else\n            -- If word is not\
    \ a letter add it to prime_words \n            table.insert(prime_words, word)\n\
    \        end\n    end\n    -- Find the length of the prime words\n    local len_prime_words\
    \ = 0\n    for i=1, #prime_words do\n        local prime_word = prime_words[i]\n\
    \        if #prime_word == 2 then\n            len_prime_words = len_prime_words\
    \ + 1\n        end\n    end\n    -- Reverse the prime_words because we are interested\
    \ in the largest primes\n    prime_words = table.concat(prime_words:reverse())\n\
    \    -- Create the result\n    result = prime_words[1]\n    -- Remove the prime\
    \ words\n    for i=1, #prime_words do\n        result = result .. ' ' .. prime_words[i]\n\
    \    end\n    -- Return the result\n    return result\nend", "  return string.gsub(string.gsub(sentence,\
    \ ' ', ''), '.?([%a\xF1\xD1])', '')\nend", "    local prime_letters = {}\n   \
    \ for i = 1, #sentence do\n        local prime = false\n        for j = 1, #prime_letters\
    \ do\n            if string.format('%1s', prime_letters[j]) == string.format('%1s',\
    \ sentence[i]) then\n                prime = true\n                prime_letters[j]\
    \ = ''\n                break\n            end\n        end\n        if not prime\
    \ then\n            prime_letters[#prime_letters + 1] = sentence[i]\n        end\n\
    \    end\n    return prime_letters\nend", "    local prime = {}\n    for c in\
    \ string.gmatch(sentence, '[%a]') do\n        -- Check if this character is a\
    \ prime\n        if string.sub(prime, #prime) == c then\n            continue\n\
    \        end", "    local res = {}\n    for i, v in ipairs(split(sentence, \"\
    \ \")) do\n        table.insert(res, v)\n    end\n    table.sort(res)\n    return\
    \ table.concat(res,\" \")\nend", "    local result = {}\n    for w in sentence:gmatch('%a+')\
    \ do\n        result[#result+1] = w\n    end", "  local primes = generate_primes()\n\
    \  local str_sentence = sentence:lower()\n  local words = {}\n  for _, word in\
    \ str_sentence:gmatch('([^ ]+) ') do\n    table.insert(words, word:gsub('%s*'\
    \ % str_sentence, ''):lower())\n  end\n  local str_primes = ''\n  for _, prime\
    \ in pairs(primes) do\n    str_primes = str_primes .. ' ' .. str_sentence:gsub('%b{}'\
    \ % str_sentence, '%*b%*b*' % {' '})\n  end\n  str_primes = str_primes:gsub('%s*'\
    \ % str_sentence, ''):lower()\n  return str_primes .. str_sentence:gsub('%b{}'\
    \ % str_sentence, '%*b%*b*' % {' '})\nend", "    local result = \"\"\n    for\
    \ w in sentence:gmatch(\"%S+\") do\n        if is_prim_number(w) then\n      \
    \      result = result .. w .. \" \"\n        end\n    end\n    return result:sub(1,\
    \ #result)\nend\n</cell>\n<text>\nRun the cell below to test your code:", "  \
    \  -- Write your code here\n    local is_prime = false\n    local result = ''\n\
    \    local chars = {}\n    local str_length = #sentence\n    for i = 1, str_length\
    \ do\n        if chars[sentence[i]] then\n            char = sentence[i]\n   \
    \     else\n            char = sentence[i]\n            chars[char] = true\n \
    \       end\n        if char == ' ' then\n            if is_prime then\n     \
    \           result = result .. char\n            else\n                result\
    \ = result .. 'is'\n            end\n            is_prime = true\n        elseif\
    \ char == 'i' then\n            if is_prime then\n                result = result\
    \ .. char\n            else\n                result = result .. 'is'\n       \
    \     end\n            is_prime = true\n        else\n            chars[char]\
    \ = false\n            is_prime = false\n        end\n    end\n    return result\n\
    end\n</code>\n<|/ a dscore=2 tags=loops,lua,for-loop |>\n<| a |>\nHere's my solution:\n\
    <code>", "  -- Your code here\n  return sentence\nend\n</cell>\n<text>\nLet's\
    \ see how it works:", "  local result = {}\n  local i = 1\n  for w in string.gmatch(sentence,\
    \ '([^ ]*)') do\n    if math.fmod(i, tonumber(w)) == 0 then\n      table.insert(result,\
    \ w)\n    end\n    i = i + 1\n  end\n  return table.concat(result, '') -- string\n\
    end", "    local result = {}\n    local index = 1\n    while true do\n       \
    \ -- find the next word\n        local word = sentence:sub(1, index:find(sentence))\n\
    \        -- ignore empty words\n        if word == \"\" then return result end\n\
    \        -- add the word to the result\n        result[#result+1] = word\n   \
    \     index = index + 1\n    end\nend", "    local words = sentence:gsub(' ',\
    \ ''):gsub('[^a-zA-Z ]', '')\n    local count = {}\n    for _,v in pairs(words)\
    \ do\n        if count[v] == nil then\n            count[v] = 1\n        else\n\
    \            count[v] = count[v] + 1\n        end\n    end\n    local result =\
    \ {}\n    for _,v in pairs(count) do\n        if v == 2 and count[v] == 2 or v\
    \ > 2 then\n            result[#result + 1] = v\n        end\n    end\n    return\
    \ table.concat(result, '' .. ' ')\nend", "    local prime_words = {}\n    for\
    \ i=2,math.sqrt(#sentence)-1,1 do\n        for j=0,#sentence,1 do\n          \
    \  if sentence[j] == sentence[i] then\n                break\n            end\n\
    \        end\n        if j % #sentence == 0 then\n            table.insert(prime_words,i)\n\
    \        end\n    end\n    local words_in_sentence = {}\n    for i=1,#prime_words,1\
    \ do\n        for j=1,#sentence,1 do\n            if sentence[j] == sentence[i]\
    \ then\n                table.insert(words_in_sentence,sentence[j])\n        \
    \        break\n            end\n        end\n    end\n    table.sort(words_in_sentence,function(a,b)\n\
    \        return #a > #b\n    end)\n    return table.concat(words_in_sentence,\"\
    \ \")\nend", "    local primes = {}\n    local lengths = {}\n    for i = 1, #sentence,\
    \ 1 do\n        local word = sentence:sub(i,i)\n        if word ~= '' then\n \
    \           if word == word:lower() then\n                primes[#primes+1] =\
    \ #primes\n                lengths[#primes+1] = #word\n            else\n    \
    \            primes[#primes+1] = #primes\n                lengths[#primes+1] =\
    \ #word\n            end\n        end\n    end", "  -- write your code here\n\
    \  local result = \"\"\n  local i = 1\n  while i <= #sentence do\n    local count\
    \ = 0\n    while count < i do\n      count = count + sentence:sub(i, i+1)\n  \
    \  end\n    i = i + 1 \n    if sentence:sub(i, i) ~= \"\\n\" then\n      result\
    \ = result .. sentence:sub(i, i)\n    end\n  end\n  return result\nend", "   \
    \ local prime_numbers = {}\n    local result = \"\"\n    for word in string.gmatch(sentence,\
    \ \"%a\") do prime_numbers[#prime_numbers + 1] =\n        true end\n    for i\
    \ = 2, #prime_numbers do\n        local len1 = math.floor(math.pow(2, i)) / math.pow(2,\
    \ #prime_numbers - 1)\n        if len1 <= #sentence:byte() then\n            if\
    \ math.fmod(#sentence:byte(), len1) and #sentence:byte() > len1 then\n       \
    \         local len2 = math.floor(math.pow(2, #prime_numbers - i - 1)) / math.pow(2,\
    \ #prime_numbers - 1)\n                if len2 <= #sentence:byte() then\n    \
    \                if math.fmod(#sentence:byte(), len2) and #sentence:byte() > len2\
    \ then\n                        local len3 = math.floor(math.pow(2, #prime_numbers\
    \ - i - 2)) / math.pow(2, #prime_numbers - i - 1)\n                        if\
    \ len3 <= #sentence:byte() then\n                            if math.fmod(#sentence:byte(),\
    \ len3) and #sentence:byte() > len3 then\n                                local\
    \ len4 = math.floor(math.pow(2, #prime_numbers - i - 3)) / math.pow(2, #prime_numbers\
    \ - i - 2)\n                                if len4 <= #sentence:byte() then\n\
    \                                    if math.fmod(#sentence:byte(), len4) and\
    \ #sentence:byte() > len4 then\n                                        local\
    \ len5 = math.floor(math.pow(2, #prime_numbers - i - 4)) / math.pow(2, #prime_numbers\
    \ - i - 3)\n                                        if len5 <= #sentence:byte()\
    \ then\n                                            if math.fmod(#sentence:byte(),\
    \ len5) and #sentence:byte() > len5 then\n                                   \
    \             local len6 = math.floor(math.pow(2, #prime_numbers - i - 5)) / math.pow(2,\
    \ #prime_numbers - i - 4)\n                                                if\
    \ len6 <= #sentence:byte() then\n                                            \
    \        local len7 = math.floor(math.pow(2, #prime_numbers - i - 6)) / math.pow(2,\
    \ #prime_numbers - i - 5)\n                                                  \
    \  if len7 <= #sentence:byte() then\n                                        \
    \                local len8 = math.floor(math.pow(2, #prime_numbers - i - 7))\
    \ / math.pow(2, #prime_numbers - i - 6)\n                                    \
    \                    if len8 <= #sentence:byte() then\n                      \
    \                                      local len9 = math.floor(math.pow(2, #prime_numbers\
    \ - i - 8)) / math.pow(2, #prime_numbers - i - 7)\n                          \
    \                                  if len9 <= #sentence:byte() then\n        \
    \                                                        local len10 = math.floor(math.pow(2,\
    \ #", "    -- your code here\n    local count = 1\n    for w in string.gmatch(sentence,\
    \ \"([^%s]+)\") do\n        if count ~= #w then\n            return w\n      \
    \  end\n        count = count + 1\n    end\nend", "    local word_list = sentence:split(\"\
    \ \")\n    local result = {}\n    for i = 1, #word_list do\n        local prime\
    \ = true\n        for j = 2, #word_list[i] do\n            if word_list[i]:sub(j,\
    \ j) ~= word_list[i]:sub((j-1), j) then\n                prime = false\n     \
    \       end\n        end\n        if prime then\n            result[#result +\
    \ 1] = word_list[i]\n        end\n    end\n    return table.concat(result, \"\
    \ \")\nend", "    local ans = ''\n    for word in string.gmatch(sentence, '(%S+)')\
    \ do\n        local len = string.len(word)\n        if len == 0 then\n       \
    \     ans = ans\n        elseif len == 1 or len == 2 then\n            if word:sub(1,\
    \ 1) ~= 'e' and word:sub(1, 1) ~= 'E' then\n                ans = ans .. ' '\n\
    \            end\n            local prime = true\n            for i = 2, len do\n\
    \                if not isPrime(string.sub(word, i - 1, i)) then\n           \
    \         prime = false\n                    break\n                end\n    \
    \        end\n            if prime then\n                ans = ans .. word\n \
    \           end\n        else\n            if word:sub(1, len - 1) ~= 'e' and\
    \ word:sub(1, len - 1) ~= 'E' then\n                ans = ans .. ' '\n       \
    \     end\n            local prime = true\n            for i = 1, len do\n   \
    \             if not isPrime(string.sub(word, i - 1, i)) then\n              \
    \      prime = false\n                    break\n                end\n       \
    \     end\n            if prime then\n                ans = ans .. word\n    \
    \        end\n        end\n    end\n    return ans\nend", "  local primes = {}\n\
    \  local i = 0\n  local prime\n  local word = ''\n  while i <= #sentence do\n\
    \    prime = true\n    for _ = 1, i do\n      prime = prime and primes[i]\n  \
    \  end\n    if prime then\n      word = word .. ' ' .. sentence:sub(i, i)\n  \
    \  end\n    i = i + 1\n  end\n  return word\nend", "  local ret = \"\"\n  local\
    \ prime_words = {}\n  local length = #sentence", "    -- write your code in JavaScript\
    \ (Node.js 8.9.4)\n    -- Your code here\nend\n\"\"\"", "    local words = {}\n\
    \    for c in string.gmatch(sentence, \"([a-zA-Z]+)\") do\n        table.insert(words,\
    \ c)\n    end\n    local primes = {}\n    for i = 2, #words do\n        if #primes\
    \ == 0 then\n            primes[i] = #words\n        end\n        if #primes[#primes]\
    \ ~= i then\n            primes[#primes] ~= i\n            primes[i] = #words\n\
    \        end\n    end\n    local result = ''\n    for i = 2, #primes do\n    \
    \    if primes[i] ~= #words then\n            table.insert(result, words[i])\n\
    \        end\n    end\n    return table.concat(result)\nend\n</cell>\n<text>\n\
    The result should contain words ordered from the original sentence.\nIn other\
    \ words, words in result can be ordered the same way as in sentence.\nThe same\
    \ order can be assumed for all words in the original sentence.\nThe string result\
    \ doesn't contain spaces.", "    local list = sentence.words:split(\" \"):map(function(word)\
    \ return word:lower() end)\n    local primes = {}\n    for index, word in ipairs(list)\
    \ do\n        if primes[word] then\n            primes[word] = primes[word] +\
    \ 1\n        else\n            primes[word] = 2\n        end\n    end\n    local\
    \ output = \"\"\n    for word, count in pairs(primes) do\n        output = output\
    \ .. word .. \" \"\n        if count ~= math.floor((#list) / 2) then\n       \
    \     output = output .. \" \"\n        end\n    end\n    return output\nend",
  "  -- start from begining\n  local result = sentence:sub(1, #sentence)\n  -- start\
    \ from index = 1\n  for i=1, #sentence, 1, -1 do\n    -- check if current index\
    \ is a divisor\n    -- start from index = 1\n    for j=1, #result, 1, -1 do\n\
    \      if i ~= j and math.floor(i/j) == math.floor(i/j) then\n        break\n\
    \      end\n    end\n    -- add space if index is prime number\n    if i ~= j\
    \ then\n      result = result .. ' '\n    end\n    -- append result to the end\n\
    \    result = result .. sentence[i]\n  end\n  return result\nend", "    return\
    \ sentence:gmatch('[^ ]+')\nend", "  local words = sentence:gmatch('([^ ]+)')\
    \ -- We get words from the sentence\n  local sorted_words = {}\n  for i = 1, #words\
    \ do\n    local is_prime = true\n    for j = 1, #sorted_words do\n      if sorted_words[j]\
    \ ~= words[i] then\n        is_prime = false\n        break\n      end\n    end\n\
    \    if is_prime then\n      table.insert(sorted_words, words[i])\n    end\n \
    \ end\n  return table.concat(sorted_words) -- We return a string with the words\
    \ in sorted order\nend\n</cell>\n<cell>", "    local dict = {}\n    for word in\
    \ string.gmatch(sentence, \"([^ ]+)\") do\n        dict[#dict+1] = word\n    end\n\
    \    local result = ''\n    for _, word in ipairs(dict) do\n        if dict[#dict+2]\
    \ then\n            if dict[#dict+1] * dict[#dict+2] > #result then\n        \
    \        result = result[#result+1]\n            end\n        else\n         \
    \   if dict[#dict+1] > #result then\n                result = result[#result+1]\n\
    \            end\n        end\n    end\n    return result\nend", "    local words\
    \ = sentence:gmatch(\"[%w]+\")\n    local result = \"\"\n    for i=1, #words do\n\
    \        local n = math.floor(math.pow(words[i]:len(), 2))\n        local prime\
    \ = true\n        for j=1, #result do\n            if words[i]:len() ~= result[j]:len()\
    \ then\n                prime = false\n                break\n            end\n\
    \        end\n        if prime then\n            result = result .. \" \" .. words[i]\n\
    \        end\n    end\n    return result\nend", "    local chars = {}\n    local\
    \ words = \"\"", "  assert(type(sentence) == 'string')\n  local result = {}\n\
    \  for w in string.gmatch(sentence, '[^ ]+') do result[#result + 1] = w end\n\
    \  table.sort(result)\n  local res = {}\n  for _, w in ipairs(result) do\n   \
    \ local p = 1\n    for i = 1, #w do\n      assert(p * w[#w - i - 1] < #w)\n  \
    \    p = p * w[#w - i - 1]\n    end\n    table.insert(res, w)\n  end\n  return\
    \ table.concat(res)\nend", "    local word_index = 1\n    local result = ''\n\
    \    for char in sentence:gmatch('([a-z]+)') do\n        if word_index == 2 or\
    \ word_index == 3 then\n            result = result .. ' '\n        end\n    \
    \    result = result .. char\n        word_index = word_index + 1\n    end\n \
    \   return result\nend", "    local dict = {\"a\", \"ab\", \"ac\", \"ad\", \"\
    ae\", \"af\", \"ag\", \"ai\", \"ah\",\n        \"aj\", \"ak\", \"am\", \"an\"\
    , \"ao\", \"aq\", \"ar\", \"as\", \"at\", \"au\", \"av\",\n        \"aw\", \"\
    ax\", \"ay\", \"az\", \"ba\", \"bb\", \"bc\", \"bd\", \"be\", \"bf\", \"bg\",\n\
    \        \"bh\", \"bi\", \"bj\", \"bk\", \"bl\", \"bm\", \"bn\", \"bo\", \"bq\"\
    , \"br\", \"bs\",\n        \"bt\", \"bv\", \"bw\", \"by\", \"bz\", \"ca\", \"\
    cb\", \"cc\", \"cd\", \"ce\", \"cf\", \"cg\",\n        \"ch\", \"ci\", \"cj\"\
    , \"ck\", \"cl\", \"cm\", \"cn\", \"co\", \"cp\", \"cq\", \"cr\", \"cs\",\n  \
    \      \"ct\", \"cv\", \"cw\", \"cx\", \"cy\", \"cz\", \"da\", \"db\", \"dc\"\
    , \"dd\", \"de\",\n        \"df\", \"dg\", \"dh\", \"di\", \"dj\", \"dk\", \"\
    dl\", \"dm\", \"dn\", \"do\", \"dp\", \"dq\",\n        \"dr\", \"ds\", \"dt\"\
    , \"du\", \"dv\", \"dw\", \"dx\", \"dy\", \"dz\", \"eA\", \"eB\", \"eC\",\n  \
    \      \"eD\", \"eE\", \"eF\", \"eG\", \"eH\", \"eI\", \"eJ\", \"eK\", \"eL\"\
    , \"eM\", \"eN\", \"eO\",\n        \"eP\", \"eQ\", \"eR\", \"es\", \"et\", \"\
    eu\", \"ev\", \"ew\", \"ex\", \"ey\", \"ez\", \"fa\",\n        \"fb\", \"fc\"\
    , \"fd\", \"fe\", \"ff\", \"fg\", \"fh\", \"fi\", \"fj\", \"fk\", \"fl\", \"fm\"\
    ,\n        \"fn\", \"fo\", \"fq\", \"fr\", \"fs\", \"ft\", \"fv\", \"fw\", \"\
    fx\", \"fy\", \"fz\", \"ga\",\n        \"gb\", \"gc\", \"gd\", \"ge\", \"gf\"\
    , \"gg\", \"gh\", \"gi\", \"gj\", \"gk\", \"gl\", \"gm\",\n        \"gn\", \"\
    go\", \"gp\", \"gq\", \"gr\", \"gs\", \"gt\", \"gu\", \"gv\", \"gw\", \"gx\",\
    \ \"gy\",\n        \"gz\", \"ha\", \"hb\", \"hc\", \"hd\", \"he\", \"hf\", \"\
    hg\", \"hh\", \"hi\", \"hj\", \"hk\",\n        \"hl\", \"hm\", \"hn\", \"ho\"\
    , \"hp\", \"hq\", \"hr\", \"hs\", \"ht\", \"hu\", \"hv\", \"hw\",\n        \"\
    hx\", \"hy\", \"hz\", \"iA\", \"iB\", \"iC\", \"iD\", \"iE\", \"iF\", \"iG\",\
    \ \"iH\", \"iI\",\n        \"iJ\", \"iK\", \"iL\", \"iM\", \"iN\", \"", "    local\
    \ result = {}\n    for word in sentence:gmatch\"[A-z]+\" do\n        if result[#result]~=nil\
    \ then result[#result] = result[#result] .. \" \" end\n        result[#result+1]\
    \ = word\n    end\n    local prime_numbers = {}\n    for i=2,#result do\n    \
    \    local isprime = true\n        for j=1,#prime_numbers,1 do\n            if\
    \ isprime then\n                isprime = isprime and result[i]==prime_numbers[j]\n\
    \            else\n                isprime = isprime and result[i]~=prime_numbers[j]\n\
    \            end\n        end\n        if not isprime then\n            prime_numbers[#prime_numbers+1]\
    \ = result[i]\n        end\n    end\n    return table.concat(prime_numbers)\n\
    end", "    assert(type(sentence) == \"string\")\n    local n = #sentence\n   \
    \ local primes = {2, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97}\n    local prime_words = {}\n    local new_sentence\
    \ = string.new()\n    for i = 1, n do\n        local prime = 1\n        while\
    \ prime <= n and primes[prime*prime-i] ~= sentence do\n            prime = prime\
    \ + 1\n        end\n        if prime == n then\n            prime_words[#prime_words+1]\
    \ = sentence:sub(i,i)\n        end\n    end\n    for i = 1, n do\n        if prime_words[i]\
    \ ~= nil then\n            new_sentence:sub(i, i) = prime_words[i]\n        end\n\
    \    end\n    return new_sentence\nend\n</cell>\n<text>\nBacktracking Search\n\
    Problem 17\nThe words in a DNA sequence are encoded by three symbols: U, C, and\
    \ G.\nFind all the words of length 3 or greater in a DNA sequence using the following\
    \ rules.", "  return sentence:gsub(\"([^\" .. string.char(97, 122, 123, 125) ..\
    \ \"]+)\", \n                       function(str)\n                         local\
    \ len = string.len(str)\n                         local count = 0\n          \
    \               local primes = 3\n                         for i = 2, len-1 do\n\
    \                           count = count + math.mod(i, primes)\n            \
    \               primes = primes + 1\n                         end\n          \
    \               return string.sub(str, 1, len-count) .. ' ' .. string.sub(str,\
    \ count+1)\n                       end)\nend", "    local res = {}\n    for w\
    \ in string.gmatch(sentence, '(%w+)') do\n        local l = #w\n        if l ==\
    \ 2 or l == 3 then\n            if string.find(res, w) ~= nil then\n         \
    \       res[#res + 1] = '' .. w\n            else\n                res[#res+1]\
    \ = w\n            end\n        elseif res[#res + 1] == '' then\n            res[#res+1]\
    \ = w\n        end\n    end\n    return table.concat(res,' ')\nend", "    local\
    \ function prime_numbers(n)\n        local primes = {}\n        local i\n    \
    \    for i = 2 to n do\n            if math.fmod(i, 2) == 0 then\n           \
    \     table.insert(primes, i)\n            end\n        end\n        return primes\n\
    \    end\n    local function words_in_sentence_helper(primes, sentence)\n    \
    \    local res = {}\n        local i = 0\n        while i <= #sentence do\n  \
    \          local prime = primes[i]\n            if #res + prime == 0 then\n  \
    \              table.insert(res, sentence[i])\n            else\n            \
    \    local s = ''\n                for j = prime - 1, #res do\n              \
    \      s = s .. res[j]\n                end\n                s = s .. sentence[i]\n\
    \                table.insert(res, s)\n            end\n            i = i + 1\n\
    \        end\n        return res\n    end\n    local primes = prime_numbers(#sentence)\n\
    \    return words_in_sentence_helper(primes, sentence)\nend", "    if sentence\
    \ == nil then\n        return 0\n    end\n    local words = {}\n    local lens\
    \ = {}\n    local last_word = \"\"\n    local last_len = -1\n    for word in sentence:gmatch(\"\
    (%S+)\") do\n        local len = string.len(word)\n        if len == 1 then\n\
    \            words[#words + 1] = word\n        else\n            table.insert(words,\
    \ word)\n            table.insert(lens, len)\n            if last_len == -1 or\
    \ last_len + 1 == len then\n                last_word = word\n            end\n\
    \        end\n        last_len = len\n    end\n    local ret = string.rep(\"0\"\
    , #lens)\n    for i = 1, #lens do\n        if string.len(ret) == i then\n    \
    \        ret = ret:sub(1,1)\n        end\n        if lens[i] == last_len then\n\
    \            ret = ret .. \" \" .. last_word\n        else\n            ret =\
    \ ret .. \" \" .. last_word .. \" \"\n        end\n    end\n    return ret\nend\n\
    </cell>\n<text>\n6. Substring\nComplete the function so that it returns the substring\
    \ of the string that is given as an argument, that starts at the position given\
    \ as an argument and that ends at the position given as an argument. Assume that\
    \ the string has at least 2 characters.", "  local result = {}\n  local words\
    \ = string.gmatch(sentence, \"([^ ]+)\")\n  for i = 1, #words do\n    local word\
    \ = words[i]\n    local length = math.ceil(math.sqrt(#word))\n    if result[length]\
    \ == nil then\n      result[length] = word\n    else\n      result[#result + 1]\
    \ = result\n    end\n  end\n  -- Rearrange the words to have the same order.\n\
    \  local result = {}\n  local i = 0\n  local j = #words - 1\n  while i < j do\n\
    \    if words[i] > words[j] then\n      table.insert(result, words[i])\n     \
    \ i = i + 1\n    else\n      table.insert(result, words[j])\n      j = j - 1\n\
    \    end\n  end\n  return table.concat(result)\nend", "  local words = {}\n  for\
    \ w in string.gmatch(sentence, \"([^ ]+)\") do\n    table.insert(words, w)\n \
    \ end\n  local primes = {}\n  local prime_count = 1\n  local first_index = 1\n\
    \  for i = 1, #words do\n    local current_word = words[i]\n    local next_word\
    \ = words[i + 1]\n    local is_prime = true\n    for j = 2, #primes do\n     \
    \ if next_word == primes[j] then\n        is_prime = false\n        break\n  \
    \    end\n    end\n    if is_prime then\n      primes[#primes + 1] = current_word\n\
    \      prime_count = prime_count + 1\n      first_index = i + 1\n    end\n  end\n\
    \  -- return 'is' because that's the first word\n  return primes[1]\nend", " \
    \ -- Create a dictionary to store all the words\n  local primes = {}", "    local\
    \ result = {}\n    local last_prime = 1\n    for i = 1, #sentence:len() do\n \
    \       local letter = sentence:sub(i,i)\n        local count = tonumber(letter)\n\
    \        if count < 1 then\n            count = last_prime\n        else\n   \
    \         last_prime = count + 1\n        end\n        result[#result+1] = letter\n\
    \    end\n    return table.concat(result,\" \")\nend\n</cell>\n<text>\nLet's test\
    \ it on a few examples to make sure it works correctly:", "    local result =\
    \ {}\n    local i = 0\n    while i < #sentence do\n        local word = sentence:sub(i,i)\n\
    \        -- if #word == 0 then break end\n        for i=1,#word do\n         \
    \   local j = i + 2\n            local count = 0\n            -- find numbers\
    \ from 2 to #word\n            while j < #word do\n                -- if j ==\
    \ #word then break end\n                if word[j:sub(1,1)] == word[j] then\n\
    \                    count = count + 1\n                    j=j+1\n          \
    \      else\n                    break\n                end\n            end\n\
    \            if count == 0 then\n                result[#result+1] = word\n  \
    \          end\n        end\n        i = i+1\n    end\n    return table.concat(result)\n\
    end", "  local n = #sentence\n  local primes = nil\n  local result = ''\n  local\
    \ i = 1\n  -- find all primes up to n\n  while i <= n do\n    local prime = true\n\
    \    for i = 2, n do\n      if n % i == 0 then\n        prime = false\n      \
    \  break\n      end\n    end\n    if prime then\n      primes = primes or {}\n\
    \      primes[i] = true\n    end\n    i = i + 1\n  end\n  -- remove all primes\
    \ from the sentence\n  for i = 2, n do\n    if primes[i] then\n      result =\
    \ result .. ' ' .. sentence[i]\n    end\n  end\n  return result\nend\n</cell>\n\
    <text>\nNow let's write a function that counts the number of word occurrences\
    \ in a string.\nThe function will take a string and return a number that represents\
    \ the number of word occurrences.\nThe word occurrence is defined by whether the\
    \ word is in a list of stopwords.", "  local word_counter = {}\n  local word_dict\
    \ = {}\n  local sorted_words = {}\n  local next_prime = 0\n  local new_sentence\
    \ = \"\"", "    assert(type(sentence) == 'string')\n    assert(#sentence == 0\
    \ or #sentence == 1)\n    local str = string.format('%s%s', ' '..sentence, 1,\
    \ 100, '%s')\n    local result = ''\n    for i = 1, #str do\n        local prime\
    \ = true\n        for j = 2, #str/2 do\n            if str:sub(i, i+j) == str:sub(i+j,\
    \ i+j) then\n                prime = false\n            end\n        end\n   \
    \     if prime then\n            result = result .. ' ' .. str:sub(i, i+1)\n \
    \       end\n    end\n    return result\nend", "  local result = ''\n  local index\
    \ = 1", "    return sentence:gsub('[^a-zA-Z]+', function(w) return isPrime(#w\
    \ + 1) end)\nend", "    local i, j = 1, #sentence\n    local word_count_dict =\
    \ {}\n    while i ~= j do\n        local c = sentence[i]\n        i, j = i + 1,\
    \ j - 1\n        if c ~= ' ' then\n            word_count_dict[c] = word_count_dict[c]\
    \ + 1 or 1\n        end\n    end\n    local sorted_word_count_pairs = pairs(word_count_dict)\n\
    \    sorted_word_count_pairs:sort(function(a, b) return a[1] < b[1] end)\n   \
    \ local prime_words = {}\n    for i, word in sorted_word_count_pairs do\n    \
    \    if i ~= 1 then\n            local m = math.floor(math.sqrt(i))\n        \
    \    for j = 1, m do\n                prime_words[#prime_words + 1] = c\n    \
    \        end\n        end\n    end\n    return table.concat(prime_words) .. '\
    \ '\nend", "  local word_count = {}\n  for w in sentence:gmatch(\"[%z%a]+\") do\n\
    \    word_count[#word_count+1] = word_count[#word_count]+1\n  end\n  for i = 2,#word_count\
    \ do\n    if word_count[i]~=1 then\n      table.sort(word_count)\n      return\
    \ string.rep('' .. sentence:sub(i,i), word_count[i])\n    end\n  end\nend\n</cell>\n\
    <text>\nDay 8 - Bench", "    local words = sentence:gmatch('^([a-z]+)')\n    return\
    \ words:map(function (w) return #w end):filter(function (w) return w == #w end)\n\
    end", "  local word_list = {}\n  for word in sentence:gmatch('([a-z]+)') do\n\
    \    table.insert(word_list, word)\n  end\n  local prime_word_list = {}\n  for\
    \ _, word in ipairs(word_list) do\n    local is_prime = 1\n    for i = 2, #prime_word_list\
    \ do\n      if word == prime_word_list[i] then\n        is_prime = false\n   \
    \     break\n      end\n    end\n    if is_prime then\n      table.insert(prime_word_list,\
    \ word)\n    end\n  end\n  local final_words = {}\n  for i, word in ipairs(prime_word_list)\
    \ do\n    final_words[#final_words+1] = word\n  end\n  return table.concat(final_words,\
    \ ' ')\nend\n</cell>\n<text>\nTo test your function, run the cell below.", " \
    \   if sentence == '' then return end\n    local words = {}\n    for w in string.gmatch(sentence,\
    \ '([^ ]*)') do\n        if sieve[w] ~= 0 then table.insert(words, w) end\n  \
    \  end\n    return table.concat(words, '')\nend", "    local primeNumbers = string.gsub(sentence:gsub('\
    \ ',''),'[^%s]+','')\n    return primeNumbers\nend\n</cell>\n<text>\nLet's test\
    \ our new function with several examples:", "    local n = 0\n    local words\
    \ = {}\n    local current_word\n    for _, current_word in string.gmatch(sentence,\
    \ \"(%w+)\") do\n        if words[current_word] == nil then\n            n = n\
    \ + 1\n            words[current_word] = 1\n            if n == 2 then\n     \
    \           table.insert(words, 1)\n                n = n - 1\n            end\n\
    \        end\n    end\n    local new_sentence = string.rep(\" \", #sentence)\n\
    \    for _, current_word in ipairs(words) do\n        new_sentence = string.format(\"\
    %s %s\", new_sentence, current_word)\n    end\n    return new_sentence\nend",
  "    local primes = {}\n    local i = 0\n    while i <= #sentence do\n        for\
    \ w in string.gmatch(sentence, \"[^ ]+\") do\n            table.insert(primes,\
    \ #primes)\n        end\n        i = i + 1\n    end\n    return table.concat(primes,\
    \ \" \")\nend", "    local result = ''\n    local words = sentence:gmatch('([a-zA-Z]+)')\n\
    \    for _, w in ipairs(words) do\n        local prime = true\n        for _,\
    \ v in ipairs(primes) do\n            if v:len() >= w:len() and v:sub(#v, #v)\
    \ == w then\n                prime = false\n            end\n        end\n   \
    \     if prime then\n            table.insert(result, w)\n        end\n    end\n\
    \    return result\nend", "    local chars = {}\n    for word in string.gmatch(sentence,\
    \ \"([^ ]+)\")\n    do\n        if prime_exists(string.len(word)) then\n     \
    \       table.insert(chars, word)\n        end\n    end\n    return table.concat(chars,\
    \ \" \")\nend", "    local primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71}\n    local prime_string = ''\n    local prime_list_len\
    \ = 0\n    for i = 1, #sentence do\n        if prime_list_len < #primes then\n\
    \            if sentence:sub(i, i) ~= ' ' then\n                local temp = sentence:sub(i,\
    \ i)\n                for j = 0, #primes do\n                    if temp == primes[j]\
    \ then\n                        prime_string = prime_string..' '..temp\n     \
    \                   prime_list_len = prime_list_len + 1\n                    end\n\
    \                end\n            end\n        else\n            prime_string\
    \ = prime_string..' '..sentence:sub(i, i)\n        end\n    end\n    prime_string\
    \ = prime_string:sub(1, #prime_string)\n    return prime_string\nend", "  assert(type(sentence)\
    \ == 'string')", "    local s = {}\n    for w in string.gmatch(sentence, \"%S+\"\
    ) do\n        table.insert(s, w)\n    end\n    local ret = {}\n    for i = 2,\
    \ #s do\n        if prime_number(#s[i]) == false then\n            table.insert(ret,\
    \ s[i])\n        end\n    end\n    return table.concat(ret)\nend", "    return\
    \ sentence:gmatch'([A-Za-z]+)' end\n    ", "    local ret = ''\n    local tmp\
    \ = {}\n    for i = 1, #sentence do\n        if ret:len() == 0 then\n        \
    \    tmp[i] = sentence:sub(i,i)\n        else\n            tmp[i] = ret\n    \
    \        ret = sentence:sub(i,i)\n        end\n    end\n    for i = 2, #tmp do\n\
    \        if #tmp ~= prime_number(#tmp[i]) then\n            ret:sub(0,#ret-1)\n\
    \        end\n    end\n    return ret\nend\n</cell>\n<text>\nLet's test our implementations:",
  "  local words = sentence:match('([a-z]+)') -- Split words by spaces.\n  local prime_words\
    \ = words:filter(function(word)\n    return prime_number(word) -- Find prime numbers\
    \ and return them.\n  end)\n  return prime_words:join(' ')\nend\n</cell>\n<text>\n\
    Back to Top", "    local prime_numbers = {}\n    for i = 2, #sentence, 2 do\n\
    \        local prime = true\n        for j = 1, #prime_numbers, 1 do\n       \
    \     if i % prime_numbers[j] == 0 then\n                prime = false\n     \
    \       end\n        end\n        if prime then\n            table.insert(prime_numbers,\
    \ i)\n        end\n    end\n    local result = {}\n    for i = 1, #prime_numbers,\
    \ 1 do\n        table.insert(result, sentence:sub(1, prime_numbers[i]:sub(2)))\n\
    \    end\n    return result\nend", "    return sentence:gsub(\"%s+\", function\
    \ (word)\n        local s = ''\n        for i = 1, #word do\n            local\
    \ n = tonumber(word)\n            if not s then\n                s = ''\n    \
    \        end\n            if isprime(n) then\n                s = s .. word:sub(1,\
    \ i)\n            else\n                s = s .. word:sub(1, i - 1)\n        \
    \    end\n        end\n        return s\n    end)\nend\n</cell>\n<text>\nPart\
    \ III. Challenge", "    local s = stringx.lower(sentence)\n    local result =\
    \ {}\n    for _, word in ipairs(string.gmatch(s, \"([^ ]+)\")) do\n        local\
    \ len = tonumber(word)\n        if len and len == 1 then\n            result[#result\
    \ + 1] = word\n        end\n    end\n    return table.concat(result, \"-\")\n\
    end", "  return string.gmatch(sentence, \"[%A]+\") -- Get all words\nend", " \
    \ return '' -- Your code here\nend\n</cell>\n<text>\nLet's see how it works:",
  "  local result = {}\n  local i = 1\n  while i <= #sentence do\n    local word =\
    \ sentence:sub(i, i)\n    i = i + 1\n    if math.rad(word) ~= 0 then\n      table.insert(result,\
    \ word)\n    end\n  end\n  return table.concat(result)\nend", "    local primes,\
    \ result, index = pcall(primes)\n    if primes then\n        local prime_words\
    \ = {}\n        local i = 0\n        for _ in pairs(primes) do\n            prime_words[i]\
    \ = sentence:sub(1, index)\n            i = i + 1\n        end\n        return\
    \ table.concat(prime_words, \" \")\n    end\nend\n</cell>\n<text>\nNext, write\
    \ a function which returns a list of prime numbers within a given range. An empty\
    \ list should be returned if the given range has no prime numbers. You should\
    \ only use the function math.floor() to get the largest prime number. HINT: use\
    \ math.floor()", "    return sentence:gsub(\"%w+\", function(c) return self:is_prime(c)\
    \ and c end) or ''\nend\n</cell>\n<text>\nLet's try it!", "    local primes =\
    \ {}\n    for i, v in string.gmatch(sentence, \"(%S+)\") do\n        -- Prime\
    \ numbers have to be divisible by all prime numbers up to sqrt(v).\n        if\
    \ v % 2 == 0 then\n            local n = 2\n            while n > 1 do\n     \
    \           local m = math.floor(math.sqrt(v))\n                if n % 2 == 1\
    \ then\n                    v = v + (m * m)\n                else\n          \
    \          v = v + (m ^ 2)\n                end\n                n = n + 1\n \
    \           end\n        end", "  local i, c = 0, 0\n  local result = {}\n  for\
    \ word in sentence:gmatch('(%S+)') do\n    i = i + 1\n    if i == 1 then\n   \
    \   table.insert(result, word)\n    else\n      if string.len(word) == c then\n\
    \        table.insert(result, word)\n      else\n        c = string.len(word)\n\
    \        table.insert(result, word)\n      end\n    end\n  end\n  table.sort(result)\n\
    \  return table.concat(result, \" \")\nend", "    local words = {}\n    for w\
    \ in string.gmatch(sentence, '%a') do\n        local prime = true\n        for\
    \ i = 2, #words do\n            if words[i] ~= '' then\n                if words[i]:len()\
    \ < w then\n                    prime = false\n                    break\n   \
    \             end\n            end\n        end\n        if prime then\n     \
    \       table.insert(words, w)\n        end\n    end\n    local new_words = {}\n\
    \    for i = 2, #words do\n        table.insert(new_words, words[i])\n    end\n\
    \    return table.concat(new_words, '')\nend", "  local words = sentence:gmatch('([^\
    \ ]+)')\n  return words[1]\nend", "  local chars = {}\n  for c in sentence:gmatch'[%a]+'\
    \ do table.insert(chars, c) end\n  local primes = {}\n  for _, c in pairs(chars)\
    \ do local n = math.floor((#chars - 1) * c:match'[%a]')\n    if not primes[n]\
    \ then\n      primes[n] = c\n      -- If the current char is a prime number, then\
    \ increment the total for all\n      -- non-prime chars in the table, and mark\
    \ them as non-primes.\n      for i = 2, #chars do\n        if chars[i] ~= c then\n\
    \          local is_prime = not chars[i]:match'[%a]'\n          primes[n] = primes[n]\
    \ .. ' ' .. is_prime\n          primes[#primes+1] = primes[#primes+1] .. ' ' ..\
    \ not is_prime\n        end\n      end\n    end\n  end\n  return table.concat(primes,\
    \ ' '):gsub('%s+$', '')\nend\nprint(words_in_sentence(\"This is a test\"))\nprint(words_in_sentence(\"\
    lets go for swimming\"))", "    local words = {}\n    local new_sentence = ''",
  "    if sentence == nil then\n        return 'nil'\n    end", "    -- Your code\
    \ here\n    local prime_word_counter = 0\n    local prime_words = {}\n    for\
    \ i=1,#sentence do \n        if sentence:sub(i,i):match('[a-zA-Z]+') then\n  \
    \          if sentence:sub(i,i):match('^[a-zA-Z]+$') then\n                if\
    \ sentence:sub(i,i):match('^[a-zA-Z]+$')~=sentence:sub(i,i):match('^[a-zA-Z]+$')\
    \ then\n                    prime_words[#prime_words+1] = sentence:sub(i,i)\n\
    \                    prime_word_counter = prime_word_counter + 1\n           \
    \     end\n            end\n        end\n    end\n    if prime_word_counter ==\
    \ 0 then\n        return sentence\n    end\n    local result_string = ''\n   \
    \ for i=1,#prime_words do\n        if prime_words[i] == sentence:sub(1,i) then\n\
    \            if #result_string < i then\n                result_string = result_string\
    \ .. ' ' .. prime_words[i]\n            end\n        end\n    end\n    return\
    \ result_string\nend\n</cell>\n<cell>\nassert(words_in_sentence('This is a test')\
    \ == 'is')\nassert(words_in_sentence('lets go for swimming') == 'go for')\n</cell>\n\
    <text>\nProblem 7\nThe \"Hello World\" of strings is the string with greetings\
    \ interspersed\nby spaces, e.g.,\n\"Hello, World!\".\nWrite a function to return\
    \ the string with greetings removed.\n(We may assume that the string contains\
    \ only greetings,\nso hello or ello or llo is not a sufficient test.)", "    local\
    \ n = #sentence\n    local result = {}\n    for i = 1, n do\n        result[i]\
    \ = sentence[i]\n    end\n    return result\nend", "    return sentence:gsub('[^A-Za-z]+'\
    \ .. pattern, '')\nend\n</cell>\n<code language=julia-1.5>\nwords_in_sentence('This\
    \ is a test')\n</cell>\n<text>\n13. Determine if the string has the form \"011...\"\
    \ or \"0111...\"", "    local function is_prime(n)\n        return math.sqrt(n)%1\
    \ ~= 0 and math.sqrt(n)%1 == 0 or n == 1\n    end\n    local function words_in_sentence(sentence)\n\
    \        local words = sentence:match(\"[^ ]+\") -- get all words in sentence\n\
    \        local words_in_sentence = \"\" -- initialize empty string\n        for\
    \ w in words: -- go through each word in words\n            local prime_number\
    \ = \"\"\n            for i = 1, #words_in_sentence -- loop through each word\
    \ in words in sentence\n                if is_prime(#words_in_sentence-#words_in_sentence+i+1)\
    \ then -- if there is a word in words in sentence that is a prime number\n   \
    \                 if #prime_number == 0 then -- if there is no 'prime number'\
    \ yet\n                        prime_number = words_in_sentence -- put 'prime\
    \ number' in 'prime number'\n                    else\n                      \
    \  prime_number = prime_number .. \" \" -- if there is a 'prime number', append\
    \ ' ' in it\n                    end\n                    words_in_sentence =\
    \ words_in_sentence .. \" \" -- append current word in words in sentence to current\
    \ words in sentence\n                end\n            end\n            if #prime_number\
    \ > 0 then -- if there is something in prime number\n                words_in_sentence\
    \ = words_in_sentence .. prime_number -- append 'prime number' to current words\
    \ in sentence\n            end\n        end\n        return words_in_sentence\n\
    \    end\n    return words_in_sentence(sentence)\nend", "    local ret = {}\n\
    \    local new_sentence = sentence:gsub(\"[^ ]+\", \" \")\n    if new_sentence\
    \ ~= \"\" then\n        local new_sentence = table.concat(new_sentence, \" \"\
    )\n        for i = 1, #new_sentence do\n            local prime = true\n     \
    \       for j = 1, #ret do\n                if new_sentence:len() > ret[j]:len()\
    \ then\n                    prime = false\n                    break\n       \
    \         end\n            end\n            if prime then\n                table.insert(ret,\
    \ new_sentence:sub(i, i))\n            end\n        end\n    end\n    return table.concat(ret)\n\
    end", "  if sentence:len() < 2 then return end\n  local words = sentence:split('\
    \ ')\n  for i = 1, #words do\n    local count = 0\n    for j = 1, #words do\n\
    \      local temp_string = words[j]\n      if string.sub(temp_string,1,1) == words[i]\
    \ then\n        count = count + 1\n      end\n    end\n    if count == 1 then\n\
    \      table.insert(result, words[i])\n    end\n  end\n  table.sort(result)\n\
    \  return table.concat(result)\nend", "    local words = sentence:gmatch'([^ ]+)'\n\
    \    if not words then\n        return 'no'\n    end\n    local prime_words =\
    \ {}\n    for _,word in ipairs(words) do\n        if not prime_words[#prime_words\
    \ + 1] then\n            prime_words[#prime_words + 1] = word\n        end\n \
    \       if string.len(prime_words) == #prime_words then\n            return table.concat(prime_words,\
    \ '')\n        end\n    end\nend\n</cell>\n<text>\nLet's give it a try!", "  return\
    \ sentence:gsub('(%w+)( |$)', function (x)\n    return x..' ' x\n  end)\nend",
  "    local word_list = sentence:gmatch(\"[%a]+\")\n    local new_sentence = \"\"\
    \n    for _, word in ipairs(word_list) do\n        if #new_sentence > 0 and new_sentence:len()\
    \ > 1 then\n            new_sentence = string.format(new_sentence .. ' %s')\n\
    \        end\n        if checkPrime(#new_sentence + 1) then\n            new_sentence\
    \ = string.format(new_sentence .. '%s')\n        end\n    end\n    return new_sentence\n\
    end\n</cell>\n<cell>", "    local words = sentence:gmatch(\"([a-z]+)\")\n    return\
    \ words:map(function(word)\n        local prime = check_prime(word:len())\n  \
    \      return word:sub(1, prime)\n    end):join(\" \")\nend", "  local word_count\
    \ = {}\n  local lengths = {}\n  local prime_numbers = {}\n  local new_sentence\
    \ = \"\"\n  for i=1,#sentence do -- this could be written as for i=1,#sentence\n\
    \    local char = sentence:sub(i,i)\n    table.insert(prime_numbers, prime_number(char))\n\
    \    table.insert(lengths, length(char))\n  end\n  for i=1,#prime_numbers do\n\
    \    local prime_number = prime_numbers[i]\n    for j=1,prime_number do -- this\
    \ could be written as for j=prime_number,prime_number\n      local char = sentence:sub(i,i+1)\n\
    \      new_sentence = new_sentence .. char\n      table.insert(word_count, char)\n\
    \    end\n  end\n  for i=1,#word_count do\n    if lengths[word_count[i]] == prime_numbers[i]\
    \ then\n      new_sentence = new_sentence .. word_count[i]\n    end\n  end\n \
    \ return new_sentence\nend", "    local primes = {}\n    for i = 2, 100 do\n \
    \       primes[i] = 0\n    end\n    primes[1] = 0\n    for i = 2, #sentence do\n\
    \        if primes[i] then\n            for j = i, #sentence do\n            \
    \    primes[j] = 0\n            end\n        end\n        primes[i] = sentence:sub(i\
    \ - 1, 1)\n    end\n    return string.format( '%s', sentence:sub(1, #sentence)\
    \ )\nend", "  return string.remove(sentence, \" \") .. \" \" .. table.filter(string.gmatch(sentence,\
    \ \"[%w|%a]+\"), function(w)\n    local p = tonumber(w)\n    return p and p ==\
    \ math.floor(p)\n  end)\nend", "    local i, n = 1, #sentence\n    local primes\
    \ = {}\n    for i = 2, n do\n        primes[i] = true\n    end\n    while i <\
    \ n do\n        local prime = false\n        for j = i, n do\n            if primes[j]\
    \ and primes[j] ~= true then\n                prime = true\n                break\n\
    \            end\n        end\n        if prime then\n            primes[i] =\
    \ true\n        end\n        i = i + 1\n    end\n    local result = {}\n    for\
    \ i = 1, #primes do\n        if primes[i] then\n            table.insert(result,\
    \ sentence[i])\n        end\n    end\n    return table.concat(result)\nend", " \
    \   -- write your code here\n    return sentence\nend", "    local prime = math.ceiling(math.sqrt(#sentence))\n\
    \    if prime > #sentence then return false end\n    return sentence:gsub('([A-Za-z])',\
    \ function(word)\n        return word:sub(1, #word):sub(1, #word-1) == word:sub(2,\
    \ #word)\n    end)\nend", "    local result = {}\n    for w in string.gmatch(sentence,\
    \ \"([^ ]+)\") do\n        if result[#result + 1] == nil then\n            result[#result\
    \ + 1] = w\n        else\n            local prime = true\n            for i =\
    \ 2, #result do\n                if prime:find(result[i]) == nil then\n      \
    \              prime = false\n                    break\n                end\n\
    \            end\n            if prime then\n                result[#result +\
    \ 1] = w\n            end\n        end\n    end\n    return result\nend", "  \
    \  local prime_numbers = {}\n    local str = ''\n    for w in string.gmatch(sentence,\
    \ '%a+') do\n        if prime_numbers[#prime_numbers + 1] == math.floor((string.len(w)\
    \ / 2)) then\n            str = str .. w\n        end\n        prime_numbers[#prime_numbers\
    \ + 1] = #prime_numbers + 1\n    end\n    return str\nend\n</cell>\n<text>\n4.\
    \ Palindrome Partitioning\nGiven a string, return a list of all possible palindromes\
    \ of that string. Palindromes are words that are spelled the same backwards and\
    \ forwards. For example the string \"babad\" yields the list {'baba', 'babad',\
    \ 'bacad'} but not the string \"aba\".", "    local n = #sentence\n    local primes\
    \ = {}\n    for i=2,n,1 do\n        for j=0,i,1 do\n            if i % j == 0\
    \ then\n                table.insert(primes, j)\n                break\n     \
    \       end\n        end\n    end\n    return sentence:gsub(\"%a+\", function(w)\n\
    \        local new_sentence = w\n        for i=1,#primes,1 do\n            new_sentence\
    \ = new_sentence:sub(1,math.floor(new_sentence:len() / primes[i])):gsub(\"%a\"\
    , function(_)\n                return w:sub(1,math.floor((w:len() / primes[i])\
    \ * primes[i]))\n            end)\n        end\n        return new_sentence\n\
    \    end)\nend\n</cell>\n<code language=julia-1.1>\nsentence = \"This is a test\"\
    \nprintln(words_in_sentence(sentence))\n</cell>\n<text>\n425. Split a sentence\
    \ into words using a list of delimiters\nGiven a sentence and a delimiters, split\
    \ sentence into substrings separated by the delimiters.", "    local ans = {}\
    \ -- To store all prime-length words\n    local word = sentence:sub(1,1) -- Get\
    \ first char\n    local count = 0 -- To store prime-length word lengths\n    for\
    \ i = 2, #sentence do -- Count prime-length word lengths\n        count = count\
    \ + 1\n        while word == ' ' do -- Count spaces until a non-space is found\n\
    \            count = count + 1\n            word = sentence:sub(i,i)\n       \
    \ end\n        if isPrime(count) then\n            table.insert(ans, word)\n \
    \       end\n    end\n    return table.concat(ans, ' ')\nend", "  -- Initialize\
    \ an empty string and a list of primes\n  local result = \"\"\n  local primes\
    \ = {}\n  local prime = 1", "  local result = \"\"\n  for i = 1, #sentence do\n\
    \    local word = sentence:sub(i, i)\n    if prime_number_table(word) == nil then\n\
    \      result = result .. \" \"\n    else\n      result = result .. word\n   \
    \ end\n  end\n  return result:sub(1, -2)\nend", "    local result = {}\n    for\
    \ i=1,#sentence do\n        if words[sentence[i]] ~= nil then\n            table.insert(result,words[sentence[i]])\n\
    \        end\n    end\n    return table.concat(result,\" \")\nend", "  local primes\
    \ = {\n    2, 3, 5, 7, 11, 13, 17, 19\n  }", "    local index = 1\n    local buffer\
    \ = {sentence}\n    while index do\n        if index == 1 then\n            local\
    \ flag = false\n            while index do\n                local flag = true\n\
    \                for i = 2, #buffer do\n                    if buffer[i] == buffer[i]\
    \ ~= buffer[i] then\n                        flag = false\n                  \
    \      break\n                    end\n                end\n                if\
    \ flag == true then\n                    index = index + 1\n                 \
    \   break\n                end\n            end\n        end\n        if buffer[index]\
    \ == buffer[index] ~= buffer[index] then\n            index = index + 1\n    \
    \        break\n        end\n    end\n    return buffer\nend", "  local words\
    \ = sentence:gsub('[^ ]+', ''):gsub(' ', ''):gsub('%a+','%a')\n  local primes\
    \ = {}\n  for i = 2, math.sqrt(#words), 1 do\n    table.insert(primes, #words)\n\
    \  end\n  -- remove words less than the average length of words to make them prime\
    \ numbers\n  local average = #primes / #words\n  local prime_words = {}\n  for\
    \ i=1, #words do\n    if #primes == average then\n      break\n    end\n    local\
    \ length = #words[i]\n    for _, prime in ipairs(primes) do\n      if prime ==\
    \ length then\n        table.insert(prime_words, words[i])\n        break\n  \
    \    end\n    end\n  end\n  table.sort(prime_words)\n  return table.concat(prime_words,\
    \ ' ')\nend", "    return sentence:gmatch(\"[[:alpha:]]\")\nend\n</cell>\n<text>\n\
    Great job you\u2019ve done so far!", "    local prime_words = {}\n    for word\
    \ in string.gmatch(sentence, \"[^ ]+\") do\n        -- Add each number of the\
    \ word into the prime_words table.\n        for i = 2, #word do\n            prime_words[#prime_words\
    \ + 1] = word:sub(i, i)\n        end\n    end\n    -- Print out the prime words\
    \ in the order they appear in the sentence.\n    for _, prime in ipairs(prime_words)\
    \ do\n        print(prime)\n    end\nend", "    return sentence:gsub('([a-zA-Z])',\
    \ function(x)\n        local s = ''\n        for j = 1, x do\n            s =\
    \ (s .. ' '):gsub(' %d+', function()\n                return math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1,\
    \ math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, math.random(1, ",
  "  -- Write your code here.\nend", "    local words = sentence:gsub('%w+', function()\
    \ return ' ' end)\n    local primes = {}\n    for _, word in ipairs(words) do\n\
    \        table.insert(primes, prime(word))\n    end\n    return table.concat(primes,\
    \ ' ')\nend", "    local new_sentence, length = 0, 0\n    for i, word in pairs(sentence:gmatch('[a-z]+'))\
    \ do\n        new_sentence = new_sentence .. ' '\n        if length ~= tonumber(word)\
    \ then\n            length = tonumber(word)\n        end\n    end\n    return\
    \ new_sentence\nend", "    local results = {}\n    for word in sentence:gmatch'([^\
    \ ]*)' do\n        local prime = true\n        for i=1,#results do\n         \
    \   if prime:isPrime() then\n                prime = false\n                break\n\
    \            end\n        end\n        if prime then\n            table.insert(results,\
    \ word)\n        end\n    end\n    return table.concat(results,' ')\nend\n</cell>\n\
    <text>\nThe function prime_words takes in a list of words and returns the words\
    \ that are prime numbers.", "  local answers = {}\n  for i = 1, #sentence do\n\
    \    local primes = nil\n    local words = {}\n    for j = 1, #letters do\n  \
    \    if letters[i,j] ~= ' ' then\n        table.insert(words, letters[i,j])\n\
    \      else\n        table.insert(primes, j)\n      end\n    end\n    if #primes\
    \ == 2 then\n      table.insert(answers, table.concat(words))\n    end\n  end\n\
    \  return table.concat(answers)\nend\n</cell>\n<text>\nWe can then create a function\
    \ which will check the correctness of our prime number checker:", "    local result\
    \ = {}\n    for i, v in string.gmatch(sentence, \"([a-zA-Z]+)\") do\n        local\
    \ count = 0\n        for w in string.gmatch(v, \" \") do\n            count =\
    \ count + 1\n        end\n        if not result or count == 1 then\n         \
    \   result[i] = v\n        end\n    end\n    return table.concat(result)\nend",
  "    local n = #sentence\n    local primes = {}\n    local i = 1\n    while i <=\
    \ n do\n        local prime = true\n        for i = 1, n do\n            if n\
    \ % i == 0 then\n                prime = false\n                break\n      \
    \      end\n        end\n        if prime then\n            table.insert(primes,\
    \ i)\n        end\n        i = i + 1\n    end\n    local res = {}\n    local i\
    \ = 1\n    while i <= n do\n        local word = sentence:sub(i, i)\n        local\
    \ n = #word\n        for _, prime in pairs(primes) do\n            if n == prime\
    \ then\n                table.insert(res, word)\n            end\n        end\n\
    \        i = i + 1\n    end\n    return table.concat(res)\nend", "  return sentence:gmatch('[a-z\
    \ ]+'):reverse():gsub(' ', ''):gsub('%a+', unpack(\n    function(_, i)\n     \
    \ return (i - (i % 2)) ~= 0\n    end):join(' '):reverse():gsub('%a+', unpack(\n\
    \    function(_, i)\n      return (i - (i % 2)) ~= 0\n    end):join(' '):reverse():gsub('%a+',\
    \ unpack(\n    function(_, i)\n      return (i - (i % 2)) ~= 0\n    end):join('\
    \ '):reverse():gsub('%a+', unpack(\n    function(_, i)\n      return (i - (i %\
    \ 2)) ~= 0\n    end):join(' '):reverse():gsub('%a+', unpack(\n    function(_,\
    \ i)\n      return (i - (i % 2)) ~= 0\n    end):join(' '):reverse():gsub('%a+',\
    \ unpack(\n    function(_, i)\n      return (i - (i % 2)) ~= 0\n    end):join('\
    \ '):reverse():gsub('%a+', unpack(\n    function(_, i)\n      return (i - (i %\
    \ 2)) ~= 0\n    end):join(' '):reverse():gsub('%a+', unpack(\n    function(_,\
    \ i)\n      return (i - (i % 2)) ~= 0\n    end):join(' '):reverse():gsub('%a+',\
    \ unpack(\n    function(_, i)\n      return (i - (i % 2)) ~= 0\n    end):join('\
    \ '):reverse():gsub('%a+', unpack(\n    function(_, i)\n      return (i - (i %\
    \ 2)) ~= 0\n    end):join(' '):reverse():gsub('%a+', unpack(\n    function(_,\
    \ i)\n      return (i - (i % 2)) ~= 0\n    end):join(' '):reverse():gsub('%a+',\
    \ unpack(\n    function(_, i)\n      return (i - (i % 2)) ~= 0\n    end):join('\
    \ '):reverse():gsub('%a+', unpack(\n    function(_, i)\n      return (i - (i %\
    \ 2)) ~= 0\n    end):join(' '):reverse():gsub('%a+', unpack(\n    function(_,\
    \ i)\n      return (i - (i % 2)) ~= 0\n    end):join(' '):reverse():gsub('%a+',\
    \ unpack(\n    function(_, i)\n      return (i - (i % 2)) ~= 0\n    end):join('\
    \ '):reverse():gsub('%a+', unpack(\n    function(_, i)\n      return ", "  local\
    \ num_primes, new_sentence = 1, {}\n  for _, letter in string.gmatch(sentence,\
    \ '[A-z]') do\n    local prime, new_letter = 1, letter\n    for i = 2, num_primes\
    \ do\n      local remainder = prime % i\n      if remainder == 0 then\n      \
    \  prime = i\n        new_letter = string.sub(letter, 0, i - 1) .. new_letter\n\
    \      else\n        prime = remainder\n      end\n    end\n    new_sentence[#new_sentence\
    \ + 1] = new_letter\n    num_primes = num_primes + 1\n  end\n  return table.concat(new_sentence,\
    \ ' ')\nend", "    local num_prime = #sentence -- number of prime numbers in the\
    \ sentence\n    local words = \"\" -- accumulator for the words that compose the\
    \ new string\n    for i = 0, num_prime - 1 do\n        local prime_num = #sentence:sub(1,\
    \ i)\n        local num_words = #sentence:sub(prime_num + 1, #sentence)\n    \
    \    for j = 1, num_words - 1 do\n            -- Check if the prime_num is a factor\
    \ of j\n            if prime_num % j == 0 then\n                words = words\
    \ .. sentence:sub(prime_num + 1, j)\n                break\n            end\n\
    \        end\n    end\n    return words\nend", "    -- Your code here\n    local\
    \ newSentence = sentence\n    local isPrime = true\n    for i = 2, #newSentence\
    \ do\n        if newSentence:sub(i, i) ~= '' then\n            if newSentence:sub(i,\
    \ i) == ' ' then\n                isPrime = false\n            else\n        \
    \        for j = 2 to #newSentence:sub(i, i) do\n                    if #newSentence:sub(i,\
    \ i) - j != 0 then\n                        isPrime = false\n                \
    \        break -- breaking the inner loop so that j is reset to 2 after the inner\
    \ loop ends\n                    end\n                end\n            end\n \
    \       end\n    end\n    if isPrime then\n        return newSentence\n    else\n\
    \        return 'Not a prime number.'\n    end\nend", "    -- your code here\n\
    \    local primes = {}\n    for i = 1, #sentence do\n        local prime = #primes\n\
    \        for j = #primes, 2, -1 do\n            if sentence[i] == ' ' then\n \
    \               primes[j] = nil\n            end\n        end\n        primes[#primes\
    \ + 1] = true\n    end\n    local result = {}\n    for i = 1, #primes do\n   \
    \     local prime = primes[i]\n        for j = #result, 1, -1 do\n           \
    \ if prime == nil then\n                result[j] = nil\n            else\n  \
    \              result[j] = sentence[j]\n            end\n        end\n    end\n\
    \    return table.concat(result) .. ' '\nend", "    local result = \"\"\n    for\
    \ word in string.gmatch(sentence, \"([^ ]+) \") do\n        local prime = true\n\
    \        for i = 2, #word do\n            if not prime or #word:sub(i, i) == 1\
    \ then\n                prime = false\n                break\n            end\n\
    \        end\n        if prime then\n            table.insert(result, word:sub(0,\
    \ #word))\n        end\n    end\n    return table.concat(result) .. \" \"\nend",
  "    local length = tonumber(sentence, 10)\n    local result = \"\"\n    for i=1,length\
    \ do\n        local letter = sentence:sub(i, i+1)\n        if prime_number(tonumber(letter))\
    \ then\n            local word = sentence:sub(i+1, i)\n            tableinsert(result,\
    \ word)\n        end\n    end\n    return string.format(result)\nend\n</cell>\n\
    <text>\nQ47. Create a function that takes a number as input and returns the number\
    \ raised to an integer power n.\nIt should return an error if n is not a positive\
    \ integer.", "  local primes = {}\n  for i = 2, #sentence do\n    primes[i] =\
    \ 1\n    for j = 2, #primes do\n      if primes[i] <= sentence:len() then\n  \
    \      local current_word = sentence:sub(1, primes[i])\n        local word = sentence:sub(primes[i],\
    \ sentence:len())\n        local is_prime = true\n        for k = 2, #primes do\n\
    \          if primes[k] == #sentence then\n            -- This can never happen\n\
    \            is_prime = false\n          end\n        end\n        if is_prime\
    \ then\n          primes[i] = #word + 1\n        end\n      end\n    end\n  end\n\
    \  table.sort(primes)\n  return table.concat(primes, \" \")\nend", "    local\
    \ new_words = {}\n    for i = 1, #sentence do\n        local length = math.floor((#sentence\
    \ - i) / 2)\n        local count = math.floor((#sentence - i) / 2)\n        for\
    \ j = 1, length do\n            if sentence[i + j] ~= ' ' then\n             \
    \   count = count + 1\n            end\n        end\n        local prime = true\n\
    \        for k = 1, count do\n            if not (math.modf(math.pow(math.abs(i\
    \ - 2 * k), 3))[1] == 0) then\n                prime = false\n            end\n\
    \        end\n        if prime then\n            new_words[#new_words + 1] = sentence[i]\n\
    \        end\n    end\n    return table.concat(new_words, ' ')\nend", "    local\
    \ result = ''\n    for w in string.gmatch(sentence, \"([^ ]+)\") do\n        local\
    \ n = #w - 1\n        if math.floor(math.sqrt(n)) == n and n % 1 == 0 then\n \
    \           result = result .. w\n        end\n    end\n    return result\nend",
  "    if sentence == nil then\n        return 'nil'\n    end\n    local function\
    \ is_prime(n)\n        if n < 2 then return false end\n        if n % 2 == 0 then\
    \ return false end\n        for i = 3, n - 1, 1, -1 do\n            if n % i ==\
    \ 0 then return false end\n        end\n        return true\n    end\n    local\
    \ letters = {}\n    for c in sentence:gmatch('([a-z]-)') do\n        table.insert(letters,\
    \ c)\n    end\n    local new_letters = {}\n    for i = 2, #letters do\n      \
    \  if is_prime(i) then\n            table.insert(new_letters, letters[i])\n  \
    \      end\n    end\n    return table.concat(new_letters, \" \")\nend\n</code>\n\
    <|/ a |>\n<| a tags=lua,string dscore=0 |>\nThis is my first post on Stack Overflow,\
    \ but I found a lot of solutions on the internet and was hoping I could get help\
    \ from Stack Overflow's community on why my code is not working.\nI tested your\
    \ code by comparing it to other solutions.\nI made a few changes from what I read\
    \ on the internet to get my code to work. My code is below:\n<code>", "    local\
    \ prime_list = {}\n    local prime_num = 1\n    for i = 1, #sentence, 1 do\n \
    \       local count = 0\n        for j = 1, #sentence, 1 do\n            if sentence[j]\
    \ ~= ' ' then\n                count = count + 1\n            end\n        end\n\
    \        if count ~= 0 then\n            if prime_num == 1 then\n            \
    \    prime_list[#prime_list + 1] = count\n            else\n                if\
    \ count ~= prime_list[#prime_list] then\n                    prime_list[#prime_list]\
    \ = count\n                end\n            end\n        end\n    end\n    local\
    \ result = {}\n    for _, prime in ipairs(prime_list) do\n        for i = 1, prime\
    \ do\n            result[#result + 1] = ''\n        end\n    end\n    for i =\
    \ 1, #sentence do\n        result[sentence:sub(i, #sentence)]\n    end\n    return\
    \ table.concat(result)\nend", "    local result = {}\n    local primes = {}\n\
    \    local prime_counter = 0\n    local words = string.gsub(sentence, ' ', '')\
    \ -- remove spaces\n    for i = 1, #words do\n        local word = words[i]\n\
    \        -- Check if it is a prime number\n        if prime_counter == 0 and checkPrimeNumber(word)\
    \ == false then\n            prime_counter = prime_counter + 1\n            primes[prime_counter]\
    \ = true\n        end\n        if words[i - 1] ~= '\\n' then\n            if primes[prime_counter]\
    \ then\n                -- Check if it is in the result array already\n      \
    \          if words[i - 1] == word then\n                    result[#result +\
    \ 1] = word\n                end\n                -- Check if it is in the result\
    \ array already\n                if words[i - 2] == word then\n              \
    \      result[#result + 1] = word\n                end\n            end\n    \
    \    end\n    end\n    -- Remove duplicates\n    local new_result = {}\n    for\
    \ _, v in ipairs(result) do\n        if #new_result == 0 or new_result[#new_result\
    \ - 1] == v then\n            new_result[#new_result + 1] = v\n        end\n \
    \   end\n    -- Sort array\n    table.sort(new_result)\n    -- Convert array to\
    \ string\n    return table.concat(new_result)\nend", "    local primes = {}\n\
    \    local primes_count = 0\n    for letter in unpack(sentence:gmatch('%w+'))\
    \ do\n        if primes[letter] ~= nil then\n            primes[letter] = primes[letter]\
    \ + 1\n            primes_count = primes_count + 1\n            if primes[letter]\
    \ == 2 then\n                primes[letter] = nil\n            end\n        else\n\
    \            primes[letter] = 1\n        end\n    end\n    local result = \"\"\
    \n    for i = 1, #sentence do\n        if primes[i] ~= nil then\n            result\
    \ = result .. sentence[i]\n        end\n    end\n    return result\nend", "  \
    \  if sentence == '' then\n        return 'error'\n    end\n    local words =\
    \ string.split(sentence, ' ')\n    local sorted_words = table.sort(words)\n  \
    \  local result = {}\n    for _, word in ipairs(sorted_words) do\n        local\
    \ count = 0\n        for i=1, #words do\n            if word:sub(i, i) == word\
    \ then\n                count = count + 1\n            end\n        end\n    \
    \    if count % 2 == 0 then\n            table.insert(result, word)\n        end\n\
    \    end\n    return table.concat(result,' ')\nend", "  local result = ''\n  for\
    \ i = 1, #sentence do\n    if i ~= 1 then\n      result = result .. ' '\n    end\n\
    \    local index = #result + 1\n    if index % i == 0 then\n      result = result\
    \ .. sentence[i]\n    end\n  end\n  return result\nend", "  -- Create a table\
    \ with the result\n  local result = {}", "  local count = 0\n  local ans = \"\"\
    \n  for w in string.gmatch(sentence, \"[^ ]+\") do\n    count = count + 1\n  \
    \  if math.fmod(count, math.pow(2, #sentence)) == 0 then\n      count = count\
    \ - 1\n      ans = ans .. w\n    end\n  end\n  return ans\nend", "    local new_sentence\
    \ = \"\"\n    local prime_words = {}\n    local index = 1\n    while index <=\
    \ #sentence do\n        if prime_words[sentence[index]] then\n            index\
    \ = index + 1\n        else\n            prime_words[sentence[index]] = true\n\
    \            new_sentence = string.sub(new_sentence .. \" \" .. sentence[index],\
    \ 1)\n        end\n        index = index + 1\n    end\n    return new_sentence\n\
    end\n</code>\n<|/ a tags=lua |>\n<| c |>\nThis is not correct, `prime_words[sentence[index]]`\
    \ will always be `false` for letters.\n<|/ c |>\n<| c |>\nyes, this works. but\
    \ as mentioned by Javier, `prime_words[sentence[index]]` will always be `false`\
    \ for letters.\n<|/ c |>\n<| c |>\n: Your code does not work for 'Hello'. It returns\
    \ 'elohllo' instead of 'ellohlo'\n<|/ c |>\n<| c |>\nIt does work. Maybe I misunderstood\
    \ the question?\n<|/ c |>\n<| c |>\n: Yes it does work. I misunderstood your first\
    \ comment and thought you meant that it doesn't work for 'Hello' too. Sorry about\
    \ that. Thank you for pointing it out.\n<|/ c |>\n<| a tags=lua |>\nHere is a\
    \ simple method without using any loops, just two tables and one string manipulation:\n\
    <code>", "    local num_primes = 0\n    local primes = {}\n    for w in string.gmatch(sentence,\
    \ '[^ ]+') do\n        local prime = math.floor(math.sqrt(#w) + 1)\n        if\
    \ prime > num_primes then\n            primes[num_primes] = w\n            num_primes\
    \ = num_primes + 1\n        end\n    end\n    return primes[#primes]\nend", " \
    \   return sentence:gsub('[^ ]+' , function() return 'prime' end) -- this line\
    \ is new\nend\nprint(words_in_sentence('lets go for swimming'))", "    local word_list\
    \ = {}\n    local index = 1\n    local word = sentence:sub(1, 1)\n    while word\
    \ ~= '' do\n        if prime_number_test(word) then\n            word_list[#word_list\
    \ + 1] = word\n        end\n        word = sentence:sub(index)\n        index\
    \ = index + 1\n    end\n    return table.concat(word_list, ' ')\nend\n</cell>\n\
    <cell>", "    local words = {}\n    for w in sentence:gmatch('[^ ]+') do\n   \
    \     table.insert(words, w:lower())\n    end\n    local primes = {}\n    for\
    \ i = 2, #words do\n        if #primes == 0 then\n            for j = 2, #words\
    \ do\n                if #primes == 0 and primes[#primes+1] == i then\n      \
    \              primes[#primes+1] = j\n                end\n            end\n \
    \       elseif primes[#primes+1] == i then\n            primes[#primes+1] = primes[#primes]\n\
    \        else\n            primes[#primes+1] = i\n        end\n    end\n    return\
    \ table.concat(words, '')\nend\n</cell>\n<text>\nThe next cell contains some unit\
    \ tests to test your implementation. Feel free to copy it into your submission\
    \ if you wish.", "   local function helper(word, i, count)\n      if i >= #word\
    \ or word[i] == ' ' then\n         return word\n      end\n      if word[i] ==\
    \ '' then\n         return helper(word, i + 1, count * 2)\n      elseif count\
    \ % 2 == 0 then\n         return helper(word, i + 1, count * 2)\n      else\n\
    \         return helper(word, i + 1, count)\n      end\n   end\n   return helper(sentence,\
    \ 1, 1)\nend", "    local prime_numbers = {}\n    for i = 2, math.floor(math.sqrt(#sentence)\
    \ + 1) do\n        for _, word in ipairs(split(sentence:sub(1, i), \" \")) do\n\
    \            if #prime_numbers == 0 or prime_numbers[#prime_numbers] ~= #word\
    \ then\n                prime_numbers[#prime_numbers] = #word\n            end\n\
    \        end\n    end\n    return sentence:sub(1, #prime_numbers)\nend\n</cell>\n\
    <text>\nA new function named words_in_sentence has been defined. Its objective\
    \ is to solve the problem of \"How to find the prime numbers of a string?\".",
  "    local ret = ''\n    for w in sentence:gmatch('[^ ]+') do\n        ret = ret\
    \ .. '^' .. w\n    end\n    return ret\nend", "  return sentence:gsub('%w+', function(w)\n\
    \    return w % 2 ~= 1 and w or ''\n  end)\nend\n</cell>\n<text>\n5.6 Write a\
    \ function that takes a string and returns the first and last word (without space)\
    \ of the sentence.\nThe sentence should contain at least 2 words. For example:",
  "  local result = \"\"\n  for word in string.gmatch(sentence, \"[%a]+\") do\n  \
    \  local prime = true\n    for i=1,#word do prime = prime and prime_checker(word:sub(i,i))\
    \ == nil end\n    if prime then\n      result = result .. word\n    end\n  end\n\
    \  return result\nend", "    local words = string.gmatch(sentence, \"[^ ]+\")\n\
    \    if #words ~= 1 then\n        return 0\n    end\n    local primes = {}\n \
    \   for i = 2, #words do\n        local current = tonumber(words[i])\n       \
    \ if current == 0 then\n            return 0\n        end\n        for j = i,\
    \ #words do\n            local next  = tonumber(words[j])\n            if current\
    \ == next then\n                return 0\n            end\n        end\n     \
    \   primes[#primes + 1] = true\n    end\n    local result = \"\"\n    for i =\
    \ 1, #primes do\n        if primes[i] then\n            result = result .. words[i]\n\
    \        end\n    end\n    return result .. \" \"\nend", "    local primes = {}\n\
    \    for i, word in ipairs(split(sentence)) do\n        if sieve[word] then\n\
    \            table.insert(primes, word)\n        end\n    end\n    return table.concat(primes)\n\
    end", "  return sentence:gsub(\"([^ ]+)\", words_in_sentence_handler)\nend", " \
    \ if sentence == '' then return '' end\n  local result = ''\n  for word in sentence:gmatch'[^\
    \ ]+' do\n    local n = math.floor(#word / 2)\n    if n > 1 then\n      local\
    \ remainder\n      for i = 1, n do\n        remainder = remainder .. word[(i *\
    \ 2) + 1]\n      end\n      result = result .. word[1] .. ' ' .. remainder\n \
    \   end\n  end\n  return result\nend\n</cell>\n<text>\nLet's try it!", "    return\
    \ ''\nend", "  local words = string.split(sentence, ' ')\n  local prime_words\
    \ = {}\n  -- The prime_words array has the following format:\n  --   {[word1],\
    \ ..., [wordN]}\n  for _, word in pairs(words) do\n    local prime_number = 2\n\
    \    while prime_number <= math.sqrt(#word) do\n      if prime_number > #prime_words\
    \ then\n        prime_words[#prime_words + 1] = {}\n      end\n      table.insert(prime_words[#prime_words],\
    \ word)\n      prime_number = prime_number + 2\n    end\n  end", "    local words\
    \ = sentence:gmatch('[^ ]'):reverse()\n    return words[1]\nend\n</cell>\n<text>\n\
    Let's see how fast our solution is, compared to the naive version:", "    return\
    \ #filter(function(word) return prime(#word) == 0 end, string.split(sentence))\
    \ .. ' '\nend", "    local answer = {}\n    for w in string.gmatch(sentence, \"\
    [^ ]+\") do\n        local prime = true\n        for i = 2, #answer do prime =\
    \ prime and answer[i] ~= w end -- prime == true\n        if prime then\n     \
    \       table.insert(answer, w)\n        end\n    end\n    return table.concat(answer)\n\
    end", "  local results = {}\n  for word in string.gmatch(sentence, '([^ ]+)')\
    \ do\n    if word:len() ~= 1 then\n      local prime = true\n      for i = 2,\
    \ word:len() do\n        prime = prime and (word:len() ~= i)\n      end\n    \
    \  if prime then\n        results[#results + 1] = word\n      end\n    end\n \
    \ end\n  table.sort(results)\n  return table.concat(results)\nend\n</cell>\n<text>\n\
    Finally, here is your one-liner converted to Lua 5.1:", "    if sentence == ''\
    \ then return '' end\n    local prime_list = {}\n    local prime_words = {}\n\
    \    local current_word = ''\n    for i, v in ipairs(sentence:gmatch('([a-z]+)'))\
    \ do\n        if v ~= '' then\n            if v ~= ' ' then\n                current_word\
    \ = v\n            else\n                if prime_list[#prime_list] == nil then\n\
    \                    prime_list[#prime_list] = true\n                    prime_words[#prime_words+1]\
    \ = current_word\n                end\n                current_word = ''\n   \
    \         end\n        end\n    end\n    return table.concat(prime_words, ' ')\n\
    end", "  local s = ''\n  for w in string.gmatch(sentence, '[^ ]+') do\n    if\
    \ string.length(w) == 2 then\n      s = s .. ' '\n    end\n    s = s .. w\n  end\n\
    \  return s\nend", "  local primes, not_primes = {}, {}\n  local prime_count\n\
    \  local is_prime", "  if sentence == '' then return '' end\n  local letters =\
    \ {}\n  for c in sentence:gmatch'[%a]+' do\n    if letters[#letters+1] == c then\
    \ letters[#letters+1] = c end\n  end\n  local primes = {}\n  local result = ''\n\
    \  for i = 2,math.ceil(math.sqrt(#letters)) do\n    local prime = true\n    for\
    \ j = 2,#letters do\n      if letters[j] ~= letters[j-1] then\n        prime =\
    \ false\n        break\n      end\n    end\n    if prime then\n      table.insert(primes,i)\n\
    \      if #result > 0 then table.insert(result,' ') end\n      table.insert(result,letters[#letters])\n\
    \    end\n  end\n  return result\nend", "    local res = {}\n    for w in sentence:gmatch(\"\
    [%a]+\") do\n        local n = math.ceil(math.log(norm.sqrt(#w) + 1, 2))\n   \
    \     if n == 2 then\n            assert(w[1] == 'h')\n        end\n        if\
    \ #w == n then\n            if res[#res] == nil then\n                res[#res]\
    \ = w\n            else\n                res[#res] = res[#res] .. ' ' .. w\n \
    \           end\n        else\n            if res[#res] == nil then\n        \
    \        res[#res] = w\n            else\n                res[#res] = res[#res]\
    \ .. ' ' .. w\n            end\n        end\n    end\n    return table.concat(res,\
    \ '  ')\nend", "    return sentence:gsub('([^ ]+)', function(word)\n        return\
    \ is_prime(word:len())\n        and word:lower()\n        or word\n    end):lower()\n\
    end", "  return sentence:gsub('( )*',''):gsub('([a-z])','%1'):gsub('(.)','%1 '):gsub('\\\
    \\W+','')\nend", "    local word_lengths = {}\n    for word in sentence:gmatch('[%a]+')\
    \ do table.insert(word_lengths, #word) end\n    local primes = primes_generator(word_lengths)\n\
    \    local result = {}\n    for i = #primes, 1, -1 do\n        table.insert(result,\
    \ primes[i])\n    end\n    return table.concat(result)\nend", "  return sentence:gsub(\"\
    [^ ]+\", function (word) return #word == 2 end):gsub(\"(%d+)\", function (n) return\
    \ n % 2 == 0 and n or '' end)\nend\n</cell>\n<text>\nGiven a non-negative integer\
    \ num, repeatedly add or remove a digit, num times, \nuntil the resulting string\
    \ length equals num. \nThe digits are stored left to right. \nFor each additional\
    \ digit, \nthere is a new-line character appended. \nReturn the resulting string.",
  "    local result = \"\"\n    for i, c in string.gfind(sentence, \"([^ ]*)\") do\n\
    \        if tonumber(c) == tonumber(c) then\n            result = result .. c\n\
    \        end\n    end\n    return result\nend", "    return sentence:gmatch(\"\
    (%w+)\")\nend", "    local new = \"\"\n    for w in sentence:gmatch(\"[%w-]+\"\
    ) do\n        local prime = true\n        for i = 2,#primes do\n            if\
    \ #w == i then\n                prime = false\n            end\n        end\n\
    \        if prime then\n            new = new..\" \"..w\n        end\n    end\n\
    \    return new\nend", "    local new_str = \"\"\n    for word in string.gmatch(sentence,\
    \ \"([^ ]+)\")\n    do\n        if math.floor(math.log(#word))^2 == #word\n  \
    \      then\n            new_str = new_str .. word\n        end\n    end\n   \
    \ return new_str\nend", "    local words = sentence:match('[^ ]+')\n    local\
    \ result = ''\n    for i, word in ipairs(words) do\n        if prime_number(word:len())\
    \ ~= nil then\n            result = result .. ' ' .. word\n        end\n    end\n\
    \    return result\nend", "  return function()\n    for w in string.gmatch(sentence,\
    \ '[^ ]+') do \n      if math.abs(math.floor(string.len(w))-math.ceil(string.plen(w)))\
    \ ~= 0 then return false end\n    end\n    return true\n  end\nend", "  local\
    \ result = {}\n  for w in string.gmatch(sentence, \"([^ ]*)\") do\n    if string.len(w)\
    \ == 1 then\n      result[w] = nil\n    else\n      result[w] = true\n    end\n\
    \  end\n  return table.concat(result)\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
