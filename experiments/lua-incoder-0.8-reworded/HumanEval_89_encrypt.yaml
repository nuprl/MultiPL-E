name: HumanEval_89_encrypt
language: lua
prompt: "-- Create a function encrypt that takes a string as an argument and\n-- returns\
  \ a string encrypted with the alphabet being rotated. \n-- The alphabet should be\
  \ rotated in a manner such that the letters \n-- shift down by two multiplied to\
  \ two places.\n-- For example:\n-- >>> encrypt('hi')\n-- 'lm'\n-- >>> encrypt('asdfghjkl')\n\
  -- 'ewhjklnop'\n-- >>> encrypt('gf')\n-- 'kj'\n-- >>> encrypt('et')\n-- 'ix'\nlocal\
  \ function encrypt(s)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = encrypt\n\
  \    lu.assertEquals(candidate('hi'), 'lm')\n    lu.assertEquals(candidate('asdfghjkl'),\
  \ 'ewhjklnop')\n    lu.assertEquals(candidate('gf'), 'kj')\n    lu.assertEquals(candidate('et'),\
  \ 'ix')\n    lu.assertEquals(candidate('faewfawefaewg'), 'jeiajeaijeiak')\n    lu.assertEquals(candidate('hellomyfriend'),\
  \ 'lippsqcjvmirh')\n    lu.assertEquals(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'),\
  \ 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')\n    lu.assertEquals(candidate('a'),\
  \ 'e')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tlocal alphabet = string.gsub(alphabet, '([a-z])', '\\\\2\\\\1')\n\
    \treturn string.gsub(s, '(..)(..)', '\\\\2\\\\1\\\\3')\nend", "  local alphabet\
    \ = {'z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \  local rotate = function(x)\n    return alphabet[x+1]\n  end\n  \n  local out\
    \ = \"\"\n  for i=1,#s do\n    local c = s[i]\n    local rotated_char = rotate(alphabet.index(c))\n\
    \    out = out .. rotated_char\n  end\n  return out\nend", "    -- Complete this\
    \ function.\nend\n</cell>\n<cell>", "  local alphabet = {\n    ['a'] = 65,\n \
    \   ['b'] = 66,\n    ['c'] = 67,\n    ['d'] = 68,\n    ['e'] = 69,\n    ['f']\
    \ = 70,\n    ['g'] = 71,\n    ['h'] = 72,\n    ['i'] = 73,\n    ['j'] = 74,\n\
    \    ['k'] = 75,\n    ['l'] = 76,\n    ['m'] = 77,\n    ['n'] = 78,\n    ['o']\
    \ = 79,\n    ['p'] = 80,\n    ['q'] = 81,\n    ['r'] = 82,\n    ['s'] = 83,\n\
    \    ['t'] = 84,\n    ['u'] = 85,\n    ['v'] = 86,\n    ['w'] = 87,\n    ['x']\
    \ = 88,\n    ['y'] = 89,\n    ['z'] = 90\n  }\n  local t = {}\n  local n = {}\n\
    \  local i = 1\n  for c in s:gmatch('([a-z]+)'..'%d+') do\n    t[i] = alphabet[c]\n\
    \    i = i + 1\n  end\n  for i = 2,#t do\n    n[i] = t[i]\n  end\n  local str\
    \ = ''\n  i = 2\n  while i <= #n do\n    str = str..n[i]..n[i-1]\n    i = i +\
    \ 1\n  end\n  return str\nend", "    local alphabet = {\n        -- a\n      \
    \  'a','b','c','d','e','f','g','h',\n        -- b\n        'i','j','k','l','m','n','o','p',\n\
    \        -- c\n        'q','r','s','t','u','v','w','x',\n        -- d\n      \
    \  'y','z','A','B','C','D','E','F',\n        -- e\n        'G','H','I','J','K','L','M','N',\n\
    \        -- f\n        'O','P','Q','R','S','T','U','V',\n        -- g\n      \
    \  'W','X','Y','Z',' ','!','$',\n        -- h\n        '^','&','*','(',')','_','+','=',\n\
    \        -- i\n        'a','b','c','d','e','f','g','h',\n        -- j\n      \
    \  'i','j','k','l','m','n','o','p',\n        -- k\n        'q','r','s','t','u','v','w','x',\n\
    \        -- l\n        'y','z','A','B','C','D','E','F',\n        -- m\n      \
    \  'G','H','I','J','K','L','M','N',\n        -- n\n        'O','P','Q','R','S','T','U','V',\n\
    \        -- o\n        'W','X','Y','Z',' ','!','$',\n        -- p\n        '^','&','*','(',')','_','+','=',\n\
    \        -- q\n        'a','b','c','d','e','f','g','h',\n        -- r\n      \
    \  'i','j','k','l','m','n','o','p',\n        -- s\n        'q','r','s','t','u','v','w','x',\n\
    \        -- t\n        'y','z','A','B','C','D','E','F',\n        -- u\n      \
    \  'G','H','I','J','K','L','M','N',\n        -- v\n        'O','P','Q','R','S','T','U','V',\n\
    \        -- w\n        'W','X','Y','Z',' ','!','$',\n        -- x\n        '^','&','*','(',')','_','+",
  "  -- Initialize an alphabet variable and make its size double to the size of the\
    \ string.\n  local alphabet = string.char() \n  for i=1,#s do\n    alphabet =\
    \ alphabet..string.char((string.len(alphabet)+i)%#alphabet)\n  end\n  -- Set the\
    \ letter that corresponds to character 0 to letter #\n  alphabet = alphabet..string.char(0)\n\
    \  -- Loop through the string until you reach the end.\n  -- For each letter,\
    \ use the alphabet to find the next letter after\n  -- moving the letter down\
    \ by two positions, each time multiplying it by 2\n  -- so that the letter shifts\
    \ down two positions to two places.\n  -- Keep going until you reach the end.\n\
    \  for i = 1,#s do\n    local encryptedString = alphabet..string.sub(alphabet,\
    \ #alphabet*(#alphabet+2)+1, #alphabet*(#alphabet+2)+#alphabet+1)\n    alphabet\
    \ = alphabet..string.sub(alphabet, #alphabet*(#alphabet+2), #alphabet*(#alphabet+2)+#alphabet+1)\n\
    \    return encryptedString..string.sub(s,i,i)\n  end\nend", "  local cipher =\
    \ {}\n  local key = 'abcdefghijklmnopqrstuvwxyz'\n  for i = 1, #s do\n    local\
    \ c1 = string.sub(s,1,i)\n    local c2 = string.sub(s,i+1,#s)\n    local c = string.sub(key.sub(c1,#c1)..string.sub(key.sub(c2,1,#c2),1,#key.sub(c2,1,#c2)),1,#key.sub(c2,1,#c2))\n\
    \    table.insert(cipher,c)\n  end\n  return table.concat(cipher)\nend", "\t--\
    \ Convert the string to a list of characters using string.gsub().\n\t-- This function\
    \ will convert spaces to underscores (_) so that later\n\t-- we can use gsub()\
    \ to replace the underscores with spaces.\n\tlocal s = string.gsub(s, '%S', '_')",
  "  if #s < 2 then return '' : end\n  local alph = string.char(tonumber(s) .. string.sub(s,2))\n\
    \  local rot = ''\n  for i = 1, #s do\n    rot = string.sub(s,i,i+1)\n    if rot\
    \ ~= '' then\n      rot = tonumber(rot) .. string.sub(alph,tonumber(rot)-1,tonumber(rot)-1)\n\
    \    end\n  end\n  return rot\nend", "    local alphabet =\n        {'a', 'b',\
    \ 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\
    \ 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n    \n    -- Create a map that maps\
    \ letters to their shifted positions.\n    local map = {}\n    for i = 1, #alphabet\
    \ do\n        -- Rotate each letter by two to the right.\n        -- A 'l' ->\
    \ 'm', 'a' -> 'n', 's' -> 'o', etc...\n        map[alphabet[i]] = alphabet[#alphabet]..alphabet[#alphabet]..alphabet[i]\n\
    \    end\n    \n    -- The encrypted string starts off empty.\n    local encrypted\
    \ = ''\n    \n    -- For each character in 's', append its encrypted counterpart\
    \ to the result.\n    for i = 1, #s do\n        encrypted = encrypted..map[s[i]]\n\
    \    end\n    \n    return encrypted\nend", "  -- Create a dictionary where each\
    \ letter is mapped to a dictionary value.\n  -- The value will be the letter to\
    \ shift the alphabet by two places.\n  local dict={}\n  \n  -- Store the letters\
    \ to shift by two multiplied to the two places in the alphabet.\n  for i,v in\
    \ pairs(alphabet) do\n    dict[v] = i*2\n  end\n  \n  -- Loop through each character\
    \ of the string.\n  local encrypted=\"\"\n  for i=1,#s do\n    local ch=s[i]\n\
    \    local cipher=\"\"\n    -- Loop through each letter of the alphabet.\n   \
    \ for letter,multiplier in pairs(dict) do\n      -- Calculate the shifted letter\
    \ using the multiplier.\n      local shift=((letter - 'a') * multiplier) + letter\n\
    \      -- Append the shifted letter to the cipher string.\n      cipher=cipher..cipher[shift]\n\
    \    end\n    -- Append the cipher string to encrypted string.\n    encrypted=encrypted..cipher\n\
    \  end\n  \n  return encrypted\nend", "  -- Create a variable and set it to an\
    \ empty string\n  -- This is what will hold the encrypted value\n  local encrypted\
    \ = \"\";\n  \n  -- Create a variable and set it to an empty string\n  -- This\
    \ is what will hold the decrypted value\n  local decrypted = \"\";\n  \n  -- Use\
    \ a for loop to go through each character in the string\n  -- Note that I subtract\
    \ two from each character to make sure it\n  -- rotates over 2 places to account\
    \ for shifting of the letters\n  for i = 1,#s do\n    -- Get the ASCII value for\
    \ each character in our string\n    local a = tostring(s:sub(i,i)) - 'a';\n  \
    \  \n    -- If the ASCII value is a letter\n    if a >= 65 then\n      -- Get\
    \ the letter that is two letters to the right of the \n      -- ASCII value\n\
    \      local b = tostring(s:sub(i+2,i+2)) - 'a';\n      \n      -- If the letter\
    \ is a lowercase letter\n      if a <= 91 then\n        -- If the letter is not\
    \ a lowercase\n        if b <= 91 then\n          -- If the letter is not a lowercase\n\
    \          if b >= 65 then\n            -- If the letter is a lowercase\n    \
    \        -- Concatenate both the letters and then add the \n            -- ASCII\
    \ value\n            encrypted = encrypted .. string.char(b + 26);\n         \
    \ else\n            -- If the letter is a lowercase\n            -- Concatenate\
    \ both the letters but subtract the \n            -- ASCII value\n           \
    \ decrypted = decrypted .. string.char(b - 26);\n          end\n        else\n\
    \          -- If the letter is a lowercase\n          -- Concatenate just the\
    \ letters and add the ASCII value\n          encrypted = encrypted .. string.char(b\
    \ + 21);\n        end\n      else\n        -- If the letter is not a lowercase\n\
    \        -- Concatenate just the letters and add the ASCII value\n        encrypted\
    \ = encrypted .. string.char(b + 20);\n      end\n    else\n      -- If the ASCII\
    \ value is not a letter\n      -- Concatenate just the letters and add the ASCII\
    \ value\n      encrypted = encrypted .. string.char(a);\n    end\n  end\n  \n\
    \  -- Return the encrypted string\n  return encrypted;\nend", "    -- Convert\
    \ string to array\n    local arr = s:gsub(\"[a-z]\", function(letter)\n      \
    \  -- Return character with value twice subtracted from 26 \n        return string.char((string.byte(letter)\
    \ - 2) * 2); \n    end):lower()", "    local alphabet = {\n        'abcdefghijklmnopqrstuvwxyz',\n\
    \        'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n        '0123456789'\n    }\n    local\
    \ alphabets = alphabet\n    if alphabets[alphabet] ~= '' then\n        alphabets\
    \ = alphabets[alphabet:len() .. 1]\n    end\n    local alphabets_len = alphabets:len()\n\
    \    local result = {}\n    for _, chars in ipairs(s) do\n        for _, char\
    \ in ipairs(chars) do\n            result[#result + 1] = '' .. alphabets[\n  \
    \              math.floor((alphabets_len + alphabet_index(char)) * math.pow(2,\
    \ (alphabets_len - alphabet_index(char)))\n            ]\n        end\n    end\n\
    \    return table.concat(result, '')\nend", "   -- Check for empty string.\n \
    \  if s == nil or s == '' then\n      return nil\n   end\n   \n   -- Create a\
    \ variable c that will hold the encrypted string.\n   local c = ''\n   \n   --\
    \ Loop through each character in the string.\n   for i = 1, #s do\n      -- Find\
    \ the character in the alphabet\n      -- that corresponds to the current character\
    \ in the string.\n      local c = alphabet[alphabet[s][i] + 1]\n      \n     \
    \ -- If c is nil, then the current character\n      -- does not appear in the\
    \ alphabet, so add it to\n      -- the encrypted string.\n      if c == nil then\n\
    \         c = c .. s\n      else\n         -- If the current character is in the\
    \ alphabet,\n         -- then add it to the encrypted string. Otherwise,\n   \
    \      -- append it to the encrypted string.\n         if c == '' then\n     \
    \       c = s .. c\n         else\n            c = c .. s\n         end\n    \
    \  end\n   end\n   \n   return c\nend", "  -- Create a function that returns a\
    \ given letter rotated 90 degrees\n  -- clockwise, by adding a value of 9 to the\
    \ current letter's index\n  -- multiplied by two and adding the value of the rotation\
    \ multiplied by\n  -- two. For example:\n  -- >>> rotate('a')\n  -- 'za'\n  --\
    \ >>> rotate('b')\n  -- 'ab'\n  -- >>> rotate('c')\n  -- 'ac'\n  -- >>> rotate('d')\n\
    \  -- 'ad'\n  -- >>> rotate('e')\n  -- 'ae'\n  -- >>> rotate('f')\n  -- 'af'\n\
    \  -- >>> rotate('g')\n  -- 'ag'\n  -- >>> rotate('h')\n  -- 'ah'\n  -- >>> rotate('i')\n\
    \  -- 'ai'\n  -- >>> rotate('j')\n  -- 'aj'\n  -- >>> rotate('k')\n  -- 'ak'\n\
    \  -- >>> rotate('l')\n  -- 'al'\n  -- >>> rotate('m')\n  -- 'am'\n  -- >>> rotate('n')\n\
    \  -- 'an'\n  -- >>> rotate('o')\n  -- 'ao'\n  -- >>> rotate('p')\n  -- 'ap'\n\
    \  -- >>> rotate('q')\n  -- 'aq'\n  -- >>> rotate('r')\n  -- 'ar'\n  -- >>> rotate('s')\n\
    \  -- 'as'\n  -- >>> rotate('t')\n  -- 'at'\n  -- >>> rotate('u')\n  -- 'au'\n\
    \  -- >>> rotate('v')\n  -- 'av'\n  -- >>> rotate('w')\n  -- 'aw'\n  -- >>> rotate('x')\n\
    \  -- 'ax'\n  -- >>> rotate('y')\n  -- 'ay'\n  -- >>> rotate('z')\n  -- 'az'\n\
    \  -- >>> encrypt('hello')\n  -- 'oyzdcdxwvutsrqpx'\n  -- >>> encrypt('abc')\n\
    \  -- 'cdeafgjikmohbnt'\n  -- >>> encrypt('asdfghjkl')\n  -- 'ewhjklnopqusxz'\n\
    \  -- >>> encrypt('gf')\n  -- 'kjgfezvutsrqponm'\n  -- >>> encrypt('et')\n  --\
    \ 'ixuwvutsrqponm'\n  -- >>> encrypt('aeg')\n  -- 'aegieztsrqponm'\n  -- >>> encrypt('",
  "  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  local c = \"e\"\n  local i\
    \ = #alphabet\n  repeat\n    local m = math.random(i)\n    if m == i then\n  \
    \    m = math.random(i)\n    end\n    local t = alphabet[m]\n    i = i - 1\n \
    \   c = c..t\n  until (#s)%2 == 0\n  return c..encrypt(s[#s])\nend", "    -- Encrypt\
    \ the string using ROT13\n    local out = ''\n    \n    for i = 1, #s do\n   \
    \     local index = #alphabet\n        index = index - 2\n        index = index\
    \ + (alphabet[i]:byte() - 32)\n        out = out .. alphabet[index:byte()]\n \
    \   end\n    return out\nend\n</cell>\n<cell>", "\tlocal result = \"\"\n\tfor\
    \ i = #s + 1, -1, -1 do\n\t\tresult = string.sub(alphabet_rt, math.floor((#s +\
    \ i) / 2) + 1, math.floor((#s + i) % 2) + 1) .. result\n\tend\n\treturn result\n\
    end", "    local newS = ''\n    for i = 1, #s do\n        local char = s:sub(i,\
    \ i)\n        newS = newS + char(alphabet.index(char) * 2 - 2)\n    end\n    return\
    \ newS\nend", "    local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    local\
    \ encrypted = {}\n    local j = 0\n    for i = 1, #s do\n        local temp =\
    \ alphabet:sub(j, j+1)\n        encrypted[i] = alphabet:sub(j, j+1) + alphabet:sub(j,\
    \ j+2)\n        encrypted[i + 1] = temp\n        j = j + 2\n    end\n    return\
    \ table.concat(encrypted, '')\nend", "  local a = {}\n  for i = 0, 255 do\n  \
    \  table.insert(a, string.sub(s, i, i)..string.sub(s, i+1, i+1)..string.sub(s,\
    \ i+1, i+2))\n  end\n  return table.remove(a, math.random(1, #a)+1)\nend", " \
    \ local alphabet = {}\n  alphabet[1] = 'abcdefghijklmnopqrstuvwxyz'\n  alphabet[2]\
    \ = 'pqrstuvwxyzabcdefghijklm'\n  alphabet[3] = 'rstuvwxyzabcdefghijklmnopq'\n\
    \  alphabet[4] = 'uvwxyzabcdefghijklmnopqrst'\n  alphabet[5] = 'wxyzabcdefghijklmnopqrstuv'\n\
    \  alphabet[6] = 'xyzabcdefghijklmnopqrstuvw'\n  alphabet[7] = 'yzabcdefghijklmnopqrstuvwx'\n\
    \  alphabet[8] = 'zabcdefghijklmnopqrstuvwxy'\n  alphabet[9] = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  alphabet[10] = 'abcdefghijklmnopqrstuvwxyz'\n  alphabet[11] = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  alphabet[12] = 'abcdefghijklmnopqrstuvwxyz'\n  alphabet[13] = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  alphabet[14] = 'abcdefghijklmnopqrstuvwxyz'\n  alphabet[15] = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  alphabet[16] = 'abcdefghijklmnopqrstuvwxyz'\n  alphabet[17] = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  alphabet[18] = 'abcdefghijklmnopqrstuvwxyz'\n  alphabet[19] = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  alphabet[20] = 'abcdefghijklmnopqrstuvwxyz'\n  alphabet[21] = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  alphabet[22] = 'abcdefghijklmnopqrstuvwxyz'\n  alphabet[23] = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  alphabet[24] = 'abcdefghijklmnopqrstuvwxyz'\n  alphabet[25] = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  alphabet[26] = 'abcdefghijklmnopqrstuvwxyz'\n  alphabet[27] = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  alphabet[28] = 'abcdefghijklmnopqrstuvwxyz'\n  alphabet[29] = 'abcdefghijklmnopqrst",
  "   assert(type(s) == 'string')\n   local alphabet = {\n      ['a'] = 'z'\n    \
    \  ['b'] = 'm'\n      ['c'] = 'n'\n      ['d'] = 'o'\n      ['e'] = 'p'\n    \
    \  ['f'] = 'q'\n      ['g'] = 'r'\n      ['h'] = 's'\n      ['i'] = 't'\n    \
    \  ['j'] = 'u'\n      ['k'] = 'v'\n      ['l'] = 'w'\n      ['m'] = 'x'\n    \
    \  ['n'] = 'y'\n      ['o'] = 'z'\n      ['p'] = 'm'\n      ['q'] = 'n'\n    \
    \  ['r'] = 'o'\n      ['s'] = 'p'\n      ['t'] = 'q'\n      ['u'] = 'r'\n    \
    \  ['v'] = 's'\n      ['w'] = 't'\n      ['x'] = 'u'\n      ['y'] = 'v'\n    \
    \  ['z'] = 'w'\n   }", "    local alphabet = string.gsub(string.lower(s), \"[a-z]\"\
    , \"[\" .. string.sub(string.upper(string.lower(s)), 1, 1) .. \"]\")\n    local\
    \ result = ''\n    for i = 1, #s do\n        local c = string.sub(s,i,i)\n   \
    \     local idx = alphabet and string.find(alphabet, c, 'i') or 0\n        if\
    \ idx > 0 then\n            local letter = string.sub(alphabet, idx+1, idx+2)\n\
    \            idx = idx+2\n            if idx == #alphabet then\n             \
    \   idx = 0\n            end\n            local c = string.sub(s, idx+1, idx+2)\n\
    \            local p = string.find(alphabet, alphabet, 'i') or 0\n           \
    \ p = string.sub(s, idx+1, idx+2)\n            local q = string.find(alphabet,\
    \ alphabet, 'i') or 0\n            q = string.sub(s, idx+1, idx+2)\n         \
    \   local n = string.find(alphabet, alphabet, 'i') or 0\n            n = string.sub(s,\
    \ idx+1, idx+2)\n            local l = string.find(alphabet, alphabet, 'i') or\
    \ 0\n            l = string.sub(s, idx+1, idx+2)\n            local u = string.find(alphabet,\
    \ alphabet, 'i') or 0\n            u = string.sub(s, idx+1, idx+2)\n         \
    \   local t = string.find(alphabet, alphabet, 'i') or 0\n            t = string.sub(s,\
    \ idx+1, idx+2)\n            local v = string.find(alphabet, alphabet, 'i') or\
    \ 0\n            v = string.sub(s, idx+1, idx+2)\n            local x = string.find(alphabet,\
    \ alphabet, 'i') or 0\n            x = string.sub(s, idx+1, idx+2)\n         \
    \   local d = string.find(alphabet, alphabet, 'i') or 0\n            d = string.sub(s,\
    \ idx+1, idx+2)\n            local g = string.find(alphabet, alphabet, 'i') or\
    \ 0\n            g = string.sub(s, idx+1, idx+2)\n            local b = string.find(alphabet,\
    \ alphabet, 'i') or 0\n            b = string.sub(s, idx+1, idx+2)\n         \
    \   local h = string.find(alphabet, alphabet, 'i') or 0\n            h = string.sub(s,\
    \ idx+1, idx+2)\n            local f = string.find(alphabet, alphabet, 'i') or\
    \ 0\n            f = string.sub(s, idx+1, idx+2)\n            local e = string.find(alphabet,\
    \ alphabet, 'i') or 0\n            e = string.sub(s, idx+1, idx+2)\n         \
    \   local m = string.find(alphabet, alphabet, 'i') or 0\n            m = string.sub(s,\
    \ idx+1, idx+2)\n            local k = string.find(alphabet, alphabet, 'i') or\
    \ 0\n            k = string.sub(s, idx+1, idx+2)\n            local j = string.find(alphabet,\
    \ alphabet, 'i') or 0\n            j = ", "   -- We need to create a temporary\
    \ variable for the result.  In Python, \n   -- we can use list comprehensions\
    \ for this:\n   return string.char(\n      string.sub(\n         string.gsub(\n\
    \            string.gsub(\n               string.gsub(\n                  string.gsub(\n\
    \                     string.gsub(\n                        string.gsub(\n   \
    \                        string.gsub(\n                              string.gsub(\n\
    \                                 string.gsub(\n                             \
    \       string.gsub(\n                                       string.gsub(\n  \
    \                                        string.gsub(\n                      \
    \                     string.gsub(\n                                         \
    \     string.gsub(\n                                                 string.gsub(\n\
    \                                                    string.gsub(\n          \
    \                                           string.gsub(\n                   \
    \                                   string.gsub(\n                           \
    \                            string.gsub(\n                                  \
    \                      string.gsub(\n                                        \
    \                 string.gsub(\n                                             \
    \             string.gsub(\n                                                 \
    \          string.gsub(\n                                                    \
    \          string.gsub(\n                                                    \
    \           string.gsub(\n                                                   \
    \               string.gsub(\n                                               \
    \    'abcdefghijklmnopqrstuvwxyz',\n                                         \
    \          'zxcvbnm'), \n                                                   'nopqrstuvwxyz'),\n\
    \                                                   'abcdefghijklmnopqrstuvwxyz'),\
    \ \n                                                   'zxcvbnm'), \n        \
    \                                           'nopqrstuvwxyz')\n               \
    \               ),\n                              'zxcvbnm'),\n              \
    \                'nopqrstuvwxyz'),\n                              'abcdefghijklmnopqrstuvwxyz'),\
    \ \n                              'zxcvbnm'),\n                              'nopqrstuvwxyz')\n\
    \                        ),\n                        'zxcvbnm'),\n           \
    \             'nopqrstuvwxyz')\n                  ),\n               'zxcvbnm'),\n\
    \               'nopqrstuvwxyz')\n         ),\n         'zxcvbnm'),\n        \
    \ 'nopqrstuvwxyz')\n   )\nend", "  local alphabet = string.gsub(string.gsub(string.gsub(alphabet,\
    \ '\\n',''), '^',''), '\\t','')\n  local n = 0\n  \n  return string.gsub(s, \n\
    \    function(c)\n      if alphabet[#alphabet] == '' then alphabet = '' .. alphabet\
    \ end\n      if alphabet[#alphabet] > #alphabet then alphabet = alphabet[#alphabet]:sub(1,1)\
    \ end\n      \n      local result = alphabet[#alphabet]\n      alphabet = alphabet[#alphabet]\
    \ .. alphabet[#alphabet+1]\n      alphabet = alphabet:sub(1,1) .. alphabet\n \
    \     \n      n = n + 2\n      if n == #alphabet+1 then alphabet = '' end\n  \
    \    return result\n    end)\nend", "  local alphabet = string.char((string.len(s)\
    \ - 1) * 2 + 1)\n  local n = 2\n  for i = 1, #alphabet, 2 do\n    alphabet[i]\
    \ = alphabet[i + 1]\n    alphabet[i + 1] = alphabet[i]\n  end\n  s = string.sub(s,\
    \ 1, 1)\n  for i = 1, #s do\n    s = alphabet[(alphabet[s] + (n / 2)) % #alphabet]\
    \ + alphabet[(alphabet[(s - n) % #alphabet] + n / 2)] .. s\n    n = ((n * 2) %\
    \ #alphabet) + 1\n  end\n  return s\nend", "   local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \   return alphabet[#alphabet] .. alphabet[#alphabet-1] .. alphabet[#alphabet-2]\n\
    end", "    local alphabet = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n\
    \    local alphabetLen = #alphabet\n    local shift = alphabetLen + 2\n    local\
    \ result = \"\"\n    local i = 0", "  return string.gsub(s, '([%s])', function(c)\n\
    \    local alphabet = string.char(tonumber(c) % 26)\n    return alphabet\n  end,\
    \ 'g')\nend", "\tlocal alphabet = {string.char(tonumber(string.sub(s, 'x', 1)))\n\
    \t\t\t\t\t , string.char(tonumber(string.sub(s, 'x', 2)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s,\
    \ 'x', 3)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s, 'x', 4)))\n\t\t\t\
    \t\t , string.char(tonumber(string.sub(s, 'x', 5)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s,\
    \ 'x', 6)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s, 'x', 7)))\n\t\t\t\
    \t\t , string.char(tonumber(string.sub(s, 'x', 8)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s,\
    \ 'x', 9)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s, 'x', 10)))\n\t\t\t\
    \t\t , string.char(tonumber(string.sub(s, 'x', 11)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s,\
    \ 'x', 12)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s, 'x', 13)))\n\t\t\
    \t\t\t , string.char(tonumber(string.sub(s, 'x', 14)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s,\
    \ 'x', 15)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s, 'x', 16)))\n\t\t\
    \t\t\t , string.char(tonumber(string.sub(s, 'x', 17)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s,\
    \ 'x', 18)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s, 'x', 19)))\n\t\t\
    \t\t\t , string.char(tonumber(string.sub(s, 'x', 20)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s,\
    \ 'x', 21)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s, 'x', 22)))\n\t\t\
    \t\t\t , string.char(tonumber(string.sub(s, 'x', 23)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s,\
    \ 'x', 24)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s, 'x', 25)))\n\t\t\
    \t\t\t , string.char(tonumber(string.sub(s, 'x', 26)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s,\
    \ 'x', 27)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s, 'x', 28)))\n\t\t\
    \t\t\t , string.char(tonumber(string.sub(s, 'x', 29)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s,\
    \ 'x', 30)))\n\t\t\t\t\t , string.char(tonumber(string.sub(s, 'x', 31)))}\n\t\
    return string.sub(string.gsub(s, '(.)', alphabet), 3)\nend", "  local alpha =\
    \ string.letters(string.len(s)) -- Get alphabet in string.letters\n  local result\
    \ = \"\" -- Declare a string to hold encrypted string\n  local index = 0 -- Counter\
    \ for loop\n  for i = 1, string.len(s) do -- Loop through each letter in alphabet\n\
    \    local current_letter = alpha[index] -- Get current letter from alphabet\n\
    \    local next_letter = alpha[(index + 2) % string.len(alpha)] -- Get next letter\
    \ from alphabet\n    result = (result .. string.sub(current_letter, 1, 1)) ..\
    \ next_letter -- Concatenate current letter and next letter\n    index = index\
    \ + 1 -- Increment counter\n  end\n  return result -- Return encrypted string\n\
    end", "    -- We use two for loops because we'll have to use `mod` for\n    --\
    \ each letter being shifted.\n    for letter1, letter2 in pairs(s) do\n      \
    \  -- We need to shift the letter two spaces to the left because\n        -- we\
    \ want to be able to shift letters by multiplying them by 2\n        -- (`mod`\
    \ returns the remainder after dividing by 2).\n        s[letter2] = s[letter2]\
    \ .. s[letter1]\n        s[letter1] = s[letter1] .. letter2\n    end", "\tlocal\
    \ alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\t-- Create a stack of strings to store\
    \ each character.\n\tlocal stack = {}\n\tfor i=1, #s do\n\t\tstack[i] = alphabet:sub(i,i+1)\n\
    \tend\n\t-- The encrypted string is returned at the end. \n\t-- We loop over the\
    \ string, and each character is pushed on to the \n\t-- stack one at a time until\
    \ the stack is empty.\n\t-- Then we pop the last character off of the stack and\
    \ add it to the \n\t-- encrypted string. \n\tlocal encrypted = stack[1]\n\twhile\
    \ #stack ~= 0 do\n\t\tlocal c = stack[#stack]\n\t\tencrypted = c .. encrypted\n\
    \t\tstack[#stack] = alphabet:sub((#alphabet), #alphabet) \n\tend\n\treturn encrypted\n\
    end", "  -- Define the alphabet in a list\n  local alphabet = {'a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\
    \ 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n  -- Add spaces to the beginning of the\
    \ string for encryption\n  s = s .. ' '\n  -- Define the alphabet in a list\n\
    \  local alphabet2 = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n  --\
    \ Define the length of the string as an integer\n  local n = #s\n  -- Define the\
    \ counter and rotating variable\n  local c = 0\n  -- Define the result string\
    \ to be returned\n  local result = ''\n  -- Iterate through each letter in the\
    \ string\n  for i = 1, n do\n    -- Define a temp variable for encryption\n  \
    \  local t = ''\n    -- Iterate through each character of the alphabet\n    for\
    \ j = 1, #alphabet do\n      -- If the character is equal to the letter in the\
    \ string \n      -- i, increment the counter\n      if alphabet[i] == alphabet2[j]\
    \ then\n        c = c + 1\n      -- If the counter is greater then the length\
    \ of the alphabet, \n      -- add the last letter in the alphabet to the temp\
    \ variable\n      elseif c > #alphabet2 then\n        t = t .. alphabet2[(#alphabet2\
    \ - 1)]\n      -- Otherwise, add the letter to the temp variable\n      else\n\
    \        t = t .. alphabet[(c + 1) - (#alphabet + 1)]\n      end\n    end\n  \
    \  -- Add the temp variable to the result string\n    result = result .. t\n \
    \   -- Increment the counter\n    c = c + 1\n  end\n  -- Return the encrypted\
    \ string\n  return result\nend", "  if s == nil then return nil end\n  \n  --\
    \ Initialize variables\n  local encrypted = ''\n  local shift = 0\n  \n  -- Set\
    \ up rotated alphabet\n  local alphabet = {\n    ['e'] = {['a'..'z']},\n    ['f']\
    \ = {['a'..'z']..'z'},\n    ['g'] = {['a'..'z']..'z'..'a'},\n    ['h'] = {['a'..'z']..'z'..'a'..'z'},\n\
    \    ['i'] = {['a'..'z']..'z'..'a'..'z'..'z'},\n    ['j'] = {['a'..'z']..'z'..'a'..'z'..'z'..'a'},\n\
    \    ['k'] = {['a'..'z']..'z'..'a'..'z'..'z'..'a'..'z'},\n    ['l'] = {['a'..'z']..'z'..'a'..'z'..'z'..'a'..'z'..'z'},\n\
    \    ['m'] = {['a'..'z']..'z'..'a'..'z'..'z'..'a'..'z'..'z'..'a'},\n    ['n']\
    \ = {['a'..'z']..'z'..'a'..'z'..'z'..'a'..'z'..'z'..'a'..'z'},\n    ['o'] = {['a'..'z']..'z'..'a'..'z'..'z'..'a'..'z'..'z'..'a'..'z'..'z'},\n\
    \    ['p'] = {['a'..'z']..'z'..'a'..'z'..'z'..'a'..'z'..'z'..'a'..'z'..'z'..'a'},\n\
    \    ['q'] = {['a'..'z']..'z'..'a'..'z'..'z'..'a'..'z'..'z'..'a'..'z'..'z'..'a'..'z'},\n\
    \    ['r'] = {['a'..'z']..'z'..'a'..'z'..'z'..'a'..'z'..'z'..", "\tlocal alphabet\
    \ = {\n\t\t['a'] = 'g',\n\t\t['b'] = 'f',\n\t\t['c'] = 'k',\n\t\t['d'] = 'j',\n\
    \t\t['e'] = 'i',\n\t\t['f'] = 'l',\n\t\t['g'] = 'e',\n\t\t['h'] = 't',\n\t\t['i']\
    \ = 'x',\n\t\t['j'] = 'q',\n\t\t['k'] = 'p',\n\t\t['l'] = 'o',\n\t\t['m'] = 'r',\n\
    \t\t['n'] = 's',\n\t\t['o'] = 'b',\n\t\t['p'] = 't',\n\t\t['q'] = 'u',\n\t\t['r']\
    \ = 'y',\n\t\t['s'] = 'h',\n\t\t['t'] = 'c',\n\t\t['u'] = 'v',\n\t\t['v'] = 'b',\n\
    \t\t['w'] = 'u',\n\t\t['x'] = 'n',\n\t\t['y'] = 'm',\n\t\t['z'] = 'r',\n\t\t['A']\
    \ = 'G',\n\t\t['B'] = 'F',\n\t\t['C'] = 'K',\n\t\t['D'] = 'J',\n\t\t['E'] = 'I',\n\
    \t\t['F'] = 'L',\n\t\t['G'] = 'E',\n\t\t['H'] = 'T',\n\t\t['I'] = 'X',\n\t\t['J']\
    \ = 'Q',\n\t\t['K'] = 'P',\n\t\t['L'] = 'O',\n\t\t['M'] = 'R',\n\t\t['N'] = 'S',\n\
    \t\t['O'] = 'B',\n\t\t['P'] = 'T',\n\t\t['Q'] = 'U',\n\t\t['R'] = 'Y',\n\t\t['S']\
    \ = 'H',\n\t\t['T'] = 'C',\n\t\t['U'] = 'V',\n\t\t['V'] = 'B',\n\t\t['W'] = 'U',\n\
    \t\t['X'] = 'N',\n\t\t['Y'] = 'M',\n\t\t['Z'] = 'R'\n\t}\n\t\n\tlocal result =\
    \ \"\"\n\tlocal currentLetter = ''\n\t\n\tfor i, c in ipairs(s) do\n\t\tcurrentLetter\
    \ = alphabet[c]\n\t\tresult = result .. currentLetter\n\tend\n\t\n\treturn result\n\
    end", "\t-- Initialize an encryption table with 26 letters \n\tlocal alpha = {}\n\
    \t-- Initialize the encryption table by adding each letter to its proper position\n\
    \tfor i = 1, 26 do\n\t\talpha[i] = string.sub(s, 1, i)\n\tend\n\t-- Add 'a' to\
    \ the beginning of alphabet\n\talpha[1] = string.sub(s, 2, 1)\n\t-- Iterate through\
    \ each letter in alphabet\n\tfor i = 2, #alpha do\n\t\talpha[i] = alpha[i] ..\
    \ alpha[i+1]\n\tend\n\t-- Add 'a' to the end of alphabet\n\talpha[#alpha] = string.sub(s,\
    \ 1, 1)\n\t-- Iterate through each letter in alphabet\n\tfor i = 1, #alpha do\n\
    \t\talpha[i] = alpha[i] .. alpha[i-1]\n\tend\n\t-- Return encryption table\n\t\
    return alpha\nend", "  local alphabet = {\n    ['a'] = {\n      ['w'] = 'h',\n\
    \      ['r'] = 'm',\n      ['t'] = 'n',\n      ['y'] = 'j',\n      ['d'] = 'k'\n\
    \    },\n    ['b'] = {\n      ['a'] = 'l',\n      ['z'] = 'm',\n      ['g'] =\
    \ 'n',\n      ['f'] = 'j',\n      ['e'] = 'k'\n    },\n    ['c'] = {\n      ['b']\
    \ = 'l',\n      ['k'] = 'm',\n      ['f'] = 'n',\n      ['h'] = 'j',\n      ['e']\
    \ = 'k'\n    },\n    ['d'] = {\n      ['c'] = 'l',\n      ['q'] = 'm',\n     \
    \ ['h'] = 'n',\n      ['e'] = 'j',\n      ['f'] = 'k'\n    },\n    ['e'] = {\n\
    \      ['d'] = 'l',\n      ['q'] = 'm',\n      ['h'] = 'n',\n      ['c'] = 'j',\n\
    \      ['f'] = 'k'\n    },\n    ['f'] = {\n      ['e'] = 'l',\n      ['t'] = 'm',\n\
    \      ['i'] = 'n',\n      ['h'] = 'j',\n      ['c'] = 'k'\n    },\n    ['g']\
    \ = {\n      ['f'] = 'l',\n      ['i'] = 'm',\n      ['t'] = 'n',\n      ['y']\
    \ = 'j',\n      ['c'] = 'k'\n    },\n    ['h'] = {\n      ['g'] = 'l',\n     \
    \ ['i'] = 'm',\n      ['t'] = 'n',\n      ['y'] = 'j',\n      ['c'] = 'k'\n  \
    \  },\n    ['i'] = {\n      ['h'] = 'l',\n      ['t'] = 'm',\n      ['y'] = 'j',\n\
    \      ['c'] = 'k'\n    },\n    ['j'] = {\n      ['i'] = 'l',\n      ['y'] = 'm',\n\
    \      ['c'] = 'n',\n      ['f'] = 'j'\n    },\n    ['k'] = {\n      ['j'] = 'l',\n\
    \      ['c'] = 'm',\n      ['f'] = 'n',\n      ['e'] = 'k'\n    },\n    ['l']\
    \ = {\n      ['k'] = 'l',\n      ['f'] = 'm',\n      ['e'] = 'n',\n      ['d']\
    \ = 'k'\n    },\n    ['m'] = {\n      ['l'] = 'l',\n      ['f'] = 'm',\n     \
    \ ['e'] = 'n',\n      ['d'] = 'k'\n    },\n    ['n'] = {\n      ['m'] = 'l',\n\
    \      ['f'] = 'm',\n      ['e'] = 'n',", "   local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n   local n = #alphabet\n   local c\n   local l = #s\n   local e\n   local out\
    \ = {}\n   for i=1,l do\n      c = sub(s, i, i)\n      e = (n-1) * alphabet +\
    \ c\n      out[i] = e\n   end\n   return table.concat(out, \"\")\nend", "  return\
    \ string.gsub(s, 'a', 'z') - string.gsub(s, 'A', 'Z')\nend", "\tlocal newS = ''\n\
    \tfor _, c in ipairs(s) do \n\t\tnewS = newS..(string.sub(alphabet, \n\t\t\tstring.len(alphabet)\
    \ - string.len(s)+1+string.len(c)-2, \n\t\t\tstring.len(alphabet) - string.len(s)+2+string.len(c)))\
    \ \n\tend\n\treturn newS\nend", "    local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    local newalphabet = \"fghijklmnopqrstuvwxyzabcedghijkmnopqrstuvwxyz\"\n\
    \    local rotations = 2\n    \n    -- First, convert the string into a list of\
    \ characters and sort it from\n    -- lower to higher.\n    local function toAlphaSorted(s)\n\
    \        return string.gsub(s, \"([^\" .. alphabet .. \"]+)\", function(c) \n\
    \                return alphabet:sub(1, #alphabet) .. c \n        end)\n    end\n\
    \    \n    -- Now, go through the string, rotating each character two places.\n\
    \    local function rotate(s)\n        local result = s\n        \n        for\
    \ i = 1, #s do\n            -- Rotate the character two places.\n            local\
    \ char = alphabet:sub(i+1, 1)\n            \n            -- Swap the characters\
    \ if necessary.\n            if char == alphabet:sub(i-1, 1) then\n          \
    \      -- Swap the characters.\n                result = alphabet:sub(i-1, 1)\n\
    \                result = alphabet:sub(i+1, 1) .. result\n            end\n  \
    \      end\n        \n        return result\n    end\n    \n    -- Return the\
    \ encrypted string.\n    return toAlphaSorted(rotate(s))\nend", "    local c =\
    \ ''\n    for i = 1, #s do \n        c = (c + string.sub(s, i, i)..string.sub(s,\
    \ i+1, i+1))\n    end\n    return c\nend", "\tlocal e = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\tlocal t = \"\"\n\tfor i,v in pairs(s) do\n\t\tlocal e = e[string.find(e,v)]\n\
    \t\tt = t .. string.sub(v,1,1) .. e .. string.sub(v,2)\n\tend\n\treturn t\nend",
  "  if s ~= nil then\n    local alphabet = {}\n    alphabet[1] = string.char(tonumber(string.sub(s,1,1)))\n\
    \    alphabet[2] = string.char(tonumber(string.sub(s,2,2)))\n    alphabet[3] =\
    \ string.char(tonumber(string.sub(s,3,3)))\n    alphabet[4] = string.char(tonumber(string.sub(s,4,4)))\n\
    \    alphabet[5] = string.char(tonumber(string.sub(s,5,5)))\n    alphabet[6] =\
    \ string.char(tonumber(string.sub(s,6,6)))\n    alphabet[7] = string.char(tonumber(string.sub(s,7,7)))\n\
    \    alphabet[8] = string.char(tonumber(string.sub(s,8,8)))\n    alphabet[9] =\
    \ string.char(tonumber(string.sub(s,9,9)))\n    alphabet[10] = string.char(tonumber(string.sub(s,10,10)))\n\
    \    alphabet[11] = string.char(tonumber(string.sub(s,11,11)))\n    alphabet[12]\
    \ = string.char(tonumber(string.sub(s,12,12)))\n    alphabet[13] = string.char(tonumber(string.sub(s,13,13)))\n\
    \    alphabet[14] = string.char(tonumber(string.sub(s,14,14)))\n    alphabet[15]\
    \ = string.char(tonumber(string.sub(s,15,15)))\n    alphabet[16] = string.char(tonumber(string.sub(s,16,16)))\n\
    \    alphabet[17] = string.char(tonumber(string.sub(s,17,17)))\n    alphabet[18]\
    \ = string.char(tonumber(string.sub(s,18,18)))\n    alphabet[19] = string.char(tonumber(string.sub(s,19,19)))\n\
    \    alphabet[20] = string.char(tonumber(string.sub(s,20,20)))\n    alphabet[21]\
    \ = string.char(tonumber(string.sub(s,21,21)))\n    alphabet[22] = string.char(tonumber(string.sub(s,22,22)))\n\
    \    alphabet[23] = string.char(tonumber(string.sub(s,23,23)))\n    alphabet[24]\
    \ = string.char(tonumber(string.sub(s,24,24)))\n    alphabet[25] = string.char(tonumber(string.sub(s,25,25)))\n\
    \    alphabet[26] = string.char(tonumber(string.sub(s,26,26)))\n    alphabet[27]\
    \ = string.char(tonumber(string.sub(s,27,27)))\n    alphabet[28] = string.char(tonumber(string.sub(s,28,28)))\n\
    \    alphabet[29] = string.char(tonumber(string.sub(", "  local t = {}\n  for\
    \ i = #s, 1, -1 do\n    t[#t+1] = string.sub(s,i,i)\n  end\n  t = rotate(t, alphabet.len-1)\n\
    \  local alphabet = {}\n  for i = 1, alphabet.len do\n    alphabet[i] = string.sub(alphabet,i,i)\n\
    \  end\n  return table.concat(alphabet, \"\"):gsub('%a','%%a')..string.gsub(t,\
    \ '%%a', '%a')\nend", "    local alphabet = {\n       ['g'] = ['i','j','k','l','m'],\n\
    \       ['f'] = ['o','p','q','r','s'],\n       ['e'] = ['h','t','u','v','w'],\n\
    \       ['d'] = ['y','x','z'],\n       ['c'] = ['n','m'],\n       ['a'] = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','y','x','z'],\n\
    \       ['b'] = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','y','x','z'],\n\
    \       ['a'] = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','y','x','z'],\n\
    \       ['z'] = ['y','x','z'],\n       ['x'] = ['y','x','z'],\n       ['y'] =\
    \ ['y','x','z'],\n       ['z'] = ['y','x','z'],\n       ['z'] = ['y','x','z'],\n\
    \    }", "  -- Write code here.\n  \n  \n  return s\nend", "  -- Check for empty\
    \ string.\n  if s == nil then return nil end\n  -- Create a string that is the\
    \ length of the input string + 2.\n  local s2 = s..\"\"\n  -- Create a table that\
    \ maps the 26 letters of the alphabet to the letter\n  -- with the first letter\
    \ shifted two.\n  local rotated_alphabet = {}\n  for i = 65 , 90 do rotated_alphabet[i]\
    \ = string.char(i + 2) end\n  -- Perform the encryption operation and return the\
    \ result string.\n  return string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(s2,\n\
    \                                                                            \
    \                                            'a','b'),\n                     \
    \                                                                            \
    \                       'b','c'),\n                                          \
    \                                                                            \
    \  'c','d'),\n                                                               \
    \                                                         'd','e'),\n        \
    \                                                                            \
    \                                    'e','f'),\n                             \
    \                                                                            \
    \               'f','g'),\n                                                  \
    \                                                                      'g','h'),\n\
    \                                                                            \
    \                                            'h','i'),\n                     \
    \                                                                            \
    \                       'i','j'),\n                                          \
    \                                                                            \
    \  'j','k'),\n                                                               \
    \                                                         'k','l'),\n        \
    \                                                                            \
    \                                    'l','m'),\n                             \
    \                                                                            \
    \               'm','n'),\n                                                  \
    \                                                                      'n','o'),\n\
    \                                                                            \
    \                                            'o','p'),\n                     \
    \                                                                            \
    \                       'p','q'),\n                                          \
    \                                                                            \
    \  'q','r'),\n                                                               \
    \                                                         'r','s'),\n        \
    \                                                                            \
    \                                    's','t'),\n                             \
    \                                                                            \
    \               't','u'),\n                                                  \
    \                                                                      'u','v'),\n\
    \                                                                            \
    \                                            'v','w'),\n                     \
    \                                                                            \
    \                       'w','x'),\n                                          \
    \                                                                            \
    \  'x','y'),\n                                                               \
    \                                                         'y','z'),\n        \
    \                                                                            \
    \                                    'z','a')\nend", "    local alphabet = {}\n\
    \    alphabet[1] = 'a'\n    alphabet[2] = 'b'\n    alphabet[3] = 'c'\n    alphabet[4]\
    \ = 'd'\n    alphabet[5] = 'e'\n    alphabet[6] = 'f'\n    alphabet[7] = 'g'\n\
    \    alphabet[8] = 'h'\n    alphabet[9] = 'i'\n    alphabet[10] = 'j'\n    alphabet[11]\
    \ = 'k'\n    alphabet[12] = 'l'\n    alphabet[13] = 'm'\n    alphabet[14] = 'n'\n\
    \    alphabet[15] = 'o'\n    alphabet[16] = 'p'\n    alphabet[17] = 'q'\n    alphabet[18]\
    \ = 'r'\n    alphabet[19] = 's'\n    alphabet[20] = 't'\n    alphabet[21] = 'u'\n\
    \    alphabet[22] = 'v'\n    alphabet[23] = 'w'\n    alphabet[24] = 'x'\n    alphabet[25]\
    \ = 'y'\n    alphabet[26] = 'z'\n    alphabet[27] = 'A'\n    alphabet[28] = 'B'\n\
    \    alphabet[29] = 'C'\n    alphabet[30] = 'D'\n    alphabet[31] = 'E'\n    alphabet[32]\
    \ = 'F'\n    alphabet[33] = 'G'\n    alphabet[34] = 'H'\n    alphabet[35] = 'I'\n\
    \    alphabet[36] = 'J'\n    alphabet[37] = 'K'\n    alphabet[38] = 'L'\n    alphabet[39]\
    \ = 'M'\n    alphabet[40] = 'N'\n    alphabet[41] = 'O'\n    alphabet[42] = 'P'\n\
    \    alphabet[43] = 'Q'\n    alphabet[44] = 'R'\n    alphabet[45] = 'S'\n    alphabet[46]\
    \ = 'T'\n    alphabet[47] = 'U'\n    alphabet[48] = 'V'\n    alphabet[49] = 'W'\n\
    \    alphabet[50] = 'X'\n    alphabet[51] = 'Y'\n    alphabet[52] = 'Z'\n    alphabet[53]\
    \ = '0'\n    alphabet[54] = '1'\n    alphabet[55] = '2'\n    alphabet[56] = '3'\n\
    \    alphabet[57] = '4'\n    alphabet[58] = '5'\n    alphabet[59] = '6'\n    alphabet[60]\
    \ = '7'\n    alphabet[61] = '8'\n    alphabet[62] = '9'", "    -- Add 'A' to the\
    \ end to rotate the alphabet to 'Z'\n    s = s .. string.char('A')", "\t-- Convert\
    \ string to rotated alphabet. \n\t-- Also create a table of characters to shift\
    \ by two.\n\tlocal c = {}\n\tfor letter in string.gmatch(string.char(32), '%D+')\
    \ do \n\t\tc[letter] = letter + 2\n\tend", "  local alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  local encrypted = ''\n  for i = 1, #s do\n    -- Shift down the alphabet by\
    \ two and add the two characters at the \n    -- shifted position\n    encrypted\
    \ = encrypted .. alphabet:sub(#alphabet - 2 + i, #alphabet:sub(#alphabet - 2 +\
    \ i))\n  end\n  return encrypted\nend", "    -- Get the first letter in the alphabet\
    \ and shift it two positions down.\n    local alphabet = string.gsub(string.sub(alphabet,\
    \ 1, 1), '[aeiou]', '[bcdfghjiklmnopqrstuvwxyz]')\n    -- Get the rotated alphabet.\n\
    \    local rot = string.gsub(alphabet, '[bcdfghjiklmnopqrstuvwxyz]', '[aeiou]')\n\
    \    -- Shift the string.\n    local s = string.gsub(s, '[aeiou]', rot)\n    --\
    \ Return the result.\n    return s\nend", "  local alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  local alphabet2 = \"~!@#$%^&*()_+{}|:\\\"<>?/.,;-_+=~\"\n  local alphabet3\
    \ = \"~!@#$%^&*()_+{}|:\\\"<>?/.,;-_+=~:\"\n  local alphabet4 = \"~!@#$%^&*()_+{}|:\\\
    \"<>?/.,;-_+=~;\"\n  \n  -- TODO: Write more efficient code\n  local c = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  local d = string.gsub(c, \"A\", alphabet2)\n  d = string.gsub(d, \"B\", alphabet3)\n\
    \  d = string.gsub(d, \"C\", alphabet4)\n  d = string.gsub(d, \"D\", alphabet4)\n\
    \  d = string.gsub(d, \"E\", alphabet4)\n  d = string.gsub(d, \"F\", alphabet4)\n\
    \  d = string.gsub(d, \"G\", alphabet4)\n  d = string.gsub(d, \"H\", alphabet4)\n\
    \  d = string.gsub(d, \"I\", alphabet4)\n  d = string.gsub(d, \"J\", alphabet4)\n\
    \  d = string.gsub(d, \"K\", alphabet4)\n  d = string.gsub(d, \"L\", alphabet4)\n\
    \  d = string.gsub(d, \"M\", alphabet4)\n  d = string.gsub(d, \"N\", alphabet4)\n\
    \  d = string.gsub(d, \"O\", alphabet4)\n  d = string.gsub(d, \"P\", alphabet4)\n\
    \  d = string.gsub(d, \"Q\", alphabet4)\n  d = string.gsub(d, \"R\", alphabet4)\n\
    \  d = string.gsub(d, \"S\", alphabet4)\n  d = string.gsub(d, \"T\", alphabet4)\n\
    \  d = string.gsub(d, \"U\", alphabet4)\n  d = string.gsub(d, \"V\", alphabet4)\n\
    \  d = string.gsub(d, \"W\", alphabet4)\n  d = string.gsub(d, \"X\", alphabet4)\n\
    \  d = string.gsub(d, \"Y\", alphabet4)\n  d = string.gsub(d, \"Z\", alphabet4)\n\
    \  d = string.gsub(d, \"a\", alphabet)\n  d = string.gsub(d, \"b\", alphabet)\n\
    \  d = string.gsub(d, \"c\", alphabet)\n  d = string.gsub(d, \"d\", alphabet)\n\
    \  ", "   -- Create a string 'n' with length of #s + 2, initially filled with\
    \ \n   -- an empty string.\n   local n = \"\"\n   for i = 1, #s do\n      -- The\
    \ first character in the alphabet is 'a', so put a 'a' in \n      -- position\
    \ i.\n      n = n..\"a\"..i\n   end\n   -- Rotate the alphabet two places clockwise.\n\
    \   local alphabet = \"zyxwvutsrqponmlkjihgfedcba\"\n   local alpha = alphabet\n\
    \   local beta = alphabet\n   for j = #alpha, 1, -1 do\n      -- Shift the alphabet\
    \ one place to the left. \n      beta = beta..alpha[j-1]\n      -- Shift the alphabet\
    \ one place to the right. \n      alpha = alpha..alpha[j]\n   end\n   -- Return\
    \ a string of length #s + 2 that contains the original string \n   -- followed\
    \ by the encrypted string.\n   return n..beta\nend", "  -- First, find the alphabet\
    \ size.\n  local alphabet = {}\n  for c in string.gmatch(string.lower(s), '%c')\
    \ do table.insert(alphabet, string.char(c)) end\n  local alphabet_size = #alphabet\n\
    \  -- Create the shifted version of the alphabet.\n  local shifted_alphabet =\
    \ {}\n  for i = alphabet_size, 1, -1 do\n    for j = 0, 2, -1 do\n      table.insert(shifted_alphabet,\
    \ string.char(alphabet[i + j]))\n    end\n  end\n  -- The last letter of the alphabet\
    \ is the shifted version.\n  table.insert(shifted_alphabet, string.char(alphabet[alphabet_size\
    \ - 1]))\n  -- Now, go through the string and return the encrypted string.\n \
    \ return string.gsub(string.lower(s), '%s', function (c)\n    -- Find out what\
    \ letter the letter is in the alphabet and shift it.\n    local offset = 0\n \
    \   for i = 1, alphabet_size do\n      if string.lower(c) == alphabet[i] then\n\
    \        offset = i\n      end\n    end\n    return string.char(shifted_alphabet[alphabet_size\
    \ - offset + alphabet_size + 1])\n  end) \nend", "    return string.gsub(string.gsub(s,\
    \ '[%a]', function(c) return string.char((string.byte(c) + 2) % 26) end), '[%a]',\
    \ function(c) return string.char((string.byte(c) - 2) % 26) end)\nend", "  --\
    \ We need to convert everything to upper case in order for this \n  -- function\
    \ to operate on upper case strings. Since strings are immutable \n  -- this means\
    \ that we will need to make a new string.\n  local encrypted = string.gsub(string.upper(s),\
    \ string.reverse(alphabet), \n\t\tfunction(c) \n\t\t\treturn string.subc(alphabet,\
    \ string.sub(alphabet, \n\t\t\t\tstring.len()-string.len(c), string.len(c)))\n\
    \t\tend)\n\t-- Once we have our encrypted string, we simply need to wrap it in\
    \ \n\t-- upper case.\n\treturn string.upper(encrypted)\nend", "   local alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n   local result = ''\n   local length\n   if\
    \ s == nil or #s == 0 then return end\n   length = #s\n   if length < 2 then\n\
    \      return s\n   end\n   for i = 1, length do\n      result = result .. alphabet[(s:sub(i,i))\
    \ and alphabet[(s:sub(i,i)) - 1]]\n   end\n   return result\nend", "  local alphabet\
    \ = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"}\n  local encrypted = ''\n  local offset = 1\n\
    \  for i = 1, #s do\n    local current_char = alphabet[(offset + #alphabet) %\
    \ #alphabet]\n    encrypted = encrypted .. current_char\n    offset = offset +\
    \ 1\n  end\n  return encrypted\nend", "  -- We start by transforming the string\
    \ into a list of the characters. \n  -- For example, if the string is \"abcdef\"\
    , then 'abcd' = 'acbde'.\n  -- We do this by mapping each character in our string\
    \ to its\n  -- index number in the alphabet.\n  local a = {}\n  for i = 1, #s\
    \ do\n    table.insert(a, #alphabet[#alphabet] + 1)\n  end\n  -- We also have\
    \ a list of the indices of the characters in our alphabet.\n  -- For example,\
    \ if the alphabet is \"abcde\", then 'abc' = {1, 3, 5}. \n  -- We need this list\
    \ to make sure that our alphabets don't shift\n  -- out to different positions.\n\
    \  local b = {}\n  -- We also have a list for our output. Initially it contains\
    \ \"*\".\n  -- We want to rotate the output so that it starts with the same letter\n\
    \  -- the first time we encrypt the string.\n  local output = '*'\n  -- We also\
    \ keep a counter to keep track of when we're ready to rotate our alphabet.\n \
    \ local shift = 0\n  -- For each character in the string, we map it to the index\
    \ in the alphabet.\n  -- If the character is less than or equal to '~' (a letter),\
    \ then we add it to the output.\n  -- Otherwise, we rotate the output by one place.\
    \ We do this by finding the place\n  -- to put the character in the alphabet.\
    \ Then we map the character back to its\n  -- index number. Then we rotate the\
    \ alphabet by 2 places, and move to the next \n  -- character.\n  for i = 1, #s\
    \ do\n    -- If the character is less than or equal to '~', then we add it to\
    \ the output.\n    if s[i] <= '~' then\n      output = output .. alphabet[a[s[i]]]\n\
    \    -- Otherwise, we rotate the output by one place.\n    else\n      -- Find\
    \ the index to put the character in our alphabet.\n      local place = #alphabet\n\
    \      for j = #alphabet, #alphabet-1 do\n        if alphabet[j] == alphabet[j]\
    \ then\n          place = j\n          break\n        end\n      end\n      --\
    \ Shift the alphabet by two.\n      alphabet[#alphabet] = alphabet[#alphabet]\
    \ + 1\n      -- Map back to its index number.\n      a[s[i]] = #alphabet\n   \
    \   -- Shift the alphabet by two more places.\n      alphabet[#alphabet] = alphabet[#alphabet]\
    \ - 2\n      -- Move to the next character.\n      i = i + 1\n    end\n  end\n\
    \  -- Return the output.\n  return output\nend", "  local alphabet = {\n    'a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n    'n', 'o', 'p',\
    \ 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n  }\n  local ret = \"\"\n\
    \  for i = 1, #s do\n    -- Shift down all letters by two. Add two so that we\
    \ only need to \n    -- subtract 1 from the next letter when rotating.\n    ret\
    \ = ret + alphabet[#alphabet] - #alphabet\n    -- Subtract one from the current\
    \ letter since letters shift down two\n    -- each time we encrypt a letter.\n\
    \    ret = ret + alphabet[s:sub(i,i)-1]\n  end\n  return ret\nend", "  local encrypted\
    \ = ''\n  for c in s:gmatch('[a-zA-Z]') do\n    encrypted = encrypted .. string.sub(c,\
    \ 1, 1) .. string.sub(c, 2, 2) .. string.sub(c, 3, 3) .. string.sub(c, 4, 4) ..\
    \ string.sub(c, 5, 5)\n  end\n  return encrypted\nend", "    local t = {}\n  \
    \  for c = 1, #s do\n        local n = tolower(s[c])\n        if n == 'a' or n\
    \ == 'z' then\n            table.insert(t, tolower(string.sub(alphabet, 1, #alphabet\
    \ - 2)))\n        elseif n == 'b' or n == 'y' then\n            table.insert(t,\
    \ string.sub(alphabet, #alphabet, #alphabet-1))\n        end\n    end\n    table.insert(t,\
    \ alphabet[1])\n    return table.concat(t, \"\")\nend", "  local alphabet = \"\
    abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  local result = \"\"\n\
    \  for i=1,#s do\n    local char = alphabet:sub(i,i)\n    local shift = (#char\
    \ - 1) * 2\n    local new_char = alphabet:sub(shift, shift)\n    result = result\
    \ .. new_char\n  end\n  return result\nend", "\t-- Rotate the alphabet by 2 twice\
    \ per pass\n\tlocal alphabet = string.gsub(string.lower(s), '[a-z]', function(x)\n\
    \t\tlocal y = string.sub(x, 1, 2)\n\t\treturn string.format('%s%s', y, y)\n\t\
    end)\n\t\n\t-- Create two variables to store the old and new string values\n\t\
    local old = ''\n\tlocal new = ''\n\t\n\t-- For each letter in the encrypted string...\n\
    \tfor letter = 1, #s do\n\t\t-- ...if the letter equals a lowercase letter ...\n\
    \t\tif string.sub(alphabet, letter, letter) == letter then\n\t\t\t-- ...add an\
    \ uppercase letter that rotates the alphabet by 2 places\n\t\t\tnew = string.sub(alphabet,\
    \ letter, letter) + string.sub(alphabet, letter, letter) + string.sub(alphabet,\
    \ letter, letter)\n\t\telse\n\t\t\t-- ...add a letter that rotates the alphabet\
    \ by 1 place\n\t\t\tnew = string.sub(alphabet, letter, letter) + string.sub(alphabet,\
    \ letter, letter) + string.sub(alphabet, letter, letter)\n\t\tend\n\t\t\n\t\t\
    -- If the old and new strings are the same, then the string has been rotated\n\
    \t\tif old == new then\n\t\t\t-- ... return the new string\n\t\t\treturn new\n\
    \t\tend\n\t\t\n\t\t-- Set the old and new strings equal to the new string\n\t\t\
    old = new\n\tend\n\t\n\t-- The string hasn't been rotated yet\n\treturn s\nend",
  "    -- Initialize our variable to an empty string.\n    local encrypted = ''\n\
    \    \n    -- Loop through each letter in our string.\n    for i=1, #s, 1 do\n\
    \        -- If the letter isn't in the alphabet, add it to the encrypted string.\n\
    \        if alphabet[i] ~= s[i] then\n            encrypted = encrypted .. alphabet[i]\n\
    \        end\n        -- If the letter is in the alphabet, add it to the encrypted\
    \ string with two less letters.\n        else \n            encrypted = encrypted\
    \ .. alphabet[i]\n            encrypted = encrypted .. alphabet[i+1]\n       \
    \ end\n    end\n    -- Return the encrypted string.\n    return encrypted\nend",
  "  -- Your code goes here:\n  local c = {\n    ['f'] = string.char('f'),\n    ['g']\
    \ = string.char('g'),\n    ['h'] = string.char('h'),\n    ['i'] = string.char('i'),\n\
    \    ['j'] = string.char('j'),\n    ['k'] = string.char('k'),\n    ['l'] = string.char('l'),\n\
    \    ['m'] = string.char('m'),\n    ['n'] = string.char('n'),\n    ['o'] = string.char('o'),\n\
    \    ['p'] = string.char('p'),\n    ['q'] = string.char('q'),\n    ['r'] = string.char('r'),\n\
    \    ['s'] = string.char('s'),\n    ['t'] = string.char('t'),\n    ['u'] = string.char('u'),\n\
    \    ['v'] = string.char('v'),\n    ['w'] = string.char('w'),\n    ['x'] = string.char('x'),\n\
    \    ['y'] = string.char('y'),\n    ['z'] = string.char('z'),\n  }\n  \n  local\
    \ e = ''\n  for _, v in ipairs(s) do\n    if string.byte(c[v]) < string.byte(c[v\
    \ + 2]) then\n      e = e .. c[v]\n    else\n      e = e .. c[v + 2]\n    end\n\
    \  end\n  return e\nend", "\tlocal alphabet = {\n\t\t['a'] = 'k'\n\t\t['b'] =\
    \ 'm'\n\t\t['c'] = 'n'\n\t\t['d'] = 'o'\n\t\t['e'] = 'p'\n\t\t['f'] = 'q'\n\t\t\
    ['g'] = 'r'\n\t\t['h'] = 's'\n\t\t['i'] = 't'\n\t\t['j'] = 'u'\n\t\t['k'] = 'v'\n\
    \t\t['l'] = 'w'\n\t\t['m'] = 'x'\n\t\t['n'] = 'y'\n\t\t['o'] = 'z'\n\t\t['p']\
    \ = 'a' \n\t\t['q'] = 'b' \n\t\t['r'] = 'c' \n\t\t['s'] = 'd' \n\t\t['t'] = 'e'\
    \ \n\t\t['u'] = 'f' \n\t\t['v'] = 'g' \n\t\t['w'] = 'h' \n\t\t['x'] = 'i' \n\t\
    \t['y'] = 'j' \n\t\t['z'] = 'k' \n\t}\n\t\n\t-- Shift up each letter by two \n\
    \t-- >>> encrypt('hi')\n\t-- >>> encrypt('asdfghjkl')\n\t-- >>> encrypt('gf')\n\
    \t-- >>> encrypt('et')\n\t-- >>> encrypt('aeiou')\n\t-- >>> encrypt('qwerty')\n\
    \t-- >>> encrypt('zxcvbnm')\n\t-- >>> encrypt('v')\n\t-- >>> encrypt('z')\n\t\
    -- >>> encrypt('')\n\t-- >>> encrypt('aa')\n\t-- >>> encrypt('abcde')\n\t-- >>>\
    \ encrypt('bcde')\n\t-- >>> encrypt('cde')\n\t-- >>> encrypt('de')\n\t-- >>> encrypt('')\n\
    \t-- >>> encrypt('abcde')\n\t-- >>> encrypt('bcde')\n\t-- >>> encrypt('cde')\n\
    \t-- >>> encrypt('de')\n\t-- >>> encrypt('')\n\t-- >>> encrypt('aa')\n\t-- >>>\
    \ encrypt('abcde')\n\t-- >>> encrypt('bcde')\n\t-- >>> encrypt('cde')\n\t-- >>>\
    \ encrypt('de')\n\t-- >>> encrypt('')\n\t-- >>> encrypt('abcde')\n\t-- >>> encrypt('bcde')\n\
    \t-- >>> encrypt('cde')\n\t-- >>> encrypt('de')\n\t-- >>> encrypt('')\n\t-- >>>\
    \ encrypt('aa')\n\t-- >>> encrypt('abcde')\n\t-- >>> encrypt('bcde')\n\t-- >>>\
    \ encrypt('cde')\n\t-- >>> encrypt('de')\n\t-- >>> encrypt('')\n\t-- ", "\t--\
    \ Find the length of the alphabet. \n\tlocal alph_len = #alphabet\n\t-- Create\
    \ a table containing the values of the letters of the alphabet in alphabetical\
    \ order. \n\tlocal alphabet = {}\n\tfor i = 1, alph_len do\n\t\talphabet[i] =\
    \ alphabet[#alphabet] + 1\n\tend\n\t-- Create a variable that holds the encrypted\
    \ string by iterating through the string one letter at a time. \n\tlocal encrypted\
    \ = ''\n\t-- Iterate through each letter in the string and place it into encrypted.\
    \ \n\tfor _, char in string.gmatch(s, '%a') do\n\t\t-- Multiply the value on the\
    \ left of the alphabet by two. \n\t\tlocal next_alpha = alphabet[char] - alphabet[alphabet[char]]\
    \ * 2\n\t\t-- Replace the letter on the left of the alphabet with the letter on\
    \ the right of the alphabet shifted down by two. \n\t\tencrypted = encrypted ..\
    \ alphabet[alphabet[char]] = alphabet[next_alpha]\n\tend\n\treturn encrypted\n\
    end", "\tlocal rotated_alphabet = string.gsub(alphabet, \n\t\t\t\t\t\t   function(a)\
    \ return string.sub(alphabet, #alphabet) + alphabet[(string.sub(alphabet, #alphabet)\
    \ - 2)] end, '')\n\treturn string.gsub(rotated_alphabet, \n\t\t\t\t\t\t   function(a)\
    \ return string.sub(rotated_alphabet, #rotated_alphabet) + alphabet[(string.sub(rotated_alphabet,\
    \ #rotated_alphabet) - 2)] end, '')\nend", "    -- We will use an external alphabet\
    \ to encode our string.\n    local alphabet = {\n            ['a'] = 'f', 'b':\
    \ 'h', 'c': 'i', 'd': 'j', \n            'e': 'k', 'f': 'l', 'h': 'm', 'i': 'l',\
    \ \n            'j': 'n', 'l': 'o', 'm': 'o', 'n': 'p', \n            'o': 'q',\
    \ 'p': 'r', 'q': 's', 'r': 't', \n            's': 'u', 't': 'v', 'u': 'w', 'v':\
    \ 'x', \n            'w': 'z', 'x': 'y', 'y': 'z', 'z': 'a'}\n    -- We will use\
    \ a hash to encode our string, and we will use \n    -- a hash function with a\
    \ smaller alphabet to get a small \n    -- bit more compression. \n    -- This\
    \ is done to reduce the number of bits that must be \n    -- considered. \n  \
    \  local hash = require(\"hash\")\n    -- We will use an external alphabet to\
    \ encode our string.\n    local alphabet2 = {\n            ['a'] = 'z', 'b': 'y',\
    \ 'c': 'x', 'd': 'z', \n            'e': 'y', 'f': 'x', 'h': 'x', 'i': 'x', \n\
    \            'j': 'z', 'l': 'y', 'm': 'y', 'n': 'x', \n            'o': 'x', 'p':\
    \ 'x', 'q': 'x', 'r': 'y', \n            's': 'y', 't': 'x', 'u': 'y', 'v': 'x',\
    \ \n            'w': 'z', 'x': 'z', 'y': 'z', 'z': 'a'}\n    -- We will use a\
    \ hash to encode our string, and we will use \n    -- a hash function with a smaller\
    \ alphabet to get a small \n    -- bit more compression. \n    -- This is done\
    \ to reduce the number of bits that must be \n    -- considered. \n    local hash2\
    \ = require(\"hash\")\n    -- Create a function encrypt that takes a string as\
    \ an argument and\n    -- returns a string encrypted with the alphabet being rotated.\
    \ \n    -- The alphabet should be rotated in a manner such that the letters \n\
    \    -- shift down by two multiplied to two places.\n    -- For example:\n   \
    \ -- >>> encrypt('hi')\n    -- 'lm'\n    -- >>> encrypt('asdfghjkl')\n    -- 'ewhjklnop'\n\
    \    -- >>> encrypt('gf')\n    -- 'kj'\n    -- >>> encrypt('et')\n    -- 'ix'\n\
    \    return hash2(s) .. alphabet2[hash(hash(s))]\nend", "  -- Return the encrypted\
    \ string if no argument is given.\n  if #s == 0 then return '' end\n  -- Initialize\
    \ result to an empty string.\n  local result = \"\"\n  -- Initialize counter to\
    \ 0.\n  local counter = 0\n  -- While there are characters in the given string.\n\
    \  while counter < #s do\n    -- If the current character is a letter, add a letter\
    \ to the result \n    -- (shifting down 2 letters at a time) and increment the\
    \ counter.\n    if s[counter] ~= 'a' and s[counter] ~= 'b' and s[counter] ~= 'c'\
    \ and s[counter] ~= 'd' and s[counter] ~= 'e' and s[counter] ~= 'f' and s[counter]\
    \ ~= 'g' and s[counter] ~= 'h' and s[counter] ~= 'i' and s[counter] ~= 'j' and\
    \ s[counter] ~= 'k' and s[counter] ~= 'l' and s[counter] ~= 'm' and s[counter]\
    \ ~= 'n' and s[counter] ~= 'o' and s[counter] ~= 'p' and s[counter] ~= 'q' and\
    \ s[counter] ~= 'r' and s[counter] ~= 's' and s[counter] ~= 't' and s[counter]\
    \ ~= 'u' and s[counter] ~= 'v' and s[counter] ~= 'w' and s[counter] ~= 'x' and\
    \ s[counter] ~= 'y' and s[counter] ~= 'z' then\n      result = result .. string.sub(s,counter,counter)\
    \ .. string.sub(s,counter+1,counter+1)\n      counter = counter + 2\n    end\n\
    \    -- If the current character is not a letter, increment the counter.\n   \
    \ else counter = counter + 1\n    end\n  -- Return the result.\n  return result\n\
    end", "    local cipher = ''\n    for i = #s, 1, -1 do\n        cipher = cipher\
    \ .. string.sub(alphabet, math.mod(#alphabet, #s))\n        alphabet = alphabet:sub(1,\
    \ #alphabet-1)\n    end\n    return cipher\nend", "    -- The empty string should\
    \ return the empty string\n    if s == '' then\n        return ''\n    end\n \
    \   -- Convert the string to lowercase\n    local lower = s:lower()\n    -- Loop\
    \ through each letter of the alphabet\n    for i = #alphabet, 2, -1 do\n     \
    \   -- Shift the letters down by two multiplied by two and then add \n       \
    \ -- the letter to the encrypted string\n        lower = lower .. alphabet[(#alphabet)\
    \ * (i - 2)] .. alphabet[(i - 1)]\n    end\n    -- Return the encrypted string\n\
    \    return lower\nend", "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local letters = {}", "    -- first rotate the letters to the left\n    local\
    \ firstShift = 1\n    local firstChar = s[1]\n    local lastChar = s[#s]\n   \
    \ while firstChar ~= lastChar and firstChar ~= 'z' do\n        firstShift = firstShift\
    \ * 2\n        firstChar = s[firstShift]\n    end\n    -- now rotate the letters\n\
    \    local secondShift = 1\n    while firstChar ~= lastChar do\n        secondShift\
    \ = secondShift * 2\n        s[secondShift] = s[firstShift]\n        firstShift\
    \ = firstShift * 2\n        firstChar = s[firstShift]\n    end\n    -- return\
    \ the string \n    return s\nend", "    -- First, convert the letters in s to\
    \ lower case letters.\n    local str = \"\"\n    for i = 1, #s do\n        str\
    \ = str .. tolower(s[i])\n    end\n    \n    -- Now create a dictionary to keep\
    \ track of the letters \n    -- that have been seen for the encrypted string.\n\
    \    -- We initialize this dictionary with the letters from s \n    -- and then\
    \ add the letters from the alphabet rotated \n    -- to it (shifting them down\
    \ by 2).\n    local alpha = {}\n    for i = 1, #s do\n        alpha[tolower(s[i])]\
    \ = true\n    end\n    for i = #alpha, 1, -1 do\n        alpha[tolower(tostring(i\
    \ - 2))] = true\n    end\n    \n    -- Now go through the string and replace letters\
    \ once with \n    -- letters from the alphabet shifted down by two.\n    local\
    \ str2 = \"\"\n    for i = 1, #str do\n        str2 = str2 .. tostring(alpha[str[i]])\n\
    \    end\n    return str2\nend", "  local alphabet = { 'a', 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z' }\n  local len = #alphabet\n  local i, k = 0\n  local\
    \ output = ''\n  for i = 1, len do\n    output = (string.sub(s,i,i+1))\n    for\
    \ k = 0, 3 do\n      local j = ((k + 2) % len) + i\n      output = (alphabet[output]\
    \ .. alphabet[j])\n    end\n    output = alphabet[output]\n    output = output..output\n\
    \  end\n  return output\nend", "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  local rotated_alphabet = alphabet:sub(1,1) + alphabet:sub(3,3) .. alphabet:sub(-4,-5)\n\
    \  \n  local new_alphabet\n  \n  for i = 1,#s do\n    local pos = math.random(#alphabet)\n\
    \    new_alphabet = alphabet:sub(1,pos)\n    new_alphabet = alphabet:sub(pos,pos+1)\
    \ + alphabet:sub(pos+1,pos+1) + new_alphabet\n    \n    if #new_alphabet < #rotated_alphabet\
    \ then\n      new_alphabet = rotated_alphabet:sub(1,#rotated_alphabet)\n    end\n\
    \    \n    new_alphabet = alphabet:sub(1,pos) + new_alphabet\n    new_alphabet\
    \ = alphabet:sub(pos+1,pos+1) + new_alphabet\n  end\n  \n  return new_alphabet:sub(1,#new_alphabet)\n\
    end", "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    local alphabetLen\
    \ = #alphabet\n    local sLen = #s\n    local newS = newSymbols(sLen)\n    for\
    \ i = 1, sLen do\n        newS[i] = alphabet[alphabetLen - 2 - alphabet:sub(i\
    \ , i+1):byte()]\n    end\n    return newS\nend", "    local str = ''\n    for\
    \ i = 1, #s do\n        str  = str .. alphabet[#alphabet - i + 2]\n    end\n \
    \   return str\nend", "  local result = '' -- Initialize an empty string\n  local\
    \ i = 0 -- Initialize an index variable\n  while s[i] do -- Repeat the following\
    \ statement while s[i] contains something\n    result = result .. string.sub(alphabet,\
    \ math.random(), math.random()) .. string.sub(alphabet, math.random()+1, math.random()+1)\n\
    \    i = i+1\n  end\n  return result\nend", "   -- TODO: Insert your code here.\n\
    end\n</code>\nStep 4: Use that function in the main function.\n<code>", "  --\
    \ Convert each letter in the string to its ASCII value\n  -- and shift it down\
    \ by two multiplied to two places.\n  s = string.lower(s)\n  local new = ''\n\
    \  for i = 1, #s do\n    local ascii = string.byte(s,i)\n    local shift = (ascii\
    \ * 2) >> 1\n    local char = string.sub(s,i,i)\n    -- Encrypt the letter\n \
    \   if char >= 'a' and char <= 'z' then\n      char = string.char(alphabet_table[char\
    \ + shift])\n    end\n    -- Append the encrypted character\n    new .. char\n\
    \  end\n  return new\nend", "    local result = ''\n    local alpha = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    -- Rotate the alphabet two characters at a time.\n    for i = 1, #s, 2 do\n\
    \        local alpha = alpha + alpha\n        local j = 1\n        while i <=\
    \ #s do\n            j = j + 2\n            local tmp = (s:sub(i, i + 1))\n  \
    \          local char = alpha:sub(i, i + j)\n            i = i + 1\n         \
    \   -- If the letter is the same as the next letter, skip it.\n            if\
    \ char == tmp then\n                i = i + 1\n                -- If the letter\
    \ is the same as the previous letter, skip it.\n                if char == alpha:sub(i,\
    \ i - 1) then\n                    i = i + 1\n                end\n          \
    \  end\n            -- If the letter is not in the alphabet, put it in the result\
    \ string.\n            if char ~= tmp then\n                result = result ..\
    \ char\n            end\n        end\n    end\n    return result\nend", "  local\
    \ alphabet = {}\n  alphabet[1] = 'a'\n  alphabet[2] = 'b'\n  alphabet[3] = 'c'\n\
    \  alphabet[4] = 'd'\n  alphabet[5] = 'e'\n  alphabet[6] = 'f'\n  alphabet[7]\
    \ = 'g'\n  alphabet[8] = 'h'\n  alphabet[9] = 'i'\n  alphabet[10] = 'j'\n  alphabet[11]\
    \ = 'k'\n  alphabet[12] = 'l'\n  alphabet[13] = 'm'\n  alphabet[14] = 'n'\n  alphabet[15]\
    \ = 'o'\n  alphabet[16] = 'p'\n  alphabet[17] = 'q'\n  alphabet[18] = 'r'\n  alphabet[19]\
    \ = 's'\n  alphabet[20] = 't'\n  alphabet[21] = 'u'\n  alphabet[22] = 'v'\n  alphabet[23]\
    \ = 'w'\n  alphabet[24] = 'x'\n  alphabet[25] = 'y'\n  alphabet[26] = 'z'", " \
    \ local alphabet = string.chars(string.len(s)) \n  alphabet = alphabet..'z'\n\
    \  alphabet = alphabet..'y'\n  alphabet = alphabet..'x'\n  alphabet = alphabet..'w'\n\
    \  alphabet = alphabet..'v'\n  alphabet = alphabet..'u'\n  alphabet = alphabet..'t'\n\
    \  alphabet = alphabet..'s'\n  alphabet = alphabet..'r'\n  alphabet = alphabet..'q'\n\
    \  alphabet = alphabet..'p'\n  alphabet = alphabet..'o'\n  alphabet = alphabet..'n'\n\
    \  alphabet = alphabet..'m'\n  alphabet = alphabet..'l'\n  alphabet = alphabet..'k'\n\
    \  alphabet = alphabet..'j'\n  alphabet = alphabet..'h'\n  alphabet = alphabet..'g'\n\
    \  alphabet = alphabet..'f'\n  alphabet = alphabet..'e'\n  alphabet = alphabet..'d'\n\
    \  alphabet = alphabet..'c'\n  alphabet = alphabet..'b'\n  alphabet = alphabet..'a'\n\
    \  alphabet = alphabet..'z'\n  alphabet = alphabet..'y'\n  alphabet = alphabet..'x'\n\
    \  alphabet = alphabet..'w'\n  alphabet = alphabet..'v'\n  alphabet = alphabet..'u'\n\
    \  alphabet = alphabet..'t'\n  alphabet = alphabet..'s'\n  alphabet = alphabet..'r'\n\
    \  alphabet = alphabet..'q'\n  alphabet = alphabet..'p'\n  alphabet = alphabet..'o'\n\
    \  alphabet = alphabet..'n'\n  alphabet = alphabet..'m'\n  alphabet = alphabet..'l'\n\
    \  alphabet = alphabet..'k'\n  alphabet = alphabet..'j'\n  alphabet = alphabet..'h'\n\
    \  alphabet = alphabet..'g'\n  alphabet = alphabet..'f'\n  alphabet = alphabet..'e'\n\
    \  alphabet = alphabet..'d'\n  alphabet = alphabet..'c'\n  alphabet = alphabet..'b'\n\
    \  alphabet = alphabet..'a'\n  alphabet = alphabet..'z'\n  alphabet = alphabet..'y'\n\
    \  alphabet = alphabet..'x'\n  alphabet = alphabet..'w'\n  alphabet = alphabet..'v'\n\
    \  alphabet = alphabet..'u'\n  alphabet = alphabet..'t'\n  alphabet = alphabet..'s'\n\
    \  alphabet = alphabet..'", "    local alphabet = {\n        ['a'] = 'a','b','c','d','e','f','g','h','i','j',\n\
    \        ['k'] = 'k','l','m','n','o','p','q','r','s','t','u','v',\n        ['w']\
    \ = 'w','x','y','z'\n    }\n    local letters = {}\n    local key = 1\n    local\
    \ index = 1\n    for i = 1, #s do\n        letters[index] = alphabet[key][alphabet.find(s[i],'a',0,0)]\n\
    \        key = key + 1\n        index = index + 1\n    end\n    return table.concat(letters)\n\
    end", "  -- First, shift each letter in the string one place to the right\n  --\
    \ by 1 letter\n  for i = 0, #s do\n    local char = string.sub(s,i,i)\n    local\
    \ next_char = string.sub(s,i,i+1)\n    \n    -- Shift each letter down by 2 to\
    \ the power of the position of the letter on the alphabet\n    local pos_char\
    \ = string.sub('abcdefghijklmnopqrstuvwxyz',char,char,1)\n    local pos_next_char\
    \ = string.sub('abcdefghijklmnopqrstuvwxyz',next_char,next_char,1)\n    \n   \
    \ local new_pos = string.sub(alphabet,pos_char,pos_char,2)\n    local new_next_pos\
    \ = string.sub(alphabet,pos_next_char,pos_next_char,2)\n    \n    -- Add the character\n\
    \    local char = string.sub(s,i,i)\n    local new_char = string.sub(alphabet,new_pos,new_pos,2)\n\
    \    local new_next_char = string.sub(alphabet,new_next_pos,new_next_pos,2)\n\
    \    \n    local new_string = string.sub(s,i,i-1)\n    new_string = string.sub(new_string,0,i-1)\
    \ + new_char + new_next_char + string.sub(new_string,i+1,#s)\n    s = new_string\n\
    \  end\n  -- Then, shift the rest of the string one place to the right\n  for\
    \ i = #s, 1, -1 do\n    local char = string.sub(s,i,i)\n    local next_char =\
    \ string.sub(s,i,i+1)\n    \n    -- Shift each letter down by 2 to the power of\
    \ the position of the letter on the alphabet\n    local pos_char = string.sub('abcdefghijklmnopqrstuvwxyz',char,char,1)\n\
    \    local pos_next_char = string.sub('abcdefghijklmnopqrstuvwxyz',next_char,next_char,1)\n\
    \    \n    local new_pos = string.sub(alphabet,pos_char,pos_char,2)\n    local\
    \ new_next_pos = string.sub(alphabet,pos_next_char,pos_next_char,2)\n    \n  \
    \  -- Add the character\n    local char = string.sub(s,i,i)\n    local new_char\
    \ = string.sub(alphabet,new_pos,new_pos,2)\n    local new_next_char = string.sub(alphabet,new_next_pos,new_next_pos,2)\n\
    \    \n    local new_string = string.sub(s,i,i-1)\n    new_string = string.sub(new_string,0,i-1)\
    \ + new_char + new_next_char + string.sub(new_string,i+1,#s)\n    s = new_string\n\
    \  end\n  return s\nend", "\t-- The variable s is given as a parameter and is\
    \ \n\t-- passed in as a string.\n\t-- Return the encrypted string with the alphabet\
    \ rotated\n\t-- twice.\n\t-- For example, if the string is 'gf' the result will\
    \ be\n\t-- 'kj'.\n\treturn string.gsub(string.gsub(s, 'a', 'z'), 'a', 'x') \n\t\
    \t.. string.gsub(string.gsub(s, 'b', 'z'), 'b', 'x')\n\t\t.. string.gsub(string.gsub(s,\
    \ 'c', 'z'), 'c', 'x')\n\t\t.. string.gsub(string.gsub(s, 'd', 'z'), 'd', 'x')\n\
    \t\t.. string.gsub(string.gsub(s, 'e', 'z'), 'e', 'x')\n\t\t.. string.gsub(string.gsub(s,\
    \ 'f', 'z'), 'f', 'x')\n\t\t.. string.gsub(string.gsub(s, 'g', 'z'), 'g', 'x')\n\
    \t\t.. string.gsub(string.gsub(s, 'h', 'z'), 'h', 'x')\n\t\t.. string.gsub(string.gsub(s,\
    \ 'i', 'z'), 'i', 'x')\n\t\t.. string.gsub(string.gsub(s, 'j', 'z'), 'j', 'x')\n\
    \t\t.. string.gsub(string.gsub(s, 'k', 'z'), 'k', 'x')\n\t\t.. string.gsub(string.gsub(s,\
    \ 'l', 'z'), 'l', 'x')\n\t\t.. string.gsub(string.gsub(s, 'm', 'z'), 'm', 'x')\n\
    \t\t.. string.gsub(string.gsub(s, 'n', 'z'), 'n', 'x')\n\t\t.. string.gsub(string.gsub(s,\
    \ 'o', 'z'), 'o', 'x')\n\t\t.. string.gsub(string.gsub(s, 'p', 'z'), 'p', 'x')\n\
    \t\t.. string.gsub(string.gsub(s, 'q', 'z'), 'q', 'x')\n\t\t.. string.gsub(string.gsub(s,\
    \ 'r', 'z'), 'r', 'x')\n\t\t.. string.gsub(string.gsub(s, 's', 'z'), 's', 'x')\n\
    \t\t.. string.gsub(string.gsub(s, 't', 'z'), 't', 'x')\n\t\t.. string.gsub(string.gsub(s,\
    \ 'u', 'z'), 'u', 'x')\n\t\t.. string.gsub(string.gsub(s, 'v', 'z'), 'v', 'x')\n\
    \t\t.. string.gsub(string.gsub(s, 'w', 'z'), 'w', 'x')\n\t\t.. string.gsub(string.gsub(s,\
    \ 'x', 'z'), 'x', 'x')\n\t\t.. string.gsub(string.gsub(s, 'y', 'z'), 'y', 'x')\n\
    \t\t.. string.gsub(string.gsub(s, 'z', 'z'), 'z', 'x')\nend", "  local encrypted\
    \ = \"\"\n  for i = #s, 1, -1 do\n    local char = string.sub(s,i,i)\n    encrypted\
    \ = string.sub(alphabet.(string.sub(alphabet, #alphabet, #alphabet)+2),\n    \
    \                         #alphabet, #alphabet) ..\n                char\n  end\n\
    \  return encrypted\nend", "  -- Initialize empty return value.\n  local result\
    \ = ''", "  -- Create a variable called alphabet that is an array containing \n\
    \  -- the alphabet to be rotated and another variable called s that\n  -- contains\
    \ the string to be encrypted.\n  local alphabet = {\n    ['a'] = 26,  ['b'] =\
    \ 27,  ['c'] = 28,  ['d'] = 29,  ['e'] = 30,\n    ['f'] = 31,  ['g'] = 28,  ['h']\
    \ = 29,  ['i'] = 30,  ['j'] = 31,\n    ['k'] = 27,  ['l'] = 30,  ['m'] = 27, \
    \ ['n'] = 28,  ['o'] = 31,\n    ['p'] = 30,  ['q'] = 27,  ['r'] = 30,  ['s'] =\
    \ 27,  ['t'] = 31,\n    ['u'] = 28,  ['v'] = 27,  ['w'] = 30,  ['x'] = 27,  ['y']\
    \ = 28,\n    ['z'] = 29,  ['A'] = 26,  ['B'] = 27,  ['C'] = 28,  ['D'] = 29,\n\
    \    ['E'] = 30,  ['F'] = 31,  ['G'] = 28,  ['H'] = 29,  ['I'] = 30,\n    ['J']\
    \ = 31,  ['K'] = 27,  ['L'] = 30,  ['M'] = 27,  ['N'] = 28,\n    ['O'] = 31, \
    \ ['P'] = 30,  ['Q'] = 27,  ['R'] = 30,  ['S'] = 27,\n    ['T'] = 31,  ['U'] =\
    \ 28,  ['V'] = 27,  ['W'] = 30,  ['X'] = 27,\n    ['Y'] = 28,  ['Z'] = 29,  ['!']\
    \ = 26,  ['\"'] = 26,  ['#'] = 26,\n    ['$'] = 26,  ['%'] = 26,  ['&'] = 26,\
    \  '\\''] = 26,  '(' = 26,\n    [')'] = 26,  ['*'] = 26,  ['+'] = 26,  ['-'] =\
    \ 26,  ['.'] = 26,\n    ['/'] = 26,  [':'] = 26,  ';'] = 26,  '<'] = 26,  ['=']\
    \ = 26,\n    ['>'] = 26,  ['?'] = 26,  ['@'] = 26,  ['['] = 26,  ['\\\\'] = 26,\n\
    \    [']'] = 26,  ['^'] = 26,  ['_'] = 26,  ['`'] = 26,  ['{'] = 26,\n    ['|']\
    \ = 26,  ['}'] = 26,  ['~'] = 26,  [' '] = 26,  ['\\t'] = 26,\n    ['\\n'] = 26,\
    \  ['\\v'] = 26,  ['\\r'] = 26,  [':'] = 26,  ['\\0'] = 26,\n    ['@'] = 26, \
    \ ['['] = 26,  [']'] = 26,  ['\\177'] = 26,  [',", "    local alphabet = {\n \
    \       'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\
    \ 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', \n        'A', 'B',\
    \ 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R',\
    \ 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', \n    }", "  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  local alpha2 = \"nopqrstuvwxyzabcdefghijklm\"\n  local out = {}\n  for _,\
    \ v in s:gmatch(\"(.)(.+)\") do\n    table.insert(out, alphabet:sub(v:len() div\
    \ 2, v:len() div 2 + 2))\n  end\n  return table.concat(out, \"\")\nend", "\t--\
    \ We use a list here to preserve the original order of characters.\n\t-- We could\
    \ use a table of characters for even faster performance.\n\t-- The first half\
    \ of the table will be all characters starting at the\n\t-- index 0 for the base\
    \ case, the second half will be characters from \n\t-- the index 1 through 26\
    \ inclusive.\n\tlocal alphabet = {\n\t\t'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\
    \ 'i', 'j', 'k', 'l', 'm', \n\t\t'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z'\n\t}\n\tlocal result = {}\n\tfor i = 1, #s do\n\t\t-- We\
    \ shift all of the characters down by two multiplied by two places\n\t\t-- and\
    \ then add two to that to get the next character.\n\t\tlocal index = alphabet[i]\
    \ .. 'a' - 'a' + 2\n\t\tindex = index + (index * 2)\n\t\t-- Add the character\
    \ to the result and add the index to the \n\t\t-- alphabet to find it again.\n\
    \t\ttable.insert(result, alphabet[index])\n\t\talphabet = alphabet[index]\n\t\
    end\n\treturn table.concat(result)\nend", "  local alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  local rotated_alphabet = alphabet:sub(1, 1):sub(1) + alphabet:sub(1, 2):sub(1)\n\
    \  local encrypted = s:gsub(\"[a-zA-Z]\", function(x) \n    return rotated_alphabet:sub(x:len()-2,\
    \ x:len()-1+2)\n  end):reverse()\n  return encrypted\nend", "  -- Create a lookup\
    \ table containing the 26 letters in the alphabet.\n  local alphabet = s:gsub(\"\
    [%w]\", function(c) return string.char(c:byte() + 64) end)\n  -- Encrypt the string\
    \ with the rotating alphabet\n  local enc = \"\"\n  for i = 1, #s do\n    local\
    \ a = alphabet:sub(1, #alphabet)\n    local b = alphabet:sub(2, #alphabet)\n \
    \   local c = alphabet:sub(3, #alphabet)\n    local d = alphabet:sub(4, #alphabet)\n\
    \    local e = alphabet:sub(5, #alphabet)\n    local f = alphabet:sub(6, #alphabet)\n\
    \    local g = alphabet:sub(7, #alphabet)\n    local h = alphabet:sub(8, #alphabet)\n\
    \    local j = alphabet:sub(9, #alphabet)\n    local k = alphabet:sub(10, #alphabet)\n\
    \    local l = alphabet:sub(11, #alphabet)\n    local m = alphabet:sub(12, #alphabet)\n\
    \    local n = alphabet:sub(13, #alphabet)\n    local o = alphabet:sub(14, #alphabet)\n\
    \    local p = alphabet:sub(15, #alphabet)\n    local q = alphabet:sub(16, #alphabet)\n\
    \    local r = alphabet:sub(17, #alphabet)\n    local s = alphabet:sub(18, #alphabet)\n\
    \    local t = alphabet:sub(19, #alphabet)\n    local u = alphabet:sub(20, #alphabet)\n\
    \    local v = alphabet:sub(21, #alphabet)\n    local w = alphabet:sub(22, #alphabet)\n\
    \    local x = alphabet:sub(23, #alphabet)\n    local y = alphabet:sub(24, #alphabet)\n\
    \    local z = alphabet:sub(25, #alphabet)\n    enc = string.char(string.char(a:byte()\
    \ + 26) + (s:byte() * 26) + (a:byte() + 26) * 26)\n  end\n  return enc\nend",
  "  local alphabet = {\n    ['A'] = {['@'] = '@', \n             ['#'] = '#', \n\
    \             ['$'] = '$', \n             ['%'] = '%', \n             ['&'] =\
    \ '&', \n             ['*'] = '*', \n             ['('] = '(', \n            \
    \ [')'] = ')', \n             ['-'] = '-', \n             ['+'] = '+', \n    \
    \         ['.'] = '.', \n             ['/'] = '/', \n             ['0'] = '0',\
    \ \n             ['1'] = '1', \n             ['2'] = '2', \n             ['3']\
    \ = '3', \n             ['4'] = '4', \n             ['5'] = '5', \n          \
    \   ['6'] = '6', \n             ['7'] = '7', \n             ['8'] = '8', \n  \
    \           ['9'] = '9', \n             ['a'] = 'a', \n             ['b'] = 'b',\
    \ \n             ['c'] = 'c', \n             ['d'] = 'd', \n             ['e']\
    \ = 'e', \n             ['f'] = 'f', \n             ['g'] = 'g', \n          \
    \   ['h'] = 'h', \n             ['i'] = 'i', \n             ['j'] = 'j', \n  \
    \           ['k'] = 'k', \n             ['l'] = 'l', \n             ['m'] = 'm',\
    \ \n             ['n'] = 'n', \n             ['o'] = 'o', \n             ['p']\
    \ = 'p', \n             ['q'] = 'q', \n             ['r'] = 'r', \n          \
    \   ['s'] = 's', \n             ['t'] = 't', \n             ['u'] = 'u', \n  \
    \           ['v'] = 'v', \n             ['w'] = 'w', \n             ['x'] = 'x',\
    \ \n             ['y'] = 'y', \n             ['z'] = 'z', \n             'A@']\
    \ = '@', \n             'A#'] = '#', \n             'A$'] = '$', \n          \
    \   'A%'] = '%', \n             'A&'] = '&', \n             'A*'] = '*', \n  \
    \           'A('] = '(', \n             'A')'] = ')', \n             'A+'] = '+',\
    \ \n             'A.'] = '.', \n             'A/'] = '/', \n             'A0']\
    \ = '0', \n             'A1'] = '1', \n             'A2'] = '2', \n          \
    \   'A3'] = '3', \n             'A4'] = '4', \n             'A5'] = '5', \n  \
    \           'A6'] = '6', \n             'A7'] = '7', \n             'A8'] = '8',\
    \ \n             'A9'] = '9', \n             'Ab'] = 'b', \n             'Ac']\
    \ = 'c', \n             'Ad'] = 'd', \n             'Ae'] = 'e', \n          \
    \   'Af'] = 'f', \n             'Ag'] = 'g', \n             'Ah'] = 'h', \n  \
    \           'Ai'] = 'i', \n             'Aj'] = '", "  local str\n  str = s:gsub('(%S+)',\
    \ function(letter)\n    -- Convert letter to index\n    local i = (letter - 'a')\
    \ + 2\n    -- Rotate alphabet by index by multiplying by two\n    -- then adding\
    \ by one\n    return string.char(string.sub('A', i, i)..string.sub('Z', i+1, i+1))\n\
    \  end)\n  return str\nend\n</code>\nIn short, the algorithm is as follows:",
  "\tlocal alphabet = {\n\t\t'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'\n\
    \t}", "  -- Create a variable to hold our encrypted string.\n  local encrypted\
    \ = \"\"\n  -- Iterate through the string until we run out of characters.\n  for\
    \ i = 1, #s do\n    -- If the current character is equal to the character after\
    \ it then\n    -- add the encrypted version of the current character to the encrypted\n\
    \    -- variable.\n    if s[i] == s[#s] then\n      encrypted = encrypted .. rotatedChar(s[i])\n\
    \      -- If the current character is not equal to the character after it then\n\
    \      -- add two to the encrypted version of the current character to the\n \
    \     -- encrypted variable.\n    elseif s[i] ~= s[#s] then\n      encrypted =\
    \ encrypted .. rotatedChar(s[i])\n      encrypted = encrypted .. rotatedChar(s[#s])\n\
    \    end\n  end\n  -- Return the encrypted string.\n  return encrypted\nend",
  "  local alphabet = string.letters .. string.digits\n  \n  -- Rotate the alphabet\
    \ to the right.\n  alphabet = alphabet:sub(1, alphabet:len()-1)", "  -- Initialize\
    \ a string of 26 characters to an empty string.\n  local r = \"\"\n  -- Iterate\
    \ through each letter in string s.\n  for i = 1, #s do\n    -- Get the current\
    \ letter in string s letter by letter.\n    local l = s[i]\n    -- Increment i\
    \ by two.\n    i = i + 2\n    -- Check if i is greater than 26. If so then subtract\
    \ 26 from i \n    -- decrement the letter by one and append the letter.\n    if\
    \ i > 26 then\n      i = i - 26\n      l = l - 1\n    end\n    -- Append the letter\
    \ l to the string r.\n    r = r..l\n  end\n  return r\nend", "  local alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n  local c = ''\n  for i = 1, #s do c = c +\
    \ alphabet[(i + 2) % #alphabet] end\n  return c\nend", "    local alphabet = \"\
    abcdefghijklmnopqrstuvwxyz\"\n    local output = ''\n    for i = #s, 1, -1 do\n\
    \        local c = string.sub(s,i,i)\n        c = string.sub(alphabet, #alphabet\
    \ * ((#alphabet - 1) - math.floor(c/#alphabet) + 1) + 1)\n        output = output\
    \ .. string.char(c)\n    end\n    return output\nend", "  -- Write your code here.\n\
    \  local alph = string.char(string.len(s)+2)\n  local function rotate_alpha(char)\n\
    \    return alph .. string.sub(char,1,-1)\n  end\n  local output = \"\"\n  for\
    \ i=1,string.len(s) do\n    local char = string.sub(s,i,i+1)\n    local new_char\
    \ = rotate_alpha(char)\n    local new_char = string.gsub(new_char,'%S',function(c)\
    \ string.char(c-97) end)\n    output = output .. new_char\n  end\n  return output\n\
    end", "  assert(type(s) == 'string', 'encrypt expects a string')\n  local cipher\
    \ = {}\n  for i=1,26-1 do\n    table.insert(cipher, #cipher+string.sub(s, i, i+1))\n\
    \  end\n  return table.concat(cipher)\nend", "   -- Create a table that maps every\
    \ character in the alphabet to a number\n   -- that represents that character's\
    \ position in the alphabet.\n   -- For example, if the alphabet is \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    , then\n   -- the value for each character in the alphabet would be the following:\n\
    \   --     {\"A\":1, \"B\":2, \"C\":3, \"D\":4, \"E\":5, \"F\":6, \"G\":7, \"\
    H\":8, \"I\":9, \"J\":10,\n   --      \"K\":11, \"L\":12, \"M\":13, \"N\":14,\
    \ \"O\":15, \"P\":16, \"Q\":17, \"R\":18, \"S\":19,\n   --      \"T\":20, \"U\"\
    :21, \"V\":22, \"W\":23, \"X\":24, \"Y\":25, \"Z\":26}\n   -- The numbers increase\
    \ by one for each in the alphabet.\n   local alphabet = {}\n   for i = 1, #s do\
    \ alphabet[s[i]:lower()] = i end", "  if #s == 0 then return '' end\n  local ret\
    \ = ''\n  for i = #alphabet, 1, -1 do\n    ret = alphabet[(i-#alphabet)-#alphabet*2]\
    \ .. ret\n  end\n  return ret .. s\nend", "\tlocal alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\tlocal shift = 2\n\tlocal newS = s\n\tfor i = #alphabet, 1, -1 do\n\t\tnewS\
    \ = string.gsub(newS, \"%c\", alphabet[(i + shift) % #alphabet])\n\tend\n\treturn\
    \ newS\nend", "  local alpha = 'abcdefghijklmnopqrstuvwxyz'\n  local alpha_rot\
    \ = 'zyxwvutsrqponmlkjihgfedcba'\n  local l = {}\n  for i = 1, #s do\n    l[i]\
    \ = alpha:sub(#alpha-i-1, #alpha-i)\n  end\n  return alpha_rot:sub(0, #alpha_rot)*l[1]\
    \ + alpha_rot:sub(1, #alpha_rot)*l[2] + alpha_rot:sub(2, #alpha_rot)*l[3] + alpha_rot:sub(3,\
    \ #alpha_rot)*l[4] + alpha_rot:sub(4, #alpha_rot)*l[5] + alpha_rot:sub(5, #alpha_rot)*l[6]\
    \ + alpha_rot:sub(6, #alpha_rot)*l[7] + alpha_rot:sub(7, #alpha_rot)*l[1] + alpha_rot:sub(0,\
    \ #alpha_rot)*l[2] + alpha_rot:sub(1, #alpha_rot)*l[3] + alpha_rot:sub(2, #alpha_rot)*l[4]\
    \ + alpha_rot:sub(3, #alpha_rot)*l[5] + alpha_rot:sub(4, #alpha_rot)*l[6] + alpha_rot:sub(5,\
    \ #alpha_rot)*l[7] + alpha_rot:sub(6, #alpha_rot)*l[1] + alpha_rot:sub(0, #alpha_rot)*l[2]\
    \ + alpha_rot:sub(1, #alpha_rot)*l[3] + alpha_rot:sub(2, #alpha_rot)*l[4] + alpha_rot:sub(3,\
    \ #alpha_rot)*l[5] + alpha_rot:sub(4, #alpha_rot)*l[6] + alpha_rot:sub(5, #alpha_rot)*l[7]\
    \ + alpha_rot:sub(6, #alpha_rot)*l[1] + alpha_rot:sub(0, #alpha_rot)*l[2] + alpha_rot:sub(1,\
    \ #alpha_rot)*l[3] + alpha_rot:sub(2, #alpha_rot)*l[4] + alpha_rot:sub(3, #alpha_rot)*l[5]\
    \ + alpha_rot:sub(4, #alpha_rot)*l[6] + alpha_rot:sub(5, #alpha_rot)*l[7] + alpha_rot:sub(6,\
    \ #alpha_rot)*l[1] + alpha_rot:sub(0, #alpha_rot)*l[2] + alpha_rot:sub(1, #alpha_rot)*l[3]\
    \ + alpha_rot:sub(2, #alpha_rot)*l[4] + alpha_rot:sub(3, #alpha_rot)*l[5] + alpha_rot:sub(4,\
    \ #alpha_rot)*l[6] + alpha_rot:sub(5, #alpha_rot)*l[7] + alpha_rot:sub(6, #alpha_rot)*l[1]\
    \ + alpha_rot:sub(0, #alpha_rot)*l[2] + alpha_rot:sub(1, ", "\tlocal alphabet\
    \ = string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.",
  "  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  return alphabet[(alphabet:len()\
    \ - s:len()) + s:len()] \nend", "  -- Create a counter\n  local c=0\n  -- Encrypt\
    \ the letter\n  for i=1,#s do\n    c=c+2\n    if c>#s then\n      c=c-(#s-1)\n\
    \    end\n    local a=ALPHABET[c]\n    -- Shift the letter\n    s=s%a..a\n  end\n\
    \  return s\nend", "    local e = ''\n    local i = 0\n    while i < (#s) do\n\
    \        e = e .. string.sub(s, i, i + 1)\n        i = i + 2\n    end\n    return\
    \ e\nend", "  -- Encrypt a string\n  -- First we find the index of the first character\
    \ of the alphabet\n  -- and move it over by two, i.e. we subtract by two in the\
    \ rotation.\n  local alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  local alphabetLen = #alphabet\n  local firstIndex = alphabet ~= s and (alphabet\
    \ ~= string.sub(alphabet, s)) or 0\n  local firstIndex = firstIndex - 2\n  --\
    \ Rotate the alphabet by two characters\n  local rotatedAlphabet = alphabet:sub(1,\
    \ firstIndex) + alphabet:sub(firstIndex + 1, alphabetLen)\n  -- Encrypt the string\n\
    \  -- We get the number of characters in the string and subtract one\n  -- because\
    \ the first character of the string is the encrypted letter.\n  local numCharsIn\
    \ = #s - 1\n  local res = string.sub(rotatedAlphabet, firstIndex, firstIndex +\
    \ numCharsIn)\n  return res\nend", "  -- Initialize the alphabet\n  local alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  -- Initialize the\
    \ result to be an empty string\n  local result = \"\";\n  -- Loop over each character\
    \ in the string\n  for i = 1, #s do\n    -- If the character is a letter (a-z\
    \ A-Z 0-9)\n    if alphabet:sub(i,i) <= 'z' and alphabet:sub(i,i) >= '0' then\n\
    \      -- Rotate the letter by multiplying by 2\n      -- Subtract 26 from current\
    \ letter\n      -- Add letter to the result (shifting down by 2)\n      -- Example:\
    \ alphabet:sub('a',2) == 'b' so result is 'b' + alphabet:sub('a',4) == 'c' \n\
    \      alphabet = alphabet:sub(i,i) + alphabet:sub(i,i) + alphabet:sub(i,i) -\
    \ 26;\n      result = result + alphabet:sub(i,i);\n    end\n  end\n  -- return\
    \ the result\n  return result;\nend", "  if s == nil then return nil end\n  local\
    \ result = ''\n  \n  for i = 1, #s do\n    local letter = string.sub(s,i,i)\n\
    \    letter = string.sub(letter,1,1)\n    letter = string.gsub(letter,\".\",'')\n\
    \    letter = string.gsub(letter,\" \",'')\n    letter = string.gsub(letter,\"\
    ,\",'')\n    letter = string.gsub(letter,\".\",'')\n    letter = string.gsub(letter,\"\
    ,\",'')\n    letter = string.gsub(letter,\"[\",'')\n    letter = string.gsub(letter,\"\
    ]\",'')\n    letter = string.gsub(letter,\"'\",'')\n    letter = string.gsub(letter,\"\
    *\",'')\n    letter = string.gsub(letter,\"(\",'')\n    letter = string.gsub(letter,\"\
    )\",'')\n    letter = string.gsub(letter,\":\",'')\n    letter = string.gsub(letter,\"\
    -\",'')\n    letter = string.gsub(letter,\"+\",'')\n    letter = string.gsub(letter,\"\
    ,\",'')\n    letter = string.gsub(letter,\"%\",'')\n    letter = string.gsub(letter,\"\
    $\",'')\n    letter = string.gsub(letter,\"%\",'')\n    letter = string.gsub(letter,\"\
    +\",'')\n    letter = string.gsub(letter,\";\",'')\n    letter = string.gsub(letter,\"\
    ?\",'')\n    letter = string.gsub(letter,\"!\",'')\n    letter = string.gsub(letter,\"\
    #\",'')\n    letter = string.gsub(letter,\"%\",'')\n    letter = string.gsub(letter,\"\
    %\",'')\n    letter = string.gsub(letter,\"*\",'')\n    letter = string.gsub(letter,\"\
    &\",'')\n    letter = string.gsub(letter,\"+\",'')\n    letter = string.gsub(letter,\"\
    &\",'')\n    letter = string.gsub(letter,\"%\",'')\n    letter = string.gsub(letter,\"\
    *\",'')\n    letter = string.gsub(letter,\"-\",'')\n    letter = string.gsub(letter,\"\
    +\",'')\n    letter = string.gsub(letter,\"-\",'')\n    letter = string.gsub(letter,\"\
    +\",'')\n    letter = string.gsub(letter,\"*\",'')\n    letter = string.gsub(letter",
  "  -- Base case\n  if s:len() < 3 then return s end\n  \n  -- If the first letter\
    \ is 'i', make it 'o'. Otherwise, it's 'i'.\n  local t = s:sub(1, 1):upper()\n\
    \  if t == 'I' then t = 'O' end\n  \n  -- Rotate the rest of the string\n  for\
    \ i = 2, #s do\n    local t = s:sub(i, i)\n    if t == 'I' then t = 'O' end\n\
    \    s = s .. t\n  end\n  \n  -- Put the base case back in\n  t = s:sub(1, 1):upper()\n\
    \  if t == 'I' then t = 'O' end\n  s = t .. s\n  \n  return s\nend\n</code>\n\
    <|/ a |>\n<| c |>\nI didn't think of that solution. Thanks!\n<|/ c |>\n<| a dscore=2\
    \ |>\nJust another variation on John's solution, using pattern matching instead\
    \ of string manipulation:\n<code>", "    return string.gsub(string.gsub(string.gsub(s,'.','[.]'),'$','.'),'..','[.]')\n\
    end", "\tlocal alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\tlocal newalphabet\
    \ = alphabet:sub(1, alphabet:len()-1) + alphabet:sub(2, alphabet:len()-1) + alphabet:sub(3,\
    \ alphabet:len()-1)\n\t\n\t-- Create a string with newalphabet and s\n\tlocal\
    \ news = newalphabet\n\tlocal n = 1\n\tfor i = 1, #s do\n\t\t-- Add newalphabet\
    \ letter to the end of the news string\n\t\tnews = news + alphabet:sub(n, #alphabet)\n\
    \t\t-- Add one to n\n\t\tn = n + 1\n\tend\n\t\n\t-- Replace s with news string\n\
    \treturn s\nend", "    -- Convert string to list\n    local l = s:gsub(\"^%s*(.-)%s*$\"\
    , \"%2\"):gmatch(\"(.-)\")", "   local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \   \n   s = s:upper()\n   local slen = #s\n   local new = ''", "    local alphabet\
    \ = {\n        [[a],[c],[g],[m],[o],[q],[t],[u],[v]],\n        [[b],[e],[h],[j],[o],[q],[u],[z]],\n\
    \        [[f],[i],[l],[o],[r],[v]],\n        [[d],[h],[j],[m],[p]],\n        [[f],[l],[o],[r],[u],[z]],\n\
    \        [[a],[c],[g],[m],[o],[q],[t]],\n        [[b],[e],[h],[j],[o],[q],[u]],\n\
    \        [[f],[i],[l],[o],[r]],\n        [[d],[h],[j],[m],[p]],\n        [[f],[l],[o],[r],[u]],\n\
    \        [[a],[c],[g],[m],[o],[q],[t]],\n        [[b],[e],[h],[j],[o],[q],[u]],\n\
    \        [[f],[i],[l],[o],[r]],\n        [[d],[h],[j],[m],[p]],\n        [[f],[l],[o],[r],[u]],\n\
    \        [[a],[c],[g],[m],[o],[q],[t]],\n        [[b],[e],[h],[j],[o],[q],[u]],\n\
    \        [[f],[i],[l],[o],[r]],\n        [[d],[h],[j],[m],[p]],\n        [[f],[l],[o],[r],[u]],\n\
    \    }", "  if s == '' then\n    return ''\n  end\n  \n  local t = ''\n  for i\
    \ = 1, #s do\n    local c = string.sub(s,i,i)\n    if i == 1 then\n      t = string.sub(t,1,1)\n\
    \    end\n    t = string.sub(alphabet,(c-1),(c-1)+2)\n    t = string.sub(t,1,1)\n\
    \    t = string.sub(t,1,2)\n  end\n  return t\nend", "  -- Get the length of the\
    \ string.\n  local length = #s\n  \n  -- If the string is empty, then return an\
    \ empty string.\n  if length == 0 then\n    return ''\n  end\n  \n  -- Create\
    \ a list to hold the characters.\n  local alpha = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  \n  -- Initialize a variable to hold the string.\n  local result = ''\n  \n\
    \  -- Initialize the counter.\n  local counter = 1\n  \n  -- Loop through the\
    \ characters in the string.\n  for i = 1, length do\n    -- If the character is\
    \ in the alphabet then add it to the \n    -- result string.\n    if alpha:sub(i,i+1)\
    \ ~= s:sub(i,i+1) then\n      -- Add the character to the result string.\n   \
    \   result = result .. alpha:sub(counter,counter+1)\n      -- Set the counter\
    \ to increment by two.\n      counter = counter + 2\n    end\n  \n    -- If the\
    \ character is not in the alphabet, then add it to\n    -- result string and set\
    \ counter to increment by two.\n  end\n  \n  -- Add the last character to the\
    \ result string.\n  result = result .. alpha:sub(counter,counter+1)\n  \n  return\
    \ result\nend", "    local c1, c2, c3 = 'z'\n    local alphabet = {c1, c2, c3}\n\
    \    for i = #alphabet, 1, -1 do\n        local c = alphabet[i]\n        alphabet[i]\
    \ = c\n        alphabet[i + #alphabet] = alphabet[#alphabet] - c\n    end\n  \
    \  local cipher = s\n    for i = #alphabet, 1, -1 do\n        local c = alphabet[i]\n\
    \        cipher = cipher .. c\n    end\n    return cipher\nend", "   -- We start\
    \ by making two copies of our original string. One is the\n   -- original string\
    \ and one is what we will return as our encrypted string.\n   local s1 = s:gsub('%a','a')\n\
    \   local s2 = s:gsub('%A','A')\n   -- Now we create a rotated copy of our original\
    \ string. Since the\n   -- alphabet is rotated left by 2 we will need to rotate\
    \ each letter in\n   -- the input string down by 2 positions.\n   local t = \"\
    \"\n   for i = 1, #s do\n      -- Rotate down by 2 each letter in the input string.\n\
    \      t = t .. s2(i)\n      -- Rotate down by 2 each letter in the rotated string.\n\
    \      t = t .. s2((i+1)%#s)\n      -- Add our original letter to the end of the\
    \ output string.\n      t = t .. s1(#s)\n   end\n   return t\nend\n</code>\n<|/\
    \ a tags=lua,encryption |>\n<| c |>\nThanks for the help.  Can you please explain\
    \ how this works? I am not familiar with gsub, etc. What are the advantages of\
    \ using gsub and others when you have the code you provided?\n<|/ c |>\n<| c |>\n\
    I added some comments to the code above. Basically, `gsub()` replaces some pattern\
    \ with another pattern. I chose `%a` and `%A` but you could replace them with\
    \ `%z` and then replace the letter with `chr(ord(a)+ord(b)):sub(1,1)`.\n<|/ c\
    \ |>\n<| a tags=lua,encryption |>\n<code>", "    -- Create alphabet of 26 characters.\
    \ \n    -- Shift each letter up by 2 multiplied by 2.\n    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    -- Initialize an empty string to return.\n    local returnString = ''\n \
    \   -- Iterate through the string and add every letter to the return string.\n\
    \    for letter in s:gmatch'[a-z]' do\n        returnString = returnString ..\
    \ alphabet:sub(1,alphabet:len() -2) \n        returnString = returnString .. alphabet:sub(1,alphabet:len()\
    \ -2)\n        returnString = returnString .. alphabet:sub(1,alphabet:len() -2)\n\
    \    end\n    -- Return the encrypted string.\n    return returnString\nend",
  "    local alphabet = {\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n\
    \        'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n        'u', 'v',\
    \ 'w', 'x', 'y', 'z', '0', '1', '2', '3',\n        '4', '5', '6', '7', '8', '9'\n\
    \    }\n    local i, j, k\n    for i = 0, #s do\n        j = i - 1\n        k\
    \ = i % 2 -- k is 0 or 1\n        s[k] = alphabet[k] .. alphabet[j]\n    end\n\
    \    return s\nend", "  -- Initialize a variable that contains the alphabet to\
    \ rotate by.\n  local rotate_alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  -- Create\
    \ a variable that contains the letters that will be rotated \n  -- into the alphabet.\n\
    \  local rotated_letters = {}\n  -- For each letter in the string passed in, we'll\
    \ use the rotate alphabet\n  -- function to rotate each letter in the alphabet\
    \ by its position in \n  -- rotate_alphabet. For example, the rotated letter for\
    \ \"i\" would be \n  -- \"k\" since rotate_alphabet[3] would be \"i\".\n  for\
    \ letter in s:gmatch('[a-z]+') do \n    -- Rotate each letter in the alphabet\
    \ by its position in rotate_alphabet\n    -- and place each letter in rotated_letters.\n\
    \    rotated_letters[#rotated_letters + 1] = rotate_alphabet:sub(1, #rotate_alphabet)\
    \ + letter\n  end\n  -- Return the string with rotated letters.\n  return table.concat(rotated_letters,\
    \ '') \nend", "  -- Pre-calculate the shift offsets\n  local shifts = {\n    e\
    \ = 2,\n    o = 4,\n    i = 6,\n    l = 8,\n    t = 10,\n    h = 12,\n    n =\
    \ 14,\n    b = 16,\n    f = 18\n  }", "  local alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  local newS = \"\"\n  local i = 0\n  \n  for i = #s , 1, -1 do\n    local c1\
    \ = alphabet:sub(i,i)\n    local c2 = alphabet:sub(i+2,i+2)\n    local c3 = alphabet:sub(i+4,i+4)\n\
    \    local c4 = alphabet:sub(i+6,i+6)\n    local c5 = alphabet:sub(i+8,i+8)\n\
    \    local c6 = alphabet:sub(i+10,i+10)\n    \n    local c7 = alphabet:sub(i+14,i+14)\n\
    \    local c8 = alphabet:sub(i+16,i+16)\n    local c9 = alphabet:sub(i+18,i+18)\n\
    \    local c10 = alphabet:sub(i+20,i+20)\n    \n    local c11 = alphabet:sub(i+22,i+22)\n\
    \    local c12 = alphabet:sub(i+24,i+24)\n    local c13 = alphabet:sub(i+26,i+26)\n\
    \    local c14 = alphabet:sub(i+28,i+28)\n    local c15 = alphabet:sub(i+30,i+30)\n\
    \    \n    local c16 = alphabet:sub(i+32,i+32)\n    local c17 = alphabet:sub(i+34,i+34)\n\
    \    local c18 = alphabet:sub(i+36,i+36)\n    local c19 = alphabet:sub(i+38,i+38)\n\
    \    local c20 = alphabet:sub(i+40,i+40)\n    \n    local c21 = alphabet:sub(i+42,i+42)\n\
    \    local c22 = alphabet:sub(i+44,i+44)\n    local c23 = alphabet:sub(i+46,i+46)\n\
    \    local c24 = alphabet:sub(i+48,i+48)\n    local c25 = alphabet:sub(i+50,i+50)\n\
    \    \n    local c26 = alphabet:sub(i+52,i+52)\n    local c27 = alphabet:sub(i+54,i+54)\n\
    \    local c28 = alphabet:sub(i+56,i+56)\n    local c29 = alphabet:sub(i+58,i+58)\n\
    \    local c30 = alphabet:sub(i+60,i+60)\n    \n    local c31 = alphabet:sub(i+62,i+62)\n\
    \    local c32 = alphabet:sub(i", "  -- A list which holds all of the letters.\n\
    \  local t = {}", "  local rots = { \"abcdefghijklmnopqrstuvwxyz\", \"nopqrstuvwxyzabcdefghij\"\
    , \"pqrstuvwxyzabcdefghijklm\", \"qrstuvwxyzabcdefghijklmn\", \"rstuvwxyzabcdefghijklmnop\"\
    , \"stuvwxyzabcdefghijklmnopq\", \"stuvxyzabcdefghijklmnopqrst\", \"stuxyzabcdefghijklmnopqrstu\"\
    , \"stuyzabcdefghijklmnopqrstuv\", \"stuzabcdefghijklmnopqrstuvw\", \"studabcdefghijklmnopqrstuvwy\"\
    , \"studefghijklmnopqrstuvwxy\", \"stufghijklmnopqrstuvwxyz\", \"stugijklmnopqrstuvwxyzab\"\
    , \"stugjklmnopqrstuvwxyzabce\", \"stugjklmnopqrstuvwxyzabced\", \"stugjklmnopqrstuvwxyzabcedf\"\
    , \"stugjklmnopqrstuvwxyzabcedfg\", \"stugjklmnopqrstuvwxyzabcedfgh\", \"stugjklmnopqrstuvwxyzabcedfghi\"\
    , \"stugjklmnopqrstuvwxyzabcedfghij\", \"stugjklmnopqrstuvwxyzabcedfghijk\", \"\
    stugjklmnopqrstuvwxyzabcedfghijkl\", \"stugjklmnopqrstuvwxyzabcedfghijklm\", \"\
    stugjklmnopqrstuvwxyzabcedfghijklmn\", \"stugjklmnopqrstuvwxyzabcedfghijklmno\"\
    , \"stugjklmnopqrstuvwxyzabcedfghijklmnop\", \"stugjklmnopqrstuvwxyzabcedfghijklmnopq\"\
    , \"stugjklmnopqrstuvwxyzabcedfghijklmnopqr\"}\n  local ans = \"\"\n  for _, rot\
    \ in ipairs(rots) do\n    local str = s:gsub(\"%a\"..rot, \"%a\"..rot:sub(1, rot:len()\
    \ - 2))\n    ans = ans .. str\n  end\n  return ans\nend", "  local alphabet =\
    \ string.gsub(string.gsub('abcdefghijklmnopqrstuvwxyz',\n                    \
    \                       'g','2'), 'z', '1')\n  \n  return alphabet:gsub('(...)',\
    \ '%1'..alphabet:sub(1,1..2)..'%2')\n                     :gsub('(..)', '%1'..alphabet:sub(2,1..2)..'%2')\n\
    \                     :gsub('(.)', '%1'..alphabet:sub(3..3)..'%2')\n         \
    \            :gsub('(.)', '%1'..alphabet:sub(4..4)..'%2')\n                  \
    \   :gsub('(.)', '%1'..alphabet:sub(5..5)..'%2')\n                     :gsub('(.)',\
    \ '%1'..alphabet:sub(6..6)..'%2')\n                     :gsub('(.)', '%1'..alphabet:sub(7..7)..'%2')\n\
    \                     :gsub('(.)', '%1'..alphabet:sub(8..8)..'%2')\n         \
    \            :gsub('(.)', '%1'..alphabet:sub(9..9)..'%2')\n                  \
    \   :gsub('(.)', '%1'..alphabet:sub(10..10)..'%2')\n                     :gsub('(.)',\
    \ '%1'..alphabet:sub(11..11)..'%2')\n                     :gsub('(.)', '%1'..alphabet:sub(12..12)..'%2')\n\
    \                     :gsub('(.)', '%1'..alphabet:sub(13..13)..'%2')\n       \
    \              :gsub('(.)', '%1'..alphabet:sub(14..14)..'%2')\n              \
    \       :gsub('(.)', '%1'..alphabet:sub(15..15)..'%2')\n                     :gsub('(.)',\
    \ '%1'..alphabet:sub(16..16)..'%2')\n                     :gsub('(.)', '%1'..alphabet:sub(17..17)..'%2')\n\
    \                     :gsub('(.)', '%1'..alphabet:sub(18..18)..'%2')\n       \
    \              :gsub('(.)', '%1'..alphabet:sub(19..19)..'%2')\n              \
    \       :gsub('(.)', '%1'..alphabet:sub(20..20)..'%2')\n                     :gsub('(.)',\
    \ '%1'..alphabet:sub(21..21)..'%2')\n                     :gsub('(.)', '%1'..alphabet:sub(22..22)..'%2')\n\
    \                     :gsub('(.)', '%1'..alphabet:sub(23..23)..'%2')\n       \
    \              :gsub('(.)', '%1'..", "    local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    local alphabetIndex = {}\n    local alphabetIndexCount = 0\n    for i=1,#alphabet\
    \ do\n        alphabetIndex[alphabet:sub(i,i)] = i\n    end", "  local alphabet\
    \ = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n  local rotated = ''\n\
    \  for i = 1, #s do\n    rotated = rotated .. alphabet[(alphabet[#alphabet] -\
    \ alphabet[(#alphabet)%#alphabet] + alphabet[i]) .. alphabet[#alphabet]]\n  end\n\
    \  return rotated\nend", "   -- Note: this can get slow with large strings. Consider\
    \ caching s.\n   -- Note: the current code will break if the alphabet doesn't\
    \ have\n   -- to shift down in two.\n   local alphabet = string.letters()\n  \
    \ for i = 2, #s do alphabet = alphabet..string.letters(alphabet ) end\n   local\
    \ shift = math.floor( #alphabet/2 )\n   local alphabet2 = string.letters()\n \
    \  for i = #alphabet, 2, -1 do\n      alphabet2 = alphabet2..string.letters(alphabet2,\
    \ string.sub(alphabet, i, i+1)..string.sub(alphabet, i, i+1))\n   end\n   for\
    \ i = 1, #alphabet2 do\n      alphabet2 = alphabet2..string.letters(alphabet2,\
    \ string.sub(alphabet2, i, i+1)..string.sub(alphabet2, i, i+1))\n   end\n   return\
    \ alphabet2..string.gsub(s, '%l', alphabet)\nend", "    -- Your code goes here.\n\
    end", "    local alph = {}\n    for i = 65, 90 do\n        alph[i] = string.char(i)\n\
    \    end\n    local c = ''\n    for i = 1, #s do\n        c = c + alph[string.byte(s,i)]\n\
    \    end\n    return c\nend", "\tlocal alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\tlocal result = ''\n\t\n\t-- Rotate the alphabet by 2 places.\n\tlocal alphabet2\
    \ = alphabet:sub(1, alphabet:len()+1)\n\talphabet = alphabet:sub(1, alphabet:len()+2)\n\
    \t\n\t-- Add the first letter to the result string, rotated and flipped.\n\tresult\
    \ = alphabet2:sub(1, alphabet2:len()) + result\n\t\n\t-- Rotate the result string\
    \ by 2 places.\n\tresult = result:sub(1, result:len()+2)\n\t\n\t-- Add every letter\
    \ to the result string.\n\tfor i = 1, #s do\n\t\t-- Add the letter to the result\
    \ string, rotated and flipped.\n\t\tresult = alphabet:sub(i):sub(1, alphabet:len())\
    \ + result\n\tend\n\t\n\treturn result\nend", "   local alpha = {\n      \"e\"\
    ,\"t\",\"r\",\"q\",\"p\",\"s\",\"d\",\"f\",\"g\",\"h\",\"j\",\"k\",\"l\",\"m\"\
    ,\"n\",\"o\",\"p\",\n      \"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"\
    j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"l\",\"m\",\n      \"i\",\"v\",\"w\"\
    ,\"x\",\"y\",\"z\",\"s\",\"t\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\"\
    ,\"j\",\"k\",\n      \"l\",\"m\",\"n\",\"o\",\"p\",\"l\",\"m\",\"q\",\"r\",\"\
    s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\"k\",\n      \"j\",\"x\",\"c\"\
    ,\"f\",\"d\",\"e\",\"h\",\"g\",\"b\",\"i\",\"n\",\"o\",\"z\",\"s\",\"x\",\"v\"\
    ,\"y\",\n      \"r\",\"q\",\"p\",\"s\",\"d\",\"f\",\"g\",\"h\",\"j\",\"k\",\"\
    l\",\"m\",\"n\",\"o\",\"p\",\"l\",\"m\",\"q\",\n      \"r\",\"s\",\"t\",\"u\"\
    ,\"v\",\"w\",\"x\",\"y\",\"z\",\"k\",\"j\",\"x\",\"c\",\"f\",\"d\",\"e\",\"h\"\
    ,\"g\",\n      \"b\",\"i\",\"n\",\"o\",\"z\",\"s\",\"x\",\"v\",\"y\",\"r\",\"\
    q\",\"p\",\"s\",\"d\",\"f\",\"g\",\"h\",\"j\",\n      \"k\",\"l\",\"m\",\"n\"\
    ,\"o\",\"p\",\"l\",\"m\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\"\
    ,\"z\",\n      \"k\",\"j\",\"x\",\"c\",\"f\",\"d\",\"e\",\"h\",\"g\",\"b\",\"\
    i\",\"n\",\"o\",\"z\",\"s\",\"x\",\"v\",\"y\",\n      \"r\",\"q\",\"p\",\"s\"\
    ,\"d\",\"f\",\"g\",\"h\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"l\",\"m\"\
    ,\"q\",\n      \"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\"k\",\"\
    j\",\"x\",\"c\",\"f\",\"d\",\"e\",\"h\",\"g\",\n      \"b\",\"i\",\"n\",\"o\"\
    ,\"z\",\"s\",\"x\",\"v\",\"y\",\"r\",\"q\",\"p\",\"s\",\"d\",\"f\",\"g\",\"h\"\
    ,\"j\",\n      \"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"l\",\"m\",\"q\",\"r\",\"\
    s\",\"", "    local letters = 'abcdefghijklmnopqrstuvwxyz'\n    local alphabet\
    \ = ''\n    for i = #letters, 1, -1 do\n        alphabet = alphabet .. letters[i\
    \ - 1]\n    end\n    local news = ''\n    for i = 1, #s do\n        if s[i] then\n\
    \            local alpha = alphabet[((i - 1) %  #alphabet)]\n            news\
    \ = news .. letters[#letters + alphabet + alpha]\n        end\n    end\n    return\
    \ news\nend", "    local alphabet = {}\n    alphabet[1] = 'a'\n    alphabet[2]\
    \ = 'b'\n    alphabet[3] = 'c'\n    alphabet[4] = 'd'\n    alphabet[5] = 'e'\n\
    \    alphabet[6] = 'f'\n    alphabet[7] = 'g'\n    alphabet[8] = 'h'\n    alphabet[9]\
    \ = 'i'\n    alphabet[10] = 'j'\n    alphabet[11] = 'k'\n    alphabet[12] = 'l'\n\
    \    alphabet[13] = 'm'\n    alphabet[14] = 'n'\n    alphabet[15] = 'o'\n    alphabet[16]\
    \ = 'p'\n    alphabet[17] = 'q'\n    alphabet[18] = 'r'\n    alphabet[19] = 's'\n\
    \    alphabet[20] = 't'\n    alphabet[21] = 'u'\n    alphabet[22] = 'v'\n    alphabet[23]\
    \ = 'w'\n    alphabet[24] = 'x'\n    alphabet[25] = 'y'\n    alphabet[26] = 'z'\n\
    \    alphabet[27] = 'a'\n    alphabet[28] = 'b'\n    alphabet[29] = 'c'\n    alphabet[30]\
    \ = 'd'\n    alphabet[31] = 'e'\n    alphabet[32] = 'f'\n    alphabet[33] = 'g'\n\
    \    alphabet[34] = 'h'\n    alphabet[35] = 'i'\n    alphabet[36] = 'j'\n    alphabet[37]\
    \ = 'k'\n    alphabet[38] = 'l'\n    alphabet[39] = 'm'\n    alphabet[40] = 'n'\n\
    \    alphabet[41] = 'o'\n    alphabet[42] = 'p'\n    alphabet[43] = 'q'\n    alphabet[44]\
    \ = 'r'\n    alphabet[45] = 's'\n    alphabet[46] = 't'\n    alphabet[47] = 'u'\n\
    \    alphabet[48] = 'v'\n    alphabet[49] = 'w'\n    alphabet[50] = 'x'\n    alphabet[51]\
    \ = 'y'\n    alphabet[52] = 'z'\n    alphabet[53] = 'A'\n    alphabet[54] = 'B'\n\
    \    alphabet[55] = 'C'\n    alphabet[56] = 'D'\n    alphabet[57] = 'E'\n    alphabet[58]\
    \ = 'F'\n    alphabet[59] = 'G'\n    alphabet[60] = 'H'\n    alphabet[61] = 'I'\n\
    \    alphabet[62] = 'J'\n    alphabet[63] = 'K'\n    alphabet[64] = 'L'\n    alphabet[65]\
    \ = 'M'\n    alphabet[66] = 'N'\n    alphabet[67] = 'O'\n    alphabet[68] = 'P'\n\
    \    ", "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local shift = 1\n\
    \  local encrypt = string.rep('', #s)\n  for i = 1, #s do\n    local char = alphabet[#alphabet]\n\
    \    alphabet = alphabet:sub(1,#alphabet-1)..alphabet:sub((i+1)%#alphabet,#alphabet+1)\n\
    \    encrypt = alphabet..encrypt\n    alphabet = alphabet:sub(1,#alphabet-1)..alphabet:sub((i+1)%#alphabet,#alphabet+1)\n\
    \    encrypt = alphabet..encrypt\n    shift = shift*2\n  end\n  return encrypt\n\
    end", "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local alphabetLen =\
    \ #alphabet\n  local rotatedAlphabet = ''\n  local j = 0 -- j stores the current\
    \ character index in s\n  for i = 1, #s do -- For each character in s\n    rotatedAlphabet\
    \ = alphabet[(alphabet.lenght) - j - 2]\n    j = j + 2\n  end\n  s = s .. rotatedAlphabet\n\
    \  return s\nend", "  local alphabet = {\n    ['z'] = {\n      ['a'] = {\n   \
    \     ['p'] = {\n          ['l']\n        }\n      }\n    }\n  }\n  -- Build a\
    \ lookup table for the shift amount.\n  local shifts = {}\n  for i, letter in\
    \ pairs(alphabet) do\n    table.insert(shifts, 0)\n    local c = alphabet[letter]\n\
    \    for j, letters in pairs(c) do\n      for k, letter in pairs(letters) do\n\
    \        table.insert(shifts, shifts[#shifts] + 1)\n      end\n    end\n  end\n\
    \  local result = {}\n  local index = 1\n  repeat\n    local c = {}\n    for i\
    \ = index, index + #s do\n      table.insert(c, string.sub(s, i, i + 1))\n   \
    \ end\n    index = index + 1\n    local result = {}\n    for j = 1, #c do\n  \
    \    local key = j - shifts[j]\n      table.insert(result, alphabet[c[j]][key])\n\
    \    end\n    table.insert(result, table.concat(result))\n  until #result == 0\n\
    \  table.insert(result, table.concat(result))\n  return table.concat(result)\n\
    end", "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  -- We use recursion\
    \ to traverse the alphabet, and each time we encounter \n  -- an extra letter,\
    \ we rotate it twice to the left and add it to the \n  -- current letter. For\
    \ example, 'ae' rotates down 2 spaces, \n  -- which means we add 'd' to the current\
    \ letter. The function takes \n  -- one argument (the current letter) and returns\
    \ another letter that \n  -- will be the new value of the letter. If the current\
    \ letter is empty,\n  -- we return the empty string (because 'a' was the last\
    \ letter of the \n  -- alphabet, we can just return the empty string).\n  -- We\
    \ also add a 'z' to the end of the alphabet so the end result is \n  -- the alphabet\
    \ is rotated left.\n  -- If the alphabet has fewer than 3 letters, we just return\
    \ the string. \n  -- If the string has an odd number of letters ('abc' or 'ba'),\
    \ we \n  -- add a 'z' to the end of the string so that it has an even number.\n\
    \  -- We do that by rotating right the alphabet 3 times.\n  return alphabet:sub(1,\
    \ 1):sub(1, 1) .. \n          alphabet:sub(1, 1):sub(2, 1):sub(2, 1) .. \n   \
    \       alphabet:sub(1, 1):sub(3, 1):sub(3, 1) .. \n          alphabet:sub(2,\
    \ 1):sub(3, 1):sub(3, 1) .. \n          alphabet:sub(3, 1):sub(3, 1) .. 'z'\n\
    end", "  assert(type(t) == \"string\" and #t > 0)\n  local result = {}\n  local\
    \ count = 0\n  for i = 1, #t do\n    count = count + 1\n    local index = alphabet.find(t[i])\n\
    \    if index == nil then\n      error(\"can't find character \" .. t[i])\n  \
    \  end\n    count = count - 1\n    local alpha = alphabet[index]\n    local newIndex\
    \ = alphabet.find(alpha)\n    index = newIndex\n    index = index * 2 - 1\n  \
    \  local value = alphabet[index]\n    result[#result + 1] = value\n  end\n  return\
    \ table.concat(result)\nend", "\t-- A simple function that takes a string as an\
    \ argument and returns\n\t-- the encrypted string.\n\t-- This function encrypts\
    \ the string by rotating the alphabet by\n\t-- two places and then reversing the\
    \ encrypted string. \n\t-- We use the rotate function for this.\n\tlocal function\
    \ rotate(s)\n\t\t-- This function rotates the alphabet by two places.\n\t\t--\
    \ The output of this function will be the encrypted string of\n\t\t-- the original\
    \ string with the alphabet rotated two places.\n\t\treturn string.gsub(string.gsub(s,\
    \ \n\t\t\t-- The first argument, 'a' is a character in the alphabet.\n\t\t\t'a',\
    \ '@') + \n\t\t\t-- The second argument, 'b' is another character in the\n\t\t\
    \t-- alphabet.\n\t\t\t'b', string.sub(alphabet, math.random(1, #alphabet)) + \n\
    \t\t\t'@', \n\t\t\t'a', string.sub(alphabet, math.random(1, #alphabet)) + \n\t\
    \t\t'b', \n\t\t\t-- The third argument, 'a' is a character in the alphabet.\n\t\
    \t\t'a', '@') \n\t\tend)\n\tend", "    local alphabet = {\n        'a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\
    \ 't', 'u', 'v', 'w', 'x', 'y', 'z'\n    }\n    local rotated = {}", "    local\
    \ a = {}\n    local count = 0\n    for i = 1, #s, 2 do \n        local c = string.sub(s,i,i+2)\n\
    \        count = count + 1\n        table.insert(a, c)\n    end\n    for i = 1,\
    \ #a, 2 do\n        local c = string.sub(a,i,i+2)\n        table.insert(a, c)\n\
    \    end\n    return string.format('%s%s', a[1], a[#a])\nend", "  local alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n  local alphabet2 = \"zyxwvutsrqpoiuyz\"\n\
    \  local result = ''\n  for i = 1, #s do\n    local c = alphabet[#alphabet]\n\
    \    alphabet = alphabet2\n    alphabet2 = c\n    result = result .. (alphabet2..'z'..alphabet)\n\
    \  end\n  return result\nend", "\t-- Define the list of characters that will be\
    \ rotated\n\tlocal alphabet = {\n\t\t['A'] = 'V',\n\t\t['B'] = 'W',\n\t\t['C']\
    \ = 'X',\n\t\t['D'] = 'Y',\n\t\t['E'] = 'Z',\n\t\t['F'] = 'A',\n\t\t['G'] = 'B',\n\
    \t\t['H'] = 'C',\n\t\t['I'] = 'D',\n\t\t['J'] = 'E',\n\t\t['K'] = 'F',\n\t\t['L']\
    \ = 'G',\n\t\t['M'] = 'H',\n\t\t['N'] = 'I',\n\t\t['O'] = 'J',\n\t\t['P'] = 'K',\n\
    \t\t['Q'] = 'L',\n\t\t['R'] = 'M',\n\t\t['S'] = 'N',\n\t\t['T'] = 'O',\n\t\t['U']\
    \ = 'P',\n\t\t['V'] = 'Q',\n\t\t['W'] = 'R',\n\t\t['X'] = 'S',\n\t\t['Y'] = 'T',\n\
    \t\t['Z'] = 'U',\n\t}\n\t-- Initialize a new variable to store the encrypted string\n\
    \tlocal str = ''\n\t-- Initialize a new variable to store the index of the current\
    \ letter\n\tlocal idx = 0\n\t-- Loop through each character in the string\n\t\
    for i = 1, #s do\n\t\t-- Grab the current character\n\t\tlocal cur = s[i]\n\t\t\
    -- Check if the current character is the same as the previous character\n\t\t\
    -- If it is, move on\n\t\tif i > 1 and cur == s[i - 1] and #alphabet > 0 then\n\
    \t\t\t-- Append the previous character to the encrypted string\n\t\t\tstr = str\
    \ .. alphabet[alphabet[idx]]\n\t\t\t-- Reset the letter index \n\t\t\tidx = 0\n\
    \t\t-- Else append the current character to the encrypted string\n\t\telse\n\t\
    \t\t-- Append the current character to the encrypted string\n\t\t\tstr = str ..\
    \ cur\n\t\t\t-- Increment the letter index\n\t\t\tidx = idx + 1\n\t\tend\n\tend\n\
    \treturn str\nend", '  local alphabet = string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.',
  "  local c = ''\n  local i = 0\n  repeat\n    if s[i] == nil then\n      break\n\
    \    end\n    i = i+1\n    if i < #s then\n      c = c..tostring(s[i+1] .. tostring(s[i]\
    \ .. tostring(s[i])))\n    end\n  until i ~= #s\n  return c\nend", "    -- Add\
    \ an additional character to handle a rotate by 0 case\n    -- This character\
    \ is at the start of the alphabet\n    local alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    local alphabet = alphabet:sub(1, #alphabet-1)\n    -- A stack of characters\
    \ to encrypt\n    local char_stack = { s[1] }\n    -- The encrypted string\n \
    \   local encrypted = s[1]", "   s = tostring(s)\n   local alphabet = {\n    \
    \  ['A'] = 'B',\n      ['B'] = 'C',\n      ['C'] = 'D',\n      ['D'] = 'E',\n\
    \      ['E'] = 'F',\n      ['F'] = 'G',\n      ['G'] = 'H',\n      ['H'] = 'I',\n\
    \      ['I'] = 'J',\n      ['J'] = 'K',\n      ['K'] = 'L',\n      ['L'] = 'M',\n\
    \      ['M'] = 'N',\n      ['N'] = 'O',\n      ['O'] = 'P',\n      ['P'] = 'Q',\n\
    \      ['Q'] = 'R',\n      ['R'] = 'S',\n      ['S'] = 'T',\n      ['T'] = 'U',\n\
    \      ['U'] = 'V',\n      ['V'] = 'W',\n      ['W'] = 'X',\n      ['X'] = 'Y',\n\
    \      ['Y'] = 'Z',\n      ['Z'] = 'A',\n   }\n   for i = 1, #s do\n      local\
    \ char = s[i]:lower()\n      s = s:gsub(char, alphabet[alphabet[char] .. char])\n\
    \   end\n   return s\nend", "\tlocal alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\tlocal alphabetlength = #alphabet\n\tlocal alphaIndex = 0\n\tlocal alpha =\
    \ \"\"\n\tfor i = 1, #s do\n\t\tlocal letter = alphabet:sub(i,i)\n\t\tif alphaIndex\
    \ < alphabetlength/2 then\n\t\t\talphaIndex = alphaIndex + 2\n\t\t\talpha = alpha\
    \ .. letter\n\t\telse\n\t\t\talphaIndex = alphaIndex - 2\n\t\t\talpha = alpha\
    \ .. letter\n\t\tend\n\tend\n\t-- Convert to lowercase and remove non-alphabetic\
    \ characters.\n\talpha = alpha:lower()\n\talpha = \"\"\n\tfor i = 1, #s do\n\t\
    \tif alphabet:sub(i,i) == s then\n\t\t\talpha = alpha .. s\n\t\tend\n\tend\n\t\
    return alpha\nend", "  return s:gsub('(.)(.)', '\\\\2\\1')\nend", "    -- Step\
    \ 1: Rotate the letters by two places down.\n    s = s..\"e\"\n    s = s..\"h\"\
    \n    s = s..\"l\"\n    s = s..\"m\"\n    s = s..\"p\"\n    s = s..\"q\"\n   \
    \ s = s..\"r\"\n    s = s..\"s\"\n    s = s..\"t\"\n    -- Step 2: Rotate the\
    \ letters by two places up.\n    s = s..\"h\"\n    s = s..\"j\"\n    s = s..\"\
    k\"\n    s = s..\"l\"\n    s = s..\"m\"\n    s = s..\"n\"\n    s = s..\"o\"\n\
    \    s = s..\"p\"\n    s = s..\"q\"\n    s = s..\"r\"\n    s = s..\"s\"\n    s\
    \ = s..\"t\"\n    -- Step 3: Rotate the letters by two places down.\n    s = s..\"\
    h\"\n    s = s..\"j\"\n    s = s..\"k\"\n    s = s..\"l\"\n    s = s..\"m\"\n\
    \    s = s..\"p\"\n    s = s..\"q\"\n    s = s..\"r\"\n    s = s..\"s\"\n    s\
    \ = s..\"t\"\n    -- Step 4: Rotate the letters by two places up.\n    s = s..\"\
    h\"\n    s = s..\"j\"\n    s = s..\"k\"\n    s = s..\"l\"\n    s = s..\"m\"\n\
    \    s = s..\"p\"\n    s = s..\"q\"\n    s = s..\"r\"\n    s = s..\"s\"\n    s\
    \ = s..\"t\"\n    -- Step 5: Rotate the letters by two places down.\n    s = s..\"\
    h\"\n    s = s..\"j\"\n    s = s..\"k\"\n    s = s..\"l\"\n    s = s..\"m\"\n\
    \    s = s..\"p\"\n    s = s..\"q\"\n    s = s..\"r\"\n    s = s..\"s\"\n    s\
    \ = s..\"t\"\n    -- Step 6: Rotate the letters by two places up.\n    s = s..\"\
    h\"\n    s = s..\"j\"\n    s = s..\"k\"\n    s = s..\"l\"\n    s = s..\"m\"\n\
    \    s = s..\"p\"\n    s = s..\"q\"\n    s = s..\"r\"\n    s = s..\"s\"\n    s\
    \ = s..\"t\"\n    -- Step 7: Rotate the letters by two places down.\n    s = s..\"\
    h\"\n    s = s..\"j\"\n    s = s..\"k\"\n    s = s..\"l\"\n    s = s..\"m\"\n\
    \    s = s..\"p\"\n    s = s..\"q\"\n    s = s..\"r\"\n    s = s..\"s\"\n    s\
    \ = s..\"t\"\n    -- Step 8: Rotate the letters by two places up.\n    s = s..\"\
    h\"\n    s = s..\"j\"\n", "    local c = ''\n    local k = 2\n    local c2 = true\n\
    \    for i = 1, #s do\n        if i % 2 == 1 then\n            local c = s[i]\n\
    \            c2 = not c2\n            k = k + 2\n        end\n        if c2 then\n\
    \            c = c .. c\n        end\n    end\n    return c\nend", "   -- Initialize\
    \ and fill in a list of each letter in the alphabet\n   -- we use.\n   local alphabet\
    \ = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"}", "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local cipher = ''\n    for i, c in ipairs(s) do \n        -- if c == 'e'\
    \ then c = alphabet[i+2] end\n        -- if c == 'q' then c = alphabet[i+1] end\n\
    \        -- if c == 'g' then c = alphabet[i-1] end\n        -- if c == 'z' then\
    \ c = alphabet[i] end\n        -- if c == 'r' then c = alphabet[i+1] end\n   \
    \     -- if c == 'l' then c = alphabet[i+2] end\n        -- if c == 'f' then c\
    \ = alphabet[i+3] end\n        -- if c == 'b' then c = alphabet[i+4] end\n   \
    \     -- if c == 'o' then c = alphabet[i+5] end\n        -- if c == 'h' then c\
    \ = alphabet[i+6] end\n        -- if c == 'c' then c = alphabet[i+7] end\n   \
    \     -- if c == 'n' then c = alphabet[i+8] end\n        -- if c == 'm' then c\
    \ = alphabet[i+9] end\n        -- if c == 'p' then c = alphabet[i+10] end\n  \
    \      -- if c == 'v' then c = alphabet[i+11] end\n        -- if c == 'w' then\
    \ c = alphabet[i+12] end\n        -- if c == 'u' then c = alphabet[i+13] end\n\
    \        -- if c == 't' then c = alphabet[i+14] end\n        -- if c == 'y' then\
    \ c = alphabet[i+15] end\n        -- if c == 'j' then c = alphabet[i+16] end\n\
    \        -- if c == 'z' then c = alphabet[i+17] end\n        -- if c == 'a' then\
    \ c = alphabet[i+18] end\n        -- if c == 'e' then c = alphabet[i+19] end\n\
    \        -- if c == 't' then c = alphabet[i+20] end\n        -- if c == 'n' then\
    \ c = alphabet[i+21] end\n        -- if c == 'o' then c = alphabet[i+22] end\n\
    \        -- if c == 'k' then c = alphabet[i+23] end\n        -- if c == 'l' then\
    \ c = alphabet[i+24] end\n        -- if c == 'q' then c = alphabet[i+25] end\n\
    \        -- if c == 'd' then c = alphabet[i+26] end\n        -- if c == 'z' then\
    \ c = alphabet[i+27] end\n        -- if c == 'x' then c = alphabet[i+28] end\n\
    \        -- if c == 'w' then c = alphabet", "  local cipher = {}\n  local index\
    \ = 1\n  local n = #s\n  repeat\n    table.insert(cipher, #cipher + 1)\n    table.insert(cipher,\
    \ s[index:index+1])\n    index = index + 1\n  until #index >= n\n  return table.concat(cipher,\
    \ \"\")\nend", "   local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n   local alphabetLen\
    \ = #alphabet\n   local alphabetRotated = alphabet:sub(1, alphabetLen)\n   local\
    \ alphabetRotatedLen = #alphabetRotated\n   local result = ''\n   for i = 1, #s,\
    \ 1 do\n      local c = string.sub(s, i, i)\n      local char = string.sub(alphabetRotated,\
    \ math.abs(alphabet - c) + 1, alphabet - 1)\n      result = result .. char\n \
    \  end\n   return result\nend", "\tlocal alphabet = string.gsub(string.char(string.len(s)),\
    \ '[%s]', '{}')\n\tlocal rv = string.char(string.len(alphabet))\n\tfor i = 1,\
    \ string.len(alphabet) do\n\t\tlocal pos = alphabet .. i\n\t\tlocal char = string.sub(string.char(s),\
    \ i, i)\n\t\trv = string.sub(rv, 1, #pos) .. char\n\tend\n\treturn rv\nend", " \
    \ local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  local cipher = ''\n  for\
    \ i = #s, 1, -1 do\n    cipher = cipher .. alphabet:sub(#alphabet, 2*i):sub(1,\
    \ #alphabet):gsub(\"l\", \"z\"):gsub(\"n\", \"b\")\n  end\n  return cipher\nend",
  "    local alphabet = {\n        [\"b\"] = [\"a\", \"c\"], [\"c\"] = [\"d\", \"\
    e\"], [\"d\"] = [\"g\", \"f\"],\n        [\"e\"] = [\"h\", \"i\"], [\"f\"] = [\"\
    j\", \"k\"], [\"g\"] = [\"l\", \"m\"],\n        [\"h\"] = [\"n\", \"o\"], [\"\
    i\"] = [\"p\", \"q\"], [\"j\"] = [\"r\", \"s\"],\n        [\"k\"] = [\"t\", \"\
    u\"], [\"l\"] = [\"v\", \"w\"], [\"m\"] = [\"x\", \"y\"],\n        [\"n\"] = [\"\
    z\", \"z\"], [\"o\"] = [\"a\", \"b\"], [\"p\"] = [\"c\", \"d\"],\n        [\"\
    q\"] = [\"e\", \"f\"], [\"r\"] = [\"g\", \"h\"], [\"s\"] = [\"i\", \"j\"],\n \
    \       [\"t\"] = [\"k\", \"l\"], [\"u\"] = [\"m\", \"n\"], [\"v\"] = [\"o\",\
    \ \"p\"],\n        [\"w\"] = [\"q\", \"r\"], [\"x\"] = [\"s\", \"t\"], [\"y\"\
    ] = [\"u\", \"v\"],\n        [\"z\"] = [\"w\", \"x\"], [\"a\"] = [\"b\", \"c\"\
    ], [\"b\"] = [\"a\", \"c\"],\n        [\"c\"] = [\"d\", \"e\"], [\"d\"] = [\"\
    g\", \"f\"], [\"e\"] = [\"h\", \"i\"],\n        [\"f\"] = [\"j\", \"k\"], [\"\
    g\"] = [\"l\", \"m\"], [\"h\"] = [\"n\", \"o\"],\n        [\"i\"] = [\"p\", \"\
    q\"], [\"j\"] = [\"r\", \"s\"], [\"k\"] = [\"t\", \"u\"],\n        [\"l\"] = [\"\
    v\", \"w\"], [\"m\"] = [\"x\", \"y\"], [\"n\"] = [\"z\", \"z\"],\n        [\"\
    o\"] = [\"a\", \"b\"], [\"p\"] = [\"c\", \"d\"], [\"q\"] = [\"e\", \"f\"],\n \
    \       [\"r\"] = [\"g\", \"h\"], [\"s\"] = [\"i\", \"j\"], [\"t\"] = [\"k\",\
    \ \"l\"],\n        [\"u\"] = [\"m\", \"n\"], [\"v\"] = [\"o\", \"p\"], [\"w\"\
    ] = [\"q\", \"r\"],\n        [\"x\"] = [\"s\", \"t\"], [\"y\"] = [\"u\", \"v\"\
    ], [\"z\"] = [\"w\", \"x\"],\n    }", "   local result = ''\n   for i = 1, #s\
    \ do\n      local char = string.sub(s,i,i)\n      local new_char = string.sub(alphabet,char,char+2)\n\
    \      if not new_char then\n         new_char = char\n      end\n      result\
    \ = result .. new_char\n   end\n   return result\nend", "    local alphabet =\
    \ 'abcdefghijklmnopqrstuvwxyz'\n    local alphabet_len = #alphabet\n    local\
    \ alphabet2 = 'zyxwvutsrqponmlkjihgfedcba'\n    local alphabet2_len = #alphabet2",
  "    local alphabet = string.char 'abcdefghijklmnopqrstuvwxyz'\n    local alphabet2\
    \ = string.char 'zyxwvutsrqponmlkjihgfedcba'\n    local alphabet3 = string.char\
    \ 'zyxwvutsrqponmlkjihgfedcba'\n    local alphabet4 = string.char 'zyxwvutsrqponmlkjihgfedcba'\n\
    \    local alphabet5 = string.char 'zyxwvutsrqponmlkjihgfedcba'\n    local alphabet6\
    \ = string.char 'zyxwvutsrqponmlkjihgfedcba'\n    local alphabet7 = string.char\
    \ 'zyxwvutsrqponmlkjihgfedcba'\n    local alphabet8 = string.char 'zyxwvutsrqponmlkjihgfedcba'\n\
    \    local alphabet9 = string.char 'zyxwvutsrqponmlkjihgfedcba'", "    local alphabet\
    \ = {string.letters, string.letters, string.letters}\n    local n = 0\n    local\
    \ output = ''\n    local function encrypt(s, alphabet, n)\n        local alphabets\
    \ = {alphabet, '', alphabet}\n        local ns = {n, '', n}\n        local output\
    \ = ''\n        local i = 1\n        local j = 1\n        while i <= #s do\n \
    \           while j <= #alphabets do\n                local letter = alphabets[j][(ns[i])\
    \ % (#alphabets[j])]\n                output = output .. letter\n            \
    \    i = i + 1\n                j = (j + 2) % (#alphabets)\n            end\n\
    \            output = output .. alphabets[1][n] .. alphabets[2][n]\n         \
    \   ns[i] = (ns[i] + 1) % (#alphabets[1])\n            ns[j] = (ns[j] + 1) % (#alphabets[2])\n\
    \        end\n        return output\n    end\n    return encrypt(s, alphabet,\
    \ n)\nend", "  local c = 'abcdefghijklmnopqrstuvwxyz'\n  local c1 = {}\n  for\
    \ i=1,#s do\n    c1[i] = c[(#c-i-1)*2+i]\n  end\n  \n  local alpha = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \  local alphalen = #alpha\n  local k = ''\n  \n  -- Go through each character\
    \ in the string\n  for i in 1,#s do\n    -- Get the index in the alphabet for\
    \ the current letter\n    local l = (#c-i-1)*2\n    -- Get the index in the alphabet\
    \ for the previous letter\n    local k = k+1\n    -- Get the index in the alphabet\
    \ for the next letter\n    local m = alpha[alphalen]\n    -- Get the character\
    \ in the alphabet that is being swapped\n    -- (i.e. the letter being rotated)\
    \ \n    local c = c1[(i-1) + alphalen]\n    -- Perform the swap\n    if k > 0\
    \ then\n      c = c1[l]\n      c1[l] = c1[k]\n      c1[k] = c\n    end\n    \n\
    \    -- Append the character that is being rotated\n    k = k + alphalen\n   \
    \ \n    -- Append the character in the alphabet that is \n    -- being swapped\
    \ to the end of the string\n    if k > 0 then\n      k = k-1\n      k = k + alphalen\n\
    \      k = k + alphalen\n      k = k + alphalen\n      k = k + alphalen\n    \
    \  k = k + alphalen\n      k = k + alphalen\n    end\n    k = k + c\n    k = k\
    \ + c\n    k = k + c\n    k = k + c\n    k = k + c\n    k = k + c\n    k = k +\
    \ c\n    k = k + c\n    k = k + c\n    k = k + c\n    k = k + c\n    k = k + c\n\
    \    k = k + c\n    k = k + c\n    k = k + c\n    k = k + c\n    k = k + c\n \
    \   k = k + c\n    k = k + c\n    k = k + c\n    k = k + c\n    k = k + c\n  \
    \  k = k + c\n    k = k + c\n    k = k + c\n    k = k + c\n    k = k + c\n   \
    \ k = k + c\n    k = k + c\n    k = k + c\n    k = k + c\n    k = k + c\n    k\
    \ = k", "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local alphabetRev\
    \ = alphabet:reverse()\n  local shift1 = alphabet .. alphabetRev\n  local shift2\
    \ = alphabetRev .. alphabet\n  return shift2:sub(1,2):sub(1,1):sub(2):sub(3,1):sub(3)\
    \ ..\n    shift1:sub(1,1):sub(2,1):sub(3,1):sub(4,1)\nend", "  local alphabet\
    \ = {\n  -- The space character is added to the alphabet to prevent a\n  -- collision\
    \ with the space character which has the value of 32.\n  ' ',\n  'a',\n  'b',\n\
    \  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i',\n  'j',\n  'k',\n  'l',\n\
    \  'm',\n  'n',\n  'o',\n  'p',\n  'q',\n  'r',\n  's',\n  't',\n  'u',\n  'v',\n\
    \  'w',\n  'x',\n  'y',\n  'z'\n  }\n  -- Convert the string into a list of characters.\n\
    \  local chars = s:gsub(\"[^\"..alphabet..\"]\", \"\")\n  -- Add 32 to each character\
    \ in alphabet to prevent a collision with\n  -- space and prevent a shifted letter's\
    \ value from being > 32.\n  for i = 1, #alphabet do\n    alphabet[alphabet[i]]\
    \ = alphabet[alphabet[i]] + 32\n  end\n  -- Shift the values by two to the left\
    \ and concatenate them.\n  return alphabet[alphabet[#alphabet] - 2]..chars\nend",
  "  -- First we rotate the string's letters by two.\n  s = string.gsub(s, 'a','z')\n\
    \  s = string.gsub(s, 'b','t')\n  s = string.gsub(s, 'c','f')\n  s = string.gsub(s,\
    \ 'd','g')\n  s = string.gsub(s, 'e','h')\n  s = string.gsub(s, 'f','i')\n  s\
    \ = string.gsub(s, 'g','j')\n  s = string.gsub(s, 'h','k')\n  s = string.gsub(s,\
    \ 'i','l')\n  s = string.gsub(s, 'j','m')\n  s = string.gsub(s, 'k','n')\n  s\
    \ = string.gsub(s, 'l','o')\n  s = string.gsub(s, 'm','p')\n  s = string.gsub(s,\
    \ 'n','q')\n  s = string.gsub(s, 'o','r')\n  s = string.gsub(s, 'p','s')\n  s\
    \ = string.gsub(s, 'q','t')\n  s = string.gsub(s, 'r','u')\n  s = string.gsub(s,\
    \ 's','v')\n  s = string.gsub(s, 't','w')\n  s = string.gsub(s, 'u','x')\n  s\
    \ = string.gsub(s, 'v','y')\n  s = string.gsub(s, 'w','z')\n  return s\nend",
  "    local alphabet_count = #alphabet\n    local new_alphabet = alphabet\n    local\
    \ new_key = ''\n    local i, count = 1, 1\n    \n    while i <= #s do\n      \
    \  local c = string.sub(s,i,i)\n        \n        if c == ' ' then\n         \
    \   new_key = new_key .. ' '\n        else\n            new_key = new_key .. new_alphabet[((alphabet_count\
    \ + count) % (alphabet_count + 1))]\n            count = count + 1\n        end\n\
    \        \n        i = i + 1\n    end\n    \n    return new_key\nend\n</code>\n\
    <|/ a tags=encryption,python,lua |>\n<| c |>\nWhile this does work, it is highly\
    \ inefficient as you are creating two copies of the alphabet, where it would be\
    \ much more efficient to just have a single copy and rotate the single copy.\n\
    <|/ c |>\n<| c |>\nThank you for the feedback, I'll take a closer look and optimize\
    \ my answer if I can come up with a better one.\n<|/ c |>\n<| a dscore=1 |>\n\
    The question is a little unclear, but perhaps this will help.\nHere's an implementation\
    \ that uses a single string as input, and a single string as the output:\n<code>",
  "  local c=0\n  local prev=c\n  local c\n  for i=1,#s do\n    c=prev + s[i]\n  \
    \  prev=c\n  end\n  return prev\nend", "    local alphabet = {\n        ['A']\
    \ = 3,\n        ['B'] = 1,\n        ['C'] = 2,\n        ['D'] = 4,\n        ['E']\
    \ = 5,\n        ['F'] = 6,\n        ['G'] = 7,\n        ['H'] = 8,\n        ['I']\
    \ = 9,\n        ['J'] = 10,\n        ['K'] = 11,\n        ['L'] = 12,\n      \
    \  ['M'] = 13,\n        ['N'] = 14,\n        ['O'] = 15,\n        ['P'] = 16,\n\
    \        ['Q'] = 17,\n        ['R'] = 18,\n        ['S'] = 19,\n        ['T']\
    \ = 20,\n        ['U'] = 21,\n        ['V'] = 22,\n        ['W'] = 23,\n     \
    \   ['X'] = 24,\n        ['Y'] = 25,\n        ['Z'] = 26,\n        ['-'] = 27,\n\
    \        ['='] = 28,\n        ['!'] = 29,\n        ['.'] = 30,\n        ['?']\
    \ = 31,\n        [' '] = 32,\n    }\n    local alphabetLength = #alphabet", " \
    \ local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  s = s:upper()\n  local shift\
    \ = alphabet:sub(1, 1)\n  return alphabet:sub(1, alphabet:len() - shift)..alphabet:sub(0,\
    \ alphabet:len() - shift)\nend", "  -- Create a variable called rotated that holds\
    \ the alphabet rotated by\n  -- the number of letters in the string. \n  -- Then\
    \ shift each letter in the alphabet down two places.\n  -- Then use that to rotate\
    \ the whole alphabet by two.\n  local rotated = string.char(string.sub(ALPHABET,\
    \ 0, string.len(s)))\n  for i = string.len(s) - 1, -1, -1 do\n    rotated = rotated\
    \ .. string.sub(ALPHABET, i + 1, i)\n  end\n  return rotated .. string.sub(ALPHABET,\
    \ string.len(s) - 1)\nend", "  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  local rotate_alphabet = string.gsub(alphabet, \n    \"a\", \"@\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"b\", \"1\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"c\", \"2\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"d\", \"3\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"e\", \"4\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"f\", \"5\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"g\", \"6\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"h\", \"7\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"i\", \"8\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"j\", \"9\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"k\", \"0\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"l\", \"@\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"m\", \"1\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"n\", \"2\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"o\", \"3\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"p\", \"4\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"q\", \"5\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"r\", \"6\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"s\", \"7\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"t\", \"8\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"u\", \"9\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"v\", \"0\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"w\", \"@\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"x\", \"1\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"y\", \"2\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"z\", \"3\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"0\", \"4\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"@\", \"a\")\n  local\
    \ rotate_alphabet = string.gsub(rotate_alphabet, \n    \"1\", \"b\")\n  local ",
  "  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  s = string.lower(s)\n  local\
    \ c = ''\n  for i = #alphabet, 1, -1 do -- loop through string\n    local char\
    \ = alphabet:sub(i,i) -- get the i-th character\n    if char == ' ' then -- if\
    \ it's a space, put in the space\n      c = c .. ' '\n    else\n      local val\
    \ = string.byte(s,i) % alphabet -- get the value of this character mod 26\n  \
    \    c = c .. alphabet:sub(val,val) -- get the character that is at this position\
    \ from the alphabet\n    end\n  end\n  return c\nend", "   -- Write your code\
    \ in here\n   assert(#s==3,'The input should be of size 3')\n   local t=''\n \
    \  local alphabet={'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \   for i=1, #s, 1 do\n      t=t..alphabet[(#alphabet)+((2*i)-1)]\n   end\n  \
    \ return t\nend", "    local alpha = {\n        -- The characters should be rotated\
    \ so that the letters move down\n        -- by 2 when rotated left-to-right.\n\
    \        {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'},\n        {'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v'},\n        {'w', 'x', 'y',\
    \ 'z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'},\n        {'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't'},\n        {'u', 'v', 'w', 'x', 'y',\
    \ 'z', 'a', 'b', 'c', 'd', 'e', 'f'},\n        {'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's'},\n        {'t', 'u', 'v', 'w', 'x', 'y',\
    \ 'z', 'a', 'b', 'c', 'd', 'e', 'f'},\n        {'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's'},\n        {'t', 'u', 'v', 'w', 'x', 'y',\
    \ 'z', 'a', 'b', 'c', 'd', 'e', 'f'},\n        {'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's'},\n        {'t', 'u', 'v', 'w', 'x', 'y',\
    \ 'z', 'a', 'b', 'c', 'd', 'e', 'f'},\n        {'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's'},\n        {'t', 'u', 'v', 'w', 'x', 'y',\
    \ 'z', 'a', 'b', 'c', 'd', 'e', 'f'},\n        {'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's'},\n        {'t', 'u', 'v', 'w', 'x', 'y',\
    \ 'z', 'a', 'b', 'c', 'd', 'e', 'f'},\n        {'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's'},\n        {'t', 'u', 'v', 'w', 'x', 'y',\
    \ 'z', 'a', 'b', 'c', 'd', 'e', 'f'},\n        {'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's'},\n        {'t', 'u', 'v', 'w', 'x', 'y',\
    \ 'z', 'a', 'b', 'c', 'd', 'e', 'f'},\n        {'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's'},\n        {'t', 'u', 'v', 'w', 'x', 'y',\
    \ 'z', 'a', 'b', 'c', 'd', 'e', 'f'},\n        {'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's'},\n        {'t', 'u', 'v', 'w', 'x', 'y',\
    \ 'z', 'a', 'b', 'c', 'd', 'e', 'f'},\n        {'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's'},\n        {'t', 'u', 'v', 'w', 'x', 'y',\
    \ 'z', 'a', 'b', 'c', '", "  -- Make sure the string is non-empty\n  if not s\
    \ then return nil end", "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n \
    \   local n = 1\n    for i = 1, #s do\n        local c = alphabet:sub(i, i)\n\
    \        alphabet = alphabet:sub(i, i - #c)\n        n = n * #c + c\n    end\n\
    \    return alphabet:sub(1, #alphabet) * (math.floor(n/#alphabet) + 1)\nend",
  "    local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    local newS = string.gsub(string.gsub(s,\"\
    (%w)\",\n                    function(c) \n                        return alphabet:sub((alphabet.index(c)+2)%26+1,\
    \ alphabet.index(c)+1):sub(1,1)\n                    end),\"(%w)\",\n        function(c)\
    \ \n            return alphabet:sub((alphabet.index(c)+2)%26+1, alphabet.index(c)+1):sub(1,1)\n\
    \        end)\n    return newS\nend", "  s = string.lower(s)\n  local alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n  local n = #alphabet\n  local c = ''\n  local\
    \ i = 0\n  local n = #s\n  while i < n do \n    c = alphabet[(alphabet.find(s)\
    \ + i) % n]\n    s = string.sub(s,1,1) + c + string.sub(s,2,2)\n    i = i + 1\n\
    \  end\n  return s\nend", "  local alphabet = {\n    ['a'] = 'z', \n    ['b']\
    \ = 'y', \n    ['c'] = 'x', \n    ['d'] = 'w', \n    ['e'] = 'v', \n    ['f']\
    \ = 'u', \n    ['g'] = 't',\n    ['h'] = 's',\n    ['i'] = 'r',\n    ['j'] = 'q',\n\
    \    ['k'] = 'p',\n    ['l'] = 'o',\n    ['m'] = 'n',\n    ['n'] = 'm',\n    ['o']\
    \ = 'l',\n    ['p'] = 'k',\n    ['q'] = 'j',\n    ['r'] = 'i',\n    ['s'] = 'h',\n\
    \    ['t'] = 'g',\n    ['u'] = 'f',\n    ['v'] = 'e',\n    ['w'] = 'd',\n    ['x']\
    \ = 'c',\n    ['y'] = 'b',\n    ['z'] = 'a'\n  }\n  \n  -- Encrypt string s.\n\
    \  -- This should be an O(n) operation because, for each letter in the alphabet,\
    \ \n  -- the entire alphabet is iterated over.\n  -- This means we will perform\
    \ O(len(alphabet)) operations to do so.\n  -- We can make this go faster if we\
    \ have a way to hash the string s.\n  local cipher = ''\n  for i = 1, #s do\n\
    \    local c = alphabet[s[i]] -- Lookup current letter in the alphabet.\n    cipher\
    \ = cipher .. c\n    alphabet[c] = alphabet[#alphabet] -- Shift letter to the\
    \ left one position.\n    alphabet[#alphabet] = c -- Shift letter right one position.\n\
    \  end\n  return cipher\nend", "  local alphabet = s:gsub('[a-z]', '..'):gsub('[A-Z]',\
    \ '..')\n  return alphabet:gsub('..', '[A-Z]')\nend", "  -- Create a string that\
    \ has the first letter in the string rotate twice \n  -- to the right to account\
    \ for the shift\n  local rotated = s:sub(1, 1) .. s:sub(2, 2) .. s:sub(3, 3) ..\
    \ s:sub(4, 4)\n  \n  -- Now rotate the string to the right by two characters and\
    \ return it\n  return rotated:sub(1, 1) .. rotated:sub(2, 2) .. rotated:sub(3,\
    \ 3) .. rotated:sub(4, 4)\nend\n</code>\n<|/ a |>\n<| a tags=string,lua,algorithm\
    \ |>\nThis is one way to do it:\n<code>", "    local alphabet = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \    local encrypted = {}\n    local j = 0\n    for i = 1, #s do -- loop through\
    \ each character in the string\n        j = j % #alphabet -- rotate by one letter\n\
    \        encrypted[i] = alphabet[j]\n        alphabet[j] = alphabet[j+1]\n   \
    \ end\n    return table.concat(encrypted)\nend\n</code>\n<|/ a dscore=4 |>\n<|\
    \ a |>\n<code>"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
