name: HumanEval_78_hex_key
language: lua
prompt: "-- You have been tasked to write a function that receives \n-- a hexadecimal\
  \ number as a string and counts the number of hexadecimal \n-- digits that are primes\
  \ (prime number, or a prime, is a natural number \n-- greater than 1 that is not\
  \ a product of two smaller natural numbers).\n-- Hexadecimal digits are 0, 1, 2,\
  \ 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n-- Prime numbers are 2, 3, 5, 7, 11, 13,\
  \ 17,...\n-- So you have to determine a number of the following digits: 2, 3, 5,\
  \ 7, \n-- B (=decimal 11), D (=decimal 13).\n-- Note: you may assume the input is\
  \ always correct or empty string, \n-- and symbols A,B,C,D,E,F are always uppercase.\n\
  -- Examples:\n-- >>> hex_key('AB')\n-- 1\n-- >>> hex_key('1077E')\n-- 2\n-- >>>\
  \ hex_key('ABED1A33')\n-- 4\n-- >>> hex_key('123456789ABCDEF0')\n-- 6\n-- >>> hex_key('2020')\n\
  -- 2\nlocal function hex_key(num)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = hex_key\n\
  \    lu.assertEquals(candidate('AB'), 1)\n    lu.assertEquals(candidate('1077E'),\
  \ 2)\n    lu.assertEquals(candidate('ABED1A33'), 4)\n    lu.assertEquals(candidate('2020'),\
  \ 2)\n    lu.assertEquals(candidate('123456789ABCDEF0'), 6)\n    lu.assertEquals(candidate('112233445566778899AABBCCDDEEFF00'),\
  \ 12)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if num == nil or num == \"\" then\n    return nil\n  end\n  local\
    \ key = tonumber(num)\n  if key == nil then\n    return nil\n  end\n  \n  local\
    \ num_dig = math.log10(key)+1\n  local is_prime = false\n  local is_a = false\n\
    \  local is_b = false\n  local is_c = false\n  local is_d = false\n  local is_e\
    \ = false\n  local is_f = false\n  local is_g = false\n  local is_h = false\n\
    \  local is_i = false\n  local is_j = false\n  local is_k = false\n  local is_l\
    \ = false\n  local is_m = false\n  local is_n = false\n  local is_o = false\n\
    \  local is_p = false\n  local is_q = false\n  local is_r = false\n  local is_s\
    \ = false\n  local is_t = false\n  local is_u = false\n  local is_v = false\n\
    \  local is_w = false\n  local is_x = false\n  local is_y = false\n  local is_z\
    \ = false\n  local digit_sum = 0\n  local digit_sum2 = 0\n  \n  for i = 1,num_dig\
    \ do\n    local a = tonumber(string.format(\"%0*X\",num_dig,key))\n    local b\
    \ = tonumber(string.format(\"%0*X\",num_dig,key))\n    local c = tonumber(string.format(\"\
    %0*X\",num_dig,key))\n    local d = tonumber(string.format(\"%0*X\",num_dig,key))\n\
    \    local e = tonumber(string.format(\"%0*X\",num_dig,key))\n    local f = tonumber(string.format(\"\
    %0*X\",num_dig,key))\n    local g = tonumber(string.format(\"%0*X\",num_dig,key))\n\
    \    local h = tonumber(string.format(\"%0*X\",num_dig,key))\n    local i = tonumber(string.format(\"\
    %0*X\",num_dig,key))\n    local j = tonumber(string.format(\"%0*X\",num_dig,key))\n\
    \    local k = tonumber(string.format(\"%0*X\",num_dig,key))\n    local l = tonumber(string.format(\"\
    %0*X\",num_dig,key))\n    local m = tonumber(string.format(\"%0*X\",num_dig,key))\n\
    \    local n = tonumber(string.format(\"%0*X\",num_dig,key))\n    local o = tonumber(string.format(\"\
    %0*X\",num_dig,key))\n    local p = tonumber(string.format(\"%0", "  return tonumber(num)\n\
    end", "  local count_dict = {}\n  local hexa_count = 1\n  local hex_digit\n  for\
    \ i = 1, #num do\n    hex_digit = tostring(num:sub(i,i))\n    count_dict[hex_digit]\
    \ = count_dict[hex_digit]+1 or 1\n  end\n  for hex_digit, count in pairs(count_dict)\
    \ do\n    if count == 2 then hexa_count = hexa_count + 1 end\n  end\n  return\
    \ hexa_count\nend", "  local num_digits = tonumber(num)\n  if num_digits == nil\
    \ then\n    return 'error'\n  end", "\t-- Convert string to integer and make sure\
    \ it's positive.\n\tnum = tonumber(num)\n\tif num < 0 then \n\t\terror(\"String\
    \ must be positive\")\n\tend", "    local function d(x)\n        return math.floor(math.log(x)\
    \ / math.log(16))\n    end\n    local function p(x)\n        return x % 2 == 1\
    \ and 0 or 1\n    end\n    local function n(x, i)\n        local y = x\n     \
    \   for i=1, #num+1 do\n            y = y*16^d(num[i])\n        end\n        return\
    \ p(x)+y(x)\n    end\n    return n(num, 1)\nend", "  if num then\n    for i=1,#num,2\
    \ do\n      local hex=tonumber(sub(num,i,i+1))\n      local prime=hex+hex+hex+hex+hex+hex+hex+hex+hex+hex+hex+hex+hex+hex\n\
    \      if prime < 2 then\n        prime=prime+1\n      end\n      if prime==hex+hex+hex+hex+hex+hex+hex+hex+hex+hex+hex+hex+hex\
    \ then\n        return i\n      end\n    end\n  end\n  return 0\nend", "  -- Reserve\
    \ the first 4 digits for 0X and other characters for alphabetical characters.\n\
    \  -- There are a total of 5 characters for hexadecimal digits: 0-9, A-F\n  --\
    \ But we ignore the alphabetical characters, because the number would never reach\
    \ \n  -- the length of hexadecimal digits.\n  local digit_table = string.char(0x00,\
    \ 0xFF)\n  -- Count the number of hexadecimal digits in the input\n  local hex_count\
    \ = string.len(num)\n  -- Initialization: We assume no prime numbers in the input\n\
    \  local num_primes = 0\n  -- Initialization: We assume no primes in the input\n\
    \  local num_prime = 0\n  -- Initialization: We assume no prime numbers in the\
    \ input greater than the number\n  -- of hexadecimal digits\n  local hex_digit_max_value\
    \ = hex_count\n  -- Initialization: Assume no prime numbers in the input greater\
    \ than the number\n  -- of hexadecimal digits\n  local hex_digit_max_value_prime\
    \ = 0\n  -- Initialization: Assume no prime numbers in the input greater than\
    \ the number\n  -- of hexadecimal digits\n  local hex_digit_max_value_prime_prime\
    \ = 0", "   if not num then return end\n   if num:sub(1,1) == #num and #num <=\
    \ 4 then\n      local a, b, c, d = tonumber(num, 16)\n      local i = b\n    \
    \  while i <= c do\n         local j = i + d\n         if j <= c then\n      \
    \      local k = j\n            while k <= c do\n               if j % k == 0\
    \ then\n                  return k\n               end\n               k = k +\
    \ 1\n            end\n         end\n         i = i + 1\n      end\n      return\
    \ nil\n   elseif #num >= 10 then\n      local a, b, c, d, e, f = tonumber(num,\
    \ 16)\n      local i = a\n      while i <= b do\n         local j = i + d\n  \
    \       if j <= b then\n            local k = j\n            while k <= b do\n\
    \               if j % k == 0 then\n                  return k\n             \
    \  end\n               k = k + 1\n            end\n         end\n         i =\
    \ i + 1\n      end\n      return nil\n   end\n   return nil\nend", "  local n\
    \ = 0\n  local cnt = 0\n  local last = ''\n  for c in string.gmatch(num, '%x')\
    \  do\n    local v = tonumber(c, 16)\n    if v == nil then return nil end\n  \
    \  \n    if last == 'F' then return nil end\n    last = tonumber(c, 16)\n    local\
    \ g = math.floor(v / 3)\n    v = v - g * 3\n    cnt = cnt + 1\n  end \n  return\
    \ cnt\nend", "    local key_counts = {}\n    local prime_candidates = { 2, 3 }\n\
    \    local prime_divisors = {}\n    local total_hex = 0\n    local hex_count =\
    \ 0\n    local is_prime = false\n    local digit_counts = {}\n    for i = 1, #num,\
    \ 1 do\n        local digit = tonumber(num[i])\n        digit_counts[digit] =\
    \ digit_counts[digit] or 0\n        digit_counts[digit] = digit_counts[digit]\
    \ + 1\n        if digit > 0 then\n            is_prime = not is_prime\n      \
    \  end\n        total_hex = total_hex + digit\n    end\n    for i = 2, #prime_candidates,\
    \ 1 do\n        if digit_counts[prime_candidates[i]] <= 3 then\n            prime_divisors[i]\
    \ = digit_counts[prime_candidates[i]]\n        end\n    end\n    local prime_candidate\
    \ = prime_candidates[1]\n    for i = 2, #prime_candidates, 1 do\n        if prime_candidate\
    \ == prime_divisors[i] then\n            prime_candidate = prime_candidates[i]\n\
    \        else\n            break\n        end\n    end\n    local prime_divisors_copy\
    \ = {}\n    for i = 1, #prime_divisors, 1 do\n        prime_divisors_copy[i] =\
    \ prime_divisors[i]\n    end\n    for i = #prime_divisors_copy, #prime_candidates,\
    \ 1 do\n        prime_divisors_copy[#prime_divisors_copy + i] = prime_candidates[i]\n\
    \    end\n    local next_prime = prime_candidate\n    for i = #prime_divisors_copy,\
    \ #prime_candidates, 1 do\n        local next_divisor = prime_divisors_copy[i]\n\
    \        if next_divisor > next_prime then\n            next_prime = next_divisor\n\
    \        end\n    end\n    local next_prime_copy = {}\n    for i = 1, #prime_candidates,\
    \ 1 do\n        next_prime_copy[i] = next_prime\n    end\n    local prime_candidate_index\
    \ = 1\n    while prime_candidate_index <= #prime_candidates do\n        for i\
    \ = prime_candidate_index + 1, #prime_candidates, 1 do\n            if prime_divisors_copy[i]\
    \ == next_prime_copy[i] then\n                next_prime_copy[i] = prime_candidates[i]\n\
    \            end\n        end\n        prime_candidate_index = prime_candidate_index\
    \ + 1\n    end\n    for i = 1, #prime_candidates, 1 do\n        if prime_divisors_copy[i]\
    \ > next_prime then\n            next_prime = prime_divisors_copy[i]\n       \
    \ end\n    end\n    local total_hex_copy = 0\n    for i = 1, #total_hex, 1 do\n\
    \        total_hex_copy = total_hex_copy + digitto", "  local count = 0\n  \n\
    \  -- Your code here\n  \n  return count\nend", "    local key_num = 0\n    local\
    \ hex = '0123456789ABCDEF'\n    local digits = ''\n    for i = 1, #num do\n  \
    \      if hex:sub(i,i) = '0' then\n            key_num = key_num + 1\n       \
    \     digits = digits .. hex:sub(i,i)\n        elseif hex:sub(i,i) ~= '0' then\n\
    \            break\n        end\n    end\n    return key_num\nend", "    local\
    \ i, count = 0\n    while num:len() ~= 0 do\n        count = count + 1\n     \
    \   num = num:sub(1,1)\n    end\n    if count <= 4 then\n        return count\n\
    \    end\n    if count > 4 then\n        return nil\n    end\n    local p = {\n\
    \        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97,\n    }\n    local tt = {}\n    for i = 2, count do\n\
    \        local t = #p\n        while t > 0 do\n            local k = math.floor(math.log(t,2)\
    \ / 3)\n            if k:len() == 0 then\n                return nil\n       \
    \     end\n            local p = t\n            if tt == nil then\n          \
    \      tt[k] = p\n            else\n                local a = tt[k-1]\n      \
    \          local b = tt[k]\n                tt[k] = (a + b) /2\n             \
    \   if tt[k] == t then\n                    tt[k] = 0\n                end\n \
    \           end\n            if p > t then\n                p = p - t\n      \
    \      else\n                t = t - 1\n            end\n        end\n    end\n\
    \    local ret = 1\n    for i = 2, #p do\n        local c = tt[i]\n        if\
    \ c ~= nil then\n            if ret > c then\n                ret = c\n      \
    \      end\n        end\n    end\n    return ret\nend", "    num = string.lower(num)\n\
    \    local digits, i = 1, 1\n    while i < #num do\n        local d = string.byte(num,\
    \ i)\n        if d <= '7' then\n            digits = digits + 1\n        elseif\
    \ d == 'A' or d == 'B' or d == 'C' or d == 'D' or d == 'E' or d == 'F' then\n\
    \            return digits * 2\n        end\n        i = i + 1\n    end\n    return\
    \ nil\nend", "\tnum = string.lower(num)\n\tlocal count_hex = 0\n\tlocal count_digit\
    \ = 0\n\tfor i = 1, #num do\n\t\tlocal a = string.byte(num, i)\n\t\tlocal b =\
    \ string.byte(num, i + 1)\n\t\tif a == 0 and b == 0 then\n\t\t\tcount_digit =\
    \ count_digit + 1\n\t\telseif b == 0 then\n\t\t\tif a ~= 1 and a ~= 0 then\n\t\
    \t\t\tcount_digit = count_digit + 1\n\t\t\telseif count_digit == 2 then\n\t\t\t\
    \tcount_digit = 0\n\t\t\t\tcount_hex = count_hex + 1\n\t\t\tend\n\t\telseif a%2\
    \ == 1 and b%2 == 1 and a < b then\n\t\t\tcount_digit = count_digit + 1\n\t\t\
    end\n\tend\n\treturn count_hex\nend", "  local n=0\n  local n_digits=#num\n  local\
    \ prime=3\n  local prime2=0\n  local prime3=0\n  local prime5=0\n  local prime7=0\n\
    \  local prime11=0\n  local prime13=0\n  local prime17=0\n  local prime19=0\n\
    \  local prime23=0\n  local prime29=0\n  local prime31=0\n  local prime37=0\n\
    \  local prime41=0\n  local prime43=0\n  local prime47=0\n  local prime53=0\n\
    \  local prime59=0\n  local prime61=0\n  local prime67=0\n  local prime71=0\n\
    \  local prime73=0\n  local prime79=0\n  local prime83=0\n  local prime89=0\n\
    \  local prime97=0\n  local prime101=0\n  local prime107=0\n  local prime113=0\n\
    \  local prime119=0\n  local prime121=0\n  local prime127=0\n  local prime131=0\n\
    \  local prime137=0\n  local prime141=0\n  local prime145=0\n  local prime147=0\n\
    \  local prime151=0\n  local prime157=0\n  local prime163=0\n  local prime169=0\n\
    \  local prime171=0\n  local prime177=0\n  local prime181=0\n  local prime187=0\n\
    \  local prime191=0\n  local prime197=0\n  local prime203=0\n  local prime209=0\n\
    \  local prime211=0\n  local prime217=0\n  local prime221=0\n  local prime227=0\n\
    \  local prime231=0\n  local prime237=0\n  local prime241=0\n  local prime245=0\n\
    \  local prime247=0\n  local prime251=0\n  local prime257=0\n  local prime263=0\n\
    \  local prime269=0\n  local prime271=0\n  local prime277=0\n  local prime281=0\n\
    \  local prime287=0\n  local prime293=0\n  local prime299=0\n  local prime301=0\n\
    \  local prime307=0\n  local prime311=0\n  local prime317=0\n  local prime323=0\n\
    \  local prime329=0\n  local prime331=0\n  local prime337=0\n  local prime341=0\n\
    \  local prime347=0\n  local prime351=0\n  local prime", "\tnum = string.upper(num)\n\
    \tlocal digit_count = {}\n\tfor i = 1, #num do\n\t\tdigit_count[string.byte(num,\
    \ i)] = digit_count[string.byte(num, i)] or 0\n\tend\n\tlocal prime_count = 1\n\
    \tlocal prime = prime_count\n\tlocal hex_count = 0\n\tlocal i = 0\n\twhile prime_count\
    \ <= prime:len() do\n\t\tlocal j\n\t\tprime_count = prime -- update primality\
    \ count\n\t\tprime = string.gsub(prime, '([^%s])', '')\n\t\tlocal prime_sum =\
    \ 1\n\t\tfor j = 2, #prime do -- prime number sum calculation\n\t\t\tprime_sum\
    \ = (prime_sum * 2) + (string.byte(prime, j) - 48)\n\t\tend\n\t\tfor j = 2, #num\
    \ do\n\t\t\tif j % prime_sum == 0 then\n\t\t\t\tdigit_count[string.byte(prime,\
    \ j)]\n\t\t\tend\n\t\tend\n\t\tfor i = 2, #digit_count do\n\t\t\tif digit_count[i]\
    \ ~= 0 then\n\t\t\t\thex_count = hex_count + 1\n\t\t\t\tdigit_count[i] = digit_count[i]\
    \ - 1\n\t\t\tend\n\t\tend\n\tend\n\treturn hex_count\nend", "  local prime_digits\
    \ = {}\n  local prime = 0\n  local key = 0\n  local digit_count = 1\n  for i =\
    \ 1, #num, 1 do\n    local digit = string.sub(num,i,i)\n    if digit == \"A\"\
    \ then\n      prime = 11\n      digit_count = 1\n    elseif digit == \"B\" then\n\
    \      prime = 13\n      digit_count = 1\n    elseif digit == \"C\" then\n   \
    \   prime = 17\n      digit_count = 1\n    elseif digit == \"D\" then\n      prime\
    \ = 23\n      digit_count = 1\n    elseif digit == \"E\" then\n      prime = 29\n\
    \      digit_count = 1\n    elseif digit == \"F\" then\n      prime = 33\n   \
    \   digit_count = 1\n    elseif digit == \"0\" then\n      prime = 59\n      digit_count\
    \ = 1\n    else\n      prime = math.floor(math.log(math.abs(digit), 10))\n   \
    \   if prime ~= 1 and prime ~= 3 then\n        prime = nil\n      elseif prime\
    \ == 3 then\n        prime = prime_digits[prime]\n      end\n    end\n    if prime\
    \ ~= nil then\n      prime_digits[prime] = digit_count\n      if prime == 3 then\n\
    \        prime = prime_digits[prime]\n      end\n      if prime == nil and digit_count\
    \ == 1 then\n        prime = nil\n      end\n      if prime ~= nil and prime >\
    \ 1 then\n        digit_count = 2\n      end\n      key = key + prime * digit_count\n\
    \    end\n    if digit_count == 2 and prime == nil and #prime_digits == 0 then\n\
    \      key = key + 1\n    end\n  end\n  return key\nend", "\t-- Your code here\n\
    end", "    local primes = {}\n    local i = 1\n    for s in string.gmatch(string.gsub(num,\
    \ '%X', ''), '%X') do\n        if string.len(s) == 2 then\n            primes[i]\
    \ = s[1]\n            i = i + 1\n        else\n            primes[i] = nil\n \
    \       end\n    end\n    local res = 1\n    for i = 2,#primes do\n        if\
    \ primes[i] == nil then\n            local count = 0\n            for j = 2,#num/2\
    \ do\n                if string.sub(num, i*j, i*j) == string.sub(num, i*j+1, i*j+1)\
    \ then\n                    count = count + 1\n                end\n         \
    \   end\n            if count == #num/2 then\n                res = i\n      \
    \          break\n            end\n        end\n    end\n    return res\nend",
  "    local num_len = #num\n    local digits = {}\n    for i = 1, num_len do\n  \
    \      local tmp = string.byte(num, i)\n        if tmp == 0 or string.byte(num,\
    \ i) == A or string.byte(num, i) == B or string.byte(num, i) == C or string.byte(num,\
    \ i) == D or string.byte(num, i) == E or string.byte(num, i) == F then\n     \
    \       return nil\n        else\n            table.insert(digits, tmp)\n    \
    \    end\n    end\n    \n    local count = 0\n    local cur = 1\n    local prime_count\
    \ = 0\n    local prime = 1\n    for i = 1, num_len do\n        prime_count = prime_count\
    \ + 1\n        if digits[i] == A and digits < prime_count then\n            prime_count\
    \ = prime_count\n            prime = prime + 1\n        elseif digits[i] == D\
    \ and digits < prime_count then\n            prime_count = prime_count\n     \
    \       prime = prime + 1\n        else\n            count = count + 1\n     \
    \   end\n    end\n    \n    if count > 2 then\n        return nil\n    end\n \
    \   return prime\nend", "    -- Convert the number into a string and remove any\
    \ extra characters. \n    local num_str = table.concat(num, '').\n      match(\"\
    ([^a-fA-F0-9]*)\") -- Removes non-hex characters. \n      or(0) -- If no number\
    \ was entered, returns 0\n    \n    -- Use a for loop to determine prime numbers.\
    \ \n    local prime_count = 0\n    for i=2,num_str do\n        if num_str % i\
    \ ~= 0 then\n            prime_count = prime_count + 1\n        end\n    end\n\
    \    \n    -- Return the number of primes found.\n    return prime_count\nend",
  "    local n = tonumber(num)\n    if n == nil then\n        error(\"bad argument\
    \ for hex_key()\")\n    end\n    if n < 0 then\n        error(\"hex_key(): argument\
    \ must be positive\")\n    end\n    if n > 0xFFFFFFFFFFFFFFFF then\n        error(\"\
    hex_key(): argument out of range (max is 2^64-1)\")\n    end\n    local count\
    \ = 0\n    local s = string.gsub(to_string(hex(n)),\"^%x+\",\"%x%x%x\")\n    for\
    \ i = 1, #s do\n        if string.sub(s, i, i) ~= \"0\" then\n            count\
    \ = count + 1\n        end\n    end\n    return count\nend", "\tlocal n = tonumber(num)\n\
    \tif not n then\n\t\treturn nil\n\tend\n\t-- If the string does not contain hexadecimal\
    \ digits, return nil.\n\tlocal function contains_digit(str)\n\t\tlocal digit_count\
    \ = 1\n\t\twhile true do\n\t\t\tlocal digit = str:sub(1, digit_count)\n\t\t\t\
    if tonumber(digit) then\n\t\t\t\treturn true\n\t\t\tend\n\t\t\tdigit_count = digit_count\
    \ + 1\n\t\tend\n\tend\n\t-- If string contains only digits, remove them. Otherwise,\
    \ return nil.\n\tif contains_digit(num) then\n\t\treturn num:gsub(\"^%a+\", \"\
    \")\n\tend\n\treturn nil\nend", "   -- num: string \n   if num == nil then \n\
    \      return nil \n   end", "    local digits = {}\n    for i=1,num:len()-1 do\n\
    \        local char = num:sub(i,i)\n        local key = tonumber(char) or 0\n\
    \        local is_prime = ( key == 2 or key == 3 or key == 5 or key == 7 or key\
    \ == 11 or key == 13 or key == 17)\n        if is_prime then \n            digits[i]\
    \ = digits[i]+1 \n        end\n    end\n    local prime_key = {}\n    for i=1,digits[1]\
    \ do\n        if digits[i] ~= 0 then\n            prime_key[i] = true\n      \
    \  end\n    end\n    local i = 1\n    for key,value in pairs(prime_key) do\n \
    \       if i == 1 then\n            return value \n        else\n            if\
    \ key ~= i then\n                return value\n            end\n        end\n\
    \        i = i + 1\n    end\nend", "\tlocal num_str = string.gsub(tostring(num),\
    \ '^0', '');\n\tlocal hex_digits = string.gsub(num_str, '(..)', '\\\\1');\n\t\
    local hex_key_digits = string.gsub(num_str, '(..)', '\\\\x\\1');\n\tlocal count\
    \ = #hex_key_digits / 2;\n\t\n\treturn count\nend", "    local res=0\n    for\
    \ i=1,16 do\n        if hex_decimal(num:sub(i,i))~=i then\n            res=res+1\n\
    \        end\n    end\n    return res\nend", "\tlocal key = ''\n\tnum = string.gsub(num,\
    \ string.char(48), string.char(57))\n\tfor i,v in ipairs(string.gmatch(num, \"\
    .-?%d+\")) do\n\t\t-- check for prime\n\t\tlocal count = 0\n\t\tlocal p = 2\n\t\
    \twhile p <= (v*v) and count < 50 do\n\t\t\tif math.fmod(v,p) == 0 then\n\t\t\t\
    \tcount = count+1\n\t\t\tend\n\t\t\tp = p*p\n\t\tend\n\t\tif count < 50 then\n\
    \t\t\tkey = key .. v\n\t\tend\n\tend\n\treturn tonumber(key)\nend", "  local hex\
    \ = string.char()\n  for i = 0, num:len() - 1, 1 do\n    hex = string.sub(num,\
    \ i, i) + hex\n  end\n  return #hex\nend", "\tlocal num_str = tonumber(num)\n\t\
    assert(num_str, \"num is not a number\")\n\tlocal num_str = tonumber(num_str)\n\
    \tassert(num_str, \"num is not a number\")\n\tlocal num_str = tonumber(num_str)\n\
    \tassert(num_str, \"num is not a number\")\n\t\n\tlocal num_zero = string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(num_str,\
    \ \"[[:digit:]]\", \"\"), \"[[:lower:]]\", \"\"), \"[[:upper:]]\", \"\"), \"[^0-9]\"\
    , \"\")\n\t\n\tlocal num_1 = tonumber(num_str)\n\tassert(num_1, \"num is not a\
    \ number\")\n\tlocal num_1 = tonumber(num_1)\n\tassert(num_1, \"num is not a number\"\
    )\n\tlocal num_1 = tonumber(num_1)\n\tassert(num_1, \"num is not a number\")\n\
    \t\n\tlocal num_2 = tonumber(num_str)\n\tassert(num_2, \"num is not a number\"\
    )\n\tlocal num_2 = tonumber(num_2)\n\tassert(num_2, \"num is not a number\")\n\
    \tlocal num_2 = tonumber(num_2)\n\tassert(num_2, \"num is not a number\")\n\t\n\
    \tlocal num_3 = tonumber(num_str)\n\tassert(num_3, \"num is not a number\")\n\t\
    local num_3 = tonumber(num_3)\n\tassert(num_3, \"num is not a number\")\n\tlocal\
    \ num_3 = tonumber(num_3)\n\tassert(num_3, \"num is not a number\")\n\t\n\tlocal\
    \ num_4 = tonumber(num_str)\n\tassert(num_4, \"num is not a number\")\n\tlocal\
    \ num_4 = tonumber(num_4)\n\tassert(num_4, \"num is not a number\")\n\tlocal num_4\
    \ = tonumber(num_4)\n\tassert(num_4, \"num is not a number\")\n\t\n\tlocal num_5\
    \ = tonumber(num_str)\n\tassert(num_5, \"num is not a number\")\n\tlocal num_5\
    \ = tonumber(num_5)\n\tassert(num_5, \"num is not a number\")\n\tlocal num_5 =\
    \ tonumber(num_5)\n\tassert(num_5, \"num is not a number\")\n\t\n\tlocal num_6\
    \ = tonumber(num_str)\n\tassert(num_6, \"num is not a number\")\n\tlocal num_6\
    \ = tonumber(num_6)\n\tassert(num_6, \"num is not a number\")\n\tlocal num_6 =\
    \ tonumber(num_6)\n\tassert(num_6, \"num is not a number\")\n\t\n\tlocal num_7\
    \ = tonumber(num_str)\n\tassert(num_7, \"num", "    local primes = {}\n    --\
    \ Find the first prime number\n    for i=1, 2 do\n        primes[i] = true\n \
    \   end\n    -- Loop until there are no more prime numbers\n    while primes[1]\
    \ do\n        local num_digits = 0\n        local prime = nil\n        for i=1,16\
    \ do\n            if num:sub(i,i) == 'A' or num:sub(i,i) == 'B' or num:sub(i,i)\
    \ == 'C' or num:sub(i,i) == 'D' then\n                if prime then\n        \
    \            break\n                elseif primes[i] then\n                  \
    \  prime = i\n                end\n            end\n            num_digits = num_digits\
    \ + 1\n        end\n        -- If none of the digits are prime numbers\n     \
    \   if num_digits <= 1 then\n            return nil\n        end\n        -- Find\
    \ the next prime number\n        for i=1, 16 do\n            if num:sub(i,i) ==\
    \ 'A' or num:sub(i,i) == 'B' or num:sub(i,i) == 'C' or num:sub(i,i) == 'D' then\n\
    \                if not primes[i] then\n                    primes[i] = true\n\
    \                    prime = i\n                end\n                break\n \
    \           end\n        end\n    end\n    -- Return the number of hexadecimal\
    \ digits\n    return #num\nend", "\tlocal digits = string.gsub(num, '%a+', '%A+')\n\
    \tlocal prime_digits = {}\n\tfor i = 1, 16 do\n\t\tprime_digits[i] = 1\n\tend\n\
    \tfor i = 1, 16 do\n\t\tprime_digits[i] = 1\n\t\tfor j =i, 16, 1 do\n\t\t\tif\
    \ string.sub( digits, i, j ) == '' then\n\t\t\t\tbreak\n\t\t\tend\n\t\t\tprime_digits[j]\
    \ = prime_digits[j] + 1\n\t\tend\n\tend\n\tlocal n = 1\n\tfor i = 1, 10 do\n\t\
    \tif prime_digits[i] > 0 then\n\t\t\tn = n + 1\n\t\tend\n\tend\n\treturn n\nend",
  "\t-- Your code here.\n\tlocal count = 0\n\tlocal t = string.sub(num, 1, 2)\n\t\
    if t=='2' then\n\t\tcount = count + 1\n\telseif t=='3' then\n\t\tcount = count\
    \ + 1\n\telseif t=='5' then\n\t\tcount = count + 1\n\telseif t=='7' then\n\t\t\
    count = count + 1\n\telseif t=='B' then\n\t\tcount = count + 1\n\telseif t=='D'\
    \ then\n\t\tcount = count + 1\n\telseif t=='E' then\n\t\tcount = count + 1\n\t\
    elseif t=='F' then\n\t\tcount = count + 1\n\telseif t=='0' then\n\t\tcount = count\
    \ + 1\n\telse\n\t\tcount = count + 1\n\tend\n\treturn count\nend", "   local result\
    \ = #num\n   for i = 1, #num, 2 do\n      local t = tonumber(num:sub(i,i+2),16)\n\
    \      if t > 0 and t ~= math.ceil(t) and t % 2 ~= 0 and t % 3 ~= 0 then\n   \
    \      result = (result + t) / 2\n      end\n   end\n   return result\nend", "\t\
    local hexadecimal = {}\n\tlocal prime_hexadecimal = {}\n\tlocal hex_digit = {}\n\
    \tlocal i = 1\n\tfor char in string.gmatch(num, '%x') do\n\t\thexadecimal[i] =\
    \ char\n\t\thex_digit[i] = true\n\tend\n\thexadecimal[1] = true\n\tfor i = 2,\
    \ #hexadecimal do\n\t\thexadecimal[i] = false\n\tend\n\tfor i = 0, #hexadecimal\
    \ - 1 do\n\t\tif hexadecimal[i] then\n\t\t\tfor j = i + 2, #hexadecimal do\n\t\
    \t\t\tif hexadecimal[j] then\n\t\t\t\t\tprime_hexadecimal[j] = true\n\t\t\t\t\
    else\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tlocal prime_count\n\
    \tprime_count = 0\n\tfor i = 1, #prime_hexadecimal do\n\t\tif prime_hexadecimal[i]\
    \ then\n\t\t\tprime_count = prime_count + 1\n\t\tend\n\tend\n\treturn prime_count\n\
    end", "    local num_str = tonumber(num)\n    local result = 0\n    local i =\
    \ 1\n    while num_str:sub(i):len() ~= 0 do\n        local digit = tonumber(num_str:sub(i))\n\
    \        if digit == 2 then\n            -- Check first digit\n            if\
    \ num_str:sub(i-1) < num_str:sub(i) then\n                -- Check second digit\n\
    \                if num_str:sub(i-2) < num_str:sub(i) then\n                 \
    \   -- Check third digit\n                    if num_str:sub(i-3) < num_str:sub(i)\
    \ then\n                        -- Check fourth digit\n                      \
    \  if num_str:sub(i-4) < num_str:sub(i) then\n                            -- Check\
    \ fifth digit\n                            if num_str:sub(i-5) < num_str:sub(i)\
    \ then\n                                -- Check sixth digit\n               \
    \                 if num_str:sub(i-6) < num_str:sub(i) then\n                \
    \                    -- Check seventh digit\n                                \
    \    if num_str:sub(i-7) < num_str:sub(i) then\n                             \
    \           -- Check eighth digit\n                                        if\
    \ num_str:sub(i-8) < num_str:sub(i) then\n                                   \
    \         -- Check ninth digit\n                                            if\
    \ num_str:sub(i-9) < num_str:sub(i) then\n                                   \
    \             -- Check tenth digit\n                                         \
    \       if num_str:sub(i-10) < num_str:sub(i) then\n                         \
    \                           -- Check eleventh digit\n                        \
    \                            if num_str:sub(i-11) < num_str:sub(i) then\n    \
    \                                                    -- Check twelfth digit\n\
    \                                                        if num_str:sub(i-12)\
    \ < num_str:sub(i) then\n                                                    \
    \        -- Check thirteenth digit\n                                         \
    \                   result = result + 1\n                                    \
    \                        i = i - 12\n                                        \
    \                else\n                                                      \
    \      result = result + 1\n                                                 \
    \           i = i - 11\n                                                     \
    \   end\n                                                    else\n          \
    \                                              -- Check fourteenth digit\n   \
    \                                                     result = result + 1\n  \
    \                                                      i = i - 10\n          \
    \                                          end\n                             \
    \                   else\n                                                   \
    \ -- Check fifteenth digit\n                                                 \
    \   result = result + 1\n                                                    i\
    \ = i - 9\n                                                end\n             \
    \                               else\n                                       \
    \         -- Check sixteenth digit\n                                         \
    \       result = result + 1\n                                                i\
    \ = i - 8\n                                            end\n                 \
    \                       else\n                                            -- Check\
    \ seventeenth digit\n                                            result = result\
    \ + 1\n                                            i = i - 7\n               \
    \                         end\n                                    else\n    \
    \                                    -- Check eighteenth digit\n             \
    \                           result = result + 1\n                            \
    \            i = i - 6\n                                    end\n            \
    \                    else\n                                    -- Check ninteenth\
    \ digit\n                                    result = result + 1\n           \
    \                         i = i - 5\n                                end\n   \
    \                         else\n                                -- Check twelfth\
    \ digit\n                                result = result + 1\n               \
    \                 i = ", "    if not num then\n        return 0\n    end\n   \
    \ local n = 1\n    if #num == 0 then\n        return 0\n    end\n    for i = 2,\
    \ #num do\n        if ((#num - i) % 2) == 0 then\n            n = n*16 + tonumber(num[i])\n\
    \        else\n            n = n*16 + tonumber(num[i]) * 16\n        end\n   \
    \ end\n    return n\nend", "\tlocal num_str = tostring(num)\n\t-- first find two\
    \ numbers that divide the number\n\tlocal first = 2\n\tlocal last = num_str:byte()\
    \ - 1\n\twhile first <= last do\n\t\tlocal mid = (first + last) / 2\n\t\tlocal\
    \ is_prime = true\n\t\t-- find the first factor\n\t\tfor i = first, 1, -1 do\n\
    \t\t\tif math.fmod(mid,i) == 0 then\n\t\t\t\tis_prime = false\n\t\t\t\tbreak\n\
    \t\t\tend\n\t\tend\n\t\t-- find the second factor\n\t\tfor i = last, 1, -1 do\n\
    \t\t\tif math.fmod(mid,i) == 0 then\n\t\t\t\tis_prime = false\n\t\t\t\tbreak\n\
    \t\t\tend\n\t\tend\n\t\tif is_prime then\n\t\t\tfirst = first + 1\n\t\telse\n\t\
    \t\tlast = last - 1\n\t\tend\n\tend\n\treturn last + 1\nend", "   if num ~= ''\
    \ then\n      return #(string.gmatch(num, \"^%x\"))\n   else\n      return 0\n\
    \   end\nend", "    local n = tonumber(num)\n    local primes, factors = {}, {}\n\
    \    for i=2,n do\n        local fact = 1\n        for j=1,i do\n            fact\
    \ = fact*i\n        end\n        if n%fact ~= 0 then\n            table.insert(primes,i)\n\
    \            table.insert(factors,fact)\n        end\n    end\n    if #primes\
    \ > 1 then\n        return primes[1]\n    end\n    return nil\nend", "\tlocal\
    \ digit_count = string.len(num)\n\tif digit_count > 16 then\n\t\tdigit_count =\
    \ 16\n\tend", "  if #num < 1 then\n    return nil\n  end", "    local num_str\
    \ = tonumber(num)\n    if num_str == nil then\n        return nil\n    end\n \
    \   -- num_str = tonumber(tonumber(num))\n    -- num_str = tonumber(tostring(num))\n\
    \    -- num_str = tonumber(tostring(num_str))\n    -- num_str = tonumber(tostring(tostring(num)))\n\
    \    -- num_str = tonumber(tostring(tostring(num_str)))\n    -- num_str = tonumber(tostring(tostring(tostring(num))))\n\
    \    local num_hex = 0\n    local num_arr = 0\n    local str_arr = 0\n    local\
    \ str_str = ''\n    local str_len = 0\n    for i = 1, #num_str do\n        local\
    \ tmp_num_hex = tonumber(num_str:sub(i,i))\n        if tmp_num_hex > 0 then\n\
    \            num_arr = tmp_num_hex\n        else\n            num_hex = tmp_num_hex\n\
    \        end\n    end\n    if num_arr < 2 then\n        return nil\n    end\n\
    \    str_arr = num_arr\n    str_str = tostring(num_str)\n    str_len = #str_str\n\
    \    for i = 1, str_len do\n        num_hex = tonumber(str_str:sub(i,i))\n   \
    \     if num_hex > 0 then\n            str_arr = str_arr + 1\n        end\n  \
    \  end\n    str_str = tostring(str_str)\n    str_len = #str_str\n    for i = 1,\
    \ str_len do\n        num_hex = tonumber(str_str:sub(i,i))\n        if num_hex\
    \ > 0 then\n            str_arr = str_arr + 1\n        end\n    end\n    str_str\
    \ = tostring(str_str)\n    str_len = #str_str\n    for i = 1, str_len do\n   \
    \     num_hex = tonumber(str_str:sub(i,i))\n        if num_hex > 0 then\n    \
    \        str_arr = str_arr + 1\n        end\n    end\n    str_str = tostring(str_str)\n\
    \    str_len = #str_str\n    for i = 1, str_len do\n        num_hex = tonumber(str_str:sub(i,i))\n\
    \        if num_hex > 0 then\n            str_arr = str_arr + 1\n        end\n\
    \    end\n    str_str = tostring(str_str)\n    str_len = #str_str\n    for i =\
    \ 1, str_len do\n        num_hex = tonumber(str_str:sub(i,i))\n        if num_hex\
    \ > 0 then\n            str_arr = str_arr + 1\n        end\n    end\n    str_str\
    \ = tostring(str_str)\n    str_len = #str_str\n    for i = 1, str_len do\n   \
    \     num_hex = tonumber(str_str:sub(i,i))\n        if num_hex > 0 then\n    \
    \        str_arr = str_arr + 1\n        end\n    end\n    str_str = ", "\tlocal\
    \ result = 0\n\tlocal p = 3\n\tlocal n = 1\n\twhile n ~= 0 do\n\t\tlocal m = math.modf(math.pow(16,\
    \ p) - math.pow(16, n) - num) * 16\n\t\tresult = result + m\n\t\tp = p + 1\n\t\
    \tn = n - 1\n\tend\n\treturn result\nend", "   local count = 3\n   for i=1, #num,\
    \ 2 do\n      if math.mod(tonumber(num:sub(i,i+1)), 2) == 0 then\n         count\
    \ = count + 1\n      end\n   end\n   return count\nend\n</code>\n<|/ q tags=lua\
    \ |>\n<| c |>\nI doubt that you've learned how to do this on your own before now.\
    \ Did you try anything?\n<|/ c |>\n<| c |>\nI believe you are being asked to write\
    \ the function by yourself (I haven't learned how to do that yet), however I don't\
    \ know how to approach this. So I asked this question here for help.\n<|/ c |>\n\
    <| c |>\nThat doesn't necessarily mean that you should ask for help without having\
    \ tried anything first. Also, I would avoid asking people to do your homework\
    \ for you. You're supposed to try to do your homework yourself first, and come\
    \ here with specific questions when you get stuck or get errors.\n<|/ c |>\n<|\
    \ c |>\nI edited my post to try to explain what I'm having trouble with. The function\
    \ I wrote can already count the amount of characters in a string but I don't know\
    \ how to count the amount of characters in a hexadecimal number as a string.\n\
    <|/ c |>\n<| a |>\nYour function is very close:\n<code>", "  if #num < 2 then\n\
    \    return 0\n  end\n  if num:sub(1,1) == 'A' then\n    return 10\n  end\n  if\
    \ num:sub(1,1) == 'B' then\n    return 11\n  end\n  if num:sub(1,1) == 'C' then\n\
    \    return 12\n  end\n  if num:sub(1,1) == 'D' then\n    return 13\n  end\n \
    \ if num:sub(1,1) == 'E' then\n    return 14\n  end\n  if num:sub(1,1) == 'F'\
    \ then\n    return 15\n  end\n  \n  if num:sub(1,1) == '0' then\n    if num:sub(2,2)\
    \ == '00' then\n      return 2\n    end\n    if num:sub(2,2) == '10' then\n  \
    \    return 3\n    end\n    if num:sub(2,2) == '20' then\n      return 5\n   \
    \ end\n    if num:sub(2,2) == '30' then\n      return 7\n    end\n    if num:sub(2,2)\
    \ == '40' then\n      return 11\n    end\n    if num:sub(2,2) == '50' then\n \
    \     return 13\n    end\n    if num:sub(2,2) == '60' then\n      return 17\n\
    \    end\n    if num:sub(2,2) == '70' then\n      return 19\n    end\n    if num:sub(2,2)\
    \ == '80' then\n      return 23\n    end\n    if num:sub(2,2) == '90' then\n \
    \     return 29\n    end\n    if num:sub(2,2) == 'A0' then\n      return 37\n\
    \    end\n    if num:sub(2,2) == 'B0' then\n      return 43\n    end\n    if num:sub(2,2)\
    \ == 'C0' then\n      return 49\n    end\n    if num:sub(2,2) == 'D0' then\n \
    \     return 55\n    end\n    if num:sub(2,2) == 'E0' then\n      return 59\n\
    \    end\n    if num:sub(2,2) == 'F0' then\n      return 63\n    end\n  end\n\
    \  \n  local function is_prime(n)\n    if n > 1 then\n      for i = 2, n do\n\
    \        if n % i == 0 then\n          return false\n        end\n      end\n\
    \      return true\n    end\n  end\n  \n  local function key_to_int(num)\n   \
    \ local function hex_to_int(num)\n      local function base10_to_base16(num)\n\
    \        return string.char(base10 ^ num * base10)\n      end\n      local function\
    \ base16_to_base10(num)\n        return tonumber(\"0x\"..num)\n      end\n   \
    \   return base16_to_base10(\n        string.sub(\n          string.gsub(\n  \
    \          string.gsub(\n              string.gsub(\n", "  local result = 0\n\
    \  \n  for i = 1, #num do\n    local ch = string.sub(num, i, i)\n    if ch ~=\
    \ '0' and ch ~= 'A' and ch ~= 'B' and ch ~= 'C' and ch ~= 'D' and ch ~= 'E' and\
    \ ch ~= 'F' then\n      result = result + 1\n    end\n  end", "   local function\
    \ checkPrime()\n      -- Check primes\n      if num % 2 ~= 0 or num <= 0 then\n\
    \         return nil\n      end", "  -- Your code goes here.\n  \n  local prime\
    \ = 0\n  local count = 0\n  local hex = {}\n  local hex_cnt = 0\n  local i = 0\n\
    \  local len = #num\n  local num = 0\n  \n  for i=1, len do\n    num = tonumber(string.sub(num,\
    \ i, i))\n    if hex_cnt == 0 then\n      if num == 0 then\n        hex_cnt =\
    \ 2\n      elseif num == 1 then\n        hex_cnt = 1\n      end\n    end\n   \
    \ if hex_cnt > 2 and num > 0 and num < 10 then\n      -- The number is in the\
    \ right range\n      hex[hex_cnt] = num\n      hex_cnt = hex_cnt + 1\n    end\n\
    \  end\n  for i = 1, hex_cnt do\n    local tmp = 1\n    if hex[i] > 0 then\n \
    \     for j = 1, hex[i] do\n        tmp = tmp * 2\n      end\n      if prime ==\
    \ 0 then\n        prime = tmp\n        count = count + 1\n      elseif tmp % prime\
    \ == 0 then\n        count = count + 1\n      end\n    end\n  end\n  if count\
    \ > 2 then\n    -- The count is greater than 2\n    return 2\n  end\n  if prime\
    \ == 0 then\n    -- The prime is zero\n    return 1\n  end\n  if prime > 6 then\n\
    \    -- The prime is greater than 6\n    return 4\n  end\n  if len < 4 then\n\
    \    -- The length is less than 4\n    return 6\n  end\n  \nend", "    if num\
    \ == nil or num == '' then\n        return 0\n    end\n    local hex = tonumber(num)\n\
    \    local count = 0\n    if hex == 0 then\n        return 0\n    end\n    if\
    \ hex < 0 then\n        return 0\n    end\n    local hex_string = string.sub(tostring(hex),\
    \ 1, 1)\n    if hex_string == 'A' or hex_string == 'B' or hex_string == 'C' then\n\
    \        return 3\n    end\n    if hex_string == 'D' or hex_string == 'E' or hex_string\
    \ == 'F' then\n        return 5\n    end\n    while hex >= 2 do\n        if hex\
    \ % 2 = 0 then\n            count = count + 1\n        end\n        hex = hex\
    \ / 2\n    end\n    return count\nend", "  local count=0\n  local i=1\n  while\
    \ i ~= #num\n    do\n      if num:sub(i,i) ~= '0' and num:sub(i,i) ~= 'A' and\
    \ num:sub(i,i) ~= 'B' and num:sub(i,i) ~= 'C' and num:sub(i,i) ~= 'D' and num:sub(i,i)\
    \ ~= 'E' and num:sub(i,i) ~= 'F'\n      then\n        return count\n      end\n\
    \      i=i+1\n    end\n  end\n  return count\nend", "    -- Convert number from\
    \ string to hex representation if necessary\n    if type(iconv.decode(num, 'hex'))\
    \ ~= 'string' then\n        num = iconv.encode(num, 'hex')\n    end", "\tlocal\
    \ primes, isPrime, factors\n\tprimes = {}\n\tisPrime = {}\n\tfactors = {}\n\t\
    local dig = 0\n\t-- count the number of hexadecimal digits, to determine if its\
    \ a prime number\n\tfor i = 1,#num,2 do\n\t\tlocal v = tonumber(sub(num,i,i+1),16)\n\
    \t\tif v ~= nil then\n\t\t\tdig = 1\n\t\t\tbreak\n\t\tend\n\tend\n\tfor i = 1,#num,2\
    \ do\n\t\tlocal v = tonumber(sub(num,i,i+1),16)\n\t\tif v ~= nil then\n\t\t\t\
    isPrime[dig] = true\n\t\t\tprimes[dig] = true\n\t\t\tdig = dig + 1\n\t\tend\n\t\
    end\n\t-- find all the factors of the prime numbers\n\tfor i = 2,#primes,2 do\n\
    \t\tlocal factor = 1\n\t\tfor j = 2,#primes,i do\n\t\t\tlocal k = i - j\n\t\t\t\
    if k ~= 0 then\n\t\t\t\tlocal mult = 1\n\t\t\t\tfor m = 1,k,1 do\n\t\t\t\t\tmult\
    \ = mult*primes[k]\n\t\t\t\tend\n\t\t\t\tfactor = mult\n\t\t\t\tbreak\n\t\t\t\
    end\n\t\tend\n\t\tfactors[#factors + 1] = factor\n\tend\n\t-- find all the factors\
    \ of the number of hexadecimal digits\n\tfor i = 2,#isPrime,1 do\n\t\tlocal factor\
    \ = factors[i]\n\t\tfor j = 1,#isPrime,i do\n\t\t\tlocal k = i - j\n\t\t\tif k\
    \ ~= 0 then\n\t\t\t\tfactor = factor*factor\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\
    \t\tfactors[#factors + 1] = factor\n\tend\n\treturn #factors\nend", "\t-- Your\
    \ solution goes here\nend", "\tlocal digits = {}\n\tlocal digits_count = 0\n\t\
    local max_digit = math.pow(10,hex_decimal)\n\tlocal max_digit2 = math.pow(10,hex_decimal)\n\
    \tfor i = 1,hex_decimal,1 do\n\t\tlocal digit = tochar(string.byte(num, i))\n\t\
    \tif digit ~= nil then\n\t\t\tif digit > max_digit then\n\t\t\t\tdigits[#digits\
    \ + 1] = 'E'\n\t\t\telseif digit > max_digit2 then\n\t\t\t\tdigits[#digits + 1]\
    \ = 'F'\n\t\t\telse\n\t\t\t\tdigits[#digits + 1] = digit\n\t\t\tend\n\t\tend\n\
    \tend\n\tlocal primes_count = 0\n\tfor _,v in pairs(digits) do\n\t\tif is_prime(v)\
    \ then\n\t\t\tprimes_count = primes_count + 1\n\t\tend\n\tend\n\treturn primes_count\n\
    end", "  num = num or ''\n  local primes = {}\n  -- First we count how many digits\
    \ are in the number.\n  local lenNum = string.len(num)\n  -- For each hexadecimal\
    \ digit (0-9), we store in primes the number \n  -- of primes with that digit.\n\
    \  for i = 1, lenNum do\n    local hex = string.sub(num, i, i)\n    primes[hex]\
    \ = primes[hex] + 1\n  end\n  -- Now we count how many primes there are with that\
    \ digit.\n  for i = 1, lenNum do\n    -- If no prime with that digit exists, we\
    \ increment the number of\n    -- primes with that digit.\n    if primes[i] ~=\
    \ nil then\n      primes[hex(i)] = primes[hex(i)] + 1\n    end\n  end\n  -- And\
    \ finally we return the number of the most frequent prime with \n  -- the given\
    \ hexadecimal digit.\n  local maxPrime = nil\n  local maxCount = 0\n  for i =\
    \ 1, lenNum do\n    -- If no prime with that digit exists, we increment the number\
    \ of\n    -- primes with that digit.\n    if primes[i] ~= nil then\n      if maxCount\
    \ == nil then\n        maxCount = primes[i]\n        maxPrime = i\n      elseif\
    \ primes[i] > maxCount then\n        maxCount = primes[i]\n        maxPrime =\
    \ i\n      end\n    end\n  end\n  return maxPrime\nend", "  local sum = 0\n  local\
    \ last_digit = nil\n  for i, c in string.gmatch(num, '%x') do\n    if last_digit\
    \ ~= 'A' and last_digit ~= 'B' and last_digit ~= 'C' and last_digit ~= 'D' and\
    \ last_digit ~= 'E' and last_digit ~= 'F' then\n      sum = sum + tonumber(last_digit)\n\
    \    end\n    last_digit = c\n  end\n  if sum >= 10 then\n    return 0\n  else\n\
    \    return sum\n  end\nend", "  local count = 0\n  local digit\n  for i = 1,\
    \ #num, 2 do\n    digit = string.sub(num, i, i)\n    count = count + 1\n    if\
    \ digit == \"0\" and i > 1 then\n      count = count + 1\n    end\n  end\n  return\
    \ count\nend", "   local count = 0\n   for i = 1, #num do\n      local n = tonumber(string.sub(num,\
    \ i, i))\n      if n <= 16 then\n         count = count + 1\n      elseif n <\
    \ 17 and n % 17 == 0 then\n         count = count + 1\n      end\n   end\n   return\
    \ count\nend", "\tlocal digits = {}\n\tfor i = 1, #num, 1 do\n\t\tlocal c = string.sub(num,\
    \ i, i)\n\t\tlocal isPrime = isPrimeHex(digits[c - '0'])\n\t\tif isPrime then\n\
    \t\t\tdigits[c - '0'] = digits[c - '0'] + 1\n\t\tend\n\tend\n\treturn #digits\
    \ > 0 and digits[1] or 0\nend", "   local hex_key = {}\n   local is_prime", " \
    \   -- Your code here.\n    -- Example: num = 'ABED1A33'\n    -- num = '1077E'\n\
    \    -- num = '123456789ABCDEF0'\n    -- num = '2020'\n    local hex_key = 0\n\
    \    local count = 0\n    for i = 1, #num do\n        local temp1 = tonumber(string.format('%X',\
    \ num[i]))\n        local temp2 = tonumber(string.format('%X', num[i+1]))\n  \
    \      if temp1 ~= nil and temp2 ~= nil then\n            if ((temp1 ~= temp2\
    \ or temp2 ~= temp1) and temp1 % temp2 == 0) then\n                count = count\
    \ + 1\n            else\n                count = count + 1\n            end\n\
    \        else\n            count = count + 1\n        end\n    end\n    return\
    \ count\nend\nreturn hex_key", "    local count = 0\n    -- remove all the extra\
    \ chars at the end\n    num = string.gsub(num, string.char(6,7), '') \n    --\
    \ check if the number is valid\n    if num:sub(1,1) ~= '0' then return -1 end\n\
    \    -- convert the string to binary\n    local binary = bit.bor(bit.lshift(string.sub(num,\
    \ 1, 1), 8), bit.rshift(string.sub(num, 1, 2), 8))\n    for i = 2, #binary do\n\
    \        local bit = binary[i]\n        if bit == 1 then\n            count =\
    \ count + 1\n        end\n    end\n    return count\nend", "   local ret = 0\n\
    \   for i = 1, #num, 1 do\n      ret = ret + tonumber(num[i]) - tonumber(string.sub(num,\
    \ 1, i)) * tonumber(string.sub(num, i, #num))\n   end\n   return ret\nend", " \
    \ -- Your code here\n  -- You have to return a number of prime numbers which is\
    \ equal to decimal \n  -- number of hexadecimal digits in the input. \n  return\
    \ #primes\nend", "    local num_str=string.format(\"%x\",tonumber(num))\n    local\
    \ num_array={}\n    for i,v in ipairs(num_str) do\n        local x=tonumber(v)\n\
    \        if x==nil or x==0 or x=='0' or x=='00' or x=='000' or x=='0000' then\n\
    \            num_array[i]=0\n        else\n            num_array[i] = num_array[i]\
    \ + 2*x\n        end\n    end\n    local num_prime=0\n    local num_prime_str={}\n\
    \    for i,v in ipairs(num_array) do\n        if v==2 then\n            num_prime\
    \ = num_prime + 1\n            num_prime_str[i] = '2'\n        elseif v==3 then\n\
    \            num_prime = num_prime + 1\n            num_prime_str[i] = '3'\n \
    \       elseif v==5 then\n            num_prime = num_prime + 1\n            num_prime_str[i]\
    \ = '5'\n        elseif v==7 then\n            num_prime = num_prime + 1\n   \
    \         num_prime_str[i] = '7'\n        elseif v==11 then\n            num_prime\
    \ = num_prime + 1\n            num_prime_str[i] = 'B'\n        elseif v==13 then\n\
    \            num_prime = num_prime + 1\n            num_prime_str[i] = 'D'\n \
    \       end\n    end\n    return num_prime\nend", "  local key = {}\n  local k\n\
    \  local n = tonumber(num)\n  if n == nil then\n    return nil\n  end", "  local\
    \ hex_list = string.gmatch(num, \"^[a-fA-F0-9]+$\")\n  return #hex_list\nend",
  "    local primes = {}\n    local count = {}\n    local last_number = tonumber(num)\n\
    \    if last_number == nil then\n        return 0\n    end\n    for i=last_number+1,\
    \ last_number+2, 1 do\n        if hex_to_dec(i) == nil then\n            primes[#primes+1]\
    \ = i\n        end\n    end\n    local count = 0\n    local prime_index = 1\n\
    \    for i=last_number+1, last_number+3, 1 do\n        local digit = hex_to_dec(i)\n\
    \        if digit == nil then\n            prime_index = #primes\n        else\n\
    \            if primes[prime_index] == nil then\n                prime_index =\
    \ prime_index - 1\n            else\n                primes[prime_index] = digit\n\
    \                count = count + 1\n                if count==3 then\n       \
    \             break\n                end\n            end\n        end\n    end\n\
    \    return count\nend", "  -- Your code here\n  local hex = {}\n  local i = 0\n\
    \  while i <= math.max(#num, 0) do\n    hex[i] = tonumber(num:sub(1, i+1))\n \
    \   i = i + 1\n  end\n  local n = 1\n  for i = 1, #hex do\n    for i = 1, #hex\
    \ do\n      if hex[i] * hex[i-1] % 2 ~= 0 then\n        n = n + 1\n        break\n\
    \      end\n    end\n  end\n  return n\nend", "  if num == '' then return 1 end\n\
    \  num = tonumber(num)\n  local hex_dig = string.char(10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10)\n  local num_dig  = string.len(num)\n  local mod_num  =\
    \ 0\n  local count = 0\n  \n  -- TODO: write your code below this line\n  for\
    \ i = 1, num_dig do\n    -- determine how many digits are divisible by 3\n   \
    \ mod_num = mod_num + math.mod(num[i], 3)\n    \n    -- determine how many digits\
    \ are divisible by 5\n    -- TODO: write your code below this line\n    mod_num\
    \ = mod_num + math.mod(num[i], 5)\n    \n    -- determine how many digits are\
    \ divisible by 7\n    -- TODO: write your code below this line\n    mod_num =\
    \ mod_num + math.mod(num[i], 7)\n    \n    -- determine how many digits are divisible\
    \ by 11\n    -- TODO: write your code below this line\n    mod_num = mod_num +\
    \ math.mod(num[i], 11)\n    \n    -- determine how many digits are divisible by\
    \ 13\n    -- TODO: write your code below this line\n    mod_num = mod_num + math.mod(num[i],\
    \ 13)\n    \n    -- count the digits\n    if mod_num == 0 then count = count +\
    \ 1 end\n    mod_num = 0\n  end\n  \n  return count\nend", "   -- Check validity\
    \ of the input.\n   if type(num) ~= 'string' then return 1 end\n   if #num < 2\
    \ then return 1 end\n   if #num > 16 then return 1 end\n   for i = 1, 16 do\n\
    \      -- Convert char to number.\n      local n = tonumber(string.sub(num, i,\
    \ i))\n      if n ~= nil then\n         -- Check digit primality (number of divisors\
    \ is always >= 1).\n         if math.floor(n/2) == n then\n            -- Return\
    \ digit count.\n            return i\n         end\n      end\n   end\n   return\
    \ 0\nend", "  local hex_list = string.gmatch(string.gsub(num, '\\W+', ','), '(%d+)')\n\
    \  local hex_count = hex_list[1]\n  local hex_key = hex_list[2] .. hex_list[3]\
    \ .. hex_list[4] .. hex_list[5] .. hex_list[6] .. hex_list[7]\n  return hex_count\n\
    end", "\tlocal digits, power = {}, 1\n\tfor i = 1, #num do\n\t\tlocal c = string.sub(num,\
    \ i, i)\n\t\tdigits[c] = digits[c] + 1\n\t\tpower = power * 16\n\tend\n\tlocal\
    \ hex = nil\n\tfor i = 1, 10 do\n\t\tif (digits[i] ~= 0) then\n\t\t\tif (digits[i]\
    \ == 1) then\n\t\t\t\thex = i\n\t\t\telse\n\t\t\t\thex = hex * 16 + i\n\t\t\t\
    end\n\t\tend\n\tend\n\treturn hex\nend", "\tlocal key_len = 0\n\tlocal prime_count\
    \ = 0\n\tlocal num_count = 0\n\tlocal prime = \"\"\n\tlocal digits = \"ABCDEF0123456789\"\
    \n\tfor i = 1,#num,1 do\n\t\tlocal d = tonumber(num:sub(i,i))\n\t\tnum_count =\
    \ num_count + 1\n\t\tif d > 48 and d < 58 then\n\t\t\tif key_len == 0 then\n\t\
    \t\t\tprime_count = prime_count + 1\n\t\t\t\tprime = prime_count \n\t\t\t\tkey_len\
    \ = #digits\n\t\t\telseif key_len == 1 then\n\t\t\t\tprime = prime_count \n\t\t\
    \tend\n\t\telse\n\t\t\tprime_count = prime_count + 1\n\t\t\tprime = prime_count\
    \ \n\t\t\tkey_len = #digits\n\t\tend\n\tend\n\treturn key_len - 1 - num_count\
    \ - prime_count\nend", "  local res = 0\n  local i, remainder = str:find(num,\
    \ '[A-z]')\n  if i~=nil then\n    if remainder~=nil then\n      res = hex_key(num:sub(0,\
    \ i+1):lower() + num:sub(i+1):upper())\n    else\n      res = 1 + hex_key(num:sub(0,\
    \ i+1):lower())\n    end\n  end\n  return res\nend", "    -- Write your solution\
    \ here\nend", "  local primes = {}\n  local prime_index = 1\n  local prime_count\
    \ = 2\n  local digits = {}\n  local digit_index = 1\n  local digit_count = 1\n\
    \  local hex_index = 1\n  local hex_count = 1\n  local prime_char = ''\n  local\
    \ digit_char = ''\n  local hex_char = ''\n  local hex_value = ''\n  local i =\
    \ 1\n  while i <= #num do\n    digit_value = tonumber(num:sub(i,i+1))\n    digit_char\
    \ = num:sub(i,i)\n    digit_index = digit_index + 1\n    digits[digit_index] =\
    \ digit_value\n    digit_count = digit_count + 1\n    i = i + 1\n  end", "  local\
    \ count = 0\n  local s = num:upper()\n  for i,v in string.gmatch(s, '%x') do\n\
    \    count = count + math.floor(math.log2(v))\n  end\n  return count\nend", " \
    \   local i, count  = 0, 0\n    local hex_list = {\n        '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'\n\
    \    }\n    for i = 1, #num, 1 do\n        if string.sub(num, i, i) ~= 'A' and\n\
    \            string.sub(num, i, i) ~= 'B' and\n            string.sub(num, i,\
    \ i) ~= 'C' and\n            string.sub(num, i, i) ~= 'D' and\n            string.sub(num,\
    \ i, i) ~= 'E' and\n            string.sub(num, i, i) ~= 'F' then\n          \
    \  count = count + 1\n        end\n    end\n    return count\nend", "\tlocal n\
    \ = 0\n\tfor i = 1,9 do\n\t\tif tonumber(num:sub(i,i)) == tonumber(i) then\n\t\
    \t\tn = n + 1\n\t\tend\n\tend\n\tif tonumber(num:sub(n,n)) == tonumber(n) then\n\
    \t\treturn n + 1\n\telse\n\t\treturn 1\n\tend\nend", "  local function is_digit(c)\n\
    \    return stringbyte(num)==tonumber(c)\n  end\n  local function is_prime(n)\n\
    \    local function is_composite(i)\n      local r,s = i,1\n      while r<=n and\
    \ s>0 do\n        if n%r==0 then\n          s=s-1\n        else\n          r,s\
    \ = r*r,s-1\n        end\n      end\n      return s==0\n    end\n    local primes\
    \ = [2,3,5,7]\n    if is_prime(primes[1]) then return primes[1] end\n    if is_prime(primes[2])\
    \ then return primes[2] end\n    if is_prime(primes[3]) then return primes[3]\
    \ end\n    if is_composite(primes[5]) then return primes[5] end\n    if is_composite(primes[7])\
    \ then return primes[7] end\n  end", "  -- TODO: fix with regex\n  -- local pattern\
    \ = '([A-F][A-F0-9]{2})'\n  -- local pattern = '([A-F][A-F0-9]{2,})'\n  -- local\
    \ pattern = '([A-F][A-F0-9]{2,})?'\n  -- local pattern = '([A-F]{2})?([A-F])?([A-F]{0,2})?'\n\
    \  -- local pattern = '([A-F]{2})([A-F])([A-F]{0,2})([A-F]{0,2})?'\n  -- local\
    \ pattern = '([A-F]{2})([A-F])([A-F]{0,2})([A-F]{0,2})?'\n  -- local pattern =\
    \ '([A-F]{2})([A-F])([A-F]{0,2})([A-F]{0,2})?'\n  -- local pattern = '([A-F]{2})([A-F])([A-F]{0,2})([A-F]{0,2})?'\n\
    \  -- local pattern = '([A-F]{2})([A-F])([A-F]{0,2})([A-F]{0,2})?'\n  -- local\
    \ pattern = '([A-F]{2})([A-F])([A-F]{0,2})([A-F]{0,2})?'\n  -- local pattern =\
    \ '([A-F]{2})([A-F])([A-F]{0,2})([A-F]{0,2})?'\n  -- local pattern = '([A-F]{2})([A-F])([A-F]{0,2})([A-F]{0,2})?'\n\
    \  -- local pattern = '([A-F]{2})([A-F])([A-F]{0,2})([A-F]{0,2})?'\n  -- local\
    \ pattern = '([A-F]{2})([A-F])([A-F]{0,2})([A-F]{0,2})?'\n  -- local pattern =\
    \ '([A-F]{2})([A-F])([A-F]{0,2})([A-F]{0,2})?'\n  -- local pattern = '([A-F]{2})([A-F])([A-F]{0,2})([A-F]{0,2})?'\n\
    \  -- local pattern = '([A-F]{2})([A-F])([A-F]{0,2})([A-F]{0,2})?'\n  -- local\
    \ pattern = '([A-F]{2})([A-F])([A-F]{0,2})([A-F]{0,2})?'\n  -- local pattern =\
    \ '([A-F]{2})([A-F])([A-F]{0,2})([A-F]{0,2})?'\n  -- local pattern = '([A-F]{2})([A-F])([A-F]{0,2})([A-F]{0,2})?'\n\
    \  -- local pattern = '([A-F]{2})([A-F])([A-F]{0,2})([A-F]{0,2})?'\n  -- local\
    \ pattern = '([A-F]{2})([A-F])([", "    local num_str = tonumber(num)\n    local\
    \ primes_count = 0\n    local i = 1\n    while i < num_str do\n        if num:sub(i,i)\
    \ ~= 'A' and num:sub(i,i) ~= 'B' and\n           num:sub(i,i) ~= 'C' and num:sub(i,i)\
    \ ~= 'D' and\n           num:sub(i,i) ~= 'E' and num:sub(i,i) ~= 'F' then\n  \
    \          break\n        end\n        primes_count = primes_count + 1\n     \
    \   i = i + 1\n    end\n    return primes_count\nend", "\tif num == nil or num\
    \ == '' or num == '-' then return 0 end\n\tlocal key, count = {}, 0\n\tfor i=1,10\
    \ do\n\t\tkey[i] = 0\n\tend\n\tlocal hex = string.byte(num)\n\tfor i = 1, #hex\
    \ do\n\t\tlocal num = tonumber(string.sub(num, i, i+1))\n\t\tif num ~= nil then\n\
    \t\t\tcount[num] =+ 1\n\t\tend\n\tend\n\tfor i = 2, #key do\n\t\tkey[i] = key[i-2]\
    \ + key[i-1]\n\tend\n\treturn count[1]\nend", "  local n = 0\n  for i = 1, 16\
    \ do\n    local a = tonumber(num, i)\n    if a ~= nil then\n      n = n + a\n\
    \    end\n  end\n  return n\nend", "   if not num then return nil end\n   local\
    \ num_len = #num\n   if num_len > 0 then\n      local i = 1\n      while i <=\
    \ num_len do\n         if num:sub(i,i) == hex_key('0123456789ABCDEF') then\n \
    \           i = i + 1\n         else\n            if num:sub(i,i) == 'A' or num:sub(i,i)\
    \ == 'B' then\n               i = i + 1\n            elseif num:sub(i,i) == 'C'\
    \ or num:sub(i,i) == 'D' then\n               i = i + 1\n            elseif num:sub(i,i)\
    \ == 'E' or num:sub(i,i) == 'F' then\n               i = i + 1\n            elseif\
    \ num:sub(i,i) == hex_key('0123456789ABCDEF') then\n               i = i + 1\n\
    \            end\n         end\n      end\n   end\n   return num - hex_key('0123456789ABCDEF')\n\
    end", "\tlocal result = 0\n\t\n\tfor i = 1, #num, 2 do\n\t\tlocal c = string.sub(num,\
    \ i, i+2)\n\t\t\n\t\tif not (math.isnan(c) or math.isinf(c) or c:match('^[0123456789ABCDEF]$'))\
    \ then -- number\n\t\t\tlocal d = tonumber(string.sub(num, i+2, i+4)) -- digits\n\
    \t\t\t\n\t\t\tif d <= 4 then\n\t\t\t\t-- prime\n\t\t\t\tresult = result + math.floor((c\
    \ * d) * math.pow(16, d))\n\t\t\telse\n\t\t\t\t-- not prime\n\t\t\tend\n\t\telse\n\
    \t\t\t-- symbol\n\t\tend\n\tend\n\t\n\treturn result\nend", "    -- your code\
    \ here\nend", "    local primes = { 2, 3 }\n    for i = #num, 2, -1 do\n     \
    \   if primes[#primes] == #num:sub(1) then\n            primes[#primes+1] = num:sub(1,i)\
    \ or primes[#primes+1]\n        end\n    end\n    for i = 2, #primes do\n    \
    \    if primes[i] == #num:sub(i) then\n            return primes[i]\n        end\n\
    \    end\n    return nil\nend", "    -- Your code here\n    local ret = 0\n  \
    \  for i = 1, #num do\n        local a = tonumber(num:sub(i,i))\n        if a\
    \ <= 57 then\n            ret = ret + 1\n        end\n    end\n    return ret\n\
    end", "\tlocal key_hex = {}\n\tlocal i = 1\n\tlocal count\n\twhile i <= #num and\
    \ i <= 36 do\n\t\tcount = #num - i\n\t\tif count == 0 then\n\t\t\tbreak\n\t\t\
    else\n\t\t\tlocal j = 1\n\t\t\twhile j <= count and j <= #num do\n\t\t\t\tif num:sub(i,\
    \ i + 1) ~= 'A' and num:sub(i, i + 1) ~= 'B' and num:sub(i, i + 1) ~= 'C' and\
    \ num:sub(i, i + 1) ~= 'D' and num:sub(i, i + 1) ~= 'E' and num:sub(i, i + 1)\
    \ ~= 'F' then\n\t\t\t\t\tlocal tmp = 1\n\t\t\t\t\twhile tmp <= i do\n\t\t\t\t\t\
    \tif num:sub(tmp, tmp + 1) ~= '0' then\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\telse\n\
    \t\t\t\t\t\t\ttmp++\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tif tmp == i then\n\
    \t\t\t\t\t\tkey_hex[#key_hex + 1] = i\n\t\t\t\t\telse\n\t\t\t\t\t\tkey_hex[#key_hex\
    \ + 1] = nil\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tj = j + 1\n\t\t\tend\n\t\tend\n\
    \t\ti = i + 1\n\tend\n\treturn #key_hex - 1\nend", "\tlocal count = 0\n\tfor i=1,\
    \ math.floor(math.sqrt(num), 2) do\n\t\tlocal div = math.floor(num / i)\n\t\t\
    if div * i ~= num then break end\n\t\tif div % 2 == 0 then\n\t\t\tcount = count\
    \ + 1\n\t\tend\n\tend\n\treturn count\nend", "    local count = 0\n    local digit\
    \ = 0\n    for i = 1, #num do\n        if num:sub(i,i) == 'A' then\n         \
    \   digit = 11\n        elseif num:sub(i,i) == 'B' then\n            digit = 13\n\
    \        elseif num:sub(i,i) == 'D' then\n            digit = 13\n        elseif\
    \ num:sub(i,i) == 'E' then\n            digit = 13\n        elseif num:sub(i,i)\
    \ == 'F' then\n            digit = 13\n        elseif num:sub(i,i) == '0' then\n\
    \            digit = 0\n        else\n            digit = tonumber(num:sub(i,i))\n\
    \        end\n        if digit ~= nil then\n            count = count + 1\n  \
    \      end\n    end\n    return count\nend", "  num = string.gsub(num, '[ABCDEF]',\
    \ '')\n  if #num > 0 then\n    local primes = {}\n    for i = 2, #num do\n   \
    \   local n = tonumber(num:sub(i,i))\n      if n ~= nil then\n        primes[#primes+1]\
    \ = n\n      end\n    end\n    \n    local prime, idx = 1, #primes\n    while\
    \ prime <= #primes and prime ~= idx do\n      idx = prime\n      prime = primes[idx]\n\
    \      if tonumber(num:sub(i,i)) % prime == 0 then\n        idx = (prime*prime)\n\
    \      end\n    end\n    if idx <= #primes then\n      return primes[idx]\n  \
    \  end\n  end\nend\n</cell>\n<cell>", "  -- Your code here\n  return num\nend",
  "  local i, remainder\n  num = string.gsub(num, \"\", \"_\")\n  for i, chart in\
    \ ipairs(string.gmatch(num, \"[a-fA-F0-9]*(.[a-fA-F0-9]+)\") do\n    remainder\
    \ = string.byte(num)%16\n    num = string.sub(num, 1, i+1); \n    if not remainder\
    \ then break end\n    if remainder < 10 then break end\n  end\n  return i+1\n\
    end", "\t-- Write your code here\n\tlocal hex_key = 0\n\tlocal num_digits = 0\n\
    \tlocal num_prime = 0\n\tlocal num_prime_prime = 0\n\tlocal num_prime_not_prime\
    \ = 0\n\tlocal num_not_prime = 0\n\tlocal num_prime_not_prime_prime = 0", "  \
    \  local str_num\n    if num == '' then\n        return nil\n    end\n    for\
    \ str_num in str:gmatch(\"%x\") do\n        -- If the number is prime\n      \
    \  if str_num:sub(1,1) == 'B' then\n            -- Return number\n           \
    \ return str_num:sub(2) == str_num:sub(3)\n        end\n    end\nend", "  local\
    \ num_hex = {}\n  local i = 1\n  for k, v in pairs(num) do\n    if v >= '0' and\
    \ v <= '9' then\n      num_hex[i] = v\n    else\n      if v == 'A' or v == 'B'\
    \ then\n        num_hex[i] = v\n      elseif v == 'C' or v == 'D' then\n     \
    \   num_hex[i] = v\n      elseif v == 'E' or v == 'F' then\n        num_hex[i]\
    \ = v\n      end\n    end\n    i = i + 1\n  end\n  return #num_hex\nend", "\t\
    local result = 0\n\tlocal digits = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}\n\
    \tfor i = 1, string.len(num) do\n\t\tlocal digit = string.sub(num, i, i)\n\t\t\
    local is_prime = false\n\t\tfor _, prime in ipairs(primes) do\n\t\t\tif digit\
    \ == prime then\n\t\t\t\tis_prime = true\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\
    \tif is_prime then\n\t\t\tresult = result + 1\n\t\tend\n\tend\n\treturn result\n\
    end", "  local hex_key = #num\n  local num_str = string.sub(num, 1, 1)\n  local\
    \ digit_str = \"\"\n  local num_digit\n  for num_digit in string.gmatch(num, \"\
    %x\") do\n    digit_str = digit_str .. num_digit\n  end\n  for num_digit in string.gmatch(num_str,\
    \ \"%d\") do\n    hex_key =\n      hex_key * 16 +\n      (string.byte(digit_str,\
    \ num_digit - 48) - 2)\n  end\n  return hex_key\nend", "\tlocal n = 0\n\tlocal\
    \ i = 1\n\twhile n ~= nil do\n\t\tn = tonumber(num)\n\t\tif n == 'A' then\n\t\t\
    \tn = 10\n\t\tend\n\t\tif n % 2 == 0 then\n\t\t\tn = n + 1\n\t\telse\n\t\t\tn\
    \ = n / 2\n\t\tend\n\t\ti = i + 1\n\tend\n\tif i == 1 then\n\t\treturn 0\n\telse\n\
    \t\tlocal n = 0\n\t\tlocal j = 1\n\t\twhile n ~= nil do\n\t\t\tn = tonumber(num)\n\
    \t\t\tj = j + 1\n\t\t\tif n % j == 0 then\n\t\t\t\treturn j\n\t\t\tend\n\t\tend\n\
    \t\treturn nil\n\tend\nend", "    local nums = string.gsub(string.gsub(num, '[^0-9A-F]',\
    \ '', ''), '[^0-9]', '')\n    local primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107,\
    \ 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193,\
    \ 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281,\
    \ 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383,\
    \ 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479,\
    \ 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593,\
    \ 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683,\
    \ 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809,\
    \ 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911,\
    \ 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997}\n    local digit\
    \ = nil\n    for i = 1, #nums do\n        digit = tonumber(string.sub(digits,\
    \ i))\n        if digit ~= nil then\n            for i2 = 1, prime do\n      \
    \          if digit % i2 == 0 then\n                    return prime - i\n   \
    \             end\n            end\n        end\n    end\nend", "    if not num\
    \ then return 0 end\n    local count = 1\n    local i = 0\n    while i < #num\
    \ do\n        if not tonumber(num[i]) then return 0 end\n        if tonumber(num[i])\
    \ < 16 then return 0 end\n        if tonumber(num[i]) >= 48 and tonumber(num[i])\
    \ <= 57 then\n            count = count + 1\n        end\n        i = i + 1\n\
    \    end\n    return count\nend", "    -- Your code here\n    --assert(type(num)\
    \ == 'string')\n    --assert(string.find(num, \"%[0-9A-Fa-f]\") == nil)", "  \
    \ num = string.upper(num)\n   local digits = {'A', 'B', 'C', 'D', 'E', 'F'}\n\
    \   local i = 1\n   local count = 0\n   while i ~= #num do \n      local d = tonumber(string.sub(num,\
    \ i, i + 1))\n      if d ~= nil then\n         if d in digits then\n         \
    \   count = count + 1\n         end\n      end\n      i = i + 1\n   end\n   return\
    \ count\nend", "   -- Your solution here\nend", "   -- Your code here\n   -- Example\n\
    \   -- assert(hex_key('ABED1A33')==4)\n   -- assert(hex_key('123456789ABCDEF0')==6)\n\
    \   -- assert(hex_key('2020')==2)\n   local primes = { 2,3,5,7,11,13,17,19 }\n\
    \   local str_num = tonumber(num)\n   local cnt = 0\n   for i = 2, str_num do\n\
    \      if str_num % i ~= 0 then break end\n      cnt = cnt + 1\n   end\n   if\
    \ str_num == 0 then return 0 end\n   if cnt == #primes then return 1 end\n   return\
    \ #primes - cnt\nend\n</cell>\n<cell>", "    local count = {}\n    for d = string.len(num),\
    \ 2, -1 do\n        local digit = tonumber(string.sub(num, d, d))\n        local\
    \ key = tonumber(string.sub(hexa, digit - 1, digit))\n        if key ~= nil then\n\
    \            table.insert(count, key)\n        end\n    end\n    return #count\n\
    end", "    num = string.gsub(num, \" \", \"\")\n    if #num == 0 then\n      \
    \  return 0\n    end", "\tnum = string.lower(num)\n\tlocal digit_count = 3\n\t\
    local digits = ''\n\tlocal prime_count = 0\n\tlocal prime_num = 1\n\tlocal prime\
    \ = false\n\tlocal temp_num = 1\n\tlocal temp_num_prime = 1\n\tlocal is_prime\
    \ = true\n\tfor i = 2, #num do\n\t\tlocal temp = string.sub(num,i,i)\n\t\tlocal\
    \ temp_digit = tonumber(temp)\n\t\tif temp_digit == nil then\n\t\t\tdigit_count\
    \ = digit_count + 1\n\t\telse\n\t\t\tif temp_digit % 2 == 0 then\n\t\t\t\tdigit_count\
    \ = digit_count + 1\n\t\t\telse\n\t\t\t\tdigit_count = digit_count - 1\n\t\t\t\
    end\n\t\t\tif temp_digit == 0 then\n\t\t\t\tdigit_count = digit_count + 1\n\t\t\
    \telse\n\t\t\t\tdigit_count = digit_count - 1\n\t\t\tend\n\t\t\tif temp_digit\
    \ == 1 then\n\t\t\t\tdigit_count = digit_count + 1\n\t\t\telse\n\t\t\t\tdigit_count\
    \ = digit_count - 1\n\t\t\tend\n\t\t\tif temp_digit == 2 then\n\t\t\t\tdigit_count\
    \ = digit_count + 1\n\t\t\telse\n\t\t\t\tdigit_count = digit_count - 1\n\t\t\t\
    end\n\t\t\tif temp_digit == 3 then\n\t\t\t\tdigit_count = digit_count + 1\n\t\t\
    \telse\n\t\t\t\tdigit_count = digit_count - 1\n\t\t\tend\n\t\t\tif temp_digit\
    \ == 4 then\n\t\t\t\tdigit_count = digit_count + 1\n\t\t\telse\n\t\t\t\tdigit_count\
    \ = digit_count - 1\n\t\t\tend\n\t\t\tif temp_digit == 5 then\n\t\t\t\tdigit_count\
    \ = digit_count + 1\n\t\t\telse\n\t\t\t\tdigit_count = digit_count - 1\n\t\t\t\
    end\n\t\t\tif temp_digit == 6 then\n\t\t\t\tdigit_count = digit_count + 1\n\t\t\
    \telse\n\t\t\t\tdigit_count = digit_count - 1\n\t\t\tend\n\t\t\tif temp_digit\
    \ == 7 then\n\t\t\t\tdigit_count = digit_count + 1\n\t\t\telse\n\t\t\t\tdigit_count\
    \ = digit_count - 1\n\t\t\tend\n\t\t\tif temp_digit == 8 then\n\t\t\t\tdigit_count\
    \ = digit_count + 1\n\t\t\telse\n\t\t\t\tdigit_count = digit_count - 1\n\t\t\t\
    end\n\t\t\tif temp_digit == 9 then\n\t\t\t\tdigit_count = digit_count + 1\n\t\t\
    \telse\n\t\t\t\tdigit_count = digit_count - 1\n\t\t\tend\n\t\t\tif temp_digit\
    \ == 10 then\n\t\t\t\tdigit_count = digit_count + 1\n\t\t\telse\n\t\t\t\tdigit_count\
    \ = digit_count - 1\n\t\t\tend\n\t\t\tif temp_digit == 11 then\n\t\t\t\tdigit_count\
    \ = digit_count + 1\n\t\t\telse\n\t\t\t\tdigit_count = digit_count - 1\n\t\t\t\
    end\n\t\t\tif temp_digit == 12 then\n\t\t\t\tdigit_count = digit_count + 1\n\t\
    \t\telse\n\t\t\t\tdigit_count = digit_count - 1\n\t\t\tend\n\t\t\tif temp_digit\
    \ == 13 then\n\t\t\t\tdigit_count = digit_count + 1\n\t\t\telse\n\t\t\t\tdigit_count\
    \ = digit_count - 1\n\t\t\tend\n\t\t\tif temp_digit == 14 then\n", "  local key\
    \ = {}\n  local num_digits = tonumber(num)\n  if not num_digits then\n    return\
    \ nil\n  end\n  -- convert string to list of digits\n  local digits = {}\n  for\
    \ i=1, num_digits do\n    digits[i] = tonumber(string.format('%2.2x', i)) \n \
    \ end\n  -- convert to array\n  local digits_array = {}\n  for i=1, num_digits\
    \ do\n    digits_array[i] = digits[i]\n  end\n  -- count the odd number digits\n\
    \  for i = 1, num_digits do\n    local odd = 1\n    if i ~= 1 then\n      local\
    \ k = i - 1\n      while digits_array[k] % digits_array[i] == 0 do\n        odd\
    \ = odd + odd\n        k = k - 1\n      end\n    end\n    table.insert(key, odd)\n\
    \  end\n  -- determine prime number\n  for i = 2, #key do\n    local p = 1\n \
    \   for j = 2, #key do\n      if key[i] > key[j] and key[i] % key[j] == 0 then\n\
    \        -- isprime returns true if the number is prime or composite\n       \
    \ -- p is a prime if it is not divisible by any other number.\n        -- Therefore,\
    \ p must be divisible by all even numbers in key array.\n        local is_p =\
    \ 1\n        for k = 1, #key do\n          if key[k] % j == 0 then\n         \
    \   is_p = 0\n            break\n          end\n        end\n        if is_p then\n\
    \          p = p + 1\n        end\n      end\n    end\n    if p > 2 then\n   \
    \   -- add prime number to key\n      table.insert(key, p)\n    end\n  end\n \
    \ -- return the key\n  return table.concat(key)\nend", "  -- convert string to\
    \ number\n  local n = 0\n  for i, v in ipairs(num) do\n    n = n * 16 + tonumber(v)\n\
    \  end\n  \n  -- prime numbers\n  local primes = {}\n  local primesLen = 0\n \
    \ for i = 2, sqrt(n) do\n    if n % i == 0 then\n      primes[#primes + 1] = i\n\
    \      primesLen = #primes\n    end\n  end\n  \n  -- return n\n  if primesLen\
    \ > 1 then\n    return primes[primesLen - 2]\n  end\n  \n  -- return n+1\n  local\
    \ n2 = math.floor(n/16) + 2\n  if n2 >= primesLen then\n    return n\n  end\n\
    \  return primes[n2]\nend", "  local nums = string.gmatch(num, \"(%d+)\")\n  local\
    \ prime_digits, nonprime_digits\n  \n  if #nums > 1 then\n    -- Only one number,\
    \ which may be a hexadecimal key \n    -- (i.e. '1077E'), so no need to test if\
    \ hex\n    prime_digits = nums\n  else\n    prime_digits, nonprime_digits = hex_num(num)\n\
    \  end\n  \n  return prime_digits, nonprime_digits\nend", "    local function\
    \ is_prime(n)\n        for i = 2,n do\n            if n%i == 0 then\n        \
    \        return false\n            end\n        end\n        return true\n   \
    \ end\n    local function is_hex(n)\n        return n >= 0 and n <= 16\n    end\n\
    \    local function is_digit(n)\n        return n >= 0 and n <= 9\n    end\n \
    \   local function next_char(s)\n        local ch = s:sub(1, 1)\n        s = s:sub(2)\n\
    \        return ch, s\n    end\n    local function next_digit(s)\n        local\
    \ ch = s:sub(1, 1)\n        s = s:sub(2)\n        return ch, tonumber(s)\n   \
    \ end\n    local function next_str(s)\n        local n = tonumber(s)\n       \
    \ s = s:sub(2)\n        return n, s\n    end\n    local function next_hex(s)\n\
    \        local n = tonumber(s)\n        s = s:sub(2)\n        return n, tonumber(s)\n\
    \    end\n    local function next_next_digit(s)\n        local ch, n = next_next_char(s)\n\
    \        if ch == 'A' or ch == 'B' then\n            if n == 1 then\n        \
    \        return next_hex(s)\n            elseif n ~= 2 then\n                return\
    \ next_next_digit(s)\n            else\n                return next_str(s)\n \
    \           end\n        elseif ch == 'C' or ch == 'D' then\n            if n\
    \ == 1 then\n                return next_hex(s)\n            elseif n ~= 3 then\n\
    \                return next_next_digit(s)\n            else\n               \
    \ return next_str(s)\n            end\n        elseif ch == 'E' or ch == 'F' then\n\
    \            if n == 1 then\n                return next_hex(s)\n            elseif\
    \ n ~= 5 then\n                return next_next_digit(s)\n            else\n \
    \               return next_str(s)\n            end\n        else\n          \
    \  return next_next_digit(s)\n        end\n    end\n    local function next_next_hex(s)\n\
    \        local ch, n = next_next_char(s)\n        if ch == 'A' or ch == 'B' then\n\
    \            if n == 1 then\n                return next_next_digit(s)\n     \
    \       elseif n ~= 2 then\n                return next_next_hex(s)\n        \
    \    else\n                return next_hex(s)\n            end\n        elseif\
    \ ch == 'C' or ch == 'D' then\n            if n == 1 then\n                return\
    \ next_next_digit(s)\n            elseif n ~= 3 then\n                return next_next_hex(s)\n\
    \            else\n                return next_hex(s)\n            end\n     \
    \   elseif ch == 'E' or ch == 'F' then\n            if n == 1 then\n         \
    \       return next_next_digit(s)\n            elseif n ~= 5 then\n          \
    \      return next_next_hex(s)\n            else\n                return next_hex(s)\n\
    \            end\n", "    local a = 0\n    local b = 0\n    local c = 0\n    local\
    \ d = 0\n    local e = 0\n    local f = 0\n    local g = 0\n    local h = 0\n\
    \    local i = 0\n    local j = 0\n    local k = 0\n    local l = 0\n    local\
    \ m = 1\n    local n = 0\n    local o = 0\n    local p = 2\n    local q = 3\n\
    \    local r = 5\n    local s = 7\n    local t = 11\n    local u = 13\n    local\
    \ v = 0\n    local w = 0\n    local x = false\n    local y = true\n    local z\
    \ = false\n    local a = tonumber(num)\n    local b = tonumber(num)\n    local\
    \ c = tonumber(num)\n    local d = tonumber(num)\n    local e = tonumber(num)\n\
    \    local f = tonumber(num)\n    local g = tonumber(num)\n    local h = tonumber(num)\n\
    \    local i = tonumber(num)\n    local j = tonumber(num)\n    local k = tonumber(num)\n\
    \    local l = tonumber(num)\n    local m = tonumber(num)\n    local n = tonumber(num)\n\
    \    local o = tonumber(num)\n    local p = tonumber(num)\n    local q = tonumber(num)\n\
    \    local r = tonumber(num)\n    local s = tonumber(num)\n    local t = tonumber(num)\n\
    \    local u = tonumber(num)\n    local v = tonumber(num)\n    local w = tonumber(num)\n\
    \    local x = tonumber(num)\n    local y = tonumber(num)\n    local z = tonumber(num)\n\
    \    return \nend", "\t-- Convert str to decimal number\n\tlocal decimal_value\
    \ = tonumber(num, 16)\n\t-- Convert decimal number to hexadecimal string\n\tlocal\
    \ hexadecimal_value = tostring(tonumber(decimal_value, 16))\n\t-- Convert hexadecimal\
    \ string to binary string\n\tlocal binary_string = tostring(decimal_value)\n\t\
    -- Convert binary string to boolean vector\n\tlocal binary_vector = binary_string\
    \ == '00000000000000000000000000000000'\n\t-- Iterate over vector and count the\
    \ 1s\n\tlocal count = 0\n\tfor i = 1, #binary_vector do\n\t\tif binary_vector[i]\
    \ then\n\t\t\tcount = count + 1\n\t\tend\n\tend\n\t-- Return value of count\n\t\
    return count\nend", "   local hex_key = '01234567BCD'\n   local i = 0\n   while\
    \ i <= #num do\n      local j = 1\n      while j <= #hex_key do\n         if hex_key:sub(i,i)\
    \ == num:sub(i, i) then\n            j = j + 1\n         else\n            break\n\
    \         end\n      end\n      if j == 2 or j == 3 then\n         return i\n\
    \      end\n      i = i + 1\n   end\n   return #num\nend", "  local n = tonumber(num)\n\
    \  if n == '0' then\n    return 0\n  end\n  \n  local hexs = \"\"\n  \n  -- Get\
    \ each hexadecimal digit in the string\n  for i = 1, n do\n    local hex = math.floor((n\
    \ - i) / 16)\n    -- If the current digit is not valid hexadecimal digit, continue\
    \ with next digit\n    if hex == 16 then\n      hexs = hexs .. 'F'\n      n =\
    \ n + 1\n      continue\n    end\n    \n    -- If the current digit is equal to\
    \ A, B, C, D, E, F, continue with next digit\n    if hex == 11 then\n      hexs\
    \ = hexs .. 'E'\n      n = n + 1\n      continue\n    end\n    \n    -- If the\
    \ current digit is equal to 1, 2, 3, or 5, continue with next digit\n    if hex\
    \ == 2 or hex == 3 or hex == 5 then\n      hexs = hexs .. 'E'\n      n = n + 1\n\
    \      continue\n    end\n    \n    -- If the current digit is 5, continue with\
    \ next digit\n    if hex == 5 then\n      hexs = hexs .. 'F'\n      n = n + 1\n\
    \      continue\n    end\n    \n    -- If the current digit is 2, continue with\
    \ next digit\n    if hex == 2 then\n      hexs = hexs .. 'F'\n      n = n + 1\n\
    \      continue\n    end\n    \n    -- If the current digit is 1, continue with\
    \ next digit\n    if hex == 1 then\n      hexs = hexs .. 'F'\n      n = n + 1\n\
    \      continue\n    end\n    \n    -- If the current digit is 0, continue with\
    \ next digit\n    if hex == 0 then\n      hexs = hexs .. 'F'\n      n = n + 1\n\
    \      continue\n    end\n    \n    hexs = hexs .. string.sub(tostring(hex), 1,\
    \ 1)\n    \n  end\n  \n  -- Count how many hexadecimal digits we have\n  local\
    \ count = 0\n  for i = 1, #hexs do\n    count = count + 1\n  end\n  \n  -- Check\
    \ if the current string contains B or D letter\n  -- If yes, we count how many\
    \ times it appears and return its value\n  if string.find(hexs, 'B') ~= nil or\
    \ string.find(hexs, 'D') ~= nil then\n    count = count + 1\n  end\n  \n  return\
    \ count\nend", "  local s = '' -- s is the string we are building\n  local n =\
    \ tonumber(num)\n  -- If s starts with 0 it is a prime number\n  if s == 0 or\
    \ s ~= nil then\n    if n == 0 or n ~= nil then\n      -- We are in a non-prime\
    \ number\n      n = tonumber(s)\n      if n == 0 or n ~= nil then\n        if\
    \ n >= 2 then\n          if n <= 15 then\n            -- We are in a prime number\n\
    \            -- If we find our digit in our number we know we found a prime\n\
    \            -- number, else we found a non-prime\n            if n > 13 then\n\
    \              -- We found our digit\n              s = s .. n\n            else\n\
    \              -- We found our digit and we already found a prime\n          \
    \    s = s .. n\n            end\n          else\n            -- We are in a non-prime\
    \ number\n            -- If we find our digit in our number we know we found a\
    \ prime\n            -- number, else we found a non-prime\n            if n >\
    \ 9 then\n              -- We found our digit\n              s = s .. n\n    \
    \        else\n              -- We found our digit and we already found a prime\n\
    \              s = s .. n\n            end\n          end\n        end\n     \
    \ end\n    end\n  end\n  return s\nend", "  local ret = 0\n  local base = 1\n\
    \  local digits = ''\n  local hex_digits = ''\n  local i = 1\n  repeat\n    hex_digits\
    \ = hex_digits .. string.sub(num, i, i)\n    i = i + 1\n  until i == num:len()",
  "  num = num:upper()\n  local count = 0\n  local n = 0\n  for i = 1, #num do\n \
    \   if string.sub(num,i,i) == 'A' then\n      n = n*16 + 16\n    elseif string.sub(num,i,i)\
    \ == 'B' then\n      n = n*16 + 8\n    elseif string.sub(num,i,i) == 'C' then\n\
    \      n = n*16 + 4\n    elseif string.sub(num,i,i) == 'D' then\n      n = n*16\
    \ + 2\n    elseif string.sub(num,i,i) == 'E' then\n      n = n*16 + 1\n    end\n\
    \  end\n  if n > 2 then\n    for i = 2, n do\n      if n ~= i then\n        count\
    \ = count + 1\n      end\n    end\n  end\n  if count == 0 then\n    count = 0\n\
    \  end\n  return count\nend", "\tlocal count = 0\n\t\n\t-- Your code starts here!\n\
    \t\n\t-- The \"right\" way to do this is with recursion.\n\t-- For a more comprehensive\
    \ solution, please see section 2.2\n\t-- of the OOP tutorial.\n\t\n\t-- The base\
    \ case is when the number has only 1 digit.\n\t-- A number is prime if the only\
    \ prime divisors divide the number.\n\t-- If so, return the number.\n\t\n\t--\
    \ The recursive case is when a number has more than 1 digit.\n\t-- If the number\
    \ is divisible by any of the numbers in the list \n\t-- of all prime divisors\
    \ (from 2 to sqrt(n)), then it can be divided by \n\t-- any number in the list.\
    \ The list is generated with list() \n\t-- and filter() functions.\n\t\n\t-- NOTE:\
    \ It may be difficult to understand some parts of the code.\n\t-- The Python code\
    \ can be found below.\n\t\n\t-- The Python code below is my solution for this\
    \ exercise.\n\t-- If it is incorrect or needs improvement, please let me know.\n\
    \t\n\t-- See also:\n\t-- OOP tutorial: https://www.tutorialspoint.com/oop_concepts/oop_concepts.htm\n\
    \t-- Python code: https://github.com/jasonbobichon/python-codes/blob/master/oop_example/hex_key.py\n\
    \t-- Recursion tutorial: https://www.tutorialspoint.com/recursion/recursion.htm\n\
    \t-- List: https://www.tutorialspoint.com/lua/lists_functions.htm\n\t-- Filter\
    \ function: https://www.tutorialspoint.com/python/python_list_filter.htm\n\t\n\
    \t-- The Python code below is my solution for this exercise.\n\t-- If it is incorrect\
    \ or needs improvement, please let me know.\n\t\n\t-- See also:\n\t-- OOP tutorial:\
    \ https://www.tutorialspoint.com/oop_concepts/oop_concepts.htm\n\t-- Python code:\
    \ https://github.com/jasonbobichon/python-codes/blob/master/oop_example/hex_key.py\n\
    \t\n\t-- The Python code below is my solution for this exercise.\n\t-- If it is\
    \ incorrect or needs improvement, please let me know.\n\t\n\t-- See also:\n\t\
    -- OOP tutorial: https://www.tutorialspoint.com/oop_concepts/oop_concepts.htm\n\
    \t-- Python code: https://github.com/jasonbobichon/python-codes/blob/master/oop_example/hex_key.py\n\
    \t-- Recursion tutorial: https://www.tutorialspoint.com/recursion/recursion.htm\n\
    \t\n\t-- The Python code below is my solution for this ", "    local t = ''\n\
    \    for i = 1, #num-1 do\n        t = (t:gsub('%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d',\n\
    \          function(x)\n            return tostring(#x)*2 + x\n        end))\n\
    \    end\n    return #t\nend", "  local hex = string.format('%x', tonumber(num))\n\
    \  local n = #hex\n  local count = 3\n  for i = 1, n do\n    local ch = hex:sub(i,\
    \ i)\n    count = count + ch:byte()\n  end\n  return count\nend", "    -- Complete\
    \ this function.\nend", "   num = num:upper()\n   if num:sub(1,2) ~= 'AB' and\
    \ num:sub(1,3) ~= '10' then\n      return 0\n   end\n   if #num % 2 == 0 then\n\
    \      return 0\n   end\n   local primes = {}\n   local n = 0\n   for i = 2, #num\
    \ - 1 do\n      local prime = 1\n      for k = 3, i / 2, 2 do\n         local\
    \ a = i%k\n         if a == 0 then\n            prime = false\n         end\n\
    \      end\n      if prime then\n         primes[n] = i\n      end\n      n =\
    \ n + 1\n   end\n   for k = 3, #num - 1 do\n      if primes[k] == num[k] then\n\
    \         return num[k] - 1\n      end\n   end\n   return 0\nend", "    local\
    \ n = 0\n    local primes = 0\n    local max = 0", "  num = tonumber(num)\n  local\
    \ primes = {2,3,5,7,11,13,17,19}\n  for i = 2, #primes, 2 do\n    local count\
    \ = 0\n    for j = 1, #num do\n      local v = string.format(\"%X\", tonumber(num:sub(i,i+1)))\n\
    \      if v ~= \"\" then\n        local hv = tonumber(v:sub(1,1))\n        count\
    \ = count + primes[i] * hv\n      end\n    end\n    if count == num then\n   \
    \   return primes[i]\n    end\n  end\n  return nil\nend\n</cell>\n<text>\nExercise\
    \ 4\nWrite a program that converts words from one language to another with only\
    \ alphanumeric characters (letters and numbers) using the following conversion\
    \ table (see the code of the function convert_word): \n{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}\n\
    Note: The words are case sensitive.", "  local p = 1\n  local counter = 1\n  local\
    \ key_str = ''\n  for i = 1, #num do\n    -- if hexadecimal digit is not between\
    \ 0-9, then it is a symbol\n    if string.sub(num,i,i) ~= '0123456789ABCDEF' then\n\
    \      key_str = key_str .. string.sub(num,i,i)\n      -- if the number is not\
    \ a prime, continue counting\n    elseif p == 1 or p > 1 then\n      if p == 1\
    \ then\n        counter = counter + 1\n      end\n      -- if the number is not\
    \ prime, keep counting until it becomes \n      -- prime (product of numbers 1\
    \ and 2 > 1)\n      while p ~= 1 and counter < 8 do\n        p = 3 * p + 1\n \
    \       counter = counter + 1\n      end\n      if p ~= 1 then\n        key_str\
    \ = key_str .. p\n        counter = counter + 1\n      end\n    else\n      p\
    \ = p + 1\n    end\n  end\n  return key_str\nend", "  if num == nil then return\
    \ end\n  if #num % 2 == 0 then\n    return nil -- error\n  end\n  -- convert string\
    \ to array of digits\n  local arr = string.gsub(num, string.char(48), string.char(255))\n\
    \  -- create array of digits to check\n  local digits = { }\n  local i = 1\n \
    \ for i=1,16 do\n    digits[i] = nil\n  end\n  -- convert hexadecimal digits to\
    \ decimal values\n  for i=1,16 do\n    local c = string.sub(arr,i,i)\n    if c\
    \ == 'A' then\n      c = 33\n    end\n    if c == 'B' then\n      c = 33\n   \
    \ end\n    if c == 'C' then\n      c = 34\n    end\n    if c == 'D' then\n   \
    \   c = 35\n    end\n    if c == 'E' then\n      c = 36\n    end\n    if c ==\
    \ 'F' then\n      c = 37\n    end\n    digits[i] = tonumber(c)\n  end\n  -- get\
    \ prime numbers for each digit\n  local primes = { }\n  for i=1,16 do\n    local\
    \ p, n = prime_for(digits[i])\n    if p and n then\n      primes[i] = p -- found\
    \ prime and number of digits\n    end\n  end\n  -- count number of primes\n  local\
    \ i = 0\n  local s = 0\n  for i=1,16 do\n    if digits[i] and digits[i] ~= nil\
    \ then\n      s = s + 1\n    end\n  end\n  -- return count\n  return s\nend",
  "    -- Your code here\nend", "\tlocal result = 0\n\tnum = tonumber(num)\n\tif num\
    \ then\n\t\tfor i=0,5 do\n\t\t\tlocal div = 1\n\t\t\twhile div < math.ceil(math.log(i,16))\
    \ do\n\t\t\t\tresult = result + math.ceil(i/math.pow(16,math.floor(math.log(i,16))))\n\
    \t\t\t\tdiv = div + 1\n\t\t\tend\n\t\tend\n\tend\n\treturn result\nend", "  --\
    \ Your code here\n  local i = 0\n  local ret = 1\n  while i < (num:len()) do\n\
    \    local c = num:sub(i,i)\n    if c ~= #c then\n      ret = ret * 16\n     \
    \ if c ~= 'A' and c ~= 'B' and c ~= 'C' and c ~= 'D' and c ~= 'E' and c ~= 'F'\
    \ then\n        ret = ret + ((c == '0'):int() or 10)\n      end\n    else\n  \
    \    i = i + 1\n    end\n  end\n  return ret\nend", "    local n = 0\n    for\
    \ i=0,#num-1,1 do\n        local hex = string.sub(num,i,i)\n        n = n*16 +\
    \ tonumber(hex)\n    end\n    return n\nend", "  local nums = tonumber(num)\n\
    \  -- A hexadecimal digit can be one of the following digits: 0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, A, B, C, D, E, F.\n  -- The prime numbers are 2, 3, 5, 7, 11, 13,\
    \ 17,...\n  -- So you have to determine a number of the following digits: 2, 3,\
    \ 5, 7, \n  -- B (=decimal 11), D (=decimal 13).\n  local hex = {}\n  for i =\
    \ 2, 11 do\n    local hexadecimal = nums % i\n    -- If the hexadecimal digit\
    \ is in the set: 3, 5, 7, B, D, then increment the counter.\n    if hexadecimal\
    \ >= 3 and hexadecimal <= 7 then\n      hex[#hex + 1] = i\n    end\n  end\n  return\
    \ #hex\nend", "    local key_digits = {}\n    for i = 0, #num - 1, 1 do\n    \
    \    local letter = string.sub(num, i, i)\n        key_digits[letter] = key_digits[letter]\
    \ + 1\n    end\n    local num_primes = 0\n    for i = #key_digits, 1, -1 do\n\
    \        if key_digits[i] <= 1 then \n            num_primes = num_primes + 1\n\
    \        elseif key_digits[i] <= 3 then\n            num_primes = num_primes +\
    \ 1\n        elseif key_digits[i] <= 5 then\n            num_primes = num_primes\
    \ + 1\n        elseif key_digits[i] <= 7 then\n            num_primes = num_primes\
    \ + 1\n        elseif key_digits[i] <= 11 then\n            num_primes = num_primes\
    \ + 1\n        elseif key_digits[i] <= 13 then\n            num_primes = num_primes\
    \ + 1\n        end\n    end\n    return num_primes\nend", "\tlocal count = 0\n\
    \tfor i = 1,#num,2 do\n\t\tlocal c = string.sub(num, i, i)\n\t\tcount = count\
    \ + math.floor(math.log(c,16)/math.log(10))\n\tend\n\treturn count\nend", "  local\
    \ primes = {\n    hexadecimal = 0, // \"num\" starts as 0\n    prime = 1, // 1\
    \ is a prime\n    two = 2, // first prime after 2\n    three = 3, // first prime\
    \ after 3\n    five = 5, // first prime after 5\n    seven = 7, // first prime\
    \ after 7\n    nine = 9, // first prime after 9\n  }\n  local digits = 0\n  local\
    \ index = 0\n  local sum = 0\n  while digits < num:len() do\n    index = num:sub(1,\
    \ digits):sub(2, digits:len() - 2)\n    sum = sum + primes[index]\n    digits\
    \ = digits + 2\n  end\n  return sum\nend", "    local count = 1\n    local digits\
    \ = {2,3,5,7,11,13,17,19}\n    -- find the first non-hex digit\n    local i =\
    \ 1\n    for i=1,#num-1 do\n        -- only consider digits, as there are more\
    \ digits to be found\n        if string.sub(num,i,i) ~= '#' then\n           \
    \ break\n        end\n    end\n    -- get the last non-hex digit\n    i = #num\n\
    \    for i=#num,1,-1 do\n        -- only consider digits, as there are more digits\
    \ to be found\n        if string.sub(num,i,i) ~= '#' then\n            break\n\
    \        end\n    end\n    -- if the digit before the last non-hex digit is less\
    \ than 7, \n    -- then the last digit will be less than 7, so do not add it\n\
    \    if num:sub(i-1,i) ~= '7' then \n        i = i + 1\n    end\n    -- add the\
    \ last digit\n    count = count + 1\n    -- loop through all hex digits, except\
    \ the first one (which is \n    -- always 2)\n    for i=2,#num-1 do\n        --\
    \ if the current hex digit is greater than or equal to the \n        -- the current\
    \ count, then it is prime, otherwise it is not \n        -- a prime, so to know\
    \ that it is prime, its multiplier must be a \n        -- prime number (i.e. it\
    \ must be a product of two smaller \n        -- numbers)\n        if num:sub(i,i)\
    \ >= count then\n            -- count must be a prime\n            if digits[count]\
    \ <= digits[count] then\n                count = count + 1\n            else\n\
    \                -- this hex digit is NOT a prime, so to know that it is \n  \
    \              -- NOT prime, its multiplier must be a prime number (i.e. \n  \
    \              -- it must be a product of two smaller numbers)\n             \
    \   for j=2,digits[count] do\n                    if digits[count]*j >= count\
    \ then\n                        count = count + 1\n                    end\n \
    \               end\n            end\n        end\n    end\n    -- return the\
    \ number of primes found\n    return count\nend", "   num = num:upper()\n   local\
    \ sum = 0\n   for i=1,#num do\n      local ch = num:sub(i,i)\n      if ch == 'A'\
    \ or ch == 'B' then\n         ch = ch+1\n      elseif ch == 'C' or ch == 'D' then\n\
    \         ch = ch+1\n      elseif ch == 'E' or ch == 'F' then\n         ch = ch+1\n\
    \      end\n      if ch > '9' then\n         break\n      end\n      if ch > 'F'\
    \ then\n         break\n      end\n      if ch > '7' then\n         break\n  \
    \    end\n      if ch > '5' then\n         break\n      end\n      if ch > '3'\
    \ then\n         break\n      end\n      if ch > '2' then\n         break\n  \
    \    end\n      if ch > '0' then\n         break\n      end\n      sum = sum +\
    \ 1\n   end\n   return sum\nend", "\tlocal n = 0\n\twhile n <= #num and num:sub(n,n+1)\
    \  ~= '' do\n\t\tif num:sub(n,n+1)  == 'A' or num:sub(n,n+1)  == 'B' or num:sub(n,n+1)\
    \  == 'C' or\n\t\t\tnum:sub(n,n+1)  == 'D' or num:sub(n,n+1)  == 'E' or num:sub(n,n+1)\
    \  == 'F' then\n\t\t\tlocal hexDigit = string.byte(num)\n\t\t\tif hexDigit ==\
    \ 11 then hexDigit = 13 else hexDigit = hexDigit + 1 end\n\t\t\tif hexDigit ==\
    \ 13 then hexDigit = 17\n\t\t\telseif hexDigit == 17 then hexDigit = 19\n\t\t\t\
    elseif hexDigit == 19 then hexDigit = 23 else\n\t\t\t\thexDigit = hexDigit + 3\n\
    \t\t\tend\n\t\t\tif hexDigit == 2 then hexDigit = 3 end\n\t\t\tif hexDigit ==\
    \ 3 then hexDigit = 5 end\n\t\t\tif hexDigit == 5 then hexDigit = 7 end\n\t\t\t\
    if hexDigit == 7 then hexDigit = 11 end\n\t\t\tif hexDigit == 11 then hexDigit\
    \ = 13 end\n\t\t\tif hexDigit == 13 then hexDigit = 17 end\n\t\t\tif hexDigit\
    \ == 17 then hexDigit = 19 end\n\t\t\tif hexDigit == 19 then hexDigit = 23 end\n\
    \t\t\tif hexDigit == 23 then hexDigit = 29 end\n\t\t\tif hexDigit == 29 then hexDigit\
    \ = 31 end\n\t\t\tif hexDigit == 31 then hexDigit = 37 end\n\t\t\tif hexDigit\
    \ == 37 then hexDigit = 39 end\n\t\t\tif hexDigit == 39 then hexDigit = 41 end\n\
    \t\t\tif hexDigit == 41 then hexDigit = 43 end\n\t\t\tif hexDigit == 43 then hexDigit\
    \ = 51 end\n\t\t\tif hexDigit == 51 then hexDigit = 59 end\n\t\t\tif hexDigit\
    \ == 59 then hexDigit = 61 end\n\t\t\tif hexDigit == 61 then hexDigit = 67 end\n\
    \t\t\tif hexDigit == 67 then hexDigit = 73 end\n\t\t\tif hexDigit == 73 then hexDigit\
    \ = 79 end\n\t\t\tif hexDigit == 79 then hexDigit = 83 end\n\t\t\tif hexDigit\
    \ == 83 then hexDigit = 91 end\n\t\t\tif hexDigit == 91 then hexDigit = 93 end\n\
    \t\t\tif hexDigit == 93 then hexDigit = 97 end\n\t\t\tif ", "    local ret = 0\n\
    \    for i=1, #num-1 do\n        local div, mod = div(num, 16)\n        if mod\
    \ == 0 or mod == 1 then\n            ret = ret + 1\n        else\n           \
    \ if mod == 0 then\n                ret = ret + 1\n            else\n        \
    \        ret = ret + 3\n            end\n        end\n        num = div\n    end\n\
    \    return ret\nend", "  local hex = \"\"\n  local count = 1\n  local last_num\
    \ = \"\"\n  local last_count = 0\n  for i=1,#num,1 do\n    local c = tonumber(num:sub(i,i))\n\
    \    if c == nil then\n      break\n    end\n    hex = hex..c\n    count = count*10\n\
    \    if last_count > count then\n      last_count = count\n      last_num = hex\n\
    \    end\n  end\n  if last_count > 0 then\n    count = last_count\n    hex = last_num\n\
    \  end\n  return count\nend", "    num = num:gsub(\"%a\",\"\")\n    num = tonumber(num)\
    \ \n    if num == nil then return nil end\n    \n    -- If num is less than 10,\
    \ it is not a prime number\n    if num < 10 then \n        return nil\n    end\n\
    \    -- Counting hexadecimal digits is a bit easier than counting decimal digits\n\
    \    local i = 1\n    while i <= #num do \n        if math.mod(tonumber(num),2)\
    \ == 0 then\n            i = i + 1\n        end\n        num = num:sub(1,2)\n\
    \    end\n    -- Checking if num is prime\n    if math.mod(tonumber(num),2) ==\
    \ 0 then\n        return nil\n    end\n    -- Checking  if num is a prime\n  \
    \  if tonumber(num) <= 1 then\n        return nil\n    end\n    local prime_count\
    \ = 0\n    -- Counting prime numbers is easier\n    while tonumber(num) ~= 1 do\n\
    \        prime_count = prime_count + 1\n        num = math.floor(num / 2)\n  \
    \  end\n    -- Prime number found\n    return prime_count\nend\n</code>\n<|/ a\
    \ tags=lua dscore=2 |>\n<| c |>\nThis does not answer the question. It is just\
    \ for learning how to write a function\n<|/ c |>\n<| a |>\nI have some code but\
    \ i am not sure why it work\n<code>", "    local c = 0\n    local n = 0\n    for\
    \ i = 1, #num, n+1 do -- skip leading spaces, count every char\n        local\
    \ hex = tonumber(string.sub(num,i,i))\n        if hex ~= nil then\n          \
    \  n = n + 1\n            -- every char except A B C D E F should be converted\
    \ to a number\n            if hex > 57 then\n                hex = hex + 4\n \
    \           end\n            if hex > 64 then\n                hex = hex + 6\n\
    \            end\n            if hex > 97 then\n                hex = hex + 8\n\
    \            end\n            if hex > 122 then\n                hex = hex + 10\n\
    \            end\n            if hex > 127 then\n                hex = hex + 12\n\
    \            end\n            if hex > 255 then\n                hex = hex + 16\n\
    \            end\n            if hex > 259 then\n                hex = hex + 20\n\
    \            end\n            -- if the char is a digit, add it to the counter\n\
    \            if hex >= 48 then\n                c = c + 1\n            end\n \
    \       end\n    end\n    return c\nend", "    local key_dig = ''\n    for i =\
    \ 1, #num do\n        local c = string.sub(num, i, i)\n        if c ~= ' ' and\
    \ c ~= '0' and c ~= '1' and c ~= '2' and c ~= '3' and c ~= '4' and c ~= '5' and\
    \ c ~= '6' and c ~= '7' and c ~= '8' and c ~= '9' and c ~= 'A' and c ~= 'B' and\
    \ c ~= 'C' and c ~= 'D' and c ~= 'E' and c ~= 'F' then\n            key_dig =\
    \ key_dig + c\n        end\n    end\n    -- remove symbols: A,B,C,D,E,F\n    key_dig\
    \ = string.gsub(key_dig, '[ABCDEF]', '')\n    -- convert into decimal representation\n\
    \    key_dig = tonumber(key_dig)\n    -- counts the number of key digits prime\n\
    \    -- since we know they are all numbers from 2 up to 9\n    -- just add them\
    \ up\n    -- note: since hexadecimal digits are in order from 0 to F\n    -- in\
    \ our algorithm, we need to count from the right side\n    -- i.e. add 8 instead\
    \ of 1 to get number of digits\n    local num = 0\n    for i = 8, 1, -1 do\n \
    \       num = num + math.pow(3, i)\n    end\n    -- determine whether it is a\
    \ prime number\n    -- by checking the modulus by 7\n    local isPrime = true\n\
    \    local keyDigits = math.pow(3, num)\n    for i = 1, math.pow(3, math.floor(math.log10(key_dig)))\
    \ do\n        -- if the remainder of key_dig is 0, it is not\n        -- a prime\
    \ number\n        if math.mod(key_dig, keyDigits) == 0 then\n            isPrime\
    \ = false\n            break\n        end\n        -- else it is a prime number\n\
    \    end\n    -- return the number of key digits prime number\n    return isPrime\
    \ and num\nend", "\tnum = tonumber(num)\n\tlocal count = 0\n\t\n\twhile true do\n\
    \t\tif num >= 2 then\n\t\t\tif num >= 6 and num % 6 == 0 then\n\t\t\t\treturn\
    \ 1 + count\n\t\t\tend\n\t\t\tcount = count + 1\n\t\tend\n\t\t\n\t\tif num ==\
    \ 0 then\n\t\t\treturn 0\n\t\tend\n\t\t\n\t\tnum = num / 16\n\tend\nend", "  \
    \  local hex_key = {}\n    local i = 1\n    while true do\n        local hexa\
    \ = string.sub(num,i,i)\n        local base = 10\n        if hexa == \"0\" then\n\
    \            if hexa[#hexa] ~= \"0\" then\n                break\n           \
    \ else\n                i = i + 1\n                hex_key[#hex_key + 1] = 0\n\
    \                continue\n            end\n        end\n        if hexa[#hexa]\
    \ ~= \"\" then\n            base = 16\n        end\n        local digit = tonumber(hexa,base)\n\
    \        if digit == nil then\n            break\n        end\n        hex_key[#hex_key+1]\
    \ = digit\n        i = i + 1\n    end\n    return #hex_key\nend", "    -- check\
    \ if the input is empty\n    if #num == 0 then return 0 end", "  local hexa_decimal\
    \ = {1,2,3,4,5,6,7,8,9,10,11,13,17}\n  local count = {}\n  for i = 1, #num do\n\
    \    local tmp_hex = string.sub(num, i, i)\n    local hex = tonumber(tmp_hex,\
    \ 16)\n    if hex in hexa_decimal then\n      count[hex] = count[hex] + 1\n  \
    \  end\n  end\n  return #count\nend", "  if num == nil then\n    return 1\n  else\n\
    \    num = num:upper()\n    if num ~= '' then\n      local count=0\n      for\
    \ i=1,#num,2 do\n        local hex=num:sub(i,i+1)\n        local dec=tonumber(hex,16)\n\
    \        if dec == 0 then\n          dec=hex:sub(1,1)\n        end\n        --\
    \ print((dec==2 and (hex:sub(1,2) == '0' or hex:sub(1,2) == '1')) or (dec==3 and\
    \ (hex:sub(1,3) == '0' or hex:sub(1,3) == '1' or hex:sub(1,3) == '2'))) \n   \
    \     -- print('dec',dec) \n        -- print('hex',hex) \n        -- print('hex:',hex)\
    \ \n        if dec == 2 and hex:sub(1,1) == '0' or dec==3 and hex:sub(1,1) ==\
    \ '0' or dec==5 and hex:sub(1,1) == '0' or dec==7 and hex:sub(1,1) == '0' or dec==9\
    \ and hex:sub(1,1) == '0' or dec==11 and hex:sub(1,1) == '0' or dec==13 and hex:sub(1,1)\
    \ == '0' or dec==17 and hex:sub(1,1) == '0' or dec==19 and hex:sub(1,1) == '0'\
    \ or dec==21 and hex:sub(1,1) == '0' or dec==23 and hex:sub(1,1) == '0' or dec==25\
    \ and hex:sub(1,1) == '0' or dec==27 and hex:sub(1,1) == '0' or dec==29 and hex:sub(1,1)\
    \ == '0' or dec==31 and hex:sub(1,1) == '0' or dec==33 and hex:sub(1,1) == '0'\
    \ or dec==35 and hex:sub(1,1) == '0' or dec==37 and hex:sub(1,1) == '0' or dec==39\
    \ and hex:sub(1,1) == '0' or dec==41 and hex:sub(1,1) == '0' or dec==43 and hex:sub(1,1)\
    \ == '0' or dec==45 and hex:sub(1,1) == '0' or dec==47 and hex:sub(1,1) == '0'\
    \ or dec==49 and hex:sub(1,1) == '0' or dec==51 and hex:sub(1,1) == '0' or dec==53\
    \ and hex:sub(1,1) == '0' or dec==55 and hex:sub(1,1) == '0' or dec==57 and hex:sub(1,1)\
    \ == '0' or dec==59 and hex:sub(1,1) == '0' or dec==61 and hex:sub(1,1", "   \
    \ local primes = {}\n    local prime_count = 0\n    local digits = {}\n    local\
    \ digit_count = 1", "\tnum = string.gsub(num, \" \", \"\") -- remove spaces\n\t\
    local primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997]\n\
    \tlocal count = 0\n\tlocal primes_num = #primes\n\tlocal primes_pow = 0\n\tlocal\
    \ primes_base = 0\n\tlocal i = 1\n\tlocal num = string.gsub(num, \" \", \"\")\
    \ -- remove spaces\n\tlocal is_prime = true\n\twhile i <= #num and is_prime ==\
    \ true do\n\t\tlocal num = tonumber(num)\n\t\tfor i = 1, primes_num do\n\t\t\t\
    primes_pow = primes_pow + primes[i]\n\t\t\tif num % primes[i] == 0 then\n\t\t\t\
    \tis_prime = false\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tcount = count + 1\n\
    \t\ti = i + 1\n\tend\n\treturn count\nend", "    local n = tonumber(num)\n   \
    \ if n == nil or n ~= n or n < 0 then\n        return '0'\n    end\n    local\
    \ num_str = ''\n    for i = 1,32 do\n        if i ~= n then\n            num_str\
    \ = num_str .. string.char(i)\n        end\n    end\n    -- num_str is a string\
    \ with digits from 0 to 9.\n    -- This can be easily transformed to binary representation\n\
    \    local b = { }\n    for j = 1,8 do\n        local num = tonumber(num_str)\n\
    \        if num ~= num then\n            return '0' \n        end\n        table.insert(b,\
    \ tonumber(num_str:sub(1, 1)))\n        num_str = num_str:sub(2)\n    end\n  \
    \  -- Transform b to binary representation of hexadecimal number with leading\
    \ zeros.\n    -- This can be used to find prime numbers.\n    local hex_str =\
    \ { }\n    for i = 1,8 do\n        table.insert(hex_str, string.char(b[i]))\n\
    \    end\n    return #hex_str\nend", "   assert(type(num)=='string')\n   assert(#num==16)\n\
    \   local count=0\n   for i=0,15 do\n      if tonumber(num:sub(i,i))==tonumber(i..'0')\
    \ then\n         count = count + 1\n      end\n   end\n   return count\nend",
  "    if num ~= nil and num ~= '' then\n        local digits = {}\n        for i\
    \ = 0, #num-1 do\n            local digit = tonumber(num:sub(i,i))\n         \
    \   table.insert(digits,digit)\n        end\n        local prime_count = 0\n \
    \       for i = 2, #digits do\n            if digits[i]:mod(i) == 0 then\n   \
    \             prime_count = prime_count + 1\n            end\n        end\n  \
    \      return prime_count\n    end\n    return nil\nend", "    local hex = string.format(\"\
    %x\", tonumber(num))\n    local prime_digit_count = 0\n    for i=1, hex do\n \
    \       local digit = string.byte(hex)\n        prime_digit_count = prime_digit_count\
    \ + (digit % 2 == 0 and 1 or -1)\n    end\n    return prime_digit_count\nend",
  "\tlocal function is_prime(n)\n\t\tif (n == 1) then return true end\n\t\tlocal sqrtn\
    \ = math.floor(math.sqrt(n))\n\t\tfor i=1, sqrtn-1 do\n\t\t\tif (n % i == 0) then\
    \ return false end\n\t\tend\n\t\treturn true\n\tend\n\tlocal function is_divisible_by_3(n)\n\
    \t\tif (n == 0) then return false end\n\t\tlocal sqrtn = math.floor(math.sqrt(n))\n\
    \t\tfor i=1, sqrtn-1 do\n\t\t\tif (n % i == 0) then return false end\n\t\tend\n\
    \t\treturn true\n\tend\n\tlocal function to_hex(num)\n\t\tlocal result = ''\n\t\
    \tfor i=1, #num do\n\t\t\tresult = result .. string.char(math.floor(num / 16)\
    \ + 48)\n\t\t\tnum = num mod 16\n\t\tend\n\t\treturn result\n\tend\n\tif (num\
    \ == '') then return 0 end\n\tlocal num = tonumber(num)\n\tlocal result = 0\n\t\
    if (is_prime(num)) then\n\t\tresult = result + 1\n\telse\n\t\tnum = to_hex(num)\n\
    \t\tfor i=1, #num do\n\t\t\tif (is_divisible_by_3(num[i])) then\n\t\t\t\tresult\
    \ = result + 1\n\t\t\telse\n\t\t\t\tresult = result + 1\n\t\t\t\tbreak\n\t\t\t\
    end\n\t\tend\n\tend\n\treturn result\nend", "\tlocal key = 0\n\tfor i, v in ipairs(num)\
    \ do\n\t\tkey = key * 16 + tonumber(string.sub(v,i,i))\n\tend\n\treturn key\n\
    end", "\tlocal result = 0\n\tlocal i = 0\n\tlocal last = 0\n\tlocal is_prime =\
    \ true\n\t\n\twhile num ~= '' do\n\t\tlast = tonumber(num)\n\t\tnum = sub(num,\
    \ 1, length(num))\n\t\t\n\t\tif last == 0 then\n\t\t\t-- last was 0 so must be\
    \ prime\n\t\t\t-- so now test all possible digits\n\t\t\tfor j = 1, 9 do\n\t\t\
    \t\tif last % j == 0 then\n\t\t\t\t\t-- j is a prime number\n\t\t\t\t\tis_prime\
    \ = false\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\t-- last was\
    \ anything else so not prime\n\t\t\t-- so now test all possible digits\n\t\t\t\
    for j = 1, 9 do\n\t\t\t\tlocal tmp = last * j\n\t\t\t\t\n\t\t\t\tif tmp == last\
    \ then\n\t\t\t\t\t-- last is a factor\n\t\t\t\t\tis_prime = false\n\t\t\t\t\t\
    break\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t\n\t\t-- now test if last is a factor\n\
    \t\tif is_prime then\n\t\t\tresult = result + 1\n\t\tend\n\tend\n\t\n\treturn\
    \ result\nend", "  local primes = {}\n  \n  -- Determine primes for number by\
    \ prime checking\n  for i = 2, #num do\n    local m = #num\n    local r = 1\n\
    \    while m > 1 do\n      if m % 2 == 1 then\n        r = r + 1\n        m =\
    \ m / 2\n      else\n        m = m / 2\n      end\n    end\n    \n    -- prime\
    \ check\n    if r == 1 then\n      primes[#primes+1] = i\n    end\n  end\n  \n\
    \  -- Count digit from 0 to 17\n  local key = 0\n  for i = 1, 17 do\n    -- count\
    \ number from 0 to 17 digit\n    key = key + 1\n    \n    -- prime check\n   \
    \ if primes[key + 1] and #num == key + 1 then\n      break\n    end\n  end\n \
    \ \n  return key + 1\nend", "    local key = 0\n    local str_num = tonumber(num)",
  "    local d = 0\n    local p = 0\n    local count = 1\n    -- find hexa number\
    \ length and check for prime number\n    local len = 0\n    for i = 1, #num, 1\
    \ do\n        if string.byte(num, i) = 'A' or string.byte(num, i) = 'B' or string.byte(num,\
    \ i) = 'C' or string.byte(num, i) = 'D' or string.byte(num, i) = 'E' or string.byte(num,\
    \ i) = 'F' then\n            len = len + 1\n        else\n            p = p +\
    \ 1\n        end\n    end\n    if len % 2 ~= 1 then\n        return nil\n    end\n\
    \    -- if len is odd, then divide by 2, else no need\n    if len % 2 ~= 0 then\n\
    \        len = len / 2\n    end\n    -- iterate from 1 to len\n    for i = 1,\
    \ len, 1 do\n        local m = 1\n        -- iterate from 2 to i to find remainder\n\
    \        for j = 2, i, 1 do\n            local c = string.byte(num, i)\n     \
    \       if c ~= nil and c >= '0' and c <= '9' then\n                m = m + (c\
    \ * math.pow(16, j))\n            end\n        end\n        local m1 = m\n   \
    \     local m2 = m\n        -- iterate from 3 to i to find remainder\n       \
    \ for j = 2, i, 1 do\n            local c = string.byte(num, i)\n            if\
    \ c ~= nil and c >= '0' and c <= '9' then\n                m2 = m2 + (c * math.pow(16,\
    \ j))\n            end\n        end\n        local n = 1\n        -- iterate from\
    \ 4 to i to find remainder\n        for j = 2, i, 1 do\n            local c =\
    \ string.byte(num, i)\n            if c ~= nil and c >= '0' and c <= '9' then\n\
    \                n = n + (c * math.pow(16, j))\n            end\n        end\n\
    \        -- check for divisor\n        if m1 == m2 then\n            count = count\
    \ + 1\n        end\n    end\n    -- remove extra decimals\n    if #num > 0 then\n\
    \        num = string.sub(num, 1, len - 1)\n    else\n        return nil\n   \
    \ end\n    -- hexadecimal numbers are integers, convert them to string\n    local\
    \ str = \"\"\n    for i = 1, #num, 1 do\n        str = str .. string.char(string.byte(num,\
    \ i))\n    end\n    return count\nend", "  num = string.gsub(string.gsub(string.upper(num),\
    \ '[A-F]', ''), '0', '')\n  local primes\n  primes = #num\n    ==> 9\n    local\
    \ index = 0\n    local prime_count = 0\n    local next_prime = 1\n    local last_prime\n\
    \    while prime ~= nil do\n      local current_prime = next_prime\n      local\
    \ current_factor\n      local current_digits\n      current_digits = #num\n  \
    \      ==> 11\n        local last_factor\n      last_factor = 1\n      while current_digits\
    \ > 1 do\n        last_factor = last_factor * last_prime\n        current_prime\
    \ = current_prime + 2\n        current_digits = current_digits / 2\n      end\n\
    \      current_factor = last_factor * current_prime\n      if prime ~= nil then\n\
    \        if prime == current_factor then\n          prime_count = prime_count\
    \ + 1\n        end\n      end\n      prime = current_prime\n      index = index\
    \ + 1;\n      next_prime = next_prime + 2\n    end\n    return prime_count\n \
    \ end\n  return hex_key(nil)\nend", "  local primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,\n\
    \     73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,\n    163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,\n\
    \    251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,\n    349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,\n\
    \    439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,\n    529,541,547,557,563,569,571,577,587,593,599,601,607,613,617,\n\
    \    619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,\n    727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,\n\
    \    827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,\n    937,941,947,953,967,971,977,983,991,997}\n\
    \  return #primes[#primes] - (#primes - 1) / 2 \nend", "   -- Your code here\n\
    \   -- Return the count of hexadecimal digits that are primes\n   -- that are\
    \ not product of two smaller hexadecimal digits.\n   -- Note: you may assume the\
    \ input is always correct or empty string, \n   -- and symbols A,B,C,D,E,F are\
    \ always uppercase.\n   -- Examples:\n   -- >>> hex_key('AB')\n   -- 1\n   --\
    \ >>> hex_key('1077E')\n   -- 2\n   -- >>> hex_key('ABED1A33')\n   -- 4\n   --\
    \ >>> hex_key('123456789ABCDEF0')\n   -- 6\n   -- >>> hex_key('2020')\n   -- 2\n\
    \   if num == nil then\n      return 0\n   end\n   local count = 1\n   for i=1,\
    \ #num-1 do\n      local n = tonumber(num[i])\n      if n ~= nil then\n      \
    \   if n % 2 == 1 then\n            if n ~= 3 then\n               if n ~= 5 then\n\
    \                  if n ~= 7 then\n                     if n ~= 11 then\n    \
    \                    if n ~= 13 then\n                           if n ~= 17 then\n\
    \                              if n ~= 19 then\n                             \
    \    if n ~= B then\n                                     if n ~= D then\n   \
    \                                     count = count + 1\n                    \
    \                   end\n                                    end\n           \
    \                      end\n                              end\n              \
    \             end\n                        end\n                     end\n   \
    \               end\n               end\n            end\n         end\n     \
    \ end\n   end\n   return count\nend", "  local num_chars = #num\n  -- if num doesn't\
    \ have enough characters to determine the number of \n  -- hexadecimal digits,\
    \ return -1\n  if num_chars < 2 then\n    return -1\n  end\n  -- if num has enough\
    \ characters to determine the number of hexadecimal \n  -- digits, return that\
    \ number\n  if num_chars == 2 then\n    return tonumber(num)\n  end\n  -- count\
    \ the number of hexadecimal digits that are primes (prime number, or\n  -- a prime,\
    \ is a natural number greater than 1 that is not a product of two \n  -- smaller\
    \ natural numbers).\n  local count = 2\n  local digits_count = 0\n  local prime_num\
    \ = 1\n  local is_prime = true\n  for i = 2, num_chars do\n    -- if it's a hexadecimal\
    \ digit, continue\n    if #num < i then\n      break\n    end\n    -- if it's\
    \ a prime number, continue\n    if num_chars - i <= 3 then\n      is_prime = false\n\
    \      break\n    end\n    -- if it's a non-prime number, add its digits to digits_count\
    \ and continue\n    digits_count = digits_count + i\n    i = i\n  end\n  -- if\
    \ the number of characters is even, return -1 for hexadecimal numbers\n  if num_chars\
    \ % 2 == 0 then\n    return -1\n  end\n  -- if the number of digits is not odd,\
    \ return -1 for hexadecimal numbers\n  if digits_count % 2 ~= 0 then\n    return\
    \ -1\n  end\n  -- if the number is greater than 1, return -1 for hexadecimal numbers\n\
    \  if prime_num > 1 then\n    return -1\n  end\n  -- if the number is less than\
    \ 1, return -1 for hexadecimal numbers\n  if prime_num < 1 then\n    return -1\n\
    \  end\n  -- if the number is a prime, return its number\n  if is_prime then\n\
    \    return prime_num\n  end\n  -- if the number is not a prime, return the number\
    \ of hexadecimal digit\n  -- (excluding the first digit)\n  return count\nend",
  "   local digits = \"\"\n   local c\n   if num == nil or type(num) ~= 'string' then\n\
    \      return nil\n   end\n   for c in string.gmatch(num, '%a') do\n      local\
    \ digit = c\n      local factor = 1\n      if c:upper() == 'A' then\n        \
    \ factor = factor * 4\n      elseif c:upper() == 'B' then\n         factor = factor\
    \ * 2\n      elseif c:upper() == 'C' then\n         factor = factor * 2\n    \
    \  elseif c:upper() == 'D' then\n         factor = factor * 3\n      elseif c:upper()\
    \ == 'E' then\n         factor = factor * 2\n      elseif c:upper() == 'F' then\n\
    \         factor = factor * 8\n      end\n      if digits:len() > 0 then\n   \
    \      digits = digits .. string.sub(digit, 2, 2)\n      else\n         digits\
    \ = digit\n      end\n      if digits:len() == 3 then\n         return digits:sub(2,\
    \ 2)\n      elseif digits:len() == 5 then\n         return digits:sub(2, 3)\n\
    \      end\n   end\n   if digits:len() == 0 then\n      return nil\n   end\nend",
  "\tlocal n = 0\n\twhile true\n\t\tdo\n\t\t\tlocal a = string.byte(num)\n\t\t\tif\
    \ not a then break end\n\t\t\tn = n + 1\n\t\t\tlocal b = string.byte(num, n, n)\n\
    \t\t\tif b == 1 then break end\n\t\t\tnum = string.sub(num, n, n)\n\t\tend\n\t\
    return n\nend", '    local hex = string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.',
  "    local digit_count = {}\n    for i = 1, (#num / 16) do\n        digit_count[#digit_count\
    \ + 1] = 1\n    end\n    for i = 1, (#num / 16 + 1) do\n        local digit =\
    \ num:sub(((i * 16) + 1), ((i * 16) + 16))\n        digit_count[#digit_count +\
    \ 1] = digit_count[#digit_count + 1] + 2\n        if digit_count[#digit_count]\
    \ == 3 then\n            digit_count[#digit_count] = 5\n        end\n    end\n\
    \    return digit_count[#digit_count]\nend\n</code>\n<|/ a dscore=1 tags=lua |>\n\
    <| c |>\nThe most common way for determining whether a number is prime is by checking\
    \ whether the sum of the digits of that number is divisible by 3, 6, 9, or 11.\n\
    <|/ c |>\n<| c |>\nThanks for your comment. That's true but this question asked\
    \ for a different method.\n<|/ c |>\n<| a dscore=0 tags=lua |>\n<code>", "  local\
    \ count = 1\n  num = tostring(num)\n  for i = 1, #num, 1 do\n    if num:sub(i,i)\
    \ == 'A' or num:sub(i,i) == 'B' or num:sub(i,i) == 'C' or num:sub(i,i) == 'D'\
    \ or num:sub(i,i) == 'E' or num:sub(i,i) == 'F' then\n      count = count + 1\n\
    \    end\n  end\n  return count\nend", "    local ret = 0\n    local i = 0\n \
    \   while i do\n        local n = tonumber(num, 16)\n        if n then\n     \
    \       ret = ret + n\n            i = i + 1\n        else\n            return\
    \ nil\n        end\n    end\n    if ret and ret % 2 == 1 and ret % 3 ~= 0 then\n\
    \        ret =  ret + 2\n    end\n    return ret\nend", "    -- Implement this\
    \ function.\nend", "\tlocal result = 0\n\t-- Convert each character to its integer\
    \ representation in base 10.\n\t-- Convert each integer to the base of the number\
    \ you want to determine. \n\t-- For example if you have hexadecimal number 'AB',\
    \ you need to convert it to \n\t-- decimal number 10 and then to base 10:\n\t\
    -- 10 (hex) = 2 \n\t-- 10 (dec) =  2\n\t-- Then you know that the number you want\
    \ to determine is 2.\n\tfor i = 1, #num, 1 do\n\t\tlocal digit = tonumber(string.format('%c%s',\
    \ num:sub(i, i+1), 'a'))\n\t\tif digit ~= nil then\n\t\t\tresult = result + digit\
    \ \n\t\tend\n\tend\n\treturn result\nend", "  local count = 0\n  for i=1,8 do\n\
    \    if num:sub(1,i)=='A' or num:sub(1,i)=='B' then\n      count = count+1\n \
    \   end\n  end\n  return count\nend", "  local n1 = tonumber(num:sub(1, 2))\n\
    \  local n2 = tonumber(num:sub(3, 4))\n  local n3 = tonumber(num:sub(6, 8))\n\
    \  local n4 = tonumber(num:sub(9, 12))\n  local n5 = tonumber(num:sub(12, 16))\n\
    \  local n6 = tonumber(num:sub(16, 20))\n  local n7 = tonumber(num:sub(20, 24))\n\
    \  local n8 = tonumber(num:sub(24, 28))\n  local n9 = tonumber(num:sub(28, 32))",
  "\tlocal digits = {0,2,3,5,7,11,13,17,19,23,29,31,37,41}\n\tlocal primes = {2,3,5,7,11,13,17,19,23,29,31}\n\
    \tlocal counter = 1\n\tfor i=1,#num do\n\t\tlocal digit = string.byte(num)[i]\n\
    \t\tif digit == nil then\n\t\t\ttable.insert(digits, 0)\n\t\t\treturn\n\t\tend\n\
    \t\tif digit >= #digits then\n\t\t\ttable.insert(digits, 0)\n\t\t\treturn\n\t\t\
    end\n\t\tif digits[digit] == nil then\n\t\t\tdigits[digit] = 0\n\t\tend\n\t\t\
    digits[digit] = digits[digit] + 1\n\tend\n\tfor i = 1, #primes do\n\t\tif digits[primes[i]]\
    \ > 1 then\n\t\t\tcounter = counter + 1\n\t\tend\n\tend\n\treturn counter\nend",
  "  local digit = {}\n  for i = 1, 4 do\n    digit[i] = math.floor(math.abs(num)\
    \ % (10 ** i))\n    num = math.floor(num / 10 ** i)\n  end\n  local hex_count\
    \ = 0\n  for i = 2, 6 do\n    local isPrime = true\n    for j = 2, i do\n    \
    \  if digit[i] == digit[j] then\n        isPrime = false\n        break\n    \
    \  end\n    end\n    if isPrime then\n      hex_count = hex_count + 1\n    end\n\
    \  end\n  return hex_count\nend", "\tlocal hexa = tonumber(num)\n\tlocal count\
    \ = 0\n\tif hexa then\n\t\tfor i=0,hexa do\n\t\t\tlocal d = tonumber(string.format('%x',\
    \ i))\n\t\t\tif d <= hex then\n\t\t\t\tcount = count + 1\n\t\t\telseif d > hex\
    \ then\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend", "    local\
    \ ret = 0\n    for i = 1, #num do\n        if #num < i then\n            break\n\
    \        end\n        local v = tonumber(string.sub(num, i, i), 16)\n        if\
    \ v == 1 then\n            ret\n        elseif v == 0 then\n            return\
    \ nil\n        elseif is_prime(v) then\n            ret += 2\n        end\n  \
    \  end\n    return ret\nend", "  -- Your code here\n  local hex_key = 0\n  \n\
    \  for i = 1, #num-1, 2 do\n    local digit = tonumber(string.sub(num, i, i+1))\n\
    \    if digit == nil then break end\n    hex_key = hex_key + digit * 16^(i-1)\n\
    \  end\n  \n  return hex_key\nend", "  local primes = setmetatable({}, { __mode=\"\
    k\"})\n  for i=1,16 do\n    local isPrime=false\n    for j = 1,i do\n      isPrime\
    \ = isPrime or  (num:sub(i,i)==num:sub(1,i))\n    end\n    if isPrime then\n \
    \     primes[i] = true\n    end\n  end\n  \n  -- Now we count the prime numbers\
    \ that start with the first hex digit\n  -- \n  local hexDigits = tonumber(num)\n\
    \  \n  if hexDigits<=0 then\n    return nil\n  end\n  \n  -- count the number\
    \ of primes we found\n  local count = 0\n  for i=1,16 do\n    if primes[i] then\n\
    \      count = count + 1\n    end\n  end\n  \n  -- count the hexadecimal digits\
    \ we found\n  local digits = 0\n  for i=1,16 do\n    if primes[i] then\n     \
    \ if isHexDigit(num:sub(i,i)) then\n        digits = digits + 1\n      end\n \
    \   end\n  end\n  \n  if digits > hexDigits then\n    -- if the length of the\
    \ input number is bigger than the number of \n    -- hexadecimal digits we have\
    \ found, it means we have an invalid input\n    return nil\n  end\n  \n  -- return\
    \ the correct value \n  return count\nend", "    if num ~= '' then\n        num\
    \ = string.lower(num)\n        if num:sub(1,1) == 'a' and num:sub(2,2) == 'b'\
    \ then\n            return hex_key(string.sub(num, 3, -1))\n        elseif num:sub(1,1)\
    \ == '0' then\n            return hex_key(string.sub(num, 2))\n        elseif\
    \ num:sub(1,1) == '1' and num:sub(2,2) == 'b' then\n            return hex_key(string.sub(num,\
    \ 2, -1))\n        elseif num:sub(1,1) == '2' and num:sub(2,2) == 'c' then\n \
    \           return hex_key(string.sub(num, 2, -1))\n        elseif num:sub(1,1)\
    \ == '3' and num:sub(2,2) == 'd' then\n            return hex_key(string.sub(num,\
    \ 2, -1))\n        elseif num:sub(1,1) == '4' and num:sub(2,2) == 'e' then\n \
    \           return hex_key(string.sub(num, 2, -1))\n        elseif num:sub(1,1)\
    \ == '5' and num:sub(2,2) == 'f' then\n            return hex_key(string.sub(num,\
    \ 2, -1))\n        elseif num:sub(1,1) == '6' and num:sub(2,2) == 'a' then\n \
    \           return hex_key(string.sub(num, 2, -1))\n        elseif num:sub(1,1)\
    \ == '7' and num:sub(2,2) == 'b' then\n            return hex_key(string.sub(num,\
    \ 2, -1))\n        elseif num:sub(1,1) == '8' and num:sub(2,2) == 'c' then\n \
    \           return hex_key(string.sub(num, 2, -1))\n        elseif num:sub(1,1)\
    \ == '9' and num:sub(2,2) == 'd' then\n            return hex_key(string.sub(num,\
    \ 2, -1))\n        elseif num:sub(1,1) == 'b' and num:sub(2,2) == 'e' then\n \
    \           return hex_key(string.sub(num, 2, -1))\n        elseif num:sub(1,1)\
    \ == 'c' and num:sub(2,2) == 'f' then\n            return hex_key(string.sub(num,\
    \ 2, -1))\n        elseif num:sub(1,1) == 'd' and num:sub(2,2) == 'a' then\n \
    \           return hex_key(string.sub(num, 2, -1))\n        elseif num:sub(1,1)\
    \ == 'e' and num:sub(2,2) == 'f' then\n            return hex_key(string.sub(num,\
    \ 2, -1))\n        end\n    else\n        return nil\n    end\nend", "    local\
    \ num_str, num_length = tonumber(num), string.len(num)\n    local prime_digits\
    \ = {2,3,5,7,11,13,17,19}\n    local prime_nums = {}\n    local is_prime = true\n\
    \    local prime_num = 1\n    local prime_len = 2\n    while prime_len <= num_length\
    \ do\n        local is_prime = true\n        for i=1,prime_len do\n          \
    \  local tmp_str = num_str:sub(i,i+1)\n            if tmp_str:sub(1,1) == '0'\
    \ then\n                is_prime = false\n            end\n        end\n     \
    \   if is_prime then\n            table.insert(prime_nums, prime_num)\n      \
    \      prime_num = prime_num * prime_len + prime_digits[prime_len]\n        end\n\
    \        prime_len = prime_len + 1\n    end\n    return #prime_nums\nend", " \
    \   -- Write your solution here\n    local num_str = string.rep(num, string.len(num))\n\
    \    local digits_prime_str = {}\n    local prime_num = 0\n    for i = 1, string.len(num_str),\
    \ 2 do\n        local dig = 0\n        local hex_digit = tonumber(num_str[i])\n\
    \        digits_prime_str[dig] = hex_digit\n        while hex_digit == tonumber(num_str[i\
    \ + 1]) do\n            digit_prime_str = tonumber(num_str[i + 1])\n         \
    \   dig = (dig + 1)\n            digits_prime_str[dig] = digit_prime_str\n   \
    \         hex_digit = digit_prime_str\n        end\n    end\n    prime_num = digits_prime_str[1]\n\
    \    for i = 2, string.len(num_str), 2 do\n        prime_num = prime_num + digits_prime_str[i]\n\
    \    end\n    return prime_num\nend", "  if #num < 1 then return 0 end\n  local\
    \ primes = {2,3,5,7,11,13,17,19}\n  local digits = str:match(\"^[a-fA-F0-9]+$\"\
    )\n  -- Convert letters to numbers and filter out any non-hexadecimal digits.\n\
    \  -- If there are letters, this will be treated as a number and therefore \n\
    \  -- will not be prime. Remove leading zeros.\n  num = tonumber(num)\n  num =\
    \ math.floor(num)\n  if num == 0 then return 0 end\n  num = num % 16\n  -- If\
    \ num is a prime, return it directly.\n  if digits and primes[num] then return\
    \ num; end\n  -- Otherwise check for multiples and find out which are factors.\n\
    \  local factors = {}\n  for i = 2, math.floor(math.log(num)) + 1 do\n    local\
    \ f = tonumber(num / i)\n    if not f then break end\n    factors[f] = f\n  end\n\
    \  for k, f in pairs(factors) do\n    -- If the number is divisible by another\
    \ prime number, add it to the \n    -- list of primes and then divide by it.\n\
    \    local f1 = tonumber(num / f)\n    if f1 then\n      primes[f1] = true\n \
    \     num = num / f\n    end\n  end\n  -- If there are no factors, return that\
    \ it's prime.\n  if #factors == 0 then return 1 end\n  -- Return the greatest\
    \ prime number that has all digits.\n  return #primes -- or primes[#primes] --\
    \ or whatever you prefer\nend", "\tnum = tostring(num)\n\tlocal i = 0\n\tlocal\
    \ n = 1\n\tlocal c = 0\n\twhile i < #num do\n\t\tlocal v = string.sub(num, i,\
    \ i)\n\t\tlocal a = tonumber(v)\n\t\tlocal b = tonumber(v:sub(1, 1))\n\t\tlocal\
    \ c = c * a + b\n\t\tif v == \"E\" then\n\t\t\tn = n + 1\n\t\t\tif c == 2 then\n\
    \t\t\t\tn = n + 3\n\t\t\t\tc = c + 1\n\t\t\tend\n\t\telse\n\t\t\tif c > 2 then\n\
    \t\t\t\tn = n + 3\n\t\t\t\tc = c + 1\n\t\t\tend\n\t\tend\n\t\ti = i + 1\n\tend\n\
    \tif n > 4 then\n\t\tn = n - 1\n\tend\n\treturn n\nend", "  -- Your code here.\n\
    \  return #num > 0 and #num % 2 == 0 or #num == 0\nend", "\t-- initialize with\
    \ hexadecimal digits count\n\tlocal hex_count = 0\n\t-- initialize with symbols\
    \ count\n\tlocal symbol_count = 0\n\t-- initialize with key count\n\tlocal key_count\
    \ = 0\n\t-- initialize with current key\n\tlocal key = '1'\n\t-- initialize with\
    \ current hexadecimal digit\n\tlocal hex = '1'\n\t-- initialize with current symbol\n\
    \tlocal symbol = 'A'\n\t-- initialize with current char\n\tlocal char\n\t-- initialize\
    \ with current hexadecimal value\n\tlocal hex_value\n\t-- initialize with current\
    \ symbol\n\tlocal symbol_value\n\t-- initialize with current current char value\n\
    \tlocal char_value\n\t-- initialize with last hexadecimal digit in string\n\t\
    local last_hex = '1'\n\t-- initialize with last symbol in string\n\tlocal last_symbol\
    \ = 'A'\n\t-- initialize with last char in string\n\tlocal last_char\n\t-- initialize\
    \ with last hexadecimal value in string\n\tlocal last_hex_value\n\t-- initialize\
    \ with last symbol in string\n\tlocal last_symbol_value\n\t-- initialize with\
    \ last char in string\n\tlocal last_char_value\n\t-- initialize with current hexadecimal\
    \ value\n\tlocal current_hex_value\n\t-- initialize with current symbol\n\tlocal\
    \ current_symbol\n\t-- initialize with current char in string\n\tlocal current_char\n\
    \t-- initialize with last hexadecimal digit in string\n\tlocal last_hex_value\n\
    \t-- initialize with last symbol in string\n\tlocal last_symbol_value\n\t-- initialize\
    \ with last char in string\n\tlocal last_char_value\n\t-- initialize with last\
    \ symbol in string\n\tlocal last_char\n\t-- initialize with last hex value in\
    \ string\n\tlocal last_hex\n\t-- initialize with last char value in string\n\t\
    local last_char\n\t-- initialize with last hex value in string\n\tlocal last_hex\n\
    \t-- initialize with last hex value in string\n\tlocal last_hex\n\t-- initialize\
    \ with last char value in string\n\tlocal last_char\n\t-- initialize with last\
    \ hex value in string\n\tlocal last_hex\n\t-- initialize with last char value\
    \ in string\n\tlocal last_char\n\t-- initialize with current symbol in string\n\
    \tlocal current_symbol\n\t-- initialize with current char in string\n\tlocal current_char\n\
    \t-- iterate over string\n\tfor char in string.gmatch(tostring(num), '%[a-f]')\
    \ do\n\t\t-- check if current char is a hex digit\n\t\tif string.byte(char) ==\
    \ 48 then\n\t\t\t-- check if current hexadecimal digit is not the last one\n\t\
    \t\tif ", "  local res = \"\"\n  for i=1,#num-1 do\n    local tmp = string.byte(num)\n\
    \    if string.byte(num)==\"A\" and (i==1 or string.byte(num)==\"B\") then\n \
    \     tmp = string.byte(num)-1\n    end\n    if tmp ~= 0 and tmp%2 ~= 0 then\n\
    \      res = res .. tmp\n    end\n  end\n  print(res)\n  return string.len(res)\
    \ \nend", "   if string.find(num,'[','^') then\n      print('Error - Input is\
    \ not a hexadecimal string!')\n      return false\n   end\n   if string.find(num,'^')\
    \ then\n      print('Error - Input is an empty string!')\n      return false\n\
    \   end\n   local hex_digits = {0,1,2,3,4,5,6,7,8,9,'A','B','C','D','E','F'}\n\
    \   local digit_map = {\n      A = 3,\n      B = 5\n   }\n   for i = 1, string.len(num)\
    \ do\n      if string.find(num,hex_digits[i]) then\n         local digit = string.sub(hex_digits[i],1,1)\n\
    \         if digit_map[digit] == nil then\n            print('Error - Wrong digit')\n\
    \            return false\n         end\n         digit_map[digit] = digit_map[digit]\
    \ + 1\n      end\n   end\n   local primes = 0\n   for k, v in pairs(digit_map)\
    \ do\n      if v == k then\n         primes = primes + 1\n      end\n   end\n\
    \   return primes\nend", "  -- Convert number string to array of numbers\n  local\
    \ arr = tostring(num):match('^%x%s*%d+'):gmatch('(.-)')\n  -- Convert array to\
    \ array of numbers\n  arr = arr:gsub('%d+',function(x) x..0)\n  -- Count the number\
    \ of primes\n  local count = 3\n  -- Loop through array of numbers\n  for i=2,#arr,1\
    \ do\n    -- Calculate the modulo (remainder) of current number with every number\
    \ in arr\n    local mods = arr:sub(i,i-1) * arr:sub(i-1,i)\n    -- If number mod\
    \ is 1 (prime), increment count\n    if mods == 1 then\n      count = count +\
    \ 1\n    end\n  end\n  return count\nend\nprint(hex_key('ABED1A33'))\nprint(hex_key('1077E'))\n\
    print(hex_key('AB'))\nprint(hex_key('123456789ABCDEF0'))\nprint(hex_key('2020'))",
  "  local hex_key = {}\n  local num_str = string.gsub(tostring(num), '[^a-f0-9]',\
    \ '')\n  if #num_str > 0 then\n    if #num_str ~= 6 then\n      error('Invalid\
    \ string for hex_key.')\n    end\n    hex_key[1] = 2\n    local j = 2\n    hex_key[2]\
    \ = 2\n    local i = 2\n    while i + 2 <= #num_str do\n      local c1 = num_str:sub(i,\
    \ i + 2)\n      if c1 ~= 'A' and c1 ~= 'B' and c1 ~= 'C' and c1 ~= 'D' and c1\
    \ ~= 'E' and c1 ~= 'F' then\n        error('Invalid symbol in hex_key.')\n   \
    \   end\n      if c1 ~= 'A' and c1 ~= 'B' then\n        hex_key[j] = tonumber(c1)\n\
    \      end\n      i = i + 2\n      j = j + 2\n    end\n    hex_key[4] = 2\n  \
    \  hex_key[5] = 2\n  end\n  return hex_key\nend", "    local num_digits = #num\n\
    \    local key_digits = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997}\n\
    \    for i = 1, num_digits, 2 do\n        local digit = tonumber(num:sub(i,i))\n\
    \        if digit ~= nil then\n            if key_digits[digit] ~= nil then\n\
    \                return key_digits[digit]\n            end\n        end\n    end\n\
    \    return nil\nend", "\t-- write your code here\n\tlocal num_str=\"\"\n\tfor\
    \ i=1,#num do\n\t\tnum_str=(num_str..tostring(math.abs(num:sub(i,i)-1))..\"0\"\
    )\n\tend\n\tlocal lenth=tonumber(num_str)\n\tlocal n=0\n\tlocal num2=0\n\tlocal\
    \ i=2\n\twhile i <= lenth do\n\t\tlocal prime = math.pow(i,2)\n\t\tif num > prime\
    \ then\n\t\t\tn = n + 1\n\t\tend\n\t\ti = i + 2\n\tend\n\tnum2=num-num*math.pow(n,2)\n\
    \treturn num2\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
