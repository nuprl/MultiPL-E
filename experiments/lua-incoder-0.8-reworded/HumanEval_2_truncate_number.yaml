name: HumanEval_2_truncate_number
language: lua
prompt: "-- Given a positive floating point number, it can be decomposed into\n--\
  \ and integer part (largest integer smaller than given number) and decimals\n--\
  \ (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
  -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
  \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
  \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local decimal_part = math.floor(math.abs(number))\n  if decimal_part\
    \ < number then\n    return decimal_part\n  else\n    local integer_part = math.ceil(number)\n\
    \    return integer_part\n  end\nend", "\tassert(type(number) ~= 'number' or (math.isnan(number)\
    \ and number ~= 0),\n\t\t'argument should be a number')", "    if number < 1 then\
    \ return 1 end\n    local scale = 1\n    if number >= 1 then\n        -- The largest\
    \ integer smaller than a given number.\n        -- In other words, find the largest\
    \ integer that is smaller than the\n        -- given number.\n        local i\
    \ = 1\n        while i <= number do\n            i = i * 10 + 1\n        end\n\
    \        scale = i - number\n    end\n    -- Get the decimal part.\n    local\
    \ decimal_part = math.modf(number - 1)[1]\n    -- Return the truncated number\
    \ and the number of decimals.\n    return decimal_part, scale\nend", "    return\
    \ math.floor((number - math.floor(number)) * 100) / 100\nend", "\tlocal integer_part\
    \ = 0\n\tlocal fractionals = 0\n\tfor part in string.gmatch(tostring(number),\
    \ \"%1.?[0-9]*\") do\n\t\tlocal integer = tonumber(part)\n\t\tif integer == 0\
    \ then\n\t\t\tbreak\n\t\tend\n\t\tinteger_part = integer_part * 10 + integer\n\
    \t\tfractionals = fractionals + 1\n\tend\n\tif fractionals == 1 then\n\t\treturn\
    \ integer_part\n\tend\n\treturn number - (integer_part + (integer_part and fractionals\
    \ * 10))\nend", "  assert(type(number) ~= 'number' or number > 0)\n  assert(number\
    \ >= 0)\n  local factor = 1\n  local integer = 0\n  local decimal = 0\n  while\
    \ number ~= 0 do\n    number = number / factor\n    integer = integer + 1\n  \
    \  factor = factor * 10\n    if factor > 1 then\n      decimal = decimal + 1\n\
    \    end\n  end\n  -- Decompose integer part and decimals.\n  if integer ~= 0\
    \ then\n    return integer * (10^decimal)\n  else\n    return 0\n  end\nend",
  "\tif number <= 1 then return number end\n\tlocal factor = 10\n\tlocal remainder\n\
    \twhile true do\n\t\tremainder = math.floor((number % factor) / factor)\n\t\t\
    number = math.floor(number / factor)\n\t\tif number == factor then\n\t\t\tbreak\n\
    \t\telse\n\t\t\tfactor = factor * 10\n\t\tend\n\tend\n\treturn remainder\nend",
  "    if number < 0.0 then\n        return 0.0\n    end\n    local integer_part =\
    \ math.floor(number)\n    local decimal_part = math.floor(math.abs(number - integer_part))\n\
    \    if decimal_part ~= 0.0 then\n        return integer_part + decimal_part /\
    \ math.pow(10.0, math.ceil(math.log10(decimal_part)))\n    else\n        return\
    \ integer_part\n    end\nend", "  -- We don't need exact precision for our purpose,\
    \ so we use integer\n  -- arithmetics. To do that, we multiply number by 10^precision,\
    \ where the\n  -- precision will be adjusted for numbers smaller than 1. The result\
    \ will\n  -- have precision equal to 'precision + truncate_fraction(number - 1)',\
    \ where the\n  -- truncate_fraction function is the one defined in this file.\
    \ The function\n  -- rounds down to the nearest integer. For example:\n  -- >>>\
    \ truncate_fraction(0.5)\n  -- 0\n  -- >>> truncate_fraction(1.0)\n  -- 1\n  --\
    \ >>> truncate_fraction(2.5)\n  -- 0\n  -- >>> truncate_fraction(0.0)\n  -- 0\n\
    \  -- >>> truncate_fraction(-0.5)\n  -- -1\n  -- >>> truncate_fraction(-1)\n \
    \ -- -1\n  -- >>> truncate_fraction(-1.5)\n  -- -1\n  -- >>> truncate_fraction(-2.5)\n\
    \  -- -1", "    local part1, part2 = math.modf(number)\n    return math.floor(part1),\
    \ part2\nend", "  -- >>> truncate_number(0.6)\n  -- 0.6\n  -- >>> truncate_number(-0.6)\n\
    \  -- 0.0\n  -- >>> truncate_number(0.3)\n  -- 0.30000000000000004\n  -- >>> truncate_number(-0.3)\n\
    \  -- -0.3\n  -- >>> truncate_number(0.00000002)\n  -- 0.2\n  -- >>> truncate_number(-0.00000002)\n\
    \  -- -0.02\n  return math.floor((number - math.floor(number)) * 10 + 0.5) / 10\n\
    end", "    -- Return just the integer part\n    if number <= math.trunc(number)\
    \ then\n        return math.trunc(number)\n    end", "  return tonumber(string.format(\"\
    %.1f\", number))\nend", "    local decimal_part = math.modf(number)[1]\n    local\
    \ integer = math.floor(number)\n    return integer + (decimal_part < 0.0 and 1\
    \ or 0)\nend", "    return math.floor(number - 0.5) * 10\nend", "   if number\
    \ <= 0 then\n      return 0\n   end\n   if number < 0.5 then\n      return number\n\
    \   end\n   local i = 1\n   while i * i < number do\n      i = i + 1\n   end\n\
    \   local remainder = (number - i) / i\n   return i * i + remainder\nend", "\t\
    local decimal, integer = math.modf(number)\n\treturn number - decimal\nend", " \
    \ local precision, integer_part, decimal_part = tonumber(number:gsub(\"%.\",\"\
    \"))\n  if precision == nil then\n    precision = 0\n  elseif precision == 0 then\n\
    \    return 0\n  else\n    return decimal_part\n  end", "\t-- Round up if necessary\
    \ to avoid returning huge numbers.\n\tif number >= 2^30 - 1 then\n\t\tnumber =\
    \ 2^30 - 1\n\tend\n\tlocal number, integerPart, decimalPart = math.round(number),\
    \ 0, number\n\t-- Get decimal part from the remainder of the division between\
    \ the number and\n\t-- the next power of 10.\n\tlocal _, nextDecimalPartInTheNumber\
    \ = math.modf(decimalPart)\n\t-- Divide the number by 10 and keep dividing till\
    \ we get to 1 by adding one\n\t-- to the integer part (until we reach 2^30 - 1).\n\
    \trepeat\n\t\tdecimalPart = nextDecimalPartInTheNumber\n\t\tintegerPart = integerPart\
    \ + 1\n\t\t_, nextDecimalPartInTheNumber = math.modf(decimalPart)\n\tuntil integerPart\
    \ > 2^30 - 1\n\t-- Return the decimal part.\n\treturn decimalPart\nend", "  local\
    \ precision = math.floor(math.log(number, 10)) + 1 -- +1 because the decimal part\
    \ always smaller than 1\n  local remainder, integerpart = math.modf(number)\n\
    \  return remainder / 10^precision, integerpart % 10^precision\nend\nreturn {\n\
    \  truncate_number = truncate_number\n}", "   local num = tonumber(number) or\
    \ 0\n   return math.floor(num / 10) * 10\nend", "  if number < 0 then\n    error(\"\
    Truncation is not defined for negative numbers\")\n  end\n  local floor_part =\
    \ math.floor(number)\n  local decimal_part = math.modf(number - floor_part)[1]\n\
    \  return floor_part, decimal_part\nend", "  assert(type(number) == \"number\"\
    , \"number must be a number\")\n  assert(number >= 0, \"number must be positive\"\
    )\n  return math.floor((number + math.floor(1)) / 2)\nend", "    local _, decimals\
    \ = math.modf(number)\n    if decimals == 0 then\n        return number\n    end",
  "  return math.floor((number - math.floor(number)) * 100) / 100\nend", "   local\
    \ decimal_part = math.floor(math.abs(number))\n   if decimal_part > math.ceil(math.abs(number))\
    \ then\n      return math.ceil(math.abs(number))\n   else\n      return math.floor(math.abs(number))\n\
    \   end\nend", "  if number < 1 then\n    return 0\n  end", "    local integer,\
    \ decimals = math.modf(number)\n    decimals = decimals > 0 and decimals or 1\n\
    \    return integer and integer - decimals or number\nend", "    local n = tonumber(number)\n\
    \    if not n then return number end", "    local integer = math.floor(number)\n\
    \    local decimal = number - integer\n    return integer + decimal\nend", " \
    \   local result = math.floor(number);\n    local decimals = math.floor(math.log(number)\
    \ / math.log(10));\n    result = (result - math.floor(result)) * 10 ^ decimals;\n\
    \    return result / 10 ^ decimals;\nend", "   local decimal_part = math.modf(number)[1]\n\
    \   return decimal_part * tonumber(string.format(\"%.1f\", number))\nend", " \
    \   local decimal = math.floor(number)\n    if decimal ~= number then\n      \
    \  return number\n    end\n    -- Truncate decimals to 1 or -1\n    decimal =\
    \ math.min(decimal, 1)\n    -- Return the decimal part only\n    return math.round(number\
    \ * 10^decimal) / 10^decimal\nend", "    -- Decompose the given floating point\
    \ number\n    local intPart = math.floor(number)\n    local decimals = number\
    \ - intPart\n    -- If there's more than 1 decimal part\n    if decimals > 1 then\n\
    \        -- Decompose the decimal part into an integer\n        local intDecimals\
    \ = math.floor(decimals)\n        -- Return the truncated number with decimals\n\
    \        return intPart .. \".\" .. intDecimals\n    else\n        return intPart\n\
    \    end\nend", "   assert(type(number) == 'number')\n   assert(number >= 0)",
  "  local i, decimals = math.modf(number)\n  local truncated = i + (decimals - math.trunc(decimals))\n\
    \  return truncated, decimals\nend", "  -- If the number is very large, ignore\
    \ it (we cannot know for sure\n  -- what will happen when truncating any small\
    \ integer)\n  if number > math.pi then\n    return number\n  else\n    -- Truncate\
    \ by first checking if the number is small enough and then\n    -- truncating\
    \ by checking if the remainder is small. Also avoid\n    -- using integer division\
    \ which will introduce a small rounding error in\n    -- the case where number\
    \ is small and we truncate it.\n    local function is_small_enough(number, decimals)\n\
    \      return math.floor((number - 1) / math.pow(10, decimals)) <= number\n  \
    \  end\n    local function truncation_check(remainder)\n      local rounded_number\
    \ = math.floor((remainder - 1) / math.pow(10, decimals))\n      return rounded_number\
    \ == remainder and rounded_number % math.pow(10, decimals) ~= 0\n    end\n   \
    \ local decimals = math.floor(math.log(number) / math.log(10))\n    return math.min(number,\
    \ math.ceil(number / math.pow(10, math.floor(decimals)) * math.pow(10, math.ceil(decimals))))\n\
    \  end\nend", "\tassert(type(number) == \"number\", \"Number must be a number\
    \ or convertible to a number.\")\n\tif number == 0 then\n\t\treturn 0\n\tend\n\
    \tlocal precision = math.floor(math.log(number, 10) + 1)\n\tlocal fraction = number\
    \ - truncate_number(math.pow(10, precision))\n\treturn math.round(fraction / math.pow(10,\
    \ -precision))\nend", "  -- Handle all cases where the number is less than 1.\n\
    \  -- The number is never less than 1 as long as it's positive.\n  -- >>> truncate_number(1)\n\
    \  -- 1\n  if number < 1 then\n    return 1\n  end", "  local decimals = math.floor(math.log(number)\
    \ / math.log(10) + 1)\n  return math.floor(number / 10^(decimals - 1)) / 10^decimals\n\
    end", "    local decimal_part = math.modf(number)[1]\n    if decimal_part >= 1\
    \ then\n        return number\n    end\n    return number - decimal_part\nend",
  "  local decimal_part = math.modf(number)[1]\n  return decimal_part * 10\nend",
  "  if number < 1 then\n    return math.NaN\n  end\n  local result = math.floor (number)\n\
    \  local decimals = math.mod (number, 1)\n  if decimals > 0 then\n    local factor\
    \ = 1\n    if decimals < 3 then\n      factor = decimals\n      decimals = 0\n\
    \    end\n    result = result + factor * (10^decimals)\n  end\n  return result\n\
    end", "   local decimal_part = math.floor(number)\n   local truncate_part = number\
    \ - decimal_part", "   local fraction, whole = math.modf(number)\n   return whole\
    \ + fraction / math.pow(10, math.floor(math.log10(number)))\nend", "  local sign\
    \ = number:sub(1,1)\n  number = number:sub(2)\n  if sign ~= '-' and number ~=\
    \ 0 then return number end\n  local decimals = {}\n  decimals.left = 1\n  local\
    \ decimal = tonumber(string.format(\"%.\" .. (#number-1) .. \"f\", number))\n\
    \  if decimal ~= number then decimals.right = number end\n  number = decimal\n\
    \  local integral = number\n  while true do\n    decimal = tonumber(string.format(\"\
    %.\" .. (#decimals.left) .. \"f\", number))\n    if decimal ~= number then break;\
    \ end\n    decimals.left = decimals.left + 1\n  end\n  if decimal < 1 then return\
    \ integral end\n  decimals.right = 1\n  decimal = tonumber(string.format(\"%.\"\
    \ .. (#decimals.right) .. \"f\", number))\n  if decimal ~= number then decimals.left\
    \ = number end\n  local power = 1\n  local total = 0\n  local decimals_left =\
    \ #decimals.left\n  for i = 1, decimals_left do\n    total = total + integral\
    \ * power\n    power = power * 10\n  end\n  return sign * total + decimals.left\
    \ * decimal\nend", "  local decimal_part = floor(number)\n  number = number -\
    \ decimal_part\n  return decimal_part + number\nend", "    local function add_decimals(number)\n\
    \        return math.floor(number * 10 + math.mod(number, 10)) / 10\n    end",
  "  -- The smallest floating point number with a decimal part smaller than 1.\n \
    \ local smallest_float = math.min(number, 1.0)", "  local result = math.floor(number)\n\
    \  local decimals = math.modf(number - result) * (math.pow(10, string.len(number)\
    \ - string.len(result)))\n  return result + decimals[1]\nend", "  local precision\
    \ = math.floor(math.log(number, math.huge))\n  return math.modf(number * math.pow(10,\
    \ precision))[1] / math.pow(10, precision)\nend", "    local integer_part, decimal_part\
    \ = math.modf(number)\n    return decimal_part * (10^-integer_part)\nend", " \
    \   local int_part = math.floor(number)\n    local fraction_part = number - int_part\n\
    \    \n    -- return integer part if fraction part is 0\n    if fraction_part\
    \ < 0 then\n        return int_part\n    else\n        return int_part + math.floor(fraction_part\
    \ * 10) / 10\n    end\nend", '  if number == nil then return nil end', "    --\
    \ Truncate decimal part\n    if number % 1 ~= 0 then\n        return math.trunc(number)\n\
    \    end", "   assert(type(number) == 'number')\n   assert(math.fmod(number, 1)\
    \ == 0)", "    local digit, fraction = math.floor(number), math.modf(number)\n\
    \    if digit < 0 then\n        digit = digit + 1\n        fraction = fraction\
    \ - number\n    end\n    return digit, fraction\nend", "    -- Test for NaN\n\
    \    if number == number then\n        return number\n    end", "  if number <\
    \ 0 then\n    error(\"cannot truncate negative numbers\")\n  end\n  local int_part,\
    \ decimals = math.modf(number)\n  return decimals\nend", "  if number < 1 then\n\
    \    return 0\n  end\n  local decimals = math.floor(math.log(number) / math.log(10))\
    \ + 1\n  return math.floor(number / 10^decimals) / 10^decimals\nend", "  local\
    \ factor = 10\n  local decimal_part = 0\n  while number >= factor do\n    number\
    \ = math.floor(number / factor)\n    decimal_part = decimal_part + 1\n  end\n\
    \  return math.floor(number), decimal_part\nend", "    if number <= 0 then return\
    \ nil end\n    local decimals, integer = math.modf(number)\n    local decimal_part\
    \ = math.floor(number)\n    local truncated = decimal_part\n    if integer > 0\
    \ then\n        truncated = truncated + 1 -- The decimal part is always smaller\
    \ than 1.\n    end\n    return truncated\nend", "   if number < 1 then\n     \
    \ return 0\n   end\n   local remainder = math.floor((number * 1e5) / 2)\n   return\
    \ remainder / 10\nend", "  local n, i = tonumber(number), 0\n  while n ~= 0 do\n\
    \    n = n / 10\n    i = i + 1\n  end\n  return math.floor(number * 10^i) / 10^i\n\
    end", "  if number == 0.0 then\n    return 0\n  end\n  if number < 0.0 then\n\
    \    number = number * -1.0\n  end\n  local integer_part = math.floor(number)\n\
    \  local fractional_part = number - integer_part\n  local frac_length = math.floor(math.log10(fractional_part))\n\
    \  local decimals = frac_length - 1\n  -- If fractional_part is less than 1, then\
    \ we are not interested in\n  -- fractional part at all.\n  -- If frac_length\
    \ == 0, then we are interested only in integer part.\n  return integer_part +\
    \ decimals, fractional_part / math.pow(10, decimals)\nend", "\tif number <= 0\
    \ then\n\t\treturn 0\n\tend\n\tif number ~= math.floor(number) then\n\t\tnumber\
    \ = math.floor(number)\n\tend\n\tlocal dec = 10\n\twhile number >= 1 do\n\t\t\
    number = number - dec\n\t\tdec = dec + 1\n\tend\n\treturn dec\nend", "   local\
    \ n = tonumber(number)\n   if n == nil then\n      return nil\n   end\n   local\
    \ fp = math.frexp(number)\n   local int = math.floor(n)\n   local decimals = fp\
    \ % 1\n   if decimals > 0 then\n      return int\n   else\n      return int -\
    \ decimals\n   end\nend", "  -- The largest integer smaller than the given number.\n\
    \  local largest = math.floor(number)\n  -- If this number is smaller than 1,\
    \ then return it.\n  if largest < 1 then\n    return number\n  end\n  -- The decimal\
    \ part of the number.\n  local decimal = number - largest\n  -- Return the fractional\
    \ part.\n  return decimal\nend", "  assert(type(number) == 'number')\n  if number\
    \ < 0 then\n    return 0\n  end\n  if number == 0 then\n    return number\n  end\n\
    \  assert(number > 0)\n  if number == math.floor_(number) then\n    return math.floor(number)\n\
    \  end\n  if math.modf(number)[1] then\n    return math.ceil(number)\n  end\n\
    \  return math.floor(number)\nend", "  return math.floor(number) + 0.5\nend",
  "    local sign = math.abs(number)\n    local exponent = math.floor(math.log(sign,\
    \ 10))\n    number = number * math.pow(10, -exponent)\n    local decimals = math.modf(number)\
    \ + 1\n    local digits = 10^(-exponent)\n    return sign * math.floor(number/digits)\
    \ * digits + decimals\nend", "  if number < 1 then\n    return nil, nil\n  end\n\
    \  local _, fraction = math.modf(number)\n  return math.floor(fraction), math.fmod(number,\
    \ math.floor(fraction))\nend", "    local trunc_part = math.floor(number)\n  \
    \  local dec_part = math.mod(number, 1)\n    return trunc_part + dec_part\nend",
  "  local factor = 1\n  while factor < number do\n    factor = factor * 10\n  end",
  "\tlocal integer_part = math.floor(number)\n\tlocal fraction = math.abs(number -\
    \ integer_part)\n\treturn integer_part, fraction\nend", "    local decimal_part\
    \ = math.modf(number)[0]\n    return decimal_part * math.pow(10, math.floor(math.log(number,\
    \ 10) + 1))\nend", '  local decimal_part = number - tointeger(number)', "  if\
    \ number == nil then return nil end\n  local remainder, rounded_number = math.modf(number)\n\
    \  if remainder > 0 then\n    return rounded_number\n  else\n    return rounded_number\
    \ - 1\n  end\nend", "  if number == 0 then\n    return 0\n  end\n  local digits\
    \ = math.floor(-math.log10(number))\n  return math.pow(10, digits)\nend", "  local\
    \ factor = 1\n  local modulus = number\n  while modulus ~= 0 do\n    factor =\
    \ factor * 10\n    modulus = modulus % 1\n  end\n  if modulus == 0 then\n    return\
    \ number\n  end\n  return number - truncate_number(number * factor / modulus)\n\
    end", "\tlocal _, dec = string.match(number, \"^(%d%d%d%d)%.?$\")\n\tlocal integer\
    \ = tonumber(string.sub(number, 1, math.ceil(dec)))\n\treturn integer + tonumber(string.sub(number,\
    \ math.ceil(dec) + 1))\nend", "    local factor = 10\n    local decimal_part\n\
    \    local integer_part\n    local decimal_digits", "\tif number == 0 then\n\t\
    \treturn 0\n\tend\n\tif number < 0 then\n\t\treturn number - math.pow(10, math.floor(math.log(number)/math.log(10)))\n\
    \tend\n\treturn number\nend", "   assert(type(number) ~= 'table' and type(number)\
    \ == 'number', 'number must be a number')\n   if number < 0 then\n      return\
    \ 0\n   end\n   if number < 1 then\n      return number\n   end\n   local integer_part,\
    \ decimal_part = math.modf(number)\n   if decimal_part == 0 then\n      return\
    \ integer_part\n   else\n      return integer_part + 1 -- add one to the decimal\n\
    \   end\nend", "   local sign = number and number < 0 and -1 or 1\n   local decimal_part\
    \ = math.modf(number)[1]\n   return math.floor(sign * decimal_part * 10) or 1\n\
    end", "    if number > 1 then\n        return math.floor(number)\n    end\n  \
    \  return math.round(number)\nend", "  local decimals = math.floor(math.log(number\
    \ - 1, 2))\n  number = math.floor(number / 2^decimals) / 2^decimals\n  if number\
    \ < 1 then\n    return 1\n  else\n    return number\n  end\nend", "    local integral,\
    \ fraction = string.match(number, \"^(%d%d*)(%d)$\")\n    if integral and fraction\
    \ and integral > 1 then\n        return math.floor(number / integral) * integral\n\
    \    end\n    return number\nend", "    local precision = math.floor(math.log(number)\
    \ / math.log(10))\n    local decimal_part = math.floor(number / 10^precision)\n\
    \    return decimal_part\nend", "    -- TODO: replace with a library\n    if number\
    \ < 1 then\n        return number\n    end", "  local n = math.floor(number)\n\
    \  local p = math.modf(number-n)\n  return n*100 + p[1]\nend", "\tlocal fraction,\
    \ integer = math.modf(number)\n\t\n\t-- Remove all non-integer part\n\tif integer\
    \ ~= 0 then\n\t\tfraction = math.floor(fraction * 100)\n\tend\n\t\n\treturn integer\
    \ * 100 + fraction\nend", "  local truncate_decimals = math._floor(number)\n \
    \ local truncate_factor = math.trunc(number)\n  local truncated = truncate_decimals\
    \ % truncate_factor\n  if truncated > 0 then\n    truncated + truncate_factor\n\
    \  end\n  return truncated\nend", "    local digits = math.floor(math.log(number)/math.log(10)\
    \ + 0.5) + 1\n    return math.floor(number/10^digits)\nend", "  -- The largest\
    \ integer smaller than given number.\n  local max_integer\n  -- The leftover part\
    \ (smaller than one).\n  local max_fraction\n  -- The decimal part (always smaller\
    \ than 1).\n  local decimal_part\n  max_integer = math.floor((number - math.floor((number\
    \ - max_fraction)) * max_fraction))\n  decimal_part = number - max_integer\n \
    \ if max_integer == 0 then\n    -- Return fraction.\n    return max_fraction\n\
    \  else\n    -- Return integer part and fraction.\n    return max_integer, decimal_part\n\
    \  end\nend", "   local decimal_part = tonumber(number:sub(1, number:len())) -\
    \ 1\n   return number - (decimal_part < 0.5 and decimal_part or 0)\nend", "  assert(type(number)\
    \ == \"number\", \"number must be a number\")\n  -- This implementation uses ~=\
    \ instead of > to avoid negative zeros\n  -- and to speed up operations using\
    \ truncate_number.\n  local function factorization(number)\n    local factor =\
    \ {}\n    local num_digits = math.floor(math.log(math.abs(number), 10))\n    if\
    \ num_digits > 10 then\n      -- The number has more than ten digits, recurse.\n\
    \      for i = 1, num_digits do\n        -- Add a new factor if its value is already\
    \ in the factor.\n        if factor[i] == number then\n          factor[i] = number\n\
    \        else\n          -- Otherwise, just add the value to the factor.\n   \
    \       factor[i] = factor[i] + number\n          number = number / factor[i]\n\
    \        end\n      end\n    else\n      -- The number is less than ten digits,\
    \ just add the digits to\n      -- the factor to keep the factor of the number.\
    \ The number\n      -- must be less than 1, or there will be an error due to the\n\
    \      -- division.\n      for i = 1, num_digits do\n        -- Add a new factor\
    \ if its value is already in the factor.\n        if factor[i] == number then\n\
    \          factor[i] = number\n        else\n          -- Otherwise, just add\
    \ the value to the factor.\n          factor[i] = factor[i] + number\n       \
    \ end\n        number = number / factor[i]\n      end\n    end\n    return factor\n\
    \  end", "    local decimal_part = number - math.huge\n    local integer_part\
    \ = math.floor(number)\n    local extra_integer_part = math.floor(decimal_part)\n\
    \    local fractional_part = math.modf(number)\n    local fractional_part = fractional_part[1]\n\
    \    return integer_part + fractional_part * math.pow(10, -extra_integer_part)\n\
    end", "    return math.trunc(number)\nend", "\tlocal i, count = math.modf(number)",
  "   local integerPart = 0\n   local decimalPart = 0", "  if number < 1.0 then\n\
    \    return math.round(number)\n  end\n  return math.floor(number) + 1\nend",
  "    return math.floor((number - math.floor(number)) % 1)\nend", "  -- If the number\
    \ is positive, just return the number\n  if number >= 0 then\n    return number\n\
    \  end\n  -- If the number is negative, we want to find the largest\n  -- (smallest\
    \ integer smaller than the given number) that\n  -- has no fractional part.\n\
    \  local number_int\n  local frac_int = 1\n  local frac_places = -1\n  -- Iterate\
    \ over all decimal places from 1 to 9, checking\n  -- for fractional part.\n \
    \ for i = 1, 9 do\n    local places = math.floor(math.log10(number))\n    -- Check\
    \ if the number is no longer than the number\n    -- of places.\n    if number\
    \ > 10^i then\n      -- If the current number is no larger than the number\n \
    \     -- of places, then this is the largest integer smaller\n      -- than the\
    \ given number that has no fractional part.\n      -- Return the fractional part\
    \ as an integer.\n      number_int = math.floor((number - frac_int * frac_places)/frac_int)\n\
    \      -- We need to truncate this integer (the fractional part) before\n    \
    \  -- returning, as that is the smallest integer with a fractional\n      -- part\
    \ smaller or equal than the given number.\n      -- In other words, this integer\
    \ will be the smallest integer\n      -- that has no fractional part.\n      return\
    \ math.floor(number_int * 10^i)\n    end\n    -- Keep track of the fractional\
    \ part and number of decimal places.\n    -- The fractional part is floored after\
    \ the decimal places have\n    -- been checked.\n    frac_int = frac_int * 10\n\
    \    frac_places = places\n  end\n  -- If the number has no fractional part, then\
    \ return the integer part.\n  return number_int\nend", "  local result = math.trunc(number)\n\
    \  return result - math.trunc(result / 10)\nend", "\tlocal i, i1, i2 = 1, math.floor(number),\
    \ math.ceil(number)\n\twhile i <= i2 do\n\t\ti = i + 1\n\t\tif number - i == 0\
    \ then\n\t\t\treturn i .. \"0\"\n\t\tend\n\tend\n\t\n\treturn number\nend", " \
    \   local intpart = 0\n    local fracpart = number", "  if number == 0 then\n\
    \    -- If the given number is 0, return 0 instead of -0.\n    return 0\n  end\n\
    \  if number == -1 then\n    -- If the given number is -1, return -1 instead of\
    \ -0.\n    return -1\n  end\n  if number % 1 == 0 then\n    -- If the given number\
    \ is an integer or a float, return it.\n    return number\n  end\n  -- If the\
    \ given number is negative, decompose it into an integer part\n  -- and a decimal\
    \ part.\n  local int_part, decimal_part = math.modf(number)\n  return truncate_number(int_part)\
    \ * 100 + decimal_part\nend", "    local integer = math.floor(number)\n    local\
    \ decimal = math.floor(number - integer)\n    integer = math.max(integer, 1)\n\
    \    decimal = math.min(decimal, 1)\n    return integer + (decimal == 0 and 0\
    \ or decimal)\nend", '    local _, decimals = math.modf(number)', "    local num\
    \ = tonumber(number)\n    local dec = 0\n    if num >= 0 then\n        dec = math.floor(math.log(num)\
    \ / math.log(10) + 1)\n        if dec <= 0 then\n            dec = 0\n       \
    \ end\n    end\n    return math.floor(num * 10^dec) / 10^dec\nend", "    local\
    \ integer = 0\n    local decimal = 0", "    if number < 1 then\n        return\
    \ nil\n    end\n    local div = math.floor\n    local mod\n    local dec = 0\n\
    \    while true do\n        mod = div(number, 10)\n        if mod == 0 then\n\
    \            break\n        end\n        dec = dec + 1\n        number = mod(number,\
    \ 10)\n    end\n    if dec == 0 then\n        -- number is already truncated\n\
    \        return number\n    end\n    return number - 10^dec\nend", "\tlocal num_str,\
    \ decimal = string.format(\"%0.f\", number:floor()), \"0\"\n\tif number:gt(1)\
    \ then\n\t\tdecimal, number = math.modf(number)\n\t\tnum_str = string.format(\"\
    %0.f\", number)\n\tend\n\treturn num_str, decimal\nend", "  local truncated =\
    \ 0\n  local decimals = 0\n  local i = 0\n  while number >= 1 do\n    i = i +\
    \ 1\n    number = math.floor(number)\n    truncated = truncated + number\n   \
    \ number = number - truncated\n    decimals = decimals + 1\n  end\n  local last_digit\
    \ = math.floor(number - truncated)\n  return last_digit * math.pow(10, -decimals)\n\
    end", "    local sign = math.sign( number )\n    local magnitude = math.abs(number)\n\
    \    if magnitude < 1 then\n        return number\n    end\n    local remainder\
    \ = magnitude - math.floor(magnitude)\n    local integer_part = math.floor( magnitude\
    \ )\n    local decimal_part = math.mod(magnitude, 1) - remainder\n    return integer_part\
    \ .. decimal_part\nend", "  return math.trunc(number):rep(1):mul(1):div(1):sub(1):rem(1)\n\
    end", "  return math.floor(number):type(number):div(1):float()\nend", "    local\
    \ factor = 10\n    local decimal = 0\n    local integer = 0", "  local sign, digits,\
    \ exponent = math.abs(number), {}, 0\n  while number > 0 do\n    table.insert(digits,\
    \ number % 10)\n    number = math.floor(number / 10)\n  end\n  -- At this point\
    \ digits contains all the digits of number truncated to the\n  -- right of the\
    \ decimal point.\n  -- As the number is positive, digits must contain at least\
    \ one non-zero.\n  if sign ~= 0 then\n    table.insert(digits, 0)\n  end\n  --\
    \ The exponent is defined as the number of leading zeroes in digits.\n  -- If\
    \ there are more non-zero digits in the digits-table than this, then\n  -- leading\
    \ zeroes are dropped, else the exponent is one larger than it should\n  -- be.\
    \ Since digits are right-biased, this also works properly for\n  -- negative numbers\
    \ (where digits is all but the right-most digit).\n  -- >>> truncate_number(-345.678)\n\
    \  -- -5.678\n  -- >>> truncate_number(-40.337)\n  -- -40.336\n  -- >>> truncate_number(0.337)\n\
    \  -- 0.336\n  if #digits > 1 then\n    exponent = #digits-1 -- One more than\
    \ the highest non-zero digit.\n  else\n    exponent = 0 -- No non-zero digits.\n\
    \  end\n  return sign, table.concat(digits, ''), exponent\nend", "    local integer_part\
    \ = math.trunc(number)\n    local decimal_part = number - integer_part\n    local\
    \ left_over = decimal_part < 1\n    return integer_part, decimal_part, left_over\n\
    end", "  return math.floor(number * 100) / 100\nend", "    if number >= 1 then\n\
    \        return math.trunc(number)\n    end\n    local remainder = number % 1\n\
    \    return number - remainder\nend", "  local parts = math.floor(number * 1000)\
    \ / 1000\n  if parts > 0 and number % 1 == 0 then\n    return math.floor(parts)\n\
    \  elseif parts > 0 then\n    return math.floor(number * 1000) / 1000\n  else\n\
    \    return math.floor(number)\n  end\nend", "  if number == 0 then\n    return\
    \ 0\n  elseif number < 0 then\n    local sign = 1\n    number = -number\n  else\n\
    \    local sign = 0\n  end", "    local num = tonumber(number)\n    if num ==\
    \ nil then\n        return number\n    end\n    if num == 0 then\n        return\
    \ 0.00\n    end", "    local int_part\n    local remainder\n    if number % 1\
    \ == 0 then\n        int_part = math.floor(number)\n        remainder = number\
    \ - int_part\n    else\n        int_part = number\n        remainder = 0\n   \
    \ end\n    return int_part, remainder\nend", "    if number < 1 then\n       \
    \ return number\n    end", "  local int_part = math.floor(number)\n  if number\
    \ - int_part < 0.5 then\n    return number\n  else\n    return int_part\n  end\n\
    end", "  assert(type(number) == 'number')\n  assert(number >= 0, 'number should\
    \ be greater than or equal to 0')\n  local _, decimals = math.modf(number)\n \
    \ return decimals\nend", "  local decimals, integer = math.modf(number)\n  return\
    \ integer or 0, decimals or 0\nend", "    local decimal_part = math.floor(number)\n\
    \    if decimal_part == 0 then\n        return 0\n    end\n    if decimal_part\
    \ == 1 then\n        return math.max(number, 0)\n    end\n    return math.max(decimal_part\
    \ - 1, 0)\nend", "  local integer = 0\n  local decimal = 1\n  while number >=\
    \ 1 do\n    integer = integer + 1\n    number = number - decimal\n    decimal\
    \ = 1 / decimal\n  end\n  return integer - decimal\nend", "  return math.floor(number):reverse():sub(1):reverse()\n\
    end", "\tlocal digits = 0\n\twhile true do\n\t\tnumber = math.floor(number)\n\t\
    \tif number < 1 then break end\n\t\tdigits = digits + 1\n\tend", "    local integer\
    \ = math.floor(number)\n    local decimal = math.modf(number - integer)\n    return\
    \ integer + decimal[1]\nend", "\tlocal decimal_part = math.floor(number)\n\tlocal\
    \ integer_part = number - decimal_part\n\treturn decimal_part + integer_part /\
    \ 10\nend", "  local result = 0\n  -- Split number in integer and decimal part.\n\
    \  local integer_part, decimal_part = math.modf(number)\n  -- Round decimal part.\n\
    \  decimal_part = math.round(decimal_part * 10)\n  -- If decimal part is more\
    \ than 0.1 then we add it to integer part.\n  if decimal_part > 0.1 then\n   \
    \ result = integer_part + decimal_part\n  end\n  -- Return integer part and decimal\
    \ part.\n  return result, decimal_part\nend", "  return math.floor(number):max(1):(1\
    \ / number)\nend", "  -- We first check if number is float or integer number\n\
    \  if number ~= number then\n    number = tonumber(number)\n    if number == nil\
    \ then\n      return nil, nil\n    end\n  end", "  if number < 0.0 then\n    number\
    \ = math.abs(number)\n  end\n  local i = 1\n  local result = 0.0\n  while number\
    \ > 0 do\n    local factor = 10^i\n    local remainder = math.mod(number, factor)\n\
    \    result = result + factor * remainder\n    number = number / factor\n    i\
    \ = i + 1\n  end\n  return result\nend", "  if number < 1 then\n    return nil\n\
    \  end\n  local num, decimals = math.modf(number)\n  local precision = tonumber(string.format(\"\
    %.%d\",\n                                      ((#num > 1 and num) or 0)))\n \
    \ local new_number = string.format(\"%.*f\", precision, number)\n  local result\
    \ = number\n  if decimals ~= 0 then\n    result = string.format(\"%.0f\", result)\n\
    \  end\n  return new_number\nend", "  if number < 1 then\n    return number\n\
    \  end", "    return math.floor(math.abs(number) + 0.5)\nend", "\tlocal decimal_part\
    \ = math.modf(number)[1]\n\tlocal integer_part = math.floor(number)\n\treturn\
    \ integer_part, decimal_part\nend", "    local factor = 1\n    local int_part,\
    \ decimal_part = math.modf(number)\n    if decimal_part > 1 then\n        factor\
    \ = math.pow(10, math.floor(math.log10(decimal_part)))\n    end\n    return int_part\
    \ * factor\nend", "   assert(number ~= nil, \"cannot truncate a nil number\")\n\
    \   if number < 0 then\n      number = -number\n   end\n   local factor = 1\n\
    \   local i = 1\n   local decimal = 1\n   for i = 1, math.floor(number), 1 do\n\
    \      factor = factor * 10\n      decimal = decimal * 10\n      if factor < 1\
    \ then\n         break\n      end\n   end\n   return number / factor\nend", " \
    \ assert(type(number) == 'number')\n  assert(number > 0)\n  local integerPart\
    \ = math.floor(number)\n  local decimalPart = number - integerPart\n  if decimalPart\
    \ == 0.0 then\n    return integerPart\n  else\n    return integerPart + decimalPart\
    \ * 10^(math.ceil(math.log10(number)))\n  end\nend", "  local truncated = math.floor(number)\n\
    \  local remainder, decimals = math.modf(truncated - number)\n  return remainder,\
    \ decimals\nend", "   -- Make sure the number isn't too small for even rounding.\n\
    \   local n = math.floor(number)\n   if n == 0 then\n      error()\n   end\n \
    \  local factor\n   local factor10\n   if n <= 10 then\n      factor = math.floor(n\
    \ / 10)\n      factor10 = n % 10\n   else\n      factor = math.floor(n / 100)\n\
    \      factor10 = n % 100\n   end\n   if factor10 == 0 and factor > 0 then\n \
    \     return truncate_number(factor * 10)\n   end\n   return factor * 10 + factor10\n\
    end", "  local num, decimals = math.floor(number), 0\n  while num < 1 do\n   \
    \ decimals = decimals + 1\n    num = math.floor(number * 10) + 1\n  end\n  return\
    \ number, decimals\nend", "  local integer, decimals = math.modf(number)\n  return\
    \ math.floor(integer + 0.5)\nend", "  local result = math.top.max(math.top.floor(number),\
    \ 1)\n  return math.abs(result - number) > 0.5 and number - result or result\n\
    end", "    local integer = math.floor(number)\n    local decimals = math.modf(number\
    \ - integer)[1]\n    return integer + (decimals > 0 and decimals or 0)\nend",
  "  if number <= 0 then\n    return 0\n  else\n    return math.floor((math.floor(number)\
    \ + 1) / 10)\n  end\nend", "  if number <= math.floor(nan) return number end\n\
    \  local digits = string.format('%.*f', string.byte(number), math.pow(10, string.len(number)\
    \ - 1))\n  local _, decimal = string.match(digits, '%f'):gsub('%d+$', ''):gsub('%d+',\
    \ '%d')\n  local integer = string.sub(digits, 1, string.len(digits) - decimal)\n\
    \  return integer * math.pow(10, string.len(integer) - 1)\nend", "  local factor\
    \ = 1\n  while number % factor == 0 do\n    factor = factor * 10\n  end\n  return\
    \ number / factor\nend", "  if number < 1 then\n    return nil\n  else\n    local\
    \ _, decimal = math.modf(number)\n    return decimal\n  end\nend", "  local integer_part\
    \ = math.floor(number)\n  local decimal_part = math.fmod(number, integer_part)\n\
    \  return decimal_part + integer_part\nend", "  local precision = math.floor(math.log(number\
    \ + 1, 10) + 1)\n  local factor = 10^precision", "    if number == nil then\n\
    \        return nil\n    end\n    local integer_part = math.floor(number)\n  \
    \  local decimal_part = math.modf(number)\n    if decimal_part[1] >= 1 then\n\
    \        return integer_part\n    else\n        return integer_part + 0.1\n  \
    \  end\nend", "  if number >= 1 then\n    return math.floor(number), math.floor(number\
    \ * 10) % 10\n  end\nend", "    -- Return the number itself if it's non-negative.\n\
    \    if not number then\n        return number\n    end\n    \n    -- If the number\
    \ has decimals, cut off those from the right.\n    if number < 1 then\n      \
    \  return number\n    end", "  assert(type(number) ~= 'number')\n  if number ==\
    \ 0 then\n    return number\n  end\n  local sign = number:floor()\n  number =\
    \ number:abs() - sign\n  if number < 0 then\n    number = -number\n    sign =\
    \ sign*-1\n  end\n  local decimals = number:gsub('.',''):gsub('[^0-9.]+',''):gsub('%+$','')\n\
    \  local integer_part = number:gsub('%+','')\n  number = sign + integer_part *\
    \ tonumber(decimals)\n  return number\nend", "    -- >>> truncate_number(2.5)\n\
    \    -- 2\n    -- >>> truncate_number(2)\n    -- 0\n    -- >>> truncate_number(0.1)\n\
    \    -- 0\n    return math.floor((number - math.floor(number)) * 100) / 100\n\
    end", "  return math.floor(math.abs(number)) * math.sign(number) - 1\nend", " \
    \ local result = math.floor(number)\n  -- Decompose the number into integer part\
    \ and decimal part.\n  local ipart = math.floor(result)\n  local dpart = math.min(number\
    \ - ipart, 1)\n  return ipart + (dpart / math.pow(10, math.floor(math.log10(dpart))))\n\
    end", "   if number < 0 then\n      error(\"Invalid argument '\" .. tostring(number)\
    \ .. \"'\")\n   end\n   local sign = 1\n   local decimal_part = 0\n   if number\
    \ > 0 then\n      number = math.floor(number)\n      sign = number\n      decimal_part\
    \ = math.fmod(number, 1)\n   end\n   return sign, decimal_part\nend", "    if\
    \ number < 1 then\n        return 0.0\n    end", "    -- First convert number\
    \ to string.\n    local number = tostring(number)", "   local part1 = math.floor(\
    \ number )\n   local part2 = math.mod( number, part1 )\n   return part2, part1\n\
    end", "    if number < 1 then\n        return number\n    end\n    local biggest_fraction\
    \ = math.round(number + 0.5)\n    local decimal_part = math.floor(biggest_fraction)\n\
    \    local fraction = biggest_fraction - decimal_part\n    return decimal_part,\
    \ fraction\nend", "  if number < 1 then\n    return 0\n  end\n  if number == 1\
    \ then\n    return 1\n  end\n  local factor = 0\n  while number % 2 == 0 do\n\
    \    factor = factor + 1\n    number = number / 2\n  end\n  number = number -\
    \ factor\n  local modulus = number\n  while modulus > 0 and modulus % 2 == 0 do\n\
    \    modulus = modulus / 2\n  end\n  return modulus\nend", "    local sign = number\
    \ < 0 and \"-\" or \"\"\n    local number_int = math.floor(number)\n    local\
    \ number_dec = number - number_int\n    local decimal_int = 1\n    if number_dec\
    \ > 0 then\n        decimal_int = 1\n        while number_dec ~= 0 do\n      \
    \      number_dec = number_dec / 10\n            decimal_int = decimal_int + 1\n\
    \        end\n    end\n    return sign .. tostring(number_int) .. \".\" .. tostring(decimal_int)\n\
    end", "  -- If number is smaller than one (like 1.9999999999999999999),\n  --\
    \ we can't get a decimal part by truncating, so we return number as-is.\n  --\
    \ Otherwise, if number is too big, we return 1\n  if number > 1.0 then\n    return\
    \ number\n  end", "  return math.floor(number) + 1\nend", "  return math.floor(number\
    \ * 100) / 100\nend", "    local sign = math.sign( number)\n    if sign == 0 then\n\
    \        error(\"The given number must be positive.\", 2)\n    end\n    local\
    \ factor = 1\n    local i = 1\n    while true do\n        local remainder = math.trunc(number/factor)\
    \ or 1\n        number = number/factor\n        factor = factor * 10\n       \
    \ if number == 0 then\n            break\n        end\n        local new_factor\
    \ = 1\n        local j = 1\n        while true do\n            local remainder_power\
    \ = math.mod(number, factor) or 1\n            number = number/factor\n      \
    \      new_factor = new_factor * 10\n            factor = factor * 10\n      \
    \      if factor > 1 and remainder == 0 then\n                break\n        \
    \    end\n            if remainder_power < 10 then\n                remainder\
    \ = \"0\" + remainder\n            elseif remainder == 0 then\n              \
    \  break\n            end\n            if j == 1 then\n                remainder\
    \ = truncate_number(remainder + remainder_power..\"e\"..j)\n            end\n\
    \            j = j + 1\n        end\n        if new_factor < 10 then\n       \
    \     factor = factor .. \"0\"..new_factor\n        else\n            factor =\
    \ factor .. new_factor\n        end\n    end\n    if sign == -1 then\n       \
    \ number = number * -1\n    end\n    return number\nend", "    local number =\
    \ tonumber(number)\n    if number == nil then\n        return\n    end\n    if\
    \ number < 1 then\n        return number\n    end\n    local integer_part, decimals\
    \ = math.modf(number)\n    return integer_part + (decimals * 1e6)\nend", "  return\
    \ math.floor((number - math.floor(number)) * 10)\nend", "    -- Get the decimal\
    \ part.\n    local decimal = math.floor(number)\n    local decimals = math.round(number\
    \ - decimal)\n    -- Get an integer part.\n    local integer = math.floor(decimal)\n\
    \    -- Return the number without decimal part.\n    return integer .. '.' ..\
    \ decimals\nend", "  local decimal_part = math.modf(number)\n  return decimal_part[1]\n\
    end", "    local factor = 0\n    if number > 1 then\n        while number > 1\
    \ do\n            local remainder = math.modf(number)\n            factor = factor\
    \ * 10 + remainder[1]\n            number = remainder[2]\n        end\n    end\n\
    \    return number / factor\nend", "    local function is_positive(number)\n \
    \       return number >= 0\n    end\n    if is_positive(number) then\n       \
    \ if number == 1 then\n            return 1\n        else\n            return\
    \ math.floor(number)\n        end\n    else\n        if number == -1 then\n  \
    \          return -1\n        else\n            return math.ceil(number)\n   \
    \     end\n    end\nend", "  return math.floor(number):round() / 100\nend", " \
    \ assert(type(number) == 'number')\n  assert(number > 0)", "\tif number < 1 then\n\
    \t\treturn number\n\telse\n\t\tlocal decimal_part = math.floor(math.log(number)\
    \ / math.log(10))\n\t\treturn math.pow(10, decimal_part) * number\n\tend\nend",
  "    local decimals = math.floor(number)\n    local result = number - decimals",
  "   local m = math.modf(number)\n   if m[1] ~= number then\n      return number\n\
    \   end\n   return math.floor(m[1]) * math.pow(10, math.floor(math.log10(m[1])\
    \ + 1))\nend", "\t-- First make sure that the decimal part is always below 1.\n\
    \tlocal decimal_part = math.floor(number)\n\tif decimal_part > 1 then\n\t\t--\
    \ Now truncate the decimal part. At least one truncated digit will do,\n\t\t--\
    \ so we are guaranteed to only truncate one digit from the decimal part.\n\t\t\
    -- We are also guaranteed that the integer part is at most half of the\n\t\t--\
    \ integer part.\n\t\tlocal trunc_part = math.floor(number - decimal_part - 0.5)\n\
    \t\treturn trunc_part\n\telse\n\t\treturn decimal_part\n\tend\nend", "  -- Truncate\
    \ the number down if it too large for integer.\n  if number > math.floor() then\n\
    \    return math.trunc(number)\n  end", "  if number >= 0 then\n    local digits\
    \ = math.floor(math.log(number)/math.log(10))\n    return math.trunc(number/math.pow(10,\
    \ digits))\n  end\n  return number\nend", "  local decimal_part = math.floor(number)\n\
    \  local integer_part = math.floor(number - decimal_part)\n  -- If the fractional\
    \ part has too many decimals we need to remove them\n  -- (the number itself is\
    \ never truncated).\n  -- E.g. truncate 3.45 to 3.5, but do not truncate 3.4500001\
    \ to 3.49999.\n  if decimal_part < 1000 and\n    integer_part == 0 and\n    (decimal_part\
    \ % 1000) ~= 0 and\n    decimal_part % 1000 ~= 0\n  then\n    integer_part = math.floor(number\
    \ - decimal_part)\n  end\n  return decimal_part, integer_part\nend", '  local
    i, decs = math.modf(number)', "    return math.floor(number):mod(1):mul(1):div(1):add(1)\n\
    end", "\tlocal sign = math.sign(number)\n\tlocal decimal_part = math.trunc(number\
    \ * 10)\n\tif sign == -1 then\n\t\tdecimal_part = -decimal_part\n\tend\n\treturn\
    \ decimal_part\nend", "  local decimal_part = math.floor(number)\n  if decimal_part\
    \ < 1 then\n    return number\n  end\n  return number - decimal_part\nend", " \
    \  local integer,decimal = math.modf(number)\n   return math.floor(number),decimal\n\
    end", "    local decimal_part = math.floor(math.log(number) / math.log(10) + 0.5)\n\
    \    if decimal_part < 1 then\n        -- Round it down:\n        number = math.floor(number)\n\
    \    end\n    return number / math.pow(10, decimal_part)\nend", "  if number <\
    \ 0 then\n    error(\"Argument should be a positive float\")\n  end\n  local floor_of_int\
    \ = math.floor(number)\n  local fraction = number - floor_of_int\n  return floor_of_int\
    \ + (fraction < 0 and 0.5 or fraction)\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
