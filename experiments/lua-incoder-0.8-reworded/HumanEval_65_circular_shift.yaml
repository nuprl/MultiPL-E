name: HumanEval_65_circular_shift
language: lua
prompt: "-- Circular shift the digits of the integer x, shift the digits right by\
  \ shift\n-- and return the result as a string.\n-- If shift > number of digits,\
  \ return digits reversed.\n-- >>> circular_shift(12, 1)\n-- '21'\n-- >>> circular_shift(12,\
  \ 2)\n-- '12'\nlocal function circular_shift(x, shift)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = circular_shift\n\
  \    lu.assertEquals(candidate(100, 2), '001')\n    lu.assertEquals(candidate(12,\
  \ 2), '12')\n    lu.assertEquals(candidate(97, 8), '79')\n    lu.assertEquals(candidate(12,\
  \ 1), '21')\n    lu.assertEquals(candidate(11, 101), '11')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  assert(shift > 0)\n  local num_digits = math.floor(math.log(abs(x),\
    \ 10))\n  assert(num_digits >= shift)\n  \n  local result = \"\"\n  while x >\
    \ 0 do\n    local digit = x % 10\n    local remainder = x % 10\n    x = math.floor(x\
    \ / 10)\n    \n    if remainder == 0 then\n      if result ~= \"\" then\n    \
    \    result = string.gsub(result, string.reverse(digit), digit)\n      else\n\
    \        result = digit\n      end\n    else\n      result = string.reverse(digit)\n\
    \    end\n  end\n  \n  if result ~= \"\" then\n    local offset = 0\n    for i\
    \ = 1, shift do\n      offset = offset + math.pow(10, shift)\n    end\n    result\
    \ = string.reverse(result)\n    result = string.gsub(result, offset, result)\n\
    \  else\n    result = \"\"\n  end\n  \n  if shift <= num_digits then\n    result\
    \ = string.reverse(result)\n  end\n  \n  return result\nend", "  local digits\
    \ = x:reverse()\n  shift = shift or 1\n  if shift > #digits then return digits\
    \ end\n  -- Circular shift the digits of the integer\n  digits = digits:reverse()\n\
    \  local carry\n  do\n    local d = digits:shiftRight(shift)\n    digits = digits:sub(1)\n\
    \    -- Carry from previous digit\n    carry = digits:sub(0, 1) and 1 or 0\n \
    \   digits = d + carry\n  end\n  return digits:reverse()\nend", "    if shift\
    \ > math.floor(x/10) or shift < 0 then\n        return '0'\n    end\n    local\
    \ result = \"\"\n    local carry = 1\n    for i = 1, math.floor(x/10) - math.floor(shift/10)\
    \ do\n        local digit = math.floor(x%10)\n        result = result .. (((10*digit)\
    \ + carry) .. string.sub(digitstrings,math.floor(digit/10)-1,math.floor(digit/10)-1))\n\
    \        carry = digit%10\n    end\n    return result.. (((10*carry) + math.floor(x/10))..string.sub(strings,math.floor(shift/10)-1,math.floor(shift/10)-1))\n\
    end", "   local s = math.floor(math.log10(x))\n   if shift > s then\n      shift\
    \ = s\n   end\n   local result = {}\n   for i = 1, shift do\n      result[i] =\
    \ x:sub(1, math.floor((x % 10)))\n      x = math.floor(x / 10)\n   end\n   result[i]\
    \ = x\n   return table.concat(result)\nend", "  if x == 0 then\n    return ''\n\
    \  else\n    local sign = ''\n    if x < 0 then\n      sign = '-'\n      x = -x\n\
    \    end\n    local digits, shift = 0, shift\n    repeat\n      digits = digits*10\
    \ + ((x%10) + shift)\n      x = math.floor(x/10)\n    until x > 1\n    digits\
    \ = digits + math.floor(x/10)\n    if digits == 0 and shift > 0 then\n      return\
    \ sign..(shift == 1 ? '' : circular_shift(shift, shift - 1))\n    end\n    if\
    \ digits == 0 then\n      shift = 0\n    else\n      shift = shift - 1\n    end\n\
    \    return sign..digits_to_string(digits, shift)\n  end\nend", "    local digits\
    \ = tostring(x) or '0'\n    shift = shift or 1\n    if shift > 1 then\n      \
    \  return digits.sub(1, #digits + shift)\n    else\n        return digits.sub(1,\
    \ #digits - shift)\n    end\nend", "  shift = shift or 0\n  local num_digits =\
    \ math.floor(math.log(x, 10))\n  x = x / math.pow(10, num_digits)\n  x = x * math.pow(10,\
    \ shift)\n  x = x / math.pow(10, num_digits - shift)\n  return tostring(x)\nend",
  "\tlocal digits = math.floor(math.log(x, 10)) + 1\n\t-- Reverse the digits of x\
    \ for 0 <= shift <= digits.\n\tlocal function reverse(x, shift)\n\t\treturn ((x\
    \ % 10 + shift * 10) % 10) * math.floor(x / 10)\n\tend\n\t-- Shift right by shift,\
    \ then reverse digits and return.\n\treturn (reverse(math.mod(x, 10) + shift,\
    \ shift):reverse() * math.floor(x / 10)) * math.floor(x / 10) % 10\nend", "  local\
    \ result = {}\n  repeat\n    local digit = math.floor((x / 10) * 10)\n    if shift\
    \ > 0 then\n      digit = digit + shift - #result\n    end\n    table.insert(result,\
    \ digit)\n    x = x - digit\n  until x == 0\n  return table.concat(result, '')\
    \ .. '0'\nend", "  shift = shift or 1\n  local digits = tostring(x) or ''\n  local\
    \ ndigits = #digits\n  if shift >= 0 then -- Negative shift.\n    -- Append shift\
    \ to digits.\n    for i = math.max(digits .. '', 1); i >= math.floor(ndigits);\
    \ i = math.floor(ndigits) do\n      ndigits = math.floor(ndigits/2)\n      if\
    \ ndigits == 0 then break end\n      digits = digits:reverse()\n    end\n  else\
    \ -- Positive shift.\n    -- Remove shift from digits.\n    if ndigits > shift\
    \ then\n      digits = digits:reverse()\n    end\n  end\n  return digits\nend",
  "\tlocal digits = math.floor(x/10**shift)\n\tx = x - digits*(10**shift)\n\t\n\t\
    local result = \"\"\n\tfor i = 1, digits do\n\t\tresult = result .. string.format(\"\
    %d\", math.mod(x, 10))\n\t\tx = math.floor(x/10)\n\tend\n\t\n\treturn result\n\
    end", "  local digits = tostring(x)\n  local result = \"\"\n  local digits_length\
    \ = digits:len()\n  if shift == 0 then\n    return digits\n  elseif shift > digits_length\
    \ then\n    shift = digits_length\n  end\n  -- Shift the digits by shift times\
    \ to get to the right position.\n  local digits_shift = digits:sub(1, digits_length\
    \ - shift)\n  -- Reverse the digits if the shift amount is greater than the number\
    \ of digits.\n  if shift > digits_length then\n    digits = digits:reverse():sub(1,\
    \ digits_length - shift)\n  end\n  -- Shift the digits and rebuild the string.\n\
    \  for i = digits_length - shift, 1, -1 do\n    local digit_i = digits:sub(i,\
    \ i)\n    result = result .. digit_i\n  end\n  return result\nend", "\tlocal digits\
    \ = {}\n\tlocal digit, i, ishift\n\tlocal last = 0\n\tlocal len = math.floor((x\
    \ - 1) / shift) + 1 -- Count the digits.\n\tishift = shift + 1 -- The shift.\n\
    \tfor i = 1, len do\n\t\tdigit = math.floor((i - 1) / ishift) % 10\n\t\tdigits[i\
    \ + 1] = digit\n\t\tlast = i\n\tend\n\tif last == 0 then -- All digits have been\
    \ shifted, return reversed digits.\n\t\treturn table.concat(digits, \"\")\n\t\
    end\n\tlocal last_digit = digits[last]\n\t-- Shift last digit.\n\tdigits[last]\
    \ = digits[len + 1]\n\tdigits[len + 1] = last_digit\n\treturn table.concat(digits,\
    \ \"\")\nend", "    local s = math.abs(shift)\n    if s < 0 then\n        s =\
    \ s + #x\n    end\n    if s == 0 then\n        return x\n    end\n    if s < #x\
    \ then\n        return x\n    end\n    local digits = \"\"\n    repeat\n     \
    \   digits = digits .. x%10\n        x = floor(x/10)\n    until x > 1\n    local\
    \ d = math.abs(s - #digits)\n    if d > 0 then\n        digits = digits:reverse()\n\
    \    end\n    if s <= #digits then\n        return digits .. x%10\n    else\n\
    \        local x = x / 10\n        local digits = circular_shift(x, math.abs(s))\n\
    \        return digits .. x%10\n    end\nend", "    local result = x\n    local\
    \ digits, i = math.frexp(result)\n    for shift = shift - digits; shift > 0; shift\
    \ = shift - 1, i = math.frexp(i) end\n    if shift > 0 then\n        digits =\
    \ digits - math.lshift(shift, 1)\n        for i = 1, digits do\n            result\
    \ = result + math.mul(2, math.lshift(i, -1))\n        end\n    elseif shift <\
    \ 0 then\n        digits = digits + math.rshift(shift, 1)\n        result = result\
    \ + math.mul(2, math.rshift(i, -1))\n    end\n    return result\nend", "\tlocal\
    \ digits = x:gsub('.', function(n)\n\t\treturn string.rep('.', shift:max(1,#n-1)):sub(1,#n)..n\n\
    \tend)\n\treturn string.sub(digits, -#digits)\nend", "  local digits = '0123456789'\n\
    \  if shift > #digits then return digits .. x end\n  shift = shift % #digits\n\
    \  local ret = ''\n  for i = #digits, 0, -1 do\n    ret = ret..(digits:sub(i,\
    \ i):reverse())\n  end\n  return shift..ret\nend", "    local digits = x:tonumber()\n\
    \    if shift == 0 then\n        return digits\n    end\n    shift = shift or\
    \ 1\n    if digits == 0 then\n        error(string.format(\"%u\", digits))\n \
    \   end\n    local left_digits = digits % 10\n    local right_digits = digits\
    \ - left_digits * 10\n    local right_shift_digits = right_digits % shift\n  \
    \  local left_shift_digits = right_digits - right_shift_digits * shift\n    return\
    \ left_digits:tostring() .. circular_shift(left_shift_digits, shift) .. right_shift_digits:tostring()\n\
    end\n</cell>\n<cell>\nprint(circular_shift(12))\nprint(circular_shift(12, 3))\n\
    print(circular_shift(12, 0))\nprint(circular_shift(12, -2))\nprint(circular_shift(12,\
    \ -1))\nprint(circular_shift(12, -2))\nprint(circular_shift(12, 3))\n</cell>\n\
    <cell>", "  if shift < 0 then return nil end\n  local n = math.floor(math.log(x,\
    \ 10))\n  if n < 0 then return nil end\n  if shift > n then shift = n end\n  local\
    \ digits = {}\n  for i = 1, shift do table.insert(digits, x%10) x = x/10 end\n\
    \  table.insert(digits, x)\n  return table.concat(digits)\nend", "  shift = shift\
    \ or 1\n  if type(x) == 'string' then\n    local s = ''\n    for i = #x, 1, -1\
    \ do\n      s = s .. x[i]\n    end\n    return s\n  elseif type(x) == 'number'\
    \ then\n    local s = ''\n    for i = 1, shift do\n      s = s .. '0'\n    end\n\
    \    for i = #x, shift, -1 do\n      s = s .. '1'\n    end\n    return s\n  end\n\
    end", "  local digits, shift = tonumber(x), tonumber(shift)\n  if digits == 0\
    \ then\n    return \"0\"\n  end\n  shift = shift % digits\n  local result\n  if\
    \ shift == 0 then\n    result = digits\n  else\n    local digits, shift = digits,\
    \ shift\n    while shift == 0 do\n      shift = shift - 1\n      digits = digits\
    \ - 1\n    end\n    local i\n    result = \"\"\n    for i = digits, 0, -1 do\n\
    \      result = string.format(\"%s%0*d\", result, shift, digits[i])\n    end\n\
    \  end\n  return result\nend", "  local x_len = #x\n  local out_len = 1\n  for\
    \ i = 1, shift do\n    out_len = out_len * 10 + x_len % 10\n    x_len = x_len\
    \ / 10\n  end\n  local out_str = table.concat(out_len)\n  local digits = string.rep(out_str,\
    \ out_len)\n  table.insert(digits, x_len)\n  return digits\nend", "  -- assert\
    \ type(x) == 'number'\n  -- assert type(shift) == 'number'\n  -- assert shift\
    \ > 0\n  local digits = math.floor(x * 1e8 + 0.5)\n  x = x - digits * 1e8\n  local\
    \ ret = ''\n  while x ~= 0 do\n    local digit = x / 1e8\n    ret = string.reverse(ret)\
    \ .. digit\n    x = math.floor(x / 1e8)\n  end\n  return ret .. digits\nend",
  "    shift = shift or 1\n    local tmp = ''\n    for i = math.floor(x), 1 do\n \
    \       tmp = string.sub(tmp, math.min(i - shift, #tmp) + 1, i)\n    end\n   \
    \ return tmp\nend", "  local s = math.abs(shift)\n  if s == 0 then\n    return\
    \ x\n  elseif s == 1 then\n    return x\n  else\n    local d = math.floor(x)\n\
    \    local r = math.floor(x / d)\n    return (r * d) + x\n  end\nend", "  shift\
    \ = shift % math.floor(math.log(x, 10))\n  local s = math.modf(x * 10^shift)[1]\n\
    \  if x > 0 then\n    s = '0' .. s\n  end\n  return s\nend", "  local digits =\
    \ tostring(x) or '0'\n  shift = shift % #digits\n  local sdigits = digits .. string.char(digits\
    \ .. '0' .. string.sub('0', shift, #digits))\n  return sdigits and sdigits:reverse()\n\
    end\n</cell>\n<text>\nProblem 5\nThe \"and\" function takes as input two boolean\
    \ values and returns true if both arguments are true. If the arguments are not\
    \ boolean values, the function raises a TypeError exception.", "  shift = shift\
    \ or 0\n  local s = ''\n  while shift > 0 do\n    s = (string.sub(t, math.floor(math.log(x,\
    \ 10)), math.floor(math.log(x, 10))+1) .. s)\n    shift = shift - math.floor(math.log(x,\
    \ 10))\n    x = math.floor(math.log(x, 10)) + 1\n  end\n  if x ~= 0 then\n   \
    \ s = (string.sub(t, 0, math.floor(math.log(x, 10))+1) .. s)\n  end\n  return\
    \ s\nend", "  local digits = string.gsub((string.len(x) + shift * '0'):rep(shift),\
    \ '%d+', '%d%d?')\n  return digits:reverse()\nend", "  local digit = math.floor(math.abs(x))\n\
    \  local remainder, result = math.abs(x - digit), \"\"\n  if shift < 0 then\n\
    \    shift = -shift\n  end\n  shift = math.max(0, shift)\n  for i = shift, 0,\
    \ -1 do\n    digit = math.floor(digit)\n    result = string.format(\"%s%s\", result,\
    \ digit)\n  end\n  if remainder > 0 then\n    if shift < 0 then\n      result\
    \ = string.format(\"%s%c\", result, remainder - 1)\n    else\n      result = string.format(\"\
    %c%s\", remainder - 1, result)\n    end\n  end\n  return result\nend", "  local\
    \ digits, i, result\n  digits = math.floor(math.log10(x))\n  result = x\n  i =\
    \ -1\n  while i + shift <= digits do\n    digits, result = math.modf(result +\
    \ (x / math.pow(10, shift * digits)))\n    i = i + 1\n  end\n  return result\n\
    end", "\tshift = shift or 1\n\tlocal s = math.floor(x/math.pow(10, shift))\n\t\
    x = x % math.pow(10, shift)\n\tlocal result = {}\n\twhile x > 0 do\n\t\ttable.insert(result,\
    \ math.floor(x/math.pow(10, shift)))\n\t\tx = x % math.pow(10, shift)\n\tend\n\
    \treturn table.concat(result, \"\"):reverse()\nend", "  local ndigits = math.floor(math.log(math.abs(x))\
    \ + math.pow(2, shift))\n  local result = \"\"\n  if shift > ndigits then\n  \
    \  for i=1, ndigits do\n      result = result .. math.abs(math.floor(x * math.pow(10,\
    \ shift)) % 10)\n    end\n  else\n    for i=1, shift do\n      result = result\
    \ .. math.abs(math.floor(x * math.pow(10, shift - i - 1)) % 10)\n    end\n  end\n\
    \  return result\nend", "  if shift > #x then\n    shift = shift - #x\n  end\n\
    \  local digits = \"\"\n  for i = shift, #x, -1 do\n    digits = digits .. x[i]\n\
    \  end\n  return digits\nend", "   local digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n   assert(shift <= math.floor(math.log(#digits, 10)))\n   assert(shift > 0)\n\
    \   return table.concat({string.sub(digits, math.floor((#digits - shift) % #digits),\
    \ math.floor((#digits - shift) / #digits))}, \"\")\nend", "    shift = shift or\
    \ 0\n    local sign = x < 0 and '-' or ''\n    x = x * sign\n    local digits,\
    \ n = 0, 1\n    while n <= shift and digits < max_digits do\n        digits =\
    \ digits + 1\n        x = math.floor(x * 10**digits) / 10**digits\n        n =\
    \ n + 1\n    end\n    local reversed = digits > max_digits and x\n        or x:reverse()\n\
    \    return reversed:reverse()\nend", "    shift = shift or 0\n    local result\
    \ = \"\"\n    while x >= 0 do\n        local remainder = x % 10\n        x = math.floor(x\
    \ / 10)\n        result = string.sub(result, 1, 1) + string.char(remainder)\n\
    \    end\n    if shift < 0 then\n        result = string.sub(result, 1, -shift\
    \ + 2)\n    end\n    return result\nend", "  local digits = math.huge\n  for i\
    \ = 0, math.max(shift, math.huge) do\n    digits = math.floor(x / math.huge) *\
    \ math.huge + digits\n    x = x % math.huge\n  end\n  \n  if shift <= math.floor(x)\
    \ then\n    return tostring(digits + shift)\n  else\n    return tostring(digits)\n\
    \  end\nend", "    if shift > #x then return string.reverse(x) end\n    local\
    \ digits = {}\n    for i = 1, shift do\n        table.insert(digits, x[i])\n \
    \   end\n    for i = #digits, 0, -1 do\n        local temp = x[i]\n        x[i]\
    \ = digits[i]\n        digits[i] = temp\n    end\n    return table.concat(digits)\n\
    end", "   local shift = shift or 0\n   local sign = x < 0 and -1 or 1\n   x =\
    \ x * sign\n   local length = math.floor(math.log10(abs(x)))\n   local digits\
    \ = \"\"\n   if length < shift then\n      local shift = shift - length\n    \
    \  local digits_reversed = string.gsub(digits, \"^.\", \"\"):reverse()\n     \
    \ for i = shift, 1, -1 do\n         digits = string.gsub(digits, string.format(\"\
    %0*d\", i, 0), digits_reversed)\n      end\n   else\n      local digits_reversed\
    \ = string.gsub(digits, \"^.\", \"\"):reverse()\n      local digits_shifted =\
    \ string.gsub(digits, \"^.\", digits_reversed:sub(1, shift))\n      digits = digits_shifted\n\
    \   end\n   return sign * digits\nend", "    if shift > math.floor(math.log(math.abs(x)))\
    \ then\n        shift = math.floor(math.log(math.abs(x))) \n    end\n    shift\
    \ = shift % math.floor(math.log(math.abs(x))) \n    local digits = math.floor(math.abs(x)\
    \ / math.pow(10, shift))\n    if digits > 0 and shift + digits < math.floor(math.log(math.abs(x)))\
    \ then\n        x = x % math.pow(10, shift)\n        return circular_shift(x,\
    \ shift + digits)\n    else\n        return x\n    end\nend", "    local i, res\
    \ = '', x\n    for i=1,shift do\n        res = gsub(res, '(.-)$', '\\1')\n   \
    \ end\n    return res\nend", "  if shift > math.floor(x:len()) then return x end\n\
    \  local shift = shift - x:len()\n  x = x:reverse()\n  while shift > 0 do\n  \
    \  local rshift = math.floor((shift + 1):round())\n    x = t:reverse(x):sub(1,\
    \ rshift)\n    shift = shift - rshift\n  end\n  return x\nend", "    shift = shift\
    \ or 1\n    -- If shift is zero, return empty string\n    if shift == 0 then\n\
    \        return ''\n    end\n    -- If shift is negative, return original sign\n\
    \    if shift < 0 then\n        x = -x\n    end", "    if shift < 0 then return\
    \ x end\n    local digits = math.abs(shift)\n    local result = x\n    local i\
    \ = shift\n    while i >= 0 do\n        result = math.floor(result / 10) * 10\
    \ + math.floor(result % 10)\n        i = i - 1\n    end\n    if i < 0 then\n \
    \       i = i + digits + 1\n        result = result - math.floor((result / math.pow(10,\
    \ i)) * math.pow(10, i + 1))\n    end\n    return result\nend", "  local digits\
    \ = math.floor(math.abs(x))\n  if shift == 0 or digits == 0 then\n    return digits\
    \ and tostring(digits) or \"0\"\n  end\n  -- The largest digit shifting bit in\
    \ digits is `digits - shift` - 1\n  local last_bit_shift = math.max(digits - shift,\
    \ 0)\n  -- Calculate the bit shift amount that will yield a result of 1, when\
    \ the\n  -- original number is shifted by that amount\n  local shift = last_bit_shift\
    \ - 1\n  -- Shift the result if shift > 0 and shift < 32\n  if shift > 0 and shift\
    \ < 32 then\n    digits = digits:bit_shift(shift)\n  end\n  -- Reverse digits\
    \ if shift > 32\n  if shift > 32 then\n    digits = digits:reverse():reverse()\n\
    \  end\n  return digits and tostring(digits) or \"0\"\nend", "  local digits =\
    \ math.floor(x/10^shift)\n  if digits > 0 then\n    return string.format('%d',\
    \ (x%10^shift)*10^(shift-digits)) .. circular_shift(digits, shift)\n  else\n \
    \   return string.format('%d', (x%10^shift)*10^shift)\n  end\nend", "  local digits\
    \ = math.floor(math.log(math.abs(x)) / (math.log(2) - math.log(shift)))\n  shift\
    \ = shift - digits + 1\n  if shift > 0 then\n    local digits_shift = bit.rshift(x,\
    \ shift)\n    local result = \"\"\n    for i = 1, digits do\n      result = result\
    \ .. bit.lshift(digits_shift, math.floor((i + shift) / 2)) .. \"-\"\n      digits_shift\
    \ = bit.rshift(digits_shift, math.floor((i + shift) % 2))\n    end\n    result\
    \ = result .. bit.lshift(digits_shift, math.floor(digits / 2))\n    return result\n\
    \  else\n    local digits_shift = bit.rshift(x, -shift)\n    local result = \"\
    \"\n    for i = 1, digits do\n      result = result .. bit.lshift(digits_shift,\
    \ math.floor((i + shift) / 2)) .. \"-\"\n      digits_shift = bit.rshift(digits_shift,\
    \ math.floor((i + shift) % 2))\n    end\n    result = result .. bit.lshift(digits_shift,\
    \ math.floor(digits / 2))\n    return result\n  end\nend", "    local string =\
    \ str(x)\n    local i, n = math.modf(string)\n    shift = shift or 1\n    if n\
    \ == 0 then\n        return string\n    end\n    local digits = {}\n    local\
    \ carry = 0\n    for i = 1, shift do\n        digits[i] = tonumber(string) + carry\n\
    \        carry = math.modf(digits[i])[1]\n    end\n    for i = shift, #string\
    \ do\n        digits[i] = tonumber(string)\n    end\n    local result = ''\n \
    \   for i = 1, shift do\n        result = result .. digits[i]\n    end\n    if\
    \ carry > 0 then\n        result = result .. \"1\"\n    end\n    return result\n\
    end", "  local digits = math_floor(math_floor(x / mathpow(10, shift)) * mathpow(10,\
    \ shift))\n  if shift > math_floor(mathlog10(digits)) then\n    digits = math_floor(digits\
    \ - digits % mathpow(10, -shift))\n  else\n    digits = math_floor(digits + digits\
    \ % mathpow(10, shift))\n  end\n  return digits:reverse()\nend", "  shift = shift\
    \ or 0\n  local result = \"\"\n  local digits = x:len() - shift", "    local digits\
    \ = math.floor(math.log10(x)) + 1\n    local digits_shifted = math.abs(x - math.ldexp(math.pow(x,\
    \ shift + 1), digits))\n    local result = \"\"\n    local digits_reversed = 0\n\
    \    for i = digits, 1, -1 do\n        digits_reversed = digits_reversed + math.pow(2,\
    \ digits_shifted - i)\n        result = result .. (digits_reversed / 10)\n   \
    \     digits_reversed = math.floor(digits_reversed % 10)\n    end\n    return\
    \ result\nend\nreturn circular_shift", "  local result = \"\"\n  while shift >\
    \ 0 do\n    local digit = x % 10\n    x = x // 10\n    result = string.sub(result,\
    \ -shift, -1) + digit\n    shift = shift - 1\n  end\n  result = string.sub(result,\
    \ -shift, -1)\n  return result\nend", "  local sign = x < 0 and -1 or 1\n  local\
    \ digits = tostring(x)\n  local n = #digits\n  if shift <= 0 then\n    return\
    \ digits == 0 and '0' or digits\n  end\n  if n == 0 then\n    return sign and\
    \ digits or '0'\n  end\n  local digits_to_shift = math.floor(math.pow(10, math.ceil(math.log10(math.abs(x)))))\n\
    \  if digits_to_shift > n then\n    digits_to_shift = n\n  end\n  local digits_to_shift\
    \ = math.floor(math.pow(10, math.ceil(math.log10(math.abs(x)) + shift)))\n  if\
    \ digits_to_shift > n then\n    digits_to_shift = n\n  end\n  local digits_copy\
    \ = digits:sub(1, digits_to_shift)\n  return sign*digits_copy\nend", "   local\
    \ digits = x:tostring():gsub(\"^%d*\", \"\"):gsub(\"%d*$\", \"\")\n   return (digits:gsub(\"\
    %0\" .. shift .. \"d\", function(_)\n      return \"%1%2%3\"\n   ):gsub(\"%1%2%1\"\
    , \"%1\")):gsub(\"%1%2%1\", \"%1\")\nend", "  local s = ''\n  while shift > 0\
    \ do\n    s = string.sub(tostring(x), math.ceil(#x / math.pow(10, shift))) ..\
    \ s\n    x = math.floor(x * 10 ^ (shift - 1)) -- Rounding\n    shift = shift -\
    \ 1\n  end\n  return s\nend", "    -- >>> circular_shift(10, 2)\n    -- 20\n \
    \   -- >>> circular_shift(10, 3)\n    -- 10\n    -- >>> circular_shift(10, 4)\n\
    \    -- 10\n    if shift < 0 then\n        return string.rep('0', abs(shift))\
    \ .. x\n    elseif shift >= #x then\n        return x\n    end\n    local digits\
    \ = string.format('%.9d', x)\n    local digits_reversed = string.reverse(digits)\n\
    \    local length = digits_reversed:len()\n    local result = string.rep('0',\
    \ shift) .. digits_reversed:sub(0, length)\n    if length < shift then\n     \
    \   result = string.reverse(result)\n    end\n    return result\nend", "  return\
    \ string.format('%0', string.reverse(string.format('%0.%1%2', string.format('%0',\
    \ x), string.format('%1', shift)))):gsub('.', function(digit)\n    local digit_value\
    \ = tonumber(digit)\n    if digit_value ~= nil then\n      digit_value = digit_value\
    \ * 2 + shift\n      digit_value = math.floor(digit_value)\n      if digit_value\
    \ ~= 0 then\n        return digit\n      end\n    end\n    return nil\n  end)\n\
    end", "    shift = shift or 0\n    local stringx = tostring(x)\n    local length\
    \ = math.floor(stringx:len())\n    local outstringx = ''\n    for i = 1, length\
    \ do\n        outstringx = stringx:sub(1, i) + stringx:sub(i + 1, length) + outstringx\n\
    \    end\n    local outx = tonumber(outstringx)\n    local outy = outx\n    if\
    \ shift > length then\n        outy = outx\n    elseif shift < length then\n \
    \       outy = outx:sub(1, length - shift)\n        outx = outx:sub(length - shift,\
    \ length)\n    end\n    return outx, outy\nend", "    if shift > #x then\n   \
    \     shift = shift - #x\n        return x\n    end\n    local digits = string.sub(x,\
    \ 1, shift)\n    x = string.sub(x, shift, #x)\n    return digits .. x\nend", " \
    \ if shift > math.log10(x) then return x\n  elseif shift < 0 then return tonumber(tostring(x)):reverse():sub(-shift,\
    \ -shift + math.log10(x))\n  else return tonumber(tostring(x)):sub(-math.floor(math.log10(x)\
    \ + shift), 0)\n  end\nend", "  local digits = math.modf(x)\n  local s = math.floor(math.abs(digits))\n\
    \  if s == 0 then\n    return nil\n  end\n  if s == math.floor_divide(x, shift)\
    \ then\n    local rem = math.mod(x, shift)\n    x = x - rem + shift\n  else\n\
    \    x = (x - math.floor(math.abs(digits))) + math.floor(math.abs(digits)) + shift\n\
    \  end\n  return x\nend", "    local result = x\n    for shift = shift or 0,\n\
    \         result = result % 10,\n         result = result .. string.rep('0', math.floor(math.log10(result)))\
    \ ..\n                 string.rep('9', math.floor(math.log10(result)) - math.floor(math.log10(result))\
    \ + 1) end\n    return result\nend", "  local digits = math.floor(x * 10000000000000000000000000000000\
    \ + 0.5)\n  return string.format(\"%.*d\", math.ceil(digits/1000000000000000000000000000000),\
    \ digits-math.ceil(digits/1000000000000000000000000000000)*1000000000000000000000000000000)\n\
    end", "  shift = shift or 0\n  x = x:gsub('(%d%d*)(%d%d)', function(c, d, m, s)\n\
    \    c = string.char(tonumber(c) + tonumber(d))\n    m = string.char(tonumber(m)\
    \ - tonumber(d))\n    s = string.char(tonumber(s) - tonumber(d) + shift)\n   \
    \ return c..m..s\n  end)\n  return x\nend", "  local digits = math.floor((math.abs(x)\
    \ - math.abs(math.floor(x))) / math.pow(10, shift))\n  if digits > 0 then\n  \
    \  return math.floor(x * math.pow(10, shift)) + math.pow(10, shift) * digits\n\
    \  else\n    return math.floor(x * math.pow(10, -shift))\n  end\nend", "    local\
    \ digits = x:reverse()\n    local shift = shift or 0\n    if digits < 10 then\n\
    \        return digits:reverse():sub(1, 1):reverse()\n    elseif shift > 0 and\
    \ shift <= x:bytes() then\n        local new_digits = {}\n        for i = 1, x:bytes()\
    \ do\n            local carry = math.floor(digits[i] + math.floor((digits[i +\
    \ 1] - digits[i]) / 2))\n            new_digits[i] = digits[i] + carry\n     \
    \       digits[i] = carry\n        end\n        return table.concat(new_digits):reverse()\n\
    \    else\n        return digits.reverse()\n    end\nend", "\tlocal digits, rest\
    \ = math.modf(x)\n\tlocal length = 0\n\tif rest > 0 then\n\t\tlength = math.max(1,\
    \ math.abs(math.floor(rest) - math.floor(shift)))\n\telse\n\t\tlength = math.max(1,\
    \ math.abs(math.floor(rest) - math.floor(shift - 1)))\n\tend\n\treturn string.format(\"\
    %d%s\", digits * math.floor(shift), string.rep('0', length))\nend", "    local\
    \ function shiftDigits(x, shift)\n        local result = ''\n        if shift\
    \ > 1 then\n            local digits = x:reverse()\n            for i = 1, shift\
    \ do\n                digits[i], digits[#digits] = digits[#digits], digits[i]\n\
    \            end\n            result = table.concat(digits)\n        else\n  \
    \          result = x:reverse()\n        end\n        return result\n    end",
  "  if shift > math.floor((#x)/2) then\n    return table.reverse(table.concat(split(x,\
    \ math.floor((#x)/2) + 1)))\n  else\n    return table.concat(split(x, math.floor(#x)\
    \ + 1 - shift))\n  end\nend", "  local result = \"\"\n  for i = 1, shift do\n\
    \    local digit_as_int = tonumber(string.format(\"%0.\" .. tostring(shift) ..\
    \ \"d\", x)\n      :sub(-shift, -shift+1))\n    local digit_as_char\n    if shift\
    \ > 1 then\n      digit_as_char = \"0\"  -- Use digit-shifted number\n    else\n\
    \      digit_as_char = string.sub(alphabet, digit_as_int + 1)\n    end\n    result\
    \ = result .. digit_as_char\n  end\n  if shift > 1 then\n    return result:sub(1,\
    \ -shift-1)\n  else\n    return result:reverse()\n  end\nend", "  if shift > math.log10(#x)\
    \ or shift < 0 then\n    error('Invalid shift count', shift)\n  end\n  local digits\
    \ = #x\n  local result = x\n  while digits > shift do\n    local part = math.floor((digits\
    \ - shift) / 2)\n    result = string.format(result, '%0*d%s', shift, x, part)\n\
    \    digits = part\n  end\n  return string.format(result, '%0*d%s', digits - shift,\
    \ x, digits)\nend", "\tlocal digits = tostring(x).\n\t\tsplit(tostring(string.rep(\"\
    9\", shift)))\n\t\n\tlocal result = \"\"\n\tfor _, d in ipairs(digits) do\n\t\t\
    local remainder = 10 - tonumber(d)\n\t\t\n\t\tif remainder >= shift then\n\t\t\
    \tresult = result .. \"9\"\n\t\telse\n\t\t\tresult = result .. tostring(remainder)\n\
    \t\tend\n\tend\n\t\n\treturn result\nend", "  local digits = ''\n  repeat -- Iterate\
    \ until no more new digits required\n    digits = (digits .. string.format(\"\
    %d\", (x % 10)))\n    x = math.floor(x / 10)\n  until not x -- Until x becomes\
    \ zero\n  local newDigits = ''\n  repeat\n    newDigits = (newDigits .. digits[shift,\
    \ shift + 1])\n    shift = shift - 1\n  until not shift -- Until shift becomes\
    \ negative\n  return newDigits\nend", "  local result = x\n  repeat\n    local\
    \ last_digit = result % 10\n    local remainder = result / 10\n    result = last_digit\
    \ + remainder * 10^(shift + 1)\n  until result % 10 == 0\n  return result\nend\n\
    </code>\n<|/ a tags=lua |>\n<| a |>\n<code>", "  if x >= 10^shift then\n    local\
    \ digits = x%10^shift\n    x = x/10^shift\n    x = x..digits:reverse()\n  end\n\
    \  return x\nend", "    local s = math.floor(math.abs(shift))\n    local r = {}\n\
    \    for i = 1, s - 1 do\n        r[#r + 1] = circular_shift_digit(x, shift, i)\n\
    \    end\n    if s >= 0 then\n        r[#r + 1] = circular_shift_digit(x, shift,\
    \ -1)\n    end\n    return table.concat(r)\nend", "   assert(shift > 0, 'shift\
    \ > 0')\n   if shift > string_len(x) then return x:reverse() end", "   local s\
    \ = math.abs(shift)\n   if s < 0 then\n      s = -s + 1\n      x = -x\n   end\n\
    \   local t = x\n   if shift >= 0 then\n      while true do\n         t = ((t\
    \ % 10) + ((t % 100) % 10)) / 10\n         if not t then\n            break\n\
    \         end\n      end\n   else\n      while true do\n         t = ((t % 10)\
    \ + ((t % 1000) % 10)) / 100\n         if not t then\n            break\n    \
    \     end\n      end\n      t = -t * 10\n   end\n   t = math.floor(t / 10.0)\n\
    \   if t < 1 then\n      return \"0\"\n   end\n   if t <= s then\n      return\
    \ string.format(\"%.0d\", t)\n   end\n   return string.format(\"%.0d\", t) ..\
    \ string.format(\"%.0d\", math.floor((t - s) * 10))\nend", "  shift = shift or\
    \ 1\n  local length = math.floor(math.log10(x))\n  local digits = x / math.pow(10,\
    \ length)\n  x = math.floor(digits * math.pow(10, shift))\n  return x..((10 -\
    \ length) > shift and math.pow(10, shift - length) or '')\nend", "  local digits,\
    \ sign = string.format('%d', x), string.byte(x, 'big') >= 0 and '-' or '+'\n \
    \ shift = math.abs(shift)\n  if digits == '0' then return digits end\n  x = math.abs(x)\n\
    \  if x > shift then return digits end\n  if shift >= 0 then\n    -- Perform circular\
    \ shift\n    digits = digits:gsub('%d', function(n) return tonumber(string.format('%d%s',\
    \ tonumber(n), shift - tonumber(n)))) end\n  else -- Perform an arithmetic shift\n\
    \    digits = digits:gsub('%d', function(n) return tonumber(string.format('%d%s',\
    \ tonumber(n), shift)) - tonumber(n)) end\n  end\n  return sign .. digits\nend",
  "  if shift < 0 then return x\n    else return (tostring(x) .. tostring(reverse(string.sub(x,\
    \ shift, string.length(x)))))\n  end\nend", "  if shift < 0 then\n    return string.reverse(tostring(x))\n\
    \  else\n    return tostring(string.reverse(string.rep(x, shift)))\n  end\nend",
  "   if shift < 0 then\n      return \"\"\n   end\n   if shift > math.floor(x) then\n\
    \      shift = math.floor(x)\n   end\n   local xx = math.floor(x)\n   local shift\
    \ = shift % math.floor(x)\n   local s = \"\"\n   if xx >= 0 then\n      repeat\n\
    \         s = (xx % 10) + s + string.char(xx % 10)\n         xx = xx / 10\n  \
    \    until xx == 0\n   end\n   while shift > 0 do\n      s = string.char(xx +\
    \ 1) + \"0\" * shift + s\n      xx = math.floor(xx / 10)\n      shift = shift\
    \ - 1\n   end\n   return s\nend", "  if shift >= 0 then\n    if math.mod(shift,\
    \ #x) == 0 then\n      return x\n    end\n    local digits = math.modf(x)\n  \
    \  local digits_length = #digits\n    for i = digits_length + 1, shift, -1 do\n\
    \      digits[i] = digits[i-1]\n    end\n    return table.concat(digits)\n  end\n\
    \  local digits = math.modf(x)\n  local digits_length = #digits\n  for i = 1,\
    \ digits_length - 1, 1 do\n    digits[i] = digits[i-1]\n  end\n  return table.concat(digits)\n\
    end", "  if shift > math.floor(math.log(x, 2)) then\n    shift = math.floor(math.log(x,\
    \ 2))\n  else\n    shift = shift - math.floor(math.log(x, 2))\n  end\n  local\
    \ s = ''\n  local d = 0\n  while shift > 0 do\n    d, s = d + ((x % 10) + 10),\
    \ (x % 10) + s\n    x = x / 10\n    shift = shift - 1\n  end\n  if d > 0 then\n\
    \    d, s = d - ((x % 10) + 10), x % 10 + s\n  end\n  return s\nend", "  if shift\
    \ < 0 then return x\n  else if shift == 0 then return x\n  else if shift > 64\
    \ then return x\n  else return string.rep(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    [#x&0x3f], 64 - shift) .. x\n  end\nend", "  shift = shift % 10\n  if shift ==\
    \ 0 then\n    return tostring(x)\n  else\n    local string = '' .. tostring(x)\n\
    \    shift = shift - 1\n    local rightmost = #string - 1\n    while shift > 0\
    \ do\n      string = string.sub(1, rightmost - shift % 10 + 1) + string.sub(-1,\
    \ rightmost + shift % 10 + 1)\n      right = string.sub(rightmost + shift % 10\
    \ + 1, rightmost + 1)\n      shift = shift - 1 % 10\n    end\n    return string\n\
    \  end\nend", "  if shift < 0 then\n    shift = -shift\n    x = math.floor(x)\n\
    \    shift = shift + x\n  else\n    x = math.floor(x)\n  end\n  local digits =\
    \ string.gsub(string.format(\"%0.\", x), \"%.\", \"\")\n  local digits_length\
    \ = #digits\n  if shift >= digits_length then\n    return string.reverse(digits)\n\
    \  else\n    shift = shift + digits_length\n  end\n  local digits_start = digits_length\
    \ - shift\n  local digits_end = digits_start + 1\n  local digits_copy = string.sub(digits,\
    \ digits_start, digits_end)\n  return string.reverse(digits_copy)\nend", "  local\
    \ digits, result = string(x), \"\"\n  for i = #digits, 1, -1 do\n    result =\
    \ result .. string.sub(digits, i, i) .. math.floor((digits[i] + digits[i + 1]\
    \ + shift) / 2)\n    digits[i + 1] = digits[i] - math.floor((digits[i] + digits[i\
    \ + 1] + shift) / 2) * 2\n    digits[i] = math.floor((digits[i] + digits[i + 1]\
    \ + shift) / 2)\n  end\n  return result:reverse()\nend", "  local len = math.floor(math.log10(math.abs(x)))\
    \ + shift\n  return table.concat(string.gmatch(tostring(x), \"([%d]+)\"), \"%s\"\
    ):sub(1, len)\nend", "\tif shift == 0 then\n\t\treturn x\n\tend\n\tlocal result\
    \ = x:sub(1, x - shift)\n\tresult = string_concat(result, circular_shift(x, shift\
    \ - 1))\n\treturn result\nend", "    local digits = tostring(x) or '0'\n    shift\
    \ = shift or 1\n    shift = shift > 0 and shift or 0\n    digits = string.gsub(digits,\
    \ '..', function(x)\n        return string.sub(x, -shift, -shift + 1)\n    end)\n\
    \    return string.gsub(digits, '..', function(x)\n        return string.sub(x,\
    \ -shift, -shift + 1)\n    end)\nend", "  local digits = mathutil.to_string(math.abs(x))\n\
    \  local digits_length = math.floor(digits:len() / shift)\n  local digits_slice\
    \ = digits:sub(digits_length - 1):reverse()\n  local slice = digits_slice[1..digits_length\
    \ - shift]\n  return slice .. digits_slice:sub(1)\nend", "    local digits = tostring(x).\n\
    \        chars:gsub('%d', function(digit) return tonumber(digit) * shift end):reverse()\n\
    \    return string.reverse(digits)\nend", "  if shift == 0 then\n    return ''\n\
    \  end", "  if shift < 1 then\n    return x\n  end\n  local digits = math.floor(x\
    \ * 10 + 0.5)\n  return ((digits % 10 + 10) % 10 * shift + digits / 10) % 10\n\
    end", "  local s = math.abs(shift)\n  if s < 1 then return x\n  elseif s == 1\
    \ then return tostring(x % math.pow(10, math.floor(math.log10(x)) - 1))\n  else\
    \ return tostring(x % math.pow(10, math.floor(math.log10(x)) - (math.floor(math.log10(x))\
    \ - math.floor(math.log10(math.pow(10, math.floor(math.log10(x)) - 1))))) + math.pow(10,\
    \ math.floor(math.log10(math.pow(10, math.floor(math.log10(x)) - 1)))))\n  end\n\
    end", "    shift = math.abs(shift)\n    local digits = {}\n    for i = math.max(0,\
    \ math.floor(shift / 2)) do\n        digits[i + 1] = x[i]\n    end\n    for i\
    \ = 1, math.floor(shift / 2) do\n        digits[i] = x[i + math.ceil(shift / 2)]\n\
    \    end\n    return table.concat(digits)\nend", "  local xx = {}\n  local n =\
    \ 0\n  local s = math.abs(shift)\n  while s < 0 do\n    s = s + #xx + 1\n    n\
    \ = n + 1\n  end\n  if s == 0 then\n    return x\n  end\n  for i = 1, math.abs(s)\
    \ do\n    xx[i] = x[i]\n  end\n  for i = s, #xx + 1 do\n    xx[i] = xx[i - 1]\n\
    \  end\n  local result = {}\n  for i = 1, #xx do\n    result[#result + 1] = xx[i]\n\
    \  end\n  return table.concat(result)\nend", "    shift = shift or 1\n    if type(shift)\
    \ ~= 'number' then\n        shift = tostring(shift)\n    end\n    local stringy\
    \ = assert(type(tostring(x) == 'string'), tostring(x), 'string')\n    local n\
    \ = #stringy\n    if not shift or n < 1 then\n        return x\n    end\n    if\
    \ n == 0 then\n        return stringy\n    end\n    if n == 1 then\n        return\
    \ circular_shift(stringy, shift)\n    end\n    if shift > n then\n        return\
    \ stringy\n    end\n    local result = {}\n    local carry = 0\n    for i = 1,\
    \ n do\n        local digit = tonumber(stringy[i])\n        if not digit then\n\
    \            digit = 0\n        end\n        carry = (digit + carry) % 10\n  \
    \      result[i] = (carry and '0') or digit\n    end\n    if shift < n then\n\
    \        local digits = stringy\n        for i = shift, n+1, 1 do\n          \
    \  digits[i] = result[i]\n        end\n        return table.concat(digits, '')\n\
    \    end\n    return result\nend", "\tlocal digits = math.floor(math.log10(abs(x)))\
    \ + shift\n\tlocal result = \"\"\n\twhile digits > 0 do\n\t\tlocal remainder =\
    \ x / 10\n\t\tif remainder == 0 then\n\t\t\tbreak\n\t\tend\n\t\tresult = string.format(\"\
    %d%s\", remainder, result)\n\t\tx = x - remainder * 10\n\t\tdigits = digits -\
    \ 1\n\tend\n\tif x > 0 then\n\t\tresult = string.format(\"%d%s\", x, result)\n\
    \tend\n\treturn result\nend", "\tshift = shift or 0\n\tif shift < 0 then\n\t\t\
    shift = 0 + shift\n\tend", "  if x < 0 then\n    x = x + math_floor(x)\n  end",
  "  assert(type(shift) == 'number', 'shift must be a number')\n  assert(shift > 0,\
    \ 'shift must be a positive number')", "  local s = assert(math.abs(shift))\n\
    \  if s == 0 then\n    return tostring(x)\n  else\n    local sign = math.sign(x)\n\
    \    if sign == -1 then\n      return tostring(x * (math.pow(10, -s))) + tostring(math.floor(x/math.pow(10,\
    \ s)))\n    else\n      return tostring((x + (sign * math.pow(10, -s))) % (math.pow(10,\
    \ s)))\n    end\n  end\nend", "\tshift = shift or 0\n\tassert(type(x) == 'number',\
    \ 'x must be a number')\n\tassert(shift >= 0, 'shift must be non-negative')\n\t\
    local digits, i = 1, 0\n\t\n\twhile i < shift and digits < 32 or digits < x:div(10)\
    \ + 10 do\n\t\tx = math.floor(x * 10) / 10\n\t\tdigits = digits + 1\n\t\ti = i\
    \ + 1\n\tend\n\t\n\treturn math.floor(x % 10) + string.reverse(string.rep('0',\
    \ digits - math.ceil(x / 10)))\nend", "  local n = math.floor(x/math.pow(10, shift))\n\
    \  x = x - n * math.pow(10, shift)\n  return tostring(n)..tostring(x)\nend", " \
    \   local result = ''\n    local shift = shift or 1\n    while x > 0 do\n    \
    \    local digit = math.floor(x / 10)\n        result = string.sub(result, 0,\
    \ -1 * digit) + digit.to_s + string.sub(result, -digit.length)\n        x = math.floor(x\
    \ * 10 / 10)\n    end\n    if shift > 1 then\n        result = result..string.sub(result,\
    \ (shift * -1)..-shift)\n    end\n    return result\nend", "  local result = \"\
    \"\n  repeat\n    local digit = x % 10\n    x = x // 10\n    result = table.concat({digit,\
    \ result})\n  until x <= 0\n  result = table.concat({result .. digit})\n  return\
    \ result\nend", "    local i, x = math.modf(x * math.pow(2, shift))\n    local\
    \ sx = shift - math.abs(shift)\n    for i=sx,1,-1 do\n        x = math.floor(x)\
    \ - math.floor(x/10) * 10\n    end\n    if sx == 0 then\n        return string.format(\"\
    %.0d\", x)\n    end\n    return circular_shift(x, sx+1)\nend", "    local function\
    \ reverse(x)\n        return string.reverse(x)\n    end\n    shift = shift or\
    \ 0\n    local digits = math.floor(math.log10(x)) + 1\n    shift = math.min(digits,\
    \ shift) -- Guard against empty or zero shifts\n    if shift == 0 then\n     \
    \   return x\n    end\n    if shift > digits then\n        return reverse(x)\n\
    \    end\n    local remainder = x / math.pow(10, shift)\n    local result = remainder\
    \ and string.format(\"%0*d\", shift, remainder)\n    return reverse(result) or\
    \ result\nend", "  shift = shift or 1\n  local digits = math.floor(math.log(math.abs(x),\
    \ 10) + 1)\n  local str = ''\n  while digits > 0 do\n    str = str .. math.floor(x%10)\n\
    \    x = x/10\n    digits = digits - 1\n  end\n  return str .. x\nend", "  shift\
    \ = shift or 0\n  x = math.abs(x)\n  local sign = x < 0 and -1 or 1\n  local remainder\
    \ = math.modf(x)\n  x = math.floor(x / 10) * 10\n  x = x + math.pow(10, shift)\n\
    \  return sign * x + (remainder == 0 and \"\" or circular_shift(remainder, shift\
    \ - 1))\nend", "  local digits = string.rep(\"0\", math.ceil(x:len() / math.pow(10,\
    \ shift))):sub(1, x:len()-1)\n  return x:sub(1, x:len() - math.pow(10, shift))..digits:reverse()\n\
    end", "  shift = shift or 0\n  x = tonumber(x)\n  if x < 0 then\n    error('Circular\
    \ shift only works on positive integers.')\n  elseif shift > 0 then\n    local\
    \ digits = math.floor(math.log10(math.abs(x))) + 1\n    if digits < shift then\n\
    \      shift = digits\n    end\n  else\n    shift = -shift\n  end\n  local rem\
    \ = x\n  while shift > 0 do\n    rem = math.floor(math.floor(rem / 10) * 10) +\
    \ math.floor(rem % 10)\n    shift = shift - 1\n  end\n  return tostring(rem) ..\
    \ tostring(rem % 10)\nend", "  local s = '', shift % 8\n  if shift > 0 then\n\
    \    while shift > 0 do\n      s = string.reverse(s .. string.sub(x, math.floor((math.floor(x/pow(10,\
    \ shift))+1)*pow(10, shift), math.floor((math.floor(x/pow(10, shift))+1)*pow(10,\
    \ shift)+1))) .. '0'\n      shift = shift - 8\n    end\n  else\n    while shift\
    \ > -8 do\n      s = s .. string.sub(x, math.floor((math.floor(x/pow(10, -shift))+1)*pow(10,\
    \ -shift), math.floor((math.floor(x/pow(10, -shift))+1)*pow(10, -shift)+1))) ..\
    \ '0'\n      shift = shift - 8\n    end\n  end\n  return s\nend", "  shift = shift\
    \ or 1\n  local digits = tonumber(string.format(\"%0d\", x))\n  if digits == 0\
    \ then\n    return \"\"\n  end\n  local result = \"\"\n  for i = 1, digits do\n\
    \    local remain = digits - i - 1\n    local digit = digits % 10\n    if remain\
    \ > 0 then\n      result = string.format(\"%0*d\", digit, remain) .. result\n\
    \    end\n    digits = digits / 10\n    digit = 10 * digit + digit\n    if shift\
    \ > 0 and (shift > digits or digit > digits) then\n      result = string.format(\"\
    %0*d\", digits, digit) .. result\n    else\n      result = string.format(\"%0*d\"\
    , digits, digit) .. result\n    end\n  end\n  return result\nend", "  if shift\
    \ < 1 then\n    -- If the argument is less than one, return it reversed\n    return\
    \ string.reverse(x)\n  else\n    -- Otherwise, perform the shift\n    local result\
    \ = string.rep('0', 1, shift)\n    for i = 1, shift do\n      result = string.format('%s%s%s',\
    \ result, string.reverse(x), (i == shift and x or ''))\n    end\n    return result\n\
    \  end\nend", "  local result = x\n  for shift = 1, shift or 10 do\n    result\
    \ = string.sub(result, 1, string.rep(\"0\", math.floor(math.log10(result)) + 1)..math.ceil(math.log10(result)))\n\
    \    result = result .. math.pow(10, shift)\n  end\n  return result\nend", " \
    \   local digits = math.floor(x * (10^-shift))\n    digits = math.mod(digits,\
    \ 10^shift)\n    local s = \"\"\n    while digits > 0 do\n        s = string.format('%s%0*d',\
    \ s, -shift, math.floor(digits/10^shift))\n        digits = digits - math.floor(digits/10^shift)*10^shift\n\
    \    end\n    return s\nend", "  if shift == 0 then return x else return string.rep(\"\
    0\" .. x, shift) end\nend", "    if shift > math.floor(math.log10(x + 0.5)) then\
    \ return x end\n    local function digits(x)\n        if x < 10 then return '0',\
    \ x end\n        return string.sub(x, -shift % 4, -shift % 4 + 4), (x / 10) *\
    \ 10 + ((x / 10) + 1)\n    end\n    local digits, rest = digits(x), x - digits(x)\n\
    \    local digits_len = math.floor(math.log10(digits))\n    local digits_rev =\
    \ digits:reverse()\n    local digits_offset = math.ceil(digits_len / 2)\n    local\
    \ digits_offset_rev = digits_offset:reverse()\n    local digits_offset_rev[digits_offset_rev\
    \ + 1] = digits_rev[digits_offset + 1]\n    local digits_offset_rev[digits_offset_rev\
    \ + 2] = digits_rev[digits_offset]\n    local digits_offset_rev[digits_offset_rev\
    \ + 3] = digits_rev[digits_offset + 1]\n    local digits_offset_rev[digits_offset_rev\
    \ + 4] = digits_rev[digits_offset]\n    local digits_offset_rev[digits_offset_rev\
    \ + 5] = digits_rev[digits_offset + 1]\n    local digits_offset_rev[digits_offset_rev\
    \ + 6] = digits_rev[digits_offset]\n    local digits_offset_rev[digits_offset_rev\
    \ + 7] = digits_rev[digits_offset + 1]\n    local digits_offset_rev[digits_offset_rev\
    \ + 8] = digits_rev[digits_offset]\n    local digits_offset_rev[digits_offset_rev\
    \ + 9] = digits_rev[digits_offset + 1]\n    local digits_offset_rev[digits_offset_rev\
    \ + 10] = digits_rev[digits_offset]\n    local digits_offset_rev[digits_offset_rev\
    \ + 11] = digits_rev[digits_offset + 1]\n    return string.char(digits_offset_rev):reverse()\n\
    end", "  if shift > math.floor(x/10) or shift < 1 then\n    error(\"invalid shift\
    \ value\")\n  end\n  x = x - math.floor(x/10) * 10\n  return string.format(\"\
    %0.\" .. shift .. \"d\", x)\nend", "  local digits, shift = tonumber(x), tonumber(shift)\n\
    \  if shift < 0 then return '0' end\n  if shift > digits then return digits end\n\
    \  local result = {}\n  for i = 1, shift do\n    result[i] = string.rep('0', digits)\n\
    \  end\n  for i = shift, 1, -1 do\n    result[i] = string.rep('0', digits)\n \
    \ end\n  return table.concat(result)\nend", "  local result = \"\"\n  local sign\
    \ = x and \"-\" or \"\"\n  if x == 0 then return \"0\" end\n  local shift = shift\
    \ or 0\n  for i = math.floor(math.log(x, 10)) do -- Use log to determine how many\
    \ digits to shift\n    local tmp = x % 10\n    x = x / 10\n    result = tmp ..\
    \ result .. tostring(x)\n  end\n  result = result .. tostring(x)\n  for i = 1,\
    \ shift do -- Circular shift\n    result = string.sub(result, 1, #result - i +\
    \ 1)\n  end\n  return result .. sign\nend", "  local str = ''\n  if shift > math.floor(math.log(x\
    \ + 1, 10)) then\n    shift = math.floor(math.log(x + 1, 10)) + 1\n  end\n  for\
    \ i = shift, #x, shift do\n    str = str .. string.format('%0*d', i, x)\n  end\n\
    \  return str:reverse()\nend", "  local digits = math.floor(math.log10(x)) + 1\n\
    \  if shift >= digits then\n    shift = digits - 1\n  end\n  local result = string.rep(\"\
    0\", math.min(shift, digits))\n  for i = digits, 0, -1 do\n    result[i] = string.sub(x,\
    \ math.mod(x, 10) * 10 + math.floor(x/10) % 10, 1)\n    x = math.floor(x/10)\n\
    \  end\n  return result\nend", "    local digits = string.format(\"%.10g\", x)\n\
    \    local digits_reversed = string.gsub(digits, \"^(-?%d+)\", string)\n    return\
    \ string.sub(digits_reversed, -shift, -shift + 10)\nend", "  local s = ''\n  local\
    \ power = 1\n  -- Find the power of 2 that's greater or equal than the shift.\n\
    \  -- If shift is odd, return power * x.\n  -- Otherwise, return power * x + digits(x\
    \ - power * x).\n  while shift > 0 do\n    shift = shift - 1\n    power = power\
    \ << 1\n  end\n  -- Remove trailing zeros.\n  x = digits(x)\n  for i = #x - 1,\
    \ #s + 1 do\n    local digit = x[i]\n    if digit == '0' and i > 1 then\n    \
    \  break\n    end\n    s = s .. digit\n  end\n  -- Circular-shift the digits to\
    \ the left by the shift.\n  for i = #x - shift, 1, -1 do\n    local digit = x[i]\n\
    \    s = s .. digit\n  end\n  -- Strip trailing zeros.\n  if #s > 0 then\n   \
    \ s = string.sub(s, 1, #s - 1)\n  end\n  return s\nend", "    local digit_size\
    \ = math.floor(math.log10(x + 1))\n    local n = x\n    local digits = {}\n  \
    \  local last_digit\n    local carry = false\n    -- Shift digits right if shift\
    \ > digit size\n    if shift > digit_size then\n        shift = shift - digit_size\n\
    \    -- Shift digits left if shift < digit size\n    elseif shift < digit_size\
    \ then\n        shift = shift - digit_size\n        carry = true\n    end\n  \
    \  -- Add 1 to shift, add digits and take remainder\n    for i = shift, 1, -1\
    \ do\n        digits[i] = n % 10\n        n = math.floor(n/10)\n    end\n    --\
    \ Add final digit if needed\n    if n >= 1 then digits[#digits] = n end\n    --\
    \ Append last digit if needed\n    if carry then digits[#digits] = digits[#digits]\
    \ + 1 end\n    -- Reverse digits if necessary\n    if shift > digit_size then\n\
    \        for i = #digits, 1, -1 do\n            digits[i] = digits[i - 1]\n  \
    \      end\n    end\n    -- Concatenate digits and return\n    return table.concat(digits)\n\
    end", "  local t = {}\n  local digits = 1\n  repeat\n    table.insert(t, digits[math.floor(math.log(x)\
    \ / math.log(10) + 1)])\n    x = x % 10\n  until (digits > shift)\n  return table.concat(t,\
    \ \"\")\nend", "  local digits = tostring(x).\n    split('.')\n  digits[1] = digits[1]:gsub('%d',\
    \ function(digit)\n    return string.rep(\"0\", shift) + digit\n  end)\n  return\
    \ table.concat(digits, '.')\nend", "    shift = shift or 1\n    if x < 0 then\n\
    \        shift = shift - 1 + #x\n        x = -x -- If x is negative, need to add\
    \ # digits of x\n    end\n    if shift < 0 then\n        shift = shift + #x\n\
    \    end\n    local ret = ''\n    while shift > 0 do\n        local remaining\
    \ = math.modf(x * 10 + ret)[1]\n        if remaining > 0 then\n            ret\
    \ = string.sub(ret, 1, #ret + 1..-#remaining) + '0'\n        end\n        shift\
    \ = shift - 1\n    end\n    return ret .. string.sub(#ret, #ret + 1, #ret)\nend",
  "    if shift < 0 then return \"-\" .. tostring(x) end\n    local s = math.abs(shift)\n\
    \    local result = tostring(x)\n    if s < #result then return result end\n \
    \   while s > 0 do\n        -- Shift the digits right by shift (s -= 1)\n    \
    \    local t = result\n        result = t\n        local i = 1\n        while\
    \ #result > i do\n            result = result .. t\n            i = i + 1\n  \
    \      end\n        if s > 0 then\n            -- Shift the digits left (s -=\
    \ 1)\n            local t = result\n            result = t\n            i = 1\
    \ -- i is 1 for the first digit, 1 for the second, etc.\n            while #result\
    \ > i do\n                result = result .. t\n                i = i + 1\n  \
    \          end\n        end\n        s = s - 1\n    end\n    -- Reverse the digits\
    \ from the right\n    if s > 0 then\n        local t = result\n        result\
    \ = t\n        i = 1 -- i is 1 for the first digit, 1 for the second, etc.\n \
    \       while #result > i do\n            result = result .. t\n            i\
    \ = i + 1\n        end\n    end\n    return result\nend", "    if shift > #x then\
    \ return x\n    else return table.remove(unpack(string.gsub(string.format(\"%0.\"\
    \ .. (#x - shift) ..\"d\", x), \"%d\", \"%0\")), #x - shift)\n    end \nend",
  "    local s = math.abs(shift)\n    if s < 0 then\n        s = -(-s) + 1\n    end\n\
    \    local t = (x%10 + shift)*math.pow(10, s+2)\n    if s < 0 then\n        t\
    \ = math.abs(t - math.pow(10, s+1))\n    end\n    if x < 0 then\n        t = -(t-1)\n\
    \    end\n    return t:format(\"%g\"):reverse()\nend", "    local ret = \"0\"\n\
    \    while shift > 0 and ret ~= \"\" do\n        if x < 0 then\n            if\
    \ shift > 1 then\n                ret = string.reverse(ret)\n                shift\
    \ = shift - 1\n            end\n            if shift > 2 then\n              \
    \  ret = string.reverse(ret)\n                shift = shift - 2\n            end\n\
    \            if shift > 3 then\n                ret = string.reverse(ret)\n  \
    \              shift = shift - 3\n            end\n            if shift > 4 then\n\
    \                ret = string.reverse(ret)\n                shift = shift - 4\n\
    \            end\n            if shift > 5 then\n                ret = string.reverse(ret)\n\
    \                shift = shift - 5\n            end\n            if shift > 6\
    \ then\n                ret = string.reverse(ret)\n                shift = shift\
    \ - 6\n            end\n            if shift > 7 then\n                ret = string.reverse(ret)\n\
    \                shift = shift - 7\n            end\n            if shift > 8\
    \ then\n                ret = string.reverse(ret)\n                shift = shift\
    \ - 8\n            end\n            if shift > 9 then\n                ret = string.reverse(ret)\n\
    \                shift = shift - 9\n            end\n            if shift > 10\
    \ then\n                ret = string.reverse(ret)\n                shift = shift\
    \ - 10\n            end\n            if shift > 11 then\n                ret =\
    \ string.reverse(ret)\n                shift = shift - 11\n            end\n \
    \           if shift > 12 then\n                ret = string.reverse(ret)\n  \
    \              shift = shift - 12\n            end\n        end\n        remainder\
    \ = math.floor((x / 10) + 0.5)\n        x = remainder * 10\n        if x > 10\
    \ then\n            shift = shift - 1\n        end\n        shift = shift - 1\n\
    \    end\n    return ret\nend", "\tlocal digits = tostring(x).\n\t\tgsub('.',\
    \ function(c) c = string.char((string.byte(c) + shift) mod #string.char(c)); return\
    \ c end).\n\t\treverse()\n\treturn string.sub(digits, 1, -shift)\nend", "  local\
    \ r = x\n  repeat\n    r = r * 10 % 10 + r / 10\n  until r < 1\n  r = math.floor(r)\n\
    \  x = x - r\n  repeat\n    r = r * 10 % 10 + r / 10\n  until r >= 1\n  x = x\
    \ + r\n  return string.format(\"%0.*d\", shift, x)\nend", "    -- We start by\
    \ adding digits in reverse order to a string of zeroes, then reverse the string.\n\
    \    local digits = string.rep(\" \", shift)\n    digits = string.reverse(digits)",
  "  if shift < 0 then\n    shift = shift + #x\n  end\n  local digits = #x\n  for\
    \ i = 0, digits - shift + 1 do\n    local digit_idx = i + shift\n    if digit_idx\
    \ >= #x then\n      digit_idx = #x - 1\n    end\n    table.inserts(x, digit_idx)\n\
    \  end\n  return table.concat(x)\nend", "  -- Based on code by @glennjones from\
    \ https://forums.aws.amazon.com/thread.jspa?threadID=5606\n  assert(x >= 0, \"\
    Cannot shift non-positive numbers by \" .. shift .. \".\")\n  local s = stringx.strip_zeros(tonumber(x))\n\
    \  local n = tonumber(s)\n  if n and tonumber(string.sub(s, 1, shift)) then\n\
    \    return string.sub(s, 1, shift)\n  else\n    return string.gsub(s, \"%d+\"\
    , function(c) return string.sub(c, shift, 1) end)\n  end\nend", "  assert(type(x)\
    \ ~= 'string')\n  assert(type(shift) ~= 'number')\n  assert(shift >= 0)\n  local\
    \ digits = tonumber(x):reverse()\n  local length = math.floor(digits:length()\
    \ / shift)\n  assert(math.ceil(digits:length() / shift) == length)\n  local digits_shift\
    \ = digits:sub(1, length - 1)\n  local digits_shift_right = digits:sub(1, length)\
    \ * shift\n  return string.reverse(digits_shift .. digits_shift_right)\nend",
  "  local digits = '0' + x\n  local i, n = 1, #digits\n  while n > shift do\n   \
    \ digits = digits:sub(1, #digits - shift)\n    i = i + 1\n    n = math.floor(math.pow(10,\
    \ i) * x) / math.pow(10, i)\n  end\n  return digits:sub(1, i)\nend", "  local\
    \ digits = math.floor(math.log(x, 256))\n  local shiftbits = math.abs(shift)",
  "  local s, i\n  if shift < 0 then return string.reverse(x) end\n  s = ''\n  i =\
    \ math.ceil(x) - math.floor(x + 0.5)\n  while i > 0 do\n    if i == shift then\n\
    \      s = s .. x\n    else\n      s = s .. '0' .. math.floor(i/10)\n    end\n\
    \    i = math.floor(i/10)\n  end\n  return s\nend", "  if x < 0 then\n    return\
    \ -circular_shift(-x, shift)\n  end\n  local result = \"\"\n  while x > 0 do\n\
    \    local digit = math.floor(x)\n    digit = math.modf(x - digit)\n    local\
    \ last_digit = digit[1]\n    x = math.floor(x / 10)\n    if last_digit ~= 0 then\n\
    \      result = table.concat(digit, last_digit..\"0\"..result)\n    else\n   \
    \   result = table.concat(digit, result)\n    end\n  end\n  return result .. (shift\
    \ == 1 and \"\" or \"0\"..shift)\nend", "\tlocal len = math.ceil(x/10)\n\tx =\
    \ x % 10\n\tlocal result = ''\n\tif len < shift then\n\t\t-- Shift too large\n\
    \t\tx = 0\n\t\tresult = result .. math.abs(x)\n\telse\n\t\t-- Shift too small\n\
    \t\tx = x / 10\n\t\tfor i = len - shift:-1 do\n\t\t\tx = x + 10\n\t\t\tresult\
    \ = result .. math.abs(x)\n\t\tend\n\tend\n\treturn result\nend", "   local digits,\
    \ remainder = divmod(x, 10)\n   if shift*2 < digits:\n      return string.format(\"\
    %0*d\", digits, remainder)\n   else\n      return string.format(\"%0*d\", digits,\
    \ circular_shift(remainder, shift*2))\n   end\nend", "  if shift > math.floor(x)\
    \ then\n    return string.reverse(string.sub(x, math.floor(x), math.floor(x) +\
    \ shift))\n  end\n  return string.sub(x, math.floor(x), math.floor(x) + shift)\n\
    end", "  if shift > #x then\n    return x\n  end\n  local string = \"\"\n  for\
    \ i = #x + 1, shift, -1 do\n    string = string .. tostring(x[i])\n  end\n  return\
    \ string\nend", "  local result = x\n  assert(shift > 0 and shift < x and math.floor(x\
    \ + 0.5) == math.floor(x + 0.5))\n  if shift < 0 then\n    shift = -shift\n  \
    \  local y = x\n    do result = result .. '0' end\n    while math.abs(shift) >\
    \ math.ceil(math.log(y) / math.log(2)) do\n      result = math.floor(result /\
    \ 10) * 10 + math.floor(result / 100 % 10) * 100 + math.floor(result / 1000 %\
    \ 10) * 1000 + math.floor(result / 10000 % 10) * 10000 + math.floor(result / 100000\
    \ % 10) * 100000 + math.floor(result / 1000000 % 10) * 1000000\n    end\n  else\n\
    \    local y = x\n    do result = result .. '9' end\n    while math.abs(shift)\
    \ > math.ceil(math.log(y) / math.log(2)) do\n      result = math.floor(result\
    \ / 10) * 10 + math.floor(result / 100 % 10) * 100 + math.floor(result / 1000\
    \ % 10) * 1000 + math.floor(result / 10000 % 10) * 10000 + math.floor(result /\
    \ 100000 % 10) * 100000 + math.floor(result / 1000000 % 10) * 1000000\n    end\n\
    \  end\n  return result\nend", "    if shift > #x then\n        return string.reverse(x)\n\
    \    end\n    return string.rep('0', shift) + string.reverse(string.rep('0', #x\
    \ - shift))\nend", "    -- if shift is bigger than number of digits, just return\
    \ the digits reversed\n    if shift == 0 then return x end\n    local num_digits\
    \ = math.floor(math.log10(x)) + 1\n    shift = shift % num_digits\n    if shift\
    \ >= num_digits then shift = num_digits end", "   local digits = x\n   if shift\
    \ == 1 then\n      return digits:reverse()\n   end\n   if shift > #digits then\n\
    \      return \"0\"\n   end\n   local r = digits:reverse()\n   for i = #digits,\
    \ 0, -shift do\n      r = string.rep(\"0\" .. digits[i], shift)\n      r = r +\
    \ r\n   end\n   return r\nend", "  if shift > math.log10(x) then\n    return \"\
    Invalid argument\"\n  end", "  if shift > math.log10(#x) then\n    shift = math.log10(#x)\n\
    \  end", "  local digits = math.floor(math.log10(x))\n  if digits > shift then\n\
    \    -- Reverse the digits if shift is > number of digits\n    x = x * 10 ^ (shift\
    \ - digits)\n  else\n    -- Shift the digits left\n    x = x ^ math.pow(10, shift)\n\
    \  end\n  return string.format(\"%0.\" .. shift .. \"d\", x)\nend", "  local numchars\
    \ = '0123456789'\n  local numcharslen = #numchars\n  local digits, result = string.rep('',\
    \ shift), ''\n  for i = 1, shift do\n    digits = string.sub(numchars, ((i + 1)\
    \ * numcharslen - 1) % numcharslen, i * numcharslen + 1)\n    result = result\
    \ .. digits\n  end\n  if x > shift then\n    result = result .. string.sub(numchars,\
    \ ((shift + 1) * numcharslen - 1) % numcharslen, ((shift + 2) * numcharslen -\
    \ 1) % numcharslen)\n  end\n  return result\nend", "  shift = shift or 0\n  local\
    \ s = math.floor(math.log10(x))\n  local shiftSign = shift > 0 and 1 or -1\n \
    \ local r = 10\n  local result = ''\n  -- Reverse digits and shift left\n  while\
    \ x ~= 0 do\n    local digit = math.floor((x / r) % 10)\n    local shiftDigit\
    \ = (x / r) - digit*10\n    local result = digit .. result\n    x = shiftDigit\n\
    \    if shiftDigit ~= 0 then\n      x = 10*x + shift\n      r = 10\n    end\n\
    \  end\n  if shift > s then -- Shift right\n    shift = s\n    local digit = math.floor((x\
    \ / 10) % 10)\n    local shiftDigit = (x / 10) - digit*10\n    local result =\
    \ digit .. result\n  elseif shift < -s then -- Shift left\n    shift = -s\n  \
    \  local digit = math.floor((x / r) % 10)\n    local shiftDigit = (x / r) - digit*10\n\
    \    local result = digit .. result\n  else\n    shift = 0\n  end\n  if shiftSign\
    \ * 10 ~= shift then -- Shift sign\n    shift = -shift\n  end\n  return result\n\
    end", "   local result = string.rep(string.sub(x, 1, shift + 1), shift)\n   return\
    \ string.gsub(result, '..$', '')\nend", "  local digits = math.floor(math.log10(math.abs(x)))\
    \ + shift - 1\n  local digit = math.floor(math.pow(10, digits))\n  local ans =\
    \ \"\"\n  for i = 1, digits do\n    local m = math.modf(x / digit)\n    ans =\
    \ string.rep(\"0\", digit-math.floor(digits)) + ans + string.rep(\"1\", math.abs(m[1]))\
    \ ..\n      m[2] .. ans .. string.rep(\"0\", digit-math.floor(digits))\n    digit\
    \ = math.floor(digit)\n  end\n  if digits > 0 then\n    ans = string.reverse(ans)\n\
    \  end\n  return ans\nend", "  local s, r = shift, x\n  while s < string.len(x)\
    \ do\n    s = s - r\n    r = string.format('%0*d', s, r)\n  end\n  return r\n\
    end\n</cell>\n<text>\nNext, we implement a function that checks if a string is\
    \ a valid telephone number.", "    local digits = math.floor(math.log10(x))\n\
    \    local digits = math.min(digits, math.max(shift, 0))\n    local digits_str\
    \ = string.format(\"%0\", digits)\n    local result = \"\"\n    for i = 0, digits-1\
    \ do\n        local digit = math.floor(x/math.pow(10, i))\n        if digit >\
    \ 0 then\n            digits_str = string.format(\"%s%d\", digits_str, digit)\n\
    \        end\n        result = string.format(\"%s%s\", result, digits_str)\n \
    \   end\n    return result\nend", "  local result = x\n  for i = 1, shift do\n\
    \    result = result .. \"0\"\n  end\n  return result\nend", "  local str = tonumber(string(x))\n\
    \  if str == 0 then return \"\" end\n  local n = math.floor(math.log(str, 10))\n\
    \  if shift <= n then return str end\n  local result = string(tonumber(string(x)))\n\
    \  for i = 1, n do\n    local s = math.floor((math.floor(n / 2) * 2) + 1)\n  \
    \  local p = string.sub(result, 0, s)\n    local f = math.floor((n / 2) - 1)\n\
    \    local t = string.sub(result, (s + 1), (s + 1))\n    local g = string.sub(result,\
    \ (f + 1), (f + 1))\n    if f > n then g = '9' end\n    p = string.sub(p, f +\
    \ 1, f)\n    t = string.sub(t, f + 1, f)\n    local n = string.len(p)\n    for\
    \ k = 1, f do\n      local j = string.find(string.sub(t, (k - 1), k), '9')\n \
    \     if j > -1 then\n        p = string.sub(p, j, j)\n        t = string.sub(t,\
    \ (j + 1), (j + 1))\n      else\n        j = string.find(t, '9')\n        if j\
    \ > -1 then\n          t = string.sub(t, 0, j)\n        else\n          t = t\
    \ .. '9'\n        end\n      end\n    end\n    if string.sub(t, 0, f) == '9' then\n\
    \      t = t .. '0'\n    end\n    if f > n then return t end\n    result = result\
    \ .. p\n  end\n  return result\nend", "    local str = ''\n    local pow = 1\n\
    \    for i = #x, 1, -1 do\n        local digit = tonumber(string.format(\"%0*d\"\
    , i, x))\n        str = string.format('%0*d', i, digit + shift * pow)\n      \
    \  pow = pow * 10\n    end\n    return str\nend", "    local s = \"\"\n    for\
    \ i = 1, shift, 1 do\n        s = string.rep(\"0\", math.floor(x%10)) + s\n  \
    \      x = math.floor(x/10)\n    end\n    if x > 0 then\n        s = string.rep(\"\
    0\", math.floor(x%10)) + s\n    end\n    return s\nend", "  local num_digits =\
    \ math.floor(math.log10(x))\n  local digits = x\n  local shift_count = 0", " \
    \ if x < 0 then\n    error(message('number:negative', 'x'), 1)\n  end\n  local\
    \ digits = 0\n  -- Shift up to the highest number that will still have the given\
    \ number of digits.\n  -- The highest number with n digits is floor((n + 1) /\
    \ 2) * 2 + 1, or n\n  -- digits in length.\n  while shift * digits + digits <=\
    \ math.floor((math.floor(#x) / #x) * 2) and shift > 0 do\n    -- Circular shift\
    \ the digits to the left by shift.\n    digits = digits + 1\n    x = string.format('%0*d',\
    \ shift, x:gsub('.', ''))\n    -- Shift down to the next highest number that will\
    \ still have the same\n    -- number of digits.\n    -- The lowest number with\
    \ n digits is floor((n + 1) / 2) * 2, or n\n    -- digits in length.\n  end\n\
    \  -- Truncate to number of digits (with rounding up).\n  return x:sub(1, digits)\n\
    end", "  local x_str = tostring(x)\n  local n_digits = #x_str\n  local n_zeros\
    \ = math.floor(n_digits / shift)\n  local n_zeros = n_zeros - n_digits % shift\
    \ or n_zeros", "    if shift < 0 then\n        shift = shift + #x\n    end\n \
    \   if shift > #x then\n        shift = shift - #x\n    end\n    local s = ''\n\
    \    for i=0,shift do\n        s = string.format('%0*d', #x + i + 1, s)\n    end\n\
    \    return s\nend", '  if shift > math.log10(x) or shift < -math.log10(x) then
    return x end', "  if shift > math.log10(#x) or shift < 0 then\n    return string.reverse(string.sub(string.sub(string,\
    \ 1, math.log10(#x)), 1, -shift))\n  end\n  return string.reverse(string.sub(string.sub(string,\
    \ 1, math.log10(#x)), math.log10(#x) - 1, -shift))\nend", "\tlocal n = math.abs(x)\n\
    \tlocal s = math.floor(math.log(n, 10) + shift + 1) -- Round up to the next multiple\
    \ of 10\n\treturn tonumber(string.format('%d', x - ((10^s - 1) / (10^s))))\nend",
  "  local result = x\n  local digits, i = 0, 0\n  repeat\n    digits = math.floor(result\
    \ % 10) + 1\n    result = math.floor(result / 10)\n    result = string.sub(string.sub(result..'0',\
    \ i, i), -1, 1)\n    result = result .. string.sub(string.sub(result..'0', shift,\
    \ shift), -1, 1)\n    i = i + shift - digits\n  until i < 0\n  return result ..\
    \ string.sub(result..'0', i, i)\nend", "  local s = math.floor(math.abs(x))\n\
    \  local shifted = x % s\n  if shift == 0 then return shifted end\n  if shift\
    \ == s then return \"0\"\n  elseif shift == s - 1 then return \"1\" end\n  return\
    \ circular_shift(shifted, shift + 1)\nend", "   assert(type(shift)==\"number\"\
    )\n   assert(shift > 0)\n   assert(type(x)==\"string\" and  x == tostring(x) and\
    \ #x>0 and #x<=1024)\n   local digits = {}\n   local last = 0\n   repeat\n   \
    \   local last = last + 1\n      digits[last] = x%10\n      x = x/10\n   until\
    \ not x \n   local result = ''\n   for i = 1, #digits do\n      result = result\
    \ .. digits[i]\n      if i > shift then result = result .. tostring(digits[#digits])\
    \ end\n   end\n   return result\nend", "  if shift > tonumber(string(x)) then\
    \ return x end\n  local s = math.abs(shift)\n  local digits = math.floor(math.log(x\
    \ / 10^s, 10))\n  x = x * 10^s\n  local result = \"\"\n  for i = digits, 1, -1\
    \ do\n    result = string.format(\"%d%s\", tonumber(string(x)), result)\n    x\
    \ = x / 10^s\n  end\n  return result\nend", "    local ret = \"\"\n    if x ~=\
    \ 0 then\n        local m = math.floor(math.log(abs(x)))\n        shift = shift\
    \ - m % shift\n        if shift < 0 then\n            m = m - shift\n        \
    \    for i = m-1, -1, -1 do ret = ret * 10 + tostring(i) end\n        else\n \
    \           m = m + shift\n            for i=1, m do ret = ret * 10 + tostring(i)\
    \ end\n        end\n    end\n    return ret\nend", "    if x ~= 0 then\n     \
    \   -- If shift > number of digits, return digits reversed.\n        -- >>> circular_shift(12,\
    \ 2)\n        -- '12'\n        if shift > math.floor(math.log(abs(x), 10)) + 1\
    \ then\n            local digits = math.floor(math.log(abs(x), 10))\n        \
    \    return ((x / math.pow(10, digits)) * math.pow(10, shift))\n        end\n\
    \        local digits = math.floor(math.log(abs(x), 10))\n        return ((x /\
    \ math.pow(10, digits)) * math.pow(10, shift)) / math.pow(10, digits)\n    end\n\
    \    return 0\nend", "   if shift == 0 then\n      return x\n   else\n      local\
    \ remaining = math.modf(x)\n      local sign = math.sign(remaining)\n      local\
    \ shift = math.abs(shift)\n      x = math.abs(x)", "\tshift = shift and shift\
    \ or 0\n\tx = x and tonumber(x) or 0\n\tx = x and math.floor(x) or 0\n\tlocal\
    \ result = x\n\twhile shift > 0 and x > 0 do\n\t\tresult = math.floor(result /\
    \ 10) * 10 + result % 10\n\t\tshift = shift - 1\n\tend\n\tlocal reversed = result\
    \ and result > 0 and string or sub\n\tresult = result and result > 0 and result\
    \ or 0\n\treturn reversed(result)\nend", "    local str = tonumber(string(x))\n\
    \    if not str then\n        error('String expected.')\n    end\n    local strlen\
    \ = #str\n    if not strlen then\n        error('String length is nil.')\n   \
    \ end\n    if strlen ~= shift then\n        error('Too many digits to shift left.')\n\
    \    end\n    local str0 = str\n    local res = {}\n    local pos1 = 0\n    repeat\n\
    \        local pos2 = math.floor((pos1 + shift) / 2)\n        res[pos2] = str0[pos1]\n\
    \        str0 = str0[#pos1]\n        pos1 = pos2\n    until pos1 == 0\n    return\
    \ table.concat(res, ''):reverse()\nend", "   local digits = x:gsub('%d+', function(digit)\
    \ return (digit-1) % shift+1 end)\n   return (x:gsub('%d+', function(digit) return\
    \ digit end):reverse()):sub(1)\nend", "  local function rotate_left(x, n)\n  \
    \  return (x * math.pow(2, n - 1)) + math.floor(x * math.pow(2, n))\n  end\n \
    \ local function rotate_right(x, n)\n    return ((x - math.floor(x * math.pow(2,\
    \ n))) / math.pow(2, n)) + math.floor(x * math.pow(2, n))\n  end", "    local\
    \ string = {}\n    shift = shift - math.floor(shift)", "  assert(type(shift) ==\
    \ \"number\")\n  assert(shift > 0)", "    local digits, length = x:div(10), x:mod(10)\n\
    \    if length ~= 0 then\n        local digits, length = digits:mul(shift), digits:mul(shift:abs())\n\
    \        return digits:sum(digits) + length\n    end\n    return x:reverse()\n\
    end", "  if shift > math.floor(x:len()) then return x:reverse() end\n  local s\
    \ = math.floor(x:len()) - shift\n  local out = { }\n  local power = 1\n  for i\
    \ = s, 1, -1 do\n    table.insert(out, x[i])\n    if power < x:len() and x[i]\
    \ == '0' then\n      power = 0\n    else\n      power = power + 1\n    end\n \
    \ end\n  return table.concat(out)\nend", "    local rem, result = x%10, \"\"\n\
    \    for i = 1, shift do\n        result = string.format(\"%d%s\", rem, result)\n\
    \        rem = math.floor(x/10)\n    end\n    return result .. result\nend", " \
    \   if shift < 0 then\n        shift = -shift\n        x = x and x:reverse()\n\
    \    end\n    local digits, rest = x\n    if digits then\n        digits = digits:byte()\n\
    \        local digitsLength = #digits\n        local shiftDigit = shift % digitsLength\n\
    \        shift = (shift - shiftDigit) / digitsLength\n        for i = digits,\
    \ 1, -1 do\n            digits[i] = digits[i - shift]\n        end\n        return\
    \ table.concat(digits, \"\")\n    else\n        -- Shift digits by -shift\n  \
    \      local shiftDigit = shift % #rest\n        shift = shift - shiftDigit\n\
    \        local newRest = {}\n        for i = 1, #rest + shift do table.insert(newRest,\
    \ table.unpack(rest, 1, i - 1)) end\n        return table.concat(newRest, \"\"\
    )\n    end\nend", "    local digits = tostring(x) and \"0123456789\" or tostring(x)\n\
    \    local result = \"\"\n    repeat\n        local digit, mod = div(digits, 10)\n\
    \        digits = mod\n        result = result .. digit\n    until not digit\n\
    \    local length = #result\n    if length > shift then\n        result = result:sub(1,\
    \ #result - shift)\n    elseif length < shift then\n        result = result:sub(1,\
    \ #result + shift)\n    end\n    return result\nend", "  -- assert(type(shift)\
    \ == \"number\")\n  assert(shift >= 0 and shift <= 16, \"shift must be between\
    \ 0 and 16\")\n  local digits, carry\n  digits = x:byte()\n  carry = 0\n  for\
    \ i = 1, shift do\n    -- shift digits right\n    digits = digits:bitshift()\n\
    \    -- carry the digit\n    carry = digits:borrow()\n    -- add carry to digits\n\
    \    digits = digits:add(bit.borrow(carry))\n  end\n  return table.concat(digits,\
    \ \"\")\nend", "    local digits = math.floor(x) - math.floor(math.floor(x) /\
    \ 10)\n    if digits == 0 then\n        return ''\n    else\n        shift = shift\
    \ + math.floor(math.log10(math.abs(digits)))\n        return string.format('%g',\
    \ math.floor(x / 10 ** shift)) * 10 ** shift\n    end\nend", "   if shift > #x\
    \ then\n      return string.char(tonumber(x)):reverse()\n   else\n      return\
    \ string.sub(string.char(tonumber(x)), 1, shift)\n   end\nend", "    shift = shift\
    \ or 1\n    local digits = math.log10(x) + 1\n    local sdigits = math.pow(10,\
    \ digits)\n    local result = {}\n    for i=1,digits do\n        table.insert(result,\
    \ math.floor((x % sdigits) / sdigits))\n        x = x / sdigits\n    end\n   \
    \ local reversed = true\n    if shift == digits then\n        reversed = false\n\
    \    elseif shift < digits then\n        for i=1,shift do\n            table.insert(result,\
    \ x[i])\n        end\n    else\n        for i=shift,1,-1 do\n            table.insert(result,\
    \ x[i])\n        end\n    end\n    if reversed then\n        table.insert(result,\
    \ x[1])\n    end\n    return table.concat(result)\nend\n</code>\n<|/ a |>\n<|\
    \ a dscore=1 |>\nIf you don't mind a lua based solution, you could also use this:\n\
    <code>", "  shift = shift % #x\n  return string.reverse(string.sub(string.char(x),\
    \ #x + shift, #x + #x - shift))\nend", "  local digits, i = 0, 1\n  repeat\n \
    \   digits = string.sub(digits, i, i + digits)\n    i = i + digits + 1\n  until\
    \ not digits or i <= #x"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
