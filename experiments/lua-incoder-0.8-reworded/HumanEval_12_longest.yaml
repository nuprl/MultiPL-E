name: HumanEval_12_longest
language: lua
prompt: "-- Out of table of strings, return the longest one. Return the first one\
  \ in case of multiple\n-- strings of the same length. Return None in case the input\
  \ table is empty.\n-- >>> longest({})\n-- None\n-- >>> longest({'a', 'b', 'c'})\n\
  -- 'a'\n-- >>> longest({'a', 'bb', 'ccc'})\n-- 'ccc'\nlocal function longest(strings)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = longest\n\
  \    lu.assertEquals(candidate({}), None)\n    lu.assertEquals(candidate({'x', 'y',\
  \ 'z'}), 'x')\n    lu.assertEquals(candidate({'x', 'yyy', 'zzzz', 'www', 'kkkk',\
  \ 'abc'}), 'zzzz')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local longest, longestlen = nil, -1\n  for key, value in pairs(strings)\
    \ do\n    if longestlen == -1 or #key > longestlen then\n      longest, longestlen\
    \ = key, #key\n    end\n  end\n  return longest\nend", "  if next(strings) ~=\
    \ nil then\n    return longest(next(strings)) or longest(strings)\n  end\n  return\
    \ nil\nend", "  assert(type(strings) == 'table')\n  local maxLen = nil\n  local\
    \ longestString = nil\n  for k, v in pairs(strings) do\n    local newLen = #v\n\
    \    if newLen > maxLen then\n      maxLen = newLen\n      longestString = k\n\
    \    end\n  end\n  return longestString\nend", "    if next(strings) ~= nil then\n\
    \        local maxlen = 0\n        for _, s in ipairs(strings) do\n          \
    \  local len = #s\n            if len > maxlen then\n                maxlen =\
    \ len\n            end\n        end\n        if maxlen == 0 then return nil end\n\
    \        return strings[#strings]\n    end\nend", "  if #strings == 0 then\n \
    \   return nil\n  end\n  local largest = strings[1]\n  local length = #largest\n\
    \  for i = 2, #strings do\n    if length < #strings[i] then\n      largest = strings[i]\n\
    \      length = #largest\n    end\n  end\n  return largest\nend", "  assert(type(strings)\
    \ == 'table')\n  if #strings == 0 then return nil end\n  local longest = strings[1]\n\
    \  for i = 2, #strings do\n    if longest:len() > strings[i]:len() then\n    \
    \  longest = strings[i]\n    end\n  end\n  return longest\nend", "  local longest_len\
    \ = -1\n  local longest_str = nil\n  for _, s in pairs(strings) do\n    local\
    \ len = #s\n    if len > longest_len then\n      longest_len = len\n      longest_str\
    \ = s\n    end\n  end\n  return longest_len == -1 and nil or longest_str\nend",
  "    local max = 0\n    local first, rest = table.remove(strings, 1), {}\n    for\
    \ k, v in pairs(strings) do\n        local l = #k\n        if max < l then\n \
    \           max, first = l, k\n        elseif l > max then\n            max =\
    \ l\n        end\n        rest[k] = v\n    end\n    return first, table.remove(rest,\
    \ 1)\nend", "    local max_len = -1\n    local max_len_string\n    for _, string\
    \ in ipairs(strings) do\n        local cur_len = #string\n        if cur_len >\
    \ max_len and cur_len > 0 then\n            if max_len == -1 or cur_len > max_len\
    \ then\n                max_len = cur_len\n                max_len_string = string\n\
    \            end\n        end\n    end\n    return max_len_string\nend", "  local\
    \ length = -1\n  local result = false", "  local longest_len = 0\n  local longest_str\
    \ = nil\n  for i=1, #strings do\n    local len = #strings[i]\n    if len > longest_len\
    \ then\n      longest_len = len\n      longest_str = strings[i]\n    end\n  end\n\
    \  return longest_str\nend", "\tlocal max = nil\n\tlocal maxLen = -1\n\tfor i,\
    \ str in pairs(strings) do\n\t\tlocal length = string.len(str)\n\t\tif max ~=\
    \ nil then\n\t\t\tif maxLen < length then\n\t\t\t\tmaxLen = length\n\t\t\t\tmax\
    \ = str\n\t\t\tend\n\t\telse\n\t\t\tmax = str\n\t\t\tmaxLen = length\n\t\tend\n\
    \tend\n\treturn max and max\nend", "  local longest_string = \"\"\n  local longest_string_len\
    \ = 1\n  for k, v in pairs(strings) do\n    if #k < longest_string_len then\n\
    \      longest_string = k\n      longest_string_len = #k\n    end\n  end\n  return\
    \ longest_string or nil\nend", "    local longest, length\n    longest, length\
    \ = nil, 0\n    for _, s in ipairs(strings) do\n        length = length + #s\n\
    \        if length >= #longest then\n            longest, length = s, length\n\
    \        end\n    end\n    return longest or strings[1]\nend", "\tassert(strings\
    \ and strings[1] and strings[1])\n\tif #strings == 0 then\n\t\treturn nil\n\t\
    end\n\tlocal max_length = strings[1]:len()\n\tfor i, string in pairs(strings)\
    \ do\n\t\tif string:len() > max_length then\n\t\t\tmax_length = string:len()\n\
    \t\tend\n\tend\n\tif max_length == 1 then\n\t\treturn strings[1]\n\tend\n\tfor\
    \ i, string in pairs(strings) do\n\t\tif string:len() > max_length then\n\t\t\t\
    return strings[i]\n\t\tend\n\tend\nend", "  local strings_count = #strings\n \
    \ if strings_count < 1 then\n    return nil\n  end", "  assert(type(strings) ==\
    \ 'table' and next(strings))\n  local len = #strings[#strings]\n  -- Optimize\
    \ cases where all strings have the same length\n  if len == #strings then\n  \
    \  return next(strings)\n  elseif len == 1 then\n    return strings[1]\n  else\n\
    \    -- Iterate over longest strings, in order and return the first one (longest)\n\
    \    for _, s in pairs(strings) do\n      if len > #s then len = #s end\n    end\n\
    \    return strings[len]\n  end\nend", "\tif not strings then\n\t\treturn nil\n\
    \tend", "   if #strings == 0 then\n      return nil\n   end", "  if next(strings)\
    \ == nil then return nil end\n  local longest = next(strings)\n  for i = 1, #strings\
    \ do\n    longest = strings[i] and longest and strings[i]:len() > longest:len()\
    \ and strings[i]:len()\n    if longest ~= strings[i] then\n      return longest\n\
    \    end\n  end\n  return longest\nend", "    local longestLength, longestString\
    \ = \"-1\", \"NONE\"\n    for _, str in pairs(strings) do\n        if str == \"\
    NONE\" or str == \"\" then\n            return str\n        end\n        if string.len(str)\
    \ > longestLength then\n            longestLength, longestString = string.len(str),\
    \ str\n        end\n    end\n    return longestString\nend", "  local max\n  if\
    \ next(strings) == nil then return end\n  max = nil\n  for _, str in ipairs(strings)\
    \ do\n    if max then\n      if max == str then return end -- Multiple strings\
    \ of the same length, return the last\n      if #max > #str then max = str end\
    \ -- String longer than others, keep it for the first longest string\n    else\
    \ max = str end\n  end\n  return max\nend", "  local max_len = nil\n  for _, string\
    \ in ipairs(strings) do\n    if not string then\n      -- empty string\n     \
    \ break\n    end\n    if max_len and max_len < #string then\n      -- more than\
    \ one length string\n      break\n    end\n    max_len = #string\n  end\n  if\
    \ max_len then\n    return strings[max_len]\n  else\n    return max_len\n  end\n\
    end", "  local lengths = {}\n  local longest, length\n  for _, str in ipairs(strings)\
    \ do\n    table.insert(lengths, #str)\n  end\n  local length\n  for _, length\
    \ in ipairs(lengths) do\n    if not length then break end\n  end\n  local maxLength\
    \ = length\n  while true do\n    local maxLength2 = 1\n    for _, length in ipairs(lengths)\
    \ do\n      if length > maxLength then\n        maxLength = length\n      elseif\
    \ length < maxLength2 then\n        maxLength2 = length\n      end\n    end\n\
    \    if maxLength2 == length then\n      break\n    end\n    maxLength = maxLength2\n\
    \  end\n  return longest, maxLength\nend", "    if next(strings) == nil then\n\
    \        return nil\n    end", "    local result = nil\n    local maxlen = 0\n\
    \    for k, v in pairs(strings) do\n        local l = #v\n        if l > maxlen\
    \ then\n            maxlen = l\n            result = v\n        end\n    end\n\
    \    return result\nend", "  local longest = strings[1]\n  for i = 2, #strings\
    \ do\n    if #longest < #strings[i] then\n      longest = strings[i]\n    end\n\
    \  end\n  return longest\nend", "  if next(strings) == nil then return end\n \
    \ local max_len = -1\n  local max_idx = nil\n  for idx, string in ipairs(strings)\
    \ do\n    if max_len < string#string or max_len == -1 then\n      max_len = string#string\n\
    \      max_idx = idx\n    end\n  end\n  return strings[max_idx] if max_len > 1\
    \ then return strings[max_idx] else return strings[max_idx] end\nend", "  if #strings\
    \ == 0 then\n    return nil\n  elseif #strings == 1 then\n    return strings[1]\n\
    \  else\n    local longest_length = math.max(#strings, 1)\n    local longest_string\
    \ = strings[longest_length]\n    for i = longest_length + 1, #strings do\n   \
    \   local str_length = strings[i]\n      if str_length == longest_length then\n\
    \        longest_string = strings[i]\n      else\n        break\n      end\n \
    \   end\n    return longest_string\n  end\nend", "   local maxLength = 0\n   local\
    \ maxString = nil\n   for _, string in ipairs(strings) do\n      if maxLength\
    \ < #string then\n         maxLength = #string\n         maxString = string\n\
    \      elseif maxLength == #string then\n         if #string > maxLength then\n\
    \            -- We need to return the first string with a longer length\n    \
    \        return maxString\n         end\n      end\n   end\n   return maxString\n\
    end", "    if not strings then\n        return nil\n    end\n    local longest_len\
    \ = -1\n    local longest_str = nil\n    for str in pairs(strings) do\n      \
    \  local len = #str\n        if len > longest_len then\n            longest_len\
    \ = len\n            longest_str = str\n        end\n    end\n    return longest_str\n\
    end", "  if #strings == 0 then return nil end\n  local largest = nil\n  local\
    \ longest = 0\n  for i = 1, #strings do\n    if largest == nil or strings[i] >\
    \ largest then\n      largest = strings[i]\n      longest = i\n    end\n  end\n\
    \  return largest == nil and strings[longest] or largest\nend", "\tlocal longest,\
    \ i, count = nil, 0, 0\n\tfor i, value in pairs(strings) do\n\t\tif count < strings.length\
    \ then\n\t\t\tcount = strings.length\n\t\tend\n\t\tif count > 0 then\n\t\t\tif\
    \ count == 1 then\n\t\t\t\tlongest = value\n\t\t\telse\n\t\t\t\tlongest = strings[count]\n\
    \t\t\tend\n\t\tend\n\tend\n\treturn longest\nend", "  assert(type(strings) ==\
    \ 'table')", "\tif not strings or #strings == 0 then\n\t\treturn nil\n\telse\n\
    \t\tlocal longest_len = -1\n\t\tlocal longest_str = nil\n\t\tfor _, str in ipairs(strings)\
    \ do\n\t\t\tlocal len = #str\n\t\t\tif len > longest_len then\n\t\t\t\tlongest_len\
    \ = len\n\t\t\t\tlongest_str = str\n\t\t\tend\n\t\tend\n\t\treturn longest_str\n\
    \tend\nend", "    local len = #strings\n    if len == 0 then\n        return nil\n\
    \    end\n    local longest = strings[len]\n    for i = len + 1, 1, -1 do\n  \
    \      local other = strings[i]\n        if len > 1 then\n            local len\
    \ = #other + 1\n            if len > #longest then\n                longest =\
    \ other\n            end\n        elseif other ~= '' then\n            longest\
    \ = other\n        end\n    end\n    return longest\nend", "    local longest_string\
    \ = nil\n    local longest_string_len = 0", "\tlocal longest_len = 0\n\tlocal\
    \ longest_len_string = nil\n\tfor i = 1, #strings do\n\t\tlocal len = #strings[i]\n\
    \t\tif len > longest_len then\n\t\t\tlongest_len = len\n\t\t\tlongest_len_string\
    \ = strings[i]\n\t\tend\n\tend\n\treturn longest_len_string\nend", "  if not strings\
    \ then return nil end\n  local longest, longestLength = nil, -1\n  for _, str\
    \ in pairs(strings) do\n    local currentLength = str:len()\n    if currentLength\
    \ > longestLength then\n      longest, longestLength = str, currentLength\n  \
    \  end\n  end\n  return longest\nend", '  if not strings then return nil end',
  "  if next(strings) ~= nil then\n    local lengths = map(string.pad, 0, strings)\n\
    \    local index = 1\n    for i = 2, #strings do\n      local length = lengths[index]\n\
    \      if length > lengths[index-1] then\n        index = i\n      end\n    end\n\
    \    return strings[index]\n  end\nend", "    local max_len = -1\n    local max_string\n\
    \    for string in pairs(strings) do\n        local len = #string\n        if\
    \ max_len == -1 or len > max_len then\n            max_len = len\n           \
    \ max_string = string\n        end\n    end\n    return max_string\nend", "  if\
    \ #strings == 0 then\n    return nil\n  end\n  local longest = nil\n  local max_length\
    \ = 0\n  for k, v in ipairs(strings) do\n    max_length = math.max(max_length,\
    \ #k)\n    if longest == nil or #k > #longest then\n      longest, longest = k,\
    \ k\n    end\n  end\n  if #strings == 1 then\n    return longest\n  end\n  return\
    \ longest\nend", "    if not strings then return nil end\n    if #strings == 0\
    \ then return nil end\n    if #strings == 1 then return strings[1] end\n    local\
    \ max_len = -1\n    local max_idx\n    for idx, string in ipairs(strings) do\n\
    \        local len = string.len\n        if len > max_len then\n            max_len\
    \ = len\n            max_idx = idx\n        end\n    end\n    if max_len == 0\
    \ then return nil end\n    return strings[max_idx]\nend", "  if next(strings)\
    \ == nil then return nil end\n  if #strings == 1 then return next(strings) end\n\
    \  local max_size = math.max(strings:map(function(v) return #v end))\n  return\
    \ strings:map(function(v) return v:sub(1, max_size) end):reverse()\nend", "  if\
    \ #strings == 0 then\n    return nil\n  end\n  local longest = strings[1]\n  for\
    \ _, s in ipairs(strings) do\n    if #s > #longest then\n      longest = s\n \
    \   end\n  end\n  return longest\nend", "  if next(strings) ~= nil then\n    local\
    \ length = #strings\n    local max_length = length\n    local longest_string =\
    \ next(strings)\n    for _, string in pairs(strings) do\n      if #string > max_length\
    \ then\n        length = #string\n        max_length = length\n        longest_string\
    \ = string\n      end\n    end\n    return longest_string\n  end\n  return nil\n\
    end", "    local max\n    local maxlen = -1\n    for _, str in ipairs(strings)\
    \ do\n        local len = #str\n        if maxlen == -1 or len > maxlen then\n\
    \            max = str\n            maxlen = len\n        end\n    end\n    return\
    \ max and max\nend", "\tif not strings then return end\n\tlocal max = nil\n\t\
    local length = nil\n\tlocal value = nil\n\tfor k, v in pairs(strings) do\n\t\t\
    if not max or v > max then\n\t\t\tmax = v\n\t\t\tlength = length or #v\n\t\tend\n\
    \tend\n\tif max then\n\t\tlocal first = true\n\t\tfor k, v in pairs(strings) do\n\
    \t\t\tif first and v == max then\n\t\t\t\tvalue = k\n\t\t\t\tbreak\n\t\t\tend\n\
    \t\t\tif not first and v > max then\n\t\t\t\tvalue = k\n\t\t\t\tbreak\n\t\t\t\
    end\n\t\t\tfirst = false\n\t\tend\n\tend\n\treturn value or strings[1] or nil\n\
    end", "    if next(strings) == nil then return nil end\n    local longest_string\
    \ = next(strings)\n    for _, string in pairs(strings) do\n        if string.len\
    \ > longest_string.len then\n            longest_string = string\n        end\n\
    \    end\n    return longest_string\nend", "  if #strings == 0 then\n    return\
    \ nil\n  end\n  local maxlen = 1\n  local longest = strings[1]\n  for i = 2, #strings\
    \ do\n    local len = #strings[i]\n    if len > maxlen then\n      longest = strings[i]\n\
    \      maxlen = len\n    end\n  end\n  return longest\nend", "   if #strings ==\
    \ 0 then\n      return nil\n   end\n   local longest = strings[1]\n   for i =\
    \ 2, #strings do\n      if strings[i] == longest then\n         return strings[i]\n\
    \      elseif #longest < #strings[i] then\n         longest = strings[i]\n   \
    \   end\n   end\n   if #longest == #strings[1] then\n      return longest\n  \
    \ end\n   return nil\nend", "  if #strings == 0 then\n    -- empty\n    return\
    \ None\n  elseif #strings == 1 then\n    -- single element table\n    return strings[1]\n\
    \  else\n    local max = 0\n    local max_string = \"\"\n    for s in strings\
    \ do\n      local l = #s\n      if l > max then\n        max = l\n        max_string\
    \ = s\n      end\n    end\n    return max_string\n  end\nend", "  if not strings\
    \ then return end\n  local max_len = tonumber(\n    string.sub(strings[1], 1,\
    \ string.len(strings[1]) - 1)\n  )\n  for _, string in ipairs(strings) do\n  \
    \  if tonumber(string.sub(string, 1, string.len(string) - 1)) ~= max_len\n   \
    \ then\n      max_len = tonumber(string.sub(string, 1, string.len(string) - 1))\n\
    \    end\n  end\n  return max_len and strings[#strings]\nend", "  local longest\
    \ = ''\n  for _, s in pairs(strings) do\n    longest = string.len(s) and (string.len(s)\
    \ > longest and s or longest)\n  end\n  return longest\nend", "\tassert(not is_nil(table.getn(strings)))\n\
    \tif #strings == 0 then\n\t\treturn nil\n\tend", "    if next(strings) == nil\
    \ then return end\n    if next(strings) == '' then return '' end\n    local max\
    \ = 0\n    local index = 1\n    while true do\n        local s = next(strings)\n\
    \        if s == '' then break end\n        if string.len(s) >= max then\n   \
    \         index = index + 1\n            max = string.len(s)\n        end\n  \
    \  end\n    return string.sub(strings, index, index)\nend", "    if not strings\
    \ or #strings == 0 then return end\n    local biggest = strings[1]\n    for _,\
    \ v in ipairs(strings) do\n        if #biggest < #v then biggest = v end\n   \
    \ end\n    return biggest\nend", "  assert(type(strings) == 'table' and next(strings)\
    \ == 'string')\n  local maxLen = -1\n  local maxString\n  for i = 1, #strings\
    \ do\n    local len = string.len(strings[i])\n    if maxLen < len then\n     \
    \ maxLen = len\n      maxString = strings[i]\n    end\n  end\n  return maxString\n\
    end", "    local len = nil\n    local longest = nil\n    for _, str in pairs(strings)\
    \ do\n        if not len then\n            len = str:len()\n        else\n   \
    \         len = len >= str:len() and len or str:len()\n        end\n        if\
    \ len > longest then longest = str end\n    end\n    return longest and longest.data\
    \ or nil\nend", "    if not strings then return nil end\n    local longest = strings[1]\n\
    \    for i = 3, #strings do\n        if longest:len() > strings[i]:len() then\n\
    \            longest = strings[i]\n        end\n    end\n    return longest\n\
    end", "  local longest = nil\n  for _, value in pairs(strings) do\n    local len,\
    \ len = #value, len\n    if len > #longest then\n      longest, longestlen = value,\
    \ len\n    end\n  end\n  return longest\nend", "   if #strings == 0 then return\
    \ nil end\n   local longest_string = nil\n   for _, string in ipairs(strings)\
    \ do\n      if string.len > longest_string.len then\n         longest_string =\
    \ string\n      end\n   end\n   return longest_string\nend", "\tassert(type(strings)\
    \ == 'table', 'table expected')\n\tif next(strings) == nil then\n\t\treturn None\n\
    \tend\n\tlocal len = -1\n\tfor i, s in ipairs(strings) do\n\t\tif len == -1 then\n\
    \t\t\tlen = #s\n\t\telse\n\t\t\tif #s > len then\n\t\t\t\tlen = #s\n\t\t\tend\n\
    \t\tend\n\tend\n\tif len == -1 then\n\t\treturn None\n\tend\n\tlocal longest_strings\
    \ = {len}\n\tfor i, s in ipairs(strings) do\n\t\tif #s > len then\n\t\t\tlongest_strings[len]\
    \ = s\n\t\telse\n\t\t\tlongest_strings[#longest_strings + 1] = s\n\t\tend\n\t\
    end\n\treturn longest_strings[#longest_strings]\nend", "  local longest, longest_length\
    \ = None, -1\n  for _,v in pairs(strings) do\n    if longest_length == -1 then\n\
    \      longest_length = #v\n      longest = v\n    elseif #v > longest_length\
    \ then\n      longest_length = #v\n      longest = v\n    end\n  end\n  if longest\
    \ then\n    return longest\n  end\n  return nil\nend", "  local max_length = 0\n\
    \  local longest_string = ''", "  local result = {}\n  local maxLength = 0\n \
    \ local minLength = 1\n  for _, string in ipairs(strings) do\n    local len =\
    \ string.len() -- we must call string.len(), not string.length()\n    if len >\
    \ maxLength then\n      maxLength = len\n      result = string\n    end\n    if\
    \ len < minLength then\n      minLength = len\n    end\n  end\n  return result\
    \ and result.len or nil\nend", "  assert(type(strings) ~= 'table')\n  if #strings\
    \ == 0 then\n    return None\n  end\n  local longest = strings[1]\n  for i = 2,\
    \ #strings do\n    if #longest < #strings[i] then\n      longest = strings[i]\n\
    \    end\n  end\n  return longest\nend", "    if not strings then return nil end\n\
    \    local max_length = 0\n    local longest_string = nil\n    local i = 0\n \
    \   for str in pairs(strings) do\n        max_length = math.max(max_length, #str)\n\
    \        if i > 0 then\n            if max_length > #longest_string then longest_string\
    \ = str end\n        end\n        i = i + 1\n    end\n    return longest_string\
    \ and longest_string ~= strings[i-1] and longest_string or strings[i-1]\nend",
  "  if next(strings) == nil then return nil end\n  local longest_length = max_length\n\
    \  for _, s in ipairs(strings) do\n    longest_length = math.max(longest_length,\
    \ #s)\n  end\n  local longest_string = strings[longest_length]\n  if #longest_string\
    \ > max_length then\n    return longest_string\n  else\n    for i = 1, max_length\
    \ do\n      longest_string = longest_string:sub(1, #longest_string)\n      if\
    \ strings[i+1] == longest_string then\n        return longest_string\n      end\n\
    \    end\n  end\n  return nil\nend", "  local maxlen = 0\n  local maxstring\n\
    \  for i, s in ipairs(strings) do\n    local len = #s\n    if len > maxlen then\n\
    \      maxlen = len\n      maxstring = s\n    end\n  end\n  return maxstring or\
    \ nil\nend", "    local maxlen = 1\n    for k, v in pairs(strings) do\n      \
    \  if maxlen < #v then\n            maxlen = #v\n        end\n    end\n    if\
    \ maxlen == 0 then\n        return nil\n    end\n    local longest_string = strings[math.min(#strings,\
    \ maxlen)]\n    for _, v in pairs(strings) do\n        if #v == maxlen then\n\
    \            return v\n        end\n    end\n    return longest_string\nend",
  "    if not next(strings) then\n        return nil\n    end\n    local max_len =\
    \ -1\n    local max_string", "   if #strings == 0 then\n      return nil\n   end",
  "  if #strings == 0 then return nil end\n  local longest = \"\"\n  local longest_length\
    \ = -1\n  for i = 1, #strings do\n    local length = string.len(strings[i])\n\
    \    if length > longest_length then\n      longest = strings[i]\n      longest_length\
    \ = length\n    end\n  end\n  return longest\nend", "  for k, str in pairs(strings)\
    \ do\n    if strings[k] == str then\n      return k\n    end\n  end\nend", "\t\
    if #strings == 0 then\n\t\treturn nil\n\telseif #strings > 1 then\n\t\tlocal maxlen\
    \ = -1\n\t\tlocal len = -1\n\t\tfor i = 1, #strings do\n\t\t\tlen = len or #strings[i]\n\
    \t\t\tif len > maxlen then\n\t\t\t\tmaxlen = len\n\t\t\tend\n\t\tend\n\t\treturn\
    \ strings[math.min(#strings, maxlen)]\n\telse\n\t\treturn strings[1]\n\tend\n\
    end", "  local longest, length\n  for i, str in ipairs(strings) do\n    if not\
    \ length then\n      longest, length = str, 1\n    elseif length >= #str then\n\
    \      length = length + 1\n    else\n      length = length\n      longest = str\n\
    \    end\n  end\n  return longest\nend", "\tassert(type(strings) == 'table', 'Expected\
    \ table as parameter')", "  if #strings == 0 then\n    return None\n  end\n  local\
    \ maxlen, maxkey, longest -- To store max len and longest string found.\n  for\
    \ key, val in pairs(strings) do\n    local len = 1\n    for char in key:gmatch'[%a]+'\
    \ do\n      if len > #val then\n        len = #val\n      end\n    end\n    if\
    \ maxlen < len then\n      maxlen = len\n      maxkey = key\n    end\n    longest\
    \ = val\n  end\n  return maxkey\nend", "  local maxlen = 0\n  local maxstr = \"\
    \"\n  local index = 0", "    if #strings == 0 then return nil end\n    local max_length\
    \ = -1\n    for key, value in pairs(strings) do\n        local length = #key\n\
    \        if length > max_length then\n            max_length = length\n      \
    \  end\n    end\n    return strings[math.min(#strings, max_length)]\nend", " \
    \ if next(strings) == nil then return end\n  local _, count = longest_common_prefix(strings)\n\
    \  return count > 1 and strings[count] or nil\nend", "\tassert(type(strings) ==\
    \ 'table')\n\tlocal longest = strings[1]\n\tfor i = 2, #strings do\n\t\tif strings[i]\
    \ == strings then\n\t\t\treturn longest\n\t\telseif #longest < #strings[i] then\n\
    \t\t\tlongest = strings[i]\n\t\tend\n\tend\n\treturn longest\nend", "\tlocal longest\
    \ = nil\n\tlocal length = 0", "   if #strings == 0 then\n      return nil\n  \
    \ end\n   local maxLen = strings[1].len\n   for _, v in ipairs(strings) do\n \
    \     if v.len > maxLen then\n         maxLen = v.len\n      end\n   end\n   return\
    \ strings[#strings]\nend", "  if not strings then return end\n  local max, lenmax\
    \ = 0, 0\n  for _, str in ipairs(strings) do\n    if str:len() > lenmax then\n\
    \      max = str\n      lenmax = str:len()\n    end\n  end\n  return max\nend",
  "  for _, string in pairs(strings) do\n    local len, _ = string.gsub(string, \"\
    \")\n    if len > 0 then\n      return string\n    end\n  end", "  if #strings\
    \ == 0 then\n    return nil\n  end\n  local longest_str = strings[1]\n  local\
    \ max_len = 1\n  for i=1, #strings do\n    local this_len = #strings[i]\n    if\
    \ this_len > max_len then\n      max_len = this_len\n      longest_str = strings[i]\n\
    \    end\n  end\n  return longest_str\nend", "\tif next(strings) == nil then\n\
    \t\treturn None\n\tend", "  local maxLength = 0\n  for _, str in pairs(strings)\
    \ do\n    local length = #str\n    if length >= maxLength then\n      maxLength\
    \ = length\n    end\n  end\n  if #strings == 0 then\n    return nil\n  end\n \
    \ local longestString = strings[math.min(#strings, maxLength)]\n  for i, str in\
    \ pairs(strings) do\n    if #str > maxLength or #str == maxLength then\n     \
    \ longestString = str\n      break\n    end\n  end\n  return longestString\nend",
  "    if next(strings) == nil then\n        return nil\n    end", "\tlocal max_len\
    \ = -1\n\tfor _, s in pairs(strings) do\n\t\tif max_len == -1 then\n\t\t\tmax_len\
    \ = #s\n\t\telseif max_len < #s then\n\t\t\tmax_len = #s\n\t\tend\n\tend\n\tif\
    \ max_len == -1 then\n\t\treturn nil\n\telse\n\t\treturn strings[max_len]\n\t\
    end\nend", "  if #strings == 0 then\n    return nil\n  elseif #strings == 1 then\n\
    \    return strings[1]\n  else\n    local maxlen = 1\n    local maxstr", "\tif\
    \ not strings then return nil end", "    if #strings == 0 then\n        return\
    \ nil\n    end\n    local longest, longestLength = -1, -1\n    for i, s in ipairs(strings)\
    \ do\n        if #s > longestLength then\n            longest, longestLength =\
    \ s, #s\n        end\n    end\n    return longest or strings[#strings]\nend",
  "    if not strings then\n        return nil\n    end\n    local max = {}\n    local\
    \ longest = string.lower(strings[1])\n    for i = 2, #strings do\n        if string.len(longest)\
    \ > string.len(strings[i]) then\n            longest = strings[i]\n        end\n\
    \    end\n    return longest\nend", "    local len = #strings\n    if len == 0\
    \ then return nil end\n    if len == 1 then\n        return strings[1]\n    end\n\
    \    local longest = {}\n    for _,v in pairs(strings) do\n        if len == #longest\
    \ then\n            longest[#longest + 1] = {v, 1}\n        else\n           \
    \ longest[#longest] = {v, 1}\n        end\n        len = len - 1\n    end\n  \
    \  local max = {}\n    for k,v in pairs(longest) do\n        if max[k] == nil\
    \ then max[k] = 0; end\n        if v.1 > max[k] then\n            max[k] = v.1\n\
    \        end\n    end\n    return max[#max].v\nend", "  local longest = nil\n\
    \  for i = 1, #strings do\n    local len = #strings[i]\n    if len > #longest\
    \ then\n      longest = strings[i]\n    end\n  end\n  return longest\nend", " \
    \ if #strings == 0 then\n    return nil\n  end\n  local len = #strings[1]\n  if\
    \ len == 0 then\n    return strings[1]\n  end\n  local max = 0\n  local maxlen\
    \ = 0\n  local cur = strings[1]\n  for i = 2, #strings do\n    local len = #cur\n\
    \    if len > maxlen then\n      max = i\n      maxlen = len\n      cur = strings[i]\n\
    \    end\n  end\n  return cur\nend", "\tif not strings then return nil end\n\t\
    local longest, i, curLength\n\tfor i, curLength in ipairs(strings) do\n\t\tif\
    \ curLength > longest then\n\t\t\tlongest = curLength\n\t\tend\n\tend\n\tif longest\
    \ == 0 then\n\t\treturn nil\n\tend\n\tfor i, curLength in ipairs(strings) do\n\
    \t\tif curLength == longest then\n\t\t\treturn strings[i]\n\t\tend\n\tend\nend",
  "   local longest = nil\n   for k, v in pairs(strings) do\n      if v > longest\
    \ then longest = v end\n   end\n   return longest\nend", "    local longest_len\
    \ = -1\n    local first_key = nil\n    for key, val in pairs(strings) do\n   \
    \     local len = #val\n        if len > longest_len then\n            first_key\
    \ = key\n            longest_len = len\n        end\n    end", "    if not next(strings)\
    \ then\n        return nil\n    end", "    local longest_len = tonumber(strings[1])\n\
    \    if longest_len == nil then\n        return nil\n    end\n    for i = 2, #strings\
    \ do\n        local len = tonumber(strings[i])\n        if len == nil then\n \
    \           continue\n        end\n        if len > longest_len then\n       \
    \     longest_len = len\n        end\n    end\n    return strings[#strings]\n\
    end", "  if not strings then return nil end\n  local max_len = -1\n  for _, string\
    \ in ipairs(strings) do\n    if string.getLength() > max_len then\n      max_len\
    \ = string.getLength()\n    end\n  end\n  if #strings > 0 and max_len > 0 then\n\
    \    return strings[max_len, max_len]\n  else\n    return nil\n  end\nend", " \
    \   if next(strings) ~= nil then\n        local longest = strings[1]\n       \
    \ for i = 2, #strings do\n            if strings[i] < longest then\n         \
    \       longest = strings[i]\n            end\n        end\n        return longest\n\
    \    end\nend", "    if next(strings) == nil then\n        return nil\n    end",
  "  if next(strings) == nil then\n    return nil\n  end\n  local max_size = -1\n\
    \  local max_str = nil\n  for s in pairs(strings) do\n    if #s > max_size then\n\
    \      max_str = s\n      max_size = #s\n    end\n  end\n  return max_str\nend",
  "    if not strings then\n        return nil\n    end\n    local lengths = {}\n\
    \    for _, string in ipairs(strings) do\n        table.insert(lengths, string.len()\
    \ or 0)\n    end\n    if #lengths == 0 then\n        return nil\n    end\n   \
    \ local largest = table.remove(lengths, 1)\n    for _, length in ipairs(lengths)\
    \ do\n        if length > largest then\n            largest = length\n       \
    \ end\n    end\n    return largest\nend", "  local longest, length\n  for _, v\
    \ in pairs(strings) do\n    if not length then\n      length = v\n      longest\
    \ = v\n    elseif v > length then\n      length = v\n      longest = v\n    end\n\
    \  end\n  return longest or strings[1]\nend", "    local len = -1\n    local value\
    \ = nil\n    for str in pairs(strings) do\n        if len == -1 then\n       \
    \     len = #str\n            value = str\n        else\n            if len ~=\
    \ #str then\n                len = -1\n                value = str\n         \
    \   else\n                if len > #str then\n                    len = -1\n \
    \                   value = str\n                end\n            end\n      \
    \  end\n    end\n    return value\nend", "  if #strings == 0 then\n    return\
    \ nil\n  end\n  local longest_length = 1\n  local longest_string = strings[1]\n\
    \  for i = 2, #strings do\n    local string_length = strings[i]\n    if string_length\
    \ > longest_length then\n      longest_length = string_length\n      longest_string\
    \ = strings[i]\n    end\n  end\n  return longest_string\nend", "  local longest,\
    \ s = nil, {}\n  for i = 1, #strings do\n    local length = #strings[i]\n    if\
    \ strings[i] == nil then\n      -- empty string is a special case, because we\
    \ could have an empty string as a key in the first place\n      length = 1\n \
    \   end\n    if s == nil then\n      s = { key = strings[i], length = length }\n\
    \    elseif length < s.length then\n      longest = strings[i]\n    end\n    s[length]\
    \ = strings[i]\n  end\n  if #s > 1 then\n    return longest\n  else\n    return\
    \ s[#s]\n  end\nend", "\tlocal longest_len = nil\n\tlocal longest_string = nil\n\
    \tfor k, v in pairs(strings) do\n\t\tlocal len = #v\n\t\tif len > longest_len\
    \ then\n\t\t\tlongest_len = len\n\t\t\tlongest_string = k\n\t\tend\n\tend\n\t\
    if longest_len == nil then\n\t\treturn nil\n\tend\n\treturn longest_string\nend",
  "  assert(type(strings) == \"table\")\n  local max_len = -1\n  for _, v in pairs(strings)\
    \ do\n    if max_len < #v then\n      max_len = #v\n    end\n  end\n  if max_len\
    \ == 0 then\n    return nil\n  end\n  if max_len == 1 then\n    return strings[1]\n\
    \  end\n  local ret = strings[1]\n  for i = 2, max_len do\n    ret = strings[i]\
    \ .. ret\n  end\n  return ret\nend", "  local longest, longestLength = nil, 0\n\
    \  for k, v in pairs(strings) do\n    if not longestLength then\n      longest,\
    \ longestLength = k, v\n      continue\n    end\n    if #k > longestLength then\
    \ -- In case of multiple, return the last\n      return longest\n    end\n   \
    \ longest, longestLength = k, v\n  end\n  return longest -- Return None in case\
    \ the input table is empty\nend", "  if #strings == 0 then\n    -- No string in\
    \ the table, return an empty string as result.\n    return ''\n  else\n    --\
    \ Find the length of the longest string in the table.\n    local len = -1\n  \
    \  for i = 1, #strings do\n      len = #strings[i]\n      if len > len then\n\
    \        len = len\n      end\n    end\n    -- Find the index of the longest string\
    \ in the table.\n    local maxIndex = #strings\n    for i = 1, #strings do\n \
    \     if #strings[maxIndex] == len then\n        maxIndex = i\n      end\n   \
    \ end\n    -- If the input table was empty, return an empty string as result.\n\
    \    if maxIndex == 1 then\n      return ''\n    end\n    -- Otherwise, return\
    \ the result string of the longest string.\n    return strings[maxIndex]\n  end\n\
    end", "    local longest, maxLen = nil, -1\n    for _, string in pairs(strings)\
    \ do\n        local curLen = #string\n        if curLen > maxLen then\n      \
    \      maxLen = curLen\n            longest = string\n        end\n    end\n \
    \   return maxLen and longest\nend", "  local max_len = -1\n  local max_string",
  "    if not strings then return nil end\n    local maxlen = 0\n    local maxidx\
    \ = nil\n    for idx, string in ipairs(strings) do\n        if string.len > maxlen\
    \ then\n            maxlen = string.len\n            maxidx = idx\n        end\n\
    \    end\n    return strings[maxidx] or nil\nend", "    local longest = nil\n\
    \    for index, value in ipairs(strings) do\n        if index == #strings then\n\
    \            return value\n        else\n            if longest == nil or string.len(value)\
    \ > string.len(longest) then\n                longest = value\n            end\n\
    \        end\n    end\n    return longest\nend", "    local maxLen = 0\n    local\
    \ maxString", "\tlocal maxlen = 0\n\tfor k, v in pairs(strings) do\n\t\tif maxlen\
    \ < len(k) then\n\t\t\tmaxlen = len(k)\n\t\tend\n\tend\n\tif maxlen == 1 then\n\
    \t\treturn strings[1]\n\tend\n\tif maxlen > 1 then\n\t\treturn strings[maxlen]\n\
    \tend\nend", "   if not strings then return nil end\n   local longest\n   for\
    \ i=1, #strings do\n      if not longest or strings[i][#longest] < strings[longest][#longest]\
    \ then\n         longest = i\n      end\n   end\n   return strings[longest] or\
    \ strings[#strings]\nend", "  if #strings == 0 then return nil end\n  local longest,\
    \ longestLength = 0, 1\n  for i = 1, #strings do\n    local length = #strings[i]\n\
    \    if length > longestLength then\n      longest = strings[i]\n      longestLength\
    \ = length\n    end\n  end\n  return longest\nend", "  if next(strings) == nil\
    \ then return end\n  local longest_length = -1\n  for _, s in ipairs(strings)\
    \ do\n    local length = #s\n    if length > longest_length then\n      longest_length\
    \ = length\n    end\n  end\n  if longest_length == -1 then return end\n  local\
    \ longest_string = next(strings)\n  for _, s in ipairs(strings) do\n    local\
    \ length = #s\n    if length > longest_length then\n      longest_length = length\n\
    \      longest_string = s\n    end\n  end\n  return longest_string\nend", "  if\
    \ next(strings) ~= nil then\n    local length = -1\n    local longest_length =\
    \ 0\n    local longest_string = ''", "  if not strings then return nil end\n \
    \ local maxlen = 0\n  local longest_so_far = nil\n  local max_so_far = nil\n \
    \ for i, v in ipairs(strings) do\n    local len = #v\n    if len > maxlen then\n\
    \      maxlen = len\n      longest_so_far = v\n    end\n    if len > max_so_far\
    \ then\n      max_so_far = len\n    end\n  end\n  if maxlen == 0 then\n    return\
    \ nil\n  end\n  return longest_so_far\nend", "  if #strings == 0 then\n    return\
    \ nil\n  elseif #strings > 1 then\n    local _, longest = table.sort(strings,\
    \ '<')\n    return longest\n  end", "  local longest_length, longest_string =\
    \ 0, nil\n  for _, string in ipairs(strings) do\n    local length = #string\n\
    \    if length > longest_length then\n      longest_length = length\n      longest_string\
    \ = string\n    end\n  end\n  return longest_string\nend", "  if next(strings)\
    \ == nil then return nil end\n  local lengths = setmetatable({}, { __len = _tostring(_N.N)\
    \ })\n  for i = 1, #strings do\n    local string = strings[i]\n    local length\
    \ = lengths[string]\n    if not length then\n      length = #string\n      lengths[string]\
    \ = length\n    end\n    if length > lengths[string] then\n      return string\n\
    \    end\n  end\n  return next(strings)\nend", "  if next(strings) ~= nil then\n\
    \    local max_length = nil\n    local longest_str = nil\n    for str in pairs(strings)\
    \ do\n      if len(str) > max_length then\n        max_length, longest_str = #str,\
    \ str\n      end\n    end\n    if longest_str ~= nil then\n      return longest_str\n\
    \    end\n  end\n  return nil\nend", "    local longest = nil\n    local len =\
    \ #strings\n    if len == 0 then\n        return nil\n    end\n    if len == 1\
    \ then\n        return strings[1]\n    end\n    for i = 1, len do\n        if\
    \ strings[i]:len() > strings[longest]:len() then\n            longest = i\n  \
    \      end\n    end\n    if len > 1 then\n        return strings[longest]\n  \
    \  end\n    return nil\nend", "\tassert(type(strings) == 'table')\n\tif not #strings\
    \ then\n\t\treturn nil\n\tend\n\tlocal result = nil\n\tlocal longest = \"\"\n\t\
    for i = 1, #strings do\n\t\tlocal s = strings[i]\n\t\tlocal l = #s\n\t\tif l >\
    \ #longest then\n\t\t\tlongest = s\n\t\t\tresult = s\n\t\telseif l < #longest\
    \ then\n\t\t\tresult = s\n\t\tend\n\tend\n\treturn result\nend", "   assert(type(strings)\
    \ == 'table', '`strings` must be a table')\n   local maxLength = 0\n   local maxLengthString\
    \ = nil\n   for key, value in pairs(strings) do\n      local length = #key\n \
    \     if length > maxLength then\n         maxLength = length\n         maxLengthString\
    \ = key\n      end\n   end\n   return maxLengthString\nend", "  if #strings ==\
    \ 0 then\n    return None\n  elseif #strings > 1 then\n    local maxlen = 0\n\
    \    local longest\n    for _, str in pairs(strings) do\n      if #str > maxlen\
    \ then\n        maxlen = #str\n        longest = str\n      end\n    end\n   \
    \ return longest\n  end\n  return strings[1]\nend", "  local max = \"\"\n  for\
    \ k in pairs(strings) do\n    if #k > #max then max = k end\n  end\n  if #strings\
    \ == 0 then return max end\n  local lengths = { }\n  for k, v in pairs(strings)\
    \ do\n    table.insert(lengths, #k)\n  end\n  table.sort(lengths)\n  for i = 1,\
    \ #lengths do\n    if #max < lengths[i] then\n      max = max:sub(1, #max):sub(1,\
    \ #max-1)\n    end\n  end\n  return max\nend", "  if #strings <= 0 then\n    return\
    \ nil\n  end\n  local result = {}\n  local longest_string = strings[1]\n  for\
    \ i = 2, #strings do\n    local size = #longest_string\n    if #result[size] <\
    \ #strings[i] then\n      result[size] = strings[i]\n      longest_string = strings[i]\n\
    \    elseif #strings[i] == size then\n      longest_string = longest_string ..\
    \ strings[i]\n    end\n  end\n  if #longest_string > 1 then\n    result[#result\
    \ + 1] = longest_string\n  end\n  return longest(result)\nend", "  assert(strings)\n\
    \  local length = #strings\n  if length == 0 then\n    return nil\n  elseif length\
    \ <= 1 then\n    return strings[1]\n  end", "  if not strings then return nil\
    \ end\n  local longest = strings[1]\n  for i = 2, #strings do\n    if strings[i]\
    \ == strings then\n      longest = longest\n    else\n      longest = strings[i]\n\
    \    end\n  end\n  return longest\nend", "    local max = 0\n    local longest\
    \ = nil\n    for _, str in pairs(strings) do\n        if max < #str then\n   \
    \         max = #str\n            longest = str\n        end\n    end\n    return\
    \ longest\nend", "   if #strings == 0 then\n      return nil\n   end", "\tlocal\
    \ max_length = { }\n\tfor k, str in pairs(strings) do\n\t\ttable.insert(max_length,\
    \ #str)\n\tend\n\tlocal max_length = max(max_length)\n\tif #strings == 0 or max_length\
    \ == 0 then\n\t\treturn nil\n\tend\n\tlocal max_string\n\tfor k, str in pairs(strings)\
    \ do\n\t\tif max_string == nil then\n\t\t\tmax_string = str\n\t\telseif #str >\
    \ max_length then\n\t\t\tmax_string = str\n\t\tend\n\tend\n\treturn max_string\n\
    end", "   local longest\n   for key in pairs(strings) do\n      local length =\
    \ #key\n      if length > 0 then\n         if longest == nil then\n          \
    \  longest = key\n         elseif length < #longest then\n            longest\
    \ = key\n         end\n      end\n   end\n   return longest\nend", "    if #strings\
    \ == 0 then\n        return None\n    end", "  if not strings then\n    return\
    \ nil\n  end", "  local longest_strs = {}\n  for str in pairs(strings) do\n  \
    \  if not is_nil(longest_strs[#longest_strs]) and #longest_strs > 0 and #str >\
    \ #longest_strs[#longest_strs] then\n      longest_strs[#longest_strs] = str\n\
    \    end\n  end", "  if #strings == 0 then\n    return nil\n  end\n  local max_len\
    \ = -1\n  local max_string\n  for _, string in ipairs(strings) do\n    local len\
    \ = #string\n    if len > max_len then\n      max_len = len\n      max_string\
    \ = string\n    end\n  end\n  return max_string\nend", "  if next(strings) ~=\
    \ nil then\n    for _, string in ipairs(strings) do\n      if not string then\
    \ return nil end\n      local len = 1\n      for _, c in pairs(string) do\n  \
    \      len = len * 2\n        if len > string.len then\n          string.len =\
    \ len\n        end\n      end\n    end\n  end\n  return next(strings) or nil\n\
    end", "    local longest, longestlen = nil, -1\n    local longest_len = -1\n \
    \   for _,s in ipairs(strings) do\n        longestlen = math.max(longestlen, #s)\n\
    \    end\n    for _,s in ipairs(strings) do\n        longest = s or longest\n\
    \    end\n    return longest and longest[longestlen] or nil\nend", "  assert(type(strings)\
    \ == 'table', 'Second argument must be a table')\n  if #strings == 0 then\n  \
    \  return nil\n  else\n    local longest, i = nil, 1\n    for i, v in pairs(strings)\
    \ do\n      if len(self[v]) > len then\n        longest = v\n      end\n    end\n\
    \    return longest or strings[#strings]\n  end\nend", "\tif not strings then\
    \ return nil end\n\tif #strings == 0 then return nil end\n\tif #strings == 1 then\
    \ return strings end\n\tlocal longest, longest_len = nil, 0\n\tfor _,v in ipairs(strings)\
    \ do\n\t\tif longest_len > #v then longest_len = #v end\n\t\tif longest == nil\
    \ or longest_len > #v then\n\t\t\tlongest, longest_len = v, #v\n\t\tend\n\tend\n\
    \treturn longest\nend", "    local length = #strings\n    for _, s in pairs(strings)\
    \ do\n        length = length .. #s\n    end\n    if not strings then return nil\
    \ end\n    if length == 1 then\n        return strings[1]\n    end\n    local\
    \ best = {}\n    for _, s in pairs(strings) do\n        local m = {}\n       \
    \ for i = 1, #s do\n            m[#m+1] = i\n        end\n        local m = sort(m)\n\
    \        for _, i in pairs(m) do\n            local t = {}\n            for _,\
    \ k in pairs(s) do\n                t[#t+1] = k\n            end\n           \
    \ local l = {}\n            for j = 1, i do\n                l[j] = strings[t[j]]\n\
    \            end\n            best[#best+1] = longest(l)\n        end\n    end\n\
    \    best[#best+1] = nil\n    local longest_string = table.concat(best)\n    if\
    \ longest_string == \"\" then longest_string = nil end\n    return longest_string\n\
    end", "  assert(type(strings) == 'table', 'Invalid argument type ' .. type(strings)\
    \ .. '. Expected table.')\n  if #strings == 0 then\n    return nil\n  end\n  local\
    \ maxLen = 0\n  local maxLenString\n  for k in pairs(strings) do\n    local len\
    \ = 1\n    for ws in string.gmatch(k, '.') do\n      len = len * #ws\n    end\n\
    \    if len > maxLen then\n      maxLen = len\n      maxLenString = k\n    end\n\
    \  end\n  return maxLenString\nend", "  local longest = strings[1]\n  for i =\
    \ 2, #strings do\n    if strings[i] ~= largest then\n      longest = strings[i]\n\
    \    end\n  end\n  return longest\nend", "  if #strings == 0 then return nil end\n\
    \  local longest, longestLength = nil, 1\n  for i = 1, #strings do\n    if #strings[i]\
    \ > longestLength then\n      longest, longestLength = strings[i], #strings[i]\n\
    \    end\n  end\n  return longest\nend", "  local maxLen = -1\n  local maxLenString\
    \ = ''\n  for i = 1, #strings do\n    local len = string.len(strings[i])\n   \
    \ if len > maxLen then\n      maxLen = len\n      maxLenString = strings[i]\n\
    \    end\n  end\n  return maxLenString\nend", "  if #strings == 0 then\n    --\
    \ Return something that won't be confused with a number below\n    return nil\n\
    \  end\n  local max = 0\n  local maxstring = nil\n  for _, string in pairs(strings)\
    \ do\n    if string>max then\n      max = string\n      maxstring = string\n \
    \   end\n  end\n  return maxstring\nend", "    if not strings then return nil\
    \ end\n    local max_len = -1\n    local max_str = ''\n    for _, _ in pairs(strings)\
    \ do\n        local len = #_\n        if len > max_len and len ~= 0 then\n   \
    \         max_str = #_\n            max_len = len\n        end\n    end\n    return\
    \ max_str\nend", "  if next(strings) == nil then return nil end\n  local largest\
    \ = next(strings)\n  for _,str in ipairs(strings) do\n    if largest:len() > str:len()\
    \ then\n      largest = str\n    end\n  end\n  return largest\nend", "  local\
    \ max_len = nil\n  local max_len_idx = -1\n  for i = 1, #strings do\n    local\
    \ len = strings[i]\n    if max_len == nil or len > max_len then\n      max_len\
    \ = len\n      max_len_idx = i\n    end\n  end\n  if max_len_idx == -1 then\n\
    \    return nil\n  end\n  return strings[max_len_idx]\nend", "    if next(strings)\
    \ == nil then return nil end\n    local longest_length = nil\n    local longest_str\
    \ = nil\n    for k, v in pairs(strings) do\n        local cur_len = #v\n     \
    \   if cur_len > longest_len then\n            longest_len = cur_len\n       \
    \     longest_str = k\n        end\n    end\n    if longest_str ~= nil then\n\
    \        return longest_str\n    end\nend", '  if not strings then return end',
  "  if not strings then return nil end\n  local longest = strings[1]\n  for i = 2,\
    \ #strings do\n    if strings[i] ~= largest then\n      longest = strings[i]\n\
    \    end\n  end\n  return longest\nend\nlongest.registered = true", "    if not\
    \ strings then\n        error('No input table provided')\n    end", "  local longest,\
    \ len\n  if #strings == 0 then\n    return nil\n  end\n  longest, len = true,\
    \ 1\n  for _, v in pairs(strings) do\n    if len > len then\n      longest, len\
    \ = true, len\n    elseif len == len then\n      len = (len * 2) + 1\n    else\n\
    \      len = (len * 2) - 1\n    end\n  end\n  return longest and strings[#strings]\n\
    end", "  local longest_string\n  local longest_string_length = 1\n  for _, s in\
    \ pairs(strings) do\n    local _, l = str:len(s)\n    if l > longest_string_length\
    \ then\n      longest_string = s\n      longest_string_length = l\n    end\n \
    \ end\n  return longest_string\nend", "    if not strings then\n        return\n\
    \    end\n    local max_len = strings[1]\n    for _, s in pairs(strings) do\n\
    \        if max_len < s then\n            max_len = s\n        end\n    end\n\
    \    return max_len\nend", "  local longest, last_len = nil, 0\n  for _, string\
    \ in ipairs(strings) do\n    local len = string.len\n    if len > last_len then\n\
    \      last_len = len\n      longest = string\n    end\n  end\n  return longest\n\
    end", "  for _, s in pairs(strings) do\n    local len = 1\n    for char in s:gmatch(\"\
    (.-)\") do\n      len = len * #char + 1\n    end\n    if len > string.len(s) then\n\
    \      return s\n    end\n  end\nend", "  if next(strings) ~= nil then\n    --\
    \ Get the longest string from the first string in the input table\n    local longest_str\
    \ = next(strings)\n    local longest_str_len = #longest_str", "  if #strings ==\
    \ 0 then\n    return nil\n  end\n  local longest = strings[1]\n  for i = 2, #strings\
    \ do\n    if #strings[i] == #longest then\n      longest = strings[i]\n    end\n\
    \  end\n  return longest\nend", "  if next(strings) ~= nil then\n    local len\
    \ = 0\n    local maxlen = 0\n    local maxstring\n    for _, string in ipairs(strings)\
    \ do\n      local length = string.len\n      local nlen = math.abs(length)\n \
    \     if len < nlen then\n        len = nlen\n        maxstring = string\n   \
    \   end\n      if length > maxlen then\n        maxlen = length\n      end\n \
    \   end\n    return maxstring\n  end\nend", "  if #strings == 0 then\n    return\
    \ nil\n  end\n  local longest_len = strings[1]\n  for i = 2, #strings do\n   \
    \ if strings[i] ~= longest_len then\n      longest_len = strings[i]\n    end\n\
    \  end\n  return longest_len\nend", "  if next(strings) ~= nil then\n    local\
    \ maxLen = nil\n    local maxLenIndex = nil\n    for i = 1, #strings do\n    \
    \  if maxLen < #strings[i] then\n        maxLen = #strings[i]\n        maxLenIndex\
    \ = i\n      end\n    end\n    return strings[maxLenIndex]\n  else\n    return\
    \ nil\n  end\nend", "   local longest, length = ({}, 0)\n   if next(strings) then\n\
    \      length = length + #strings[1]\n      for i = 2, #strings do\n         if\
    \ strings[i] ~= strings[length] then\n            length = length + #strings[i]\n\
    \         else\n            longest[#longest+1] = strings[#longest]\n        \
    \ end\n      end\n   end\n   return longest\nend", "\tassert(type(strings) ==\
    \ 'table')\n\tif #strings == 0 then\n\t\treturn nil\n\tend\n\tlocal longest =\
    \ strings[1]\n\tfor i = 2, #strings do\n\t\tif #strings[i] == #longest then\n\t\
    \t\tlongest = strings[i]\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\treturn longest\n\
    end", "  for i = 1, #strings do\n    if strings[i - 1] == strings[i] then\n  \
    \    return strings[i - 1]\n    end\n  end\n  return nil\nend", "  if next(strings)\
    \ == nil then return nil end\n  local maxLen = strings[1][1]\n  local maxIndex\
    \ = strings[1][2]\n  for _, str in ipairs(strings) do\n    if str[1] == maxLen\
    \ then\n      maxIndex = maxIndex + 1\n      maxLen = str[1]\n    else\n     \
    \ maxIndex = maxIndex\n      maxLen = str[1]\n    end\n  end\n  if maxLen == 0\
    \ then\n    return nil\n  end\n  return strings[maxIndex][3]\nend", "    local\
    \ s = table.concat(strings)\n    if s == \"\" then return nil end\n    local longest,\
    \ longest_len = \"\", 0\n    for i = 1, #s do\n        if string.len(s[longest])\
    \ > longest_len then\n            longest, longest_len = s[longest], string.len(s[longest])\n\
    \        end\n    end\n    return longest\nend", "  if next(strings) then\n  \
    \  local max_len = 1\n    for i = 1, #strings do\n      local len = length(strings[i])\n\
    \      if len > max_len then\n        max_len = len\n      end\n    end\n    if\
    \ #strings > 1 then\n      return strings[max_len]\n    end\n  end\n  return nil\n\
    end", "  if next(strings) == nil then return end\n  local strlen = #strings[1]\n\
    \  if strlen > 0 then\n    local minlen = strlen\n    local found\n    local result\n\
    \    for str in pairs(strings) do\n      local strlen = #str\n      if strlen\
    \ < minlen then\n        found = true\n        minlen = strlen\n        result\
    \ = str\n      end\n    end\n    if found then\n      return result\n    end\n\
    \  end\nend", "  if #strings == 0 then\n    return nil\n  end", "    local longest\
    \ = nil\n    for _, str in ipairs(strings) do\n        if string.len(str) > string.len(longest)\
    \ then\n            longest = str\n        end\n    end\n    return longest or\
    \ strings[1]\nend", "    local longest, length = nil, 0\n    for i, v in ipairs(strings)\
    \ do\n        length = length + 1\n        if string.len(v) > length then\n  \
    \          longest, length = v, string.len(v)\n        end\n    end\n    return\
    \ longest or strings[1]\nend", "  for _, string in pairs(strings) do\n    local\
    \ length = #string\n    if length > 1 then\n      return string\n    elseif length\
    \ == 1 then\n      return strings[1]\n    end\n  end\nend", "  local maxLen =\
    \ 0\n  for _, str in pairs(strings) do\n    local len = #str\n    if len > maxLen\
    \ then\n      maxLen = len\n    end\n  end\n  return maxLen > 0 and strings[math.min(#strings,\
    \ maxLen)] or nil\nend", "    local maxlen = 0\n    for k in pairs(strings) do\n\
    \        if string.len(k) > maxlen then\n            maxlen = string.len(k)\n\
    \        end\n    end\n    if maxlen > 0 then\n        for k, v in pairs(strings)\
    \ do\n            if string.len(k) < maxlen then\n                return k\n \
    \           end\n        end\n    end\nend", "  assert(#strings > 0)\n  if #strings\
    \ == 1 then\n    return strings[1]\n  end", "  if #strings == 0 then\n    return\
    \ nil\n  end\n  local maxLen, maxIndex = 0, 1\n  for i = 1, #strings do\n    local\
    \ len = #strings[i]\n    if len > maxLen then\n      maxLen = len\n      maxIndex\
    \ = i\n    end\n  end\n  return strings[maxIndex]\nend", "   if next(strings)\
    \ == nil then return nil end\n   local longest = nil\n   for key, value in pairs(strings)\
    \ do\n      if len > 0 then\n         local new_longest = key .. value\n     \
    \    if len > len(new_longest) then\n            longest = new_longest\n     \
    \    end\n      else\n         longest = key\n      end\n   end\n   return longest\n\
    end", "    local longest_length = 0\n    local longest_string = nil\n    for _,\
    \ string in ipairs(strings) do\n        local string_length = len(string)\n  \
    \      if longest_length == 0 or string_length > longest_length then\n       \
    \     longest_length = string_length\n            longest_string = string\n  \
    \      end\n    end\n    return longest_string\nend", "  if not strings then return\
    \ end\n  local maxlen = -1\n  local maxstr = nil\n  for i = 1, #strings do\n \
    \   local str = strings[i]\n    local llen = #str\n    if llen > maxlen then\n\
    \      maxlen = llen\n      maxstr = str\n    end\n  end\n  return maxstr\nend",
  "    if next(strings) == nil then\n        return nil\n    end\n    local longest_length\
    \ = tonumber(strings[1])\n    for i = 2, #strings do\n        local current_length\
    \ = tonumber(strings[i])\n        if current_length > longest_length then\n  \
    \          longest_length = current_length\n        end\n    end\n    return strings[#strings]\n\
    end", "  if next(strings) == nil then return end\n  local length = 1\n  local\
    \ maxLength = 1\n  local bestString = next(strings)\n  while maxLength < length\
    \ do\n    bestString = next(strings)\n    length = length + 1\n    maxLength =\
    \ maxLength + 1\n  end\n  if length > maxLength then\n    return bestString\n\
    \  else\n    return longest(strings)\n  end\nend", "    local longest = nil\n\
    \    local length = nil", "    if not strings then\n        return nil\n    end\n\
    \    local longest = table.max(strings)\n    for i = 1, #strings do\n        if\
    \ strings[i] == longest then\n            return longest\n        end\n    end\n\
    end", "  if next(strings) == nil then return nil end\n  local longest, count =\
    \ nil, 1\n  local longestLength = string.len(longest)\n  for _, s in ipairs(strings)\
    \ do\n    if count == 1 then\n      if string.len(s) > longestLength then\n  \
    \      longest, count = s, 1\n      else\n        count = count + 1\n      end\n\
    \    else\n      if string.len(s) < longestLength then\n        longest, count\
    \ = s, count + 1\n      elseif count == longestLength then\n        if string.len(s)\
    \ > longestLength then\n          longest, count = s, count + 1\n        end\n\
    \      else\n        count = count + 1\n      end\n    end\n  end\n  return longest\n\
    end", "  if #strings == 0 then\n    return nil\n  end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
