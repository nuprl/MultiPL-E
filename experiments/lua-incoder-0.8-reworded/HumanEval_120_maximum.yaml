name: HumanEval_120_maximum
language: lua
prompt: "-- Given a table arr of integers and a positive integer k, return a sorted\
  \ table \n-- of length k with the maximum k numbers in arr.\n-- Example 1:\n-- >>>\
  \ maximum({-3, -4, 5}, 3)\n-- {-4, -3, 5}\n-- Example 2:\n-- >>> maximum({4, -4,\
  \ 4}, 2)\n-- {4, 4}\n-- Example 3:\n-- >>> maximum({-3, 2, 1, 2, -1, -2, 1}, 1)\n\
  -- {2}\n-- Note:\n-- 1. The length of the table will be in the range of [1, 1000].\n\
  -- 2. The elements in the table will be in the range of [-1000, 1000].\n-- 3. 0\
  \ <= k <= len(arr)\nlocal function maximum(arr, k)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = maximum\n\
  \    lu.assertEquals(candidate({-3, -4, 5}, 3), {-4, -3, 5})\n    lu.assertEquals(candidate({4,\
  \ -4, 4}, 2), {4, 4})\n    lu.assertEquals(candidate({-3, 2, 1, 2, -1, -2, 1}, 1),\
  \ {2})\n    lu.assertEquals(candidate({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20,\
  \ 123})\n    lu.assertEquals(candidate({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20})\n\
  \    lu.assertEquals(candidate({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3,\
  \ 5, 15})\n    lu.assertEquals(candidate({-1, 0, 2, 5, 3, -10}, 2), {3, 5})\n  \
  \  lu.assertEquals(candidate({1, 0, 5, -7}, 1), {5})\n    lu.assertEquals(candidate({4,\
  \ -4}, 2), {-4, 4})\n    lu.assertEquals(candidate({-10, 10}, 2), {-10, 10})\n \
  \   lu.assertEquals(candidate({1, 2, 3, -23, 243, -400, 0}, 0), {})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local max_val, min_val = arr[1], arr[1]\n    for i = 2, k do\n\
    \        local val = min_val\n        for j = 1, i do\n            val = val >\
    \ arr[j] or val == arr[j] and arr[j] or val\n        end\n        max_val = val\n\
    \        min_val = max_val and max_val or arr[i]\n    end\n    return max_val\n\
    end", "  assert(k > 0 and k + 1 <= #arr, \"k should be larger than 0, and k should\
    \ be smaller than or equal to the length of arr.\")\n  local max = #arr\n  local\
    \ index = 1\n  while index < k do\n    if arr[index] > arr[index - 1] then\n \
    \     max = index\n    end\n    index = index + 1\n  end\n  return arr[max - 1,\
    \ ...]\nend", "  if k > #arr then return end\n  local max\n  if #arr > 1 then\n\
    \    local a = {}\n    local i = 1\n    while i <= #arr do\n      local v = arr[i]\n\
    \      if not max or v > max then max = v end\n      if i == k then break end\n\
    \      table.insert(a, v)\n      i = i + 1\n    end\n  end\n  return a\nend",
  "\tlocal table = {}\n\tlocal len = 0\n\tfor i, v in ipairs(arr) do\n\t\ttable.insert(table,\
    \ v)\n\t\tlen = len + 1 \n\t\tif len == k then\n\t\t\tbreak\n\t\tend\n\tend\n\t\
    table.sort(function(a, b) return a > b end)\n\treturn table\nend", "  if k ==\
    \ 0 then\n    return arr\n  else\n    local n = #arr\n    if k > n then\n    \
    \  return {}\n    end\n    local maxes = { [n - 1] = Infinity }\n    for i = 1,\
    \ k do\n      local current = -Infinity \n      for j = 1, n do\n        if arr[j]\
    \ <= current then\n          current = arr[j]\n        end\n      end\n      maxes[i]\
    \ = current\n    end\n    return maxes\n  end\nend", "\t-- Base case\n\tif k ==\
    \ 1 then\n\t\treturn {arr[1]}\n\tend", "  local t = {} -- the result table\n \
    \ local max = 0 -- the max element of arr\n  local i = 1\n  while i <= #arr and\
    \ max < arr[i] do\n    t[#t+1] = arr[i]\n    i = i + 1\n    max = max or arr[i]\n\
    \  end\n  \n  while k <= #t do\n    t[#t+1] = max\n    k = k + 1\n  end\n  \n\
    \  return t\nend", "  if k < 1 then\n    return nil\n  elseif k > #arr then\n\
    \    k = #arr\n  end\n  \n  local maxArr\n  local maxVal\n  \n  -- Create maxArr\
    \ and maxVal if not exist.\n  if not maxArr then\n    maxArr = Array()\n    maxVal\
    \ = nil\n  end\n  if not maxVal then\n    maxVal = arr[1]\n  end\n  \n  -- Append\
    \ the elements to the maxArr.\n  for i = 2, k do\n    if arr[i] > maxVal then\n\
    \      maxArr = Array()\n      maxVal = arr[i]\n    end\n    maxArr = maxArr +\
    \ arr[i]\n  end\n  \n  -- Return the result.\n  return maxArr\nend", "\tlocal\
    \ table = {}\n\tlocal n = #arr\n\tlocal kmax = k\n\tlocal m\n\t\n\tif k > n then\n\
    \t\tk = n\n\tend\n\t\n\tfor i = 1, n do\n\t\tm = i\n\t\tfor j = 1, k do\n\t\t\t\
    if arr[j] > arr[m] then\n\t\t\t\tm = j\n\t\t\tend\n\t\tend\n\t\ttable[i] = arr[m]\n\
    \tend\n\t\n\treturn table\nend", "    local m = math.max(k)\n    local max = {}\n\
    \    for i = 1, m do\n        local maxi = {}\n        for j = 1, k do\n     \
    \       if arr[j] > arr[i - 1] then\n                maxi[j] = arr[j]\n      \
    \      else\n                maxi[j] = arr[i - 1]\n            end\n        end\n\
    \        max = maxi + (max + maxi) * (m / k)\n    end\n    return max\nend", " \
    \ if k > #arr then return end\n  local arr = setmetatable(arr, arr)\n  local max_num\
    \ = math.max(0, arr[1])\n  arr[1] = nil\n  local i = 0\n  while i + 1 < k do\n\
    \    local cur_num = math.max(0, arr[i + 1])\n    if cur_num > max_num then\n\
    \      arr[i + 1] = nil\n      max_num = cur_num\n    else\n      arr[i + 1] =\
    \ nil\n    end\n    i = i + 1\n  end\n  return arr\nend", "    if k == 1 then\n\
    \        -- If the array is empty, return an empty table\n        if #arr == 0\
    \ then\n            return {}\n        end\n        \n        -- Return the given\
    \ array\n        return arr\n    end\n    \n    -- If the size of the given array\
    \ is less than k, return an empty table\n    if k < 1 then\n        return {}\n\
    \    end\n    \n    -- Create a table\n    local res = k - 1\n    for i = 1, k\
    \ do\n        res = {}\n        for j = 1, #arr do\n            if arr[j] > res[#res]\
    \ then\n                res[#res] = arr[j]\n            end\n        end\n   \
    \ end\n    \n    -- Return the table\n    return res\nend", "    local n = math.min(k,\
    \ #arr)\n    local m = {}\n    for i = 1, n do\n        table.insert(m, math.max(arr[i]))\n\
    \    end\n    return m\nend", "\tlocal n = #arr\n\tlocal m = math.max(math.ceil(math.log(n,\
    \ k)), 1)\n\tlocal s = math.ceil(n / m)\n\tlocal ans = {}\n\tfor i = 1, s do\n\
    \t\tlocal t = {}\n\t\tfor _, v in ipairs(arr) do\n\t\t\ttable.insert(t, v)\n\t\
    \tend\n\t\ttable.sort(t, function(a, b) return b - a end)\n\t\ttable.insert(ans,\
    \ table.unpack(t))\n\tend\n\treturn ans\nend", "  -- Write your code here.\n \
    \ local sorted_arr={}\n  if k > #arr then return arr end\n  if k == 1 then\n \
    \   table.insert(sorted_arr,arr[#arr])\n    return sorted_arr\n  else\n    local\
    \ count=0\n    for i=1,k-1 do\n      if arr[count] > arr[i] then\n        arr[i],\
    \ arr[count]=arr[count],arr[i]\n        count=count+1\n      end\n    end\n  \
    \  arr[k],arr[count]=arr[count],arr[k]\n    for i=count,#arr do\n      arr[i],\
    \ arr[count]=arr[count],arr[i]\n    end\n    table.insert(sorted_arr,arr[#arr])\n\
    \    return sorted_arr\n  end\nend", "  local tbl = {}\n  local i = 1\n  while\
    \ i <= k do\n    local max\n    local found = false\n    for _, v in pairs(arr)\
    \ do\n      if not found and v > max then\n        max = v\n        found = true\n\
    \      end\n    end\n    if not found then\n      table.insert(tbl, max)\n   \
    \ end\n    i = i + 1\n  end\n  return tbl\nend", "  if k > #arr then return arr\
    \ end\n  if k == 0 then return {} end\n  local arr2 = {}\n  local n = k\n  local\
    \ s = arr[1]\n  while n > 0 do\n    local m = math.floor(n / 2)\n    if arr[m]\
    \ < s then arr2 = arr2{arr[m], arr[m+1]} arr[m] = arr[m+1] end\n    if arr[m]\
    \ > s then arr2 = arr2{s, arr[m+1]} arr[m] = arr[m+1] end\n    s = arr[m]\n  \
    \  n = n - 1\n  end\n  return arr2\nend", "\tif k > #arr then return end\n\tlocal\
    \ ret = {}\n\tlocal i = 1\n\twhile i <= k do\n\t\tlocal temp = i\n\t\tlocal m\
    \ = i\n\t\twhile m <= k and arr[temp] < arr[m - 1] do\n\t\t\ttemp = temp + 1\n\
    \t\tend\n\t\tif arr[i - 1] > arr[temp] then\n\t\t\tfor j = i - 1; j >= m; j--\
    \ do\n\t\t\t\tret[j] = arr[j]\n\t\t\tend\n\t\tend\n\t\tif arr[temp] > arr[i -\
    \ 1] and m > 1 then\n\t\t\tlocal k = m\n\t\t\twhile arr[i - 1] > arr[m - 1] do\n\
    \t\t\t\ti = i + 1\n\t\t\t\tif i > k then\n\t\t\t\t\tfor j = i - 1; j >= k; j--\
    \ do\n\t\t\t\t\t\tret[j] = arr[j]\n\t\t\t\t\tend\n\t\t\t\t\tbreak\n\t\t\t\tend\n\
    \t\t\tend\n\t\tend\n\tend\n\treturn ret\nend", "  -- Base case\n  if k == 0 or\
    \ k == 1 then\n    return {arr}\n  end", "  if k == nil then return arr end\n\
    \  local table = setmetatable({}, {__mode=\"k\"})\n  for i = 1, k do\n    local\
    \ max_element = table.unpack(arr:select(i, #arr))\n    table.insert(table, max_element)\n\
    \  end\n  table.sort(table)\n  local result = {}\n  for i = 1, k do table.insert(result,\
    \ table.unpack(table[i])) end\n  return result\nend", "\tif k <= 0 then\n\t\t\
    return nil\n\tend\n\tlocal res = {}\n\tfor i = 1, k do\n\t\ttable.insert(res,\
    \ arr[i])\n\tend\n\treturn res\nend", "\tif k < 1 or k > #arr then\n\t\tassert(false,\
    \ \"k is out of range\")\n\tend", "  if k < 1 then return arr end\n  if k > #arr\
    \ then return arr end\n  local res = {}\n  for i = 1, k do\n    local v = arr[math.floor(i/k)\
    \ * k + i % k]\n    if v > res[#res] then\n      res[#res] = v\n    end\n  end\n\
    \  return res\nend", "    local result = {}\n    local i = 0\n    local length\
    \ = #arr\n    if k == 0 then\n        return result\n    end\n    while i < k\
    \ do\n        local value = arr[i]\n        if value > result[k] then\n      \
    \      result[k] = value\n        end\n        i = i + 1\n    end\n    result[k+1]\
    \ = arr[length]\n    return result\nend", "  if k < 1 or k > length(arr) then\
    \ return {} end\n  local result = {}\n  for i = 1, k do\n    result[#result+1]\
    \ = arr[i]\n  end\n  table.sort(result, function(x,y)\n    return x <=> y\n  end)\n\
    \  return result\nend", "    if k < 1 or k > #arr then return end\n    local max\
    \ = arr[1]\n    for i = 2, k do\n        if arr[i] > max then max = arr[i] end\n\
    \    end\n    return max\nend", "  local res = {}\n  local m = 0\n  for i = 1,\
    \ k do\n    local tmp = arr[m + 1]\n    for j = 1, #arr do\n      if arr[j] >\
    \ tmp then\n        tmp = arr[j]\n      end\n    end\n    table.insert(res, tmp)\n\
    \    m = m + 1\n  end\n  return res\nend", "   local sorted_arr = {}\n   local\
    \ current_max = -math.huge\n   for i = 1, k do\n      for index = 1, #arr do\n\
    \         if arr[index] > current_max then\n            current_max = arr[index]\n\
    \         end\n      end\n      table.insert(sorted_arr, current_max)\n   end\n\
    \   return sorted_arr\nend", "  assert(k > 0, 'k must greater than 0')\n  assert(k\
    \  < 1000, 'k must less than 1000')\n  assert(k <= #arr, 'k must be less than\
    \ the length of arr')\n  \n  local arr = arr\n  local arr_idx = 1 -- index of\
    \ the first element\n  local max_idx = 1 -- index of the first element larger\
    \ than arr[0]\n  \n  -- find the first largest element larger than arr[0]\n  while\
    \ arr_idx <= #arr do\n    if arr[arr_idx] >= arr[max_idx] then\n      arr_idx\
    \ = max_idx\n      max_idx = arr_idx + 1\n    end\n    arr_idx = arr_idx + 1\n\
    \  end\n  \n  -- find the first largest element smaller than arr[0]\n  while arr_idx\
    \ <= #arr do\n    if arr[arr_idx] < arr[max_idx] then\n      arr_idx = max_idx\n\
    \      max_idx = arr_idx + 1\n    end\n    arr_idx = arr_idx + 1\n  end\n  \n\
    \  -- now the largest elements are arr[0], arr[k-1]\n  local new_arr = {}\n  for\
    \ i = 1, k do\n    new_arr[i] = arr[arr_idx]\n    arr_idx = arr_idx + 1\n  end\n\
    \  return new_arr\nend", "  local n = #arr\n  assert(1 <= k <= n)", "  -- write\
    \ your code here\n  assert(k > 0 and k <= #arr)\n  local ans = {}\n  local max\
    \ = 0\n  for i = 1, k do\n    if i > max then\n      ans = arr\n      max = i\n\
    \      return\n    end\n    local t = {}\n    for j = 1, #arr do\n      if arr[j]\
    \ > arr[i] then\n        t.push(arr[j])\n      end\n    end\n    ans = table.concat(ans,\
    \ t, \"-\", i)\n  end\n  if max > #arr then ans = ans .. table.concat(arr, max)\
    \ end\n  return ans\nend", "  -- Write your code here.\n  assert(k > 0 and k ==\
    \ 1 or k == 0, \"k should larger than 0.\")\n  local maxes = {}\n  for i = 1,\
    \ k do\n    maxes[i] = -1000\n  end\n  for i = 1, #arr do\n    if maxes[arr[i]]\
    \ < arr[i] then\n      maxes[arr[i]] = arr[i]\n    end\n  end\n  return maxes\n\
    end", "\tlocal n = #arr\n\tlocal m = math.max(k, n)\n\tlocal ans = { }\n\tlocal\
    \ i = 1\n\twhile i <= m do\n\t\tlocal cur = i - 1\n\t\tlocal max = -1000\n\t\t\
    for j=1, n do\n\t\t\tif arr[j] <= arr[cur] then\n\t\t\t\tmax = arr[j]\n\t\t\t\t\
    break\n\t\t\tend\n\t\tend\n\t\tif max > -1000 then\n\t\t\ttable.insert(ans, max)\n\
    \t\tend\n\t\ti = i + 1\n\tend\n\treturn ans\nend", "    local arr2 = {}\n    local\
    \ n = #arr\n    local max_i = math.max(1, n-1)\n    local max_j = 1\n    while\
    \ max_j < n do\n        if arr[max_j] <= arr[max_i] then\n            arr2[max_j+1]\
    \ = arr2[max_j]\n            arr2[max_j] = arr[max_i]\n            max_i = max_i-1\n\
    \        else\n            arr2[max_j+1] = arr2[max_j]\n            arr2[max_j]\
    \ = arr[max_i]\n        end\n        max_j = max_j+1\n    end\n    return arr2\n\
    end", "  assert(k > 0 and k <= #arr, 'illegal input')\n  local ret = {}\n  local\
    \ n = #arr\n  for i = 1, k do\n    if i <= n then\n      ret[i] = arr[i - 1]\n\
    \    else\n      ret[i] = arr[n]\n      n = n - 1\n    end\n  end\n  return ret\n\
    end", "   if k > #arr then return end\n   local t = {}\n   if k == 1 then\n  \
    \    for i=1,#arr do\n         table.insert(t, arr[i])\n      end\n   else\n \
    \     for i=1,k do\n         local max = arr[1]\n         for j=i,#arr do\n  \
    \          if arr[j] > max then\n               max = arr[j]\n            end\n\
    \         end\n         table.insert(t, max)\n      end\n   end\n   return t\n\
    end", "    if k < 1 or k > #arr then return {} end\n    local table = {}\n   \
    \ table.__index = table\n    table.__count = #arr\n    table.__size = k\n    table._hash\
    \ = 0\n    table._next = {} -- dummy entry\n    table._prev = {} -- dummy entry\n\
    \    return table\nend", "  -- Time Complexity: O(k)\n  -- Space Complexity: O(1)\n\
    \  -- Use a hashmap to store the result\n  local res = { }\n  local hash_map =\
    \ {}\n  -- For each element in arr\n  for i = 1, k do\n    -- Check if this element\
    \ is already in the hashmap\n    if hash_map[arr[i]] == nil then\n      -- If\
    \ this element is not in the hashmap, then store this element in the hashmap\n\
    \      hash_map[arr[i]] = i\n      -- Add the element to the result\n      table.insert(res,\
    \ arr[i])\n    else\n      -- If this element is already in the hashmap, then\
    \ increment the current index\n      hash_map[arr[i]] = hash_map[arr[i]] + 1\n\
    \    end\n  end", "    local ans = arr\n    for i = #arr + k - 1, 0, -1 do\n \
    \       local val = ans[i]\n        if val ~= nil then\n            table.insert(ans,\
    \ val)\n        end\n    end\n    return ans\nend", "    local result = {}\n \
    \   local i, j = k, #arr\n    while i ~= 0 do\n        if j > 0 then\n       \
    \     if arr[i] > arr[j] then\n                local tmp = arr[i]\n          \
    \      arr[i] = arr[j]\n                arr[j] = tmp\n            end\n      \
    \  end\n        i = i - 1\n        j = j - 1\n    end\n    return result\nend",
  "\tassert(k > 0 and k <= #arr, 'Invalid k')\n\tlocal t = {}\n\tlocal m = math.max(k,\
    \ 1)\n\tfor i = 1, m do\n\t\tt[#t+1] = arr[i]\n\tend\n\tlocal j = 1\n\tfor i =\
    \ m + 2, #t do\n\t\tt[j] = t[i]\n\t\tj = j + 1\n\tend\n\treturn t\nend", "\tlocal\
    \ result = {}\n\tlocal index = 1\n\tlocal max = -math.inf\n\twhile index <= k\
    \ do\n\t\tlocal element = arr[index]\n\t\tif element > max then\n\t\t\tmax = element\n\
    \t\tend\n\t\tindex = index + 1\n\tend\n\tlocal i = k - 1\n\twhile i >= 1 do\n\t\
    \tlocal element = arr[i]\n\t\tif element > max then\n\t\t\tresult = result ..\
    \ element .. element\n\t\telse\n\t\t\tresult = result .. element\n\t\tend\n\t\t\
    i = i - 1\n\tend\n\treturn result\nend", "\tassert(k > 0, 'k should > 0!')\n\t\
    assert(k == 1 or k == 2, 'k should in [1, 2]!')\n\tassert(arr == nil or arr:size()\
    \ > 0, 'arr should be nil or not empty!')\n\tassert(arr:size(1) == 1 or arr:size(1)\
    \ == 2, 'arr should in [1, 2]!')\n\tlocal max_count = 0\n\tlocal max_element =\
    \ nil\n\tlocal max_index = nil\n\tlocal last_element = -1000\n\tfor i = 1, arr:size(1)\
    \ do\n\t\tlocal element = arr[i]\n\t\tlast_element = element\n\t\tif max_count\
    \ > 0 then\n\t\t\tif element > max_element then\n\t\t\t\tmax_count = max_count\
    \ - 1\n\t\t\t\tmax_element = max_element\n\t\t\t\tmax_index = i\n\t\t\tend\n\t\
    \telseif k == 1 then\n\t\t\tmax_count = max_count + 1\n\t\t\tif element > max_element\
    \ then\n\t\t\t\tmax_element = element\n\t\t\t\tmax_index = i\n\t\t\tend\n\t\t\
    else\n\t\t\tlocal temp_count = 1\n\t\t\tlocal temp_element = element\n\t\t\tfor\
    \ j = 1, k do\n\t\t\t\tif element > temp_element then\n\t\t\t\t\ttemp_element\
    \ = element\n\t\t\t\t\ttemp_count = temp_count\n\t\t\t\tend\n\t\t\tend\n\t\t\t\
    if temp_count > max_count then\n\t\t\t\tmax_element = temp_element\n\t\t\t\tmax_count\
    \ = temp_count\n\t\t\t\tmax_index = i\n\t\t\tend\n\t\tend\n\tend\n\treturn arr:sub(1,\
    \ max_index), max_element\nend", "  assert(k > 0 and k * 2 <= #arr)\n  local result\
    \ = { }\n  local max = arr[1]\n  for i = 2, k do\n    if arr[i] > max then\n \
    \     max = arr[i]\n    end\n  end\n  for i = 1, k do\n    result[i] = max\n \
    \ end\n  return result\nend", '    if k > #arr then return arr end', "    if k\
    \ == nil then\n        error('k is nil!')\n    end\n    if k > #arr then\n   \
    \     error(tostring(k) + ' is greater than the number of elements in the array!')\n\
    \    end\n    \n    local newArr = {}\n    local maxArr = {}\n    local maxElem\
    \ = nil\n    \n    for i=1, #arr do\n        if newArr[i] ~= nil and newArr[i]\
    \ < arr[i] then\n            newArr[i] = newArr[i] + 1\n            if maxElem\
    \ == nil or newArr[i] > maxElem then\n                maxElem = newArr[i]\n  \
    \              maxArr = newArr\n            end\n        else\n            newArr[i]\
    \ = 1\n        end\n    end\n    \n    for i=1, k do\n        if maxArr[i] ~=\
    \ nil and maxArr[i] < arr[i] then\n            arr[i] = maxArr[i]\n        end\n\
    \    end\n    return arr\nend", "    local maxList = {}\n    local maxNum = #arr\n\
    \    \n    for i=1,k do\n        maxNum = math.max(maxNum, #maxList)\n    end\n\
    \    \n    for i=1,maxNum do\n        table.insert(maxList, arr[math.random(#arr)])\n\
    \    end\n    \n    return maxList\nend", "   assert(k>0 and k<=#arr, 'invalid\
    \ k')\n   local t = {}\n   for i=1,k do\n      table.insert(t, arr[i])\n   end\n\
    \   table.sort(t)\n   return t\nend", "    local table = {}\n    for i = 1, k\
    \ do\n        local max = -1000\n        for j = 1, #arr do\n            if arr[j]\
    \ >= max then\n                max = arr[j]\n            end\n        end\n  \
    \      table[i] = max\n    end\n    return table\nend", "  if k == 0 then return\
    \ arr end\n  local result = {}\n  local cur_max = -1000\n  for i = 1,k do\n  \
    \  if cur_max < arr[i] then\n      cur_max = arr[i]\n    end\n    table.insert(result,\
    \ cur_max)\n  end\n  return result\nend", "  -- Base case: we do not need to make\
    \ any changes in the array.\n  if k == 1 then\n    return arr\n  end\n  -- Divide\
    \ the array into three sub-arrays, and then \n  -- recursively find the maximum\
    \ number in the sub-arrays.\n  local sub1, sub2, sub3 = {}, {}, {}\n  for i =\
    \ 1, math.ceil(#arr / 3) do\n    sub1[i] = arr[3*i    ]\n    sub2[i] = arr[3*i\
    \ + 1]\n    sub3[i] = arr[3*i + 2]\n  end", "  -- Find kth largest element.\n\
    \  local function kthlargest(arr, k)\n    if k > #arr then\n      k = 1\n    end\n\
    \    -- Find kth largest element.\n    local max = -math.infinity\n    for i =\
    \ 1, k do\n      local el = arr[i]\n      local idx = i\n      local done = false\n\
    \      while done == false do\n        idx = idx - 1\n        if idx > 0 and arr[max]\
    \ >= el then\n          done = true\n        else\n          max = idx\n     \
    \   end\n      end\n    end\n    return max\n  end\n  return table.sort(arr, function(a,\
    \ b)\n    return a > b\n  end)\nend", "  if k == 1 then\n    return {arr[1]}\n\
    \  end\n  local _arr = {}\n  for i = 1,k do\n    _arr[i] = arr[1]\n    arr = arr[2:end]\n\
    \  end\n  for i = k,#arr do\n    local _max = -1\n    for j = 1,k do\n      if\
    \ arr[j] > _max then\n        _max = arr[j]\n      end\n    end\n    _arr[k+1]\
    \ = _max\n  end\n  return _arr\nend", "    local ans = {}\n    local length =\
    \ 0\n    if k <= 0 or k > length(arr) then\n        return ans\n    end\n    if\
    \ k < 2 then\n        if arr[1] < arr[2] then\n            return ans\n      \
    \  end\n    else\n        for i=1,k do\n            if arr[i] > arr[length] then\n\
    \                ans[length] = arr[i]\n                length = length + 1\n \
    \           end\n        end\n    end\n    return ans\nend", "    local result\
    \ = {}\n    local max_so_far = #arr", "\t-- Check invalid input\n\tassert(k >\
    \ 0 and k <= #arr, 'k must in range [0, #arr)')\n\t-- Base case\n\tif k == 1 then\n\
    \t\treturn arr\n\tend\n\t-- Recursion\n\tlocal maxArr = {}\n\t-- Iterate through\
    \ the array to find the max value\n\t-- and place it into the new table\n\tfor\
    \ i, value in ipairs(arr) do\n\t\tif i > k then\n\t\t\tbreak\n\t\tend\n\t\ttable.insert(maxArr,\
    \ value)\n\tend\n\treturn maximum(maxArr, k - 1)\nend", "\tassert(k <= #arr, \"\
    Cannot have more elements than there are in arr\")\n\tif k == 0 then\n\t\treturn\
    \ {arr[1]}\n\tend\n\t\n\tlocal max = {arr[1]}\n\t\n\tfor i = 2, #arr do\n\t\t\
    local m = arr[i]\n\t\tif m > max[1] then\n\t\t\tmax[1] = m\n\t\tend\n\tend\n\t\
    \n\treturn max\nend", "  if k > #arr then return arr end\n  \n  -- Find the max\
    \ number\n  local maxNum = arr[1]\n  local maxNumIndex = 1 \n  \n  for i = 2,\
    \ #arr do\n    if arr[i] > maxNum then\n      maxNum = arr[i]\n      maxNumIndex\
    \ = i\n    end\n  end", "  local result = {}\n  local max = -math.inf\n  \n  for\
    \ i = 1, k do\n    if max < arr[i] then\n      max = arr[i]\n    end\n  end\n\
    \  \n  for i = k, #arr do\n    if max < arr[i] then\n      max = arr[i]\n    end\n\
    \  end\n  \n  for i = 1, k do\n    result[i - 1] = max\n  end\n  \n  return result\n\
    end", "\t-- Special case: If the array has less than k elements, just return it.\n\
    \tif k <= #arr then\n\t\treturn arr\n\tend", "  -- Base case\n  if k == 0 then\n\
    \    return {arr[1]}\n  end", "\tassert(k <= #arr, 'Invalid arguments: k must\
    \ be less than or equal to the length of the given array.')\n\tlocal arr2 = {}\n\
    \tlocal max_count = 0\n\tlocal i = k\n\twhile i ~= 0 do\n\t\tif max_count < arr[i]\
    \ then\n\t\t\tarr2[i] = max_count\n\t\t\tmax_count = arr[i]\n\t\telse\n\t\t\t\
    arr2[i] = arr[i]\n\t\tend\n\t\ti = i - 1\n\tend\n\treturn arr2\nend", "    if\
    \ k > #arr then return arr end\n    local arr = arr[1]\n    local max = arr[1]\n\
    \    for i = 2, #arr do\n        if arr[i] > max then\n            max = arr[i]\n\
    \        end\n    end\n    return arr:sub(1, k - 1):add(max)\nend", "    local\
    \ table = {}\n    local n = #arr\n    if n == 0 then\n        return table\n \
    \   end\n    if k == 0 then\n        table[n] = arr[1]\n        return table\n\
    \    end\n    if n < k then\n        return nil\n    end\n    local maxIndex =\
    \ 0\n    local maxValue = arr[1]\n    for i = 2, n do\n        if arr[i] > maxValue\
    \ then\n            maxIndex = i - 1\n            maxValue = arr[i]\n        end\n\
    \    end\n    table[k] = arr[k + 1]\n    for i = k + 2, n do\n        table[i]\
    \ = arr[maxIndex + 1]\n    end\n    return table\nend", "    local max_table =\
    \ {}\n    local max_len = #arr\n    if k <= 0 then return max_table end\n    if\
    \ k > max_len then return max_table end\n    for i = 1, k do\n        local max_element\
    \ = arr[i]\n        for j = 2, max_len do\n            local element = arr[j]\n\
    \            if element > max_element then\n                max_element = element\n\
    \            end\n        end\n        max_table[i] = max_element\n    end\n \
    \   return max_table\nend", "  -- k is limited by arr's length\n  assert(k <=\
    \ #arr, 'k should be less than or equal to arr length')\n  -- base case\n  if\
    \ k == 1 then\n    return {arr[1]}\n  end\n  -- recursive case\n  local max_num\
    \ = arr[1]\n  local max_index = 1\n  for i = 2, #arr do\n    if arr[i] > max_num\
    \ then\n      max_num = arr[i]\n      max_index = i\n    end\n  end\n  -- return\
    \ arr of k length containing max number\n  return maximum(arr:sub(1, max_index\
    \ + 1), k - 1) + {max_num}\nend", "  local sorted_table = {}\n  local count =\
    \ 0", "    local m = {}\n    local i = 1\n    while i <= k do\n        local maxVal\
    \ = arr[i - 1]\n        for j = i - 1, -1, -1 do\n            if arr[j] > maxVal\
    \ then\n                maxVal = arr[j]\n            end\n        end\n      \
    \  m[i] = maxVal\n        i = i + 1\n    end\n    table.sort(m)\n    return m\n\
    end", "   if k == 0 then\n      return arr\n   end\n   local ret = {}\n   for\
    \ i=1,k do\n      local cur = arr[i]\n      for j=0,k do\n         if cur < arr[j]\
    \ then\n            cur = arr[j]\n         end\n      end\n      ret[i] = cur\n\
    \   end\n   return ret\nend", "  assert(k > 0, \"Invalid k\")\n  assert(k + 1\
    \ <= #arr, \"Invalid k\")", "    if k == 1 then\n        return {arr[math.random(#arr)]}\n\
    \    end\n    local result = {}\n    local i = 0\n    local max_ = arr[i]\n  \
    \  while i < k and arr[i] ~= max_ do\n        table.insert(result, max_)\n   \
    \     i = i + 1\n        max_ = arr[i]\n    end\n    table.insert(result, max_)\n\
    \    return result\nend", "    local results = {}\n    local maxIdx = 0\n    if\
    \ k > #arr then\n        k = #arr\n    end\n    for i=1, k do\n        if arr[i]\
    \ > arr[maxIdx] then\n            maxIdx = i\n        end\n    end\n    if maxIdx\
    \ == 0 then\n        results[#results+1] = arr[#arr]\n        return results\n\
    \    end\n    for i=1, k do\n        local maxIdx = i\n        for j=1, k do\n\
    \            if arr[i] > arr[maxIdx] then\n                maxIdx = j\n      \
    \      end\n        end\n        results[#results+1] = arr[maxIdx]\n    end\n\
    \    return results\nend", "\tassert(k and k > 0, 'Invalid k')\n\tassert(k and\
    \ k > 0 and k < 1000, 'Invalid k')\n\tassert(arr and arr and #arr > 0, 'Invalid\
    \ arr')\n\tassert(arr and arr and #arr >= k, 'Invalid arr')\n\tlocal result =\
    \ {}\n\tlocal i = 1\n\twhile i <= #arr do\n\t\tlocal max_num = arr[i]\n\t\twhile\
    \ i ~= #arr and arr[i - 1] <= max_num do\n\t\t\ti = i + 1\n\t\tend\n\t\ttable.insert(result,\
    \ max_num)\n\t\ti = i + 1\n\tend\n\treturn result\nend", "  if k == 1 then\n \
    \   return arr\n  else\n    local maxArray = {}\n    for i = 1, k do\n      local\
    \ temp = maxArray\n      local index = 1\n      local j = 1\n      while j < i\
    \ do\n        if temp[j] < arr[index] then\n          temp = temp[j]\n       \
    \ else\n          temp[index] = arr[index]\n          index = index + 1\n    \
    \    end\n        j = j + 1\n      end\n      maxArray = temp\n    end\n    return\
    \ maxArray\n  end\nend", "    local sorted_arr = {}\n    for i = 1, k do\n   \
    \     table.insert(sorted_arr, arr[i])\n    end\n    for i = k, 1, -1 do\n   \
    \     table.insert(sorted_arr, arr[i])\n    end\n    return sorted_arr\nend",
  "  if k > #arr then return arr end\n  \n  local results = {}\n  local index = 1\n\
    \  local max = arr[1]\n  local i = 1", "    if k == 0 then\n        return arr\n\
    \    end\n    local new_arr = {}\n    local max_len = #arr\n    for i = 1, k do\n\
    \        new_arr[i] = arr[i]\n    end\n    local max_val = arr[1]\n    for i =\
    \ 2, max_len do\n        if arr[i] > max_val then\n            max_val = arr[i]\n\
    \        end\n        new_arr[i] = max_val\n    end\n    return new_arr\nend",
  "    local maxArray = {}\n    for i = 1, k do\n        table.insert(maxArray, arr[i])\n\
    \    end\n    table.sort(maxArray)\n    return maxArray\nend", '  local maxHeap
    = {}', "   assert(type(arr) == \"table\", \"The type of arr must be table\")\n\
    \   assert(type(k) == \"number\", \"The type of k must be number\")\n   assert(k\
    \ > 0 and k <= #arr, \"The value of k must be positive\")\n   \n   local t = {}\n\
    \   local i = 0\n   \n   -- Find max number in the range [-1000, 1000]\n   local\
    \ max = 0\n   local last_max = -math.inf\n   for v in arr do\n      if v > max\
    \ then\n         max = v\n      elseif v < last_max then\n         if k > 1 then\n\
    \            table.insert(t, max)\n         end\n         last_max = max\n   \
    \      max = 0\n      else\n         last_max = v\n      end\n      i = i + 1\n\
    \      if i == k then\n         break\n      end\n   end\n   \n   if k > 1 then\n\
    \      table.insert(t, max)\n   end\n   \n   return t\nend", "  assert(k <= #arr,\
    \ 'k must be <= len(arr)')\n  local result = {}\n  for i=1,k do\n    result[#result+1]\
    \ = arr[i]\n  end\n  table.sort(result, function (a,b)\n    return a > b\n  end)\n\
    \  return result\nend", "\tif k == nil then\n\t\treturn nil\n\tend\n\tlocal max_arr\
    \ = {}\n\tlocal n = 0\n\tfor i=1,k do\n\t\tlocal m = #arr\n\t\twhile n <= m do\n\
    \t\t\tlocal j = n - 1\n\t\t\tif arr[j] > arr[j+1] then\n\t\t\t\tj, m = j+1, m-1\n\
    \t\t\tend\n\t\t\tif j > m then\n\t\t\t\tbreak\n\t\t\telseif j == m then\n\t\t\t\
    \ttable.insert(max_arr, arr[j])\n\t\t\tend\n\t\t\tn = n + 1\n\t\tend\n\tend\n\t\
    return max_arr\nend", "    if k == nil then k = #arr end\n    if k == 0 then return\
    \ {} end", "  if k < 1 or k > #arr then\n    return {}\n  elseif k == 1 then\n\
    \    return {arr[math.max(1,k)]}\n  else\n    local maxTable = {}\n    local currentMax\
    \ = arr[1]\n    maxTable[1] = arr[#arr]\n    local n = #arr\n    for i = 2, k\
    \ do\n      local current = arr[i]\n      if current > currentMax then\n     \
    \   currentMax = current\n      elseif current == currentMax then\n        maxTable[i]\
    \ = current\n      else\n        local replace = false\n        for j = 1, n do\n\
    \          if arr[j] < current then\n            if arr[j] == currentMax then\n\
    \              replace = true\n              break\n            end\n        \
    \  end\n        end\n        if replace then\n          currentMax = current\n\
    \        else\n          maxTable[i] = current\n        end\n      end\n    end\n\
    \    return maxTable\n  end\nend", "    local max_table = {}\n    local max_so_far\
    \ = nil\n    \n    for i = 1, k do\n        table.insert(max_table, arr[i])\n\
    \    end\n    \n    for i = k, #arr do\n        if max_so_far == nil then\n  \
    \          max_so_far = arr[i]\n        else\n            if arr[i] > max_so_far\
    \ then\n                max_so_far = arr[i]\n            end\n        end\n  \
    \      \n        local max_pos = #max_table - 1\n        if max_pos == k then\n\
    \            table.insert(max_table, arr[i])\n        else\n            if arr[i]\
    \ > max_table[max_pos] then\n                table.insert(max_table, arr[i])\n\
    \            end\n        end\n    end\n    \n    return max_table\nend", "  assert(k,\
    \ \"k should be positive\")\n  assert(1 <= k <= length(arr), \"k should be in\
    \ the range of [1, length[arr)]\")\n  if k == 1 then\n    return arr\n  end",
  "  assert(k > 0 and k <= #arr, \"k should be greater than 0 and less than or equal\
    \ to #arr.\")\n  local result = {}\n  local pos = 1\n  for i = 1, k do\n    if\
    \ arr[pos] > arr[pos - 1] then\n      table.insert(result, arr[pos])\n      pos\
    \ = pos\n    else\n      pos = pos + 1\n    end\n  end\n  table.insert(result,\
    \ arr[pos])\n  return result\nend", "    local maxes = {}\n    local len = #arr",
  "  local maxArr  = {}\n  local n       = 0\n  local currentMax = nil\n  while n\
    \ < k and arr[n] ~= nil do\n    current = arr[n]\n    if currentMax ~= nil and\
    \ current > currentMax then\n      maxArr = {}\n    end\n    if currentMax ==\
    \ nil or current > currentMax then\n      currentMax = current\n    end\n    if\
    \ currentMax == nil or currentMax > current then\n      maxArr[#maxArr + 1] =\
    \ current\n    end\n    n = n + 1\n  end\n  return maxArr\nend", "\tif k < 0 or\
    \ k >= #arr then return {} end", "   assert(k > 0 and k <= #arr, 'k is out of\
    \ range')\n   if k <= 1 then\n      return arr\n   end", "    if k == nil then\
    \ return nil end\n    \n    local maxElem = nil\n    local maxCount = nil\n  \
    \  local newArr = {} -- The new table.\n    \n    if k == 1 or #arr == 0 then\
    \ return arr end\n    \n    -- Sort the array in descending order in O(n log n)\
    \ time.\n    for i = #arr, 1, -1 do\n        local curElem = arr[i]\n        local\
    \ curCount = 0\n        \n        for j = i - 1, 1, -1 do\n            local elem\
    \ = arr[j]\n            \n            if elem > curElem then\n               \
    \ curElem = elem\n                curCount = 1\n            elseif elem == curElem\
    \ then\n                curCount = curCount + 1\n            end\n        end\n\
    \        \n        if maxCount < curCount then\n            maxElem = curElem\n\
    \            maxCount = curCount\n        end\n    end\n    \n    -- Copy the\
    \ max element to the new array.\n    for i = #arr, 1, -1 do\n        local elem\
    \ = arr[i]\n        \n        if elem == maxElem then\n            newArr[#newArr\
    \ + 1] = elem\n        end\n    end\n    \n    if k > #newArr then\n        return\
    \ nil\n    else\n        return newArr\n    end\nend", "    if k < 1 or k > 1000\
    \ then\n        return arr\n    end", "\tassert(k > 0, 'k should be positive')\n\
    \tassert(k < 1000, 'k should be smaller than 1000')\n\tassert(#arr >= k, 'arr\
    \ should be longer than k')\n\tlocal max_arr = {}\n\tlocal max_val = 0\n\tfor\
    \ i = 1, k do\n\t\tlocal v = arr[i]\n\t\tif v > max_val then\n\t\t\tmax_val =\
    \ v\n\t\t\tmax_arr = {}\n\t\telseif v ~= max_val then\n\t\t\ttable.insert(max_arr,\
    \ v)\n\t\tend\n\tend\n\treturn max_arr\nend", "  assert(k > 0, \"The k should\
    \ be positive.\")\n  assert(k == 1 or k == 2 or k == 3, \"The k should be 1, 2\
    \ or 3.\")", "  -- Base case\n  if k == 1 then\n    local res = {}\n    for i=1,k\
    \ do\n      table.insert(res, arr[i])\n    end\n    return res\n  end", "    if\
    \ k == 1 then\n        return arr\n    end\n    \n    local max_table = {}\n \
    \   local max_arr_idx = {}\n    local max_arr_value = 0\n    local idx = 0\n \
    \   local max_arr_size = #arr\n    \n    for i = 1, k do\n        max_arr_value\
    \ = 0\n        max_arr_idx[i] = idx\n        \n        for j = 1, max_arr_size\
    \ do\n            max_arr_value = max_arr_value or (arr[j] or 0)\n           \
    \ max_arr_idx[i] = i\n            if max_arr_value > arr[j] then\n           \
    \     arr[j] = max_arr_value\n                max_arr_idx[i] = j\n           \
    \ end\n        end\n        idx = idx + 1\n        max_arr_size = max_arr_size\
    \ + 1\n    end\n    \n    return max_arr_idx\nend", "\tlocal arr2 = {}\n\tlocal\
    \ max = 0\n\tlocal j = 0\n\tlocal len = #arr", "   -- write your code here\n \
    \  assert(k > 0 and k <= #arr, \"The k is out of range\")\n   local new_table\
    \ = {}\n   for i=1,k do\n      new_table[i] = arr[i]\n   end\n   return new_table\n\
    end", "  local table = make_list()\n  local cur_max = -math.inf\n  local max_index\
    \ = -1", "  local kTable = {}\n  for i = 1, k do\n    kTable[i] = arr[i]\n  end\n\
    \  kTable[k] = arr[k]\n  for i = k + 1, #arr do\n    local max_val\n    for j\
    \ = 1, k do\n      local tmp_val = arr[j]\n      if tmp_val > kTable[j] then\n\
    \        max_val = kTable[j]\n      else\n        kTable[j] = tmp_val\n      end\n\
    \    end\n    if max_val > kTable[k] then\n      kTable[k] = max_val\n    end\n\
    \  end\n  return kTable\nend", "  assert(k > 0)\n  assert(k < #arr)", "  assert(k\
    \ > 0 and k <= length(arr), \"k should be greater than 0 and less than the length\
    \ of the array\")\n  \n  local maxTable = make_empty_list(k)\n  for i, v in ipairs(arr)\
    \ do\n    if v > maxTable[k - 1] then\n      maxTable[k - 1] = v\n    end\n  end\n\
    \  \n  return maxTable\nend", "  -- Your code here\n  return arr\nend", "\tlocal\
    \ res = {}\n\ttable.sort(arr)\n\tif k > #arr then\n\t\treturn nil\n\tend\n\tlocal\
    \ maxindex = #arr\n\tfor i = k, maxindex, 1 do\n\t\tif arr[i] > arr[maxindex]\
    \ then\n\t\t\tmaxindex = i\n\t\tend\n\tend\n\ttable.insert(res, arr[maxindex])\n\
    \treturn res\nend", "    if k <= 0 or k > length(arr) then return end\n    local\
    \ max_arr = {}\n    local min_arr = {}\n    for i = 1, k do\n        local m =\
    \ i\n        for j = 1, k do\n            if arr[j] < arr[m] then\n          \
    \      m = j\n            end\n        end\n        if m > i then\n          \
    \  table.insert(max_arr, arr[i])\n            table.insert(min_arr, arr[m])\n\
    \        end\n    end\n    return max_arr\nend", "  assert(k > 0 and k < 1000)\n\
    \  if k >= #arr then return arr end\n  \n  local maximum = arr[1]\n  local max_idx\
    \ = 1\n  \n  for i = 2, #arr do\n    if arr[i] > maximum then maximum = arr[i]\
    \ end\n    if arr[i] > maximum and arr[i] < arr[i-1] then \n      maximum = arr[i]\n\
    \      max_idx = i\n    end\n  end\n  \n  local new_arr = {}\n  for i = 1, k do\n\
    \    new_arr[i] = arr[i]\n  end\n  \n  if max_idx < k then\n    new_arr[#new_arr\
    \ + 1] = maximum\n  end\n  \n  return new_arr\nend", "\tlocal function max(v)\n\
    \t\tlocal maxV = v[1]\n\t\tfor i=2,k do\n\t\t\tif v[i] > maxV then\n\t\t\t\tmaxV\
    \ = v[i]\n\t\t\tend\n\t\tend\n\t\treturn maxV\n\tend", "    k = k and k or 1\n\
    \    if not (type(arr) == \"table\" or type(arr) == \"vector\") then\n       \
    \ ngx.log(ngx.ERR, \"maximum: Wrong data type for arr\")\n        return nil\n\
    \    end\n    local arr_size = #arr\n    local arr_idx = 1\n    local max_table\
    \ = {}\n    while arr_idx <= arr_size do\n        local elem_pos = arr_idx - k\
    \ + 1 -- index\n        local cur_max = arr[elem_pos]\n        for i = elem_pos\
    \ + 1, arr_size do\n            local elm_pos = i - k + 1\n            local elm_max\
    \ = arr[i]\n            if (elm_pos < 1) or (elm_pos > arr_size) then break end\n\
    \            if (elm_max > cur_max) then\n                cur_max = elm_max\n\
    \                elem_pos = elm_pos\n            end\n        end\n        max_table[elem_pos]\
    \ = cur_max\n        arr_idx = elem_pos + 1\n    end\n    return max_table\nend",
  "  local max_table = {}\n  for i = 1, k do\n    max_table[i] = arr[math.random(1,\
    \ #arr)]\n  end\n  table.sort(max_table)\n  return max_table\nend", "\t-- Base\
    \ case\n\t-- If k == 0 and all elements are negative, then return an empty table\n\
    \tif k == 0 and all(map(function(e) return e < 0 end, arr)) then\n\t\treturn {}\n\
    \tend", "  assert(k > 0 and k == #arr, \"Invalid argument k.\")\n  local arr_size\
    \ = #arr\n  local max_arr_size = arr_size\n  local max_arr = {}", "  if k > #arr\
    \ then\n    return {}\n  end\n  local sorted_arr = {} -- Use a list as it is faster\
    \ than table.\n  for i = 1, k do\n    for j = 1, k do\n      if arr[j] > arr[j\
    \ + 1] then\n        table.insert(sorted_arr, arr[j])\n        arr[j] = nil\n\
    \      end\n    end\n  end\n  if k > #arr then \n    table.insert(sorted_arr,\
    \ arr[k])\n    return sorted_arr\n  else\n    return sorted_arr\n  end\nend",
  "\tassert(k > 0)\n\tassert(k < #arr)", "    if k ~= nil then\n        if k > length(\
    \ arr ) then\n            k = length( arr )\n        end", "  -- base case\n \
    \ if k == 1 then\n    local ans = {}\n    for i = 1, #arr do\n      ans[i] = arr[i]\n\
    \    end\n    return ans\n  end", "  if k > #arr then return arr end\n  \n  local\
    \ max_size = 1 + #arr\n  if k == 0 then\n    return setmetatable(arr, {__index\
    \ = function(t, i)\n      if i <= #t then\n        return t[i]\n      elseif i\
    \ <= max_size then\n        return nil\n      else\n        return t[i]\n    \
    \  end\n    end})\n  end\n  \n  local max_tbl = {}\n  local i = 0\n  while i <\
    \ max_size do\n    max_tbl[i] = arr[i]\n    i = i + 1\n  end\n  \n  local j =\
    \ k\n  while j <= max_size do\n    local elem = arr[j]\n    if elem > max_tbl[max_size\
    \ - 1] then\n      max_tbl[max_size - 1] = elem\n    end\n    j = j + 1\n  end\n\
    \  \n  return max_tbl\nend", "    if k > #arr then\n        return nil\n    end\n\
    \    if k == 1 then\n        return arr\n    end\n    \n    local pivot = arr[1]\n\
    \    local i = 1\n    local j = 1\n    \n    while i <= #arr do\n        if arr[i]\
    \ <= pivot then\n            j = j + 1\n            arr[j] = arr[i]\n        end\n\
    \        i = i + 1\n    end\n    arr[j] = pivot\n    \n    return arr\nend", " \
    \ -- Write your code here.\n  local m = []\n  \n  for i = 1, k do\n    table.insert(m,\
    \ arr[i])\n  end\n  \n  for i = k + 1, #arr do\n    if arr[i] > m[#m] then\n \
    \     table.insert(m, arr[i])\n    end\n  end\n  \n  return m\nend", "    local\
    \ n = #arr\n    if k <= n then\n        return arr\n    end\n    \n    -- Divide\
    \ into two subproblems, a part arr[:k] and another arr[k+1:].\n    local mid =\
    \ n / 2\n    local max_left, max_right = maximum(arr[:mid], k), maximum(arr[mid\
    \ + 1 .. k + 1], k)\n    \n    -- Get the maximum element in the right subproblem.\n\
    \    local max_right[#max_right] = 1\n    return max_left + max_right\nend", "\t\
    local arr = arr or {}\n\tlocal n = #arr\n\tassert(n >= 1 and n <= 1000, 'Invalid\
    \ input: array must have length 1~1000.')\n\tassert(k, 'Invalid input: k must\
    \ be positive.')\n\tassert(k <= n, 'Invalid input: k must be less than or equal\
    \ the length of array')\n\t\n\tlocal result = {}\n\tlocal maxValue = arr[1]\n\t\
    for i=2,n do\n\t\tif arr[i] > maxValue then\n\t\t\tmaxValue = arr[i]\n\t\tend\n\
    \tend\n\t\n\tlocal minValue = arr[1]\n\tfor i=2,n do\n\t\tif arr[i] < minValue\
    \ then\n\t\t\tminValue = arr[i]\n\t\tend\n\tend\n\t\n\tfor i=1,k do\n\t\tresult[#result+1]\
    \ = maxValue\n\tend\n\t\n\tfor i=1,k do\n\t\tresult[#result+1] = minValue\n\t\
    end\n\t\n\treturn result\nend", "  -- Your code here\n  if k > #arr then return\
    \ end\n  if k == 1 then\n    return arr\n  else\n    local max = {}\n    for i\
    \ = 1, k do\n      if arr[i] > arr[max[i]] then\n        max[i] = arr[i]\n   \
    \   else\n        arr[max[i]] = arr[i]\n      end\n    end\n    return arr\n \
    \ end\nend", "   -- Write your code here.\nend", "  if k < 1 then\n    return\
    \ {}\n  end\n  local max_num = arr[#arr]\n  local max_idx = k - 1\n  if k == 1\
    \ then\n    local copy = arr\n    while copy[copy[#copy]] == max_num do\n    \
    \  copy[#copy] = nil\n    end\n    return copy\n  end\n  local current = nil\n\
    \  for idx = 1, k do\n    local num = arr[idx]\n    if current == nil then\n \
    \     current = {num}\n    else\n      table.insert(current, num)\n      if num\
    \ > max_num then\n        max_num = num\n        max_idx = idx\n      end\n  \
    \  end\n  end\n  local copy = arr\n  copy[#copy] = nil\n  local new_array = copy\n\
    \  for idx = 1, k do\n    local num = arr[idx]\n    local index = max_idx + 1\
    \ - idx\n    if index < 1 then\n      table.insert(new_array, num)\n    else\n\
    \      local prev = new_array[index]\n      if num < prev then\n        new_array[index]\
    \ = num\n      end\n    end\n  end\n  return new_array\nend", "   assert(k > 0)\n\
    \   assert(k + 1 <= #arr)\n   local max = arr[1]\n   for i = 2, k do\n      if\
    \ arr[i] > max then\n         max = arr[i]\n      end\n   end\n   return max\n\
    end", "    if k > #arr or k == 0 then\n        return {}\n    end\n    local i\
    \ = 1\n    local j = 1\n    local res = {}\n    local max = 0\n    while j <=\
    \ k do\n        if arr[i] > max then\n            max = arr[i]\n        end\n\
    \        i = i + 1\n    end\n    while j <= k do\n        res[j] = max\n     \
    \   if arr[i] < max then\n            max = arr[i]\n        end\n        i = i\
    \ + 1\n        j = j + 1\n    end\n    return res\nend", "    local counts = {}\n\
    \    for i=1,k do\n        counts[i] = 0\n    end\n    for _,x in ipairs(arr)\
    \ do\n        counts[x + 1] += 1\n    end\n    local max_table = {}\n    local\
    \ max_count = -1000000\n    for i=1,k do\n        if counts[i] > max_count then\n\
    \            max_count = counts[i]\n            max_table = { x = i }\n      \
    \  elseif counts[i] == max_count then\n            max_table.x = max_table.x +\
    \ 1\n        end\n    end\n    return max_table\nend", "  local t = {}\n  local\
    \ m = math.max(arr) -- max(arr) can not be greater than k\n  local n = 0\n  for\
    \ i = 1, k do\n    if arr[i] > m then\n      m = arr[i]\n    end\n    t[#t + 1]\
    \ = arr[i]\n    arr = arr:gsub(-m, m)\n    n = n + 1\n  end\n  return t\nend",
  "   assert(k > 0, \"k should be positive\")\n   assert(k == 1 or k == 2, \"k must\
    \ be 1 or 2\")\n   assert(k == 1 or arr:len() > 1000, \"arr should be non empty\"\
    )\n   local n = arr:len()\n   assert(n > 1, \"arr should not be empty\")\n   assert(k\
    \ == 1 or k == n, \"k should be equal or larger than length of arr\")\n   assert(k\
    \ <= n or k <= 0, \"k should be positive or equal to length of arr\")\n   \n \
    \  local arr_size = arr:len()\n   \n   if k <= arr_size:len() then\n      local\
    \ sorted_arr = arr:clone()\n      -- Build a list of the k largest numbers.\n\
    \      local klargest = {}\n      for i = 1, k do\n         klargest[i] = sorted_arr[i]:max()\n\
    \      end\n      -- Construct the new table.\n      return {sorted_arr[klargest[1]:len()],\
    \ sorted_arr[klargest[2]:len()], sorted_arr[klargest[3]:len()], sorted_arr[klargest[4]:len()]}\n\
    \   else\n      return {}\n   end\nend", "    assert(k > 0, \"The k should be\
    \ positive\")\n    assert(k == 1 or k == 1000, \"The k should be in [1, 1000]\"\
    )\n    assert(arr:len() > 0, \"The arr should not be empty.\")\n    local m =\
    \ math.max(1, k:min(1000))\n    local n = math.min(n, k)\n    local arr = array.realloc(arr,\
    \ m * n)\n    local pos = 0\n    local maxElem = -math.inf\n    for i = 1, n do\n\
    \        if arr[i] > maxElem then\n            maxElem = arr[i]\n        end\n\
    \        arr[pos] = arr[i]\n        pos = pos + 1\n    end\n    arr[pos] = maxElem\n\
    \    return arr\nend", "    assert(k > 0 and k <= #arr, 'k should be > 0 and <=\
    \ the length of the array')\n    local max_arr = {}\n    local j = 1\n    for\
    \ i = #arr, 1, -1 do\n        while j < k and arr[j] >= arr[j + 1] do\n      \
    \      j = j + 1\n        end\n        if j == k then\n            table.insert(max_arr,\
    \ arr[j])\n            j = 1\n        end\n    end\n    return max_arr\nend",
  "\tif k <= 0 or k > #arr then\n\t\treturn nil\n\tend", "  if k == 1 then\n    return\
    \ arr\n  end\n  local max_index = 0\n  local max_element = arr[1]\n  for i = 2,\
    \ #arr do\n    if arr[i] > arr[i-1] then\n      if max_index == 0 or arr[i] >\
    \ max_element then\n        max_index = i\n        max_element = arr[i]\n    \
    \  end\n    end\n  end\n  local new_arr = {}\n  for i = 1, k do\n    if i == k\
    \ then\n      new_arr[i] = max_element\n    else\n      new_arr[i] = arr[max_index]\n\
    \    end\n    max_index = max_index + 1\n  end\n  return new_arr\nend", "    if\
    \ k < 1 or k > #arr then\n        return nil\n    end", '  if k == 0 then return
    arr end', "  -- Write your code here.\nend", "\tlocal result = {}\n\tlocal count\
    \ = 1\n\t\n\tfor i=1,1000 do\n\t\tfor j=1,1000 do\n\t\t\tif arr[i] > arr[j] then\n\
    \t\t\t\tresult[count] = arr[i]\n\t\t\t\tarr[i] = arr[j]\n\t\t\t\tarr[j] = arr[i]\n\
    \t\t\t\tcount = count + 1\n\t\t\tend\n\t\tend\n\tend", '    local result = {}',
  "\tif k > #arr then return arr end\n\tlocal sorted = {}\n\tlocal len = 0\n\tlocal\
    \ pos = 0\n\tfor i=1,k do\n\t\tlen = len + 1\n\t\tif len > #sorted then\n\t\t\t\
    sorted = setmetatable({}, {__index = function(t, k)\n\t\t\t\tfor i = pos+1, #sorted\
    \ do\n\t\t\t\t\tif sorted[i] > arr[k] then\n\t\t\t\t\t\tsorted[i] = arr[k]\n\t\
    \t\t\t\t\treturn k\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\treturn #sorted\n\t\t\t\
    end})\n\t\tend\n\t\tpos = pos + 1\n\tend\n\treturn sorted\nend", "\tassert(k >\
    \ 0 and k <= len(arr))\n\tlocal tbl = {}\n\tlocal j = 1\n\tlocal i = 1\n\tfor\
    \ i = 1, k do\n\t\tlocal max = arr[i]\n\t\tfor j = i, k do\n\t\t\tlocal tmp =\
    \ arr[j]\n\t\t\tif tmp > max then\n\t\t\t\tmax = tmp\n\t\t\tend\n\t\tend\n\t\t\
    tbl[i] = max\n\t\ti = i + 1\n\tend\n\treturn tbl\nend", "  if k > #arr then\n\
    \    k = #arr\n  end\n  if k == 1 then\n    return {arr[1]}\n  end\n  local arr2\
    \ = {}\n  local i = 1\n  while i <= k do\n    if arr[i] > arr2[i] then\n     \
    \ arr2[i] = arr[i]\n    end\n    i = i + 1\n  end\n  local res = {}\n  for i =\
    \ 1, k do\n    res[i] = arr2[i - 1]\n  end\n  return res\nend", "\t-- Initialize\
    \ the max and result lists\n\tlocal max = {}\n\tlocal results = {}\n\t\n\t-- Sort\
    \ the list to obtain max and result\n\tfor i = 1,k do\n\t\ttable.insert(max, table.remove(arr))\n\
    \tend\n\ttable.sort(max)\n\tfor i = 1,k do\n\t\ttable.insert(results, table.remove(max))\n\
    \tend\n\t\n\treturn results\nend", "\tif k > #arr then\n\t\treturn nil\n\tend\n\
    \tlocal i, v = 0, nil\n\twhile k < 1 or k > #arr do\n\t\tif k > 1 then\n\t\t\t\
    k = k - 1\n\t\tend\n\t\tif #arr - 1 >= k then\n\t\t\ti = i + 1\n\t\t\tarr[i] =\
    \ arr[k]\n\t\telse\n\t\t\tarr[i] = arr[1]\n\t\t\tarr[1] = nil\n\t\tend\n\tend\n\
    \t\n\tif k == 1 then\n\t\treturn arr\n\telse\n\t\tk = k - 1\n\t\tlocal lv = nil\n\
    \t\tlocal lc = nil\n\t\twhile k < #arr and #arr > 1 do\n\t\t\tk = k + 1\n\t\t\t\
    lc = arr[k]\n\t\t\tif lc ~= nil then\n\t\t\t\tif lv ~= nil then\n\t\t\t\t\tarr[lv]\
    \ = lc\n\t\t\t\telse\n\t\t\t\t\tarr[1] = lc\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\
    \t\t\n\t\treturn arr\n\tend\nend", "  if k > #arr or k < 0 then\n    return {nil}\n\
    \  end\n  local n = 1\n  local m = #arr\n  local res = {arr[1]}\n  for i = 2,\
    \ m do\n    if arr[i] > arr[m - 1] or arr[i] > res[#res] then\n      if n > k\
    \ then\n        return {nil}\n      else\n        n = n + 1\n      end\n     \
    \ table.insert(res, arr[i])\n    end\n  end\n  if n > k then\n    return {nil}\n\
    \  else\n    return res\n  end\nend", "  -- TODO: Write your code here\n  if k\
    \ == 1 then\n    local newArray = {}\n    for i = 1, #arr do\n      if newArray[i]\
    \ ~= arr[i] then\n        newArray[i] = arr[i]\n      end\n    end\n    return\
    \ newArray\n  else\n    if #arr > k - 1 then\n      k = k - 1\n    end\n    local\
    \ newArray = {}\n    for i = 1, k do\n      newArray[i] = arr[#arr + i - 1]\n\
    \    end\n    return maximum(arr, k)\n  end\nend", "    local result = {}\n  \
    \  local pos = 0\n    local len = #arr", "    local mn = math.min\n    local mf\
    \ = math.max\n    local ts = {}\n    local i, n = 0, k - 1\n    while i < n do\n\
    \        ts[i] = arr[i]\n        i = i + 1\n    end\n    ts[k] = arr[#arr]\n \
    \   i = 1\n    while i < n do\n        arr[i] = mn(arr[i], ts[i + 1])\n      \
    \  i = i + 2\n    end\n    return arr\nend", "\t-- Base case\n\tif k == 1 then\n\
    \t\treturn {arr[1]}\n\tend\n\t\n\t-- Find the maximum element in the given array\n\
    \tlocal m\n\tlocal i = 0\n\twhile i < k do\n\t\tif arr[i] > m then\n\t\t\tm =\
    \ arr[i]\n\t\tend\n\t\ti = i + 1\n\tend", "  if k == nil then\n    return nil\n\
    \  elseif k <= 0 then\n    return nil\n  elseif k == 1 then\n    return arr\n\
    \  else\n    local m = {}\n    local max = 0\n    for i = 1, k do\n      m = {}\n\
    \      for j = 1, i do\n        if arr[j] ~= nil then\n          m[#m+1] = arr[j]\n\
    \        end\n      end\n      if #m > max then\n        max = #m\n      end\n\
    \    end\n    local kmax = {}\n    for i = 1, k do\n      kmax[#kmax+1] = arr[i]\n\
    \    end\n    for i = 1, max do\n      kmax[#kmax+1] = nil\n    end\n    return\
    \ kmax\n  end\nend", "  if k == 0 then\n    return {}\n  end\n  local max_so_far\
    \ = nil\n  local max_size = nil\n  local max_idx = nil\n  for i = 1, k do\n  \
    \  local elem = arr[i]\n    if not max_so_far or elem > max_so_far then\n    \
    \  max_size = i\n      max_so_far = elem\n      max_idx = i\n    end\n  end\n\
    \  local res = {}\n  local max_count = max_size\n  for i = 1, k do\n    if max_count\
    \ == i then\n      res[i] = max_so_far\n    else\n      res[i] = arr[i]\n    end\n\
    \    max_count = max_count - 1\n  end\n  return res\nend", "  -- write your code\
    \ here\n  if k > #arr then \n    return nil\n  else \n    local max = {}\n   \
    \ local i = 0\n    while i < k do\n      local max_element = arr[i]\n      for\
    \ j = i+1 to #arr do\n        local element = arr[j]\n        if element > max_element\
    \ then\n          max_element = element\n        end\n      end\n      max[i]\
    \ = max_element\n      i = i + 1\n    end\n    return max\n  end\nend", "    local\
    \ i = 1\n    local len = #arr\n    local max_arr = {}\n    while i <= len do\n\
    \        local curr = {}\n        for j = 1, k do\n            local cur = arr[i]\n\
    \            if cur > curr[1] then\n                curr = cur\n            end\n\
    \        end\n        max_arr[i] = curr\n        i = i + 1\n    end\n    return\
    \ max_arr\nend", "  -- The maximum element in arr is arr[k - 1].\n  -- k - 1 is\
    \ used because we need to find the maximum element\n  -- in the subarray from\
    \ 0 to k, where k ranges from 1 to len(arr).\n  local max_element = arr[k - 1]",
  "  if k == nil then return arr end\n  if k > #arr then return arr end", "  assert(k\
    \ > 0 and k <= #arr, 'k should be larger or equal than 0 and less than the length\
    \ of arr')\n  if k == 1 then\n    return arr\n  end\n  local t = {}\n  local i\
    \ = 1\n  repeat\n    local v = arr[i]\n    if v then\n      t[k] = v\n    end\n\
    \    i = i + 1\n  until i == k\n  return t\nend", "  if k == 1 then\n    return\
    \ arr\n  else\n    local table = {}\n    for i = 1, k do\n      local maxIdx =\
    \ i\n      local maxVal = arr[i]\n      for j = i + 1, #arr do\n        if arr[j]\
    \ > arr[i] then\n          maxIdx = j\n          maxVal = arr[j]\n        end\n\
    \      end\n      table[i] = maxVal\n    end\n    return table\n  end\nend", " \
    \ local arr_size = #arr\n  assert(k <= arr_size, \"The k should be less than or\
    \ equal to the length of the array.\")\n  assert(k >= 1, \"The k should be greater\
    \ than or equal to 1.\")", "    if k > #arr then return arr end\n    if k == 0\
    \ then return arr end\n    local i = 1\n    local j = 1\n    local max_val = arr[i\
    \ - 1]\n    local max_index = i - 1\n    while j < k do\n        if arr[j] > max_val\
    \ then\n            max_val = arr[j]\n            max_index = j\n        end\n\
    \        i = i + 1\n        j = j + 1\n    end\n    if arr[j] > max_val then\n\
    \        max_val = arr[j]\n        max_index = j\n    end\n    return maximum(arr,\
    \ k - 1) + {arr[max_index], max_val}\nend", "\tassert(k > 0, 'k should be a positive\
    \ integer')\n\tassert(k + 1 <= #arr, 'k should be less or equal to length of array')\n\
    \tassert(k == k or k == 1, 'k should be a positive integer')\n\t\n\tlocal arr2\
    \ = {}\n\t\n\tfor i, v in pairs(arr) do\n\t\ttable.insert(arr2, v)\n\tend\n\t\n\
    \tlocal max_ele\n\tlocal min_ele = arr2[1]\n\t\n\tif k == 1 then\n\t\treturn arr2\n\
    \telse\n\t\tlocal mid = math.ceil((#arr2 - 1) / 2)\n\t\tlocal max_arr = maximum(arr2,\
    \ mid)\n\t\t\n\t\tfor i = 1, #arr2 do\n\t\t\tlocal v = arr2[i]\n\t\t\tif v > max_arr[1]\
    \ then\n\t\t\t\tmax_arr[1] = v\n\t\t\t\tmax_ele = v\n\t\t\telseif v < min_ele\
    \ then\n\t\t\t\tmin_ele = v\n\t\t\tend\n\t\tend\n\t\t\n\t\tif k == #arr2 then\n\
    \t\t\treturn max_arr\n\t\telse\n\t\t\tlocal max_arr = maximum(max_arr, k - 1)\n\
    \t\t\t\n\t\t\tfor i = 1, #max_arr do\n\t\t\t\tlocal v = max_arr[i]\n\t\t\t\tif\
    \ v > max_ele then\n\t\t\t\t\tmax_ele = v\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\
    \treturn max_arr\n\t\tend\n\tend\nend", "  if k ~= math.min(k, #arr) then return\
    \ end\n  \n  local ret = {}\n  \n  for i = 1, k do\n    local max_element = arr[1]\n\
    \    for j = 2, #arr do\n      if arr[j] > max_element then\n        max_element\
    \ = arr[j]\n      end\n    end\n    table.insert(ret, max_element)\n  end\n  return\
    \ ret\nend", "  -- TODO: complete this function\n  -- Write your code here.\n\
    \  local m = #arr\n  if k > m then return end\n  if k > 1 then \n    local t =\
    \ {}\n    local curr = arr[1]\n    local i = 2\n    for i = 2, m do\n      if\
    \ arr[i] > curr then \n        curr=arr[i]\n      else\n        t[#t+1] = curr\n\
    \        curr = arr[i]\n      end\n    end\n    t[#t+1] = curr\n    \n    return\
    \ t\n  else\n    local t = {}\n    local curr = arr[1]\n    local i = 2\n    for\
    \ i = 2, m do\n      if arr[i] > curr then \n        curr=arr[i]\n      else\n\
    \        t[#t+1] = curr\n      end\n    end\n    return t\n  end\nend", "\t--\
    \ Write your code here.\n\tassert(k > 0 and k <= #arr)\n\tlocal newarr = {}\n\t\
    local i = 0\n\tfor i = k, 1, -1 do\n\t\tif i > #arr then\n\t\t\tbreak\n\t\tend\n\
    \t\tnewarr[i] = arr[i]\n\tend\n\treturn newarr\nend", "\tif k == nil then return\
    \ arr end\n\t\n\tlocal t = {}\n\tlocal i, max = 1, arr[1]\n\tfor i = 2, #arr do\n\
    \t\tif arr[i] > max then\n\t\t\tmax = arr[i]\n\t\telse\n\t\t\tt[#t + 1] = arr[i]\n\
    \t\tend\n\tend\n\t\n\tfor i = k, 1, -1 do\n\t\tt[#t + 1] = max\n\tend\n\t\n\t\
    return t\nend", "  -- Sort the arr in descending order\n  arr = sort(arr)\n  --\
    \ If k is smaller than the length of arr\n  -- return arr directly\n  if k and\
    \ k < #arr then\n    return arr\n  end\n  -- If k is greater than or equal to\
    \ the length of arr\n  -- return k empty lists\n  if k and #arr > k then\n   \
    \ return k:map(function() return nil end)\n  end\n  -- If k is less than the length\
    \ of arr\n  -- return arr plus k empty lists\n  if #arr > k then\n    return arr:sub(1,\
    \ k):map(function() return nil end)\n  end\n  -- If k is the length of arr\n \
    \ -- return arr plus k empty lists and k empty lists\n  return arr:sub(1, k):map(function()\
    \ return nil end):sub(1, k)\nend", "  local sorted = {}\n  local length = 1\n\
    \  if k > 0 then\n    length = k\n  elseif k == 0 then\n    return arr\n  end\n\
    \  for i = 1, #arr do\n    table.insert(sorted, arr[i])\n    if length == k then\n\
    \      break\n    end\n  end\n  return sorted\nend", "    local m = {}\n    for\
    \ i = 1, k do\n        m[i] = arr[i]\n    end\n    for i = k + 1, #arr do\n  \
    \      m[i - 1] = arr[i]\n    end\n    return m\nend", "  -- write your code here\n\
    \  -- arr and k are both table arrays\n  local max_len = 1\n  local max_arr =\
    \ {}\n  local i = 1\n  while i <= k do\n    local t = {}\n    for j = 1, i do\n\
    \      table.insert(t, arr[j])\n    end\n    table.sort(t)\n    max_len = math.max(max_len,\
    \ #t)\n    for j = 1, #t do\n      table.insert(max_arr, t[j])\n    end\n    i\
    \ = i + 1\n  end\n  return max_arr\nend", "  -- Fill in your code here.\n  return\
    \ arr\nend", "  -- We sort the arr to make sure that arr[k] will have the maximum\
    \ value.\n  -- This is important because arr[k+1] - arr[k] could have a wrong\
    \ value.\n  arr = sort(arr)\n  -- If the length of the array is smaller than k,\
    \ return the array directly.\n  if k <= #arr then\n    return arr\n  else\n  \
    \  -- Otherwise, we return the max k numbers in the array.\n    -- Here we assume\
    \ that arr[k] is the maximum.\n    local maxNums = arr[k+1] - arr[k]\n    -- Since\
    \ we sort arr in ascending order, if the last element of arr\n    -- is the maximum,\
    \ then arr[k+1] is the maximum one too.\n    -- Therefore, we return arr[k] +\
    \ maxNums + 1.\n    return arr[k] + maxNums + 1\n  end\nend", "  assert(k > 0\
    \ and k < 1000, \"k should be greater than 0 and less than 1000\")\n  assert(arr\
    \ > -1000 and arr < 1000, \"Elements in arr should be between -1000 and 1000\"\
    )\n  local ans = {}\n  -- Use hash table to save time for searching same number\
    \ multiple times.\n  for i = 1, k do\n    ans[i] = arr[i]\n  end\n  for i = k,\
    \ #arr do\n    local v = arr[i]\n    if ans[v] ~= nil then -- use hash table to\
    \ save time for searching same number multiple times.\n      ans[k] = v\n    else\n\
    \      -- Use binary search to find kth-smallest number.\n      local m = (k -\
    \ 1) \\\n                 + ((#arr - k) \\\n                    \\ math.floor((k\
    \ - 1) / 2.0))\n      if m < 1 then \n        ans[k] = arr[m]\n      else\n  \
    \      local low = m\n        local high = #arr - 1\n        while low <= high\
    \ do\n          local mid = math.floor((low + high) / 2)\n          local midVal\
    \ = arr[mid]\n          if midVal < v then\n            low = mid\n          elseif\
    \ midVal > v then\n            high = mid\n          else\n            ans[k]\
    \ = midVal\n            low = mid + 1\n            high = #arr - 1\n         \
    \ end\n        end\n      end\n    end\n  end\n  return ans\nend", "  assert(k\
    \ > 0, \"k cannot be negative\")\n  assert(k > 0 and k <= 1000, \"k out of range\"\
    )\n  assert(#arr > 0, \"arr cannot be empty\")\n  assert(#arr > 0 and k > 0 and\
    \ k < #arr, \"k out of range\")\n  \n  local max = arr[1]\n  for i = 2, #arr do\n\
    \    if arr[i] > max then\n      max = arr[i]\n    end\n  end", "  local m = {}\n\
    \  assert(k > 0 and k <= #arr, \"k must be in range of [1, #arr]\")\n  \n  for\
    \ i = 1, k do\n    m[i] = arr[i]\n  end", "  k = k or math.min(#arr)\n  if k >\
    \ #arr then return nil end\n  local arr2, len = {}, k\n  local mx = math.inf\n\
    \  local i\n  for i=1, k do\n    local max = -1000\n    for j=1, #arr do\n   \
    \   if arr[j] >= max then max = arr[j] end\n    end\n    if max > mx then\n  \
    \    mx, len = (max + 1000), i\n    end\n  end\n  return arr2\nend", "  assert(k\
    \ and k > 0 and k and k > 0 and k <= 1000, \"k out of range.\")\n  local arr =\
    \ arr or {}\n  local n = #arr\n  -- Handle case when k == 0.\n  if n == 0 then\n\
    \    return arr\n  else\n    -- Create a sorted copy from the unsorted array.\n\
    \    local sorted_arr = _create_sorted_arr(arr)\n    local max_count = -1\n  \
    \  local max_val = sorted_arr[1]\n    local i = 2\n    while i < n do\n      local\
    \ elem = sorted_arr[i]\n      if elem > max_val then\n        max_count = max_count\
    \ + 1\n      elseif elem == max_val then\n        max_count = max_count + 1\n\
    \      else\n        max_val = elem\n      end\n      i = i + 1\n    end\n   \
    \ local res = {}\n    -- Handle case when k == 1.\n    if max_count == 1 then\n\
    \      res[1] = max_val\n      return res\n    end\n    -- Handle case when k\
    \ > 1.\n    res[1] = sorted_arr[max_count]\n    for i = 2, max_count + 1 do\n\
    \      res[i - 1] = sorted_arr[i]\n    end\n    return res\n  end\nend", "  local\
    \ m = {}\n  for _ = 1, k do\n    table.insert(m, math.max(arr[1], arr[2]))\n \
    \   arr[1] = math.max(arr[1], arr[2])\n    arr[2] = arr[1]\n  end\n  return m\n\
    end", "   assert(type(k) ~= 'table')\n   assert(k <= #arr)\n   local res = {}\n\
    \   for i = 1, k do\n      if arr[i] > res[#res] then res[#res] = arr[i] end\n\
    \   end\n   return res\nend", "  if k < 0 then return nil end\n  if k > #arr then\
    \ return arr end\n  local t = {}\n  for i = k, #arr do\n    if #t > 0 then\n \
    \     if arr[i] > arr[#t] then\n        t[#t] = arr[i]\n      end\n    else\n\
    \      t[#t] = arr[i]\n    end\n  end\n  return t\nend", "    if k > #arr then\
    \ return arr end\n    if k == 1 then return {arr[1]} end\n    local a = {}\n \
    \   local max_count = 0\n    for i = 1, k do\n        for j = 1, #arr do\n   \
    \         local d = arr[j] - arr[i-1]\n            if d > 0 then\n           \
    \     if d > max_count then\n                    max_count = d\n             \
    \       a = {arr[j], arr[i-1]}\n                elseif d == max_count then\n \
    \                   table.insert(a, arr[j])\n                end\n           \
    \ end\n        end\n    end\n    return a\nend", "  assert(k and k > 0, 'k must\
    \ be positive')\n  assert(k and k<=1000, 'k must be in range [1,1000)')\n  local\
    \ ret = {}\n  for i = 1,k do\n    table.insert(ret, table.remove(arr, i))\n  end\n\
    \  return ret\nend", "   local t = {}\n   for i = 1, k do\n      if i == k then\
    \ break end\n      t[i] = arr[i]\n   end\n   if k > 1 then\n      for i = k +\
    \ 1, #t do\n         t[i] = t[i - 1]\n      end\n   end\n   return t\nend", "\t\
    if k == 0 then\n\t\treturn arr\n\tend", "    if k == nil then\n        k = 1\n\
    \    end\n    local max_arr = {}\n    local cur_max = 0\n    local count = 0\n\
    \    for i = 1, k do\n        count = count + 1\n        local cur_val = arr[count]\n\
    \        if cur_max < cur_val then\n            cur_max = cur_val\n        end\n\
    \        max_arr[count] = cur_val\n    end\n    for i = count, k + #arr do\n \
    \       local cur_val = arr[i]\n        if cur_max < cur_val then\n          \
    \  cur_max = cur_val\n        end\n        max_arr[i - 1] = cur_val\n    end\n\
    \    return max_arr\nend", "   local results = {}\n   for _, v in ipairs(arr)\
    \ do\n      results[v] = true\n   end\n   local maxes = math.min(k, #results)\n\
    \   for i = 1, maxes do\n      local v = results[#results]\n      results[#results]\
    \ = nil\n      table.insert(results, v)\n   end\n   return results\nend", "  \
    \  local n = #arr\n    local result = {}\n    result[1] = arr[1]\n    for i =\
    \ 2, k do\n        local maxIndex = i\n        for j = 2, n do\n            if\
    \ arr[j] > result[maxIndex] then\n                maxIndex = j\n            end\n\
    \        end\n        result[i] = arr[maxIndex]\n    end\n    return result\n\
    end", "   -- Write your code here.\n   assert(k > 0 and k < len(arr))\n   \n \
    \  local max_table = arr\n   local max_index = 1\n   local max_value = max_table[1]\n\
    \   \n   for i = 2, k do\n      if max_value < max_table[i] then\n         max_index\
    \ = i\n         max_value = max_table[i]\n      end\n   end\n   \n   if max_index\
    \ == k then\n      return max_table\n   else\n      return maximum(max_table,\
    \ k - 1)\n   end\nend\nprint(maximum({-3, -4, 5}, 3))\nprint(maximum({4, -4, 4},\
    \ 2))\nprint(maximum({-3, 2, 1, 2, -1, -2, 1}, 1))\n</cell>\n<text>\n4.2.4 Binary\
    \ Search\nWrite a function to search for a given element in a given sorted array\
    \ arr. If the element is not found, return the index where it would be inserted\
    \ in the array.", "  local n = #arr\n  local m = math.min(k, n)\n  local i = math.max(k,\
    \ 1)\n  local arr = setmetatable({}, {__mode=\"v\"}) or {}\n  for j = 1, m do\n\
    \    local m = i - j\n    local max_value = arr[m]\n    for i = m + 1, n do\n\
    \      arr[i] = arr[i - m]\n    end\n    arr[m] = arr[i]\n  end\n  return arr\n\
    end", "\tlocal tmp = {}\n\t\n\t-- We sort arr in descending order and put largest\
    \ elements at the end.\n\ttable.sort(arr, function(a, b) return a > b end)\n\t\
    for i = #arr, 1, -1 do\n\t\tif tmp[#tmp] == nil then\n\t\t\ttmp[#tmp] = arr[i]\n\
    \t\telse\n\t\t\ttmp[#tmp] = arr[i] if arr[i] > tmp[#tmp] else tmp[#tmp]\n\t\t\
    end\n\tend\n\t\n\t-- Return an array of length k with the largest elements at\
    \ the end.\n\tif k == 1 then\n\t\treturn tmp\n\telse\n\t\tlocal ans = {}\n\t\t\
    for i = 1, k do\n\t\t\tans[i] = tmp[i]\n\t\tend\n\t\treturn ans\n\tend\nend",
  "   local m = {}\n   local n = #arr\n   local i = 1\n   while (i <= n) do \n   \
    \   m[i] = arr[i]\n      i = i + 1\n   end\n   i = k\n   while (i <= n) do\n \
    \     if (m[i] > m[i - 1])\n      then\n         local aux = m[i]\n         m[i]\
    \ = m[i - 1]\n         m[i - 1] = aux\n      end\n      i = i + 1\n   end\n  \
    \ return m\nend", "  local table = {}\n  for i = 1, k do\n    table.insert(table,\
    \ arr[i])\n  end", "  assert(k > 0 and k <= #arr, \"Wrong k value\")\n  \n  local\
    \ arr2 = {}\n  \n  for i = 1, k do\n    arr2[i] = arr[i]\n  end\n  \n  local max\
    \ = 0\n  for i = k - 1, #arr do\n    if arr2[i] > arr[max] then\n      max = i\n\
    \    end\n  end\n  \n  for i = 1, k do\n    arr2[i] = arr[max]\n  end\n  \n  return\
    \ arr2\nend", "  if k == 1 then\n    return {arr[1], arr[1], arr[1]}\n  else\n\
    \    local result = {}\n    local len = #arr\n    local count = 0\n    for i =\
    \ 1, k do\n      count = count + 1\n      local min = math.min(arr[count], math.max(arr[count\
    \ + 1], arr[len]))\n      result[count] = min\n    end\n    return unpack(result)\n\
    \  end\nend", "\t-- Create a table of size k to hold the maximum element \n\t\
    -- from the given array arr. \n\t-- The array arr will be modified to hold the\
    \ maximum element of arr.\n\t-- Space complexity : O(k).\n\t-- Time complexity\
    \ : O(k).\n\t-- Algorithm : Dynamic Programming solution.\n\tassert(k > 0, \"\
    Number of elements in a table must be positive.\")\n\t\n\tlocal table = {}\n\t\
    local index = 1\n\ttable[index] = arr[1]\n\tfor i = 2, k do\n\t\tlocal max = 0\n\
    \t\tfor j = 1, index do\n\t\t\tif arr[j] > max then\n\t\t\t\tmax = arr[j]\n\t\t\
    \tend\n\t\tend\n\t\tindex = index + 1\n\t\ttable[index] = max\n\tend\n\t\n\treturn\
    \ table\nend", "  local result = {}\n  for i = 1, k do\n    local value = arr[1]\n\
    \    for j = 2, #arr do\n      if value > arr[j] then\n        value = arr[j]\n\
    \      end\n    end\n    result[i] = value\n  end\n  return result\nend", "  --\
    \ Find out the max number in the arr\n  local max_idx = arr[1]\n  for i = 2, k\
    \ do\n    if arr[i] > arr[max_idx] then\n      max_idx = i\n    end\n  end\n \
    \ -- Return the max number and the index\n  return arr[max_idx], max_idx\nend",
  "    local _arr = {}\n    local _max = -1\n    \n    local function sort(i, val)\n\
    \        if val > _max then\n            _max = val\n        end\n    end\n  \
    \  \n    local function fill()\n        for i = 1, k do\n            _arr[i] =\
    \ _max\n        end\n    end\n    \n    if k == 1 then\n        for i = 1, #arr\
    \ do\n            _arr[i] = arr[i]\n        end\n        sort(1, arr[1])\n   \
    \     return { _arr, _max }\n    end\n    \n    for i = 1, #arr do\n        if\
    \ arr[i] < arr[_max] then\n            sort(i, arr[i])\n        end\n    end\n\
    \    \n    fill()\n    \n    for i = 1, k do\n        _arr[i] = arr[_max]\n  \
    \  end\n    \n    return { _arr, _max }\nend", "\tif k <= 0 or k < 1 or k > #arr\
    \ then return nil end\n\tlocal m = math.min(k, #arr)\n\tlocal t = {}\n\tfor i\
    \ = 1, m do\n\t\tlocal r = arr[i]\n\t\tt[#t + 1] = max(r, t[#t])\n\tend\n\treturn\
    \ t\nend", "  if k > #arr then return arr end\n  if k == 0 then return arr end\n\
    \  local table = arr\n  table.sort(function(a, b) return a > b end)\n  local result\
    \ = {}\n  for i = 1, k do\n    result[i] = table[#table]\n    table.remove(table)\n\
    \  end\n  return result\nend", "  if k == nil then return arr end\n  local result\
    \ = {}\n  -- Initialize result array\n  for i = 1, k do\n    result[i] = -1000\n\
    \  end\n  -- Set initial pivot element\n  local pivot = arr[1]\n  -- Set pivot\
    \ value\n  local maxElement = -1000\n  -- Set the pointer to traverse the list\n\
    \  local pointer = 1\n  -- Traverse the list\n  for i = 2, #arr do\n    -- If\
    \ the current element is smaller than the pivot element\n    -- then swap current\
    \ element with the maximum element\n    if arr[i] < pivot then\n      arr[pointer],\
    \ arr[i] = arr[i], arr[pointer]\n      pointer = pointer + 1\n    end\n    --\
    \ Store the maximum element in the result array\n    if arr[i] > maxElement then\n\
    \      maxElement = arr[i]\n    end\n  end\n  -- If any element is not in result\
    \ array, add the pivot element\n  for i = 1, pointer + 1 do\n    result[i] = arr[i]\n\
    \  end\n  -- Return result array\n  return result\nend", "  -- base case\n  if\
    \ k == 0 or k > #arr then return end\n  \n  local arr1 = {}\n  local mx, i = arr[1],\
    \ 1\n  \n  -- Find the maximum element in the rest of the array\n  for i, v in\
    \ ipairs(arr) do\n    if v > mx then\n      mx = v\n    end\n  end\n  \n  -- Add\
    \ the maximum to the front of the table\n  arr1[1] = mx\n  \n  -- find the maximum\
    \ after the first k-1 elements\n  for i, v in ipairs(arr) do\n    if i >= k then\
    \ break end\n    if v > arr1[i] then\n      arr1[i] = v\n    end\n  end\n  \n\
    \  return arr1\nend", "  local t = {}\n  local pos = 1\n  for i = 1, k do\n  \
    \  if pos > #arr then\n      break\n    end\n    local v = arr[pos]\n    arr[pos]\
    \ = -1000\n    if v > -1000 then\n      table.insert(t, v)\n    end\n    pos =\
    \ pos + 1\n  end\n  if pos > #arr then\n    table.insert(t, arr[pos])\n  end\n\
    \  table.sort(t, function(a, b) return a > b end)\n  return t\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
