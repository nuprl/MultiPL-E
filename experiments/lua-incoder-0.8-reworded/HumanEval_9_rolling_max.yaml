name: HumanEval_9_rolling_max
language: lua
prompt: "-- From a given table of integers, generate a table of rolling maximum element\
  \ found until given moment\n-- in the sequence.\n-- >>> rolling_max({1, 2, 3, 2,\
  \ 3, 4, 2})\n-- {1, 2, 3, 3, 3, 4, 4}\nlocal function rolling_max(numbers)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rolling_max\n\
  \    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, 2, 3,\
  \ 4}), {1, 2, 3, 4})\n    lu.assertEquals(candidate({4, 3, 2, 1}), {4, 4, 4, 4})\n\
  \    lu.assertEquals(candidate({3, 2, 3, 100, 3}), {3, 3, 3, 100, 100})\nend\n\n\
  os.exit(lu.LuaUnit.run())"
completions: ["\tlocal rolling_max = nil\n\tfor i = 1, #numbers do\n\t\tlocal element\
    \ = numbers[i]\n\t\twhile i > 1 and element > numbers[i - 1] do\n\t\t\t-- TODO:\
    \ replace this with ipairs function call or a for loop\n\t\t\ti = i - 1\n\t\t\
    end\n\t\trolling_max = element if rolling_max ~= nil then\n\t\t\trolling_max =\
    \ element\n\t\telse\n\t\t\trolling_max = element\n\t\tend\n\tend\n\treturn rolling_max\n\
    end", "    local maxes = {}\n    local last = {}\n    local last_max = 0", " \
    \ local rolling_max = {}\n  for i = 1, #numbers do\n    local current = numbers[i]\n\
    \    for j = i-1, 1, -1 do\n      if numbers[j] <= current then\n        current\
    \ = numbers[j]\n      else\n        break\n      end\n    end\n    table.insert(rolling_max,\
    \ current)\n  end\n  return rolling_max\nend", "  local max = -1\n  local index\
    \ = 1\n  for i = 1, #numbers do\n    if numbers[i] > max then\n      max = numbers[i]\n\
    \      index = i\n    end\n  end\n  return max\nend", "  assert(#numbers > 0,\
    \ \"Input vector is empty.\")\n  local rolling_max = {}\n  for i = 1, #numbers\
    \ do\n    rolling_max[i] = numbers[i]\n  end\n  for i = 1, #numbers do\n    for\
    \ j = 0, i - 1 do\n      rolling_max[j] = numbers[j] > rolling_max[j] and\n  \
    \      numbers[j] or rolling_max[j]\n    end\n  end\n  return rolling_max\nend",
  "  local max = {}\n  for i=1,#numbers do\n    local found = false\n    for j = 1,#max\
    \ do\n      if max[j] >= numbers[i] then\n        max[j+1] = max[j]\n        found\
    \ = true\n      end\n    end\n    if not found then max[#max+1] = numbers[i] end\n\
    \  end\n  return max\nend", "  return setmetatable({}, { __index = function(self,\
    \ t)\n    local max = t[1]\n    for _, v in ipairs(t) do\n      if v > max then\
    \ max = v end\n    end\n    return max\n  end})\nend", "  local rolling_max =\
    \ nil\n  local last_value\n  for number, value in pairs(numbers) do\n    if last_value\
    \ and last_value > number then\n      table.insert(rolling_max, last_value)\n\
    \    end\n    table.insert(rolling_max, number)\n    last_value = value\n  end\n\
    \  return rolling_max\nend", "  local results = {}\n  for _, v in pairs(numbers)\
    \ do\n    table.insert(results, v)\n  end\n  return table.merge(rolling_max(table.drop(results,\
    \ 1, nil)), results)\nend", "    assert(numbers[1] == nil, \"The input table should\
    \ be sorted\")\n    local i = 2\n    local max = numbers[1]\n    local max_element\
    \ = numbers[2]\n    while i < #numbers do\n        if numbers[i] > max then\n\
    \            max = numbers[i]\n            max_element = numbers[i]\n        else\n\
    \            max = max .. \",\"  .. numbers[i]\n        end\n        i = i + 1\n\
    \    end\n    return max_element\nend", "    local sizes = {}\n    local max =\
    \ 0\n    for _, x in ipairs(numbers) do\n        sizes[#sizes + 1] = x\n     \
    \   if x > max then\n            max = x\n        end\n    end\n    \n    local\
    \ output = {}\n    for i = 1, #sizes do\n        table.insert(output, max)\n \
    \   end\n    return output\nend", "  return coroutine.wrap(function()\n    local\
    \ current_max\n    local current_index\n    local current_min = tonumber(numbers[1])\n\
    \    local current_sum = tonumber(numbers[2])\n    local current_index = 1\n \
    \   local current_sum = current_sum + current_min\n    local current_index = current_index\
    \ - 1", "  local result = {}\n  for i = 1, #numbers do\n    local value = numbers[i]\n\
    \    if #result == 0 then\n      table.insert(result, value)\n    else\n     \
    \ local previousValues = result[#result - 1]\n      for _, previousValue in ipairs(previousValues)\
    \ do\n        if value >= previousValue then\n          break\n        else\n\
    \          table.insert(result, previousValue)\n        end\n      end\n    end\n\
    \  end\n  return result\nend", '  local rolling_max = numbers.new()', "    local\
    \ max_val = 0\n    local max_idx = 0\n    for i=1,#numbers do\n        local el\
    \ = numbers[i]\n        if el > max_val then\n            max_val = el\n     \
    \       max_idx = i\n        end\n    end\n    return numbers[max_idx]\nend",
  "  local rolling_max = { }\n  for i = 1, #numbers do\n    local value\n    local\
    \ rolling_max_value = nil\n    for j = 1, #rolling_max do\n      value = numbers[j]\n\
    \      if value > rolling_max_value then\n        rolling_max_value = value\n\
    \      end\n    end\n    table.insert(rolling_max, rolling_max_value)\n  end\n\
    \  return rolling_max\nend", "  local size = #numbers\n  local table = {}\n  for\
    \ i = 1, size do\n    table[i] = numbers[i]\n    table.insert(table, table[i])\n\
    \  end\n  return table\nend", "  local rolling_max = { }\n  local last_num = 0\n\
    \  local cur_max = 0\n  local index = 0\n  for i = 1, #numbers do\n    if numbers[i]\
    \ > last_num then\n      index = i - 1\n      rolling_max[index] = cur_max\n \
    \     last_num = numbers[i]\n      cur_max = numbers[i]\n    else\n      cur_max\
    \ = max(numbers[i], cur_max)\n    end\n  end\n  rolling_max[index] = cur_max\n\
    \  return rolling_max\nend", "  local results = {}\n  for i = 1, #numbers do\n\
    \    local value\n    if #results == 0 then\n      value = numbers[i]\n    else\n\
    \      value = results[#results]\n    end\n    if value > numbers[i] then\n  \
    \    results[#results+i] = value\n    end\n  end\n  return results\nend", "  local\
    \ rolling_max = numbers.new()\n  for i = 1, #numbers + 1 do\n    local max_pos\
    \ = i\n    for j = 1, #numbers + i - 1 do\n      if numbers[j] > numbers[max_pos]\
    \ then\n        max_pos = j\n      end\n    end\n    table.insert(rolling_max,\
    \ numbers[max_pos])\n  end\n  return rolling_max\nend", "  if #numbers == 0 then\n\
    \    return {}\n  end\n  local results = {}\n  for i = 1, #numbers do\n    local\
    \ maxi = i\n    for j = i + 1, #numbers do\n      if numbers[j] > numbers[maxi]\
    \ then\n        maxi = j\n      end\n    end\n    results[i] = numbers[maxi]\n\
    \  end\n  return results\nend", "  local last_val = nil\n  local max_idx = nil\n\
    \  for i = 1, #numbers do\n    if not last_val then\n      last_val = numbers[i]\n\
    \      max_idx = i\n    else\n      if numbers[i] ~= last_val then\n        if\
    \ max_idx then\n          numbers[max_idx] = numbers[max_idx] + numbers[i]\n \
    \       else\n          numbers[max_idx] = numbers[i]\n        end\n      end\n\
    \      last_val = numbers[i]\n    end\n  end\n  return numbers\nend", "  local\
    \ max = {}\n  for i = 1, #numbers do\n    local tmp = max[i - 1] or 0\n    max[#max\
    \ + 1] = numbers[i]\n    if tmp > numbers[i] then\n      tmp, max[i] = numbers[i],\
    \ tmp\n    end\n  end\n  return max\nend", "  local max, i = nil, 0\n  for i =\
    \ 1, #numbers do\n    max = math.max(numbers[i], max)\n  end\n  return max\nend\n\
    </code>\nThe above code will work for arrays of any size as long as you always\
    \ have numbers to compare.\n<|/ a |>\n<| c |>\nThanks so much for this! It turns\
    \ out the problem I was having was that I was using `tables.max` on the output\
    \ of another function, rather than on the original input, which caused the `#max`\
    \ operation to always return 0, giving no results. Changing it to work on `numbers`\
    \ solved it.\n<|/ c |>\n<| a |>\nI believe this is what you want:\n<code>", "\t\
    local max_element = nil\n\tlocal max_elements = {}\n\tlocal i = 0\n\tfor i = 1,\
    \ #numbers do\n\t\tif numbers[i] > max_element then\n\t\t\tmax_element = numbers[i]\n\
    \t\t\tmax_elements[i] = 1\n\t\telse\n\t\t\tmax_elements[i] = max_elements[i] +\
    \ 1 -- Increment by 1 to make sure we get all the max elements\n\t\t\tif max_elements[i]\
    \ >= rolling_max_number then\n\t\t\t\tmax_element = max_elements[i]\n\t\t\t\t\
    max_elements[i] = 1\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\t\
    return max_elements\nend", "  local rolling_max = numbers.next\n  while true do\n\
    \    local max_element = rolling_max()\n    if max_element == nil then break end\n\
    \    local max_idx = nil\n    for i = 1, #numbers do\n      if numbers[i] ~= max_element\
    \ then\n        if max_idx == nil then\n          max_idx = i\n        else\n\
    \          max_idx = max_idx\n        end\n      end\n    end\n    if max_idx\
    \ then\n      rolling_max = function(ns)\n        local result = {}\n        local\
    \ idx = 0\n        for i = 1, #ns do\n          if ns[i] ~= max_element and idx\
    \ == 0 then\n            max_element = ns[i]\n            idx = i\n          end\n\
    \          result[#result + 1] = ns[i]\n        end\n        result[#result +\
    \ 1] = max_element\n        return result\n      end\n    end\n  end\n  return\
    \ rolling_max\nend", "  if #numbers == 1 then\n    return numbers\n  end", " \
    \ local rolling_max = {}\n  local max_element", "  local rolling_max = math.max\n\
    \  local rolling_min = math.min", '  local result = {}', "    local max_value\
    \ = nil\n    local max_index = nil\n    local index = 1\n    local max_number\
    \ = numbers[1]\n    for i = 2, #numbers do\n        if numbers[i] > max_number\
    \ then\n            max_index = index\n            max_number = numbers[i]\n \
    \       else\n            max_index = index\n            max_number = numbers[i]\n\
    \        end\n        index = index + 1\n    end\n    return max_number, max_index\n\
    end", "  local max = numbers.[1]\n  local max_so_far = numbers.[1]\n  for i=2,#numbers\
    \ do\n    if numbers[i] ~= max then\n      max = numbers[i]\n      max_so_far\
    \ = numbers[i]\n    end\n  end\n  return max_so_far\nend", "\tlocal max = numbers[1]\n\
    \tfor i = 2, #numbers do\n\t\tmax = max > numbers[i] and max or numbers[i]\n\t\
    end\n\treturn max\nend", "\tlocal result = {}\n\tfor _, value in ipairs(numbers)\
    \ do\n\t\tresult[#result+1] = value\n\tend\n\tlocal max_value = 0\n\tlocal max_pos\
    \ = 0\n\tfor i, value in ipairs(result) do\n\t\tif value > max_value then\n\t\t\
    \tmax_value = value\n\t\t\tmax_pos = i\n\t\tend\n\tend\n\tfor i, value in ipairs(result)\
    \ do\n\t\tif value == max_value then\n\t\t\tresult[i] = result[i-1]\n\t\tend\n\
    \tend\n\treturn result\nend", "\tlocal current_max = numbers[1]\n\tlocal current_max\
    \ = math.max(current_max, numbers[1])\n\tfor i = 2, #numbers do\n\t\tlocal n =\
    \ numbers[i]\n\t\tlocal max_after_n = current_max\n\t\tif max_after_n < n then\n\
    \t\t\tcurrent_max = n\n\t\telse\n\t\t\tlocal max_after_max_after_n = math.max(max_after_n,\
    \ current_max)\n\t\t\tcurrent_max = max_after_max_after_n\n\t\tend\n\tend\n\t\
    return current_max\nend", '   local maxes = numbers.max', "  assert(numbers:numel()\
    \ == 1)\n  local max_val, idx = numbers[1][1], 1\n  local max_element = numbers[1][idx]\n\
    \  for i = 2, numbers:numel() do\n    if numbers[i][1] > max_val then\n      max_val\
    \ = numbers[i][1]\n      idx = i\n    end\n  end\n  return numbers[(max_val+1)::int]\n\
    end", "   local rolling_max = setmetatable({}, {\n      __index = function(t,\
    \ i)\n         return t.rolling_max or {}\n      end,\n      __newindex = function(self,\
    \ i, val)\n         if val > self.rolling_max[i] then\n            self.rolling_max[i]\
    \ = val\n         end\n      end\n   })\n   table.sort(numbers)\n   for i, v in\
    \ ipairs(numbers) do\n      rolling_max[v] = rolling_max[v] or {}\n      for j\
    \ = #rolling_max, 1, -1 do\n         local candidate = rolling_max[j]\n      \
    \   if v < candidate[v] then\n            table.insert(rolling_max[j], v)\n  \
    \          break\n         end\n      end\n   end\n   return rolling_max\nend",
  "  local results = {}\n  local prev = 1\n  for i = 1, #numbers do\n    if numbers[i]\
    \ > prev then\n      table.insert(results, numbers[i])\n    else\n      prev =\
    \ numbers[i]\n    end\n  end\n  return results\nend", "  return setmetatable({\
    \ numbers = numbers }, { __index = rolling_max })\nend", "  local max_so_far =\
    \ nil\n  local max_in_window = nil\n  local max_index = 0\n  for i = 1, #numbers\
    \ do\n    -- Skip the largest number in window\n    if max_so_far == nil or max_so_far\
    \ > numbers[i] then\n      max_so_far = numbers[i]\n      max_in_window = max_so_far\n\
    \      max_index = i\n      continue\n    end\n    -- If new max is larger, remember\
    \ it\n    if numbers[i] > max_in_window then\n      max_in_window = numbers[i]\n\
    \      max_index = i\n    end\n  end\n  return max_in_window, max_index\nend",
  "  local rolling_max = numbers.new()\n  local i = 1\n  while i < #numbers do\n \
    \   rolling_max[i] = max(numbers[i], rolling_max[i])\n    i = i + 1\n  end\n \
    \ return rolling_max\nend", '  local result = {}', "   local rolling_max = {}\n\
    \   local index = nil", "  local last_max = numbers[1]\n  for i = 2, #numbers\
    \ do\n    if numbers[i] ~= last_max then\n      last_max = numbers[i]\n    end\n\
    \  end\n  return last_max\nend", "    local rolling_maxes = {}\n    for _, value\
    \ in ipairs(numbers) do\n        table.insert(rolling_maxes, value)\n    end\n\
    \    table.sort(rolling_maxes)", "   local function rolling_max1(table, num)\n\
    \      table[#table+1] = num\n      return table\n   end\n   \n   local maxes\
    \ = Vector(numbers[1])\n   for _, num in pairs(numbers) do\n      maxes:insert(rolling_max1(maxes,\
    \ num))\n   end\n   \n   return maxes\nend", "  local windows = {}\n  local max\
    \ = 0\n  local index = 1\n  local sum = 1\n  local length = #numbers\n  while\
    \ index <= length do\n    sum = sum + numbers[index]\n    if sum > max then\n\
    \      max = sum\n    end\n    windows[index] = sum\n    index = index + 1 --\
    \ For next iteration\n  end\n  return windows\nend", "\tlocal rolling = {}\n\t\
    local max = 0\n\tlocal index = #numbers\n\tlocal value = numbers[1]\n\twhile index\
    \ > 0 do\n\t\tif numbers[index] < value then\n\t\t\tmax = numbers[index]\n\t\t\
    end\n\t\trolling[#rolling + 1] = max(rolling[#rolling], max)\n\t\tindex = index\
    \ - 1\n\t\tvalue = value + 1\n\tend\n\treturn rolling\nend", "    local res =\
    \ {}\n    for i = 1, #numbers - 1 do\n        table.insert(res, numbers[i])\n\
    \        if numbers[i] > numbers[i - 1] and i ~= 1 then\n            table.insert(res,\
    \ numbers[i - 1])\n        end\n    end\n    return res\nend", "  local rolling_max\
    \ = {}\n  for i = 1, #numbers do\n    local elem = numbers[i]\n    if rolling_max[i\
    \ - 1] == nil then\n      rolling_max[i - 1] = 0\n    end\n    rolling_max[i]\
    \ = elem > rolling_max[i - 1] and elem or rolling_max[i - 1]\n  end\n  return\
    \ rolling_max\nend", "  if numbers == nil then return nil end\n  local rolling_max\
    \ = numbers[1]\n  local max_rolling = numbers[1]\n  for i = 2, #numbers do\n \
    \   if numbers[i] > max_rolling then\n      rolling_max = numbers[i]\n    elseif\
    \ numbers[i] ~= max_rolling and numbers[i] > rolling_max then\n      rolling_max\
    \ = numbers[i]\n    end\n  end\n  return rolling_max\nend", "  return function()\n\
    \    local max_number\n    local max_index\n    local number_index\n    for number_index,\
    \ number in pairs(numbers) do\n      if max_index == nil then\n        max_index\
    \ = number_index\n      else\n        if number >= max_number then\n         \
    \ max_index = nil\n        else\n          max_number = number\n        end\n\
    \      end\n    end\n    if max_index == nil then\n      return nil\n    end\n\
    \    local rolling_max_index\n    for rolling_max_index, rolling_max_number in\
    \ pairs(numbers) do\n      if rolling_max_index == max_index then\n        return\
    \ rolling_max_number\n      else\n        if rolling_max_number > max_number then\n\
    \          return rolling_max_number\n        else\n          max_number = rolling_max_number\n\
    \        end\n      end\n    end\n  end\nend", "  return table.concat({math.max(numbers)}):gmatch(\"\
    (%d+)\")\nend", "    local table = {}\n    for i = 1, #numbers do\n        local\
    \ last_element = numbers[i]\n        local new_element = numbers[i]\n        for\
    \ j = i+1, #numbers do\n            local element = numbers[j]\n            if\
    \ last_element < element then\n                new_element = element\n       \
    \     end\n            last_element = element\n        end\n        table[i] =\
    \ new_element\n    end\n    return table\nend", "    local rolling_max = {}\n\
    \    local i, n = #numbers, 1\n    while i do\n        rolling_max[n - 1] = numbers[i\
    \ - 1]\n        i, n = i - 1, n - 1\n    end\n    return rolling_max\nend", " \
    \ local result = {}\n  local current = nil\n  local i = 1\n  for v in pairs(numbers)\
    \ do\n    current = v\n    while i <= v do\n      result[i] = current -- Store\
    \ the rolling maximum\n      i = i + 1\n    end\n  end\n  return result\nend",
  "\tlocal max_value = numbers[1]\n\tlocal max_index = nil\n\tfor i = 2, #numbers\
    \ do\n\t\tif numbers[i] ~= max_value then\n\t\t\tmax_value = numbers[i]\n\t\t\t\
    max_index = i\n\t\tend\n\tend", "   local max_number = nil\n   for _, v in pairs(numbers)\
    \ do\n      if max_number == nil or v > max_number then\n         max_number =\
    \ v\n      end\n   end\n   return max_number\nend", "  local max, index = {},\
    \ 1\n  local done = false\n  for i = 1, #numbers do\n    local num = numbers[i]\n\
    \    local found = true\n    while found do\n      table.insert(max, num)\n  \
    \    if index > #max then break end\n      index = 1\n      found = false\n  \
    \    for j = i + 1, #numbers do\n        local next = numbers[j]\n        if num\
    \ > next then\n          index = j\n          found = true\n          break\n\
    \        end\n      end\n    end\n  end\n  return max\nend", "   local result\
    \ = {}\n   for i, x in pairs(numbers) do\n      if i >= 1 then\n         result[i]\
    \ = result[i - 1]\n      end\n      result[i] = x\n   end\n   return result\n\
    end", "  local n = 1\n  local m = numbers[1]\n  local results = {}\n  while n\
    \ <= #numbers do\n    if numbers[n] > m then\n      m = numbers[n]\n    end\n\
    \    results[n] = m\n    n = n + 1\n  end\n  return results\nend", "  assert(#numbers\
    \ > 0)\n  local max_so_far = numbers[1]\n  local index = 2\n  local max_so_far_index\
    \ = 1", "  local rolling_max = {}\n  local current = 0\n  local last_element =\
    \ 0\n  for i = 1, #numbers do\n    if numbers[i] <= current then\n      rolling_max[#rolling_max\
    \ + 1] = numbers[i]\n      current = numbers[i]\n    else\n      rolling_max[#rolling_max\
    \ + 1] = last_element\n      last_element = numbers[i]\n      current = numbers[i]\n\
    \    end\n  end\n  rolling_max[#rolling_max + 1] = last_element\n  return rolling_max\n\
    end", "  return \n    numbers \n    |> Set() \n    |> Set.toSeq() \n    |> Seq.map(function(a)\
    \ rolling_max(a |> Seq.take(numbers - 1) |> Seq.toArray) + a) \n    |> Seq.toArray()\n\
    end", "    local ret = {}\n    for i = 1, #numbers do\n        local _, max =\
    \ numbers[i]\n        for j = 1, i + 1 do\n            _, max = max > numbers[j]\
    \ and max or numbers[j]\n        end\n        ret[#ret+1] = max\n    end\n   \
    \ return ret\nend", "\tlocal result = {}\n\tlocal max = 0\n\tfor _, value in ipairs(numbers)\
    \ do\n\t\tif value > max then\n\t\t\tmax = value\n\t\tend\n\tend\n\tfor _, value\
    \ in ipairs(numbers) do\n\t\tif value == max then\n\t\t\ttable.insert(result,\
    \ max)\n\t\tend\n\tend\n\treturn result\nend", "  local function roll(table, length)\n\
    \    local new_table = {}\n    for i, value in pairs(table) do\n      new_table[i]\
    \ = value or 0\n    end\n    if length == 0 then\n      return new_table\n   \
    \ end\n    local max_so_far = math.max(1, new_table[1])\n    for i, value in pairs(new_table)\
    \ do\n      max_so_far = math.max(max_so_far, value)\n      if i == length then\n\
    \        new_table[i] = max_so_far\n      end\n    end\n    return new_table\n\
    \  end\n  return roll(numbers, #numbers)\nend", "  local max_i = numbers.n\n \
    \ local max_v = numbers.v\n  for i = 1, numbers.n do\n    if numbers.v[i] > max_v\
    \ then\n      max_i = i\n      max_v = numbers.v[i]\n    end\n  end\n  local max_number\
    \ = numbers.v[max_i]\n  local max_number = max_number + 1\n  local max_i = 1\n\
    \  local max_v = 0\n  for i = 2, numbers.n do\n    if numbers.v[i] > max_v then\n\
    \      max_i = i\n      max_v = numbers.v[i]\n    end\n  end\n  local max_number\
    \ = numbers.v[max_i]\n  local max_number = max_number + 1\n  local max_i = 1\n\
    \  local max_v = numbers.v[1]\n  for i = 2, numbers.n do\n    if numbers.v[i]\
    \ > max_v then\n      max_i = i\n      max_v = numbers.v[i]\n    end\n  end\n\
    \  local max_number = numbers.v[max_i]\n  local max_number = max_number + 1\n\
    \  local max_i = 1\n  local max_v = numbers.v[1]\n  for i = 2, numbers.n do\n\
    \    if numbers.v[i] > max_v then\n      max_i = i\n      max_v = numbers.v[i]\n\
    \    end\n  end\n  local max_number = numbers.v[max_i]\n  local max_number = max_number\
    \ + 1\n  local max_i = 1\n  local max_v = numbers.v[1]\n  for i = 2, numbers.n\
    \ do\n    if numbers.v[i] > max_v then\n      max_i = i\n      max_v = numbers.v[i]\n\
    \    end\n  end\n  local max_number = numbers.v[max_i]\n  local max_number = max_number\
    \ + 1\n  local max_i = 1\n  local max_v = numbers.v[1]\n  for i = 2, numbers.n\
    \ do\n    if numbers.v[i] > max_v then\n      max_i = i\n      max_v = numbers.v[i]\n\
    \    end\n  end\n  local max_number = numbers.v[max_i]\n  local max_number = max_number\
    \ + 1\n  local max_i = 1\n  local max_v = numbers.v[1]\n  for i = 2, numbers.n\
    \ do\n    if numbers.v[i] > max_v then\n      max_i = i\n      max_v = numbers.v[i]\n\
    \    end\n  end\n  local max_number = numbers.v[max_i]\n  local max_number = max_number\
    \ + 1\n  local max_i = 1\n  local max_v = numbers.v[1]\n  for i = 2, numbers.n\
    \ do\n    if numbers.v[i] > max_v then\n      max_i = i\n      max_v = numbers.v[i]\n\
    \    end\n  end\n  local max_number = numbers.v[max_i]\n  local max_number = max_number\
    \ + 1\n  local ", "  local result = {}\n  local maximum = numbers[1]\n  for i\
    \ = 2, #numbers do\n    if maximum < numbers[i] then\n      maximum = numbers[i]\n\
    \    end\n    result[#result + 1] = maximum\n  end\n  return result\nend", " \
    \ local rolling_max = tables.newlist()\n  local max_number = numbers[1]\n  for\
    \ i = 1, #numbers do\n    if numbers[i] > max_number then\n      rolling_max[#rolling_max\
    \ + 1] = numbers[i]\n      max_number = numbers[i]\n    else\n      rolling_max[#rolling_max\
    \ + 1] = max_number\n      max_number = numbers[i]\n    end\n  end\n  rolling_max[#rolling_max\
    \ + 1] = max_number\n  return rolling_max\nend", "  local max = 1\n  local result\
    \ = {}\n  for _, value in ipairs(numbers) do\n    max = math.max(max, value)\n\
    \  end\n  for _, value in ipairs(numbers) do\n    if value == max then\n     \
    \ table.insert(result, max)\n    else\n      max = math.max(max, value)\n    end\n\
    \  end\n  return result\nend", "    local values = {}\n    for _, number in pairs(numbers)\
    \ do\n        table.insert(values, math.max(number))\n    end\n    return values\n\
    end", "  if #numbers == 0 then\n    return {{}}\n  end\n  local max_so_far = numbers[1]\n\
    \  local max_element = numbers[1]\n  for i = 2, #numbers do\n    if numbers[i]\
    \ < max_element then\n      max_element = max_element\n    else\n      max_element\
    \ = numbers[i]\n    end\n    if max_element > max_so_far then\n      max_so_far\
    \ = max_element\n    end\n  end\n  return {{max_so_far}}\nend", "  local rolling_maxes\
    \ = {}\n  local i = 0\n  local j = 1\n  for n in pairs(numbers) do\n    rolling_maxes[#rolling_maxes\
    \ + 1] = n\n    i = i + 1\n    j = j + 1\n  end\n  while i <= j do\n    local\
    \ max_number = 0\n    for k = 1, i do\n      if rolling_maxes[k] > max_number\
    \ then\n        max_number = rolling_maxes[k]\n      end\n    end\n    rolling_maxes[i\
    \ - 1] = max_number\n    i = i + 1\n  end\n  return rolling_maxes\nend", "  local\
    \ max_idx = 1\n  local max_val = numbers[1]\n  for i = 2, #numbers do\n    if\
    \ numbers[i] > max_val then\n      max_idx = i\n      max_val = numbers[i]\n \
    \   end\n  end\n  table.insert(numbers, max_idx)\n  return numbers\nend", "  local\
    \ rolling_max = terralib.newlist()\n  local last_value = terralib.newsymbol(number)\n\
    \  for _, value in ipairs(numbers) do\n    if value == last_value then\n     \
    \ rolling_max:insert(value)\n    else\n      rolling_max:insert(value)\n     \
    \ last_value = value\n    end\n  end\n  rolling_max:insert(last_value)\n  rolling_max:append(1)\n\
    \  return rolling_max\nend", "  local result = {}\n  local max_elem = numbers[1]\n\
    \  local max_index = nil\n  for index, value in pairs(numbers) do\n    if value\
    \ > max_elem then\n      max_elem = value\n      max_index = index\n    end\n\
    \  end\n  result[1] = max_elem\n  for index = 2, #numbers do\n    local max_elem\
    \ = numbers[index]\n    local max_index = nil\n    for index2, value2 in pairs(result)\
    \ do\n      if value2 > max_elem then\n        max_elem = value2\n        max_index\
    \ = index2\n      end\n    end\n    result[#result + 1] = max_elem\n  end\n  return\
    \ result\nend", "    if #numbers <= 1 then\n        -- Nothing to do, return the\
    \ original list.\n        return numbers\n    end\n    local output = {}\n   \
    \ for i = 2, #numbers do\n        output[#output + 1] = numbers[i - 1]\n    end\n\
    \    for i = 1, #numbers do\n        if output[i - 1] > numbers[i] then\n    \
    \        output[#output + 1] = numbers[i]\n        end\n    end\n    return output\n\
    end", "  local current = nil\n  local results = {}\n  for i = 1, #numbers do\n\
    \    -- Current element to be compared\n    current = numbers[i]\n    local minimum\
    \ = results[i]\n    -- If current is less than minimum, then set minimum to current\n\
    \    if current < minimum then\n      minimum = current\n    end\n    -- If the\
    \ current element is the same, then add the element to the results\n    if current\
    \ == minimum then\n      results[i] = minimum\n    else\n      -- If the current\
    \ element is not the same, then the previous element is the minimum\n      if\
    \ #results > 0 then\n        results[#results] = minimum\n      end\n    end\n\
    \  end\n  -- Return results\n  return results\nend", "    local rolling_max =\
    \ {}\n    local current_element", "    local max = {1, 1}\n    for i = 2, #numbers\
    \ do\n        for j = 1, #max do\n            if numbers[i] > max[j] then\n  \
    \              max[1] = numbers[i]\n                max[2] = numbers[i]\n    \
    \            return\n            elseif numbers[i] < max[j] then\n           \
    \     max[1] = max[j]\n                max[2] = numbers[i]\n                return\n\
    \            end\n        end\n        max[1] = numbers[i]\n    end\n    return\n\
    end", "  local buffer = {}\n  local pos = 1\n  local last = numbers[1]\n  local\
    \ last_max = last\n  for i = 2, #numbers do\n    if numbers[i] > last then\n \
    \     last = numbers[i]\n      buffer[#buffer + 1] = numbers[i]\n    end\n   \
    \ buffer[#buffer + 1] = last\n  end\n  last_max = last\n  for i = 1, #buffer -\
    \ 1 do\n    if buffer[i - 1] > buffer[i] then\n      last_max = buffer[i]\n  \
    \  end\n  end\n  return buffer\nend", "  local max_so_far = numbers[1]\n  for\
    \ i = 2, #numbers do\n    if numbers[i] > max_so_far then\n      max_so_far =\
    \ numbers[i]\n    end\n  end\n  return max_so_far\nend", "  assert(#numbers ~=\
    \ 0)\n  local max = numbers[1]\n  local max_found = true\n  for i = 2, #numbers\
    \ do\n    if numbers[i] > max then\n      max = numbers[i]\n      max_found =\
    \ false\n    end\n  end\n  return max_found and max or nil\nend", "  if not numbers\
    \ then return end\n  local min = table.remove_by_ref(numbers, 1)\n  if min ==\
    \ nil then return end\n  local max_ = min\n  for i = #numbers, 1, -1 do\n    local\
    \ x = numbers[i]\n    if x > max_ then\n      max_ = x\n    end\n  end\n  table.remove_by_ref(numbers,\
    \ 1)\n  return max_, numbers\nend", "  local max_index = #numbers + 1\n  local\
    \ result = {}\n  for i = 1, max_index do\n    table.insert(result, numbers[i -\
    \ 1])\n  end\n  return result\nend", "  if numbers == nil then\n    numbers =\
    \ {}\n  end\n  if #numbers == 0 then\n    return numbers\n  end\n  local i = 1\n\
    \  local accum = numbers[1]\n  local lastIdx = 1\n  local accumLen = 1\n  while\
    \ i <= #numbers do\n    accum = math.max(accum, numbers[i])\n    if accum > lastIdx\
    \ then\n      accumLen = i - lastIdx\n    end\n    lastIdx = i\n    i = i + 1\n\
    \  end\n  if accumLen > 0 then\n    table.insert(numbers, accum)\n  end\n  local\
    \ j = 1\n  while j <= #numbers do\n    numbers[j] = numbers[j] + numbers[j + 1]\n\
    \    j = j + 1\n  end\n  return numbers\nend", "  local result = {}\n  local max\
    \ = 0\n  for i = 1, #numbers do\n    if numbers[i] < max then\n      max = numbers[i]\n\
    \    else\n      result[#result + 1] = max\n      max = numbers[i]\n    end\n\
    \  end\n  result[#result + 1] = max\n  return result\nend", "  local results =\
    \ {}\n  for i = 1, #numbers do\n    table.insert(results, numbers[i])\n    if\
    \ i > 1 then\n      if numbers[i] ~= numbers[i - 1] + 1 then\n        table.insert(results,\
    \ numbers[i])\n      end\n    end\n  end\n  return results\nend\n</code>\nNow\
    \ we have the function we can apply to the input you supplied:\n<code>", "   \
    \ local maxElement = 0\n    local lastElement = nil\n    for i = 1, #numbers,\
    \ 1 do\n        if numbers[i] > maxElement then\n            maxElement = numbers[i]\n\
    \            lastElement = i\n        end\n    end\n    lastElement = lastElement\
    \ - 1\n    lastElement = lastElement + 1\n    return numbers[lastElement]\nend",
  "    local result = {}\n    for i, v in ipairs(numbers) do\n        result[i] =\
    \ v\n    end\n    local window = numbers[1]\n    for i, v in pairs(numbers) do\n\
    \        if v > window then\n            window = v\n        end\n    end\n  \
    \  for i, v in pairs(numbers) do\n        if v ~= window then\n            result[i]\
    \ = v\n        end\n    end\n    return result\nend", "    return unpack(\n  \
    \      table.sort(\n            unpack(\n                table.map(\n        \
    \            function(number)\n                        return math.max(number,\
    \ numbers[1])\n                    end,\n                    numbers,\n      \
    \              nil,\n                    true\n                )\n           \
    \ )\n        )\n    )\nend", "  local max = 0\n  local rolling_max = {}", "  \
    \  local function max_val(max)\n        return function ()\n            if max\
    \ ~= nil then\n                max = max or 0\n                return max\n  \
    \          end\n        end\n    end\n    local function rolling_max_helper(current_min,\
    \ min, current_max, max, max_value)\n        if current_max ~= nil then\n    \
    \        max = max or max_value\n        end\n        if current_min ~= nil then\n\
    \            min = min or current_min\n        end\n        if max < min then\n\
    \            return nil\n        end\n        return max, min\n    end\n    return\
    \ table.insert(numbers, numbers[1])\nend", "  return table.concat({numbers[1]},\
    \ table.take(numbers, 2))\nend", "  return setmetatable({}, {\n    __index = function(self,\
    \ n)\n      local max_so_far = numbers[1]\n      for i=2, #numbers do\n      \
    \  if numbers[i] < max_so_far then\n          max_so_far = numbers[i]\n      \
    \  end\n      end\n      return max_so_far\n    end\n  })\nend", "    -- Base\
    \ case\n    if #numbers == 1 then\n        local value = numbers[1]\n        return\
    \ {value}\n    end\n    -- Get first element\n    local value = numbers[1]\n \
    \   -- Iterate through all elements except first element\n    for i = 2, #numbers\
    \ do\n        value = math.max(value, numbers[i])\n    end\n    -- Return rolling\
    \ maximum found so far\n    return {value}\nend", "  local rolling_max = terralib.newlist()\n\
    \  local pos = 0\n  local i = 0\n  repeat\n    pos = pos + 1\n    i = i + 1\n\
    \    local elem = numbers[i]\n    if elem > rolling_max[pos] then\n      rolling_max[pos]\
    \ = elem\n    end\n  until pos == #numbers or i == #numbers\n  return rolling_max\n\
    end", "  local rolling_max = {}\n  for i = 1, #numbers do\n    table.insert(rolling_max,\
    \ numbers[i])\n    rolling_max[#rolling_max + 1] = -numbers[i]\n  end\n  table.sort(rolling_max)\n\
    \  return rolling_max\nend", "    local max_value = numbers[1]\n    local max_position\
    \ = numbers[1]\n    for i = 2, #numbers do\n        if max_value < numbers[i]\
    \ then\n            max_value = numbers[i]\n            max_position = i\n   \
    \     end\n    end\n    return max_position, max_value\nend", "    return table.totable(\n\
    \        table.toarray(numbers):map(function(n)\n            return n and { n\
    \ = n, e = n }\n        end)\n    ):map(function(e)\n        if e.n then\n   \
    \         if e.n > e.e then return e end\n            e.n = math.max(e.n, e.e\
    \ + e.n - e.e)\n        end\n        return e\n    end)\nend", "  return setmetatable({},\
    \ { __index = rolling_max_index })\nend", "  if numbers ~= nil then\n    if #numbers\
    \ <= 0 then\n      return nil\n    end\n    local max_rolling = numbers[1]\n \
    \   for i = 2, #numbers do\n      local rolling = numbers[i]\n      if rolling\
    \ > max_rolling then\n        max_rolling = rolling\n      end\n    end\n    return\
    \ max_rolling\n  else\n    return nil\n  end\nend", "  local r\n  for i = 1, numbers[#numbers]\
    \ do\n    r = r or {}\n    table.insert(r, numbers[i])\n  end\n  return r\nend",
  "    return table.concat(table.sort((numbers or {}).collect (function (number)\n\
    \        return number < number and\n            number > numbers[number] and\n\
    \            numbers[number] or\n            number\n    end)))\nend", "  local\
    \ result = {}\n  local max_value = numbers[1][1]\n  for _, number in pairs(numbers)\
    \ do\n    if number > max_value then\n      table.insert(result, max_value)\n\
    \      max_value = number\n    end\n  end\n  return result\nend", "  local max_element\
    \ = nil\n  for i = 1, #numbers do\n    if numbers[i] ~= nil then\n      max_element\
    \ = numbers[i]\n    end\n  end\n  return max_element\nend", '  local last_max_num
    = nil', '  assert(numbers:type() == "table")', "  local max_index = {}\n  local\
    \ max_element", "    local result = {}\n    local i = 1\n    local max = 1\n \
    \   while i < #numbers do\n        if numbers[i] > max then\n            result\
    \ = result or {}\n            result[i - 1] = numbers[i]\n            i = i +\
    \ 1\n            max = numbers[i]\n        else\n            max = max .. \",\"\
    \ .. numbers[i]\n        end\n        i = i + 1\n    end\n    return result\n\
    end", "  assert(#numbers ~= 0)\n  local result = {}\n  for i = 1, #numbers do\n\
    \    table.insert(result, math.max(numbers[i]))\n  end\n  \n  -- If there's only\
    \ one element, return it directly\n  if #result == 1 then\n    return { result[1]\
    \ }\n  end\n  \n  return result\nend", '  local rolling_max = table()', "  local\
    \ rolling_max_table = {}\n  local rolling_max_element = nil", '  local rolling_max
    = math.max', "  local rolling_max_table = {}\n  for i = 1, #numbers do\n    local\
    \ current_max = numbers[i]\n    for j = i + 1, #numbers do\n      local rolling_max\
    \ = numbers[j]\n      if current_max < rolling_max then\n        rolling_max_table[i]\
    \ = rolling_max\n        break\n      end\n    end\n  end\n  return rolling_max_table\n\
    end", "  local rolling_max = {}\n  for i = 1, #numbers do\n    table.insert(rolling_max,\
    \ numbers[i])\n  end\n  table.sort(rolling_max)\n  local max_i = 0\n  local max_number\
    \ = rolling_max[1]\n  for i = 2, #numbers do\n    if numbers[i] > max_number then\n\
    \      max_number = numbers[i]\n      max_i = i\n    end\n  end\n  return max_i,\
    \ max_number\nend", "  if not numbers then return end\n  local result = {}\n \
    \ local max_value = numbers[1]\n  for _, num in ipairs(numbers) do\n    if num\
    \ > max_value then max_value = num end\n  end\n  for i, num in ipairs(numbers)\
    \ do\n    if num >= max_value then result[i] = max_value end\n  end\n  return\
    \ result\nend", "  local max = numbers[1]\n  for _, elem in pairs(numbers[2:end])\
    \ do\n    if elem > max then max = elem end\n  end\n  return numbers\nend", " \
    \  local size = #numbers\n   local results = {}", "  local maxima = {}\n  for\
    \ i = 1, #numbers do\n    table.insert(maxima, numbers[i])\n  end\n  local i =\
    \ 1\n  local max_roll\n  local max_roll_element\n  local rolling_max\n  while\
    \ i <= #maxima do\n    local rolling_max_element = maxima[i]\n    table.insert(maxima,\
    \ rolling_max_element)\n    max_roll_element = rolling_max_element\n    for j\
    \ = i, #maxima do\n      if maxima[j] <= max_roll_element then\n        max_roll_element\
    \ = maxima[j]\n      else\n        break\n      end\n    end\n    table.insert(maxima,\
    \ rolling_max_element)\n    max_roll = max_roll_element\n    if i == 1 then\n\
    \      rolling_max = max_roll_element\n    else\n      rolling_max = max_roll\n\
    \    end\n    i = i + 1\n  end\n  return maxima\nend", "  local rolling_max =\
    \ numbers.max\n  if #numbers == 1 then return numbers end", "  if #numbers ==\
    \ 0 then\n    return {}\n  end\n  local max = {}\n  for i = 1, #numbers do\n \
    \   local value = numbers[i]\n    local previous = numbers[i - 1]\n    local maximum\n\
    \    if previous ~= nil and previous > value then\n      maximum = previous\n\
    \    else\n      maximum = value\n    end\n    table.insert(max, maximum)\n  end\n\
    \  return max\nend", "  if not numbers then return nil end\n  local rolling =\
    \ numbers[1]\n  local max = numbers[#numbers]\n  for i = 2, #numbers do\n    if\
    \ numbers[i] ~= max then\n      max = numbers[i]\n    end\n    rolling = rolling\
    \ or max\n  end\n  return rolling\nend", "  local rolling_max = nil\n  local i\
    \ = numbers.size - 1\n  while i > 0 do\n    if numbers[i] <= numbers[i - 1] +\
    \ 1 then\n      i = i - 1\n    else\n      rolling_max = numbers[i]\n      i =\
    \ i - 1\n    end\n  end\n  return rolling_max\nend", "  local max = numbers[1]\n\
    \  for i = 2, #numbers do\n    if numbers[i] > max then\n      max = numbers[i]\n\
    \    end\n  end\n  return max\nend", "  local result = {}\n  local i = 1\n  while\
    \ i < #numbers do\n    local idx = i - 1\n    local max_num = numbers[idx]\n \
    \   if max_num < numbers[i] then\n      result[idx] = max_num\n    end\n    i\
    \ = i + 1\n  end\n  return result\nend", "  local rolling_max_array = {}\n  local\
    \ rolling_max_index = nil\n  local rolling_max_value = nil\n  local i = 1\n  while\
    \ i <= #numbers and i <= (#numbers - 1) do\n    local value = numbers[i]\n   \
    \ rolling_max_index = i - 1\n    while rolling_max_index >= 0 and rolling_max_index\
    \ > 0 and numbers[rolling_max_index] > value do\n      rolling_max_value = numbers[rolling_max_index]\n\
    \      rolling_max_index = rolling_max_index - 1\n    end\n    rolling_max_array[i]\
    \ = rolling_max_value\n    i = i + 1\n  end\n  return rolling_max_array\nend",
  "  local max_idx = 1\n  local max_val = numbers[1]\n  for idx = 2, #numbers do\n\
    \    if numbers[idx] > max_val then\n      max_idx = idx\n      max_val = numbers[idx]\n\
    \    end\n  end\n  return max_idx, max_val\nend", "  local index = 1\n  local\
    \ max = numbers[1]\n  local max_rolling = 0\n  while index do\n    local rolling\
    \ = index\n    for i = 2, #numbers do\n      if numbers[i] >= max then\n     \
    \   index = i - 1\n        rolling = rolling - 1\n        max = numbers[i]\n \
    \     else\n        max = numbers[i]\n      end\n    end\n    max_rolling = max_rolling\
    \ + (rolling > 0)\n  end\n  return max_rolling\nend", "   local result = {}\n\
    \   for i = 1, #numbers do\n      result[i] = numbers[i]\n      while i <= numbers[i]\
    \ do\n         result[i] = max(result[i], numbers[i - 1] + 1)\n         i = i\
    \ + 1\n      end\n   end\n   return result\nend", "  local max = numbers[1]\n\
    \  for _, i in ipairs(numbers) do\n    max = max > i ? max : i\n  end\n  return\
    \ max\nend", "  local results = {}\n  local index = numbers[1]\n  local index\
    \ = tonumber(index)\n  if index == 0 then\n    return numbers\n  end\n  results[index]\
    \ = numbers[index]\n  while index ~= 0 do\n    index = math.min(index + math.ceil((numbers.table[index\
    \ + 1] - numbers.table[index])/numbers.table[index]), numbers.table[index + 1]\
    \ - 1)\n    results[index] = numbers[index]\n  end\n  return results\nend", " \
    \ local sum = 1\n  for i=1,#numbers do\n    sum = sum + numbers[i]\n    if sum\
    \ > #numbers then\n      return false\n    end\n  end\n  local result = {}\n \
    \ for i=1,#numbers do\n    result[i] = numbers[i]\n  end\n  local j = 1\n  while\
    \ #result > #numbers + j do\n    j = j + 1\n    for i=1,#numbers do\n      local\
    \ val = result[i]\n      if not result[i] then\n        result[i] = result[i-1]\n\
    \      else\n        result[i] = val\n      end\n    end\n  end\n  return result\n\
    end", "\tlocal maxElement = nil\n\tlocal maxIndex = nil\n\tfor index, number in\
    \ ipairs(numbers) do\n\t\tif maxElement == nil then\n\t\t\tmaxElement = number\n\
    \t\t\tmaxIndex = index\n\t\telseif number > maxElement then\n\t\t\tmaxElement\
    \ = number\n\t\t\tmaxIndex = index\n\t\tend\n\tend\n\treturn numbers, maxIndex,\
    \ maxElement\nend", "  local maxes = {}\n  for i = 1,#numbers do\n    local max\
    \ = 1\n    for j = 1,i do\n      local diff = numbers[j] - max\n      if diff\
    \ > max then\n        max = diff\n      end\n    end\n    maxes[i] = max\n  end\n\
    \  return maxes\nend", "  return function(t)\n    if t > #numbers then\n     \
    \ return nil\n    end\n    local v = numbers[t]\n    if t < #numbers then\n  \
    \    return rolling_max(numbers, t + 1\n            , v\n            , numbers[t]:max())\n\
    \    else\n      return {v}\n    end\n  end\nend", "  local maxes = {}\n  local\
    \ max = 0", "    local rolling_max = { }\n    for i, v in ipairs(numbers) do\n\
    \        rolling_max[#rolling_max + 1] = v -- Add element\n        -- Check if\
    \ current number in rolling max is smaller than the current\n        -- number\
    \ in rolling max. If it is, set new rolling max number to the current number\n\
    \        if rolling_max[#rolling_max] < rolling_max[i] then\n            rolling_max\
    \ = rolling_max\n        end\n    end\n    return rolling_max\nend", "    local\
    \ result = {}\n    for i = 1,#numbers do\n        table.insert(result, math.max(numbers[i]))\n\
    \    end\n    return result\nend", "    local table = {}\n    local rolling_max_index\
    \ = 0\n    for i, element in ipairs(numbers) do\n        table[element] = element\
    \ and table[i] or nil\n        if table[i] == nil then\n            table[i] =\
    \ element\n        else\n            if element < table[rolling_max_index] then\n\
    \                table[i] = nil\n            else\n                rolling_max_index\
    \ = i\n            end\n        end\n    end\n    return table\nend", "  local\
    \ max_value = nil\n  local max_index = nil\n  local i = nil", "   local rolling_max\
    \ = numbers.next\n   local last_elem = numbers.last\n   for i = 1, numbers.length\
    \ do\n      rolling_max = rolling_max and rolling_max(last_elem, i + 1)\n    \
    \  last_elem = numbers[i]\n   end\n   return rolling_max\nend", "  local rolling_max\
    \ = {}\n  for _, v in ipairs(numbers) do\n    table.insert(rolling_max, v)\n \
    \   if rolling_max[#rolling_max] == v then\n      rolling_max[#rolling_max] =\
    \ nil\n    end\n  end\n  return rolling_max\nend", "   local rolling_max = numbers.new()\n\
    \   for i = 1, #numbers do\n      local value = numbers[i]\n      while #rolling_max\
    \ > #numbers then rolling_max:append(math.nan) end\n      rolling_max[#rolling_max+1]\
    \ = value\n   end\n   return rolling_max\nend", "\tlocal max = numbers[1]\n\t\
    for i = 2, #numbers do\n\t\tif numbers[i] >= max then\n\t\t\tmax = numbers[i]\n\
    \t\tend\n\tend\n\treturn max\nend", "\tlocal result = {}\n\tlocal max = 0\n\t\
    for i = 1, #numbers do\n\t\tif numbers[i] > max then\n\t\t\tmax = numbers[i]\n\
    \t\tend\n\tend\n\tfor i = 1, #numbers do\n\t\tif numbers[i] > max then\n\t\t\t\
    result[i] = max\n\t\t\tmax = numbers[i]\n\t\telse\n\t\t\tresult[i] = numbers[i]\n\
    \t\tend\n\tend\n\treturn result\nend", "  if #numbers <= 1 then return {numbers}\
    \ end\n  local current_max = numbers[1]\n  local max_indices = {1}\n  local max_count\
    \ = 0\n  local max_index_count = 1", "  local max_value = numbers[1]\n  local\
    \ max_index = nil\n  for i = 2, #numbers do\n    if numbers[i] >= max_value then\n\
    \      max_value = numbers[i]\n      max_index = i\n    end\n  end\n  return max_index,\
    \ max_value\nend", "\tlocal max = {}\n\tlocal index = {}\n\tlocal current = nil",
  "\tassert(#numbers > 0, \"rolling_max: expected table of length > 0, got \" .. #numbers)\n\
    \tlocal rolling_max = {}\n\tfor i = 1, #numbers do\n\t\tlocal max_so_far = 0\n\
    \t\tlocal max_element = 0\n\t\tfor j = 1, i do\n\t\t\tif numbers[j] > max_element\
    \ then\n\t\t\t\tmax_element = numbers[j]\n\t\t\t\tmax_so_far = j\n\t\t\tend\n\t\
    \tend\n\t\ttable.insert(rolling_max, max_element)\n\tend\n\treturn rolling_max\n\
    end", "  local rolling = numbers.new()\n  local max = numbers.new()\n  for i =\
    \ 1, #numbers do\n    rolling[i] = numbers.last()\n    if rolling[i] > max then\n\
    \      max = rolling[i]\n    end\n    numbers[i] = numbers[i] + 1 -- increment\
    \ the element\n  end\n  return max\nend", "  local rolling_max = false\n  for\
    \ i = 1, #numbers - 1 do\n    if numbers[i] > numbers[i + 1] then\n      rolling_max\
    \ = true\n      break\n    end\n  end", "  return setmetatable(\n    {},\n   \
    \ {\n      __tostring = function(self)\n        local result = {}\n        for\
    \ _, n in ipairs(numbers) do\n          if n > result then result[n] = n end\n\
    \        end\n        return table.concat(result)\n      end,\n    }\n  )\nend",
  "  local rolling = table.Create()\n  local max_so_far = -1\n  for _, value in pairs(numbers)\
    \ do\n    if value > max_so_far then\n      rolling[#rolling + 1] = value\n  \
    \    if max_so_far == -1 then\n        max_so_far = value\n      end\n    else\n\
    \      rolling[#rolling] = value\n    end\n  end\n  return rolling\nend", "  local\
    \ rolling_max = numbers.new()\n  local index = 1", "  local rolling_max_list =\
    \ {}\n  local last_max_val\n  local last_max_idx = nil\n  \n  for idx = 1, #numbers\
    \ do\n    if not rolling_max_list[last_max_idx] then\n      rolling_max_list[last_max_idx]\
    \ = {}\n    end\n    rolling_max_list[last_max_idx][#rolling_max_list[last_max_idx]\
    \ + 1] = numbers[idx]\n    if numbers[idx] > last_max_val then\n      last_max_val\
    \ = numbers[idx]\n      last_max_idx = idx\n    end\n  end\n  return rolling_max_list\n\
    end", "    return function()\n        local rolling = {{}}\n        local index\
    \ = 1\n        for _, number in ipairs(numbers) do\n            rolling[index]\
    \ = number\n            index = index + 1\n        end\n        return rolling\n\
    \    end\nend", "  local rolling_max = numbers.new\n  for i = 1, numbers.n do\n\
    \    local candidates = numbers:slice(-i, numbers.n)\n    if i == 1 then\n   \
    \   rolling_max:insert(numbers.max)\n      rolling_max:insert(numbers[1])\n  \
    \    rolling_max:insert(candidates[1])\n      rolling_max:insert(numbers[numbers.n\
    \ - 1])\n      rolling_max:insert(candidates[numbers.n - 1])\n    else\n     \
    \ rolling_max:insert(numbers[i])\n      rolling_max:insert(candidates[i])\n  \
    \  end\n  end\n  return rolling_max\nend", "\tlocal max_result = numbers[1]\n\t\
    local current_result = max_result\n\tfor i = 2, #numbers do\n\t\tif numbers[i]\
    \ > current_result then\n\t\t\tcurrent_result = numbers[i]\n\t\tend\n\tend\n\t\
    return max_result\nend", "    local current_index = 1\n    local max_value_index\
    \ = nil\n    local max_value_indexes = {}", "  local max_rolling = 0\n  local\
    \ max_rolling_times = 0\n  for i = #numbers, 1, -1 do\n    local rolling = math.max(0,\
    \ numbers[i])\n    if rolling > max_rolling then\n      max_rolling = rolling\n\
    \      max_rolling_times = i\n    end\n  end\n  return max_rolling, max_rolling_times\n\
    end", "  local rolling_max, running_max\n  running_max = 0\n  rolling_max = {}\n\
    \  for i = 1, #numbers do\n    local new_max = running_max\n    running_max =\
    \ max(numbers[i], running_max)\n    if new_max > rolling_max[i] then\n      rolling_max[i]\
    \ = new_max\n    end\n  end\n  return rolling_max\nend", "    local max = numbers[1]\n\
    \    for i = 2, #numbers do\n        if numbers[i] >= max then\n            max\
    \ = numbers[i]\n        else\n            max = numbers[i]\n        end\n    end\n\
    \    return max\nend", "  if #numbers == 0 then\n    return {}\n  end\n  local\
    \ max_elements = {numbers[1]}\n  for i = 2, #numbers do\n    local element = numbers[i]\n\
    \    for _, max in ipairs(max_elements) do\n      if element > max then\n    \
    \    max_elements = {element, max}\n        break\n      end\n    end\n  end\n\
    \  return max_elements\nend", "    local max = {}\n    local i = 1\n    while\
    \ i <= #numbers or i <= #numbers do\n        -- if numbers[i] == nil then break\
    \ end\n        local current = numbers[i]\n        for j = i + 1, #numbers or\
    \ 1 do\n            if numbers[j] ~= nil and current > numbers[j] then\n     \
    \           current = numbers[j]\n            end\n        end\n        table.insert(max,\
    \ current)\n        i = i + 1 or 1\n    end\n    return max\nend", "    local\
    \ max_so_far = nil\n    local max_so_far_index = 0\n    local max_so_far_val =\
    \ nil\n    for i = 1, #numbers do\n        if max_so_far == nil then\n       \
    \     max_so_far = numbers[i]\n            max_so_far_val = numbers[i]\n     \
    \   elseif max_so_far > numbers[i] then\n            max_so_far = numbers[i]\n\
    \            max_so_far_val = numbers[i]\n        else\n            max_so_far_val\
    \ = max_so_far_val or numbers[i]\n        end\n    end\n    -- At this point we\
    \ assume that we found the maximum element in the table of\n    -- non-nil numbers.\
    \ In other words, we didn't find a nil element.\n    if max_so_far_index < #numbers\
    \ then\n        local new_max_so_far = numbers[max_so_far_index]\n        local\
    \ new_max_so_far_val = numbers[max_so_far_index]\n        for i = max_so_far_index\
    \ + 1, #numbers do\n            if numbers[i] > max_so_far then\n            \
    \    max_so_far = numbers[i]\n                max_so_far_val = numbers[i]\n  \
    \          elseif numbers[i] < new_max_so_far then\n                new_max_so_far\
    \ = numbers[i]\n                new_max_so_far_val = numbers[i]\n            else\n\
    \                max_so_far_val = max_so_far_val or numbers[i]\n             \
    \   new_max_so_far_val = new_max_so_far_val or numbers[i]\n            end\n \
    \       end\n        numbers[max_so_far_index] = new_max_so_far_val\n        numbers[#numbers]\
    \ = new_max_so_far\n    end\n    return numbers\nend", "    local max_so_far =\
    \ numbers[1]\n    local max_so_far_index = 1", "  local buffer = {}\n  local max_so_far\
    \ = nil", "  local max = {}\n  for _, x in pairs(numbers) do\n    if max.p ==\
    \ nil then\n      max.p = x\n      max.m = 0\n    else\n      if x > max.p then\n\
    \        max.m = 1\n        max.p = x\n      else\n        if max.m < 1 then\n\
    \          max.m = 1\n        else\n          if x > max.p then\n            max.m\
    \ = max.m + 1\n            max.p = x\n          else\n            if max.m > max.m\
    \ then\n              max.m = 1\n            end\n          end\n        end\n\
    \      end\n    end\n  end\n  return max\nend", "  local max_value = nil\n  local\
    \ max_value_at_index = nil", "    local index = 1\n    local max_value = numbers[1]\n\
    \    for i = 2, #numbers do\n        if numbers[i] >= max_value then\n       \
    \     max_value = numbers[i]\n            index = i\n        end\n    end\n  \
    \  return numbers, max_value, index\nend", "  local rolling_max_table = {}\n \
    \ local index = 1\n  while index < #numbers do\n    local value = numbers[index]\n\
    \    if rolling_max_table[value] == nil then\n      rolling_max_table[value] =\
    \ 0\n    end\n    rolling_max_table[value] = math.max(rolling_max_table[value],\
    \ index)\n    index = index + 1\n  end\n  return rolling_max_table\nend", "\t\
    local max_so_far = nil\n\tlocal max_in_window = nil\n\tfor i = 1, #numbers do\n\
    \t\tlocal max_element = numbers[i]\n\t\tlocal window_start = i - 1\n\t\tlocal\
    \ window_end = i\n\t\tlocal last_element = numbers[i - 1]\n\t\tif window_start\
    \ > 1 then\n\t\t\tlocal tmp_max_element = numbers[window_start - 1]\n\t\t\tlocal\
    \ tmp_last_element = numbers[window_end]\n\t\t\tif tmp_max_element > max_element\
    \ then\n\t\t\t\tmax_in_window = tmp_max_element\n\t\t\t\tmax_so_far = tmp_last_element\n\
    \t\t\telse\n\t\t\t\tmax_in_window = max_element\n\t\t\t\tmax_so_far = last_element\n\
    \t\t\tend\n\t\telseif max_so_far ~= nil then\n\t\t\tif max_element > max_so_far\
    \ then\n\t\t\t\tmax_in_window = max_element\n\t\t\t\tmax_so_far = last_element\n\
    \t\t\tend\n\t\telse\n\t\t\tmax_in_window = max_element\n\t\t\tmax_so_far = last_element\n\
    \t\tend\n\tend\n\treturn max_in_window\nend", "  local max_rolling = numbers[1]\n\
    \  local i = 1\n  while i <= #numbers do\n    if numbers[i] >= max_rolling then\n\
    \      max_rolling = numbers[i]\n    end\n    i = i + 1\n  end\n  return max_rolling\n\
    end", "  local max = {}\n  local n = 1\n  local i = 1\n  for i = 1, #numbers -\
    \ 1 do\n    -- We store max as n-1 (the previous max element)\n    max[#max +\
    \ 1] = numbers[i - 1]\n    -- We calculate n (the next max element)\n    n = numbers[i]\n\
    \    -- And we update the max element if necessary\n    for j = 1, #max - 1 do\n\
    \      if max[j] > n then\n        max[j] = n\n      end\n    end\n  end\n  return\
    \ max\nend", "    return {}\nend", "  local rolling_maxes = {}\n  local last_max\n\
    \  for i, n in ipairs(numbers) do\n    -- If this is the first element, we don't\
    \ have a rolling max so far\n    if i then\n      rolling_maxes[#rolling_maxes\
    \ + 1] = 0\n    end", "\tlocal rolling_max = {}\n\tlocal index = 1\n\tlocal max_element\n\
    \tfor _, element in pairs(numbers) do\n\t\tif max_element == nil or max_element\
    \ < element then\n\t\t\tmax_element = element\n\t\t\trolling_max[index] = element\n\
    \t\tend\n\t\tindex = index + 1\n\tend\n\treturn rolling_max\nend", "  if #numbers\
    \ == 0 then\n    return {}\n  end", "  local size = #numbers\n  if size == 0 then\n\
    \    return {{}}\n  end\n  -- Initialize the temporary result table\n  local result\
    \ = {}\n  -- Compute the rolling max and save the result\n  for i = 1, size do\n\
    \    local value = numbers[i]\n    for j = i+1, size do\n      local value = value\
    \ or numbers[j]\n      local max = result and result[j] and max\n      if not\
    \ max then\n        max = value\n      else\n        if max ~= value then\n  \
    \        max = value\n        end\n      end\n    end\n    result[i] = max\n \
    \ end\n  return result\nend", "  local max_rolling_numbers = {}\n  local max_rolling_numbers_index\
    \ = 1\n  for i, number in ipairs(numbers) do\n    local max_rolling_number = number\n\
    \    max_rolling_number = math.max(number, max_rolling_number)\n    while max_rolling_number\
    \ > max_rolling_numbers[max_rolling_numbers_index] do\n      max_rolling_numbers[max_rolling_numbers_index]\
    \ = max_rolling_number\n      max_rolling_numbers_index = max_rolling_numbers_index\
    \ + 1\n    end\n  end\n  return max_rolling_numbers\nend", "  local result = {}\n\
    \  local current_rolling_max = numbers[1]\n  table.insert(result, current_rolling_max)\n\
    \  for i = 2, #numbers do\n    current_rolling_max = math.max(numbers[i], current_rolling_max)\n\
    \    table.insert(result, current_rolling_max)\n  end\n  return result\nend",
  "  local rolling_max = numbers.new\n  for i = 1, #numbers do\n    local value =\
    \ numbers[i]\n    if rolling_max[i] == nil then\n      rolling_max[i] = value\n\
    \    else\n      if value > rolling_max[i] then\n        rolling_max[i] = value\n\
    \      end\n    end\n  end\n  return rolling_max\nend", "    local rolling_max,\
    \ max_so_far = nil, nil\n    for i, n in ipairs(numbers) do\n        if not rolling_max\
    \ then\n            max_so_far = n \n            rolling_max = n\n        else\n\
    \            max_so_far = max_so_far > n and max_so_far or n\n        end\n  \
    \  end\n    return rolling_max\nend", "  local i, max = 1, numbers[1]\n  for i\
    \ = 2, #numbers do\n    if numbers[i] > max then\n      max = numbers[i]\n   \
    \ end\n  end\n  table.insert(numbers, max)\n  return numbers\nend", "  local result\
    \ = {}\n  local index = #numbers - 1\n  while true do\n    table.insert(result,\
    \ numbers[index])\n    index = math.max(index - 1, 0)\n    if index == 0 then\n\
    \      break\n    end\n  end\n  return result\nend", "    local max = 0\n    for\
    \ _, i in pairs(numbers) do\n        if max < i then\n            max = i\n  \
    \      end\n    end\n    return max\nend", "  local maxValue\n  local maxIndex\
    \ = nil", "  local result = {}\n  local largest = -math.inf", "\tlocal rolling_max\
    \ = numbers[1]\n\tfor i = 2, #numbers do\n\t\tif numbers[i] < rolling_max then\n\
    \t\t\trolling_max = numbers[i]\n\t\tend\n\tend\n\treturn rolling_max\nend", " \
    \ if numbers ~= nil then\n    return table.reduce(numbers, {}, function(max,num)\n\
    \      return math.max(max, num)\n    end)\n  else\n    return nil\n  end\nend",
  "  local max_size = #numbers\n  local max_value = numbers[1]\n  for i = 2, max_size\
    \ do\n    if max_value < numbers[i] then\n      max_value = numbers[i]\n    end\n\
    \  end\n  return max_value\nend", "  local i = 1\n  local max_so_far = 0\n  local\
    \ max_so_far_count = 0\n  for i = 1, #numbers do\n    local current = numbers[i]\n\
    \    if current > max_so_far then\n      max_so_far = current\n      max_so_far_count\
    \ = i\n    end\n  end\n  table.insert(numbers, max_so_far)\n  table.insert(numbers,\
    \ max_so_far)\n  table.insert(numbers, max_so_far_count)\nend", "  return local\
    \ function rolling_max_gen(table)\n    assert(type(table) == \"table\")\n    local\
    \ rolling_max = {}\n    local pos = 1\n    for i = 1, #table do\n      if table[i]\
    \ ~= nil then\n        pos = pos\n      else\n        pos = pos + 1\n      end\n\
    \      table.insert(rolling_max, table[i])\n      if pos == #table then break\
    \ end\n    end\n    return rolling_max\n  end\nend", "  local window = {}\n  local\
    \ max = {}\n  local i = 1\n  for n in numbers do\n    window[i] = n\n    if i\
    \ > 1 then\n      window[i] = window[i-1]\n    end\n    max[i] = window[i]\n \
    \   i = i + 1\n  end\n  i = 1\n  local j = 1\n  for i = 1, #numbers do\n    if\
    \ window[j] > max[i] then\n      max[i] = window[j]\n    end\n    i = i + 1\n\
    \    j = j + 1\n  end\n  return max\nend", "  local rolling_max = setmetatable({value\
    \ = nil, rolling_max = nil}, {__index = table})\n  for i = #numbers, 2, -1 do\n\
    \    local value = numbers[i]\n    rolling_max.value = value\n    rolling_max.rolling_max\
    \ = rolling_max.value\n  end\n  return rolling_max.rolling_max\nend", "   local\
    \ maxes = {}\n   for i = 1, #numbers, 1 do\n      table.insert(maxes, math.max(numbers[i]))\n\
    \   end\n   return maxes\nend", "    local size = 1\n    for i, num in pairs(numbers)\
    \ do\n        size = size * num\n    end\n    local table = {}\n    local i =\
    \ 1\n    while i <= size do\n        table.insert(table, i)\n        i = i + 1\n\
    \    end\n    return table\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
