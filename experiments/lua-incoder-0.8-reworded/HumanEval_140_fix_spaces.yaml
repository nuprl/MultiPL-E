name: HumanEval_140_fix_spaces
language: lua
prompt: "-- Given a string text, replace all spaces in it with underscores, \n-- and\
  \ if a string has more than 2 consecutive spaces, \n-- then replace all consecutive\
  \ spaces with - \n-- >>> fix_spaces(' Example')\n-- 'Example'\n-- >>> fix_spaces('\
  \ Example 1')\n-- 'Example_1'\n-- >>> fix_spaces(' Example 2')\n-- '_Example_2'\n\
  -- >>> fix_spaces(' Example 3')\n-- '_Example-3'\nlocal function fix_spaces(text)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fix_spaces\n\
  \    lu.assertEquals(candidate('Example'), 'Example')\n    lu.assertEquals(candidate('Mudasir\
  \ Hanif '), 'Mudasir_Hanif_')\n    lu.assertEquals(candidate('Yellow Yellow  Dirty\
  \  Fellow'), 'Yellow_Yellow__Dirty__Fellow')\n    lu.assertEquals(candidate('Exa\
  \   mple'), 'Exa-mple')\n    lu.assertEquals(candidate('   Exa 1 2 2 mple'), '-Exa_1_2_2_mple')\n\
  end\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tlocal new_string = \"\"\n\tlocal prev_char_has_spaces = false\n\t\
    local new_char_has_spaces = false\n\tfor i = 1, #text do\n\t\tlocal char = text:sub(i,i)\n\
    \t\tif char == \" \" then\n\t\t\tif prev_char_has_spaces then\n\t\t\t\tif new_char_has_spaces\
    \ then\n\t\t\t\t\tnew_string = new_string .. \"-\"\n\t\t\t\telse\n\t\t\t\t\tnew_string\
    \ = new_string .. \"_\"\n\t\t\t\tend\n\t\t\t\tnew_char_has_spaces = false\n\t\t\
    \telse\n\t\t\t\tprev_char_has_spaces = true\n\t\t\tend\n\t\telse\n\t\t\tprev_char_has_spaces\
    \ = false\n\t\tend\n\t\tnew_string = new_string .. char\n\tend\n\tif prev_char_has_spaces\
    \ then\n\t\tif new_char_has_spaces then\n\t\t\tnew_string = new_string .. \"_\"\
    \n\t\telse\n\t\t\tnew_string = new_string .. \"-\"\n\t\tend\n\tend\n\treturn new_string\n\
    end", "  text = text:gsub(' ', '_')\n  if text:gsub(' ', ' ') then\n    return\
    \ text:gsub(' ', '_')\n  else\n    return ''\n  end\nend", "   if text:gsub('\
    \ ','_'):gsub('  ','-') > 3 then\n      text = text:gsub(' ','_'):gsub('  ','-')\n\
    \   end\n   return text\nend", "  local num_spaces = #text:match(\"^ +$\")\n \
    \ if num_spaces > 1 then\n    local space_index = 1\n    local result = \"\"\n\
    \    repeat\n      if text:sub(1,space_index) == \" \" then\n        space_index\
    \ = space_index + 1\n      else\n        space_index = space_index + 1\n     \
    \ end\n    until space_index > num_spaces\n    local i = 1\n    while i <= num_spaces\
    \ do\n      if text:sub(-i,i) == \" \" then\n        result = result .. \"_\"\n\
    \      else\n        result = result .. text:sub(-i,i)\n      end\n      i = i\
    \ + 1\n    end\n    return result\n  else\n    return text\n  end\nend", "   text\
    \ = text:gsub('  ','_')\n   text = text:gsub(' ','-')\n   if text:gsub(' ','-')\
    \ ~= '' then text = text .. '_' else text\n   return text\nend\n</cell>\n<text>\n\
    Fix missing values\nThe first task is to identify any missing values and fill\
    \ them with appropriate values. Here we use a simple, but effective, method of\
    \ assuming missing values mean zero values.", "    return text:gsub(' ', '_'):gsub('\
    \ ', '-')\nend", "  local spaces_regex = ' %{%d+}$'\n  local no_spaces_regex =\
    \ ' %+$'", "  -- Replace all spaces with underscores\n  text = text:gsub(' ',\
    \ '\\uFF0E')\n  -- Split text into words by spaces and apply fix_spaces()\n  local\
    \ words = text:gsub(' ', '\\uFF0E'):split(' ')\n  -- Keep only first and last\
    \ word\n  local word1 = words[1]\n  local word2 = words[#words]\n  -- If word1\
    \ or word2 has more than one space, \n  -- then replace all consecutive spaces\
    \ with _\n  if word1 ~= '' then\n    local firstIndex = text:find(word1)\n   \
    \ local endIndex = firstIndex + #word1\n    if endIndex >= 1 then\n      -- Replace\
    \ all spaces with _\n      text = text:gsub(' ', '_')\n      -- Replace all words\
    \ that had more than 2 spaces with -\n      text = text:gsub('%s{2,}' % word1,\
    \ '_')\n      text = text:gsub('%s{%d,%d}' % (word1, endIndex), '_')\n    end\n\
    \  end\n  if word2 ~= '' then\n    local firstIndex = text:find(word2)\n    local\
    \ endIndex = firstIndex + #word2\n    if endIndex >= 1 then\n      -- Replace\
    \ all spaces with _\n      text = text:gsub(' ', '_')\n      -- Replace all words\
    \ that had more than 2 spaces with -\n      text = text:gsub('%s{2,}' % word2,\
    \ '_')\n      text = text:gsub('%s{%d,%d}' % (word2, endIndex), '_')\n    end\n\
    \  end\n  return text\nend", "  return text:gsub(' ','_'):gsub('%S+', function(t)\
    \ \n    return t:gsub(' ','-')\n  end)\nend", "  return text:gsub(' ', '_'):gsub('\
    \  +', '_')\nend", "  if text == nil or text  == '' or text  == nil then\n   \
    \ return text\n  else\n    local spaces = text:gsub(' ', '') -- Replace all spaces\n\
    \    local consecutiveSpaces = spaces:gsub(' ', '-') -- Replace consecutive spaces\n\
    \    if consecutiveSpaces ~= spaces then\n      return consecutiveSpaces .. '_'\
    \ .. spaces\n    else\n      return text\n    end\n  end\nend", "  local has_space\
    \ = string.find(text, \"  \")\n  if has_space ~= nil then\n    return text:gsub(\"\
    \  \", \"_\")\n  else\n    return text\n  end\nend", "  local spaces  = string.gsub(text,\
    \ ' *', '|_')\n  local dashes = string.gsub(spaces, '_', '-')\n  return dashes\
    \ .. '_'\nend", "   -- Add underscores at spaces in text\n   local new_text =\
    \ text:gsub(' ','_')", "    local spaces = 0\n    for i = 1, #text do\n      \
    \  if text[i] == ' ' then spaces = spaces + 1 else spaces = spaces end\n    end\n\
    \    if spaces > 1 then\n        local newtext = \"\"\n        for i = 1, #text\
    \ do\n            if text[i] == ' ' then\n                if i == (spaces-1) then\n\
    \                    newtext = newtext .. \"_\"\n                else\n      \
    \              newtext = newtext .. \"-\"\n                end\n            else\n\
    \                newtext = newtext .. text[i]\n            end\n        end\n\
    \        return newtext\n    else\n        return text\n    end\nend", "  text\
    \ = text:gsub(' ', '_')\n  text = text:gsub('  +', '_')\n  text = text:gsub('\
    \  ', '- ')\n  return text\nend", "  -- Removing extra space at the end\n  text\
    \ = text.trim()\n  -- Replace multiple spaces with single '-'\n  text = string.rep(\"\
    \ \",\"-\",text)\n  -- Removing extra space at the beginning\n  text = string.gsub(\"\
    ^ +\",\"\",text)\n  return text\nend", "  return string.gsub(text,\" \",\"_\"\
    )\nend", "    local spaces = text\n        ..' ' -- space at the begining of the\
    \ string\n        ..' ' -- space at the end of string\n        ..' ' -- space\
    \ in between words\n        ..' ' -- consecutive spaces in between words\n   \
    \     ..' ' -- multiple spaces in between words\n        ..' ' -- multiple spaces\
    \ in one word\n        ..' ' -- multiple consecutive spaces in one word\n    \
    \    ..' ' -- multiple consecutive spaces in one word\n        ..' ' -- multiple\
    \ consecutive spaces in one word\n        ..' ' -- multiple consecutive spaces\
    \ in one word\n        ..' ' -- multiple consecutive spaces in one word\n    \
    \    ..' ' -- multiple consecutive spaces in one word\n        ..' ' -- multiple\
    \ consecutive spaces in one word\n        ..' ' -- multiple consecutive spaces\
    \ in one word\n        ..' ' -- multiple consecutive spaces in one word\n    \
    \    ..' ' -- multiple consecutive spaces in one word\n        ..' ' -- multiple\
    \ consecutive spaces in one word\n        ..' ' -- multiple consecutive spaces\
    \ in one word\n        ..' ' -- multiple consecutive spaces in one word\n    \
    \    ..' ' -- multiple consecutive spaces in one word\n        ..' ' -- multiple\
    \ consecutive spaces in one word\n        ..' ' -- multiple consecutive spaces\
    \ in one word\n        ..' ' -- multiple consecutive spaces in one word\n    \
    \    ..' ' -- multiple consecutive spaces in one word\n        ..' ' -- multiple\
    \ consecutive spaces in one word\n        ..' ' -- multiple consecutive spaces\
    \ in one word\n        ..' ' -- multiple consecutive spaces in one word\n    \
    \    ..' ' -- multiple consecutive spaces in one word\n        ..' ' -- multiple\
    \ consecutive spaces in one word\n        ..' ' -- multiple consecutive spaces\
    \ in one word\n        ..' ' -- multiple consecutive spaces in one word\n    \
    \    ..' ' -- multiple consecutive spaces in one word\n        ..' ' -- multiple\
    \ consecutive spaces in one word\n        ..' ' -- multiple consecutive spaces\
    \ in one word\n        ..' ' -- multiple consecutive spaces in one word\n    \
    \    ..' ' -- multiple consecutive spaces in one word\n        ..' ' -- multiple\
    \ consecutive spaces in one word\n        ..' ' -- multiple consecutive spaces\
    \ in one word\n        ..' ' -- multiple consecutive spaces in one word\n    \
    \    ..' ' -- multiple consecutive spaces in one word", "  return text:gsub('\
    \ ','_'):gsub(' ','_'):gsub('  ','_')\nend", "  return text:gsub(' ', '_') --\
    \ replace spaces with underscores\n      .. '-' -- replace all spaces with hyphens\n\
    \      .. text:gsub(' ', '-') -- replace consecutive spaces with underscores\n\
    end", "  local newText = text\n  -- Replace all spaces with underscores\n  local\
    \ i = 0\n  while i <= #newText do\n    local char = newText:sub(i,i)\n    if char\
    \ == ' ' then\n      newText = newText:sub(i,i-1)\n    else\n      newText = newText:sub(i,i)\n\
    \    end\n    i = i + 1\n  end\n  -- If there are more than two consecutive spaces,\
    \ \n  -- then replace all consecutive spaces with -\n  local j = #newText\n  while\
    \ j ~= 0 do\n    if newText:sub(j,j) == ' ' then\n      newText = newText:sub(1,j-1)\n\
    \    else\n      break\n    end\n    j = j - 1\n  end\n  return newText\nend",
  "   local space_re = '([%s])' -- A sequence of spaces and characters\n   local trailing_space_re\
    \ = '(%s$)'\n   local leading_space_re = '([^%s]+)' -- A sequence of characters\
    \ and non-space\n   local trailing_space_re = '([^%s$]+)' -- A sequence of non-space\
    \ and non-char\n   -- We use the pattern to find any sequence of spaces in \n\
    \   -- the text with any amount of characters in between.\n   --\n   -- The pattern\
    \ returns the space character itself and the \n   -- text surrounded by the space\
    \ character in group 1\n   local pattern = space_re..trailing_space_re\n   local\
    \ space_re = assert(pattern:match(text))\n   if space_re then\n      local trailing_space\
    \ = space_re:sub(#space_re)\n      local leading_space = space_re:sub(1, #space_re)\n\
    \      -- We replace any sequence of spaces with -\n      -- Then we add the leading\
    \ space back on\n      return string.rep(trailing_space, '-') .. \n         string.rep(leading_space)\n\
    \   else\n      return text\n   end\nend", "  return text:gsub('%s+', function(s)\
    \ return s:gsub('%s+', ' ') end):gsub(' %s+', function(s) return '_' end)\nend",
  "    local no_spaces = text:gsub(\"^%s*(.-)%s*$\", \"%1\")\n    local spaces = no_spaces:gsub(\"\
    \  \", \"_\")\n    if spaces ~= no_spaces then\n        no_spaces = spaces:gsub(\"\
    _\", \"_\")\n    end\n    return no_spaces\nend\n</code>\n<|/ a dscore=5 |>\n\
    <| a tags=filenames,filename-extension,string,lua dscore=4 |>\n<code>", "  local\
    \ spaces\n  do\n    spaces = text:gsub(' ','_')\n  end\n  if spaces ~= text then\n\
    \    do\n      local first = true\n      local i = 2\n      while i <= #spaces\
    \ and spaces[i+1] ~= spaces[i] do\n        if first then\n          spaces = spaces:sub(1,i-1)..'-'..spaces:sub(i+1)\n\
    \        else\n          spaces = spaces:sub(1,i-1)..'_'..spaces:sub(i+1)\n  \
    \      end\n        i = i + 2\n        first = false\n      end\n    end\n  end\n\
    \  return spaces\nend", "    local space_pattern = \" +\"\n    return text:gsub(\"\
    %S\", function (w)\n        return string.gsub(w, space_pattern, \"_\")\n    end)\n\
    end", "    local space_count, space_count_change\n    space_count = string.len(text)\n\
    \    space_count_change = 0\n    for i = 1, space_count do\n        if string.sub(text,\
    \ i, i+1) == \" \" then\n            space_count_change = space_count_change +\
    \ 1\n        else\n            if space_count_change == 1 then\n             \
    \   text = text .. \"_\"\n            else\n                text = text .. \"\
    -\"\n            end\n        end\n    end\n    return text\nend", "  return text:gsub('\
    \ ', '_'):gsub(' ', '-')\nend", "   return text:gsub('  ','_'):gsub(' ','-')\n\
    end", "  return text:gsub('%w+',\n    function(word)\n      local fixed = word:gsub('%s+',\
    \ ' ');\n      if fixed:sub(1, 1) == ' ' and fixed:sub(2, 2) == ' ' then\n   \
    \     return word:sub(1, 1) == '_' and word:sub(2, 2) == '-' or word:sub(2, 2)\
    \ == '-'\n      else\n        return fixed\n      end\n    end\n  )\nend", " \
    \ if text:match(\"[ -]+\") then\n    local result = text:gsub(\"[ -]+\",\"_\"\
    )\n    if result:match(\"_%+\") then\n      result = result:sub(1,-2)\n    end\n\
    \    return result\n  end\n  return text\nend", "  return text:gsub(' ', ' ')\
    \ .. \n    text:gsub(' ', ' '):gsub(' ', '-')\nend", "  local num_spaces = #text:gsub(\"\
    [  ]+\",\" \")\n  if num_spaces > 2 then\n    text = text:gsub(\"[  ]+\",\"_\"\
    )\n  elseif num_spaces == 2 then\n    text = text:gsub(\"[  ]\",\"\")\n  end\n\
    \  return text\nend", "  return text:gsub(' ','_'):gsub(' ','-')\nend", "    local\
    \ space = text:match('^%s*()')\n    if space then\n        text = text:gsub('\
    \ ', '_')\n    end", "    local has_consecutive_space = false\n    local has_space\
    \ = false\n    local new_text = \"\"\n    for ch in text:gmatch(\"%S+\") do\n\
    \        if ch ~= \" \" then\n            if has_consecutive_space then\n    \
    \            new_text = new_text:gsub(\"%s+\", ch .. \"_\")\n                has_consecutive_space\
    \ = false\n            elseif has_space then\n                new_text = new_text:gsub(\"\
    %s+\", ch .. \"-\")\n            else\n                new_text = new_text:gsub(\"\
    %s\", ch)\n                has_consecutive_space = false\n                has_space\
    \ = true\n            end\n        elseif has_consecutive_space then\n       \
    \     new_text = new_text:gsub(\"%s+\", ch .. \"_\")\n        else\n         \
    \   has_consecutive_space = true\n            has_space = false\n        end\n\
    \    end\n    return new_text\nend", "  local words = text:gsub(' ', '_')\n  local\
    \ spaces = text:gsub(' ', '-')\n  local numSpaces = text:gsub(' ', '') - spaces\n\
    \  if numSpaces > 1 then\n    local result = text:gsub(' ', '- ')\n    text =\
    \ result:gsub(' ', '_')\n  end\n  return text\nend", "   text = text:gsub(' ','_')\n\
    \   text = text:gsub(' ','-')\n   if text:gsub(' ','_')~=text then return text\n\
    \   else\n       local i=text:find(' ')\n       if i==nil then return text end\n\
    \       return text:sub(1,i)..'_'..text:sub(i+1)\n   end\nend", "    local last_space\
    \ = ''\n    for i = 1, #text do -- Loop through each character in the string\n\
    \        if text[i] == ' ' then\n            last_space = i \n        elseif text[i]\
    \ == ' ' and i > 1 and i - 1 == last_space + 1 then -- Check whether the current\
    \ character is space, then the previous character\n            text[i] = '_'\n\
    \        elseif i > 1 and i - 1 == last_space + 1 then -- If previous character\
    \ is not space\n            text[i] = '-'\n        end\n    end\n    return text\n\
    end", "  local n = text:gsub(\"[%z\\s]+\", function(x)\n    local s = x:gsub(\"\
    %z\", \"_\")\n    return s if s:match(\"%z\") and s:gsub(\"%z\", \"-\") == x or\
    \ s == '-' end\n  end)\n  return n or ' ' end\nend", "  local no_spaces = text:gsub('%s+',\
    \ function(x)\n    return x:gsub(' ','_')\n  end)\n  return no_spaces:gsub('%s+',\
    \ function(x)\n    return x:gsub(' ','-')\n  end)\nend\n</cell>\n<cell>", "  text\
    \ = text:gsub(' ','_')\n  text = text:gsub(' ','-')\n  if text:len() > 1 then\n\
    \    local last_space = text:match('^%s*(.-)%s*$')\n    if last_space then\n \
    \     return text:gsub('^%s*','_'):gsub('$',last_space)\n    end\n  end\n  return\
    \ text\nend", "    local space_count = #text:gsub(' ', ' ') -- Replace all spaces\n\
    \    if space_count == 0 then\n        return text\n    elseif space_count ==\
    \ 1 then\n        return text .. '_' -- If only one space, add underscore to fix\
    \ it\n    elseif space_count > 2 then\n        return text .. '_' -- If more than\
    \ 2 spaces, replace them all with underscore\n    else\n        return text --\
    \ Else no change necessary\n    end\nend", "  if text == nil then\n    return\
    \ nil\n  end", "   local spaces_count = gsub(' ', '  ', text)\n   return (gsub(repeat('\
    \ ', spaces_count), '-', '') .. '-') .. text\nend", "    local num_spaces = #text:gsub('(\
    \ +)', '_'):gsub('(%$)', '')\n    if num_spaces > 1 then\n        return text:gsub('(\
    \ +)', '_'):gsub('(%$)', ''):gsub('( {2,})', '_')\n    else\n        return text\n\
    \    end\nend", "  text = text:gsub(' ', '_')\n  if text:find('  ') ~= nil then\n\
    \    text:gsub('  ', '- ')\n  end\n  return text\nend\n</cell>\n<cell>", "  local\
    \ fixed_text = ''\n  for c in text:gmatch('(.-)') do\n    if c == ' ' then\n \
    \     fixed_text = fixed_text .. '_'\n    else\n      fixed_text = fixed_text\
    \ .. c\n    end\n  end\n  while #fixed_text > 2 do\n    fixed_text = fixed_text:gsub('\
    \ ', ' ')\n  end\n  return fixed_text\nend", "  text = text:gsub(' ', '[#]+')\n\
    \  text = text:gsub(' ', '[-]+')\n  return text\nend", "  local spaces = text:gsub(\"\
    ^%s*(.)\", \n    function(c) return c:sub(1, #c-1) .. \"_\" end)\n  \n  if spaces:sub(1,#spaces-1)\
    \ ~= \"\" then\n    return spaces:sub(1, #spaces-1)\n  end\n  return text\nend",
  "    -- The only special characters in text are spaces and hyphens\n    local hyphen_mask\
    \ = '[-\\s]'\n    local hyphen_replace = '_'\n    -- Replace all hyphens with\
    \ underscore\n    local text = text:gsub('%p', hyphen_mask):gsub('%p', hyphen_replace)\n\
    \    local consecutive_spaces\n    -- Find the length of the string in spaces\n\
    \    -- If the string is shorter than 2 spaces, \n    -- then return the same\
    \ string\n    -- Otherwise, split the string into 2 parts, \n    -- each one with\
    \ only 1 space \n    -- >>> consecutive_spaces = count_consecutive_spaces(' Example')\n\
    \    -- 2\n    -- >>> consecutive_spaces = count_consecutive_spaces(' Example\
    \ 1')\n    -- 1\n    -- >>> consecutive_spaces = count_consecutive_spaces(' Example\
    \ 2')\n    -- 1\n    -- >>> consecutive_spaces = count_consecutive_spaces(' Example\
    \ 3')\n    -- 0\n    local len = text:len() + 1 -- add one for the hyphen\n  \
    \  if len < 2 then\n        return text\n    end\n    -- Find the length of consecutive\
    \ spaces in text\n    -- if the length is more than 2, then return the same string\n\
    \    -- otherwise, split the string into 2 parts, \n    -- each one with only\
    \ 1 space \n    -- >>> consecutive_spaces = count_consecutive_spaces(' Example')\n\
    \    -- 2\n    -- >>> consecutive_spaces = count_consecutive_spaces(' Example\
    \ 1')\n    -- 1\n    -- >>> consecutive_spaces = count_consecutive_spaces(' Example\
    \ 2')\n    -- 1\n    -- >>> consecutive_spaces = count_consecutive_spaces(' Example\
    \ 3')\n    -- 0\n    local spaces_count = text:sub(1, len - 1):find(hyphen_mask)\n\
    \    if spaces_count > 1 then\n        return text\n    else\n        return text:sub(1,\
    \ spaces_count - 1):gsub('%p', hyphen_replace)\n    end\nend", "\ttext = string.gsub(text,\
    \ \"[%a]+\", function (c) \n\t\treturn string.format(\"%a_\", c) \n\tend)\n\t\
    text = string.gsub(text, \" {2,}\", \"_\")\n\treturn text\nend", "    local spaces,\
    \ _ = text:gsub(' ', '_')\n    if spaces ~= '' then\n        return text:gsub('\
    \  +', '_'):gsub('  ', '-')\n    else\n        return text\n    end\nend", " \
    \ text = text:gsub(' ', ' ')\n  if text:gsub(' ', ' '):gsub(' ', ' ') > 2 then\n\
    \    local s = text:gsub(' ', ' ')\n    local i = 0\n    while s ~= '' do\n  \
    \    s = s:gsub(' ', ' -')\n      i = i + 1\n    end\n    return text:sub(1, i\
    \ - 1)\n  end\n  return text\nend", "    local num_spaces = 0\n    local spaces\
    \ = ''\n    for c = text:gmatch('%S+') do\n        if c == '' then\n         \
    \   num_spaces = num_spaces + 1\n        elseif num_spaces > 1 then\n        \
    \    spaces = spaces .. '-'\n        else\n            spaces = spaces .. ' '\n\
    \        end\n        text = text:gsub('%S+', spaces)\n        num_spaces = 0\n\
    \    end\n    return text\nend", "  local s = text:gsub(\"  +\", \" \")\n  local\
    \ len = s:len()\n  return len == 1 and s or text:sub(1, len - 1) .. '_' .. text:sub(len)\n\
    end", "    local spaces  -- a list of all spaces\n    local last    -- True if\
    \ space before text\n    local text_len = #text", "  local lastSpace = nil\n \
    \ local spaceCount = 0\n  for char in text:gmatch('%S+') do\n    if lastSpace\
    \ then\n      if char == ' ' then\n        spaceCount = spaceCount + 1\n     \
    \ elseif spaceCount == 2 then\n        char = '-'\n      else\n        char =\
    \ '_'\n      end\n    end\n    lastSpace = char\n  end\n  return text\nend", " \
    \   local space_count = string.gsub(text, \"[[:space:]]\", \"_\") -- count spaces\n\
    \    if space_count > 2 then\n        space_count = string.gsub(text, \"[[:space:]]*\"\
    , \"_\") -- count multiple spaces\n        if space_count > 1 then\n         \
    \   space_count = string.gsub(text, \"[[:space:]]+\", \"_\") -- count multiple\
    \ spaces\n            if space_count > 1 then\n                space_count = string.gsub(text,\
    \ \"[[:space:]]+$\", \"\") -- remove trailing spaces\n            end\n      \
    \  end\n    end\n    return text\nend", "  local n = #text\n  local result = ''\n\
    \  for i=1,n do\n    local c = text:sub(i,i)\n    if c == ' ' then\n      result\
    \ = result .. '_'\n    else\n      result = result .. c\n    end\n  end\n  if\
    \ #result > 2 then\n    result = '-' .. result\n  end\n  return result\nend\n\
    </cell>\n<text>\nA note on Python versions\nThe Python libraries are versioned.\
    \ A specific version can be installed by running pip3 install <package>. For example,\
    \ pip3 install jupyterlab will install a specific version (in this case, v0.44.0).",
  "\t-- TODO: Make this less crazy with more flexibility\n\tlocal result = text\n\t\
    local spaces = string.gsub(text, \"%s+\", \" \")\n\tspaces = string.gsub(spaces,\
    \ \" +\", \"_\")\n\tlocal spaces_count = string.gsub(spaces, \"_\", \"\")\n\t\
    -- Only replace if the text has more than 2 spaces\n\tif spaces_count > 2 then\n\
    \t\tresult = text\n\t\tspaces = string.gsub(spaces, \" +\", \"_\")\n\t\tspaces\
    \ = string.gsub(spaces, \"_+\", \"-\")\n\t\tspaces_count = string.gsub(spaces,\
    \ \"-\", \"\")\n\tend\n\t-- No spaces left? Then return the original text\n\t\
    if spaces_count == 0 then\n\t\treturn result\n\tend\n\t-- Otherwise we must fix\
    \ the text\n\ttext = string.reverse(spaces)\n\treturn string.reverse(text) --\
    \ Reverse the text again\nend", "    return text:gsub(' ','_'):gsub(' ','-')\n\
    end", "    local space_count = {}\n    for c in text:gmatch '[%Z]+' do\n     \
    \   space_count[c] = space_count[c] or 0\n        space_count[c] = space_count[c]\
    \ + 1\n    end\n    local last_space\n    local result = ''\n    for c in text:gmatch\
    \ '[%Z]+' do\n        if space_count[c] > 1 then\n            last_space = c\n\
    \        end\n        if c == ' ' then\n            if last_space ~= ' ' then\n\
    \                result =\n                    result ..\n                   \
    \ string.rep(string.sub(last_space, 1, 1), '_')\n            end\n        else\n\
    \            result =\n                result ..\n                string.rep(string.sub(c,\
    \ 1, 1), '_')\n        end\n        last_space = c\n    end\n    return result:gsub('_+$',\
    \ '')\nend\nreturn fix_spaces\nend", "\tlocal spaces = text:match(\"^[%w\\s-]+\"\
    )\n\tif spaces then\n\t\tlocal spaces_count = text:gsub(\"^[%w\\s-]+\", \"\"):match(\"\
    [%w\\s]+\")\n\t\tif spaces_count > 1 then\n\t\t\ttext = text:gsub(\"[%w\\s]+\"\
    , \"_\")\n\t\tend\n\tend\n\treturn text\nend", "  return text:gsub(' ', '_'):gsub('\
    \  ', '-')\nend", "    local new_text = text\n    local start = 1\n    local end\
    \ = 1\n    while true do\n        local n = text:find(\" \", start, true)\n  \
    \      if n ~= nil then\n            new_text = new_text:sub(0, start) .. \"_\"\
    \ .. new_text:sub(n, new_text:len())\n            start = n + 1\n        else\n\
    \            break\n        end\n    end\n    return new_text\nend", "   return\
    \ text:gsub(' ', ' ') \n      .. text:gsub(' ', '\\1')\n      .. text:gsub(' ',\
    \ '\\2')\n      .. text:gsub(' ', '\\3')\nend", "  -- If there are no spaces,\
    \ return text\n  if not text:match ' ' then return text end", "  text = text:gsub('%(%b()%(%b()*)','%1_')\n\
    \  local space = text:gsub(' ','_')\n  return text:gsub('_+'..space,'-'):gsub('_-','_')\n\
    end", "    local new_text = text\n    local count = 1\n    local prev_space =\
    \ false\n    while count > 0 do\n        local pos = new_text:find(' ', count)\n\
    \        if (not pos) then\n            count = count + 1\n        else\n    \
    \        count = pos + 1\n            if new_text:sub(1, count) == \" \" then\n\
    \                prev_space = not prev_space\n            else\n             \
    \   new_text = new_text:sub(1, count) .. \"_\"\n            end\n        end\n\
    \    end\n    return new_text .. \"-\" .. tostring(#new_text)\nend", "\t-- Strip\
    \ leading and trailing spaces.\n\ttext = text:gsub('^%s*(.-)%s*$', '%1')\n\t--\
    \ Replace any multiple spaces with a single space.\n\ttext = text:gsub('  +',\
    \ \" \")\n\t-- Replace a single space with a single underscore.\n\ttext = text:gsub('\
    \ ', '_')\n\t-- Replace all multiple underscores with a single underscore.\n\t\
    text = text:gsub('__+', '___')\n\t-- Replace any trailing spaces with a single\
    \ underscore.\n\ttext = text:gsub('%s*(.-)%s*$', '_%1', text)\n\t-- Replace any\
    \ leading spaces with a single underscore.\n\ttext = text:gsub('%s*( )%s*$', '_%1',\
    \ text)\n\treturn text\nend", "\ttext = text:gsub('%s+', unpack(\n\t\t{'([%w$]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([%w_]*)([",
  "  return text:gsub(' ', '_'):gsub(' ', '-')\nend", "  local space_index = #text\
    \ - 1 -- Index of last space\n  if space_index > 2 then\n    local s = ''\n  \
    \  for i = 1, space_index do\n      s = s .. '-'\n    end\n    return text:gsub('\
    \ ', s)\n  end\n  return text\nend", "  local s = text:gsub(' ', '_(%W)') -- Swap\
    \ spaces for _\n  local l = s:gsub('(%W)(%W)', '\\1-\\2')  -- Un-swap consecutive\
    \ _\n  return text..l\nend", "   if text ~= nil then\n      local space = \" \"\
    \n      local spaces = true\n      local space_count = nil\n      local result\
    \ = nil\n      \n      repeat\n         space_count = text:find(space,1,true)\n\
    \         if space_count ~= nil then\n            spaces = true\n            if\
    \ space_count == 1 then\n               space_count = text:len() - 1 -- -1 because\
    \ we already counted the space in space_count\n            end\n         else\n\
    \            spaces = false\n         end\n         \n         if spaces then\n\
    \            -- The string has at least two consecutive spaces, \n           \
    \ -- so replace all consecutive spaces with a single dash \n            -- >>>\
    \ fix_spaces(' Example')\n            -- 'Example'\n            -- >>> fix_spaces('\
    \ Example 1')\n            -- 'Example-1'\n            -- >>> fix_spaces(' Example\
    \ 2')\n            -- 'Example-2'\n            -- >>> fix_spaces(' Example 3')\n\
    \            -- 'Example-3'\n            space_count = text:len() - 1 -- -1 because\
    \ we already counted the space in space_count\n         else\n            space_count\
    \ = text:len() - 1\n         end\n         \n         -- Replace the space with\
    \ a dash \n         result = text:sub(1,space_count-1) .. \"-\"\n         \n \
    \        -- Replace the space in the middle with a dash \n         text = text:sub(space_count,space_count+1)\n\
    \         \n      until space_count >= 2\n   end\n   return text\nend", "  return\
    \ text:gsub(' ', '_'):gsub('  +', ' - ')\nend", "  local spaces = string.gsub(text,\
    \ \"%S+\", \"_\")\n  -- if text has spaces, and no two consecutive spaces, replace\
    \ \n  -- the spaces with dashes\n  if spaces and (string.find(spaces, \"  \")\
    \ == nil) then\n    spaces = string.gsub(spaces, \"% +\", \"- \")\n  end\n  return\
    \ spaces\nend", "  local new_text = ''\n  local consecutive_spaces = 0\n  for\
    \ i = 1, #text do\n    local c = text:sub(i, i)\n    if c == ' ' then\n      if\
    \ consecutive_spaces == 0 then\n        new_text = new_text .. '_' .. c\n    \
    \  else\n        new_text = new_text .. '-' .. c\n      end\n      consecutive_spaces\
    \ = consecutive_spaces + 1\n    else\n      new_text = new_text .. c\n    end\n\
    \  end\n  if consecutive_spaces > 1 then\n    new_text = new_text:sub(1, #new_text\
    \ - 1)\n  end\n  return new_text\nend\n</cell>\n<text>\nExercise 2.3: Fix the\
    \ spacing of the text below. How many spaces are replaced?", "   local result\
    \ = text:gsub(\"[% ]+\", \"_\")\n   if result:sub(1, #result) == '_' then \n \
    \     return result \n   else\n      return result .. '_' \n   end\nend", "\t\
    local spaces_g1, spaces_g2, spaces_g3 = {}, {}, {}\n\tfor i = 0, #text, 1 do\n\
    \t\tlocal c = text[i]\n\t\tif c == ' ' then\n\t\t\ttable.insert(spaces_g1, c)\
    \ \n\t\telseif c == '\\n' or c == '\\r' then\n\t\t\tbreak\n\t\telse\n\t\t\ttable.insert(spaces_g2,\
    \ c)\n\t\tend\n\tend\n\tlocal spaces_g2, spaces_g3 = table.concat(spaces_g2),\
    \ table.concat(spaces_g3)\n\tlocal space_count = #spaces_g1\n\ttable.insert(spaces_g3,\
    \ ' ')\n\twhile space_count > 1 do\n\t\ttable.insert(spaces_g3, '_')\n\t\tspace_count\
    \ = space_count - 1\n\tend\n\treturn table.concat(spaces_g1)\nend", "  local old_text\
    \ = text\n  -- Replace all spaces in it with underscores \n  text = text:gsub(\
    \ ' ', '' )\n  -- Remove consecutive spaces\n  text = text:gsub( ' {2,}', '_'\
    \ )\n  return old_text .. '_' .. text\nend\n</cell>\n<cell>", "   text = text:gsub(\"\
    %s+\", function() return \"_\" end)\n   text = text:gsub(\"[%s]+\", function()\
    \ return \"_\" end)\n   return text\nend", "    return text:gsub(' ', '_'):gsub('\
    \  ', '-')\nend", "  return text:gsub(' ','_'):gsub('  ','-')\nend", "    local\
    \ nspaces = string.len(text)\n    local nunders = nspaces-string.gsub(text, \"\
    [%z\\1-\\32]\", \"\")\n    local result = text\n    if nunders > 2 then\n    \
    \    -- There are more than two consecutive spaces, so use dashes.\n        result\
    \ = text\n        local i = 1\n        while string.sub(result,i, i) ~= \" \"\
    \ do\n            i = i+1\n        end\n        if i > 1 then\n            result\
    \ = result:sub(1, i)..\"-\"..result:sub(i+1, i)\n        end\n    end\n    return\
    \ result:sub(1,nunders)\nend", "  text = text:gsub(' ', '_')\n  if text:match('^%s+$')\
    \ then\n    text = text:gsub('%s+' % '^%s+$', '^%s+')\n  else\n    text = text:gsub('%s+'\
    \ % '^%s+', '%-') -- The first replacement\n  end\n  return text\nend", "  return\
    \ text:gsub(' ','_'):gsub('%S+','-%S')\nend", "  return string.gsub(text, \"[\"\
    \ .. string.gsub(\" \", \"_\", \"g\") .. \"]\", \"_\")\nend\n</cell>\n<text>\n\
    The function fix_spaces replaces all spaces in a string with _. The g is required\
    \ for the pattern to match multiple spaces. Then the pattern replaces every _\
    \ with spaces.", "\t-- first count the spaces\n\tlocal count, spaces = 0, ''\n\
    \tfor char in text:gmatch('([^ ])') do count = count + 1 end", "   -- If the text\
    \ is empty or consists only of spaces, return it\n   if text:len() == 0 or text:find('\
    \ ') == -1 then return text end\n   -- If there are two consecutive spaces, replace\
    \ them with a single dash\n   if text:find('  ') ~= nil then\n      text = text:gsub('\
    \  ', '- ')\n   end\n   -- Return the text with no spaces\n   return text\nend\n\
    </code>\n<|/ a dscore=4 |>\n<| a tags=lua |>\nThis is my solution:\n<code>", " \
    \ return text:gsub(' ','_'):gsub(' ','-')\nend\n</code>\n<|/ a |>\n<| c |>\nIf\
    \ you see my answer, I used the exact same code you did.\n<|/ c |>\n<| c |>\n\
    Oh sorry, I see what you did. My apologies.\n<|/ c |>\n<| c |>\n: I like your\
    \ solution, though my solution was more succinct.  You might want to update your\
    \ answer to highlight the fact that Lua does not have a `gsub` function.  You\
    \ can do that by calling `string.gsub()`, though, which is a Lua function.\n<|/\
    \ c |>\n<| a dscore=1 tags=lua,string,whitespace |>\nTo my knowledge there is\
    \ no builtin function that does this, so you have to do some string manipulation:\n\
    <code>", "  return text:gsub('%s+',''):gsub('[ ]+','_'):gsub('%-+','_')\nend\n\
    </cell>\n<cell>", "  -- Replace all spaces with underscores\n  text = text:gsub('\
    \ ', '_')\n  -- If the text has more than 2 consecutive spaces,\n  -- then replace\
    \ all consecutive spaces with -\n  if text:gsub(' ', ' ') ~= text then\n    text\
    \ = text:gsub(' ', '-')\n  end\n  return text\nend", "  local space\n  for space\
    \ in text:gmatch'[%z%s]*' do\n    if #space > 1 then\n      text = text:gsub('%'\
    \ .. space .. '([%z%s]+)', '%1_%2')\n    end\n  end\n  text = text:gsub('%(%z%s+%)',\
    \ '-%1')\n  return text\nend", "  return text:gsub(' ', ' '):gsub(' ', ' - '):gsub('\
    \ ', '-')\nend", "    local fixed_text = text\n    local space_count = 0\n   \
    \ while space_count < 2 do\n        -- Replace all spaces with underscores\n \
    \       fixed_text = fixed_text:gsub(' ', '\\uFF5F')\n        -- Increment space_count\
    \ if there are multiple spaces consecutively\n        space_count = space_count\
    \ + 1\n    end\n    -- Replace consecutive spaces with -\n    fixed_text = fixed_text:gsub('([\\\
    uFF5F][\\uFF5F])+', '\\1-')\n    return fixed_text\nend\n</cell>\n<cell>", " \
    \ local spaces = {\n    [\" \"] = \"_\",\n    [\"\"] = \"\",\n    [\"   \"] =\
    \ \"-\",\n    [\"    \"] = \"-\",\n    [\"    \"] = \"-\",\n  }\n  local result\
    \ = text\n  for i = 1, #spaces do\n    result = string.rep(result, spaces[i])\n\
    \  end\n  return result:gsub(\"  \", \"_\")\nend", "    local spaces = text:gsub(\"\
    %s+\", \" \")\n    if spaces:gsub(\"^ \", \"_\")\n    and spaces:gsub(\"^_*\"\
    , \"_\")\n    and spaces:gsub(\"^_*$\", \"_\") \n    then spaces = spaces:gsub(\"\
    ^ \", \"_\") \n    end\n    return spaces\nend\n</code>\n<|/ a dscore=3 |>\n<|\
    \ a tags=lua,regex dscore=1 |>\nHere's how I fixed the problem with the multiple\
    \ consecutive spaces while also taking care of upper/lower case letters (and numbers)\
    \ in the middle of the text:\n<code>", "    return text:gsub(' ', '_'):gsub('(\
    \ )', '_'):gsub('(  )', \n           '-'):gsub('  ', ' ')\nend", "  local fixed\
    \ = text:gsub('%S+', function(w)\n    return w:gsub('%S+', function(x)\n     \
    \ return x:gsub('%S+', '-')\n    end)\n  end)\n  return fixed:gsub('[-]+$', '')\n\
    end", "  local spaces = {}\n  local new_text = text\n  \n  -- Build a map of consecutive\
    \ spaces and whether or not \n  -- they should be replaced with a single dash\
    \ \n  for i = 0, #text - 1 do\n    local c = text[i]\n    \n    if c == ' ' then\n\
    \      table.insert(spaces, {i,false})\n    elseif c == '\\n' then\n      table.insert(spaces,\
    \ {i,true})\n    elseif c == '\\t' then\n      table.insert(spaces, {i,true})\n\
    \    elseif c == nil then\n      table.insert(spaces, {i,false})\n    end\n  end\n\
    \  \n  -- Replace each consecutive space with a dash\n  -- but only after having\
    \ already processed the string's leading spaces\n  for i, v in pairs(spaces) do\n\
    \    if #new_text == 0 then\n      new_text = v[1]\n    else\n      new_text =\
    \ new_text:sub(1,v[1]-1)..'-'..new_text:sub(v[1]+1)\n    end\n  end\n  \n  return\
    \ new_text\nend", "  return text:gsub(' ', '_'):gsub('  +', '_'):gsub('  +', '_')\n\
    end", "  local space_count = text:gsub(' ', ''):len()\n  if space_count > 1 then\n\
    \    return text:gsub(' ', '_'):gsub(' ', '-')\n  end\n  return text\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis is the only answer in here that actually removes multiple\
    \ spaces.\n<|/ c |>\n<| a tags=string,lua dscore=2 |>\n<code>", "   if text:match(\"\
    ^%s*(.-)%s*$\") then\n      return text:gsub(\"(%a+)\", \n         function(c)\
    \ return string.format(\"%_%a\", c:lower() .. \"_%a\") end\n      )\n   else\n\
    \      return text\n   end\nend", "  -- replace all spaces with _\n  text = text:gsub('\
    \ ', '_')\n  -- if there are more than 2 consecutive spaces, replace it with _\n\
    \  text = text:gsub('(%b)(%b)', '\\1_\\2')\n  -- if there is only one space, add\
    \ a _ before it\n  text = text:gsub('(%b)(%b)', '\\1_\\2')\n  return text\nend",
  "    local spaces_count = 0\n    local new_text = text\n    local space = \" \"\n\
    \    while true do\n        if string.find(new_text, \"%s\") then\n          \
    \  spaces_count = spaces_count + 1\n            if spaces_count > 2 then\n   \
    \             new_text = new_text:gsub(\"%s+\", space)\n            else\n   \
    \             new_text = new_text:gsub(\"%s\", space)\n            end\n     \
    \   else\n            break\n        end\n    end\n    return new_text\nend",
  "  local num_spaces = text:spaces()\n  if num_spaces > 1 then\n    local spaces\
    \ = text:sub(1,num_spaces)\n    text:gsub(' ','_')\n    text:gsub(' ', spaces)\n\
    \  end\n  return text\nend", "  local spaces = 0\n  local lastspace = text:find(\"\
    \ \")\n  while (not lastspace) do\n    spaces = spaces + 1\n    lastspace = text:find(\"\
    \ \")\n  end\n  local newtext\n  if #text > 1 then\n    newtext = text\n  elseif\
    \ spaces > 2 then\n    newtext = \"\"\n  else\n    return text\n  end\n  while\
    \ (lastspace and lastspace ~= lastspace-1) do\n    newtext = newtext .. \"_\"\n\
    \    lastspace = text:find(\" \")\n  end\n  return newtext\nend", "  return text:gsub('\
    \ ', '_') .. '_' \n  .. text:gsub(' ', '-')\n  .. text:gsub('  ', '~')\n  .. text:gsub('\
    \  ', '~')\nend", "  if text:match(' +') and text:match(' +'..' ') then\n    return\
    \ text:gsub(' +' .. ' ','-'):gsub(' +',' '):gsub(' -',' ')\n  else\n    return\
    \ text\n  end\nend", "   local num_spaces = string.gsub(text, \"^%s*(.)%s*$\"\
    , \"%1\")\n   if num_spaces > 2 then\n      return \"_\"..string.gsub(text, \"\
    ^%s*(.)[%w]*$\", \"%1\")\n   else\n      return text\n   end\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThis doesn't work properly for single letter words like `'a'`,\
    \ `'b'`, `'c'` etc, but will for multi-letter words such as `'apple'`, `'banana'`,\
    \ `'cake'` etc\n<|/ c |>\n<| a |>\nHere's an alternative to 's answer. Instead\
    \ of using gsub, we use gfind and gsub. Using gfind:\n<code>", "  local num_spaces\
    \ = 0\n  local new_text = text\n  -- find number of consecutive spaces\n  for\
    \ i = 1, #text do\n    if string.sub(text, i, i + 1) == ' ' then\n      num_spaces\
    \ = num_spaces + 1\n    else\n      num_spaces = 0\n    end\n    if num_spaces\
    \ == 2 then\n      new_text = new_text:sub(1, i - 1 .. '_')\n      num_spaces\
    \ = 0\n    end\n  end\n  if num_spaces > 1 then\n    -- find first non-space\n\
    \    local first_non_space = #new_text\n    for i = 1, #text do\n      if string.sub(text,\
    \ i, i + 1) ~= ' ' then\n        first_non_space = i\n        break\n      end\n\
    \    end\n    -- add dashes\n    new_text = new_text:sub(1, first_non_space -\
    \ 1 .. '_')\n  end\n  return new_text\nend", "  return text:gsub(\"[%w ]+\", function(s)\
    \ return s:gsub(\"[%w ]\", function(w) \n    return w:sub(\" \", \"_\"):sub(1,\
    \ w:len() - 1)\n  end)\n  end)\nend", "  text = text:gsub(\"[%l%p%c%x20%x0d%x0a]\"\
    , \"_\")\n  local spaces = text:gsub(\"  +\", \"_\"):gsub(\"^_+\", \"\")\n  if\
    \ spaces ~= spaces then\n    return text:gsub(\"_\", spaces)\n  else\n    return\
    \ text\n  end\nend", "    local spaces = text:gsub(\"%S\", \"_\") -- find all\
    \ spaces\n    local twospaces = spaces:gsub(\"  \", \"_\") -- replace consecutive\
    \ spaces with underscores\n    local len = #twospaces - 1\n    if len > 2 then\n\
    \        return twospaces:sub(1, len - 2):gsub(\"%S\", \"-\")\n    else\n    \
    \    return text\n    end\nend", "    return text:gsub(' ', ' - '):gsub(' +',\
    \ ' ')\nend\n</code>\n<|/ a |>\n<| a tags=string,lua |>\n<code>", "  -- First\
    \ replace any spaces in the text with underscores \n  -- >>> fix_spaces('Example')\n\
    \  -- 'Example'\n  -- >>> fix_spaces('Example 1')\n  -- 'Example_1'\n  -- >>>\
    \ fix_spaces('Example 2')\n  -- 'Example_2'\n  -- >>> fix_spaces('Example 3')\n\
    \  -- 'Example_3'\n  -- Then replace consecutive spaces with dashes \n  -- >>>\
    \ fix_spaces(' Example')\n  -- 'Example'\n  -- >>> fix_spaces(' Example 1')\n\
    \  -- 'Example_1'\n  -- >>> fix_spaces(' Example 2')\n  -- 'Example_2'\n  -- >>>\
    \ fix_spaces(' Example 3')\n  -- 'Example_3'\n  -- >>> fix_spaces(' Example 1\
    \ ')\n  -- 'Example_1'\n  -- >>> fix_spaces(' Example 2    ')\n  -- 'Example_2'\n\
    \  -- >>> fix_spaces(' Example 3 ')\n  -- 'Example_3'\n  -- Finally, if we have\
    \ three consecutive dashes, then just \n  -- replace all dashes with nothing\n\
    \  -- >>> fix_spaces('----')\n  -- '----'\n  -- >>> fix_spaces('--')\n  -- '-'\n\
    \  -- >>> fix_spaces('-----')\n  -- '-----'\n  -- >>> fix_spaces('------ ')\n\
    \  -- '------ ' \n  -- >>> fix_spaces('------ a')\n  -- '------ a' \n  -- >>>\
    \ fix_spaces('--- a')\n  -- '- a' \n  -- >>> fix_spaces('------ a ')\n  -- '------\
    \ a'\n  -- >>> fix_spaces('------ a b')\n  -- '------ a b' \n  -- >>> fix_spaces('------\
    \ a b c')\n  -- '------ a b c' \n  return text:gsub(\"[ -]+\", \"_\")\nend", " \
    \ return text:gsub(\"  \",\"_\")\nend", "  local spaces = text:gsub(' ', '_')\n\
    \  if text:gsub(' ', ' ') then\n    return text:gsub(' ', '_')\n  end\n  return\
    \ spaces\nend", "  -- Add underscore before space\n  text = text:gsub(' ','_')\n\
    \  -- Replace consecutive spaces with -\n  text = text:gsub(' ','-')\n  -- Restore\
    \ spaces after space\n  text = text:gsub('_',' ')\n  -- Replace underscore after\
    \ first dash\n  text = text:gsub('-','_')\n  return text\nend", "  return text:gsub('\
    \  ','_'):gsub('  ','-')\nend", "  local s = text:gsub(\"  \", \"_\")\n  if text:gsub(\"\
    _+$\", \"\") == \"\" then\n    return s\n  else\n    return s:gsub(\"_+\", \"\
    _\")\n  end\nend", "  local new_text = text\n  if text:find('  ') > -1 then\n\
    \    new_text = text:gsub('  ','_')\n  end\n  if text:find('  ') > -1 then\n \
    \   new_text = text:gsub('  ','-')\n  end\n  return new_text\nend", "   text =\
    \ text:gsub('%s', '%.-'):gsub('%s', '%.-'):gsub('%s', '%.-') \n   text = text:gsub('_+',\
    \ '-%'):gsub('_+', '%-')\n   if text:gsub('%s', '%.-'):gsub('%s', '%.-'):gsub('%s',\
    \ '%.-') == text then text = text end\n   return text\nend", "  local spaces =\
    \ string.gsub(text, \"  +\", \"_\")\n  if string.len(spaces) > 1 then\n    spaces\
    \ = string.gsub(spaces, \"  +\", \"_\")\n  end\n  return spaces\nend", "  local\
    \ last_space = -1\n  local fix_count = 0\n  for i = 1, #text do\n    if string.sub(text,\
    \ i, i) == ' ' then\n      last_space = i\n      fix_count = fix_count + 1\n \
    \   elseif fix_count >= 2 then\n      text:sub(i, i - 1) = '_'\n      last_space\
    \ = i - 1\n      fix_count = 0\n    end\n  end\n  if last_space >= 1 then\n  \
    \  text:sub(1, last_space - 1) = '-'\n  end\n  return text\nend", "    local fixed_text\n\
    \    local last_space\n    for i = 1,#text do\n        local c = text[i]\n   \
    \     if c == ' ' then\n            if not fixed_text then\n                fixed_text\
    \ = text\n                last_space = i\n            elseif last_space ~= i -\
    \ 1 then\n                fixed_text = fixed_text .. '_' .. text\n           \
    \     last_space = i\n            else\n                fixed_text = fixed_text\
    \ .. '_' .. text\n                last_space = i\n            end\n        else\n\
    \            fixed_text = fixed_text .. c\n        end\n    end\n    return fixed_text\n\
    end", "  local spaces = string.gsub(text, \"[ ]+\", \"_\")\n  local consecutive_spaces\
    \ = string.gsub(spaces, \"_+\", \"_\")\n  if consecutive_spaces == \"_\" then\n\
    \    return spaces -- no consecutive spaces found\n  end\n  return consecutive_spaces\
    \ .. \"-\"\nend", "  local new_text = text\n  local spaces = {}\n  for i = 1,\
    \ #text do\n    local c = text:sub(i,i)\n    if c == ' ' then table.insert(spaces,\
    \ i)\n    else new_text = new_text:sub(i-#spaces+1,i)..'_'..c:sub(1)\n    end\n\
    \  end\n  if #spaces > 1 then\n    new_text = new_text:sub((#spaces-1), #new_text)\n\
    \  end\n  return new_text\nend", "  text = text:gsub(' ', '_')\n  if text:gsub('\
    \ ', ' ')>2 then\n    local t = {}\n    for i=1,text:gsub(' ','_'):gsub(' ','_'):gsub('_','-'):gsub('-','_')\
    \ do \n      table.insert(t,i)\n    end\n    return text..'_' .. table.concat(t,'_')\n\
    \  end\n  return text\nend\n</cell>\n<text>\nFunction to remove multiple consecutive\
    \ spaces in text", "\tlocal spaces = ''\n\tlocal end = ''", "  local spaces\n\
    \  if text:match('%s+$') then\n    spaces = text:gsub('%s+', '%w_'):gsub('%s+$',\
    \ '')\n  else\n    spaces = ''\n  end\n  return text:gsub('%s+', spaces .. '-'):gsub('%s+$',\
    \ '')\nend\n</code>\n<|/ a tags=string,lua dscore=4 |>\n<| c |>\nNice and simple.\
    \ Thanks for sharing.\n<|/ c |>\n<| c |>\nIt works for me... However, when I run\
    \ this in Lua 5.2 I get an error \"attempt to perform arithmetic on global 'text'\
    \ (a nil value)\". I have no idea why it says this, but if I remove the `text`\
    \ parameters and make it `fix_spaces()` and then `print(fix_spaces('Example'))`\
    \ it works fine. Does anyone know why this is?\n<|/ c |>\n<| c |>\nI noticed that\
    \ this doesn't work when there is a space at the end of the string. In other words,\
    \ if you have `text = 'Example Text'`, then it returns `Example -Text` instead\
    \ of `Example-Text`.\n<|/ c |>\n<| c |>\nI ran the code on Lua 5.2 without issues.\
    \ Could you please clarify what you are seeing?\n<|/ c |>\n<| c |>\nI see it now\
    \ that I was using a string with a space at the end instead of a string. I was\
    \ just copying your example, which had a space at the end. I removed the space\
    \ and it works fine.\n<|/ c |>\n<| a |>\nThis should work for you:\n<code>", " \
    \ text = text:gsub(' ', '_')\n  text = text:gsub('  +', '-')\n  return text\n\
    end", "    local whitespace = string.char(_G.SPACE_CHAR) .. string.char(_G.SPACE_CHAR)\
    \ .. string.char(_G.SPACE_CHAR)\n    text = text:gsub(' '..whitespace, '-') --\
    \ replace spaces with -\n    return text\nend", "  text = text:gsub('%s+', string.upper)\n\
    \  text = text:gsub('([^%s]+)[%s]+', \n\t\t  string.upper, \n\t\t  string.upper)\n\
    \  text = text:gsub('[%s]+', string.upper)\n  return text\nend", "  return text:gsub('%s+',function(c)\
    \ return c==' ' and '_' or c end)\nend", "\t-- TODO: check input if text's length\
    \ is > 0 and if text\n\t-- does not contain space character\n\tlocal spaces_count\
    \ = string.gsub(text, \" \", \"_\")\n\t-- If number of spaces found > 2, then\
    \ insert underscores\n\t-- between consecutive spaces\n\tif spaces_count > 2 then\n\
    \t\tlocal space_count = 1\n\t\tlocal space_count_index = 1\n\t\tlocal fixed_text\
    \ = ''\n\t\tlocal new_text = text\n\t\t-- Loop through spaces until number of\
    \ spaces is > 2\n\t\twhile space_count ~= spaces_count do\n\t\t\t-- If current\
    \ space is less than previous, insert underscore\n\t\t\t-- between them\n\t\t\t\
    if space_count < spaces_count then\n\t\t\t\t-- Insert underscore between current\
    \ space and previous\n\t\t\t\t-- space\n\t\t\t\tfixed_text = new_text:gsub(\"\
    (\" .. space_count_index .. \")\",\n\t\t\t\t\t\t\"_\" .. space_count)\n\t\t\t\
    -- If current space is equal to previous, then leave current\n\t\t\t-- space untouched\n\
    \t\t\telse\n\t\t\t\tfixed_text = new_text:gsub(\"(\" .. space_count_index .. \"\
    )\", \"\")\n\t\t\tend\n\t\t\t-- Increment index to next space\n\t\t\tspace_count\
    \ = space_count + 1\n\t\t\tspace_count_index = space_count_index + 1\n\t\tend\n\
    \t\treturn fixed_text\n\t-- If number of spaces found < 2, then insert underscores\
    \ between\n\t-- spaces until number of spaces is < 2\n\telseif spaces_count <\
    \ 2 then\n\t\tlocal space_count = 1\n\t\tlocal space_count_index = 1\n\t\tlocal\
    \ fixed_text = ''\n\t\tlocal new_text = text\n\t\t-- Loop through spaces until\
    \ number of spaces is < 2\n\t\twhile space_count ~= spaces_count do\n\t\t\t--\
    \ If current space is less than previous, insert underscore\n\t\t\t-- between\
    \ them\n\t\t\tif space_count < spaces_count then\n\t\t\t\t-- Insert underscore\
    \ between current space and previous\n\t\t\t\t-- space\n\t\t\t\tfixed_text = new_text:gsub(\"\
    (\" .. space_count_index .. \")\",\n\t\t\t\t\t\t\"_\" .. space_count)\n\t\t\t\
    -- If current space is equal to previous, then leave current\n\t\t\t-- space untouched\n\
    \t\t\telse\n\t\t\t\tfixed_text = new_text:gsub(\"(\" .. space_count_index .. \"\
    )\", \"\")\n\t\t\tend\n\t\t\t-- Increment index to next space\n\t\t\tspace_count\
    \ = space_count + 1\n\t\t\tspace_count_index = space_count_index + 1\n\t\tend\n\
    \t\treturn fixed_text\n\t-- Otherwise, no more spaces found, so just insert\n\t\
    else\n\t\treturn text\n\tend\nend", "  local has_spaces = false\n  local result\
    \ = text\n  -- If text is empty, return the same text as input\n  if text == nil\
    \ then\n    return text\n  else\n    local spaces = ''\n    -- Find out how many\
    \ consecutive spaces we have\n    local count_spaces = 0\n    for i = 1, #text\
    \ do\n      if text[i] == ' ' then\n        count_spaces = count_spaces + 1\n\
    \      elseif count_spaces > 1 then\n        count_spaces = 0\n        spaces\
    \ = spaces .. '-'\n      end\n    end\n    if count_spaces > 1 then\n      --\
    \ If text has more than one consecutive space, \n      -- then use '_' to replace\
    \ all spaces with '-' \n      spaces = spaces .. '_' -- use '_' instead of ' '\n\
    \    end\n    \n    has_spaces = true\n    -- Replace all spaces with '_'\n  \
    \  result = result:gsub(' ', '_')\n    if spaces ~= '' then\n      -- Replace\
    \ consecutive spaces with '-'\n      result = result:gsub(' ', spaces)\n    end\n\
    \  end\n  return has_spaces and result or text\nend", "    return text:gsub('\
    \ ', '_')\nend", "    return text:gsub('%S', function(x)\n        return x:gsub('\
    \ ', ''):gsub('  ', '-')\n    end)\nend", "  text = text:gsub('%S+', function(m)\n\
    \  \tlocal result = m:gsub(' ','_')\n  \tlocal result = result:gsub(' ','-')\n\
    \  \treturn result\n  end)\n  return text\nend", "  local n = text:gsub(\"%s+\"\
    , '_')\n  if text:gsub(\"%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%-%",
  "  local space_count = text:gsub(' ', ''):gsub(' ','_')\n  return text:gsub(' ',\
    \ '_') .. '_' .. space_count\nend\n</cell>\n<text>\n2.5 Split into paragraphs\n\
    We have seen how to split text into sentences and words.", "    local spaces =\
    \ text:gsub(' ', '_ ')\n    if spaces:match ' {2,}' then\n        spaces = text:gsub('\
    \ ', '- ')\n    end\n    return spaces\nend", "   return text:gsub('%s+', function(c)\n\
    \      local s = ''\n      for i = 1, #c do\n         s = s .. c[i]:gsub('..',\
    \ function(c)\n            return string.format('%c%c' % (\n               string.rep(c,\
    \ '-', ' '):byte(), \n               string.rep(c, '-', ' '):byte())\n       \
    \     end\n            )\n         end)\n      end\n      return s\n   end)\n\
    end", "  text = text:gsub('[ ]+', '_')\n  text = text:gsub('  +', '-')\n  return\
    \ text\nend", "  text = text:gsub('[ ]+', '_')\n  text = text:gsub('[ ]+$', '')\n\
    \  if text:gsub('%s+', function(c)\n    return c == ' ' and c or '-'\n  end):gsub('%s+$',\
    \ function(c)\n    return c == ' ' and c or ''\n  end) == '--' then\n    return\
    \ text\n  else\n    return text\n  end\nend", "    return text:gsub('%S+', function(w)\
    \ \n        return w == ' ' and w or ('_' .. w)\n    end)\nend\n</cell>\n<text>\n\
    Let's try it with a few examples.", "  -- Replace all consecutive spaces with\
    \ underscore\n  text = text:gsub('  ','_')\n  -- Replace all spaces with underscore\n\
    \  text = text:gsub(' ','_')\n  -- Replace more than 2 consecutive spaces with\
    \ -\n  text = text:gsub('  ','-')\n  return text\nend", "    return text:gsub('\
    \ ','_'):gsub('%S+','-%S-'):gsub('( +)','-'):gsub('( +)','-'):gsub('-+','-')\n\
    end", "\tlocal s = text:gsub(' ','_')\n\tif s ~= s then\n\t\treturn '-' .. s\n\
    \tend\nend", "    local num_spaces = 0\n    local last_space = -1\n    local new_text\
    \ = \"\"\n    for i = 1, #text do\n        local c = text:sub(i, i)\n        if\
    \ c == \" \" then\n            if num_spaces <= 1 then\n                new_text\
    \ = new_text .. \"_\"\n                num_spaces = num_spaces + 1\n         \
    \   else\n                new_text = new_text .. \"-\"\n                num_spaces\
    \ = num_spaces - 1\n            end\n        else\n            new_text = new_text\
    \ .. c\n        end\n    end\n    return new_text\nend", "  return text:gsub('\
    \ ', '_'):gsub('  ', '___')\nend", "  text = text:gsub('%s+', '%s'):gsub('%s{2}','_%s')\n\
    \  text = text:gsub('%s+$', '%s')\n  return text\nend", "  text = text:gsub('\
    \ ', '_')\n  local last_space = -1\n  local new_text = ''\n  for i=1,#text do\n\
    \    if last_space < 0 and text[i] == ' ' then\n      new_text = new_text .. '_'\
    \ .. text[i]\n      last_space = i\n    elseif last_space < i and text[i] == '\
    \ ' then\n      new_text = new_text .. '_' .. text[i]\n    elseif last_space <\
    \ i and text[i] == ' ' then\n      new_text = new_text .. '-'\n      last_space\
    \ = i\n    end\n  end\n  return new_text\nend", "  local result = text\n  result\
    \ = result:gsub(\"[[ \\t]]+\", \"_\")\n  if result:match(\"_%-\") then\n    result\
    \ = result:gsub(\"_%-\", \"_\")\n  end\n  result = result:gsub(\"_+\", \"_\")\n\
    \  return result\nend", "  return text:gsub(' ','_'):gsub('  +','-'):gsub('  -','_')\n\
    end", "  text = string.gsub(text, '  ', '|_')\n  text = text:gsub('  +', '|-')\n\
    \  return text\nend", "    local spaces_regex = \" {2,}\"\n    local spaces_regex_nospaces\
    \ = \" {2,}\"\n    local function replace_spaces(input)\n        local output_spaces\
    \ = input:gsub(spaces_regex, \"_\")\n        local output_nospaces = input:gsub(spaces_regex_nospaces,\
    \ \"-\")\n        return output_spaces .. output_nospaces\n    end\n    return\
    \ replace_spaces(text)\nend", "\tlocal space_count = text:spacecount()\n\tlocal\
    \ last_space_index = text:rfind(' ', 1, 1)\n\tif space_count > 1 then\n\t\tlocal\
    \ first = text:sub(1, last_space_index)\n\t\tlocal last = text:sub(last_space_index\
    \ + 1)\n\t\ttext = first..'_'.. last\n\tend\n\tif text:spacecount() > 1 then\n\
    \t\tlocal first = text:sub(1, text:spaceindex()-1)\n\t\tlocal last = text:spaceindex()\n\
    \t\ttext = first..'-'..last\n\tend\n\treturn text\nend", "  return text:gsub('\
    \ ', ' '):gsub(' ', '- ')\nend\n</cell>\n<cell>", "  local consecutive_spaces\
    \ = 0\n  local new_text = text\n  new_text:gsub(' ', function(s)\n    if consecutive_spaces\
    \ > 1 then\n      new_text = new_text:gsub('%S+', '%S-')\n    else\n      consecutive_spaces\
    \ = consecutive_spaces + 1\n    end\n  end)\n  return new_text\nend", "    local\
    \ spaces = {}\n    for i, v in ipairs(text) do\n        if v ~= ' ' then spaces[i]\
    \ = v end\n    end\n    return table.concat(spaces, '_')\nend", "   local spaces\
    \ = text:gsub('[ ]', '_')\n   local spcs = text:gsub('[ ]+', '_')\n   return text\n\
    \      ..spaces\n      ..(text:gsub('[ ]+$', '_'))\nend\n</code>\n<|/ a |>\n<|\
    \ a |>\n<code>", "  text = text:gsub('^%s*(%S+)%s*$', '%1%2')\n  local consecutive\
    \ = ''\n  local i = 0\n  while text:match('(%S+)') do\n    i = i + 1\n    local\
    \ word = text:sub(1, i)\n    local space = text:sub(i, i + 1)\n    text = text:gsub('%S+',\
    \ '%' .. space .. '%')\n  end\n  local result = text:gsub('%S+', '%')\n  while\
    \ text:match('%-+') do\n    local space = text:sub(1, 1)\n    text = text:gsub('%-+',\
    \ '%' .. space .. '%')\n  end\n  return result .. consecutive\nend", "  return\
    \ text:gsub(' ', '_')\nend", "  local s = text:gsub(' ', '\\u0000') -- Convert\
    \ all spaces to null bytes\n  -- If there are too many consecutive spaces, replace\
    \ them all with '-'\n  s = s:gsub('(.)\\\\1', '\\1') -- Find all consecutive spaces\n\
    \  return s:gsub('-') -- Replace them all with '-'\nend\n</cell>\n<text>\nThe\
    \ function fix_spaces takes a string text and returns a string where all spaces\
    \ are replaced with underscores and if there are more than 2 consecutive spaces,\
    \ all consecutive spaces are replaced with -.  For example, the following text:",
  "  local s = text:gsub(\"[ ]+\", \"_\")\n  -- This one is a bit tricky: if there\
    \ are two consecutive spaces,\n  -- then we add an underscore instead of a dash.\n\
    \  s = s:gsub(\" *([%s])\", \"_$1\")\n  return s:gsub(\" *$\", \"_\")\nend\n</cell>\n\
    <code language=julia-1.4>\n# Replace all non-alphanumeric characters with underscores",
  "    local spaces = text:gsub('  +', ' - ')\n    return text:gsub('  +', '_')\n\
    end\n</cell>\n<text>\nNow we have some functions we can use to clean up our data.\
    \ In the cell below, we are reading the data into a table called 'data' and then\
    \ applying the fix_spaces function.", "  return text:gsub(' ', '_'):gsub('  ',\
    \ '-')\nend", "    local space_counts = { [1] = 0, [2] = 0, [3] = 0, [4] = 0 }\n\
    \    for i = 1, #text do\n        if text[i] == \" \" then\n            space_counts[#space_counts\
    \ + 1] += 1\n        end\n    end\n    if space_counts[1] > 2 then\n        return\
    \ text\n    end\n    local fixed_text = text\n    for i = 1, #space_counts do\n\
    \        if space_counts[i] > 1 then\n            fixed_text = fixed_text..'_'\n\
    \        end\n    end\n    return fixed_text\nend", "   local fixed_text = text\n\
    \   for i = 1, #text, 1 do\n      local c = text[i]\n      -- Replace all spaces\
    \ with underscores\n      if c == ' ' then\n         fixed_text = fixed_text ..\
    \ '_' \n      else\n         fixed_text = fixed_text .. c\n      end\n   end",
  "    local spaces = text:gsub(' ', '_')\n    local num_spaces = text:gsub(' ', ''):gsub('%S',\
    \ ''):gsub('-', '_')\n    if spaces ~= text or num_spaces ~= text then\n     \
    \   return spaces\n    end\n    return text\nend", "\ttext = text:gsub(' ','_')\n\
    \ttext = text:gsub('  +',function(m)\n\t\treturn m:gsub('  +','-')\n\tend)\n\t\
    return text\nend", "    local space_count = text:match('%s+')\n    if space_count\
    \ and space_count == text:match('(%S+)') then\n        space_count = text:match('%S+')\n\
    \        local s = ''\n        for i = 1, space_count do\n            s = s ..\
    \ '_'\n        end\n        return s:gsub(' +', '-')\n    end\n    return text\n\
    end", "\tlocal s = text:gsub(' ','_')\n\ts = s:gsub(' ','-')\n\tif text:gsub('\
    \ ','_')~=s then\n\t\treturn s\n\telse\n\t\treturn text\n\tend\nend", "  text\
    \ = string.gsub(text, \"[[:space:]]\", \"_\")\n  text = string.gsub(text, \" \
    \ *\", \"_\")\n  return text\nend", "  local consecutive, result = false, false\n\
    \  local function rewrite(s)\n    return s:gsub(\"%S\", function (x)\n      if\
    \ consecutive then\n        return x:gsub(\"%S\", \"_\")\n      end\n      consecutive\
    \ = true\n      return x\n    end)\n  end\n  while true do\n    if text:sub(1,1)\
    \ == \" \" then\n      result = true\n      text = rewrite(text)\n    end\n  \
    \  local l = text:len()\n    if l == 0 then\n      return text\n    end\n    text\
    \ = text:sub(1,l)\n    if text:sub(1,1) == \" \" then\n      text = rewrite(text)\n\
    \    end\n  end\nend", "  local spaces_count = text:find(' ', 1, 1)\n  if spaces_count\
    \ == nil then\n    return text\n  else\n    -- if string starts with one or more\
    \ spaces\n    if text:sub(1,1) == ' ' then\n      -- then return same string with\
    \ consecutive spaces replaced with -\n      return text:sub(1,1):gsub(' ', '_')\n\
    \    else\n      -- otherwise return string with first space replaced with _\n\
    \      return text:sub(1,1):gsub(' ', '_'):sub(1, text:len())\n    end\n  end\n\
    end", "  local result = text\n  -- Replace multiple spaces with just one\n  result\
    \ = result:gsub( ' ','_')\n  -- Remove any multiple spaces between words\n  result\
    \ = result:gsub(' %w+',function(t) return t:sub(1,-1) end)\n  -- Trim spaces\n\
    \  result = result:gsub('^ +',' '):gsub(' +$','')\n  return result\nend", "  text\
    \ = text:gsub(' ','_')\n  text = text:gsub('  +',function(x) return x:gsub(' \
    \ +','-') end)\n  return text\nend", "  local spaces = ''\n  local no_spaces =\
    \ ''\n  local last_char = {}", "    local spaces = text:gsub('%s+', function(c)\
    \ return '_' end)\n    local multiple_spaces = text:gsub('%s{2,}', function(c)\
    \ return '-' end)\n    return multiple_spaces ~= spaces and spaces or multiple_spaces\n\
    end", "    local s = text:gsub(\"%S+\", function(c) \n        if c ~= \" \" then\
    \ return c end\n        local prev_space = text:sub(1, -2)\n        local space\
    \ = text:sub(1, -2)\n        if prev_space ~= space then \n            return\
    \ prev_space .. \"_\"\n        else\n            return space\n        end\n \
    \   end)\n    if text ~= s then\n        return fix_spaces(s)\n    else\n    \
    \    return text\n    end\nend", "    local space_idx = 1\n    local new_text\
    \ = ''\n    for i,c in ipairs(text) do\n        if c == ' ' then\n           \
    \ space_idx = space_idx + 1\n        elseif space_idx == 1 then\n            new_text\
    \ = new_text .. c\n        else\n            new_text = new_text .. '_' .. c\n\
    \        end\n    end\n    return new_text\nend", "    local fixed = text:gsub('\
    \ ', '_')\n    if #fixed > 2 then\n        fixed = fixed:gsub('  ', '- ')\n  \
    \  end\n    return fixed\nend\n</code>\n<|/ a tags=string,lua dscore=3 |>\n<|\
    \ c |>\nJust note that Lua's `gsub` can take a table as the second argument, so\
    \ you can put the `'_'` and `'-'` pairs into the table and call `fixed:gsub(t)`.\
    \ That way you have a single function call instead of two.\n<|/ c |>\n<| c |>\n\
    Note that this will also replace consecutive spaces with dashes, not just the\
    \ ones that are separating two words. For example, `fix_spaces('aaa b') -- returns\
    \ \"aaa_b\"`. You could add `text = text:gsub(' ', fixed)` right before `return\
    \ fixed`\n<|/ c |>\n<| a dscore=3 tags=string,lua |>\nI needed this for Lua 5.3\
    \ with my application.  I needed to replace all instances of an underscore followed\
    \ by a hyphen (-) with just a single underscore.\n<code>", "  local s = text:gsub('\
    \ ','_')\n  local has_spaces = text:match('^%s*(.-)%s*$') ~= nil\n  if has_spaces\
    \ then\n    s = text:gsub(' ','-')\n  end\n  return s\nend", "  local space_re\
    \ = '[[:space:]]+'\n  local sep1, sep2 = text:find(space_re), text:find(space_re,\
    \ 0, true)\n  local s = ''\n  if sep1 and sep2 then\n    if sep2 == sep1+1 then\n\
    \      s = text:sub(1, sep2-1)\n    else\n      s = text:sub(1, sep2-1):gsub('\
    \ ', '_')\n      s = s:gsub(' ', '_')\n    end\n  else\n    s = text:gsub(' ',\
    \ '_')\n  end\n  return s\nend", "   return text:gsub(' ', '_'):gsub('  ', '-'_)\n\
    end", "  local spaces = text:match('^%s*(.-)%s*$')\n  -- Replace all consecutive\
    \ spaces with one dash\n  if spaces and spaces:gsub('%s+', '') == '_' then spaces\
    \ = '-' end\n  return text:gsub('%s+', spaces)\nend", "  text = text:gsub(' ',\
    \ ' - ')\n  if text:match('%S+$') then\n    text = text:gsub('( +)', '-%1')\n\
    \  else\n    text = text:gsub('(%S+)( +)', '\\1-\\2')\n  end\n  return text\n\
    end", "  local s = text:gsub('[ ]+', '_')\n  if #text > 1 then\n    s = s:gsub('[\
    \ ]+', '-')\n  end\n  return s\nend", "    local nspaces = string.gsub(text, '\
    \ ', '', 'g')\n    local nspaces = string.gsub(nspaces, '_', '-', 'g')\n    return\
    \ nspaces\nend\n</cell>\n<cell>", "  -- First replace any spaces with underscores\n\
    \  local result = text\n  result = result:gsub('%S+',function (t) \n    return\
    \ t:gsub(' ','_'):gsub('-','_')\n  end)", "  local spaces = string.gsub(text,\
    \ \"[[:space:]]+\", \"_\")\n  local multiple = string.gsub(spaces, \"_{2,}\",\
    \ \"_\")\n  local dash = string.gsub(multiple, \"_\", \"-\")\n  return text..dash\n\
    end", "  local spaces = ''\n  local last_space_idx = 1\n  for i = 1, #text do\n\
    \    local c = text[i]\n    if c == ' ' then\n      spaces = spaces .. '_'\n \
    \     last_space_idx = i\n    elseif i == #text - 1 then\n      spaces = spaces\
    \ .. c\n    end\n  end\n  return spaces .. text\nend", "    local fixed = text\n\
    \    local consecutive_spaces = false\n    for w in text:gmatch('([^ ])') do\n\
    \        if w ~= ' ' then\n            if consecutive_spaces then\n          \
    \      fixed = fixed..'-'\n            else\n                fixed = fixed..'_'\
    \ -- Add an underscore before the first non-space character\n                consecutive_spaces\
    \ = true\n            end\n        else\n            fixed = fixed..' '\n    \
    \        consecutive_spaces = false\n        end\n    end\n    return fixed\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't work for me because \"\
    Example 3\" turns into \"_Example-3\" instead of \"Example-3\"\n<|/ c |>\n<| c\
    \ |>\nHi Gary, you seem to have found a bug in `fix_spaces`. It doesn't work correctly\
    \ when there is only one non-space character in the string. I've fixed it (see\
    \ the last section of my answer).\n<|/ c |>\n<| c |>\nNice one! I guess you could\
    \ simplify this by adding `fixed = fixed..'_' .. fixed:sub(1,1)` to the `else`\
    \ block.\n<|/ c |>\n<| c |>\nYes, but then you would have to modify the `fix_spaces`\
    \ function for other languages which use non-breaking spaces.\n<|/ c |>\n<| c\
    \ |>\nI didn't notice that he was using non-breaking spaces, sorry! I'll test\
    \ this on my next project and update this answer.\n<|/ c |>\n<| a dscore=2 |>\n\
    This might help:\n<code>", "  return text:gsub('%S+', function(spaces)\n    if\
    \ spaces ~= spaces then\n      return '_' .. spaces\n    end\n    local newspaces\
    \ = ''\n    repeat\n      newspaces = spaces .. newspaces\n      if newspaces\
    \ ~= spaces then\n        newspaces = ''\n      end\n      spaces = newspaces:gsub('%S+',\
    \ function(spaces)\n        return ''\n      end)\n    until spaces == spaces\n\
    \    return spaces\n  end)\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
