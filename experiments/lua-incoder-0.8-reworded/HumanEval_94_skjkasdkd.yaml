name: HumanEval_94_skjkasdkd
language: lua
prompt: "-- You are given a table of integers.\n-- You need to find the largest prime\
  \ value and return the sum of its digits.\n-- Examples:\n-- >>> skjkasdkd({0, 3,\
  \ 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3})\n-- 10\n--\
  \ >>> skjkasdkd({1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1})\n--\
  \ 25\n-- >>> skjkasdkd({1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30,\
  \ 1, 9, 3})\n-- 13\n-- >>> skjkasdkd({0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0,\
  \ 5, 6})\n-- 11\n-- >>> skjkasdkd({0, 81, 12, 3, 1, 21})\n-- 3\n-- >>> skjkasdkd({0,\
  \ 8, 1, 2, 1, 7})\n-- 7\nlocal function skjkasdkd(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = skjkasdkd\n\
  \    lu.assertEquals(candidate({0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4,\
  \ 32, 3, 2, 32, 324, 4, 3}), 10)\n    lu.assertEquals(candidate({1, 0, 1, 8, 2,\
  \ 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}), 25)\n    lu.assertEquals(candidate({1,\
  \ 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}), 13)\n    lu.assertEquals(candidate({0,\
  \ 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}), 11)\n    lu.assertEquals(candidate({0,\
  \ 81, 12, 3, 1, 21}), 3)\n    lu.assertEquals(candidate({0, 8, 1, 2, 1, 7}), 7)\n\
  \    lu.assertEquals(candidate({8191}), 19)\n    lu.assertEquals(candidate({8191,\
  \ 123456, 127, 7}), 19)\n    lu.assertEquals(candidate({127, 97, 8192}), 10)\nend\n\
  \nos.exit(lu.LuaUnit.run())"
completions: ["  local prime, digits = lst[1], lst[2]\n  local sum = 0\n  for i =\
    \ 2, digits do\n    if prime == 1 then\n      return 0\n    end\n    if prime\
    \ == 0 then\n      prime, digits = lst[3], lst[4]\n      sum = 1\n    end\n  \
    \  if prime == 2 then\n      local prime2, digits2 = lst[5], lst[6]\n      local\
    \ sum2 = sum\n      -- we already checked that digits are prime\n      if prime2\
    \ ~= 1 then\n        local prime, digits = lst[7], lst[8]\n        local sum3\
    \ = sum2\n        if prime == 1 then\n          return 0\n        end\n      \
    \  if prime == 0 then\n          prime, digits = lst[9], lst[10]\n          sum1\
    \ = 1\n        end\n        if prime == 2 then\n          local prime2, digits2\
    \ = lst[11], lst[12]\n          local sum2 = sum3\n          if prime2 == 1 then\n\
    \            return 0\n          end\n          if prime2 == 0 then\n        \
    \    prime, digits = lst[13], lst[14]\n            sum1 = 1\n          end\n \
    \         if prime2 == 2 then\n            local prime2, digits2 = lst[15], lst[16]\n\
    \            local sum2 = sum3\n            -- we already checked that digits\
    \ are prime\n            if prime2 ~= 1 then\n              local prime, digits\
    \ = lst[17], lst[18]\n              local sum3 = sum2\n              if prime\
    \ == 1 then\n                return 0\n              end\n              if prime\
    \ == 0 then\n                prime, digits = lst[19], lst[20]\n              \
    \  sum1 = 1\n              end\n              if prime == 2 then\n           \
    \     local prime2, digits2 = lst[21], lst[22]\n                local sum2 = sum3\n\
    \                if prime2 == 1 then\n                  return 0\n           \
    \     end\n                if prime2 == 0 then\n                  prime, digits\
    \ = lst[23], lst[24]\n                  sum1 = 1\n                end\n      \
    \          if prime2 == 2 then\n                  local prime2, digits2 = lst[25],\
    \ lst[26]\n                  local sum2 = sum3\n                  -- we already\
    \ checked that digits are prime\n                  if prime2 ~= 1 then\n     \
    \               local prime, digits = lst[27], lst[28]\n                    local\
    \ sum3 = sum2\n                    if prime == 1 then\n                      return\
    \ 0\n                    end\n                    if prime == 0 then\n       \
    \               prime, digits = lst[29], lst[30]\n                      sum1 =\
    \ 1\n                    end\n                    if prime == 2 ", "  if #lst\
    \ == 0 then\n    return 0\n  end\n  local i = #lst\n  local max = 1\n  local curr\
    \ = 2\n  while i > 1 do\n    if lst[#lst - i - 1] < curr then\n      max = curr\n\
    \      curr = curr + 1\n    else\n      max = max * ((lst[#lst - i - 1] - curr)\
    \ / i)\n      curr = (lst[#lst - i - 1] - curr) % i\n    end\n    i = i - 1\n\
    \  end\n  max = max * curr\n  return max\nend", "    if lst == nil then\n    \
    \    return nil\n    end\n    local largest, prime, sum, i, j = 1, 0, 0, 0\n \
    \   local last_prime, last_sum, last_i = 0 -- Tracks the largest prime we've seen\
    \ and the sum of the last digit\n    for i = 2, #lst do\n        local prime,\
    \ sum = 0, 0\n        for j = 2, #lst do\n            if i == lst[j] then\n  \
    \              sum = sum + j\n                if sum > prime then\n          \
    \          prime, sum = sum, j\n                    largest = i\n            \
    \    end\n                break\n            end\n        end\n        if prime\
    \ < 2 then\n            largest = i\n        end\n        if prime > last_prime\
    \ then\n            if j - last_sum > 1 then\n                prime = last_prime\n\
    \                sum = last_sum + j\n            else\n                prime,\
    \ sum = prime, j\n            end\n            last_prime, last_sum = prime, sum\n\
    \            last_i = i\n        end\n        last_sum = last_sum + j\n    end\n\
    \    return prime * 10 + sum + last_i\nend", "    local max = 0 \n    local largest\
    \ = 0\n    local largestPrime = 0", "  local largest, largestPrime = 2, nil\n\
    \  for _, b in ipairs(lst) do\n    if b > largest then\n      largest, b = b,\
    \ largestPrime\n    elseif b == largestPrime then\n      largestPrime = largest\n\
    \    end\n  end\n  if largestPrime == nil then\n    return 0\n  end\n  largestPrime\
    \ = largestPrime or largest\n  local sum = 0\n  local pos = 1\n  local lastDigit\
    \ = nil\n  for i = 2, largestPrime do\n    local digit = math.floor((largestPrime\
    \ - i) / i)\n    if lastDigit == nil or digit > lastDigit then\n      sum = tostring(digit)\
    \ + tostring(sum)\n      lastDigit = digit\n    end\n  end\n  return tonumber(sum)\n\
    end", "  -- initialize max to the first element in the list\n  local max = lst[1]\n\
    \  -- initialize current to the first element in the list\n  local current = lst[1]\n\
    \  -- initialize sum to 0\n  local sum = 0\n  -- loop through each element in\
    \ the list\n  for _, element in ipairs(lst) do\n    -- if the current element\
    \ is greater than the max then we found a new max\n    if element > max then\n\
    \      -- set the new max\n      max = element\n      -- set current to 0\n  \
    \    current = element % max\n    else\n      -- if the current element is the\
    \ same as the current max and the current number is smaller than the previous\
    \ max then we have found a new prime\n      if current == max and element < max\
    \ then\n        current = element % max\n      -- if the current element is the\
    \ same as the current max but it's larger than the current max then we found a\
    \ duplicate\n      elseif current == max and element > max then\n        -- add\
    \ up the digits of current and multiply it by current \n        sum = sum + math.floor(element\
    \ / max) * current\n        -- reset the current number so it can be used again\n\
    \        current = 0\n      -- if the current element is not the same as the current\
    \ max and it's larger than the current max then we found a duplicate\n      elseif\
    \ not current == max and element > max then\n        -- add up the digits of current\
    \ and multiply it by current \n        sum = sum + math.floor(element / max) *\
    \ current\n        -- reset the current number so it can be used again\n     \
    \   current = 0\n      -- if the current element is not the same as the current\
    \ max and it's smaller than the previous max then we have found a new prime\n\
    \      elseif not current == max and element < max then\n        -- add up the\
    \ digits of current and multiply it by current \n        sum = sum + math.floor(element\
    \ / max) * current\n        -- reset the current number so it can be used again\n\
    \        current = 0\n      -- if the current element is not the same as the current\
    \ max and it's equal to current max then we found a new prime\n      elseif not\
    \ current == max and element == max then\n        -- add up the digits of current\
    \ and multiply it by current \n        sum = sum + math.floor(element / max) *\
    \ current\n        -- reset the current number so it can be used again\n     \
    \   current = 0\n      -- if the current element is not the same as the current\
    \ max and it's smaller than the current max then we found a duplicate\n      elseif\
    \ not current == max and element < max then\n        -- add up the digits of current\
    \ and multiply it by current \n        sum = sum + math.floor(element / max) *\
    \ current\n        -- reset the current number so it can be used again\n     \
    \   current = 0\n      -- if the current element ", "  -- first we need to check\
    \ all of the numbers are even as they aren't\n  -- divisible by 2, therefore we\
    \ only need to check the odd ones\n  -- also the largest one is the first one\n\
    \  local max_num = lst[1]\n  lst[1] = nil\n  for i = 2, #lst do\n    if lst[i]\
    \ % 2 == 0 then\n      -- if the number is even we just need to check to see if\
    \ the rest are even\n      -- if not we know it isn't a prime\n      if not lst[i]\
    \  % 2 == 0 then\n        max_num = lst[i]\n        break\n      else\n      \
    \  max_num = nil\n      end\n    end\n  end\n  -- if the largest number was not\
    \ found its not a prime\n  if max_num == nil then\n    return nil\n  end\n  --\
    \ get the first digit of largest number\n  local first_digit = math.floor(max_num\
    \ / 10)\n  -- get the remainder of the number after the first digit\n  local remainder\
    \ = max_num - first_digit * 10\n  -- we only need to check for numbers that are\
    \ divisible by the first digit\n  -- as any number that starts with the digit\
    \ can be ignored\n  for i = 1, first_digit do\n    if remainder % i == 0 then\n\
    \      return nil\n    end\n  end\n  -- return the sum of all the digits of the\
    \ number\n  return math.floor(remainder / 10)\nend", "    if lst[1] == nil then\
    \ return nil end\n    local max = lst[1]\n    for i = 2, #lst do\n        if max\
    \ % i == 0 then\n            max = max/i + lst[i]\n        end\n    end\n    return\
    \ max\nend", "  if #lst == 0 then return 0 end\n  if #lst == 1 then\n    return\
    \ lst[1]\n  end\n  local max = 1\n  local prime = 1\n  local primesum = 0\n  for\
    \ i, v in ipairs(lst) do\n    if v == 0 and primesum > prime then\n      prime\
    \ = primesum\n    elseif prime > max then\n      prime = max\n    end\n    max\
    \ = v\n    primesum = prime + primesum\n  end\n  return primesum\nend", "  local\
    \ max_prime\n  local max_sum\n  local prime_sum = 0\n  for i = 2, #lst do\n  \
    \  local n = lst[i]\n    local primes = primes.union(i * i)\n    local sum = i\
    \ * 10\n    for j = 2, sqrt(n) do\n      local prime = primes.iadd(j)\n      if\
    \ prime > max_prime then\n        max_prime = prime\n        max_sum = sum\n \
    \     end\n      sum = sum + n\n    end\n    if prime > max_prime then\n     \
    \ max_prime = prime\n      max_sum = sum\n    end\n  end\n  return max_prime +\
    \ max_sum\nend", "\t-- Check base case.\n\tif lst[1] <= 2 then\n\t\treturn lst[1]\n\
    \tend", "    local largest, i = nil, 0\n    for i, v in ipairs(lst) do\n     \
    \   if largest==nil or v <= largest then\n            largest = v\n        else\n\
    \            if v == largest and (v%largest==0 or v%largest==largest-1) then\n\
    \                largest = largest\n            end\n        end\n    end\n  \
    \  return largest\nend", "    local largest = nil\n    local sum = 0", "    local\
    \ maxprime = 1\n    local maxcount = 0\n    local maxsum = 0\n    for _, v in\
    \ ipairs(lst) do\n        if maxprime <= math.floor(v) then\n            if maxcount\
    \ == 0 then\n                maxprime = math.floor(v)\n                maxsum\
    \ = v\n                maxcount = v\n            elseif maxcount <= v then\n \
    \               maxsum = maxsum + v\n                maxcount = maxcount + 1\n\
    \            end\n        else\n            if maxcount == 1 then\n          \
    \      maxprime = math.ceil(v)\n                maxsum = v\n                maxcount\
    \ = v\n            end\n        end\n    end\n    if maxcount == 2 then\n    \
    \    if maxprime == math.ceil(lst.last) then\n            maxprime = math.floor(lst.last)\n\
    \            maxsum = lst.last\n        end\n    end\n    return maxsum\nend",
  "  local largest\n  for i = 1, #lst do\n    local prime = skjkasdkd(lst:sub(i, i))\n\
    \    if prime and prime > largest then\n      largest = prime\n    end\n  end\n\
    \  if largest then\n    return largest + sum(lst:sub(1, #lst))\n  end\nend\n</cell>\n\
    <text>\nskjkasdkd", "    local max = 2\n    local prime = 0\n    local sum = 0\n\
    \    local n = #lst\n    for i = 1, n do\n        if lst[i] == 1 then\n      \
    \      if prime > max then\n                max = prime\n            end\n   \
    \         sum = 1\n        else\n            if prime == 0 then\n            \
    \    prime = 1\n                max = prime\n            end\n            if lst[i]\
    \ % prime == 0 then\n                if prime > max then\n                   \
    \ max = prime\n                end\n            else\n                prime =\
    \ prime * lst[i]\n                if prime > max then\n                    max\
    \ = prime\n                end\n            end\n            sum = (sum * lst[i])\
    \ + lst[i]\n        end\n    end\n    return max * sum\nend", "    local max_prime\
    \ = 0 -- prime so far\n    local prime = 0 -- primes\n    local max_sum = 0 --\
    \ sum of digits\n    local sum = 0 -- sum of digits in digits\n    for i = 1,\
    \ #lst do\n        local digit = lst[i]\n        if digit > 0 then\n         \
    \   local max_digit = math.floor(math.log10(digit)) + 1 -- max digit so far\n\
    \            for j = 3, max_digit, 2 do\n                if digit % j == 0 then\n\
    \                    prime = j\n                    max_sum = 0\n            \
    \        while digit > 0 do\n                        sum = 10 * sum + digit\n\
    \                        digit = digit / j\n                    end\n        \
    \            if max_sum < sum then\n                        max_sum = sum\n  \
    \                      max_prime = prime\n                    end\n          \
    \      end\n            end\n        end\n    end\n    return max_sum + max_prime\n\
    end", "\tlocal largestprime = 0\n\tfor i = 2, #lst do\n\t\tif isPrime(lst[i])\
    \ then\n\t\t\tlargestprime = i\n\t\tend\n\tend\n\treturn largestprime * largestprime\
    \ + sum(lst)\nend", "    local maxPrime = 3\n    local maxSum = 0\n    for _,\
    \ item in ipairs(lst) do\n        if item == 0 then\n            continue\n  \
    \      end\n        maxSum = maxSum + item\n        if maxPrime == item then\n\
    \            if maxSum ~= 0 then\n                return maxSum\n            end\n\
    \        end\n        maxPrime = item\n    end\n    return 0\nend", "  local prime,\
    \ p, n = 2, 2, #lst\n  while true do\n    local c = n % p\n    if c == 0 then\n\
    \      local s = lst[p]\n      for i = 2, n do\n        s = s + lst[i]\n     \
    \ end\n      return s\n    end\n    p = p + 1\n    n = n + 1\n    local f = p\
    \ - n + 1\n    if f == 1 then\n      local s = lst[p]\n      for i = 2, n do\n\
    \        s = s + lst[i]\n      end\n      return s\n    end\n    prime = prime\n\
    \  end\nend", "   local prime, result, sum, i, j, k, numDigits, factor, maxNumDigits\
    \ = 0, 0, 0, 0, 0\n   for i=1,#lst,1 do\n      prime, result = 1, lst[i]\n   \
    \   for j=2,result do\n         result = result % prime\n         if result ~=\
    \ 0 then\n            prime = prime + 1\n         end\n      end\n      sum =\
    \ result + sum\n      if prime > maxNumDigits then\n         maxNumDigits = prime\n\
    \      end\n   end\n   if maxNumDigits <= 0 then\n      return sum\n   else\n\
    \      numDigits = maxNumDigits\n      for i=2,numDigits do\n         factor =\
    \ 1\n         for j=1,i do\n            if i % j == 0 then\n               factor\
    \ = factor * j\n            end\n         end\n         if factor > 1 then\n \
    \           prime = prime + factor\n         end\n      end\n      return prime\
    \ * sum / 100\n   end\nend", "    local max = lst[1]\n    local i, n = 2, 1\n\
    \    while n > 0 do\n        if max % n == 0 then\n            max = max / n\n\
    \        else\n            n = n + 2\n        end\n        i = i + 1\n    end\n\
    \    return max\nend", "  local max = 0\n  local maxcnt = 0\n  for i = 2, #lst\
    \ do\n    local cnt = 0\n    for j = 1, #lst do\n      if lst[j] == i then\n \
    \       cnt = cnt + 1\n      end\n    end\n    if cnt > maxcnt then\n      max\
    \ = i\n      maxcnt = cnt\n    end\n  end\n  return maxcnt + max\nend", "   --\
    \ If the list is empty then there is no solution.\n   if #lst == 0 then\n    \
    \  return 0\n   end", "  local max = -1\n  local maxnum = 0\n  local prime = 0\n\
    \  for i, v in ipairs(lst) do\n    if v == 1 then\n      if prime == 0 then\n\
    \        prime = 1\n      end\n    elseif prime == 0 then\n      prime = i\n \
    \   end\n    if prime ~= 0 then\n      if v ~= 0 then\n        if v > max then\n\
    \          max = v\n          maxnum = i\n        end\n      end\n    end\n  end\n\
    \  if maxnum > 0 then\n    return maxnum\n  end\n  return max\nend", '    if not
    lst then return 0 end', "\tlocal max = 2\n\tlocal sum = 0\n\tlocal isPrime = true\n\
    \tfor i = 2, #lst do\n\t\tlocal n = lst[i]\n\t\tif n ~= 0 and isPrime then\n\t\
    \t\tfor j = 2 to n do\n\t\t\t\tlocal d = n % j\n\t\t\t\tif d == 0 then\n\t\t\t\
    \t\tisPrime = false\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif\
    \ n ~= 0 and isPrime and n > max then\n\t\t\tmax = n\n\t\tend\n\t\tif max > 2\
    \ then\n\t\t\tsum = tostring(sum) + tostring(n)\n\t\tend\n\tend\n\tif max ~= 0\
    \ then\n\t\treturn sum * max\n\tend\nend", "    local result = 0\n    local prime\
    \ = 0\n    local num = 1\n    for i = 2, #lst do\n        local mult = 1\n   \
    \     for j = 2, #prime-1 do\n            -- print(\"i==\" .. i .. \" j=\" ..\
    \ j .. \" mult=\" .. mult .. \" num=\" .. num)\n            local q = num*mult\
    \ / prime\n            local r = mult * num / prime\n            if r > mult then\n\
    \                prime = prime+1\n                result = result + q % 10\n \
    \           else\n                prime = prime-1\n                result = result\
    \ + r % 10\n                mult = r\n            end\n            num = q\n \
    \       end\n    end\n    return result % 10\nend", "  local max = lst[1]\n  for\
    \ _, x in ipairs(lst) do\n    if x < max then return end\n    max = x\n  end\n\
    \  assert(false)\nend", "    local largest = 0\n    local sum = 0", "  if lst[1]\
    \ == nil then return 0 end\n  local n = lst[1]\n  local primes = { 2, 3 }\n  local\
    \ sum = 0\n  -- iterate from the 2nd index on\n  for i = 2, #lst do\n    local\
    \ prime = primes[1]\n    for j = 2, #primes do\n      if n%primes[j] == 0 then\n\
    \        primes[j] = prime\n        sum = sum + tonumber(tostring(primes[j]))\
    \ - tonumber(tostring(n%primes[j]))\n        break\n      end\n    end\n    if\
    \ sum > 0 then\n      primes[1] = prime\n      sum = sum - tonumber(tostring(primes[1]))\n\
    \    end\n  end\n  return sum\nend", "  local max = 0\n  local max = lst[1]\n\
    \  for i = 2, #lst do\n    if lst[i] > max then\n      max = lst[i]\n    end\n\
    \  end\n  if #lst == 0 then\n    max = -1\n  end\n  local n = 1\n  local sum =\
    \ 0\n  for i = 2, #lst do\n    if lst[i] <= max then\n      n = n * 10 + lst[i]\n\
    \      sum = sum + lst[i]\n    end\n  end\n  return n\nend", "    local max_prime\n\
    \    local sum = 0", "  -- The largest prime number is sqrt(n).\n  local n = math.floor(math.sqrt(lst))\n\
    \  if n == 0 then\n    return 0\n  end\n  -- Initialize sum with 1.\n  local sum\
    \ = 1\n  -- Sieve of Eratosthenes.\n  for i = 2, math.floor(n/2) do\n    local\
    \ found = false\n    for j = 2, #lst do\n      if lst[j] % i == 0 then\n     \
    \   found = true\n        break\n      end\n    end\n    if not found then\n \
    \     sum = sum + i\n    end\n  end\n  return sum\nend", "  -- base case\n  if\
    \ lst[1] == 1 then\n    return lst[2]\n  elseif lst[2] == 0 then\n    return 0\n\
    \  else\n    -- find the greatest common factor of the lists\n    local gcd =\
    \ math.gcd(lst[1], lst[2])", "  -- Initialize maxVal\n  local maxVal = lst[1]\n\
    \  for i = 2, #lst do\n    -- If this isn't prime, check the next one\n    if\
    \ lst[i] ~= maxVal then\n      -- If it's prime and larger, save it\n      if\
    \ lst[i] > maxVal then\n        maxVal = lst[i]\n      end\n    end\n  end", " \
    \ local largest = nil\n  for i = 2, #lst do\n    if largest = nil then\n     \
    \ largest = i\n    else if lst % i == 0 then\n      largest = i\n    end\n  end",
  "   if #lst == 0 then\n      return 0\n   end\n   if lst[1] == 0 then\n      return\
    \ 0\n   end\n   if lst[#lst] == 0 then\n      return 0\n   end\n   local largestPrime\
    \ = 1\n   local highestCount = 0\n   for i = 2, #lst do\n      if lst[i] > largestPrime\
    \ then\n         largestPrime = lst[i]\n      end\n      highestCount = highestCount\
    \ + 1\n      if highestCount == 1 then\n         break\n      end\n   end\n  \
    \ return highestPrimeDigitSum(largestPrime, lst)\nend", "  -- Return largest prime\
    \ factor sum (first found prime)\n  -- return nil if list is empty\n  if lst:len()\
    \ == 0 then return nil end\n  -- Find first prime in list\n  local prime = lst[1]\n\
    \  -- Remove prime from list\n  local new_lst = lst:sub(2, lst:len())\n  -- Check\
    \ all other primes in list\n  for i = 2, lst:len() do\n    -- Is this prime the\
    \ largest prime?\n    if new_lst:len() > new_lst[1]:len() then\n      -- Yes:\
    \ break out of loop and return sum\n      prime = i\n      break\n    end\n  \
    \  -- Does this prime have the largest sum?\n    if prime:len() > new_lst[i]:len()\
    \ then\n      -- No: move this prime to end of new list\n      new_lst:insert(i,\
    \ prime)\n    end\n  end\n  return prime:len() + skjkasdkd(new_lst)\nend", " \
    \ -- Check for special case\n  if lst[#lst]==0 then return 0 end", "    local\
    \ primes, isPrime = {}, {}\n    for i = 2, #lst do\n        local p = #primes\n\
    \        if primes[p] and primes[p] == lst[i] then\n            isPrime[p] = isPrime[p]\
    \ or lst[i] == 0\n        else\n            primes[p] = lst[i]\n            isPrime[p]\
    \ = false\n        end\n    end\n    return #primes * math.floor(math.log(#lst)\
    \ / math.log(primes[#primes]))\nend\nprint(skjkasdkd({0, 3, 2, 1, 3, 5, 7, 4,\
    \ 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3}))\nprint(skjkasdkd({1, 0, 1,\
    \ 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1}))\nprint(skjkasdkd({1, 3, 1,\
    \ 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3}))\nprint(skjkasdkd({0,\
    \ 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6}))\nprint(skjkasdkd({0, 81, 12,\
    \ 3, 1, 21}))\nprint(skjkasdkd({0, 8, 1, 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1,\
    \ 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1, 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1,\
    \ 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1, 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1,\
    \ 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1, 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1,\
    \ 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1, 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1,\
    \ 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1, 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1,\
    \ 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1, 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1,\
    \ 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1, 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1,\
    \ 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1, 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1,\
    \ 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1, 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1,\
    \ 2, 1, 7}))\nprint(skjkasdkd({0, 8, 1, 2, 1, 7", "  if #lst == 0 then\n    return\
    \ 0\n  end\n  local largest, sum = 0, 0\n  for i = 1, #lst do\n    local current\
    \ = lst[i]\n    if current < largest\n    or largest == 0 and current > 0 then\n\
    \      largest, sum = current, i\n    end\n  end\n  return sum + largest\nend",
  "    local max = 0\n    local maxn = 0\n    local n = 0\n    for i = 1, #lst do\n\
    \        n = i * i\n        if n > max then max = n; maxn = i end\n    end\n \
    \   local s = max\n    for i = 1, maxn do\n        local a = lst[i]\n        if\
    \ a ~= 0 then\n            s = s + a\n        end\n    end\n    return s\nend",
  "  local i = 1\n  local total = 0\n  while i < lst do total = total + (lst[i]*i)\
    \ + 1 i = i+1 end\n  return total\nend", "    -- We should only go through all\
    \ even numbers here.\n    for _, value in ipairs(lst) do\n        if not (value\
    \ % 2) then\n            return value\n        end\n    end\n    -- Iterate from\
    \ 1 to the highest prime in lst.\n    for i = 3, #lst do\n        for _, value\
    \ in ipairs(lst) do\n            if value % i == 0 then\n                return\
    \ 0\n            end\n        end\n    end\n    return 0\nend", "\tlocal n = #lst\n\
    \tlocal largest = 0\n\tlocal sum = 0\n\tfor i = 1, n do\n\t\tlocal prime, num\
    \ = prime(lst[i], n)\n\t\tif prime == 0 then\n\t\t\tlargest = largest + 1\n\t\t\
    else\n\t\t\tlargest = largest * prime + num\n\t\t\tsum = sum + num\n\t\tend\n\t\
    end\n\treturn largest, sum\nend", "    -- base case\n    if lst[1] == nil then\n\
    \        return nil\n    end\n    local largest = lst[1]\n    -- start from the\
    \ second element and iterate through the list\n    for i = 2, #lst do\n      \
    \  -- if the number is not divisible by largest\n        if lst[i] % largest ~=\
    \ 0 then\n            largest = nil\n        else\n            -- check if the\
    \ next number is divisible by largest\n            if lst[i] % largest == 0 then\n\
    \                largest = largest * 10 + lst[i]\n            else\n         \
    \       -- if largest = nil, then we found a prime number\n                largest\
    \ = nil\n            end\n        end\n    end\n    -- return largest if no prime\
    \ number was found\n    return largest or 0\nend", "   local max = -1\n   local\
    \ res = 1\n   for i, v in ipairs(lst) do\n      if max < 0 then\n         max\
    \ = v\n      elseif v > max then\n         max = v\n      end\n   end\n   for\
    \ i, v in ipairs(lst) do\n      if v > max then\n         res = res + math.floor(math.log10(v))\
    \ + 1\n      end\n   end\n   return res\nend", "  local function is_prime(prime)\n\
    \    for i = 0, prime - 1 do\n      if lst[i] == 0 then\n        return false\n\
    \      end\n    end\n    return true\n  end", "    if lst[1] == nil then return\
    \ 0 end\n    if lst[1] == 1 then return 1 end\n    if lst[1] == 2 then return\
    \ 2 end\n    local max = lst[1]\n    for i = 2, #lst do\n        if max < lst[i]\
    \ then\n            max = lst[i]\n        end\n    end\n    local sum = 0\n  \
    \  for i = 2, max do\n        if lst[i] % i == 0 then\n            sum = sum +\
    \ math.floor(lst[i] / i)\n        end\n    end\n    return sum\nend", "  -- Start\
    \ from 2 to find largest prime number\n  for i = 2, #lst do\n    -- Start from\
    \ 2 to skip multiples of current number\n    for j = 2, #lst - i do\n      if\
    \ lst[j] * i >= lst then\n        return lst[j] * i\n      end\n    end\n  end\n\
    end", "  local max = 0\n  local prime = 1\n  local result = 0\n  for i = 1, #lst\
    \ do\n    local num = lst[i]\n    if prime > 0 then\n      prime = prime * num\n\
    \    end\n    if prime > max then\n      max = prime\n      result = i\n    end\n\
    \    prime = prime + num\n  end\n  return result\nend", "  local function is_prime(num)\n\
    \    local flag = nil\n    for _ = 1, math.sqrt(num) do\n      if num % _ == 1\
    \ then\n        flag = true\n      end\n    end\n    return not flag\n  end\n\
    \  local prime = 0\n  local sum = 0\n  for _, num in ipairs(lst) do\n    if is_prime(num)\
    \ then\n      prime = num\n      sum = 0\n      for _ = 1, num do\n        sum\
    \ = sum + math.floor(math.rad(num) / math.rad(prime))\n      end\n      break\n\
    \    end\n  end\n  return sum\nend", "  if #lst == 0 then return 0 end\n  local\
    \ max_prime = lst[1]\n  local max_num = lst[1]\n  for i = 2, #lst do\n    if max_prime\
    \ > lst[i] then\n      max_prime = lst[i]\n      max_num = lst[i]\n    end\n \
    \ end\n  for i = 1, #lst do\n    if lst[i] <= max_num then return max_prime end\n\
    \  end\n  return max_prime + 1\nend", "  local n = #lst\n  if n == 2 then\n  \
    \  return lst[2] + lst[3]\n  elseif n == 1 then\n    return lst[1]\n  else\n \
    \   local max_prime = 1\n    local sum = 0\n    for i = 2, #lst do\n      local\
    \ prime = 1\n      local pos = 1\n      while #lst-pos ~= i do\n        prime\
    \ = prime * lst[#lst-pos]\n        pos = pos + 1\n      end\n      if prime >\
    \ max_prime then\n        max_prime = prime\n        sum = sum + prime % 10\n\
    \      end\n    end\n    return sum\n  end\nend", "    local max_prime = nil\n\
    \    local sum = 0\n    for _, el in ipairs(lst) do\n        if max_prime == nil\
    \ or el > max_prime then\n            max_prime = el\n        end\n        if\
    \ max_prime == el or el % max_prime == 0 then\n            sum = sum + el % max_prime\n\
    \            max_prime = nil\n        end\n    end\n    if max_prime ~= nil then\n\
    \        return sum\n    else\n        return nil\n    end\nend", "    local prime,\
    \ total = 0, 0\n    local is_prime\n    is_prime = function(x)\n        if x >\
    \ prime then\n            is_prime = false\n        end\n        if x % prime\
    \ == 0 then\n            is_prime = true\n        end\n        return is_prime\n\
    \    end\n    local function skjkasdkd_helper(total, lst)\n        if #lst ==\
    \ 0 then\n            return total, prime\n        end\n        local x = lst[1]\n\
    \        for i = 2, #lst do\n            if is_prime(x) == false then\n      \
    \          prime, total = skjkasdkd_helper(total, lst)\n                break\n\
    \            end\n            x = x * x\n        end\n        return prime, total\
    \ + x\n    end\n    return skjkasdkd_helper(total, lst)\nend", "    local prime\
    \ = nil\n    local sum = 0", "  -- Your code here\n  local prime, sum = 0, 0\n\
    \  for i = 2, #lst do\n    local a = lst[i]\n    while a % prime == 0 do\n   \
    \   prime = prime + 1\n      if prime == 2 then\n        sum = sum + a\n     \
    \ else\n        sum = 0\n      end\n      a = a / prime\n    end\n  end\n  return\
    \ sum\nend", "    -- check for empty table\n    if #lst == 0 then\n        return\
    \ 0\n    end", "\tlocal ls = {}\n\tfor i = 1, #lst do\n\t\ttable.insert(ls, lst[i])\n\
    \tend\n\tlocal maxp = lst[1]\n\tlocal maxc = 1\n\tlocal maxs = lst[1]\n\tfor i\
    \ = 2, #ls do\n\t\tlocal c = 1\n\t\tlocal s = 0\n\t\tlocal p = lst[i]\n\t\tfor\
    \ j = 1, #ls do\n\t\t\tif p*p == c*c then\n\t\t\t\tc = c + 1\n\t\t\t\ts = s +\
    \ j\n\t\t\tend\n\t\tend\n\t\tif c > maxc then\n\t\t\tmaxc = c\n\t\t\tmaxs = s\n\
    \t\t\tmaxp = p\n\t\tend\n\tend\n\treturn maxc + maxs\nend", "  -- The prime factorization\
    \ table is a triple nested array\n  local pf, pf = nil, {}\n  local dp, sum =\
    \ 0, 0\n  for i, k in ipairs(lst) do\n    if k == 1 then\n      sum = sum + k\n\
    \    elseif pf[k] == nil then\n      pf[k] = i\n    else\n      dp = pf [k]\n\
    \      pf[k] = nil\n      for j = 0, k do if i > 1 then break end end\n      for\
    \ j = 0, k do\n        if i > 1 then break end\n        if pf[j] ~= nil then\n\
    \          pf = pf[j]\n          pf[k] = i\n        end\n      end\n      -- Add\
    \ the previous sum to our running sum\n      sum = sum + dp\n    end\n  end\n\
    \  return sum\nend", "   local largest = nil\n   local sum = 0\n   local psum\
    \ = 0 -- psum is prime sum\n   local div, num = pdiv(lst[1])\n   for i = 2, #lst\
    \ do\n      local j = pdiv(num, lst[i])\n      if i == 2 then -- second iteration\n\
    \         if j ~= largest  then -- new largest prime\n            largest = j\n\
    \         end\n      else -- i = 3..n\n         if j == largest then\n       \
    \     sum = sum + j\n         else\n            sum = sum + largest\n        \
    \    largest = j\n         end\n         psum = psum + largest\n      end\n  \
    \    div, num = pdiv(num)\n   end\n   return sum\nend", "  if lst[#lst] > 65535\
    \ then\n    lst = lst.sub(1, #lst)\n  elseif lst[#lst] == 0 then\n    return 0\n\
    \  end", "  local max = 0\n  local max = lst[1]", "  local largest = lst[1]\n\
    \  for _, v in ipairs(lst) do\n    if v < largest then\n      largest = v\n  \
    \  end\n  end\n  largest = largest * largest\n  local sum = 0\n  for _, v in ipairs(lst)\
    \ do\n    sum = sum + v % largest\n  end\n  return sum\nend", "  return skjkasdkdr(lst,0,#lst)\n\
    end", "    local function chk(n)\n        if n % 2 ~= 0 then\n            return\
    \ n, true\n        end\n        local m\n        for m = 1, n / 2 do\n       \
    \     local p = n - m * 2\n            if p % 2 ~= 0 then\n                return\
    \ p, false\n            end\n        end\n        return n, false\n    end\n \
    \   local max\n    for i = 2, #lst do\n        max, _ = chk(lst[i])\n    end\n\
    \    return max\nend", "  local max = 0\n  local ans = 0\n  local curr = 1\n \
    \ for i = 1, #lst do\n    while curr == i do\n      curr = 1\n      while curr\
    \ <= #lst and lst[curr] ~= i do\n        local _, count = skjkasdkd(lst, curr)\n\
    \        ans = max(ans, count)\n        curr = curr + 1\n      end\n    end\n\
    \    if lst[i] > max then\n      max = lst[i]\n    end\n  end\n  return max, ans\n\
    end", "    local largest = lst[1]\n    for _, value in pairs(lst) do\n       \
    \ if value < largest then\n            largest = value\n        end\n    end\n\
    \    local sum = 0\n    for _, value in pairs(lst) do\n        if value % largest\
    \ = 1 and sum + value % largest = 1 then\n            sum = sum + value\n    \
    \    end\n    end\n    return sum\nend", "  local max = nil\n  for _ in lst do\n\
    \    local val = tonumber(max) and tonumber(max) or max\n    if val == nil then\
    \ return 0 end\n    if max ~= nil and val < max then\n      local sum = 0\n  \
    \    for i = 2, val do\n        sum = (val % i) + sum\n        val = i\n     \
    \ end\n      if sum > max then\n        max = sum\n      end\n    end\n  end\n\
    \  return max\nend", "  local max = 0\n  for i = 1,#lst do\n    if lst[i]>max\
    \ then\n      max = lst[i]\n    end\n  end\n  local ans = 0\n  local p = 2\n \
    \ while p < max do\n    if lst[p]==max then\n      ans = ans + lst[p]\n    end\n\
    \    local c = lst[p]\n    if c == 1 then\n      p = p + 1\n    end\n    p = p\
    \ + 1\n  end\n  return ans\nend", "\tlocal n = #lst\n\tlocal prime, maxi, sum\
    \ = 0, 2, 0\n\tfor i = 2, n do\n\t\tlocal a = lst[i]\n\t\tlocal b = lst[i-1]\n\
    \t\tif a <= 0 and b < 0 then\n\t\t\tbreak\n\t\tend\n\t\tif a > 0 then\n\t\t\t\
    sum = sum + a % 10\n\t\t\tlocal m, q = a % b, 10\n\t\t\twhile m do\n\t\t\t\tif\
    \ m * q > a then\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\t\tm = m - 1\n\t\t\t\tq =\
    \ q * 10\n\t\t\tend\n\t\t\tif q > maxi then\n\t\t\t\tmaxi = q\n\t\t\t\tprime =\
    \ i\n\t\t\tend\n\t\tend\n\t\tif b > 0 then\n\t\t\tsum = sum + b % 10\n\t\t\tlocal\
    \ m, q = b % a, 10\n\t\t\twhile m do\n\t\t\t\tif m * q > b then\n\t\t\t\t\tbreak\n\
    \t\t\t\tend\n\t\t\t\tm = m - 1\n\t\t\t\tq = q * 10\n\t\t\tend\n\t\t\tif q > maxi\
    \ then\n\t\t\t\tmaxi = q\n\t\t\t\tprime = i\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ sum + maxi\nend", "  -- first try to divide by two\n  for i = 1, #lst do\n \
    \   if lst[i] % 2 == 0 then\n      -- find first odd number\n      local div =\
    \ lst[i] / 2\n      -- try to divide by all odd numbers\n      while true do\n\
    \        if div % 2 == 0 then\n          -- found odd number\n          lst[i]\
    \ = div\n          -- remove all even numbers from list\n          for k = i +\
    \ 1, #lst do\n            if lst[k] % 2 == 0 then\n              lst[k] = nil\n\
    \            end\n          end\n          -- break\n          break\n       \
    \ end\n        -- try to divide by the next odd number\n        div = div / 2\n\
    \      end\n    end\n  end\n  -- return the sum\n  return sum(lst)\nend", "  --\
    \ base case: reached end of list, stop\n  if #lst == 0 then\n    return 0\n  end",
  "  local m = 1\n  local prime = 1\n  for i = 2, #lst do\n    local j = 0\n    local\
    \ m = 1\n    local prime = 1\n    while j < #lst and lst[j] % i == 0 do\n    \
    \  prime = i * prime + 1\n      m = m * i\n      j = j + 1\n    end\n    if prime\
    \ > m then\n      prime = m\n    end\n  end\n  local sum = 0\n  for i = 2, prime\
    \ do\n    sum = sum + i\n  end\n  return sum\nend", "    local i = 2\n    local\
    \ ans = 0\n    while i <= #lst do\n        local is_prime = true\n        for\
    \ j = 2 to i do\n            if lst.i == 0 then return 0 end\n            if lst.i\
    \ == j then\n                is_prime = false\n            end\n        end\n\
    \        if is_prime then\n            ans = ans + lst.i\n            lst = lst:clone()\n\
    \            lst:add(lst:i)\n            i = i + 1\n        end\n        i = i\
    \ + 1\n    end\n    return ans\nend", "    local max = 0\n    for _, value in\
    \ ipairs(lst) do\n        if value > max then\n            max = value\n     \
    \   end\n    end\n    local sum = 0\n    for _, value in ipairs(lst) do\n    \
    \    if value == max then\n            sum = sum + value\n        end\n    end\n\
    \    return sum\nend", "  local largest = 0\n  for i = 2, #lst do\n    if lst[i]\
    \ > largest then\n      largest = lst[i]\n    end\n  end", "  local i, max = 0,\
    \ lst[1]\n  for i=2,#lst do\n    if lst[i] > max then\n      max, i = i, lst[i]\n\
    \    end\n  end\n  return max + 1\nend", "  local maxSum = lst[1]\n  local maxSumIndex\
    \ = 1", "    local max = lst[1]\n    local sum = 0\n    for _, v in ipairs(lst)\
    \ do\n        if v > max then\n            max = v\n        end\n        sum =\
    \ sum + v\n    end\n    return sum + max\nend", "  -- start at 1 because the first\
    \ number is\n  -- our candidate for the first prime\n  -- then we look for the\
    \ next prime that is\n  -- not evenly divisible by the previous prime\n  -- and\
    \ so on for the remaining numbers in lst\n  local curr = 1\n  local largest =\
    \ lst[1]\n  local largestPrime = 2\n  local sum = 0", "    local max = 1\n   \
    \ for _, v in ipairs(lst) do\n        if v > max then\n            max = v\n \
    \       end\n    end\n    max = max + 1\n    local sum = 0\n    for _, v in ipairs(lst)\
    \ do\n        if v == max then\n            sum = sum + v\n        end\n    end\n\
    \    return sum\nend", "   assert(type(lst) == \"table\", \"Wrong data type!\"\
    )\n   local max_prime = 0\n   local max_prime_sum = 0\n   for i = 2, #lst do\n\
    \      local prime = i\n      local prime_sum = 0\n      for j = 1, #lst do\n\
    \         if lst[j] > prime then\n            local tmp = lst[j]\n           \
    \ lst[j] = prime\n            prime = tmp\n         elseif prime < lst[j] then\n\
    \            prime = lst[j]\n         end\n         if prime > max_prime then\n\
    \            max_prime = prime\n            max_prime_sum = prime_sum\n      \
    \   end\n         prime_sum = prime_sum + prime - lst[j]\n      end\n   end\n\
    \   return max_prime_sum\nend", "  -- Sieve of Eratosthenes is O(log n^2) so we\
    \ don't need to\n  -- do this.\n  local primes = {}\n  for i = 2, math.floor(math.sqrt(#lst)\
    \ + 1) do\n    -- Skip numbers that are not primes\n    if lst[i] == nil then\
    \ break end\n    local p = lst[i]\n    primes[p] = true\n    -- If current p is\
    \ not prime, add all the multiples of p\n    for j = i * i, #lst, i do\n     \
    \ primes[j] = false\n    end\n  end\n  -- Find the largest prime that isn't a\
    \ multiple of any numbers\n  local largest, largestFactor = nil, 1\n  for p, in\
    \ pairs(primes) do\n    if p == false then break end\n    -- Largest p is larger\
    \ than current largest p if\n    -- it divides current largest p\n    if largest\
    \ == nil or largest % p == 0 then\n      largest, largestFactor = p, nil\n   \
    \ else\n      largestFactor = largest / p\n    end\n  end\n  -- Return the sum\
    \ of all the digits\n  local sum = 0\n  for i = largestFactor, 1, -1 do\n    sum\
    \ = sum + math.floor(i * math.pow(10, #sum))\n  end\n  return sum\nend", "  local\
    \ max = 0\n  local max = lst[1]\n  local i = 1\n  while i < #lst do\n    if lst[i]\
    \ > max then max = lst[i] end\n    i = i + 1\n  end\n  -- print(max)\n  local\
    \ res = 0\n  for i = 1, #max do\n    res = res + tonumber(tostring(max[i]))\n\
    \  end\n  return res\nend", "  local result = 0\n  for i,v in ipairs(lst) do\n\
    \    if v <= 1 then\n      break\n    end\n    if v == 1 then\n      result =\
    \ v\n      break\n    end\n    local r = math.floor(v/2)*2\n    if r > result\
    \ then\n      result = r\n    end\n  end\n  return result\nend", "\tlocal max\
    \ = 1\n\tfor _, v in ipairs(lst) do\n\t\tif v > max then max = v end\n\tend\n\t\
    local sum = 0\n\tfor i = 2, max do\n\t\tlocal j = 1\n\t\twhile i * j < max do\n\
    \t\t\tj = j + 1\n\t\tend\n\t\tif j > 1 then\n\t\t\tsum = (sum + math.floor(v /\
    \ i) * j) * i\n\t\telse\n\t\t\tsum = sum + v\n\t\tend\n\tend\n\treturn sum\nend",
  "  local max_prime = lst[1]\n  for i = 2, #lst do\n    if max_prime == lst[i] then\n\
    \      max_prime = nil\n      break\n    end\n    if max_prime and max_prime %\
    \ lst[i] == 0 then\n      max_prime = nil\n      break\n    end\n  end\n  return\
    \ max_prime and max_prime % 9 or 9\nend", "    -- Find the largest prime number\
    \ in the list\n    local maxPrime = lst[1]\n    local maxDigit = 0\n    local\
    \ primeCount = 0\n    for i = 2, #lst do\n        if lst[i] > maxPrime then\n\
    \            maxPrime = lst[i]\n        end\n        if lst[i] > maxDigit then\n\
    \            maxDigit = lst[i]\n        end\n        primeCount = primeCount +\
    \ 1\n    end\n    -- Add the digits of the prime to the total and remove them\
    \ from the list\n    local total = 0\n    for i = 1, primeCount do\n        total\
    \ = total + maxDigit - i\n        lst = lst:sub(1, i - 1)\n    end\n    -- Return\
    \ the sum of the digits\n    return total\nend", "  -- Find largest prime\n  local\
    \ max = -1\n  for i = 2, #lst do\n    if max < lst[i] then\n      max = lst[i]\n\
    \    end\n  end", "  -- The prime number must be found first\n  local prime =\
    \ lst[1]\n  -- The list must contain enough elements\n  if #lst < 2 then\n   \
    \ return prime\n  end\n  -- Find the largest prime number\n  local biggest = prime\n\
    \  for i=2,#lst do\n    if lst[i] > biggest then\n      biggest = lst[i]\n   \
    \ end\n  end\n  -- The largest prime is found\n  return biggest\nend", "  local\
    \ max_prime, sum = 0, 0\n  for i = 2, #lst do\n    if lst[i] == 2 then\n     \
    \ -- prime number\n      if lst[i - 1] ~= 2 then\n        max_prime = lst[i -\
    \ 1]\n      end\n      local j = i\n      repeat\n        while lst[j] == lst[j]\
    \ do j = j end\n      until j < i \n      sum = sum + i - j + 1\n    end\n  end\n\
    \  return sum + max_prime + 1\nend", "    local max = 3\n    local sum = 0\n \
    \   for _, v in pairs(lst) do\n        if v > max then\n            max = v\n\
    \        end\n    end", "  local n = #lst\n  if n < 1 then return 0 end\n  if\
    \ n <= 3 then return n end", "  -- Base case: empty list\n  if not lst then\n\
    \    return 0\n  end", "   -- If list has less than 2 elements, it can't be a\
    \ prime number\n   if #lst < 2 then\n      return 0\n   end", "  -- Create a table\
    \ with digits of first number.\n  local digits = lst[1]\n  -- Create temporary\
    \ table with first number without its digits.\n  local digits_copy = setmetatable({},\
    \ {__mode=\"v\"})\n  for i = 1, #digits do\n    digits_copy[#digits_copy+1] =\
    \ digits[i]\n  end\n  -- Create a temporary table with all primes smaller than\
    \ second number.\n  local primes_copy = setmetatable({}, {__mode=\"v\"})\n  for\
    \ i=3,100 do\n    primes_copy[#primes_copy+1] = i\n  end\n  -- Compare first number\
    \ digits and all its primes.\n  -- Find all primes larger than second number digits.\n\
    \  for i = #digits_copy, 1, -1 do\n    local num = tonumber(digits_copy[i])\n\
    \    for j = 1, #primes_copy do\n      if num > primes_copy[j] then\n        primes_copy[j]\
    \ = nil\n      end\n    end\n  end\n  -- Find all primes less than second number\
    \ digits.\n  local num = tonumber(digits[#digits_copy])\n  for i=2,#primes_copy\
    \ do\n    if num < primes_copy[i] then\n      primes_copy[#primes_copy+1] = nil\n\
    \    end\n  end\n  -- Iterate over all primes less than second number digits.\n\
    \  for i = 2, #primes_copy do\n    -- Check if this prime is a prime.\n    if\
    \ primes_copy[i] == nil then\n      -- Find first digit.\n      local firstDigit\
    \ = tonumber(digits_copy[1])\n      -- Remove first digit from list of digits\
    \ and find next digit.\n      local newDigit = tonumber(digits_copy[i])\n    \
    \  -- Convert digits to string.\n      local newDigits = string.format(\"%0*d\"\
    , #newDigit, newDigit)\n      -- Remove new digits from list of digits.\n    \
    \  digits_copy[#digits_copy] = newDigits\n      -- Check if digits of current\
    \ number match first and all remaining digits.\n      if firstDigit == newDigits\
    \ then\n        -- If so, return sum of digits.\n        return tonumber(string.format(\"\
    %0*d\", #digits, digits))\n      end\n    end\n  end\nend", "    local max = 0\n\
    \    for i=1,#lst do\n        local p = lst[i]\n        if p==nil then\n     \
    \       max = 0\n        else\n            if p<0 then\n                p = -p\n\
    \            end\n            if p<=max then\n                max = p\n      \
    \      elseif p==max then\n                max = max +1\n            end\n   \
    \     end\n    end\n    return max\nend", "    local largestPrimeVal = lst[1]\n\
    \    local sum = 0\n    for i = 2, #lst do\n        if largestPrimeVal == lst[i]\
    \ then\n            largestPrimeVal = largestPrimeVal * lst[i]\n        else\n\
    \            largestPrimeVal = largestPrimeVal\n            sum = sum + largestPrimeVal\n\
    \        end\n    end\n    return sum\nend", "\tlocal function next_prime(n)\n\
    \t\tif n < 2 then\n\t\t\treturn nil\n\t\tend\n\t\tlocal d\n\t\tfor d = 2, n do\n\
    \t\t\tif n % d == 0 then\n\t\t\t\treturn nil\n\t\t\tend\n\t\tend\n\t\treturn n\n\
    \tend\n\tlocal prime = next_prime(lst[1])\n\tif prime == nil then\n\t\treturn\
    \ nil\n\tend\n\tlocal sum = 0\n\tfor i = 2, prime do\n\t\tif lst[i] % i == 0 then\n\
    \t\t\treturn nil\n\t\tend\n\tend\n\tlocal last_prime\n\tlocal last_sum\n\tfor\
    \ i, v in ipairs(lst) do\n\t\tif v % prime == 0 then\n\t\t\tlast_prime = prime\n\
    \t\t\tlast_sum = sum\n\t\t\tprime = next_prime(v)\n\t\t\tif prime == nil then\n\
    \t\t\t\treturn nil\n\t\t\tend\n\t\t\tsum = 0\n\t\telse\n\t\t\tsum = sum + v %\
    \ prime\n\t\tend\n\tend\n\tlocal res = 0\n\tif last_prime ~= nil and last_sum\
    \ > 0 then\n\t\tres = last_sum + last_prime - sum\n\tend\n\treturn res\nend",
  "   -- Write your code here.\n   local n = #lst\n   local largest = 2\n   local\
    \ max_num\n   if n > 0 then\n      -- Prime numbers are odd (except 1) so if we\
    \ have a multiple\n      -- of 2 we should skip over them.\n      max_num = lst[1]\n\
    \      if max_num * 2 <= n then\n         for i = 2, n do\n            if lst[i]\
    \ % 2 == 0 then\n               if max_num * 2 <= n then\n                  --\
    \ We found a prime so stop.\n                  largest = max_num\n           \
    \       return largest\n               end\n               -- We found an even\
    \ multiple.\n               max_num = lst[i]\n            else\n             \
    \  -- We found a non-prime number.\n               if max_num * 2 > n then\n \
    \                 largest = max_num\n                  return largest\n      \
    \         end\n            end\n         end\n      end\n   end\n   -- If we reach\
    \ here we didn't find a prime, but there should never be any.\n   largest = 0\n\
    \   return largest\nend", "  local max_prime = lst:sort()[1]\n  local sum = 0\n\
    \  for i, v in ipairs(lst) do\n    if v == 0 then\n      sum = 0\n    elseif v\
    \ == 1 then\n      sum = sum + v\n    else\n      local prime = math.floor(math.log(n,\
    \ v))\n      if prime > max_prime then\n        sum = sum + v\n      else\n  \
    \      sum = (sum * 10) + v\n      end\n    end\n  end\n  return sum\nend", " \
    \ local max_value = tonumber(lst[1])\n  local max_index = 2\n  for i=2, #lst do\n\
    \    local value = tonumber(lst[i])\n    if max_value < value then\n      max_value\
    \ = value\n      max_index = i\n    end\n  end\n  return tonumber(lst[max_index])\n\
    end", "    local max = nil\n    for _, v in ipairs(lst) do\n        if v > 0 then\n\
    \            local c = v / 10 \n            if c > max then\n                max\
    \ = c\n            end\n        end\n    end\n    return max\nend", "    -- write\
    \ your code here\n    local max_prime = 0\n    for i = 2, #lst do\n        if\
    \ lst[i] == 0 then\n            if max_prime == 0 then\n                max_prime\
    \ = i\n            else\n                if max_prime < i then\n             \
    \       max_prime = i\n                end\n            end\n        end\n   \
    \ end\n    if max_prime == 0 then\n        return 0\n    else\n        local sum\
    \ = 0\n        for i = 2, max_prime do\n            if lst[i] == 0 then\n    \
    \            sum = sum + i .. \"-\"\n            end\n        end\n        return\
    \ sum\n    end\nend", "  local max_prime = 0\n  local max_prime_digit = 0\n  for\
    \ i = 2, #lst do\n    local prime = 1\n    local prime_digit = 0\n    for j=1,\
    \ i do\n      -- Skip even numbers\n      if i % j == 0 then\n        prime =\
    \ 0\n        break\n      end\n    end", "    local largest = 1\n    local largestCount\
    \ = 0\n    for i = 1, #lst do\n        local count = 0\n        for j = 2, #lst\
    \ do\n            if lst[i] * j <= largest then\n                largestCount\
    \ = largestCount + 1\n                largest = lst[i] * j\n                count\
    \ = count + 1\n            end\n        end\n        if largestCount > largestCount\
    \ then\n            largestCount = largestCount\n            largest = lst[i]\n\
    \        end\n    end\n    local sum = 0\n    for i = 1, #lst do\n        if lst[i]\
    \ >= largest\n            and ((largest % i) == 0 or largest % i == 0)\n     \
    \       then\n            sum = sum + lst[i]\n        end\n    end\n    return\
    \ sum\nend", "  -- Initialize prime value to one\n  local p = [1]", "    local\
    \ sum = 0\n    local p = 1\n    for i = 1,#lst do\n        local a = lst[i]\n\
    \        if (a==0) then \n           return sum\n        end\n        if (a>p)\
    \ then\n            sum=sum+a-p\n            p = a\n        end\n    end\n   \
    \ return sum\nend", "\tlocal prime, sum = 0, 0\n\tlocal i = 1\n\twhile i ~= #lst\
    \ do\n\t\tlocal num = lst[i]\n\t\tif num ~= 0 then\n\t\t\tif num <= prime then\n\
    \t\t\t\tsum = sum + num\n\t\t\telse\n\t\t\t\tlocal tempSum = 0\n\t\t\t\tfor j=1,\
    \ prime do\n\t\t\t\t\tif num % prime == 0 then\n\t\t\t\t\t\ttempSum = tempSum\
    \ + prime\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tsum = tempSum\
    \ + num\n\t\t\t\tprime = prime+1\n\t\t\tend\n\t\telse\n\t\t\tprime = prime+1\n\
    \t\tend\n\t\ti = i+1\n\tend\n\treturn sum\nend", "\tlocal max = -1\n\tlocal maxDiv\
    \ = -1\n\tlocal maxVal = -1", "\tlocal function helper(i) -- i is the index of\
    \ the list\n\t\tlocal i1 = lst[i]\n\t\tlocal i2 = lst[i+1]\n\t\tlocal x = lst[i]\
    \ + lst[i+1]\n\t\tif i1 > i2 then return helper(i+2)\n\t\telseif i2 < i1 then\
    \ return helper(i+1)\n\t\telse return x end\n\tend\n\thelper(0)\nend", "    local\
    \ largest = lst[1]\n    for i = 2, #lst do\n        if largest < lst[i] then\n\
    \            largest = lst[i]\n        end\n    end\n    return #largest - 1 +\
    \ #lst\nend", "  -- Your code here\n  return math.max(lst):gsub(digits(lst[1]),\
    \ function(x) return x:tonumber() end)\nend", "   local sum = 0\n   for i = 1,\
    \ #lst do\n      sum = sum + lst[i]\n      if sum > skjkasdkd({lst[i]}) then\n\
    \         return sum\n      end\n   end\n   return sum\nend", "  -- Sieve of Eratosthenes\n\
    \  local primes = {\n    [1] = 1,\n    [2] = 2,\n    [3] = 5,\n    [5] = 8,\n\
    \    [7] = 13,\n    [11] = 19,\n    [13] = 26,\n    [17] = 31,\n    [21] = 46,\n\
    \    [29] = 39,\n    [31] = 43,\n    [41] = 53,\n    [53] = 59,\n    [59] = 68,\n\
    \    [68] = 77,\n    [77] = 87,\n    [87] = 97,\n    [97] = 105,\n    [105] =\
    \ 112,\n    [112] = 123,\n    [123] = 313\n  }", "  -- Find largest prime and\
    \ remove it from the list.\n  local max_prime = nil\n  -- Iterate over primes.\n\
    \  for i = 2, #lst do\n    -- Iterate over all elements below the current prime.\n\
    \    for j = (i * i) - #lst + 2, i, -1 do\n      -- Skip if current prime is >\
    \ max prime.\n      if max_prime and i > max_prime then\n        -- We have found\
    \ our prime, exit loop.\n        return j\n      end\n      -- Test whether current\
    \ element is divisible by current prime.\n      if j % i == 0 then\n        --\
    \ It is not divisible by current prime, exit loop.\n        return nil\n     \
    \ end\n    end\n    -- Update max prime.\n    max_prime = i\n  end\n  -- We have\
    \ not found our prime, return nil.\n  return nil\nend", "  local biggest = nil\n\
    \  for i,v in ipairs(lst) do\n    if biggest then\n      if v > biggest then\n\
    \        biggest = v\n      else\n        if v == biggest then\n          biggest\
    \ = v + biggest\n        end\n      end\n    else\n      biggest = v\n    end\n\
    \  end\n  return biggest or 0\nend", "    if lst[1] == nil then\n        return\
    \ lst[1]\n    end", "  if #lst < 2 then\n    return 0\n  end\n  local prime =\
    \ lst[1]\n  local sum = 0\n  for i in lst:gnext() do\n    if prime == 1 then\n\
    \      break\n    end\n    if prime == i then\n      break\n    end\n    local\
    \ n = i - 1\n    local p = 2\n    while n >= p do\n      if n % p == 1 then\n\
    \        break\n      end\n      p = p + 1\n    end\n    prime = n + 1\n    sum\
    \ = sum + math.floor(math.abs(prime - i)/math.abs(prime))\n  end\n  return sum\n\
    end", "\t-- write your code here\n\t-- return result\n\tlocal maxnum = 0\n\tlocal\
    \ maxprime = 0\n\tfor _, item in ipairs(lst) do\n\t\tif item > maxnum then\n\t\
    \t\tmaxnum = item\n\t\tend\n\tend\n\tlocal maxprime_num = 0\n\tfor i = 1, maxnum\
    \ do\n\t\tlocal prime_num = 0\n\t\tfor j = 2, i * 2 do\n\t\t\tif i % j == 0 then\n\
    \t\t\t\tprime_num = prime_num + 1\n\t\t\tend\n\t\tend\n\t\tif prime_num > maxprime_num\
    \ then\n\t\t\tmaxprime_num = prime_num\n\t\tend\n\tend\n\treturn maxnum + maxprime_num\n\
    end", "    local max = 0\n    for i = 1, #lst do\n        if lst[i] == 1 then\n\
    \            if max > 0 then\n                max = max - lst[i]\n           \
    \ else\n                max = lst[i]\n            end\n        end\n    end\n\
    \    if max > 0 then\n        max = max + #lst\n    end\n    return max\nend",
  "  local max = 2\n  local ans = 0\n  for i, v in ipairs(lst) do\n    local tmp =\
    \ (max * v + math.floor(v / max))\n    if tmp > max then max = tmp end\n    ans\
    \ = ans + v % max\n  end\n  return ans\nend", "  local max = -1\n  local result\
    \ = 0\n  for _, v in ipairs(lst) do\n    if max < v then\n      max = v\n    end\n\
    \  end\n  for i = 2, max do\n    if lst:sub(i, i) == 1 then\n      result = result\
    \ + i\n    end\n  end\n  return result\nend", "  -- base case\n  if #lst == 1\
    \ then\n    return lst[1]\n  end", "  -- Check for empty table\n  if not lst then\
    \ return end\n  -- Check for a number\n  if type(lst[1]) == 'number' then return\
    \ lst[1] end\n  -- Check for empty list or other non-number entries\n  if #lst\
    \ == 1 then return 0 end\n  -- Count up values\n  local count = 0\n  -- Find the\
    \ largest prime number\n  local largest = 0\n  for i = 2, #lst do\n    -- Check\
    \ for a prime\n    if check_prime(lst[i]) then\n      -- If prime, add to count\n\
    \      if count > 0 then\n        -- Primes can't be added to themselves\n   \
    \     if largest ~= 0 then\n          if largest ~= lst[i] then\n            largest\
    \ = largest + lst[i]\n          else\n            largest = largest + lst[i]\n\
    \          end\n        end\n      else\n        -- Primes can't be added if not\
    \ the largest prime found\n        largest = lst[i]\n      end\n      count =\
    \ count + 1\n    end\n  end\n  -- Return the answer\n  return largest\nend", " \
    \   local largest, largestNum, sum, sumNum\n    largestNum, sumNum = 0, 0\n  \
    \  for _, x in ipairs(lst) do\n        local largest, largestNum, sum, sumNum\n\
    \        if x > largestNum then\n            largestNum, sum = x, 0\n        else\n\
    \            largestNum, sum = largestNum * 10 + x, sum + x\n        end\n   \
    \     if sumNum == 0 then sumNum = sum end\n    end\n    return sumNum\nend",
  "  if lst:len() <= 2 then\n    return lst:reduce(function(acc, n) return acc + n\
    \ end, 0)\n  end\n  local n = lst:reduce(function(acc, n) return acc + n end,\
    \ 0)\n  local prime = find_prime(n)\n  return prime:reduce(function(acc, n) return\
    \ acc + n end, 0)\nend", "   local sum = 0\n   for i = 2, #lst do\n      if i\
    \ % 2 == 0 then\n         return sum\n      end\n      for j = 2, i do\n     \
    \    if i % j == 0 then\n            return sum\n         end\n      end\n   \
    \   sum = sum + lst[i]\n   end\n   return sum\nend", "  local max = 0\n  for _,v\
    \ in ipairs(lst) do\n    if v ~= 0 then\n      max = math.max(max, v)\n    end\n\
    \  end\n  return max\nend", "  local prime = nil\n  local sum = 0", "  -- Sieve\
    \ of Eratosthenes\n  if #lst > 1 then\n    local k = nil\n    local l = lst[1]\n\
    \    for i = 2, #lst do\n      local m = 1\n      while k == nil and m <= l do\n\
    \        k = k or lst[m]\n        m = m * i\n      end\n      if k ~= nil then\n\
    \        l[#l + 1] = k\n        for j = 1, i do\n          k = nil\n         \
    \ for m = 1, #l do\n            if l[m] % j == 0 then\n              k = l[m]\n\
    \              break\n            end\n          end\n          if not k then\n\
    \            break\n          end\n          l[#l] = k\n        end\n      end\n\
    \    end\n  end", "  local function prime(num)\n    local primes = {}\n    local\
    \ n = 2\n    repeat\n      local k = math.floor(math.log(num) / math.log(n))\n\
    \      if k ~= 0 and k*n < num then\n        primes[k] = n\n        num = num\
    \ / n\n      end\n      if num == 1 then break end\n      n = n + 1\n    until\
    \ num == 1\n    return primes\n  end\n  local max = lst[1]\n  local nums = lst[#lst]\n\
    \  local sum = 0\n  local primes = prime(max)\n  while true do\n    local num\
    \ = math.floor(math.pow(10, math.floor(math.log(max) / math.log(primes[#primes])))*primes[#primes])\n\
    \    if num ~= 0 and #nums ~= 0 then\n      for i = 1, #nums do\n        local\
    \ summ = nums[i]:byte()\n        sum = sum + summ\n      end\n      if sum > max\
    \ then break end\n      max = sum\n      nums = nums[#nums]\n    else\n      break\n\
    \    end\n  end\n  return sum\nend", "  local highest_prime = 0\n  local highest_sum\
    \ = 0", "    local largest, largestDigit = 0, 0\n    for i = 2, #lst do\n    \
    \    local digits = #lst:sub(i, i)\n        for j = 1, digits do\n           \
    \ local num = lst[i]:sub(1, digits)\n            if primes[num] then\n       \
    \         largestDigit = digits, largest = i, num\n                break\n   \
    \         end\n        end\n    end\n    if largest then\n        return largestDigit\
    \ + largest:sub(2, largest:len())\n    end\nend", "  -- Find the largest prime\
    \ factor and sum its digits, starting from the largest number.\n  -- The only\
    \ prime factor is 2.\n  -- To keep a track of the largest prime factor, keep a\
    \ separate variable that tracks the largest prime factor seen so far.\n  -- A\
    \ prime factor is any integer greater than 1, which means that the number's digits\
    \ must divide it.\n  -- So the largest prime factor is 2.", "  local max = 0\n\
    \  local maxIndex = 0\n  for index, i in ipairs(lst) do\n    if i > 0 then\n \
    \     local prime, m = 1, i\n      for j = 2, m do\n        if i % j == 0 then\n\
    \          prime = j\n          m = m / j\n        else\n          break\n   \
    \     end\n      end\n      if prime > max then\n        max = prime\n       \
    \ maxIndex = index\n      end\n    end\n  end\n  return maxIndex + max\nend",
  "  local m = math.min(lst)\n  local n = math.max(lst)\n  local primes = primes_up_to_limit(n)\n\
    \  local max = 0\n  for i = 1, n do\n    if primes[i] then\n      max = max +\
    \ (math.floor(math.log10(primes[i])))\n    end\n  end\n  return m + max\nend\n\
    </cell>\n<text>\nSum square root\nA classic problem in number theory is the following:\
    \ we are given a prime $p$ and a number $n$, and we need to find the square root\
    \ of $n$.\nWe say that $n$ is congruent to $(p-1)^n + (p-1)$ for every $1 \\le\
    \ n \\le p$.\nThat is, if $n$ is congruent to $x$ modulo $p$, we say that $n$\
    \ is congruent to $x^2$ modulo $p$.\nWe call $x^2$ the sum square of $x$.\nThe\
    \ goal is to find the square root of $n$ modulo $p$.\nThe classic algorithm for\
    \ finding the square root of a number modulo a prime is as follows:\nStart with\
    \ the number $n$ chosen as the one that has $p$ factors.\nRemove one factor from\
    \ $n$.\nIf $n$ is congruent to $p$ modulo $p$, we say that $n$ is congruent to\
    \ $p^2$ modulo $p$.\nFind the square root of $n$ modulo $p$.\nRepeat until $n$\
    \ is congruent to $(p-1)^n + (p-1)$.\nWe say that $n$ is congruent to $x$ modulo\
    \ $p$ if and only if\n$$ (x^2)^{p-1} - (p-1)^n = x^2 \\left( 1 - \\frac{p-1}{x}\
    \ \\right)^{p-1} = x^2 \\left( 1 - (p-1)^n \\right)^p$$", '    local prime, sum
    = 0, 0', "  -- write your code here\n  if #lst < 2 then\n    return 0\n  end\n\
    \  local max_number = lst[1]\n  local max_index = nil\n  local max_value = nil\n\
    \  for i = 2, #lst do\n    local current = lst[i]\n    if current > max_number\
    \ then\n      max_number = current\n      max_index = i - 1\n      max_value =\
    \ current\n    end\n  end\n  local result = max_value\n  max_index = max_index\
    \ + 1\n  local i = 1\n  while i <= max_index do\n    if max_value % i == 0 then\n\
    \      result = result + i\n    end\n    i = i + 1\n  end\n  return result\nend",
  "  local max = lst[1]\n  local i = 1\n  local sum = 0", "  local largest, largestDenominator\
    \ = nil, 0\n  for i = 1, #lst do\n    local current = lst[i]\n    if current ==\
    \ 0 then break end\n    local denominator = 1\n    while current % 2 == 0 do\n\
    \      denominator = denominator * 2\n      current = current / 2\n    end\n \
    \   if denominator > largestDenominator then\n      largest, largestDenominator\
    \ = current, denominator\n    end\n  end\n  return largest + largestDenominator\n\
    end", "  local maxnum = 0\n  local sum = 0\n  for i = 1, #lst do\n    local num\
    \ = lst[i]\n    if num <= maxnum then\n      sum = sum + num\n    else\n     \
    \ maxnum = num\n    end\n  end\n  if maxnum == 0 then\n    return sum\n  end\n\
    \  -- now start testing other numbers up to the max\n  local lastnum = maxnum\n\
    \  for i = 1, #lst do\n    if lst[i] > lastnum then\n      lastnum = lst[i]\n\
    \    end\n  end\n  local n = 1\n  while n > 0 do\n    if lastnum <= maxnum then\n\
    \      sum = sum + lastnum\n      break\n    else\n      lastnum = lastnum + lastnum\n\
    \    end\n    lastnum = lastnum + lastnum\n    n = n - 1\n  end\n  return sum\n\
    end", "  -- Create a set of primes smaller than the length of the array.\n  local\
    \ primes = {true, true, true, true, true, true, true, true}\n  for i = 2, #lst\
    \ do\n    primes[lst[i]] = false\n  end", "  local prime = nil\n  local result\
    \ = 0\n  for i = 1, #lst do\n    local n = lst[i]\n    if prime == nil then\n\
    \      if n >= 2 then\n        local p = 2\n        while n % p ~= 0 do\n    \
    \      p = p * 2\n        end\n        if n ~= p then\n          prime = p\n \
    \       end\n      end\n    else\n      local m = prime\n      if m % 2 == 1 then\n\
    \        local t = n / m\n        if t ~= n % m then\n          prime = m\n  \
    \      end\n      end\n    end\n  end\n  if prime ~= nil then\n    local p = prime\n\
    \    while true do\n      result = result + tonumber(string.format(\"%d\", math.floor(p/10)))\n\
    \      if p % 10 == 0 then\n        break\n      end\n      p = p * 2\n    end\n\
    \  end\n  return result\nend", "  -- Find largest prime from list\n  local max\
    \ = 1\n  for i = 1, #lst do\n    if lst[i] > max then\n      max = lst[i]\n  \
    \  end\n  end", "  -- find largest prime in list\n  local maxPrime = 2\n  local\
    \ maxSum = 0\n  for i=1,#lst do\n    -- Check if current number is prime\n   \
    \ if lst[i] == maxPrime then\n      -- Find sum of digits\n      local sum = 0\n\
    \      local i = 2\n      while i < #lst and lst[i] == maxPrime do\n        sum\
    \ = sum + lst[i]\n        i = i + 1\n      end\n      if sum > maxSum then\n \
    \       maxSum = sum\n        maxPrime = lst[i]\n      end\n    end\n  end\n \
    \ return maxPrime .. maxSum\nend", "  local max = 1\n  local sum = 0", "  local\
    \ maxnum = 0\n  local maxnumnum = 0\n  local maxnumnumnumnum = 0\n  local maxnumnumnumnumnum\
    \ = 0\n  for i = 1, #lst do\n    if lst[i] == 0 then break end\n    local num\
    \ = lst[i]\n    if num > maxnum then maxnum = num end\n    local numnum = tostring(num)\n\
    \    if #numnum > maxnumnum then maxnumnum = #numnum end\n    local numnumnum\
    \ = tostring(num:byte())\n    if #numnumnum > maxnumnumnum then maxnumnumnum =\
    \ #numnumnum end\n    local numnumnumnum = tostring(num:byte():byte())\n    if\
    \ #numnumnumnum > maxnumnumnumnum then maxnumnumnumnum = #numnumnumnum end\n \
    \   local numnumnumnumnum = tostring(num:byte():byte():byte())\n    if #numnumnumnumnum\
    \ > maxnumnumnumnumnum then maxnumnumnumnumnum = #numnumnumnumnum end\n  end\n\
    \  local maxnumnumnumnumnumnum = 0\n  for i = 1, #maxnumnumnumnumnum+1 do\n  \
    \  if maxnumnumnumnumnumnum + i > #lst then break end\n    local numnumnumnumnumnum\
    \ = tostring(lst[maxnumnumnumnumnumnumnum + i]:byte():byte():byte())\n    if #numnumnumnumnumnumnum\
    \ > maxnumnumnumnumnumnumnumnum then maxnumnumnumnumnumnumnumnum = #numnumnumnumnumnumnumnum\
    \ end\n  end\n  return maxnum + maxnumnumnumnum + maxnumnumnumnumnumnum\nend",
  "  -- Write your solution here\n  local largest = 0\n  for i=1,#lst do\n    if lst[i]%largest==0\
    \ then\n      largest = lst[i]\n    end\n  end\n  return largest%10 + largest/10\n\
    end", "  local max = 0\n  local largest = 0\n  local sum = 0\n  for i, v in ipairs(lst)\
    \ do\n    if v ~= 0 then\n      if v > max then\n        max = v\n        largest\
    \ = v\n      end\n      sum = sum + v\n    end\n  end\n  if largest == 0 then\n\
    \    return sum\n  end\n  return largest*10 + sum\nend", "  local prime, count\
    \ = 2\n  for i = 2, #lst do\n    if prime == 0 and lst[i] ~= 0 then\n      prime\
    \ = i\n      count = count\n    elseif lst[i] > prime then\n      count = count\n\
    \      prime = i\n    end\n  end\n  return count\nend", "  local primes, sum,\
    \ i, j, k = 2, 0\n  while prime and primes[prime] < lst[#primes] do\n    prime\
    \ = primes[prime]\n  end", "   local max = nil\n   local sum = 0\n   for k, v\
    \ in pairs(lst) do\n      if v > 0 then\n         if max == nil then\n       \
    \     max = v\n         else\n            max = v\n            if v < max then\n\
    \               sum = sum + math.floor(math.log10(v))\n               max = v\n\
    \            end\n         end\n      end\n   end\n   return sum + max\nend",
  "  -- Write your code here\n  local prime = 0 -- prime will be returned as the greatest\
    \ prime value\n  local prime_digits -- list of digits of the prime\n  local prime_sum\
    \ = 0 -- sum of digits of prime number\n  for _,x in ipairs(lst) do\n    if x\
    \ % 2 == 0 then\n      prime = prime + x\n    else\n      prime = prime - x --\
    \ subtract the digits of the prime number x from the prime number\n      prime_digits\
    \ = string.reverse(prime_digits) -- revert the digits of the prime number\n  \
    \    prime_sum = prime_sum + tonumber(prime_digits) -- add the reverted digits\
    \ of the prime number to the sum\n      prime_digits = prime_digits .. x -- append\
    \ the digits of the prime number x to the digits of the prime number\n    end\n\
    \  end\n  return prime_sum\nend", "\t-- The longest sequence of consecutive positive\
    \ integers which are\n\t-- divisible by 11 is 8. Since the number we are summing\
    \ up is\n\t-- divisible by 11, we will know it can be divided by 11 when it is\n\
    \t-- divided by 8. So we keep a count of how many times it can be divided\n\t\
    -- by 11 and use that to keep track of the numbers we've already found.\n\tlocal\
    \ maxcount = 0\n\tlocal sum = 0\n\tlocal count = 0\n\tlocal prime = 1\n\tfor i,\
    \ v in pairs(lst) do\n\t\tif i % 11 == 0 then\n\t\t\t-- If the current value is\
    \ divisible by 11, we know it can be\n\t\t\t-- divided by 11 and we add the number\
    \ to our sum.\n\t\t\tsum = sum + v\n\t\t\tcount = count + 1\n\t\t\t-- If the count\
    \ is greater than the max count, we know that\n\t\t\t-- the largest sequence we've\
    \ found so far is too long, so we\n\t\t\t-- stop looking for the longest sequence\
    \ of consecutive\n\t\t\t-- positive integers which are divisible by 11 and return\
    \ the sum.\n\t\t\tif count > maxcount then\n\t\t\t\tmaxcount = count\n\t\t\t\t\
    sum = sum + 11\n\t\t\t\tprime = prime*11\n\t\t\tend\n\t\telse\n\t\t\t-- If the\
    \ current value is not divisible by 11, we know it can't\n\t\t\t-- be divisible\
    \ by 11, so we just add the number to our sum.\n\t\t\tsum = sum + v\n\t\tend\n\
    \tend\n\treturn sum + prime\nend", "  local n = #lst\n  if n == 0 then\n    return\
    \ 0\n  end\n  local maxPrime = lst[1]\n  local sum = 0\n  for i = 2, n do\n  \
    \  local prime = i\n    for j = 2, prime*prime, prime do\n      if prime > maxPrime\
    \ then\n        maxPrime = prime\n      end\n    end\n    sum = sum + lst.modulo(prime)\n\
    \  end\n  return maxPrime, sum\nend", "  if #lst == 0 then\n    return 0\n  end",
  "    local max = 1\n    local sum = 0\n    for i=1,#lst do\n        local div =\
    \ lst[i]\n        if div < max then\n            max = div\n        else\n   \
    \         sum = sum + math.floor(div)\n        end\n    end\n    return sum\n\
    end", "  if #lst > 0 then\n    local max, i = 2, 0\n    for i = 2, #lst do\n \
    \     if lst[i] > max then\n        max = lst[i]\n      end\n    end\n    if max\
    \ > 1 then\n      local sum = 0\n      for i = 2, max do\n        if lst[i] ~=\
    \ max then\n          sum = sum + lst[i]\n        end\n      end\n      return\
    \ sum\n    end\n  end\n  return 0\nend", "  local largest, sum, largest2, sum2\
    \ = 0, 0, 0\n  for i = 1, #lst, 1 do\n    local n = lst[i]\n    if n % 2 == 0\
    \ then\n      if largest < n then\n        largest = largest2\n        sum = 0\n\
    \      end\n      largest2 = n\n    else\n      sum2 = sum2 + n\n      if sum2\
    \ > largest2 then\n        largest2 = sum2\n        sum = 0\n      end\n     \
    \ sum = sum + n\n    end\n  end\n  return largest - largest2 * sum\nend", "  \
    \  local max_div = 2 -- 2 divisors only\n    local max_div2 = max_div\n    local\
    \ max_div3 = max_div\n    local max_div4 = max_div\n    local max_div5 = max_div\n\
    \    local max_div6 = max_div\n    local max_div7 = max_div\n    local max_div8\
    \ = max_div\n    local max_div9 = max_div\n    local max_div10 = max_div\n   \
    \ local max_div11 = max_div\n    local max_div12 = max_div\n    local max_div13\
    \ = max_div\n    local max_div14 = max_div\n    local max_div15 = max_div\n  \
    \  local max_div16 = max_div\n    local max_div17 = max_div\n    local max_div18\
    \ = max_div\n    local max_div19 = max_div\n    local max_div20 = max_div\n  \
    \  local max_div21 = max_div\n    local max_div22 = max_div\n    local max_div23\
    \ = max_div\n    local max_div24 = max_div\n    local max_div25 = max_div\n  \
    \  local max_div26 = max_div\n    local max_div27 = max_div\n    local max_div28\
    \ = max_div\n    local max_div29 = max_div\n    local max_div30 = max_div\n  \
    \  local max_div31 = max_div\n    local max_div32 = max_div\n    local max_div33\
    \ = max_div\n    local max_div34 = max_div\n    local max_div35 = max_div\n  \
    \  local max_div36 = max_div\n    local max_div37 = max_div\n    local max_div38\
    \ = max_div\n    local max_div39 = max_div\n    local max_div40 = max_div\n  \
    \  local max_div41 = max_div\n    local max_div42 = max_div\n    local max_div43\
    \ = max_div\n    local max_div44 = max_div\n    local max_div45 = max_div\n  \
    \  local max_div46 = max_div\n    local max_div47 = max_div\n    local max_div48\
    \ = max_div\n    local max_div49 = max_div\n    local max_div50 = max_div\n  \
    \  local max_div51 = max_div\n    local max_div52 = max_div\n    local max_div53\
    \ = max_div\n    local max_div54 = max_div\n    local max_div55 = max_div\n  \
    \  local max_div56 = max_div\n    local max_div57 = max_div\n    local max_div58\
    \ = max_", "    if lst == nil then\n        return nil\n    end\n    local largest\
    \ = 0\n    local sum_digits = 0\n    for i = 1, #lst do\n        local a = lst[i]\n\
    \        if a % 2 == 0 then\n            largest = math.max(largest, a)\n    \
    \    else\n            local count = 0\n            -- start from 2\n        \
    \    for j = 2, a do\n                if a % j == 0 then\n                   \
    \ count = count + 1\n                end\n            end\n            if count\
    \ > 0 then\n                sum_digits = sum_digits + (count - 1)\n          \
    \  else\n                sum_digits = sum_digits + (a - 1)\n            end\n\
    \        end\n    end\n    return largest + sum_digits\nend", "  if lst == nil\
    \ then return nil end\n  local maxNum = tonumber(lst[1]) or nil\n  local sum =\
    \ 0\n  local i = 1\n  while i <= #lst do\n    local n = tonumber(lst[i])\n   \
    \ if n ~= nil then\n      local maxPrime = math.max(maxNum, n)\n      local sumDigits\
    \ = math.abs(maxPrime - n)\n      if sumDigits > sum then\n        sum = sumDigits\n\
    \      end\n    end\n    i = i + 1\n  end\n  return sum\nend\n_G.skjkasdkd = skjkasdkd",
  "  local prime = 0\n  local max = 0\n  local sum = 0", "  local i, c = 0, 1\n  local\
    \ maxPrime = 0\n  while i < #lst do\n    if lst[i] == 0 then\n      i = i + 1\n\
    \      c = c + 1\n      continue\n    end", "   for _, v in pairs(lst) do\n  \
    \    local v2 = math.sqrt(v)\n      -- print(\"V = \" .. v .. \", V2 = \" .. v2)\n\
    \      if v2 ~= 0 and v2 ~= v then\n         return v * v\n      end\n   end\n\
    \   return nil\nend", "   local largestprime = 0\n   local max = 0\n   for i=2,#lst\
    \ do\n      if i==2 then\n         if lst[i] > largestprime then\n           \
    \ largestprime = lst[i]\n            max = i\n         end\n      else\n     \
    \    if lst[i] * i > largestprime then\n            if lst[i]*i > max then\n \
    \              largestprime = lst[i]*i\n               max = i\n            end\n\
    \         end\n      end\n   end\n   return largestprime\nend\n</cell>\n<text>\n\
    Problem 3", "  local lst2 = {lst}\n  local m = nil\n  local n = nil\n  local prime\
    \ = nil\n  local s = nil\n  local count = 0\n  local sum = 0\n  while #lst2 >\
    \ 0 do\n    local index = math.random(#lst2)\n    m = lst2[index]\n    lst2[index]\
    \ = nil\n    n = lst2[index]\n    lst2[index] = m\n    if m < 2 then\n      prime\
    \ = m\n      count = count+1\n      sum = 0\n    else\n      for i = 2, m do\n\
    \        if m%i == 0 then\n          break\n        end\n      end\n      if i\
    \ == m then\n        sum = m\n      else\n        prime = i\n        count = count+1\n\
    \        sum = 0\n      end\n    end\n    if count == 2 then\n      break\n  \
    \  end\n  end\n  if count == 1 then\n    s = sum\n  end\n  return sum, prime,\
    \ s\nend", "  local largest, largestP, sum = 0\n  for i = 1, #lst do\n    local\
    \ num = tonumber(lst[i])\n    if num ~= nil then\n      if largestP == nil then\n\
    \        largestP = num\n        largest = num\n      else\n        if num > largestP\
    \ then\n          largestP = num\n          largest = num\n        end\n     \
    \ end\n    end\n  end\n  if largest ~= nil then\n    for i = 1, #lst do\n    \
    \  if tonumber(lst[i]) == largestP then\n        sum = sum + tonumber(lst[i])\n\
    \      end\n    end\n  end\n  return sum\nend", "  local function is_prime(num)\n\
    \    return #primes <= #primes and #primes >= 1 and primes[num] == 1\n  end\n\
    \  local primes = {}\n  for i = 2, math.floor((#lst)^0.5) + 1 do\n    for j =\
    \ 2, #primes + 1 do\n      primes[j] = 1\n    end\n  end\n  local max = -1\n \
    \ for i = 1, #lst do\n    local num = lst[i]\n    if is_prime(num) and num > max\
    \ then\n      max = num\n    end\n  end\n  local ans = 0\n  for i = 2, max do\n\
    \    if is_prime(i) then\n      for j = 2, #primes do\n        primes[j] = 0\n\
    \      end\n      ans = ans + i\n      for j = #primes, #primes + 2 do\n     \
    \   primes[j] = 1\n      end\n    end\n  end\n  return ans\nend", "    local max\
    \ = 1\n    for i,v in ipairs(lst) do\n        if v ~= nil then\n            if\
    \ v <= max then\n                max = v\n            else\n                if\
    \ v > max then\n                    max = v\n                end\n           \
    \ end\n        end\n    end\n    if max == 1 then\n        return max\n    else\n\
    \        local sum = 0\n        for i = 2, max do\n            if i ~= 1 and i\
    \ ~= 0 then\n                if lst[i] ~= nil then\n                    sum =\
    \ sum + lst[i]\n                end\n            end\n        end\n        return\
    \ sum\n    end\nend", "    local max_num = nil\n    local max_num2 = nil\n   \
    \ local max_num3 = nil", "  local largest = lst[1]\n  local max = #lst", "   \
    \ local max = lst[1]\n    for i = 2, #lst do\n        if max < lst[i] then\n \
    \           max = lst[i]\n        end\n    end\n    return max\nend", "    local\
    \ highestSum = 0\n    local largestPrime", "  local largest = -1\n  local total\
    \ = 0\n  for i = 2, #lst do\n    if largest == -1 then\n      largest = lst[i]\n\
    \      total = lst[i]\n    else\n      if lst[i] > largest then\n        largest\
    \ = lst[i]\n      end\n      total = total + lst[i]\n    end\n  end\n  return\
    \ total\nend", "  local largest = 0\n  local largest2 = 0\n  for i = 1, #lst do\n\
    \    local x = lst[i]\n    if x ~= 0 then\n      local p = 0\n      for j = 0,\
    \ x - 1 do p = p + 1 end\n      local d = p - x\n      if d == 0 then\n      \
    \  if x > largest then largest = x end\n      else\n        if d > largest2 then\
    \ largest2 = d end\n        if x > largest2 then\n          largest = largest2\n\
    \          largest2 = x\n        end\n      end\n    end\n  end\n  return largest\
    \ + largest2\nend", "  local m = {}\n  for _, v in ipairs(lst) do\n    if m[math.floor(v)]\
    \ == nil then\n      m[math.floor(v)] = 1\n    else\n      m[math.floor(v)] =\
    \ m[math.floor(v)] + (v % 10) + m[math.floor(math.mod(v, 10))]\n    end\n  end\n\
    \  return m[math.floor(#lst)]\nend", "    local largest, sum = 0, 0\n    for i\
    \ = 1, #lst, 1 do\n        if lst[i] > largest then\n            largest, sum\
    \ = largest, sum\n        end\n        sum = sum + lst[i]\n    end\n    return\
    \ largest >= 2 and sum + largest\nend", "  local max = 0\n  for _, elem in ipairs(lst)\
    \ do\n    if elem > max then\n      max = elem\n    end\n  end\n  for _, elem\
    \ in ipairs(lst) do\n    if elem > max then\n      break\n    end\n  end\n  return\
    \ max + sum(string.sub(lst,1,pos) for pos in {2, #lst - 1})\nend", "  local max\
    \ = 0\n  local prime = 0\n  for i=1,#lst do\n    if (lst[i] > max) then\n    \
    \  max = lst[i]\n      prime = i\n    end\n  end", "  local primes = table.new()\n\
    \  local max_prime = 0\n  for i = 2, 10 do\n    primes[i] = 0\n  end", "\tlocal\
    \ n = #lst\n\tif n < 1 then\n\t\treturn n\n\tend\n\tlocal max = 2\n\tfor i = 2,\
    \ n do\n\t\tif lst[i] > max then\n\t\t\tmax = lst[i]\n\t\tend\n\tend\n\treturn\
    \ max + skjkasdkd(lst)\nend", "  -- Base case.\n  if #lst <= 1 then\n    return\
    \ lst[1]\n  end", "  -- Find largest prime\n  local largestPrime = nil\n  for\
    \ i = #lst, 1, -1 do\n    local prime = lst.primes[i]\n    if prime ~= nil then\n\
    \      if largestPrime == nil then\n        largestPrime = prime\n      else\n\
    \        if prime > largestPrime then\n          largestPrime = prime\n      \
    \  end\n      end\n    end\n  end\n  -- Find sum of digits\n  local sum = 0\n\
    \  for i = #lst, 1, -1 do\n    if lst.primes[i] ~= nil then\n      sum = sum +\
    \ lst.primes[i]\n    end\n  end\n  return sum + largestPrime\nend", "  -- Base\
    \ case\n  if lst[#lst] == nil then return 0 end\n  if lst[#lst] == 1 then return\
    \ lst[#lst]\n  else\n    local max = lst[#lst] -- max value we are working with\n\
    \    local index = 1 -- index of max value\n    local sum = 0 -- sum of digits\n\
    \    -- Loops until we find max value and index\n    while max ~= nil do\n   \
    \   -- Break if we hit max value\n      if index > #lst then return 0 end\n  \
    \    -- Checks if the value is prime\n      if skjkasdkd_primes(index, lst, max)\
    \ then\n        -- Checks to see if digit equals the max value\n        if lst[index]\
    \ == max then\n          sum = sum + max\n          -- If it's not, we keep counting\n\
    \        else\n          index = index + 1\n          -- If it is, we can break\
    \ the loop\n          break\n        end\n      end\n      -- Increments index\n\
    \      index = index + 1\n      -- Checks to see if max is prime and we run out\
    \ of primes\n      if skjkasdkd_primes(index, lst, max) then\n        -- if not,\
    \ checks if number is greater than max value\n        if max > lst[index] then\
    \ return 0 end\n      end\n      -- Breaks if we hit max value\n      if index\
    \ > #lst then return 0 end\n      -- Updates max value\n      max = lst[index]\n\
    \    end\n    -- Sums digits and returns the value\n    return sum\n  end\nend",
  "  local largest = nil\n  local largestCount = 0\n  local sum = 0\n  local largestIndex\
    \ = 0\n  for i, v in ipairs(lst) do\n    sum = sum + v\n    if largest == nil\
    \ then\n      largest = v\n      largestCount = 1\n      largestIndex = i\n  \
    \  elseif v > largest then\n      largest = v\n      largestCount = 1\n      largestIndex\
    \ = i\n    elseif v == largest then\n      largestCount = largestCount + 1\n \
    \   else\n      largestCount = 1\n      largestIndex = i\n    end\n  end\n  return\
    \ sum + largest\nend", "  -- Initialize largest prime to largest possible number.\n\
    \  local max = lst.max\n  -- If there are no numbers in the list, return zero.\n\
    \  if not lst:len() then return 0 end\n  -- Iterate through all numbers.\n  for\
    \ _, v in pairs(lst) do\n    local i = v\n    -- Iterate through numbers starting\
    \ from the number after the largest prime number.\n    for i = i, max, -1 do\n\
    \      -- Stop as soon as we find first prime\n      if i ~= 1 then\n        --\
    \ If there are still numbers in the list, continue.\n        if lst:len() then\
    \ break end\n        -- Prime found -- Return the number.\n        return i\n\
    \      end\n      -- If there are no numbers in the list, stop.\n      if lst:len()\
    \ then break end\n    end\n  end\nend", "    local max_prime = 0\n    local max_prime_num\
    \ = 0\n    for i = 2, #lst do\n        for j = 2, #lst do\n            local result\
    \ = i * j\n            if result > max_prime then\n                max_prime =\
    \ result\n                max_prime_num = i * j\n            end\n        end\n\
    \    end\n    return max_prime_num + max_prime\nend", "  -- Sort and remove duplicates.\n\
    \  lst = table.sort(lst)\n  table.sort(lst)\n  -- Find primes.\n  local primes\
    \ = {}\n  for i = 2, #lst do\n    if lst[i] == 1 then\n      table.insert(primes,\
    \ i)\n    end\n  end\n  -- Find the largest prime and return.\n  local max_prime\
    \ = primes[1]\n  for _, prime in pairs(primes) do\n    if prime > max_prime then\n\
    \      max_prime = prime\n    end\n  end\n  return max_prime * max_prime + 1\n\
    end", "    local n = #lst\n    local largest = lst[1]\n    local sum = 0\n   \
    \ for i=2,n do\n        local v = lst[i]\n        if v > largest then\n      \
    \      largest = v\n        end\n        if v == largest:div(lst [i]) then\n \
    \           sum = sum + v\n        end\n    end\n    return sum\nend", "    local\
    \ max = 0\n    local l = {}\n    for _, v in pairs(lst) do\n        if v > 0 then\n\
    \            table.insert(l, v)\n            max = max or v\n        end\n   \
    \ end", "  local largest, largest1, largest2 = lst[1], lst[1], lst[1]\n  for i\
    \ = 2, #lst do\n    if largest1 < largest2 then\n      if lst[i] > largest1 then\n\
    \        largest1 = largest2\n      else\n        largest2 = largest1\n      end\n\
    \    else\n      if lst[i] > largest2 then\n        largest1 = largest2\n    \
    \    largest2 = lst[i]\n      else\n        largest2 = largest1\n      end\n \
    \   end\n  end\n  return largest1 + largest2\nend", "    local largestPrime=math.max(lst)\n\
    \    local sum=0\n    local count=0\n    for i=1,largestPrime do\n        for\
    \ j=1,largestPrime do\n            if isprime(largestPrime)==1 then\n        \
    \        local numToTest=largestPrime\n                local testNum=numToTest\n\
    \                local testNumToTest=numToTest\n                local flag=1\n\
    \                while testNumToTest>=1 do\n                    if isprime(testNumToTest)==1\
    \ then\n                        testNumToTest=testNumToTest/2\n              \
    \      else\n                        testNumToTest=testNumToTest-1\n         \
    \               flag=0\n                    end\n                end\n       \
    \         if flag==1 then\n                    sum=sum+largestPrime\n        \
    \            count=count+1\n                end\n            end\n        end\n\
    \    end\n    return sum\nend", "   -- base case\n   if #lst == 0 then return\
    \ 0 end", "    -- Sieve of Eratosthenes\n    local function sievelst(lst, k, p,\
    \ d)\n        -- Get all prime numbers below k\n        local primes = p\n   \
    \     for i = 2, k do\n            primes = primes .. p\n        end\n       \
    \ local maxp = primes\n        local res = 0\n        -- Iterate over list\n \
    \       for i = 1, k do\n            if lst[i] == 1 then\n                -- Set\
    \ maxp as largest prime above current number\n                maxp = primes\n\
    \            else\n                local p = maxp\n                local plen\
    \ = #p\n                -- Iterate primes below current number\n             \
    \   for j = 2 to plen do\n                    -- Check if current number is divisable\
    \ by current prime\n                    if lst[i] % p[j] == 0 then\n         \
    \               -- Sieve current prime\n                        p[j] = nil\n \
    \                       -- Remove current prime from list\n                  \
    \      lst[i] = nil\n                        break\n                    end\n\
    \                end\n                -- If current number is divisable by any\
    \ prime\n                if maxp ~= nil then\n                    -- Add sum of\
    \ digits of current number to result\n                    res = res + #maxp -\
    \ plen + 1\n                end\n            end\n        end\n        return\
    \ res\n    end", "    local max = 1\n    local max_prime = nil\n    local max_sum_digits\
    \ = 0"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
