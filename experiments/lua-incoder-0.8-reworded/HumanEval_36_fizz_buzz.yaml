name: HumanEval_36_fizz_buzz
language: lua
prompt: "-- Return the number of times the digit 7 appears in integers less than n\
  \ which are divisible by 11 or 13.\n-- >>> fizz_buzz(50)\n-- 0\n-- >>> fizz_buzz(78)\n\
  -- 2\n-- >>> fizz_buzz(79)\n-- 3\nlocal function fizz_buzz(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = fizz_buzz\n\
  \    lu.assertEquals(candidate(50), 0)\n    lu.assertEquals(candidate(78), 2)\n\
  \    lu.assertEquals(candidate(79), 3)\n    lu.assertEquals(candidate(100), 3)\n\
  \    lu.assertEquals(candidate(200), 6)\n    lu.assertEquals(candidate(4000), 192)\n\
  \    lu.assertEquals(candidate(10000), 639)\n    lu.assertEquals(candidate(100000),\
  \ 8026)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if n == 0 then return 0 else return fizz_buzz(n - 1) + fizz_buzz(n\
    \ % 11) + fizz_buzz(n % 13)\nend", "\tlocal t\n\tfor i = 1, n do\n\t\tif i % 11\
    \ == 0 then\n\t\t\tt = t + 1\n\t\telseif i % 13 == 0 then\n\t\t\tt = t + 2\n\t\
    \tend\n\tend\n\treturn t\nend", "  if n < 10 then\n    return n\n  elseif n <\
    \ 100 then\n    return fizz_buzz(n % 10) + 7\n  elseif n < 1000 then\n    return\
    \ fizz_buzz(n % 100) + 11\n  else\n    return fizz_buzz(n % 1000) + 13\n  end\n\
    end", "    local c = 0\n    while n >= 100 do\n        if ((n % 11) == 0 or (n\
    \ % 13) == 0) then\n            c = c + 1 -- Increment by 1 if n is divisible\
    \ by 11 or 13.\n        end\n        n = n / 10\n    end\n    return c\nend",
  "  if n < 10 then\n    return n\n  else\n    local digit = math.floor(n / 10)\n\
    \    local rest = n % 10\n    local count_digit = fizz_buzz(digit)\n    local\
    \ count_rest = fizz_buzz(rest)\n    if count_digit == 0 then\n      return count_rest\
    \ + 1\n    end\n    return count_digit + count_rest\n  end\nend", "    local count\
    \ = 0\n    local remainder = math.mod(n, 10)\n    while remainder ~= 0 do\n  \
    \      if remainder % 11 == 0 then\n            count = count + 1\n        end\n\
    \        remainder = math.mod(remainder, 10)\n    end\n    return count\nend",
  "  if n < 10 then return n end\n  local count  = 0\n  local mult   = 11\n  while\
    \ n >= mult do\n    count = count + 1\n    n       = n / mult\n  end\n  count\
    \ = count + 1\n  return count\nend", "  if n < 1 then return nil end\n  local\
    \ count = 0\n  for i = 1,n do\n    if n % i == 0 and n % 11 == 0 then\n      count\
    \ = count + 1\n    end\n  end\n  return count\nend", "  if n < 3 then\n    return\
    \ n\n  elseif n % 11 == 0 then\n    return fizz_buzz(n / 11) * 11 + 7\n  elseif\
    \ n % 13 == 0 then\n    return fizz_buzz(n / 13) * 13 + 7\n  else\n    return\
    \ fizz_buzz(n / 3) * 3 + 7\n  end\nend\nprint(fizz_buzz(50))\nprint(fizz_buzz(78))\n\
    print(fizz_buzz(79))\nprint(fizz_buzz(15))\nprint(fizz_buzz(13))\nprint(fizz_buzz(7))\n\
    print(fizz_buzz(3))\nprint(fizz_buzz(1))\nprint(fizz_buzz(2))\n</cell>\n<text>\n\
    FizzBuzz\nFizzBuzz (FizzBuzz) is a common coding problem that occurs when working\
    \ with prime numbers.  It occurs when trying to print out a number that has both\
    \ 1 and 3 as its factors.  For example, given number 15, you should print:", " \
    \ local count=0\n  local nums={}\n  for i=1,n,1 do\n    local j=math.floor(i/11)\n\
    \    local k=math.floor(i/13)\n    local x=i-(j+k)*11\n    if x==7 then\n    \
    \  count=count+1\n      nums[i]=1\n    elseif x==13 then\n      count=0\n    \
    \  nums[i]=1\n    elseif x%11==0 and x%13==0 then\n      count=0\n      nums[i]=1\n\
    \    elseif x%11==0 and x%13~=0 then\n      count=count+1\n      nums[i]=1\n \
    \   elseif x%11~=0 and x%13==0 then\n      count=count+1\n      nums[i]=1\n  \
    \  elseif x%11~=0 and x%13~=0 then\n      count=0\n      nums[i]=1\n    end\n\
    \  end\n  local newn={}\n  for i=1,#nums do\n    if nums[i]==1 then\n      newn[i]=1\n\
    \    end\n  end\n  return #newn\nend", "    -- Find the least integer that is\
    \ divisible by both 11 and 13\n    if n % 11 == 0 and n % 13 == 0 then\n     \
    \   return 1\n    else\n        return 0\n    end\nend", "  if n <= 0 or n % 11\
    \ == 0 or n % 13 == 0 then\n    return n\n  end\n  if n % 10 == 1 then\n    return\
    \ fizz_buzz(n / 10) + 1\n  end\n  return fizz_buzz(n / 10) + 1\nend", "  return\
    \ 1 + math.floor(math.log(n, 11) / math.log(13))\nend", "    if n >= 0 then\n\
    \        if ((n % 11) == 0) or ((n % 13) == 0) then\n            return n\n  \
    \      end\n    end\n    return fizz_buzz(math.ceil(n/11)) or fizz_buzz(math.ceil(n/13))\n\
    end", "    local count = 0\n    while n > 0 do\n        if n % 11 == 0 and n %\
    \ 13 == 0 then\n            count = count + 1\n        end\n        n = math.floor(n\
    \ / 10)\n    end\n    return count\nend", "  local count = 0;\n  for i = 1, n\
    \ do\n    -- Count the number of numbers that are divisible by 11\n    if n %\
    \ 11 == 0 then\n      count = count + 1;\n    end;", "  local nstr= tostring(n)\n\
    \  local count=0\n  for i=1,nstr do\n    if nstr:sub(i,i)==\"7\" then\n      if\
    \ nstr:sub(i,i)==\"7\" and nstr:sub(i-1,i)==\"9\" or nstr:sub(i,i)==\"7\" and\
    \ nstr:sub(i-1,i)==\"13\" then\n        count= count+1\n      elseif nstr:sub(i,i)==\"\
    7\" and nstr:sub(i-1,i)==\"11\" or nstr:sub(i,i)==\"7\" and nstr:sub(i-1,i)==\"\
    15\" then\n        count= count+1\n      end\n    end\n  end\n  return count\n\
    end", "  local count = 0\n  while n > 0 do\n    local div = n\n    local mult\
    \ = 1\n    while div > 0 do\n      local mod = math.floor(div / 11)\n      if\
    \ mod == 7 then\n        count = count + 1\n      end\n      mult = mult*11\n\
    \      div = div - mod\n    end\n    n = n - mult\n  end\n  return count\nend",
  "   if n%11 == 0 or n%13 == 0 then\n      return n\n   end", "    local numbers\
    \ = {}\n    for i = 1,n do\n        numbers[i] = tostring(i)\n    end\n    local\
    \ number_count = numbers[1]:find('7')\n    local fizzbuzz = 0\n    if number_count\
    \ ~= nil then\n        local counter = number_count:find('7')\n        local counter1\
    \ = numbers[counter]:find('7')\n        fizzbuzz = counter1 - counter\n    end\n\
    \    return fizzbuzz\nend", "  local count\n  for i = 1, n do\n    if n % 11 ==\
    \ 0 and n % 13 == 0 then\n      count = count + 1\n    end\n    n = n / 10\n \
    \ end\n  return count\nend", "  local count = 1 -- Initialize count to the value\
    \ of 1 initially.\n  for i = 1, n do\n    if isdigit(i) then\n      if i % 11\
    \ == 0 then\n        count = count + 1\n      end\n      if i % 13 == 0 then\n\
    \        count = count + 1\n      end\n    end\n  end\n  return count\nend", " \
    \ if n < 0 then\n    n\n  elseif n < 10 then\n    n\n  elseif n % 11 == 0 and\
    \ n % 13 == 0 then\n    return n\n  else\n    return fizz_buzz(math.floor(n/10))\
    \ + fizz_buzz(math.floor(n/10))\n  end\nend", "  local count=0\n  local i\n  for\
    \ i=1, math.ceil(n/11) do\n    if n % 11==0 then count=count+1 end\n  end\n  for\
    \ i=1, math.ceil(n/13) do\n    if n % 13==0 then count=count+1 end\n  end\n  return\
    \ count\nend", "  if n < 10 then\n    return n\n  elseif n < 100 then\n    if\
    \ n % 11 == 1 then\n      return n\n    else\n      if n % 13 == 1 then\n    \
    \    return n\n      else\n        return 0\n      end\n    end\n  else\n    if\
    \ n % 10 == 1 then\n      if n % 11 == 1 then\n        if n % 13 == 1 then\n \
    \         return n\n        else\n          return 0\n        end\n      else\n\
    \        return 0\n      end\n    else\n      return 0\n    end\n  end\nend",
  "  if n <= 0 then return 0 end\n  if n % 11 == 1 then return 1 end\n  if n % 13\
    \ == 1 then return 2 end\n  return fizz_buzz(n / 11) + fizz_buzz(n / 13)\nend",
  "  -- The return value is 0 to signify failure.\n  assert(n > 0)", "\tlocal count\
    \ = 0\n\tif n >= 0 and n % 11 == 0 then\n\t\tcount = count + 1\n\tend\n\tif n\
    \ >= 0 and n % 13 == 0 then\n\t\tcount = count + 1\n\tend\n\tif n >= 0 and n %\
    \ 17 == 0 then\n\t\tcount = count + 1\n\tend\n\treturn count\nend", "  local s\
    \ = \"\"\n  if n < 101 then\n    if n % 11 == 0 then s = s .. \"11\" end\n   \
    \ if n % 13 == 0 then s = s .. \"13\" end\n    return s\n  end\n  if n >= 101\
    \ then\n    for i = 101, n do\n      if i % 11 == 0 then s = s .. \"11\" end\n\
    \      if i % 13 == 0 then s = s .. \"13\" end\n    end\n  end\n  return s\nend",
  "    local n1 = math.floor(n/11)\n    local n2 = n - 11*n1\n    local n3 = math.floor(n2/13)\n\
    \    local n4 = n2 - 13*n3\n    local n5 = math.floor(n4/7)\n    local n6 = n4\
    \ - 7*n5\n    local n7 = n - 7*n6\n    return n7*11 + n6*13 + n5*7 + 1\nend",
  "  local count = 0\n  if n % 11 == 0 and n % 13 == 0 then\n    return count\n  end\n\
    \  if n % 11 == 1 then\n    count = count + 1\n  end\n  if n % 13 == 1 then\n\
    \    count = count + 1\n  end\n  return count\nend", "    local nn = math.floor(n)\n\
    \    local count = 0\n    while nn >= 0 do\n        if math.mod(nn,11) == 0 and\
    \ math.mod(nn,13) == 0 then\n            count = count + 1\n        end\n    \
    \    nn = math.floor(nn/10)\n    end\n    return count\nend", "  if n < 3 then\
    \ return n end\n  if n % 11 == 1 then return fizz_buzz(n / 11) + 1 end\n  if n\
    \ % 13 == 1 then return fizz_buzz(n / 13) + 1 end\n  return fizz_buzz(n / 3) +\
    \ 2\nend", "  local count = 1 -- Initialize the count of 7s.\n  for i = 1, n do\
    \ -- Loop from 1 to n.\n    if i % 11 == 0 and i % 13 == 0 then -- If the digit\
    \ is divisible by both 11 and 13\n      count = count + 1 -- Increment the count\
    \ by 1.\n    elseif i % 11 == 0 then -- If the digit is divisible by 11\n    \
    \  count = count + 1 -- Increment the count by 1.\n    elseif i % 13 == 0 then\
    \ -- If the digit is divisible by 13\n      count = count + 1 -- Increment the\
    \ count by 1.\n    end -- End of the else statement.\n  end -- End of the for\
    \ loop. End of the function.\n  return count -- Return the final count\nend\n\
    </cell>\n<cell>", "  -- Check input arguments.\n  if not n then\n    -- If no\
    \ argument is given, print an error.\n    -- >>> fizz_buzz()\n    -- Traceback\
    \ (most recent call last):\n    -- ...\n    -- TypeError: fizz_buzz() takes 1\
    \ argument (0 given)\n    -- >>> fizz_buzz(12)\n    -- Traceback (most recent\
    \ call last):\n    -- ...\n    -- TypeError: fizz_buzz() takes 1 argument (2 given)\n\
    \    -- >>> fizz_buzz(12, 13)\n    -- Traceback (most recent call last):\n   \
    \ -- ...\n    -- TypeError: fizz_buzz() takes 1 argument (2 given)\n    return\
    \ nil\n  elseif n < 1 then\n    -- If argument is less than 1, return 0.\n   \
    \ -- >>> fizz_buzz(-1)\n    -- 0\n    -- >>> fizz_buzz(0)\n    -- 0\n    -- >>>\
    \ fizz_buzz(1)\n    -- 0\n    -- >>> fizz_buzz(12)\n    -- 0\n    return 0\n \
    \ elseif n > 1 then\n    -- If argument is greater than 1, return 1.\n    -- >>>\
    \ fizz_buzz(12)\n    -- 1\n    -- >>> fizz_buzz(13)\n    -- 1\n    -- >>> fizz_buzz(14)\n\
    \    -- 1\n    return 1\n  else\n    -- If argument is a single digit, return\
    \ the value.\n    -- >>> fizz_buzz(8)\n    -- 8\n    -- >>> fizz_buzz(9)\n   \
    \ -- 9\n    -- >>> fizz_buzz(10)\n    -- 10\n    -- >>> fizz_buzz(11)\n    --\
    \ 11\n    -- >>> fizz_buzz(12)\n    -- 12\n    -- >>> fizz_buzz(13)\n    -- 13\n\
    \    -- >>> fizz_buzz(14)\n    -- 14\n    -- >>> fizz_buzz(15)\n    -- 15\n  \
    \  -- >>> fizz_buzz(16)\n    -- 16\n    -- >>> fizz_buzz(17)\n    -- 17\n    --\
    \ >>> fizz_buzz(18)\n    -- 18\n    -- >>> fizz_buzz(19)\n    -- 19\n    -- >>>\
    \ fizz_buzz(20)\n    -- 20\n    -- >>> fizz_buzz(21)\n    -- 21\n    -- >>> fizz_buzz(22)\n\
    \    -- 22\n    -- >>> fizz_buzz(23)\n    -- 23\n    -- >>> fizz_buzz(24)\n  \
    \  -- 24\n    -- >>> fizz_buzz(25)\n    -- 25\n    -- >>> fizz_buzz(26)\n    --\
    \ 26\n    -- >>> fiz", "  local count = 0\n  local div = math.floor(n/11)\n  count\
    \ = count + div\n  if n % 11 == 0 then count = count + 1 end\n  div = math.floor(n/13)\n\
    \  count = count + div\n  if n % 13 == 0 then count = count + 1 end\n  return\
    \ count\nend", "\t-- Handle base case\n\tif n < 0 then return end\n\t-- Return\
    \ 0 if the number is divisible by 11 or 13\n\tif n % 11 == 0 or n % 13 == 0 then\
    \ return 0 end\n\t-- Compute how many times 7 appears in the integers less than\
    \ n\n\tlocal count = 0\n\t-- Iterate over all integers less than n\n\tfor i =\
    \ 1, n do\n\t\t-- If i is a multiple of 7, count that number\n\t\tif i % 7 ==\
    \ 0 then count = count + 1 end\n\tend\n\t-- Return the count\n\treturn count\n\
    end", "  local count = 0\n  local function helper(n)\n    if n <= 0 then return\
    \ 0 end\n    if n % 13 == 0 and n % 11 == 0 then count = count + 1 end\n    return\
    \ helper(n - 1)\n  end\n  return helper(n)\nend", "  -- If n is a multiple of\
    \ 3, return n.\n  if n % 3 == 0 then\n    return n\n  -- If n is a multiple of\
    \ 15, return n (as it's divisible by 15).\n  elseif n % 15 == 0 then\n    return\
    \ n\n  -- Otherwise, return n (as it's divisible by 11 and 13).\n  else\n    --\
    \ Return the number of times 7 appears in integers less than n which are divisible\
    \ by 11 and 13.\n    return count_digits(n - 7) / 2 + 1\n  end\nend\n</code>\n\
    <|/ a tags=math,fizzbuzz |>\n<| c |>\nThis should be the accepted answer. More\
    \ straightforward, no loops, no math and it works.\n<|/ c |>\n<| a dscore=5 tags=math,fizzbuzz\
    \ |>\nA simple solution that works in O(n) time is as follows:\n<code>", "   \
    \ local count = 0\n    local i = 1\n    while i <= n do\n        if n % i == 0\
    \ then\n            if i % 11 == 0 then count = count + 1 end\n            if\
    \ i % 13 == 0 then count = count + 1 end\n        end\n        i = i + 1\n   \
    \ end\n    return count\nend", "  -- Initialize our variables. We start them at\
    \ zero, since we want the result to be \"truthful.\"\n  -- We initialize \"result\"\
    \ to a truthy value, since we want the number of times the digit 7 appears to\
    \ be truthy.\n  local result = 1\n  local count = 0\n  -- Iterate through the\
    \ numbers from 2 to n, incrementing \"count\" for each number that's divisible\
    \ by 7 or 11.\n  for x = 2, n do\n    -- If the current number is divisible by\
    \ 7 and 11, then increment \"count\" by one.\n    count = count + 1\n    if x\
    \ % 7 == 0 and x % 11 == 0 then\n      -- If the current number is divisible by\
    \ 7, then increment \"result\" by one.\n      result = result + 1\n    end\n \
    \ end\n  -- Return the number of times the digit 7 appears in integers less than\
    \ n which are divisible by 11 or 13.\n  return result\nend", "  return math.floor(n/11)\
    \ * 11 + (math.floor(n/13)) * (13 - (n % 13))\nend", "  local count = 0\n  for\
    \ i = 1, n do\n    if i % 11 == 0 and i % 13 == 0 then\n      count = count +\
    \ 1\n    else\n      count = count\n    end\n  end\n  return count\nend", "  if\
    \ n < 1 then return 0 end\n  if n <= 5 then return 1 end\n  if n % 11 == 1 then\
    \ return 2 end\n  if n % 13 == 1 then return 3 end\n  local count = 0\n  for i=1,\
    \ n do\n    if i ~= 7 and i % 11 == 1 then count = count + 1 end\n    if i ~=\
    \ 7 and i % 13 == 1 then count = count + 1 end\n  end\n  return count\nend", " \
    \   if n < 0 then\n        error('The given number must be positive.')\n    end\n\
    \    local count = 0\n    for i = 1, n do\n        if n >= 0 and n % 11 == 1 then\
    \ count = count + 1 end\n        if n >= 0 and n % 13 == 1 then count = count\
    \ + 1 end\n    end\n    return count\nend", "\tif n < 10 then\n\t\treturn n\n\t\
    elseif n % 11 == 0 and n % 13 == 0 then\n\t\treturn n - 11\n\telseif n % 11 ==\
    \ 1 then\n\t\treturn fizz_buzz(n/11) - 1\n\telseif n % 13 == 1 then\n\t\treturn\
    \ fizz_buzz(n/13) - 1\n\telse\n\t\treturn fizz_buzz(n/11) + 1\n\tend\nend", " \
    \ if n < 0 then return 0 end\n  local n1 = math.floor(n)\n  local n2 = n - n1\n\
    \  if n1 == 0 or n2 == 0 then\n    return 0\n  elseif n1 == 0 and n2 % 11 == 0\
    \ then return 1 end\n  elseif n1 == 0 and n2 % 13 == 0 then return 2 end\n  elseif\
    \ n1 == 1 then\n    local n3 = math.floor(n2 / 10)\n    if n3 % 11 == 0 then return\
    \ 3\n    else return 4 end\n  elseif n1 == 2 and n2 % 13 == 1 then return 3 end\n\
    \  elseif n1 == 3 and n2 % 13 == 1 then return 4 end\n  elseif n1 == 4 then return\
    \ 5\n  elseif n1 == 5 and n2 % 13 == 1 then return 6 end\n  elseif n1 == 6 and\
    \ n2 % 13 == 1 then return 7 end\n  elseif n1 == 7 then return 8 end\n  elseif\
    \ n1 == 8 then return 9\n  elseif n1 == 9 then return 10 end\n  elseif n1 == 10\
    \ then return 11\n  elseif n1 == 11 then return 12 end\n  elseif n1 == 12 then\
    \ return 13\n  elseif n1 == 13 then return 14\n  elseif n1 == 14 then return 15\n\
    \  elseif n1 == 15 then return 16\n  elseif n1 == 16 then return 17\n  elseif\
    \ n1 == 17 then return 18\n  elseif n1 == 18 then return 19\n  elseif n1 == 19\
    \ then return 20\n  elseif n1 == 20 then return 21\n  elseif n1 == 21 then return\
    \ 22\n  elseif n1 == 22 then return 23\n  elseif n1 == 23 then return 24\n  elseif\
    \ n1 == 24 then return 25\n  elseif n1 == 25 then return 26\n  elseif n1 == 26\
    \ then return 27\n  elseif n1 == 27 then return 28\n  elseif n1 == 28 then return\
    \ 29\n  elseif n1 == 29 then return 30\n  elseif n1 == 30 then return 31\n  elseif\
    \ n1 == 31 then return 32\n  elseif n1 == 32 then return 33\n  elseif n1 == 33\
    \ then return 34\n  elseif n1 == 34 then return 35\n  elseif n1 == 35 then return\
    \ 36\n  elseif n1 == 36 then return 37\n  elseif n1 == 37 then return 38\n  elseif\
    \ n1 == 38 then return 39\n  elseif n1 == 39 ", "  if n < 0 then\n    -- For negative\
    \ numbers, the number itself is not divisible by 11 or 13.\n    return nil\n \
    \ end\n  if n >= 11 then\n    return nil\n  end\n  if n > 13 then\n    -- For\
    \ numbers which are not divisible by 11 or 13, return the number of times the\
    \ digit 7 appears in integers less than n which are divisible by 11 or 13.\n \
    \   return fizz_buzz(n-11)\n  end\n  local count = 0\n  repeat\n    -- For numbers\
    \ which are divisible by 11 or 13, return the number of times the digit 7 appears\
    \ in integers less than n which are divisible by 11 or 13.\n    count = count\
    \ + math.floor(n/11)\n    n = math.mod(n, 11)\n  until n == 0\n  return count\n\
    end", "  local digits = {}\n  local count = 0\n  for i = 1, n do\n    local d\
    \ = i % 10\n    digits[i] = d\n    if d == 7 then\n      count = count + 1\n \
    \   end\n  end\n  if count > 0 then\n    return count\n  else\n    return nil\n\
    \  end\nend", "  if n > 0 and n <= 100 then\n    -- If n is divisible by 11, then\
    \ add 1 to the result.\n    if n%11 == 1 then return 1 end\n    -- If n is divisible\
    \ by 13, then add 2 to the result.\n    if n%13 == 2 then return 2 end\n    --\
    \ If n is divisible by both 11 and 13, then add 3 to the result.\n    if n%11\
    \ == 1 and n%13 == 2 then return 3 end\n    -- If n is divisible by both 11 and\
    \ 13, then add 4 to the result.\n    if n%11 == 1 and n%13 == 1 then return 4\
    \ end\n    -- If n is divisible by both 11 and 13, then add 5 to the result.\n\
    \    if n%11 == 1 and n%13 == 3 then return 5 end\n    -- If n is divisible by\
    \ both 11 and 13, then add 6 to the result.\n    if n%11 == 2 and n%13 == 1 then\
    \ return 6 end\n    -- If n is divisible by both 11 and 13, then add 7 to the\
    \ result.\n    if n%11 == 3 and n%13 == 1 then return 7 end\n    -- If n is divisible\
    \ by both 11 and 13, then add 8 to the result.\n    if n%11 == 3 and n%13 == 2\
    \ then return 8 end\n    -- If n is divisible by both 11 and 13, then add 9 to\
    \ the result.\n    if n%11 == 3 and n%13 == 3 then return 9 end\n  end\nend",
  "  if n > 1 then\n    return fizz_buzz(n - 1)\n  else\n    if n % 11 == 1 then\n\
    \      print(\"11\")\n    elseif n % 13 == 1 then\n      print(\"13\")\n    else\n\
    \      print(n)\n    end\n  end\nend", "    if n < 0 then\n        return 0\n\
    \    end\n    local count = 1\n    while n > 0 do\n        if ((n % 11) == 0 and\
    \ (n % 13) == 0) or ((n % 11) != 0 and (n % 13) == 0) then\n            count\
    \ = count + 1\n        end\n        n = math.floor(n/10)\n    end\n    return\
    \ count\nend", "  -- This program will find how many times digit 7 appears in\
    \ integers which are divisible by 11 or 13\n  -- Example: for n = 50, fizz_buzz(n)\
    \ = 2 because 50 has two times digit 7\n  -- Example: for n = 78, fizz_buzz(n)\
    \ = 2 because 78 has two times digit 7", "\tlocal i\n\tlocal count = 0\n\tfor\
    \ i=2, n do\n\t\tcount = count + 1\n\t\tif n % i == 0 then\n\t\t\tcount = count\
    \ + 1\n\t\t\tif i % 11 == 0 or i % 13 == 0 then\n\t\t\t\tcount = count + 1\n\t\
    \t\tend\n\t\tend\n\tend\n\treturn count\nend", "  if n%11==0 then\n    if n%13==0\
    \ then\n      n=(n+3)\n    else\n      n=(n+11)\n    end\n  end\n  return n\n\
    end", "  local count=0\n  for i=1,n do\n    if (i%11==0) and (i%13==0) then\n\
    \      count=count+1\n    end\n  end\n  return count\nend", "  return math.floor((n\
    \ % 11) * 13 + math.floor(n % 7)) % 10\nend", "  local count=0\n  for i=1,n do\n\
    \    if i%3==0 or i%5==0 then\n      if i==7 then\n        count=count+1\n   \
    \   else\n        count=count+1\n      end\n    end\n  end\n  return count\nend",
  "    local b = 0\n    while n > 0 do\n        if n >= 11 and n <= 13 then\n    \
    \        n = n - 11\n        else\n            n = n + 1\n        end\n      \
    \  if n % 11 == 1 then\n            n = n / 11\n            b = b + 1\n      \
    \  end\n        if n % 13 == 1 then\n            n = n / 13\n            b = b\
    \ + 1\n        end\n    end\n    return b\nend", "  local count = 0\n  -- Return\
    \ the number of times digit7 appears in integers less than n which are divisible\
    \ by 11 or 13.\n  -- >>> fizz_buzz(50)\n  -- 0\n  -- >>> fizz_buzz(78)\n  -- 2\n\
    \  -- >>> fizz_buzz(79)\n  -- 3\n  for i = 1, n do\n    if i % 13 == 0 and i %\
    \ 11 == 0 then\n      count = count + 1\n    end\n  end\n  return count\nend\n\
    </cell>\n<text>\nGreat, we have defined three functions in our program.", "  local\
    \ i, count = 1, 1\n  while n ~= 0 do\n    local a = n % 11\n    if a == 0 then\
    \ count = count+1 else count = count end\n    local b = n % 13\n    if b == 0\
    \ then count = count+1 else count = count end\n    local c = math.floor(n / 11)\n\
    \    count = (count+11) * (c+13)\n    n = math.floor(n / 13)\n  end\n  return\
    \ count\nend", "\tlocal function fizz_buzz_helper(start)\n\t\tlocal n = start\n\
    \t\twhile n > 0 do\n\t\t\tif n % 11 == 0 and n % 13 == 0 then\n\t\t\t\tn = n /\
    \ 11\n\t\t\t\tlocal i\n\t\t\t\tfor i, v in pairs(vs) do\n\t\t\t\t\tif n / v ==\
    \ v then\n\t\t\t\t\t\treturn i -- return the index of the first matching value\n\
    \t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\treturn nil -- if not found, return nil\n\t\
    \t\telseif n % 11 == 1 then\n\t\t\t\treturn n -- return the index of first 11\n\
    \t\t\telseif n % 13 == 1 then\n\t\t\t\treturn n -- return the index of first 13\n\
    \t\t\telse\n\t\t\t\tn = n / 13\n\t\t\tend\n\t\tend\n\t\treturn nil -- return the\
    \ index of last matching value\n\tend\n\treturn fizz_buzz_helper(n)\nend", " \
    \ if n < 7 then return n end\n  if n == 7 and n % 11 == 0 then return 1 end\n\
    \  if n == 7 and n % 13 == 0 then return 2 end\n  return fizz_buzz(n - 1) + fizz_buzz(n\
    \ - 3)\nend", "  local num_buzz = 0\n  local div_11, div_13, div_rem = divmod(n,\
    \ 11)\n  if div_11 == 0 and div_13 == 0 then\n    return num_buzz\n  elseif div_13\
    \ == 1 then\n    num_buzz = div_13\n  else\n    local div_13, div_rem = divmod(n,\
    \ 13)\n    if div_13 == 1 then\n      num_buzz = div_13\n    else\n      num_buzz\
    \ = div_13 + 1\n    end\n  end\n  return num_buzz\nend", "  if n < 0 then return\
    \ nil end\n  if n < 10 then return n end\n  local count = 0\n  local res = (n\
    \ % 11) + 13\n  while res < n do\n    count = count + 1\n    res = ((res / 11)\
    \ + 13) % n\n  end\n  return count\nend", "\tif n<10 then\n\t\treturn n\n\telseif\
    \ n==10 then\n\t\treturn \"Fizz\"\n\telseif n==11 then\n\t\treturn \"FizzBuzz\"\
    \n\telseif n==13 then\n\t\treturn \"FizzBuzz\"\n\telseif n%11==0 then\n\t\treturn\
    \ \"Buzz\"\n\telseif n%13==0 then\n\t\treturn \"Buzz\"\n\telse\n\t\treturn n\n\
    \tend\nend", "    local num_divisors = #(n:div(11))\n    local num_divisible_dig\
    \ = #(n:mod(11))\n    return num_divisors == 0 and num_divisible_dig == 0 and\n\
    \        (n % 11) == 0 or num_divisible_dig == 2 and\n        (n % 13) == 0 or\
    \ num_divisible_dig == 3\nend\n</cell>\n<text>\nThe :div() and :mod() functions\
    \ can be used to find the divisors and remainders of an integer. The :mod() function\
    \ returns both the remainder of the division and the remainder of the remainder\
    \ of the division. The :div() function returns the quotient and the quotient of\
    \ the remainder. Here is an example of the :div() function:", "  if n <= 0 then\
    \ return 0 end\n  if n % 11 == 1 then return fizz_buzz(n-1) + 1 end\n  if n %\
    \ 13 == 1 then return fizz_buzz(n-1) + 2 end\n  return fizz_buzz(n-1) + 1\nend",
  "    local c = 0\n    while n >= 11 or n >= 13 do\n        if n >= 11 then\n   \
    \         n = math.floor(n/11) * 11\n        else\n            n = math.floor(n/13)\
    \ * 13\n        end\n        c = c + 1 -- This works, but not very efficient as\
    \ we re-calculate it every time\n    end\n    return c\nend", "  local i, j, k,\
    \ count = 1, 0, 0, 0\n  for i = 1, n do\n    if (n % i == 0 and n % 11 == 0) or\
    \ (n % 13 == 0 and n % 11 == 0) then\n      count = count + 1\n      n = n / 10\n\
    \    end\n  end\n  return count\nend", "  return math.mod(math.floor((n-1) / 13)\
    \ + 1, 13) + math.mod(math.floor((n-1) % 13) + 1, 13)\nend", "    local num_count\
    \ = 0\n    for i=0,n-1 do\n        local digit = math.floor(n/10)\n        if\
    \ digit == 7 then num_count = num_count + 1 end\n        if digit == 3 then num_count\
    \ = num_count + 1 end\n        if digit == 5 then num_count = num_count + 1 end\n\
    \        if digit == 9 then num_count = num_count + 1 end\n        if digit ==\
    \ 11 then num_count = num_count + 1 end\n        if digit == 13 then num_count\
    \ = num_count + 1 end\n        n = math.floor(n/10)\n    end\n    return num_count\n\
    end", "  local z = 0\n  repeat\n    if n % 11 == 0 then\n      z = z + 1\n   \
    \ end\n    if n % 13 == 0 then\n      z = z + 3\n    end\n    n = n / 11\n  until\
    \ n < 1\n  return z\nend", "  local count = 0\n  if n == 0 then return 0 end\n\
    \  if n >= 1 and n % 11 == 0 and n % 13 == 0 then\n    return count\n  end\n \
    \ count = count + 1\n  if n >= 2 and n % 11 == 1 then\n    return count\n  end\n\
    \  count = count + 1\n  if n >= 3 and n % 13 == 1 then\n    return count\n  end\n\
    \  return count\nend", "    -- Write your code here.\nend", "    local count =\
    \ 0\n    while n > 0 do\n        if n % 11 == 1 then\n            count = count\
    \ + 1\n        end\n        if n % 13 == 1 then\n            count = count + 1\n\
    \        end\n        n = math.floor(n / 10)\n    end\n    return count\nend",
  "    if n < 10 then\n        if n % 11 == 0 then\n            return n\n       \
    \ elseif n % 13 == 1 then\n            return n\n        else\n            return\
    \ 0\n        end\n    else\n        return n\n    end\nend", "  if n < 10 then\n\
    \    return n\n  end\n  if n%11 == 0 then\n    return fizz_buzz(n/11)\n  elseif\
    \ n%13 == 0 then\n    return fizz_buzz(n/13)\n  else\n    return 1\n  end\nend\n\
    </code>\nThe recursive calls are a little ugly; you could write a helper function\
    \ that took an integer and returned the string that represents that integer, but\
    \ it's not worth the trouble.\n<|/ a tags=numbers,recursion,fizzbuzz |>\n<| c\
    \ |>\nI liked your explanation a lot, but I don't really understand what `n%11\
    \ == 0` means compared to `n%13 == 0`. Could you maybe give an example of the\
    \ output you get and how that differs from what you expected?\n<|/ c |>\n<| c\
    \ |>\nSorry for the lack of explanation. When you divide by 11, you lose the remainder;\
    \ so n/11 gets you back the whole number. Since the remainder is always 0, the\
    \ value of n%11 == 0 is always true and thus fizz_buzz(n/11) calls itself recursively\
    \ for the number n/11, which gets you the rest of the number and fizz_buzz(n/13)\
    \ will do the same.\n<|/ c |>\n<| c |>\n`% 11` is more accurately `% 100` as 11\
    \ is divisible by 11 but by 13 it is not. `11 % 100` is 11, `13 % 100` is 13.\n\
    <|/ c |>\n<| c |>\n: In fact, it should be `% 10` so that it works for any number\
    \ divisible by 10. But you're right, I should've used `% 100` instead. I'll fix\
    \ that in my answer.\n<|/ c |>\n<| c |>\nOkay, that makes sense. I'm confused\
    \ as to why it works that way. I tried it with 100 and it didn't work the same.\
    \ Do you know why it would output 11 for both `% 10` and `% 100`? Because you\
    \ say \"So n%11 is always 0...\"\n<|/ c |>\n<| a |>\nHere is a simple implementation\
    \ with tail recursion which I think might be the fastest one\n<code>\nfizzBuzz\
    \ = function (n)\n    local function fizzBuzz(n, isFizzBuzz)\n        if n >=\
    \ 100 then\n            return n\n        end\n        if n % 10 == 1 then\n \
    \           if isFizzBuzz then\n                return n .. ' FizzBuzz'\n    \
    \        else\n                return n .. ' Fizz'\n            end", "  if n\
    \ > 1000 then\n    return \"Too big\"\n  end\n  if n <= 0 then\n    return \"\
    Not positive\"\n  end\n  if n <= 100 then\n    return \"0 - 99\"\n  end\n  local\
    \ div11, div13, div23, div23, div33 = 0, 0, 0, 0, 0\n  while n > 0 do\n    local\
    \ i = math.floor(n / 11) * 11\n    local j = math.floor(n / 13) * 13\n    local\
    \ k = math.floor(n / 23) * 23\n    local l = math.floor(n / 33) * 33\n    if j\
    \ == 0 then\n      if i < 10 then\n        div11 = i + 1\n      else\n       \
    \ div11 = i + 1\n        div13 = n - 11 * i + j\n      end\n    else\n      if\
    \ i < 10 then\n        div11 = i + 1\n      else\n        div11 = i + 1\n    \
    \    div13 = n - 11 * i + j\n      end\n    end\n    if k == 0 then\n      if\
    \ j < 10 then\n        div23 = j + 1\n      else\n        div23 = j + 1\n    \
    \    div23 = n - 23 * j + k\n      end\n    else\n      if j < 10 then\n     \
    \   div23 = j + 1\n      else\n        div23 = j + 1\n        div23 = n - 23 *\
    \ j + k\n      end\n    end\n    if l == 0 then\n      if k < 10 then\n      \
    \  div33 = k + 1\n      else\n        div33 = k + 1\n        div33 = n - 33 *\
    \ k + l\n      end\n    else\n      if k < 10 then\n        div33 = k + 1\n  \
    \    else\n        div33 = k + 1\n        div33 = n - 33 * k + l\n      end\n\
    \    end\n    n = n - k - l - j - i - 10 * i\n  end\n  return div11, div13, div23,\
    \ div33\nend", "  local result\n  for i = 1, n do\n    if i mod 11 == 0 and i\
    \ mod 13 == 0 then\n      result = result + 1\n    end\n  end\n  return result\n\
    end", "    local count = 0\n    local result = nil\n    if n < 11 then\n     \
    \   result = count\n    elseif n < 13 then\n        result = count\n    elseif\
    \ n < 17 then\n        result = count + 1\n    elseif n < 19 then\n        result\
    \ = count + 1\n    elseif n < 21 then\n        result = count + 1\n    elseif\
    \ n < 23 then\n        result = count + 1\n    elseif n < 25 then\n        result\
    \ = count + 1\n    elseif n < 27 then\n        result = count + 1\n    elseif\
    \ n < 29 then\n        result = count + 1\n    elseif n < 31 then\n        result\
    \ = count + 1\n    else\n        result = count + 1\n    end\n    return result\n\
    end", "  if n < 3 then\n    return n\n  end\n  if n % 11 == 1 then\n    return\
    \ fizz_buzz(n-1) + 3\n  end\n  if n % 13 == 1 then\n    return fizz_buzz(n-1)\
    \ + 5\n  end\n  return fizz_buzz(n-1)\nend\n</cell>\n<cell>", "    if n < 0 then\
    \ return nil end\n    local count = 1\n    while n > 0 do\n        local m = math.floor(n\
    \ / 11)\n        if m % 11 == 0 then\n            count = count + 1\n        end\n\
    \        n = math.floor((n - m * 11) / 13)\n        if n % 13 == 0 then\n    \
    \        count = count + 1\n        end\n        n = math.floor((n - m * 13) /\
    \ 11)\n        if n % 11 == 0 then\n            count = count + 1\n        end\n\
    \        n = math.floor((n - m * 11) / 13)\n        if n % 13 == 0 then\n    \
    \        count = count + 1\n        end\n        n = math.floor((n - m * 13) /\
    \ 11)\n        if n % 11 == 0 then\n            count = count + 1\n        end\n\
    \    end\n    return count\nend", "  if n == 0 then\n    return 0\n  end\n  if\
    \ n <= 0 then\n    return 0\n  end\n  if n % 11 == 1 then\n    return fizz_buzz(n\
    \ - 1) + 1\n  end\n  if n % 13 == 1 then\n    return fizz_buzz(n - 1) + 3\n  end\n\
    \  return fizz_buzz(n - 1)\nend", "  return ( math.floor(n/11) == 0 and math.floor(n/13)\
    \ == 0 and (n%11) == 0 and  (n%13) == 0) ? 0 :\n\t ( ( math.floor(n/11) == 0 and\
    \ math.floor(n/13) == 0 and (n%11) != 0 and (n%13) == 0) ?\n\t\t(n%11) : 0 ) +\n\
    \t ( (math.floor(n/11) == 0 and math.floor(n/13) != 0 and (n%11) == 0 and (n%13)\
    \ != 0) ?\n\t\t(n%13) : 0 ) +\n\t (math.floor(n/11) != 0 and math.floor(n/13)\
    \ == 0 and (n%11) != 0 and (n%13) != 0 ?\n\t\t(n%11) : 0 ) +\n\t (math.floor(n/11)\
    \ != 0 and math.floor(n/13) != 0 and (n%11) == 0 and (n%13) == 0 ?\n\t\t(n%13)\
    \ : 0 );\nend", "  if n < 0 then\n    n = 0\n  elseif n < 10 then\n    -- Return\
    \ the number of times the digit 7 appears in integers less than n which are divisible\
    \ by 11 or 13.\n    return math.floor(n/11) * 11 + math.floor(n/13) * 13\n  else\n\
    \    -- Return the number of times the digit 7 appears in integers less than n\
    \ which are divisible by 11 or 13.\n    return math.floor(n/11) * 11 + math.floor(n/13)\
    \ * 13\n    -- Return the number of times the digit 7 appears in integers less\
    \ than n which are divisible by 11 or 13.\n    -- Return the number of times the\
    \ digit 7 appears in integers less than n which are divisible by 11 or 13.\n \
    \   -- Return the number of times the digit 7 appears in integers less than n\
    \ which are divisible by 11 or 13.\n    -- Return the number of times the digit\
    \ 7 appears in integers less than n which are divisible by 11 or 13.\n    -- Return\
    \ the number of times the digit 7 appears in integers less than n which are divisible\
    \ by 11 or 13.\n    -- Return the number of times the digit 7 appears in integers\
    \ less than n which are divisible by 11 or 13.\n    -- Return the number of times\
    \ the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\
    \    -- Return the number of times the digit 7 appears in integers less than n\
    \ which are divisible by 11 or 13.\n    -- Return the number of times the digit\
    \ 7 appears in integers less than n which are divisible by 11 or 13.\n    -- Return\
    \ the number of times the digit 7 appears in integers less than n which are divisible\
    \ by 11 or 13.\n    -- Return the number of times the digit 7 appears in integers\
    \ less than n which are divisible by 11 or 13.\n    -- Return the number of times\
    \ the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\
    \    -- Return the number of times the digit 7 appears in integers less than n\
    \ which are divisible by 11 or 13.\n    -- Return the number of times the digit\
    \ 7 appears in integers less than n which are divisible by 11 or 13.\n    -- Return\
    \ the number of times the digit 7 appears in integers less than n which are divisible\
    \ by 11 or 13.\n    -- Return the number of times the digit 7 appears in integers\
    \ less than n which are divisible by 11 or 13.\n    -- Return the number of times\
    \ the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\
    \    -- Return the number of times the digit 7 appears in integers less than n\
    \ which are divisible by 11 or 13.\n    -- Return the number of times the digit\
    \ 7 appears in integers less than n which are divisible by 11 or 13.\n    -- Return\
    \ the number of times the digit 7 appears in integers less than n which are divisible\
    \ by 11 or ", "   if n < 10 then\n      return n\n   end\n   if n % 11 == 0 and\
    \ n % 13 == 0 then\n      return 0\n   else\n      return fizz_buzz(math.floor(n/11))\
    \ .. math.floor(n/13)\n   end\nend", "  if n < 11 then\n    return 0\n  elseif\
    \ n == 11 or n == 13 then\n    return 1\n  elseif n >= 14 and n % 11 == 0 then\n\
    \    return 2\n  elseif n >= 14 and n % 13 == 0 then\n    return 3\n  else\n \
    \   return 0\n  end\nend", "  -- First we find the largest multiple of 3 or 5\
    \ that is less than n.\n  local multiple = 3\n  if n > 27 then multiple = 5 end\n\
    \  -- Next, we divide n by that multiple.\n  -- Note that this has the effect\
    \ of rounding down which gives us an integer\n  -- less than the original number,\
    \ which is what we want.\n  local divisor = n\n  while divisor % multiple == 0\
    \ do\n    divisor = divisor / multiple\n  end\n  -- Now that we have the largest\
    \ multiple of 3 or 5 less than n, we go through\n  -- all the multiples of 3 and\
    \ 5 until we get to the multiple of 7 that is\n  -- less than n. This gives us\
    \ all the numbers divisible by 3 or 5 but not\n  -- by 7.\n  for x = multiple,\
    \ multiple*3, multiple*5 do\n    while n % x == 0 do\n      n = n / x\n      --\
    \ print(\"x: \" .. x .. \" n is \" .. n .. \" multiple: \" .. multiple)\n    end\n\
    \  end\n  -- Now we divide n by 7 and find how many multiples of 7 there are.\n\
    \  local count = 0\n  while n % 7 == 0 do\n    n = n / 7\n    -- print(\"x: \"\
    \ .. x .. \" n is \" .. n .. \" multiple: \" .. multiple)\n    count = count +\
    \ 1\n  end\n  return count\nend", "    if n < 0 then return end\n    if n < 10\
    \ then return n end\n    if n % 11 == 0 then return n end\n    if n % 13 == 0\
    \ then return n end\n    local count = 0\n    while true do\n        if n >= 100\
    \ then break\n        count = count + 1\n        n = n / 10\n    end\n    if count\
    \ > 0 then return count end\nend", "    local numbers = ipairs(string.gmatch(n,\
    \ '%d+'))\n    local count = 0\n    for i, d in pairs(numbers) do\n        if\
    \ i % 11 == 0 and i % 13 == 0 then\n            count = count + 1\n        else\n\
    \            count = count\n        end\n    end\n    return count\nend", "  local\
    \ count = 1\n  while n > 0 and n % 11 == 0 do\n    count = count + 1\n    n /=\
    \ 11\n  end\n  -- If the number is divisible by 13, then n is divisible by 11.\n\
    \  -- Otherwise, n is divisible by 11.\n  if n > 0 and n % 13 == 0 then\n    count\
    \ = count + 1\n  end\n  return count\nend", "  return math.floor((n / 11) * 7)\
    \ + math.floor((n / 13) * 3)\nend\nreturn fizz_buzz\nend\nreturn _G.fizz_buzz_func\
    \ = _G.fizz_buzz_func or fizz_buzz_func", "  n = n and tonumber(n)\n  if n then\n\
    \    local fs = ''\n    local m\n    for m = 2, n do\n      if n % m == 0 and\
    \ n ~= m and n ~= m - 1 then\n        fs = fs .. '#'\n      end\n    end\n   \
    \ if #fs then\n      return table.concat(unpack(unpack(fs:gsub('([7][7][7])',\
    \ '\\1'):gsub('([7][7][7]\\1)', '\\2'):gsub('([7][7][7][7])', '\\3')\n       \
    \ :gsub('([7][7][7][7][7])', '\\4'):gsub('([7][7][7][7][7][7])', '\\5'):gsub('([7][7][7][7][7][7][7])',\
    \ '\\6'):gsub('([7][7][7][7][7][7][7][7])', '\\7')))\n    end\n  end\n  return\
    \ n\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI didn't even consider this one.\
    \ Thanks for sharing!\n<|/ c |>\n<| c |>\nThis is the one that actually works,\
    \ and it works well and efficiently. Thanks ! I needed something like this.\n\
    <|/ c |>\n<| a |>\nHere's a function that uses Lua pattern matching (similar to\
    \ Perl's =~ operator) to extract numbers from a string and replace them with their\
    \ FizzBuzz equivalent:\n<code>", "  if n == 0 then return 0 end\n  if n < 10 then\
    \ return n end\n  if n % 11 == 0 and n % 13 == 0 then return 2 end\n  if n % 13\
    \ == 0 and n % 11 == 0 then return 3 end\n  if n % 11 == 0 then return 4 end\n\
    \  if n % 13 == 0 then return 5 end\n  return n\nend", "  if n < 1 then return\
    \ nil end\n  if n % 11 == 0 or n % 13 == 0 then\n    return n % 11 + n - 1\n \
    \ else\n    return 0\n  end\nend", "  return math.floor(n/10) or math.ceil(n /\
    \ 13) or 0\nend", "    -- FizzBuzz -- If n is divisible by 3, then print Fizz.\
    \ Otherwise, print Buzz.\n    if n % 3 == 0 then\n        return n\n    elseif\
    \ n % 5 == 0 then\n        return n\n    elseif n % 7 == 0 then\n        return\
    \ n\n    else\n        return fizz_buzz(n / 3) * 3\n    end\nend", "  local count=0\n\
    \  local mult=1\n  while n >= 11 do\n    mult=mult*11\n    n=n/mult\n    count=count+1\n\
    \  end\n  while n >= 13 do\n    mult=mult*13\n    n=n/mult\n    count=count+1\n\
    \  end\n  return count\nend", "  local t = 0\n  while n >= 11 do\n    n = n /\
    \ 11\n    t = t + 1\n  end\n  while n >= 13 do\n    n = n / 13\n    t = t + 1\n\
    \  end\n  return t\nend", "  local count = 0\n  local mod10 = 0\n  -- Only count\
    \ divisible by 11 or 13 numbers\n  for _ = 1, n do -- Only count numbers < n\n\
    \    mod10 = ((n % 10) + 9) % 10\n    if mod10 == 0 or mod10 == 11 then -- If\
    \ the last digit is 0 or 11, then we haven't checked all of the numbers for 7,\
    \ 8 and 9.\n      count = count + 1 -- Increment the number of times 7 appears\
    \ in integers less than n which are divisible by 11 or 13.\n      if mod10 ==\
    \ 0 then -- If all the numbers are divisible by 11, then we also only want to\
    \ count the numbers which have 8 and 9 appearing.\n        mod10 = ((n % 10) +\
    \ 9) % 10\n        if mod10 == 9 or mod10 == 11 then -- If the last digit is 9\
    \ or 11, then we haven't checked all of the numbers for 7, 8 and 9.\n        \
    \  count = count + 1\n        end\n      end\n    end\n  end\n  return count\n\
    end", "  if n < 10 then\n    return n\n  elseif n < 50 then\n    if n % 11 ==\
    \ 0 or n % 13 == 0 then\n      return n\n    else\n      return 0\n    end\n \
    \ elseif n < 100 then\n    if n % 11 == 1 or (n % 11 == 0 and n % 13 == 0) then\n\
    \      if n % 11 == 0 then\n        return n\n      else\n        return n + 1\n\
    \      end\n    else\n      return 0\n    end\n  elseif n < 1000 then\n    if\
    \ n % 11 == 1 or (n % 11 == 0 and n % 13 == 1) then\n      if n % 11 == 1 then\n\
    \        return n + 1\n      else\n        return n\n      end\n    else\n   \
    \   return 0\n    end\n  else\n    return 0\n  end\nend", "  local counter = 0\n\
    \  for i=1,n do\n    local mod = n % 10\n    if mod == 11 or mod == 13 then\n\
    \      counter = counter + 1\n    end\n    n = math.floor(n/10)\n  end\n  return\
    \ counter\nend", "  -- Count the number of \"11\" and \"13\" divisible by \"7\"\
    .\n  local count = 0\n  for i = 1, n do count = count + (n % 11 == 0 or n % 13\
    \ == 0) end\n  -- Return the number of times the digit 7 appears in integers less\
    \ than n which are divisible by 11 or 13.\n  return count\nend", "    -- Return\
    \ the number of times the digit 7 appears in integers less than n which are divisible\
    \ by 11 or 13.\n    if n == 0 then\n        return 0\n    end", "  return math.min(\n\
    \    math.max(n % 11 or 13, 1),\n    math.max(n % 13 or 11, 1)\n  ) or 0\nend",
  "  local count = 0\n  while n >= 10 or n % 11 == 0 and n % 13 == 0 do\n    count\
    \ = count + 1\n    local k = math.floor(n/10)\n    n = k * 10\n  end\n  return\
    \ count\nend", "  local numbers = n:byte():gsub(\"%d\", \"%0d\"):gsub(\"\\n\"\
    , \"\"):gsub(\"^%d+\", \"%d\"):gsub(\"%%d$\", \"\"):gsub(\"%d*$\", \"\")\n  return\
    \ table.concat(numbers, \"\")\nend", "  local count = 0\n  while n >= 11 do\n\
    \    count = count + n % 11\n    local remain = n % 10\n    n =(n-remain)/10\n\
    \  end \n  return count\nend", "  local i\n  local count = 0\n  \n  -- Iterate\
    \ through all numbers from n and divisible by 11 or 13 until an appropriate result\
    \ is achieved.\n  for i = 1,n do\n    -- If the number mod 11 is zero and the\
    \ number mod 13 is zero then we've reached the desired result.\n    if i % 11\
    \ == 0 and i % 13 == 0 then\n      count = count + 1\n    end\n  end\n  \n  return\
    \ count\nend", "    if n < 1 then return nil end\n    if n < 10 then return n\
    \ end\n    local result = 1\n    for i = 10, n do\n        if n % i == 0 or n\
    \ % (i + 9) then\n            result = result + 1\n        end\n    end\n    return\
    \ result\nend", "    local buzz_count = 0\n    if n <= 0 then\n        return\
    \ 0\n    end\n    if n%11==0 and n%13==0 then\n        buzz_count = 1\n    elseif\
    \ n%11==0 then\n        buzz_count = n%11\n    elseif n%13==0 then\n        buzz_count\
    \ = n%13\n    else\n        buzz_count = 11\n    end\n    return buzz_count\n\
    end", "\tlocal count = 0\n\twhile n >= 11 do\n\t\tcount = count + 1\n\t\tn = math.floor(n\
    \ / 11)\n\tend\n\twhile n > 13 do\n\t\tcount = count + 1\n\t\tn = math.floor(n\
    \ / 13)\n\tend\n\treturn count\nend", "  if n == 0 then return 0 end\n  if n %\
    \ 11 == 0 or n % 13 == 0 then return fizz_buzz(n / 10) + 1 end\n  return fizz_buzz(n\
    \ / 10)\nend", "    if n < 13 then return 0 end\n    if n % 11 == 0 then return\
    \ 1 end\n    if n % 13 == 0 then return 2 end\n    return fizz_buzz(n - 13)\n\
    end\n</cell>\n<text>\nExercise\nNow that we've seen how to use recursive functions\
    \ to do some simple computations, let's practice a little more complex computations.",
  "  if n <= 0 then\n    return 0\n  end", "    if n % 11 == 0 and n % 13 == 0 then\n\
    \        return math.floor(n/11)+1\n    elseif n % 11 == 1 then\n        return\
    \ math.floor(n/11)+1\n    elseif n % 13 == 1 then\n        return math.floor(n/13)+1\n\
    \    else\n        return n\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nThis answer\
    \ is really great. It helped me to write my own solution for calculating fizzbuzz\
    \ and I like that it works with negative numbers too. Thank you very much.\n<|/\
    \ c |>\n<| c |>\nYour answer works perfectly in Lua 5.3.  I used a slight modification\
    \ to get it to work in 5.2.  See my answer.\n<|/ c |>\n<| c |>\nThe other answer\
    \ works perfectly in Lua 5.3. What is the `math.floor()` for? The code seems to\
    \ work for positive integers. My interpretation is that `math.floor()` is to remove\
    \ the `FizzBuzz` strings from the output and `+` to add them back.\n<|/ c |>\n\
    <| c |>\nNo, the other answer works in 5.2. `math.floor()` converts integer to\
    \ float, so that it can be compared with the number 0.\n<|/ c |>\n<| c |>\nI see.\
    \ I've tested it in Lua 5.3 with `print(math.floor(3.5))` and it did not work.\
    \ I'm using 5.2.\n<|/ c |>\n<| a tags=lua-table,lua dscore=2 |>\nHere is my simple\
    \ solution\n<code>", "  return n%11 + n%13\nend", "    local counter = math.floor(n/11)\n\
    \    if counter == 0 then\n        counter = 1\n    end\n    local counter1 =\
    \ math.floor(n/13)\n    if counter1 == 0 then\n        counter1 = 1\n    end\n\
    \    return (counter - counter1 + 1) * 3\nend", "  local n0 = n % 10\n  local\
    \ n1 = n % 100\n  local n2 = n % 1000\n  local n3 = n % 10000\n  local n4 = n\
    \ % 100000\n  local n5 = n % 1000000\n  local n6 = n % 10000000\n  local n7 =\
    \ n % 100000000", "  return math.floor((n % 11) + math.floor((n % 13) / 3.0))\n\
    end", "  return math.ceil(math.sqrt(n)) * math.ceil(n / math.sqrt(n))\nend", " \
    \ local result = 1\n  -- Return the number of times the digit 7 appears in integers\
    \ less than n which are divisible by 11 or 13.\n  for i = 2, math.floor(n/11)\
    \ do\n    -- If the remainder of dividing n by 11 is greater than or equal to\
    \ zero.\n    if n % 11 > 0 then\n      -- Return the number of times the digit\
    \ 7 appears in integers less than n which are divisible by 11 and less than or\
    \ equal to 13.\n      if n % 13 == 0 then\n        result = result + 1\n     \
    \ end\n    end\n  end\n  return result\nend", "  if n > 100 then\n    return n\n\
    \  elseif n <= 0 then\n    return 0\n  else\n    local divs = math.floor(n/10)\n\
    \    local remainder = n % 10", "\tlocal count = 0\n\tfor i = 1, n do\n\t\tif\
    \ n % 10 == 7 then count = count + 1 end\n\t\tif n % 11 == 0 then count = count\
    \ + 1 end\n\t\tif n % 13 == 0 then count = count + 1 end\n\tend\n\treturn count\n\
    end", "  if n < 1 then return nil end\n  if n % 11 == 1 then return 1 end\n  if\
    \ n % 13 == 1 then return 2 end\n  return fizz_buzz(n / 11) + fizz_buzz(n / 13)\n\
    end", "  if n > 0 and n % 11 == 1 then return end\n  if n > 0 and n % 13 == 1\
    \ then return end\n  if n % 7 == 0 then\n    if n % 11 == 1 then return end\n\
    \    if n % 13 == 1 then return end\n  end\n  return n\nend", "  if n < 10 then\n\
    \    return n\n  elseif n % 11 == 0 then\n    return fizz_buzz(n / 11) + 1\n \
    \ elseif n % 13 == 0 then\n    return fizz_buzz(n / 13) + 1\n  else\n    return\
    \ 0\n  end\nend", "  if n > 1 and n % 11 ~= 0 and n % 13 ~= 0 then\n    return\
    \ 1 + fizz_buzz(n / 10)\n  else\n    return 0\n  end\nend", "  if n % 11 == 0\
    \ and n % 13 == 0 then\n    return 1\n  elseif n % 11 == 0 then\n    return 2\n\
    \  elseif n % 13 == 0 then\n    return 3\n  else\n    return 0\n  end\nend", " \
    \ local nd = math.floor(n)\n  if nd % 11 == 1 then return nd end -- Happy Fizz\n\
    \  if nd % 13 == 1 then return nd end    -- Happy Buzz\n  if nd % 11 == 0 then\
    \ return nd end    -- Fizz Buzz\n  return nd\nend", "  return \n    n % 11 ==\
    \ 0 and \n      n % 13 == 0 or \n      n % 7 == 0 and \n      n % 15 == 0\n  and\
    \ 1 or 0\nend", "  if n <= 0 then\n    return 0\n  elseif n % 11 == 0 then\n \
    \   return 1\n  elseif n % 13 == 0 then\n    return 2\n  else\n    return fizz_buzz(n\
    \ - 1)\n  end\nend", "  local count=0\n  while n > 0 do\n    local m = math.floor(n/11)\n\
    \    if n % 11 == 0 then\n      count = count + 1\n      n = m\n    end\n    local\
    \ n = math.floor(n/13)\n    if n % 13 == 0 then\n      count = count + 1\n   \
    \   n = m\n    end\n  end\n  return count\nend", "  return math.min(math.floor(n\
    \ / 11), math.floor(n / 13)) * (n % 11) * 11\nend", "  local i = 0\n  while i\
    \ <= n do\n    -- The integer i is divisible by 11 or 13 times by the integer\
    \ n.\n    if (i % 11 == 0 and i % 13 == 0) or (i % 11 == 0 and i % 13 != 0) or\
    \ (i % 13 == 0 and i % 11 != 0) then\n      -- If i is divisible by 11 or 13 times\
    \ by the integer n, print i as if it was a fizz buzz number.\n      print(i)\n\
    \    else\n      -- Otherwise, print i as if it was a number.\n      print(i)\n\
    \    end\n    -- Add 1 to the integer i.\n    i = i + 1\n  end\nend", "  if n\
    \ < 10 then\n    return 0\n  end", "  local counter = 12\n  local i = 1\n  while\
    \ i <= n do\n    local p = math.mod(i, 12)\n    if p == 7 or p == 11 then\n  \
    \    counter = counter + 1\n    end\n    i = i + 1\n  end\n  return counter\n\
    end", "  return math.floor(math.sqrt(n) / 11)\nend", "  local count = 0\n  --\
    \ Find the smallest and largest integers greater than n.\n  local lower = math.min(math.floor(n/10),\
    \ math.ceil(n/10))\n  local upper = math.min(math.ceil(n/10), math.floor(n/10))\n\
    \  -- Loop through numbers from low to high.\n  for i = lower, upper do\n    --\
    \ If we divide by 11, or by 13, and get back to n, we found a divisor.\n    if\
    \ i % 11 == 0 or i % 13 == 0 and n ~= i then\n      count = count + 1\n    end\n\
    \  end\n  return count\nend", "    if n > 0 then\n        return fizz_buzz(math.floor(n/11)\
    \ + math.floor(n/13)) or n\n    end\nend", "  n = tonumber(n)\n  if n < 1 then\
    \ return nil end\n  local divmod3 = math.modf(n/3)\n  if divmod3 ~= 0 then\n \
    \   if divmod3 ~= 1 then return nil end\n    if n%13 == 0 then\n      local divmod11\
    \ = math.modf(n/11)\n      if divmod11 ~= 0 then\n        if divmod11 ~= 1 then\
    \ return nil end\n        if n%11 == 0 then return 1 end\n      end\n    end\n\
    \  end\n  return nil\nend\nreturn fizz_buzz\nend", "  local result = 0\n  for\
    \ i = 1, n do\n    local remainder = n % 11 or 13\n    if remainder == 7 then\n\
    \      result = result + 1\n    end\n    n = math.floor(n/10)\n  end\n  return\
    \ result\nend", "\t-- We test if n is a multiple of 11, since fizz buzz numbers\
    \ have three digits.\n\t-- If n is multiple of 11, we do nothing. If n is not\
    \ multiple of 11, we test for divisible by 7\n\t-- If n is not divisible by 7,\
    \ we test for divisible by 13\n\t-- If n is not divisible by 13, we return 0,\
    \ since fizz buzz numbers have three digits.\n\t-- We could also test for divisible\
    \ by 15 since fizz buzz numbers have three digits and are divisible by 15.\n\t\
    return (n % 11) == 0 or\n\t(n % 7) == 0 or\n\t(n % 13) == 0 or\n\t(n % 15) ==\
    \ 0\nend", "  if n % 11 == 0 and n % 13 == 0 then\n    return 0\n  end\n  local\
    \ sum = 0\n  while n > 0 do\n    sum = sum + math.floor(n/10)\n    n = math.mod(n,\
    \ 10)\n  end\n  return sum\nend", "  local digits = string.split(tostring(n))\n\
    \  return #digits > 0 and #digits % 11 == 0 or #digits > 0 and #digits % 13 ==\
    \ 0\nend\nprint(fizz_buzz(50))\nprint(fizz_buzz(78))\nprint(fizz_buzz(79))\nprint(fizz_buzz(\"\
    79\"))", "  local count = 0\n  local n = math.abs(n)\n  if n <= 20 then\n    if\
    \ n % 2 == 0 and n % 11 == 0 and n % 13 == 0 then\n      count = count + 1\n \
    \   end\n  elseif n <= 100 then\n    if n % 2 == 0 and n % 3 == 0 and n % 7 ==\
    \ 0 then\n      count = count + 1\n    end\n  elseif n <= 1000 then\n    if n\
    \ % 2 == 0 and n % 3 == 0 and n % 5 == 0 then\n      count = count + 1\n    end\n\
    \  elseif n <= 10000 then\n    if n % 2 == 0 and n % 3 == 0 and n % 7 == 0 then\n\
    \      count = count + 1\n    end\n  elseif n <= 100000 then\n    if n % 2 ==\
    \ 0 and n % 5 == 0 and n % 7 == 0 then\n      count = count + 1\n    end\n  elseif\
    \ n <= 1000000 then\n    if n % 2 == 0 and n % 3 == 0 and n % 5 == 0 then\n  \
    \    count = count + 1\n    end\n  elseif n <= 10000000 then\n    if n % 2 ==\
    \ 0 and n % 5 == 0 and n % 7 == 0 then\n      count = count + 1\n    end\n  elseif\
    \ n <= 100000000 then\n    if n % 2 == 0 and n % 7 == 0 and n % 5 == 0 then\n\
    \      count = count + 1\n    end\n  elseif n <= 1000000000 then\n    if n % 2\
    \ == 0 and n % 7 == 0 and n % 3 == 0 then\n      count = count + 1\n    end\n\
    \  else\n    if n % 2 == 0 and n % 7 == 0 and n % 3 == 0 then\n      count = count\
    \ + 1\n    end\n  end\n  return count\nend", "  local count = 0\n  local is_multiple",
  "    if n < 0 then return nil end\n    local counter = { }\n    -- Check for divisibility\
    \ by 11 or 13\n    if n % 11 == 0 then\n        counter.divisible_by_11 = 1\n\
    \    elseif n % 13 == 0 then\n        counter.divisible_by_13 = 1\n    else\n\
    \        -- Check for divisibility by 11 and 13\n        if n % 11 == 0 then\n\
    \            counter.divisible_by_11 = 1\n        elseif n % 13 == 0 then\n  \
    \          counter.divisible_by_13 = 1\n        elseif n % 11 == 1 then\n    \
    \        counter.divisible_by_11_but_not_divisible_by_13 = 1\n        elseif n\
    \ % 13 == 1 then\n            counter.divisible_by_13_but_not_divisible_by_11\
    \ = 1\n        else\n            -- Otherwise, return the count\n            counter.count\
    \ = 1\n        end\n    end\n    -- Return the number of times the digit 7 appears\
    \ in integers less than n which are divisible by 11 or 13.\n    return counter.count\
    \ + counter.divisible_by_11 + counter.divisible_by_13 + counter.divisible_by_11_but_not_divisible_by_13\
    \ + counter.divisible_by_13_but_not_divisible_by_11\nend", "  if n < 10 then\n\
    \    return n\n  elseif n < 100 then\n    return fizz_buzz(n % 10 * 3 + 7) + fizz_buzz(n\
    \ % 10)\n  elseif n < 1000 then\n    return fizz_buzz(n % 100 * 3 + 7) + fizz_buzz(n\
    \ % 100) + fizz_buzz(n % 10)\n  elseif n < 10000 then\n    return fizz_buzz(n\
    \ % 1000 * 3 + 7) + fizz_buzz(n % 1000) + fizz_buzz(n % 100) + fizz_buzz(n % 10)\n\
    \  elseif n < 100000 then\n    return fizz_buzz(n % 100000 * 3 + 7) + fizz_buzz(n\
    \ % 100000) + fizz_buzz(n % 1000) + fizz_buzz(n % 100) + fizz_buzz(n % 10)\n \
    \ else\n    return fizz_buzz(n % 1000000 * 3 + 7) + fizz_buzz(n % 1000000) + fizz_buzz(n\
    \ % 100000) + fizz_buzz(n % 1000) + fizz_buzz(n % 100) + fizz_buzz(n % 10)\n \
    \ end\nend", "  if n >= 0 and n % 11 == 0 then return n end\n  if n >= 0 and n\
    \ % 13 == 0 then return n end\n  return 1\nend", "  if n % 11 == 1 then return\
    \ 0 end\n  if n % 13 == 1 then return 0 end\n  if n%11 == 0 and n%13 == 0 then\
    \ return 2 end\n  if n%11 == 0 and n%13 == 1 then return 3 end\n  if n%11 == 1\
    \ and n%13 == 0 then return 1 end\n  return nil\nend", "  local count = 1 -- Initialize\
    \ to 1\n  local i = 0 -- Initialize to 0\n  while i < n do\n    -- If the integer\
    \ is divisible by 11 or 13, add one to the count.\n    if i % 11 == 0 or i % 13\
    \ == 0 then\n      count = count + 1\n    end\n    -- Increment the counter.\n\
    \    i = i + 1\n  end\n  return count\nend", "    local n = math.floor(n)\n  \
    \  local count = 1\n    if n % 11 == 0 then count = count + 1 end\n    if n %\
    \ 13 == 0 then count = count + 1 end\n    return count\nend", "\tn = n or 0\n\t\
    local count = 0\n\tfor i = 1, n do\n\t\tif ((n % 11) == 0 or (n % 13) == 0) then\n\
    \t\t\tcount = count + 1\n\t\tend\n\t\tn = math.modf(n/11)*11 + math.modf(n/13)*13\n\
    \tend\n\treturn count\nend", "    if n < 10 then return n end\n    if n % 11 ==\
    \ 0 then return n end\n    if n % 13 == 0 then return n end\n    return fizz_buzz(n\
    \ / 10) + 1\nend", "  if n <= 0 then\n    return 0\n  else\n    if n % 11 == 1\
    \ then\n      return 1 + fizz_buzz(n/11)\n    elseif n % 13 == 1 then\n      return\
    \ 1 + fizz_buzz(n/13)\n    else\n      return fizz_buzz(n-1)\n    end\n  end\n\
    end", "  -- Convert n to string\n  n = tonumber(string.format(\"%g\", n))\n  --\
    \ If the number is divisible by 11, return \"FizzBuzz\"\n  if n % 11 == 0 then\n\
    \    return \"FizzBuzz\"\n  -- If the number is divisible by 13, return \"Buzz\"\
    \n  elseif n % 13 == 0 then\n    return \"Buzz\"\n  -- If it's divisible by 7,\
    \ return \"Fizz\"\n  elseif n % 7 == 0 then\n    return \"Fizz\"\n  -- Otherwise,\
    \ return n\n  else\n    return n\n  end\nend\n</code>\n<|/ a dscore=3 |>\n<| a\
    \ tags=lua-table,lua dscore=3 |>\nThis solution will also work for numbers such\
    \ as 4.5 or 5.5\n<code>", "  if n%11 == 0 and n%13 == 0 then\n    return n\n \
    \ elseif n%11 == 0 then\n    return n+13\n  elseif n%13 == 0 then\n    return\
    \ n+11\n  else\n    return nil\n  end\nend", "    local count = 0\n    for i=1,n\
    \ do\n        if i %% 11 == 1 then\n            count = count + 1\n        elseif\
    \ i %% 13 == 1 then\n            count = count + 2\n        else\n           \
    \ count = count + 1\n        end\n    end\n    return count\nend", "  if n < 0\
    \ then\n    return 0\n  end", "  local fizz_buzz_count = 1\n  local i = 1\n  while\
    \ i <= n do\n    if i ~= n and i % 11 == 0 then\n      fizz_buzz_count = fizz_buzz_count\
    \ + 1\n    end\n    if i ~= n and i % 13 == 0 then\n      fizz_buzz_count = fizz_buzz_count\
    \ + 1\n    end\n    i = i + 1\n  end\n  return fizz_buzz_count\nend", "  if n\
    \ % 11 == 0 and n % 13 == 0 then\n    return 0\n  elseif n % 11 == 1 then\n  \
    \  return 1\n  elseif n % 13 == 1 then\n    return 2\n  end\nend", "    local\
    \ n = 0\n    for i = 1, n do\n        if i % 11 == 0 and i % 13 == 0 then\n  \
    \          n = n + 1\n        end\n    end\n    return n\nend", "  -- Return the\
    \ number of times the digit 7 appears in integers less than n which are divisible\
    \ by 11 or 13.\n  return math.floor(math.log10(n))\nend", "  local count = 0\n\
    \  if n >= 0 and n <= 19 then\n    count = math.ceil(math.log(n, 10))\n  end\n\
    \  if n >= 20 and n <= 99 then\n    count = count + 1\n  end\n  if n >= 100 and\
    \ n <= 191 then\n    count = count + 1\n  end\n  if n >= 200 and n <= 999 then\n\
    \    count = count + 1\n  end\n  if n >= 1000 and n <= 1919 then\n    count =\
    \ count + 1\n  end\n  return count\nend", "  -- The function returns zero for\
    \ n = 0 or negative numbers.\n  return n < 0 and 0 or n % 11 == 0 and 0 or n %\
    \ 13 == 0 and 0 or n % 17 == 0 and 0 and 0 or n % 19 == 0 and 0 and 0 or n % 23\
    \ == 0 and 0 and 0 or n % 29 == 0 and 0 and 0 or n % 31 == 0 and 0 and 0 or n\
    \ % 37 == 0 and 0 and 0 or n % 41 == 0 and 0 and 0 or n % 43 == 0 and 0 and 0\
    \ or n % 47 == 0 and 0 and 0 or n % 53 == 0 and 0 and 0 or n % 59 == 0 and 0 and\
    \ 0 or n % 61 == 0 and 0 and 0 or n % 67 == 0 and 0 and 0 or n % 71 == 0 and 0\
    \ and 0 or n % 73 == 0 and 0 and 0 or n % 79 == 0 and 0 and 0 or n % 83 == 0 and\
    \ 0 and 0 or n % 89 == 0 and 0 and 0 or n % 97 == 0 and 0 and 0 or n % 103 ==\
    \ 0 and 0 and 0 or n % 109 == 0 and 0 and 0 or n % 113 == 0 and 0 and 0 or n %\
    \ 117 == 0 and 0 and 0 or n % 121 == 0 and 0 and 0 or n % 123 == 0 and 0 and 0\
    \ or n % 129 == 0 and 0 and 0 or n % 131 == 0 and 0 and 0 or n % 137 == 0 and\
    \ 0 and 0 or n % 141 == 0 and 0 and 0 or n % 147 == 0 and 0 and 0 or n % 151 ==\
    \ 0 and 0 and 0 or n % 157 == 0 and 0 and 0 or n % 161 == 0 and 0 and 0 or n %\
    \ 167 == 0 and 0 and 0 or n % 173 == 0 and 0 and 0 or n % 179 == 0 and 0 and 0\
    \ or n % 183 == 0 and 0 and 0 or n % 189 == 0 and 0 and 0 or n % 193 == 0 and\
    \ 0 and 0 or n % 197 == 0 and 0 and 0 or n % 201 == 0 and 0 and 0 or n % 207 ==\
    \ 0 and 0 and 0 or n % 211 == 0 and 0 and 0 or n % 215 == 0 and 0 and 0 or n %\
    \ 219 == 0 and 0 and 0 or n % 223 == 0 and 0 and 0 or n % 229 == 0 and 0 and 0\
    \ or n % 233 == 0 and 0 and 0 or n % 239 == 0 and 0 and 0 or n % 243 == 0 and\
    \ 0 and 0 or n % 2489 == 0 and 0 and 0 or n % 2537 == 0 and 0 and 0 or n % 2571\
    \ == 0 and 0 and 0 or n % 2615 == 0 and 0 and 0 and 0 or n % 2637 == 0 and 0 and\
    \ 0 and 0 or n % 2657 == 0 and 0 and 0 and 0 or n % 2689 == 0 and 0 and 0 and\
    \ 0 or n % 2703 == 0 and 0 and 0 or n % 2747 == 0 and 0 and 0 or n % 2763 == 0\
    \ and 0 and 0 and 0 or n % 2781 == 0 and 0 and 0 or n % 2793 == 0 and 0 and 0\
    \ or n % 2811 == 0 and 0 and 0 or n % 2827 == 0 and 0 and 0 or n % 2839 == 0 and\
    \ 0 and 0 or n % 2851 == 0 and 0 and 0 or n % 2857 == 0 and 0 and 0 or n % 2879\
    \ == 0 and 0 and 0 and 0 or n % 2893 == 0 and 0 and 0 or n % 2909 == 0 and 0 and\
    \ 0 and 0 or n % 2943 == 0 and 0 and 0 and 0 or n % 2959 == 0 and 0 and 0 and\
    \ 0 or n % 2971 == 0 and 0 and 0 or n % 2997 == 0 and 0 and 0 and 0 or n % 3011\
    \ == 0 and 0 and 0 and 0 or n % 3023 == 0 and ", "  local f = 0\n  for i = 1,\
    \ 10 do\n    if n % i == 0 and i % 11 == 0 or i % 13 == 0 then\n      f = f +\
    \ 1\n    end\n  end\n  return f\nend", "  if n < 3 then return n end\n  if n ==\
    \ 3 or n % 11 == 0 then return n end\n  if n == 5 then return n end\n  if n %\
    \ 13 == 0 then return n end\n  return fizz_buzz(n - 1) + fizz_buzz(n - 3)\nend",
  "  if n < 10 then\n    return n\n  elseif n < 100 then\n    return if n % 11 ==\
    \ 0 or n % 13 == 0 then\n      n\n    else\n      n * fizz_buzz(n % 10) + fizz_buzz(n\
    \ % 10)\n    end\n  else\n    return if n % 11 == 0 and n % 13 == 0 then\n   \
    \   fizz_buzz((n / 10) * 10) + (n % 10)\n    else\n      fizz_buzz((n / 10) *\
    \ 10) + fizz_buzz((n / 10) * 10) + fizz_buzz((n / 10) * 10) + fizz_buzz(n % 10)\n\
    \    end\n  end\nend", "    local counter = n / 11\n    if n % 11 == 0 then\n\
    \        counter = counter + 1\n    end\n    local counter1 = n / 13\n    if n\
    \ % 13 == 0 then\n        counter1 = counter1 + 1\n    end\n    return counter,\
    \ counter1\nend", "  local ret = {}\n  -- 1\n  local n1 = n % 11\n  if n1 == 0\
    \ then ret[1] = 1 end\n  -- 2\n  local n2 = n % 13\n  if n2 == 0 then ret[2] =\
    \ 1 end\n  -- 3\n  local n3 = n % 17\n  if n3 == 0 then ret[3] = 1 end\n  -- 4\n\
    \  local n4 = n % 21\n  if n4 == 0 then ret[4] = 1 end\n  -- 5\n  local n5 = n\
    \ % 25\n  if n5 == 0 then ret[5] = 1 end\n  -- 6\n  local n6 = n % 29\n  if n6\
    \ == 0 then ret[6] = 1 end\n  -- 7\n  local n7 = n % 33\n  if n7 == 0 then ret[7]\
    \ = 1 end\n  -- 8\n  local n8 = n % 37\n  if n8 == 0 then ret[8] = 1 end\n  --\
    \ 9\n  local n9 = n % 41\n  if n9 == 0 then ret[9] = 1 end\n  -- 10\n  local n10\
    \ = n % 45\n  if n10 == 0 then ret[10] = 1 end\n  -- 11\n  local n11 = n % 49\n\
    \  if n11 == 0 then ret[11] = 1 end\n  -- 12\n  local n12 = n % 53\n  if n12 ==\
    \ 0 then ret[12] = 1 end\n  -- 13\n  local n13 = n % 57\n  if n13 == 0 then ret[13]\
    \ = 1 end\n  -- 14\n  local n14 = n % 61\n  if n14 == 0 then ret[14] = 1 end\n\
    \  -- 15\n  local n15 = n % 65\n  if n15 == 0 then ret[15] = 1 end\n  -- 16\n\
    \  local n16 = n % 69\n  if n16 == 0 then ret[16] = 1 end\n  -- 17\n  local n17\
    \ = n % 73\n  if n17 == 0 then ret[17] = 1 end\n  -- 18\n  local n18 = n % 77\n\
    \  if n18 == 0 then ret[18] = 1 end\n  -- 19\n  local n19 = n % 81\n  if n19 ==\
    \ 0 then ret[19] = 1 end\n  -- 20\n  local n20 = n % 85\n  if n20 == 0 then ret[20]\
    \ = 1 end\n  -- 21\n  local n21 = n % 89\n  if n21 == 0 then ret[21] = 1 end\n\
    \  -- 22\n  local n22 = n % 93\n  if ", "  local count = 0\n  local div11 = n\
    \ % 11\n  local div13 = n % 13", "  if n < 0 then\n    error(\"Non negative number\"\
    , 2)\n  end\n  if n % 11 == 0 then return 1 end\n  if n % 13 == 0 then return\
    \ 2 end\n  return 0\nend", "\tif n <= 10 then\n\t\treturn n\n\telseif n % 10 ==\
    \ 7 then\n\t\treturn 0\n\telseif n % 10 == 11 then\n\t\treturn 1\n\telseif n %\
    \ 10 == 13 then\n\t\treturn 2\n\telse\n\t\treturn fizz_buzz(n div 10) + 1\n\t\
    end\nend", "  local n1 = n % 11\n  local n2 = n % 13", "   if n < 0 then\n   \
    \   return nil\n   end\n   if n >= 1000 and n % 11 == 1 then\n      return n\n\
    \   elseif n >= 1000 and n % 13 == 1 then\n      return n\n   else\n      local\
    \ count = 0\n      for i = 1, n do\n         if i % 13 == 0 or i % 11 == 0 then\n\
    \            count = count + 1\n         end\n      end\n      return count\n\
    \   end\nend", "  return (( n % 11 == 0 and n % 13 == 0 ) or n % 11 == 0) and\
    \ 1 or 0\nend", "  local count = 0\n  while n > 0 and n % 11 == 0 and n % 13 ==\
    \ 0 do\n    n = math.floor(n/10)\n    count = count + 1\n  end\n  return count\n\
    end", "  local count = 0\n  if n <= 0 then return 0 end\n  if n <= 3 then\n  \
    \  return 1\n  end\n  for i = 1, n do\n    if i % 11 == 0 or i % 13 == 0 then\n\
    \      count = count + 1\n    end\n  end\n  return count\nend", "  if n < 0 then\n\
    \    return -1\n  end", "  if n < 10 then\n    return n\n  end\n  if n % 11 ==\
    \ 0 or n % 13 == 0 then\n    return 1\n  end\n  return fizz_buzz(n - 10)\nend",
  "  n = math.floor(n)\n  local count = 0\n  local i = 1\n  while i <= n do\n    local\
    \ k = math.floor(math.log10(i))\n    if k == 0 then\n      count = count + 1\n\
    \      i = math.floor(i / 10)\n    else\n      if k == 1 then\n        if i %\
    \ 10 == 0 then\n          count = count + 1\n        end\n      else\n       \
    \ if i % 10 == 1 then\n          if i % 100 == 0 then\n            count = count\
    \ + 1\n          end\n        else\n          if i % 100 == 1 then\n         \
    \   if i % 1000 == 0 then\n              count = count + 1\n            end\n\
    \          end\n        end\n      end\n    end\n    i = i + 1\n  end\n  return\
    \ count\nend", "  local count = 0\n  while n > 0 do\n    if n % 11 == 1 then\n\
    \      count = count + 1\n    end\n    if n % 13 == 1 then\n      count = count\
    \ + 1\n    end\n    n = math.floor(n/10)\n  end\n  return count\nend", "  if n\
    \ == 1 then\n    return 0\n  else\n    if n % 11 == 1 then return fizz_buzz(n-1)\
    \ + 1 end\n    if n % 13 == 1 then return fizz_buzz(n-1) + 3 end\n    return fizz_buzz(n-1)\n\
    \  end\nend", "  if n < 10 then return n end\n  if n % 11 == 1 then return n end\n\
    \  if n % 13 == 1 then return n end\n  return fizz_buzz(n - 1) + (n % 7 == 1 or\
    \ not and or and and and and and and or)\nend", "\t-- Initialize a variable to\
    \ be the length of the string representation of the integer passed in.\n\tlocal\
    \ length = 0\n\t-- Initialize a variable to be a list of the numbers in the string\
    \ representation of the integer passed in.\n\tlocal numbers = {}\n\t-- Iterate\
    \ over each digit of the integer passed in.\n\tfor i = 1, 10 do\n\t\t-- Convert\
    \ the integer passed into a string representation.\n\t\tlocal number = string.format(i,\
    \ \"%g\")\n\t\t-- Add the digit to the string representation of the integer.\n\
    \t\ttable.insert(numbers, number)\n\t\t-- Find the number of times the digit 7\
    \ appears in the string representation of the integer passed in.\n\t\tlength =\
    \ length + string.count(number, \"7\")\n\tend\n\t-- Return 0 if the length of\
    \ the integer passed in is equal to the length of the string representation of\
    \ that integer.\n\tif n == length then\n\t\treturn 0\n\telse\n\t\t-- Return the\
    \ number of times the digit 7 appears in integers less than n which are divisible\
    \ by 11 or 13.\n\t\tlocal answer = length - n\n\t\tif answer >= 0 then\n\t\t\t\
    return answer\n\t\telse\n\t\t\treturn 0\n\t\tend\n\tend\nend", "    -- Handle\
    \ edge cases.\n    if n < 1 or n % 11 ~= 0 then return end\n    if n < 17 and\
    \ n % 13 ~= 0 then return end\n    -- Handle all multiples of 11.\n    if n %\
    \ 11 == 1 then return fizz_buzz(n / 11) end\n    -- Handle all multiples of 13.\n\
    \    if n % 13 == 1 then return fizz_buzz(n / 13) end\n    -- Finally, handle\
    \ the case of multiples of both 11 and 13.\n    return fizz_buzz(n / 11) + fizz_buzz(n\
    \ / 13)\nend\n</cell>\n<text>\nQuestion 4\nWrite a function that takes the name\
    \ of a file, and prints the number of characters in each of the files. For example,\
    \ given the name \u201Csample.txt\u201D, the output should be \u201Csample: 26\u201D\
    .", "    if n < 10 then\n        return n\n    elseif n >= 0 and n % 10 == 7 and\
    \ n % 11 == 0 then\n        return fizz_buzz(n/10) + 1 -- Return the number of\
    \ times the digit 7 appears in integers less than n which are divisible by 11\
    \ or 13.\n    else\n        return fizz_buzz(n / 10) + 1\n    end\nend", "   \
    \ local count = 0\n    while n >= 11 or n >= 13 do\n        count = count + 1\n\
    \        n = math.mod(n, 11)\n        n = math.mod(n, 13)\n    end\n    return\
    \ count\nend\n</code>\n<|/ a dscore=2 tags=fizzbuzz,lua,fizzler,fizz |>\n<| a\
    \ tags=fizzbuzz,lua,fizzler,fizz dscore=2 |>\nIf you're looking for an example\
    \ of how this would look in Lua instead of pseudo-code, then I'll give you one\
    \ that uses fizzbuzzler and fizzler to get you started. The code is a little bit\
    \ long, but hopefully you can see what's going on here. \n<code>", "  local result\
    \ = 0\n  for i = 1, n do\n    if i % 11 == 1 then\n      if i % 13 == 1 then\n\
    \        -- print(i)\n        -- print(\" \")\n        result = result + 1\n \
    \     end\n    elseif i % 13 == 1 then\n      if i % 11 == 1 then\n        --\
    \ print(i)\n        -- print(\" \")\n        result = result + 1\n      end\n\
    \    else\n      -- print(i)\n      -- print(\" \")\n    end\n  end\n  print(result)\n\
    \  return result\nend", "  if n > 0 and n <= 11 then\n    return 0\n  end", " \
    \   if n < 1 then\n        return 0\n    end\n    -- If the number is divisible\
    \ by 11, we count one \"1\", otherwise we count \"11\".\n    local n_mod_11 =\
    \ n % 11\n    if n_mod_11 == 0 then\n        return 1\n    else\n        return\
    \ 1 + fizz_buzz(n_mod_11)\n    end\nend\n</cell>\n<cell>", "    if n == 0 then\n\
    \        return 0\n    end\n    if n % 11 == 0 or n % 13 == 0 then\n        return\
    \ fizz_buzz(n / 10) + 1 -- count up\n    end\n    return fizz_buzz(n / 10) + 1\n\
    end", "  if n < 1 then return 0 end\n  if n % 11 == 1 then return 1 end\n  if\
    \ n % 13 == 1 then return 2 end\n  return fizz_buzz(n-1) + fizz_buzz(n-2)\nend",
  "  if n < 0 then\n    error(\"Argument 'n' must be positive.\")\n  end\n  local\
    \ count = 0\n  while n % 11 == 0 or n % 13 == 0 do\n    count = count + 1\n  \
    \  n = n / 10\n  end\n  -- No fizz buzz for multiples of 10 and multiples of 7.\n\
    \  if n % 10 == 0 then\n    count = count + 1\n  end\n  return count\nend", " \
    \  -- Make sure n is between 1 and 100.\n   if n < 1 or n > 100 then\n      print('fizz_buzz\
    \ called with n ' .. tostring(n) .. ', but n must be between 1 and 100.')\n  \
    \    return nil\n   end\n   -- Return 1 if n is divisible by 7, return 2 if n\
    \ is divisible by 11, return 3 if n is divisible by 13, and return 4 if n is divisible\
    \ by 19.\n   if n % 7 == 0 then\n      print('fizz_buzz called with n ' .. tostring(n)\
    \ .. ', but n is divisible by 7, so returns 1')\n      return 1\n   end\n   if\
    \ n % 11 == 0 then\n      print('fizz_buzz called with n ' .. tostring(n) .. ',\
    \ but n is divisible by 11, so returns 2')\n      return 2\n   end\n   if n %\
    \ 13 == 0 then\n      print('fizz_buzz called with n ' .. tostring(n) .. ', but\
    \ n is divisible by 13, so returns 3')\n      return 3\n   end\n   if n % 19 ==\
    \ 0 then\n      print('fizz_buzz called with n ' .. tostring(n) .. ', but n is\
    \ divisible by 19, so returns 4')\n      return 4\n   end\n   return nil\nend",
  "  return math.floor(n/11)*11+math.floor(n/13)*13\nend", "  local count = 0\n  if\
    \ n % 11 == 0 then count = count + 1 end\n  if n % 13 == 0 then count = count\
    \ + 1 end\n  return count\nend", "    local num_1 = 0\n    local num_2 = 0\n \
    \   local num_3 = 0\n    local num_4 = 0\n    local num_5 = 0\n    local num_6\
    \ = 0\n    local num_7 = 0\n    local num_8 = 0\n    local num_9 = 0\n    local\
    \ num_10 = 0\n    local num_11 = 0\n    local num_12 = 0\n    local num_13 = 0\n\
    \    local num_14 = 0\n    local num_15 = 0\n    local num_16 = 0\n    local num_17\
    \ = 0\n    local num_18 = 0\n    local num_19 = 0\n    local num_20 = 0\n    local\
    \ num_21 = 0\n    local num_22 = 0\n    local num_23 = 0\n    local num_24 = 0\n\
    \    local num_25 = 0\n    local num_26 = 0\n    local num_27 = 0\n    local num_28\
    \ = 0\n    local num_29 = 0\n    local num_30 = 0\n    local num_31 = 0\n    local\
    \ num_32 = 0\n    local num_33 = 0\n    local num_34 = 0\n    local num_35 = 0\n\
    \    local num_36 = 0\n    local num_37 = 0\n    local num_38 = 0\n    local num_39\
    \ = 0\n    local num_40 = 0\n    local num_41 = 0\n    local num_42 = 0\n    local\
    \ num_43 = 0\n    local num_44 = 0\n    local num_45 = 0\n    local num_46 = 0\n\
    \    local num_47 = 0\n    local num_48 = 0\n    local num_49 = 0\n    local num_50\
    \ = 0\n    local num_51 = 0\n    local num_52 = 0\n    local num_53 = 0\n    local\
    \ num_54 = 0\n    local num_55 = 0\n    local num_56 = 0\n    local num_57 = 0\n\
    \    local num_58 = 0\n    local num_59 = 0\n    local num_60 = 0\n    local num_61\
    \ = 0\n    local num_62 = 0\n    local num_63 = 0\n    local num_64 = 0\n    local\
    \ num_65 = 0\n    local num_66 = 0\n    local num_67 = 0\n    local num_68 = 0\n\
    \    local num_69 = 0\n    local num_70 = 0\n    local num_71 = 0\n    local num_72\
    \ = 0\n    local num_73 = 0\n    local num_74 = 0\n    local num_75 = 0\n    local\
    \ num_76 = 0\n    local num_77 = 0\n    local num_78 = 0\n    local num_79 = 0\n\
    \    local num_80 = 0\n    local num_81 = 0\n    local num_82 = 0\n    local num_83\
    \ = 0\n    local num_84 = 0\n    local num_85 = 0\n    local "]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
