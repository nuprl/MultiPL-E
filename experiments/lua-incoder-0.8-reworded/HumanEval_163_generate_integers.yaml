name: HumanEval_163_generate_integers
language: lua
prompt: "-- Given two positive integers a and b, return the even digits between a\n\
  -- and b, in ascending order.\n-- For example:\n-- >>> generate_integers(2, 8)\n\
  -- {2, 4, 6, 8}\n-- >>> generate_integers(8, 2)\n-- {2, 4, 6, 8}\n-- >>> generate_integers(10,\
  \ 14)\n-- {}\nlocal function generate_integers(a, b)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = generate_integers\n\
  \    lu.assertEquals(candidate(2, 10), {2, 4, 6, 8})\n    lu.assertEquals(candidate(10,\
  \ 2), {2, 4, 6, 8})\n    lu.assertEquals(candidate(132, 2), {2, 4, 6, 8})\n    lu.assertEquals(candidate(17,\
  \ 89), {})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local digits = {}\n  local i = 1\n  while i <= b - a do\n    digits[i]\
    \ = i\n    i = i + 1\n  end\n  return digits\nend", "    assert(b > a, \"Argument\
    \ a must be greater than argument b.\")\n    local set = setmetatable({}, { __index\
    \ = {} })\n    local result\n    -- If b is negative, ignore a. Otherwise, return\
    \ a and b.\n    if b < 0 then\n        a, b = b, a\n    end\n    -- If the difference\
    \ between a and b is zero, return a and b.\n    if b == 0 then\n        return\
    \ setmetatable(set, { __index = {} })\n    end\n    -- Set up the initial result\
    \ by generating a sequence of numbers to be\n    -- compared to b. If the difference\
    \ between a and b is nonzero,\n    -- generate all numbers between a and b and\
    \ add them to the set.\n    -- Otherwise, generate numbers between 1 and b and\
    \ add them to the set\n    -- until a is reached or there are no more numbers\
    \ to generate.\n    -- We need to know whether a is positive or negative.\n  \
    \  local sign = 1\n    if b < 0 then\n        sign = -1\n    end\n    for i =\
    \ 1, b do\n        local toadd\n        if i ~= a then\n            toadd = sign\
    \ * (i + 1)\n        else\n            toadd = sign * i\n        end\n       \
    \ set.add(toadd)\n    end\n    -- Add all numbers between a and b that are less\
    \ than b.\n    for i = a + (b - a) .. 1, b do\n        set.add(sign * i)\n   \
    \ end\n    -- Return the set\n    if a == 1 then\n        result = set[1]\n  \
    \  else\n        result = set\n    end\n    return result\nend", "  local c =\
    \ {}\n  for i = a, b do\n    c[i / b] =  i %  b\n  end\n  return c\nend", "  return\
    \ setmetatable({}, {\n    __index = function(t, i)\n      if i <= b then\n   \
    \     return i - 1\n      else\n        return nil\n      end\n    end\n  })\n\
    end", "    if b > a then\n        generate_integers(b, a)\n    end", "  if a >\
    \ b then return a end\n  local range = {}\n  for i = b, a, -1 do\n    table.insert(range,\
    \ i)\n  end\n  return range\nend", "    assert(b > a)\n    -- No need to go out\
    \ of bounds.\n    assert(a <= b - 1)\n    local digits = {}\n    for i = a, 1,\
    \ -1 do\n        digits[i] = 1\n    end\n    for i = b, 1, -1 do\n        digits[i]\
    \ = 0\n    end\n    for i = 2, b, 1 do\n        local m = i\n        for j = 1,\
    \ a do\n            -- Only add digits strictly larger than the i'th digit.\n\
    \            m = m / 10\n            if digits[j] and m >= b then\n          \
    \      digits[j] = m\n            end\n        end\n    end\n    return digits\n\
    end", "  if b < 0 then\n    error(\"integer b must be positive\")\n  end\n  if\
    \ a > b then\n    error(\"integer a must be less than or equal to integer b\"\
    )\n  end\n  -- Use a set to avoid duplicate entries.\n  local set = setmetatable({},\
    \ {__mode=\"k\"})\n  -- Use a set to avoid duplicate entries.\n  local to_return\
    \ = setmetatable({}, {__mode=\"v\"})\n  for i = a .. b do\n    local digit = i\
    \ / b\n    set[i] = digit\n    -- If b is a power of 10, set b to the next higher\
    \ power of 10\n    local remainder = i % b\n    if remainder == 0 then\n     \
    \ if set[b] == nil then\n        set[b] = 1\n      else\n        set[b] = b +\
    \ 1\n      end\n    end\n  end\n  -- Return result\n  for i = a .. b do\n    to_return[set[i]]\
    \ = i\n  end\n  return to_return\nend", "  if a <= 0 then\n    return {}\n  end\n\
    \  local result\n  if b > 0 then\n    result = {a}\n  end\n  if a == 0 then\n\
    \    local limit = math.floor(b / 2)\n    limit = math.min(limit, a)\n    for\
    \ i = 1, limit do\n      table.insert(result, i)\n    end\n  end\n  return result\n\
    end", "    -- Return an empty vector if b is greater than a\n    if b > a then\n\
    \        return {}\n    end", "  local numbers = {}\n  for i = a, b do\n    numbers[#numbers\
    \ + 1] = \"0\".. i\n  end\n  return numbers\nend", "  if b > a then\n    local\
    \ temp = a\n    a = b\n    b = temp\n  end", "  if b < 0 then\n    error(\"Second\
    \ argument must be greater than zero\")\n  end\n  local results = {}\n  for i\
    \ = a or 1, b or 1 do\n    results[i] = i\n  end\n  table.sort(results)\n  return\
    \ results\nend", "  -- Generate the integers between two numbers.\n  -- Note that\
    \ this function generates *integers*. There are no floats.\n  -- Therefore, the\
    \ input has to be an integer between 0 and 2**32-1.\n  -- Therefore, in the case\
    \ of generating integers up to 2**32-1, we\n  -- will simply convert the integer\
    \ to a 32-bit binary string and\n  -- extract the even digits out of it.\n  --\
    \ The last even digit is the highest integer that can be obtained\n  -- in the\
    \ 32-bit binary representation of an integer, and therefore\n  -- 2^32-1 is the\
    \ highest possible value for an unsigned integer.\n  -- We then return the even-digits\
    \ between 0 and the highest even digit\n  -- to ensure that we have a non-empty\
    \ set of integers between 0 and\n  -- 2**32-1.\n  local i = 1\n  local evens,\
    \ odds = set{}, {}\n  while i <= math.pow(2, 32) do\n    local as_string = (i\
    \ ~= 0 and string.format(\"%u\", i))\n    local even = as_string:sub(1, 4)\n \
    \   if not evens[even] then\n      evens[even] = true\n      odds[as_string:sub(5,\
    \ #as_string)] = true\n    end\n    i = i + 1\n  end\n  -- Remove duplicates.\n\
    \  evens, odds = unpack(table.sort(evens)), unpack(table.sort(odds))\n  -- Return\
    \ the even digits.\n  return evens\nend\n</code>\n<|/ a tags=lua,recursion,string,integer,search\
    \ dscore=1 |>\n<| c |>\nOh wow I did not think about doing it that way. I will\
    \ definitely try it out. Thank you!\n<|/ c |>\n<| c |>\nI edited my answer to\
    \ improve its efficiency. Hope it helps!\n<|/ c |>\n<| c |>\nI made a quick test\
    \ and it seems to work pretty well! It also appears to take up less memory than\
    \ my original function. Thank you so much for all your help.\n<|/ c |>\n<| a |>\n\
    I wrote this as solution in JavaScript, because I like it and didn't know better\
    \ (I just had to solve the problem myself ;) ). Please correct me if I made any\
    \ mistakes.\n<code>", "  if b == 1 then\n    return {}\n  else\n    local res\
    \ = {}\n    local i = a\n    repeat\n      res[i] = i\n      i = i * 10 + 1\n\
    \    until i <= b\n    return res\n  end\nend", '  if b < a then return {} end',
  "  if b < 0 then\n    error(\"generate_integers: b must be positive\")\n  end\n\
    \  if a > b then\n    error(\"generate_integers: a must be smaller or equal than\
    \ b\")\n  end", "  if a <= 0 then\n    return {}\n  end\n  local result = {}\n\
    \  local i = 1\n  while i <= a do\n    table.insert(result, i)\n    i = i * 10\n\
    \  end\n  if a < b then\n    for i = b, a do\n      table.insert(result, i)\n\
    \    end\n  end\n  return result\nend", "  if a >= b or a < 0 then return end\n\
    \  if b >= a or b < 0 then return end\n  if a == b then return setmetatable({},\
    \ {__index = function(t, k)\n      if k ~= '__tostring' then\n        if k < a\
    \ or k > b then return nil\n      else\n        if k < a or k > b then return\
    \ setmetatable({}, {__tostring = function()\n          return '#<unsupported type\
    \ #' .. ((k - a) + b) .. '>'\n        end})\n      end\n      return t[k]\n  \
    \  end})\n  else\n    local result = {}\n    for i = a, b do\n      local digit\
    \ = (i % b) + 1\n      if digit == 0 then\n        digit = 1\n      end\n    \
    \  result[i - a] = digit\n    end\n    return result\n  end\nend", "  return setmetatable(set(),\
    \ {__index=function(self, key)\n    return ((key - a) % (b - a) + a) .. math.modf((key\
    \ - a) / b)\n  end})\nend", "  if a <= b then return {} end\n  local c = a\n \
    \ local d = b\n  while c <= d do\n    table.insert(result, c)\n    c = math.floor((c\
    \ + math.floor(b / c)) % math.floor(a / d))\n  end\nend", "  if b < a then\n \
    \   local tmp = a\n    a = b\n    b = tmp\n  end\n  local result = {}\n  for i\
    \ = a, b do\n    table.insert(result, i)\n  end\n  return result\nend", "  if\
    \ a < 2 or (b and b < 2) then\n    return {}\n  end\n  local result = {}\n  for\
    \ i = a, b do\n    result[i - a] = i\n  end\n  return result\nend", "    local\
    \ num = {}\n    local m = math.min(a, b)\n    while a <= m do\n        num[tostring(a)]\
    \ = tostring(a)\n        a = a + 2\n    end\n    for i = b, m, 2 do\n        num[tostring(i)]\
    \ = tostring(i)\n    end\n    return num\nend", "    if a > b then\n        a,\
    \ b = b, a\n    end\n    local results = {}\n    for i = a, b do\n        table.insert(results,\
    \ i % 10)\n    end\n    return results\nend", "    if a == b then\n        return\
    \ {}\n    end", "  if a <= b then return {} end\n  local result = {}\n  local\
    \ last_digit = 1\n  for i = b, 0, -1 do\n    if last_digit % 2 ~= 0 then\n   \
    \   table.insert(result, last_digit)\n    end\n    last_digit = math.floor(last_digit\
    \ / 2)\n  end\n  table.insert(result, last_digit)\n  return result\nend", "  if\
    \ a == b then\n    return {}\n  end", "  if a > b then\n    a, b = b, a\n  end\n\
    \  local numbers = {}\n  local counter = a\n  while counter <= b do\n    numbers[counter]\
    \ = counter\n    counter = counter + 1\n  end\n  return numbers\nend", "  if b\
    \ > a then\n    -- Generate the sequence up to (but not including) b.\n    return\
    \ generate_integers(b, a)\n  end\n  -- Generate all the digits between a and the\
    \ next larger integer.\n  local digits = {}\n  for i = a, 1 do\n    digits[#digits\
    \ + 1] = tonumber(string.format('%0d', i))\n  end\n  table.sort(digits)\n  --\
    \ Return the first b digits.\n  -- This isn't the fastest solution, but it's simple\
    \ and efficient.\n  return digits[a:b]\nend", "  -- assert type(a) == 'number'\
    \ and type(b) == 'number', tostring(a) or tostring(b)\n  assert(type(a) == 'number'\
    \ and type(b) == 'number', tostring(a) or tostring(b))\n  -- assert(a <= b)\n\
    \  assert(a <= b)\n  local results = {}\n  for i = a, b do\n    table.insert(results,\
    \ i)\n  end\n  -- assert(#results == (b - a) + 1)\n  return results\nend", " \
    \ if a < b then\n    generate_integers(b, a)\n  else\n    local evens = {a, b}\n\
    \    while evens[1] do\n      evens[1] = evens[1] - 2\n    end\n    return evens\n\
    \  end\nend", "  local result = {}\n  for i = a, b do\n    table.insert(result,\
    \ i % 10)\n  end\n  return result\nend", "  local function digits_in_base(n)\n\
    \    if n < 10 then\n      return 1\n    elseif n < 100 then\n      return digits_in_base(n\
    \ / 10) * 10 + n % 10\n    elseif n < 1000 then\n      return digits_in_base(n\
    \ / 100) * 100 + n % 100\n    else\n      return nil\n    end\n  end\n  if a >\
    \ b then\n    a, b = b, a\n  end\n  local count = 1\n  while a <= b do\n    count\
    \ = (digits_in_base(b) - digits_in_base(a) + count) + 1\n    a, b = b, a * (2^(digits_in_base(b)\
    \ - digits_in_base(a) + 1))\n  end\n  return math.floor(b / a) * count\nend",
  "  local result = {}\n  for i = a, b do\n    table.insert(result, i)\n  end\n  table.sort(result)\n\
    \  return result\nend", "  local ret = {}\n  local i = a\n  while i <= b do\n\
    \    ret[#ret + 1] = i\n    i = i * 10\n  end\n  return ret\nend", "  -- If b\
    \ is not an integer, then the result will be a empty set\n  -- since we know that\
    \ no elements must be between a and b.\n  if not b then\n    return {}\n  end\n\
    \  -- Return the set of digits that are between a and b.\n  -- Notice that a and\
    \ b are integers, and the result is an integer set.\n  -- This set is sorted in\
    \ ascending order since the digits are sorted\n  -- in ascending order.\n  return\
    \ setmetatable(set(), {\n    __index = function(t, k)\n      if a <= k <= b then\n\
    \        return k:tostring()\n      else\n        return nil\n      end\n    end\n\
    \  })\nend", "  local digits = {}\n  for i = a, b, 2 do table.insert(digits, i)\
    \ end\n  return table.sort(digits, math.ascend)\nend", "  if a < b then\n    generate_integers(b,\
    \ a)\n  end", "  -- We generate from smallest to largest because:\n  -- -- a)\
    \ we can stop when we reach `b`\n  -- -- b) We want to return `b` evenly distributed\
    \ numbers anyway,\n  -- so it's better to generate the smallest numbers first\
    \ and then\n  -- move to the largest numbers.\n  local numbers = terralib.newlist()\n\
    \  local index = a\n  while index <= b do\n    numbers:insert(index)\n    index\
    \ = math.max(index * 2 + 1, b + 1)\n  end\n  return numbers\nend", "    if b -\
    \ a < 0 then\n        return {}\n    end\n    local result = {}\n    for i = a,\
    \ b do\n        table.insert(result, i / 10)\n    end\n    return table.remove(result,\
    \ 1)\nend", "  return setmetatable({}, {__index = function(t, v)\n      local\
    \ digits = math.floor((b - a) / 2)\n      local numbers = generate_integers(a,\
    \ b)\n      local result = {}\n      for i = 1, digits do\n        result[i] =\
    \ a + i * 2\n      end\n      return table.concat(result, \", \")\n    end})\n\
    end", "  assert(a <= b)\n  if a == b then return { a }\n  if a <= b then return\
    \ {} end\n  local r = {}\n  for i = a, b do\n    table.insert(r, i / 10)\n   \
    \ i = i % 10\n  end\n  return r\nend", "   local c = 0\n   for i=a, math.min(b,\
    \ i) do\n      c = c + 1\n   end\n   return c\nend", "  if a < 1 then return end\n\
    \  local even = {}\n  for i = a, b do\n    if even and even[math.floor(i/2)]\n\
    \      then even[math.floor(i/2) + 1] = 1\n      else even[math.floor(i/2)] =\
    \ 1\n    end\n  end\n  -- Even numbers are in ascending order and have no duplicates.\n\
    \  return table.sort(even, function(a, b) return a < b end)\nend", "  local digits\
    \ = {}\n  for i = a, b do\n    digits[i] = true\n  end\n  local done = {}\n  while\
    \ #digits > 0 do\n    table.insert(done, true)\n    local deleted = {}\n    for\
    \ i = #digits, 1, -1 do\n      if not done[i] then\n        table.insert(deleted,\
    \ i)\n      end\n      digits[i] = false\n    end\n    for _, k in pairs(deleted)\
    \ do\n      table.insert(digits, k)\n    end\n  end\n  return table.unpack(digits)\n\
    end", "  if b < 1 then\n    return {}\n  elseif b == 0 then\n    return {a}\n\
    \  else\n    return generate_integers(a + 1, b - 1):gsub('%d+', function(x)\n\
    \      return tonumber(x)\n    end)\n  end\nend", "  if b < a then a, b = b, a\
    \ end\n  if b == a then return {} end\n  local digits = {}\n  for i = a+1, b do\n\
    \    digits[i] = 1\n  end\n  local j = 0\n  for i = b, a do\n    digits[i] = digits[i-j]*10\
    \ + digits[i-j+1]\n    j = i\n  end\n  return digits\nend", "  -- Return an empty\
    \ set if there are no more even numbers between\n  -- a and b.\n  if not a or\
    \ not b then return {} end", "  if b < a then\n    return {}\n  end\n  if a <\
    \ 2 then -- special case\n    return {}\n  end\n  local digits = {}\n  while a\
    \ <= b do\n    digits[a] = a\n    a = a + 2\n  end\n  return digits\nend", " \
    \   if b == nil then b = a end\n    local results = {}\n    local i = 1\n    while\
    \ i <= a do\n        local digit = math.floor(i/b)\n        if digit % 2 == 0\
    \ then\n            table.insert(results, digit)\n        end\n        i = i +\
    \ 1\n    end\n    table.sort(results)\n    return results\nend", "  local result\n\
    \  local start\n  if a > b then\n    result, start = a, b\n  else\n    result,\
    \ start = b, a\n  end", "  -- Find a number that divides a between a and b\n \
    \ -- First, check that the number isn't evenly divisible by a\n  -- If we had\
    \ to choose an arbitrary number, we would just divide by a\n  -- after each iteration.\
    \ But choosing such a number is more efficient.\n  while b - a > 1 do\n    --\
    \ choose a number that is divisible by a\n    a = math.modf(b - a)\n    -- if\
    \ we have chosen such a number, return it\n    if a ~= 0 then\n      -- if the\
    \ number is evenly divisible, return it\n      if a % 2 == 0 then return b end\n\
    \      -- otherwise, decrement by 1 and test again\n      b = a - 1\n    end\n\
    \  end", "  local l = {}\n  for i = a, b do\n    table.insert(l, i)\n  end\n \
    \ table.sort(l)\n  return l\nend", "  if b > a then\n    a,b = b,a\n  end\n  local\
    \ result = {}\n  for i = a, b do\n    result[i] = i\n  end\n  return result\n\
    end", "   -- A range over [0, a] will yield a result for a.\n   -- A range over\
    \ [b, b] will yield a result for b.\n   local range = math.min(math.max(a, b),\
    \ a+1)\n   local results = {}\n   for i = 1, range do\n      -- Range over [0,\
    \ b] includes b in the range.\n      local range = math.min(b-i, b+a-i)\n    \
    \  -- For each digit, add it to the accumulator.\n      for j = 0, range do\n\
    \         table.insert(results, j+i)\n      end\n   end\n   return results\nend\n\
    </code>\n<|/ a tags=lua-table,lua dscore=1 |>\n<| a dscore=1 |>\nI wanted to share\
    \ my solution to this, but I needed to do this with tables. I thought I'd share\
    \ my solution anyway. I needed two tables: One that counted how many times each\
    \ digit had been used, and one that counted how many times each digit was used.\n\
    Here's what I came up with:\n<code>", "    local function is_odd(x)\n        return\
    \ x % 2 ~= 0\n    end\n    local function next_integer(x)\n        return x *\
    \ (10 + 1) -- x * 10 + 1\n    end\n    local function is_even(x)\n        return\
    \ x % 2 == 0\n    end\n    local i = 1\n    while i <= b do\n        if a <= i\
    \ then\n            if is_even(i) then\n                return generate_integers(next_integer(i),\
    \ b)\n            else\n                return generate_integers(a, next_integer(i))\n\
    \            end\n        else\n            if is_odd(i) then\n              \
    \  return generate_integers(a, next_integer(i))\n            else\n          \
    \      return generate_integers(next_integer(i), b)\n            end\n       \
    \ end\n        i = next_integer(i)\n    end\nend", "  local ret = {}\n  while\
    \ b > 0 do\n    if b == a then\n      table.insert(ret, a)\n      b = b - 1\n\
    \    else\n      a = a - 2\n      b = b - 1\n    end\n  end\n  return ret\nend",
  "  local current = {}\n  for i = a, b do\n    current[i] = i\n  end\n  while true\
    \ do\n    local found = {}\n    for i = b, 1, -1 do\n      if #current > 0 then\n\
    \        if current[#current] == i then\n          table.insert(found, current[#current])\n\
    \          current[#current] = nil\n        else\n          break\n        end\n\
    \      else\n        break\n      end\n    end\n    if #found > 0 then\n     \
    \ return found\n    end\n    if current == {} then\n      return {}\n    end\n\
    \  end\nend", "  local ans = {}\n  local i = a\n  while i <= b do\n    if i %\
    \ 2 == 0 then\n      table.insert(ans, i)\n    end\n    i = i + 1\n  end\n  return\
    \ ans\nend", "  local digits = {}\n  while b > 0 do\n    digits[#digits + 1] =\
    \ b % 10\n    b = math.floor(b / 10)\n  end\n  local i, j = #digits, 0\n  while\
    \ i do\n    digits[#digits + 1] = digits[i - 1] * 10 + digits[i]\n    i = i -\
    \ 1\n    if i == 0 then\n      digits[#digits + 1] = 1\n      i = i - 1\n    end\n\
    \  end\n  while j <= #digits do\n    digits[#digits + 1] = digits[j - 1] * 10\
    \ + digits[j]\n    j = j + 1\n  end\n  digits = digits.sort(function (a, b) return\
    \ a < b end)\n  -- Return empty if b is bigger than the length of digits.\n  if\
    \ #digits == 0 then\n    return {}\n  end\n  return digits\nend", "  local digits\
    \ = {}\n  for i=a+1, b do\n    table.insert(digits, math.floor((i%(b-a))/(b-a)*10+1))\n\
    \  end\n  return digits\nend", "  -- If b is negative, we're done already.\n \
    \ if b < 0 then\n    return {}\n  end", "  local result = {}\n  for i = a, b,\
    \ 2 do\n    table.insert(result, i)\n  end\n  table.sort(result)\n  return result\n\
    end", "  if a == 0 and b == 0 then\n    return {}\n  end\n  local a_bin = math.huge\n\
    \  local b_bin = math.huge\n  for i = math.floor(a/2) do\n    a_bin = math.lshift(a_bin,\
    \ 1)\n  end\n  for i = math.floor(b/2) do\n    b_bin = math.lshift(b_bin, 1)\n\
    \  end\n  local a_digits = math.floor(a_bin)\n  local b_digits = math.floor(b_bin)",
  "  if b == 0 then\n    return {}\n  end\n  local results = {}\n  local n = math.min(a,\
    \ b)\n  for i = a, n do\n    results[i] = true\n  end\n  -- Recurse on each side\
    \ of the range.\n  for i = b, n do\n    local even, odd = i % 2, i / 2\n    if\
    \ even ~= 0 and odd ~= 0 then\n      -- If i is an even digit and both a and b\
    \ are odd, then i\n      -- lies in the range.\n      results[i] = generate_integers(n\
    \ - 1, b)\n    elseif even ~= 0 and odd ~= 1 then\n      -- If i is an even digit\
    \ and either a or b is odd, then i\n      -- lies in the range. If b is odd, i\
    \ lies in the range\n      -- of results of recursive calls of generate_integers\n\
    \      local even = i % 2\n      local odd = (i - 1) // 2\n      if even ~= 1\
    \ and odd ~= 1 then\n        -- If i is in the range of recursive calls of generate_integers\n\
    \        -- and b is odd, then i is in the range of final results.\n        results[i]\
    \ = generate_integers(n - 1, b)\n      else\n        -- If i is in the range of\
    \ recursive calls of generate_integers\n        -- and b is even, then (i - 1)\
    \ is also in the range of final\n        -- results. Since i must be in the range\
    \ of a or b, i must\n        -- also be in the range of recursive calls of generate_integers\n\
    \        -- and (b - 1) is also in the range of final results.\n        local\
    \ a = n - (i + 1)\n        local b = (n - 1) - i\n        results[i] = generate_integers(a,\
    \ b)\n      end\n    end\n  end\n  return results\nend\n</cell>\n<cell>\n%run\
    \ problem_037.py\n</cell>\n<text>\nProblem 038\nThe prime factors of 13195 are\
    \ 5, 7, 13 and 29.\nBy concatenating together 26 lowercase letters a-z we can\
    \ form the 26 letters of the alphabet. \nBy concatenating together 26 lowercase\
    \ letters a-z we can form the 26 letters of the alphabet.\nIf we take all the\
    \ 26 letters of the alphabet and sort them into order, \nwe get the a-z representation\
    \ of a standard lowercase English alphabet. \nFor example, \n\u201Ca\u201D comes\
    \ before \u201Cb\u201D because \u201Ca\u201D is less than \u201Cb\u201D.\nBy converting\
    \ all the letters to lowercase before creating the full 26 \nEnglish alphabet,\
    \ \nwe guarantee that a-z maps \nto unique integers in the range 0..25; \nfor\
    \ example, \u201Ca\u201D = 0 , \u201C", "  if a >= b then\n    return {}\n  end",
  "  local s = a\n  while s < b do\n    s = s * 10 + 1\n  end\n  return setmetatable({},\
    \ {__index = function (t, k)\n    if k == 1 then\n      return generate_integers(s,\
    \ b)\n    else\n      return generate_integers(s, b)\n    end\n  end})\nend\n\
    generate_integers(0, 100)", "  local results = {}\n  local i = a\n  while i <=\
    \ b do\n    table.insert(results, i)\n    i = i + 2\n  end\n  return results\n\
    end", "    local seq = {}\n    for i = a, b do\n        table.insert(seq, math.floor((math.floor((i\
    \ / 10) + math.floor((i % 10) / 2)) / 2))\n    end\n    table.sort(seq)\n    return\
    \ seq\nend", '  assert(a <= b)', "  local result\n  for i = math.min(a, b) do\n\
    \    table.insert(result, math.floor(i))\n  end\n  return result\nend", "  local\
    \ result = {}\n  while a <= b do\n    -- The result must be a list of integers\n\
    \    -- between a and b.\n    table.insert(result, math.floor(a))\n    a = math.floor(a\
    \ * 10) + math.floor(b / 10)\n    b = b - a\n  end\n  table.insert(result, math.floor(b))\n\
    \  return result\nend", "  if b < 0 then\n    return {}\n  end\n  local result\
    \ = {}\n  local current = a\n  local count = 0\n  repeat\n    count = count +\
    \ 1\n    result[count] = current\n    current = current * 10 + 1\n  until current\
    \ > b", "  assert(a > b)\n  return setmetatable({}, {__mode = \"kv\"})\nend",
  "  local results = {}\n  for i = a, b do\n    table.insert(results, i)\n  end\n\
    \  table.sort(results)\n  return results\nend", "  if a > b then\n    return {}\n\
    \  else\n    local result = {}\n    local i = 1\n    while i <= a do\n      result[i]\
    \ = i\n      i = i + 1\n    end\n    i = a + 1\n    while i <= b do\n      result[i]\
    \ = i\n      i = i + 1\n    end\n    return result\n  end\nend", "  if b == nil\
    \ then b = a end\n  local is = {}\n  for _ = a..(b-1) do\n    table.insert(is,\
    \ math.floor(rand()*10))\n  end\n  return table.concat(is)\nend", "  local r =\
    \ {}\n  for i = b, 1, -1 do\n    if i >= a and i % a == 0 then\n      table.insert(r,\
    \ i)\n    end\n  end\n  return r\nend", "    if a < 1 then return {} end\n   \
    \ if b < 1 then return {} end\n    local ret = {}\n    local i = 1\n    while\
    \ i <= a or i <= b do\n        local c = math.mod(a, 10)\n        a = math.floor(b\
    \ / 10)\n        b = c * 10 + b\n        ret[#ret + 1] = i\n        i = i + 1\n\
    \    end\n    return ret\nend", "   local result = {}\n   local i = a\n   while\
    \ i < b do\n      table.insert(result, i)\n      i = i + 1\n   end\n   return\
    \ result\nend", "    -- The first step consists of finding all of the factors\
    \ of a and b\n    local factors = {}\n    local factor_a = 1\n    local factor_b\
    \ = 1\n    local factor = 0\n    -- The algorithm keeps running until either b\
    \ or a is too small\n    while factor_a <= a and\n           factor_b <= b and\n\
    \           factor <= b\n    do\n        -- If b is a factor of a and we're now\
    \ looking for a factor, then\n        -- we move on to the next factor\n     \
    \   if factor_b == factor then\n            factor_b += 1\n        else\n    \
    \        -- Otherwise, if the current factor is larger than the one we are\n \
    \           -- looking for, then we'll move on to another factor\n           \
    \ if factor < b then\n                factor = 1\n                factor_b +=\
    \ 1\n            else\n                -- Otherwise, we know that the current\
    \ factor is smaller than the\n                -- one we're looking for, so we'll\
    \ move on to it\n                factor_b = factor\n                factor = 1\n\
    \            end\n        end\n        factors[factor] = factors[factor] + 1\n\
    \        factor = factor + 1\n    end\n    -- Now that the factors have been found,\
    \ it's easiest to just remove\n    -- factors of one until we get to the factors\
    \ of a and b\n    local integer_a = a\n    local integer_b = b\n    local factor\
    \ = 1\n    local i = 1\n    while i <= a do\n        if factors[factor] == i then\n\
    \            integer_a = integer_a - factor\n            factor = factor + 1\n\
    \        else\n            integer_a = integer_a - factor\n            factor\
    \ = factor + 1\n        end\n        i = i + 1\n    end\n    while i <= b do\n\
    \        if factors[factor] == i then\n            integer_b = integer_b - factor\n\
    \            factor = factor + 1\n        else\n            integer_b = integer_b\
    \ - factor\n            factor = factor + 1\n        end\n        i = i + 1\n\
    \    end\n    return integer_a, integer_b\nend", "  local num_digits = math.floor(math.abs(a\
    \ - b) / 2) + 1\n  local i = 0\n  local results = {}", "  if b < a then\n    return\
    \ {}\n  end\n  local result = {}\n  for i = a to b do\n    table.insert(result,\
    \ i)\n  end\n  table.sort(result)\n  return result\nend", "    local a_pieces\
    \ = a / 2\n    local b_pieces = b / 2\n    local results = {}\n    for i = 0,\
    \ a_pieces do\n        if i < b_pieces then\n            table.insert(results,\
    \ i)\n        else\n            break\n        end\n    end\n    for i = a_pieces\
    \ + 1, b_pieces do\n        table.insert(results, i)\n    end\n    if a % 2 ~=\
    \ 0 and b % 2 ~= 0 then\n        table.insert(results, (a - 1) * 2 +  b)\n   \
    \     table.insert(results, (a - 1) * 2 +  b)\n    end\n    if a % 2 == 0 and\
    \ b % 2 == 0 then\n        table.insert(results, a)\n        table.insert(results,\
    \ b)\n    end\n    return results\nend", "  local v = {}\n  for i=a,b do v[i]\
    \ = nil end\n  return v\nend", "  if b < a then\n    local t = b\n    b = a\n\
    \    a = t\n  end\n  local digits = {}\n  -- Generate all integers from 2 to a,\
    \ inclusive\n  for i = 2, a do\n    -- Add digits that are multiples of i to digits\n\
    \    for d = 0, i do\n      digits[d] = digits[d] or i\n    end\n    -- Add digits\
    \ that are multiples of a\n    for d = 0, a do\n      digits[d] = digits[d] or\
    \ a\n    end\n  end\n  -- Remove duplicate digits\n  table.sort(digits, compare)\n\
    \  -- Return digits from b to a, in ascending order\n  -- This part makes sure\
    \ that the last digit in ascending order is smaller than the rest\n  for i = b,\
    \ a do\n    table.insert(digits, i - 1)\n  end\n  table.sort(digits, compare)\n\
    \  return digits\nend", "    local s = \"\"\n    for i = a, b do\n        local\
    \ c = math.floor(i/10)\n        s = s .. tostring(c) .. tostring(i%10) .. \" \"\
    \n    end\n    return string.gsub(s, \"( [^ ]*) $\", \"%1\")\nend\n</cell>\n<text>\n\
    Next we need to add some utilities for dealing with the data.", "  -- The result\
    \ will always be ascending order\n  assert(b > 0)\n  local result = {}\n  -- The\
    \ final element will be the smallest possible number\n  -- greater than or equal\
    \ to \"b\" that is less than or equal\n  -- to \"a\"\n  --\n  -- The \"result\"\
    \ array is initialized to \"b\".\n  --\n  -- Note that because we know that \"\
    b\" must be larger than or equal\n  -- to \"a\", we only need to test values \"\
    b\" to \"a\".\n  local x = b\n  while x <= a do\n    result[#result + 1] = x\n\
    \    x = math.floor((a + x) / 2)\n  end\n  return result\nend", "  if a < b then\n\
    \    generate_integers(b, a)\n  else\n    -- First determine which integers are\
    \ already in range.\n    local is = {}\n    for i = a, 1, -1 do\n      if is[i]\
    \ then break end\n      is[i] = true\n      table.insert(i, 0)\n    end", "  local\
    \ n = a\n  if b > a then\n    n, a = b, a\n  end\n  local ret = {}\n  for i =\
    \ a, n do\n    table.insert(ret, i)\n  end\n  return ret\nend", "  local seq =\
    \ {}\n  for i=a, 1, -1 do\n    table.insert(seq, i)\n    if i <= b then\n    \
    \  table.insert(seq, i)\n    end\n  end\n  return setmetatable({}, {__mode=\"\
    v\"})\nend", "  local result = {}\n  for i = a; i <= b do\n    table.insert(result,\
    \ math.floor(i))\n  end\n  return result\nend", "  if b == nil then\n    b = a\n\
    \    a = nil\n  end\n  if a then\n    local temp, count = 1\n    for i = a, b\
    \ do\n      temp = (temp * 10) + i\n      count = count + 1\n    end\n    if count\
    \ < 2 then\n      return nil\n    end\n    -- now temp is of the form {a, b} ->\
    \ {a, 1, a, b*b}\n    -- so return the first two terms only\n    for i = 1, 2\
    \ do\n      if not temp then break end\n      table.insert(res, temp[i])\n   \
    \ end\n  end\n  return res\nend", "    if a < b then\n        return {}\n    end",
  "  local function gen(i)\n    if i < a then\n      local n = math.floor(i / 10)\
    \ * 10\n      if n % 2 ~= 0 then\n        return {n}\n      end\n      return\
    \ gen(i + 1) or {}\n    end\n    if i >= b then\n      return {b}\n    end\n \
    \   if a <= b then\n      return {a, b}\n    end\n  end\n  return gen(a) or gen(a\
    \ + 1)\nend", "  -- Generate all the integers between a and b and sort them.\n\
    \  local list = {}\n  for i = a, b do\n    list[#list + 1] = i\n  end\n  table.sort(list)\n\
    \  return list\nend", "  local ret = {}\n  local k = 1\n  for i = a, b + 1 do\n\
    \    if i ~= k then\n      ret[k] = i\n    end\n    k = k + 1\n  end\n  return\
    \ ret\nend", "    local digits = {}\n    for i = a, b do\n        digits[i] =\
    \ 1\n    end", "\tlocal t = {}\n\tlocal d = 0\n\twhile a <= b do\n\t\tt[#t + 1]\
    \ = math.floor(a * (b - a + 1) / d)\n\t\td = d * 10\n\tend\n\treturn t\nend",
  "  if a > b then\n    generate_integers(b, a)\n  end", "  local results = {}\n \
    \ for i = a, b do\n    table.insert(results, i / 10)\n  end\n  return results\n\
    end", "  if a <= b then\n    return nil\n  end", "    if a < b then\n        generate_integers(b,\
    \ a)\n    end", "  if b > a then\n    a, b = b, a\n  end\n  assert(a <= b)\n \
    \ local results = {}\n  for i = a, 1 do\n    table.insert(results, i)\n  end\n\
    \  for i = 1, b do\n    table.insert(results, 0)\n  end\n  return results\nend",
  "  if a < b then\n    a, b = b, a\n  end\n  local v = {}\n  repeat\n    table.insert(v,\
    \ math.floor(a/b))\n    a = a - v[#v] * b\n  until a < b\n  return v\nend", " \
    \ if a > b then a, b = b, a end\n  local results = {}\n  for i = a, b do\n   \
    \ table.insert(results, i)\n  end\n  return results\nend", "    if a <= b then\n\
    \        local i, imax = a, a + b\n        while i <= imax do\n            insert(integer_generator,\
    \ i)\n            i = i + b\n        end\n    end\nend", "  local i = 0\n  while\
    \ i < b do\n    table.insert(result, math.floor(a*b / i))\n    i = i + 1\n  end\n\
    \  table.sort(result)\n  assert(#result < b - a)\n  return result\nend", "  local\
    \ results = {}\n  if a < b then\n    local aux = generate_integers(b, a)\n   \
    \ for i = 0, #aux do\n      results[i] = aux[i]\n    end\n  end\n  for i = a,\
    \ b do\n    results[i] = i\n  end\n  return results\nend", "  if a < b then\n\
    \    generate_integers(b, a)\n  elseif b <= 0 then\n    return {}\n  else\n  \
    \  local c = a\n    local d = b\n    local list = {}\n    while c <= d do\n  \
    \    list[c] = c\n      c = c + 1\n    end\n    return list\n  end\nend", "  \
    \  local n\n    -- Initialize our set.\n    local ret = {}\n    -- If either number\
    \ is bigger than the other, return an empty set.\n    if a > b then\n        return\
    \ ret\n    end\n    -- Get our numbers into a table and sort them.\n    local\
    \ num = { }\n    for _ = a, b do\n        table.insert(num, _)\n    end\n    table.sort(num)\n\
    \    -- Iterate through our sorted numbers and return only the even ones.\n  \
    \  for _ = 1, #num do\n        if num[_] % 2 == 0 then\n            table.insert(ret,\
    \ num[_])\n        end\n    end\n    -- Return the resulting set.\n    return\
    \ ret\nend", "\tassert(a < b)\n\tlocal ans = {}\n\tfor i = math.floor(a/2), b\
    \ + 1 do\n\t\ttable.insert(ans, i)\n\tend\n\treturn ans\nend", "    local digits\
    \ = {}\n    local i = a\n    while i <= b do\n        digits[i] = i\n        i\
    \ = i + 1\n    end\n    return digits\nend", "    if b > 0 then\n        -- Generate\
    \ the first set of integers up until b, inclusive\n        return generate_integers(0,\
    \ b)\n    else\n        -- Generate the first set of integers a to (a - 1), inclusive\n\
    \        return generate_integers(a, a+1)\n    end\nend", "  if a < b then\n \
    \   generate_integers(b, a)\n  else\n    local ret = {}\n    for i = math.min(a,\
    \ b) - 1, 1, -1 do\n      table.insert(ret, i)\n    end\n    return ret\n  end\n\
    end", "    -- Generate an infinite sequence of integers up to, but not including,\
    \ b. \n    -- This implementation is based on Python's range function, which accepts\
    \ a\n    -- start and an end integer and generates an infinite sequence of numbers\n\
    \    -- between them.\n    -- Reference: https://docs.python.org/2/library/functions.html#range\n\
    \    -- Reference: http://stackoverflow.com/questions/2416155/how-do-i-generate-an-evenly-spaced-sequence-of-numbers-in-python\n\
    \    local seq = setmetatable({}, {__mode=\"k\"});\n    seq.__index = seq;\n \
    \   seq.__mode = \"i\";\n    seq.__seq = setmetatable({},{__mode=\"k\"});\n  \
    \  seq.__seq.__index = seq;\n    seq.__seq.__mode = \"a\";\n    seq.__seq.__seq\
    \ = {}\n    seq.__seq.__seq[1] = a;\n    while seq.__seq.__seq[seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__seq.__",
  "  -- First step is to generate all the numbers between a and b.\n  -- This means\
    \ that we will need to:\n  --\n  --   1) Generate each number between a and b\
    \ (including both a and b).\n  --   2) Filter those numbers that aren't divisible\
    \ by a given value.\n  --   3) Sort the generated numbers.\n  --\n  --   To achieve\
    \ step 1, we could simply generate a table of the numbers\n  --   between a and\
    \ b and then filter that table, but that would require us\n  --   to generate\
    \ and store all the numbers up to and including b.\n  --\n  --   To achieve step\
    \ 2, we can use a stack to generate each number between a\n  --   and b and then\
    \ filter those numbers that don't divide by a given value.\n  --   This means\
    \ that in step 2 we can keep pushing numbers onto the stack\n  --   until the\
    \ stack is empty, at which point we can generate the numbers.\n  --\n  --   To\
    \ achieve step 3, we can simply use another stack to generate the numbers\n  --\
    \   in ascending order, then we can reverse the order of the stack and\n  -- \
    \  return the result.", "  if b > a then\n    return {}\n  else\n    local c =\
    \ math.floor((b - a) / 2)\n    return generate_integers(c, b) .. generate_integers(a,\
    \ c - 1)\n  end\nend", "    local results = {}\n    for i = a, b do\n        table.insert(results,\
    \ i)\n    end\n    return results\nend", "  if a < b then\n    local tmp = a\n\
    \    a = b\n    b = tmp\n  end\n  local results = {}\n  local x = math.ceil(b\
    \ / 2)\n  local i = a\n  while i <= b do\n    table.insert(results, i)\n    i\
    \ = i + x\n  end\n  return results\nend", "  local c = math.random(a, b)\n  while\
    \ c >= a and c <= b do\n    c = math.random(a, b)\n  end\n  return c\nend", " \
    \ local start = a or 1\n  local end = b or 10\n  local digits = {}\n  local counter\
    \ = start\n  while counter <= end do\n    digits[counter] = counter\n    counter\
    \ = counter + 1\n  end\n  return digits\nend", "    -- If b > a then swap them\n\
    \    if b > a then\n        local t = a\n        a = b\n        b = t\n    end\n\
    \    -- A map of the digits\n    local numbers = {}\n    -- For each digit starting\
    \ at a and ending at b:\n    for i = a, math.min(b-1, #a+1) do\n        -- If\
    \ the digit is even, add it to the set\n        if i % 2 == 0 then\n         \
    \   table.insert(numbers, i)\n        end\n    end\n    -- Return an empty set\
    \ if there is no even digits\n    return #numbers > 0 and numbers or {}\nend",
  "  local nums = {}\n  for i = math.min(a, b) do\n    table.insert(nums, i)\n  end\n\
    \  return nums\nend", "  if b < a then\n    return {}\n  end\n  local c = 0\n\
    \  -- TODO: Maybe this could be done better.\n  -- Perhaps we could have a counter\
    \ that stores the current highest digit\n  -- and then use that to determine the\
    \ next highest digit.\n  -- TODO: This could be done by incrementing the counter\
    \ by 1\n  -- each time the new highest digit is larger than the current value.\n\
    \  -- That would allow us to have fast lookup and insertion.\n  -- This would\
    \ also be more efficient, but less clean.\n  local highest_digit = 0\n  local\
    \ current = a\n  repeat\n    highest_digit = math.floor(b / 10)\n    current =\
    \ math.floor(b / highest_digit) * 10 + highest_digit\n    -- Store the new value\
    \ at the next highest digit.\n    local next_highest_digit = math.floor(b % highest_digit)\n\
    \    table.insert(b, next_highest_digit)\n    -- If the highest digit is zero,\
    \ stop.\n    -- If it is one, then we have found the answer.\n    -- If it is\
    \ greater than one, increment by one and continue recursing.\n    if highest_digit\
    \ == 0 then\n      break\n    elseif highest_digit == 1 then\n      return current\
    \ + generate_integers(a, b)\n    end\n    -- Decrement by one.\n    -- This ensures\
    \ that we only ever call our function with positive numbers.\n    -- For negative\
    \ numbers we might call it with a negative number instead.\n    b = b - 1\n  until\
    \ true -- Infinite loop.\n  return current\nend\n</code>\n<|/ a tags=math,integer,algorithm,integer-arithmetic\
    \ |>\n<| a dscore=2 |>\nThis is a recursive solution in Python:\n<code>\ndef solve(num):\n\
    \    if num==0: return [num]\n    if num==1: return num\n    if num<0: return\
    \ solve(-num)\n    digits = []\n    while num > 0:\n        digits.append(num\
    \ % 10)\n        num = num // 10\n    digits.reverse()\n    return solve(num //\
    \ 10) + digits[0:len(digits)-1]", "  local result = {}\n  assert(b > a and b >\
    \ 0, \"Both input parameters must be positive.\")\n  while b > 0 do\n    table.insert(result,\
    \ math.floor(a))\n    a = math.floor(a/10)\n    b = b - 1\n  end\n  return result\n\
    end", "  if a >= b then\n    return {}\n  end\n  local is = {}\n  local n = 1\n\
    \  while a < b do\n    local k = math.floor(a * 10) + math.floor((a % 10) * math.pow(10,\
    \ n))\n    table.insert(is,k)\n    a = a + 1\n    i = i + 1\n    if i == 19 then\n\
    \      n = 1\n    else\n      n = n + 1\n    end\n  end\n  return is\nend", " \
    \ local results = {}\n  for i = a, b do\n    results[i] = true\n  end\n  table.sort(results)\n\
    \  return results\nend", '  if b - a < 1 then return {} end', "  local function\
    \ sort(a, b)\n    return a < b\n  end\n  return a:map(function (x)\n    return\
    \ x % b\n  end)\n  :filter(function (x)\n    return x ~= 0\n  end)\n  :sort(sort)\n\
    end\ngenerate_integers = generate_integers", "  local numbers = {}\n  for i =\
    \ a, b do\n    table.insert(numbers, i)\n  end\n  table.sort(numbers)\n  return\
    \ numbers\nend", "  assert(a ~= nil, \"'a' must be given\")\n  assert(b ~= nil,\
    \ \"'b' must be given\")\n  assert(a > b, \"'a' must be greater than 'b'\")\n\
    \  assert(a > 0, \"'a' must be positive\")\n  assert(b > 0, \"'b' must be positive\"\
    )\n  assert(a <= 10, \"'a' must be less than 10\")\n  assert(b <= 10, \"'b' must\
    \ be less than 10\")\n  local ai, bi = 1, 1\n  while bi > 0 do\n    if a % 2 ==\
    \ 0 then\n      table.insert(result, a % 10)\n      a = a / 10\n      bi = bi\
    \ -1\n    else\n      table.insert(result, b % 10)\n      b = b / 10\n      ai\
    \ = ai -1\n    end\n  end\n  return result\nend", "    if b < 0 then\n       \
    \ error(\"Must specify a positive integer\")\n    end\n    if b == 0 then\n  \
    \      -- Special case for 0.\n        return {a}\n    end", "  assert(a > 0 and\
    \ b > 0, \"Invalid input: Must be a positive integer.\")\n  assert(a <= b, \"\
    Invalid input: Must be a smaller integer.\")\n  local function is_odd(x)\n   \
    \ return math.floor(x * 2) % 2 ~= 0\n  end", "    if b < 0 then return end\n \
    \   return setmetatable({}, {\n        __index = function(t, k)\n            local\
    \ v = math.mod(k, 10)\n            local n = k - 10*v\n            if n < a then\
    \ return end\n            if n > b then return end\n            return v\n   \
    \     end\n    })\nend\ngenerate_integers.cache = {}", "    local lst = terralib.newlist()\n\
    \    local carry = 0\n    for i = a, 1, -1 do\n        -- The remainder when dividing\
    \ by 10 will be between 0 and 9. We\n        -- add the remainder to the previous\
    \ number and multiply by 10 to get\n        -- a new number. Then, we add the\
    \ carry.\n        lst:insert(100 * i % 10 + carry) -- TODO: check for overflow\n\
    \        carry = ((100 * i) / 10) % 10\n    end", "  return setmetatable({\n \
    \   start = math.floor(a),\n    stop = math.floor(b),\n  }, mt)\nend", "  if b\
    \ < 0 then return nil end\n  if a <= b then return {} end", "  -- Find the first\
    \ number which satisfies `a <= x <= b`.\n  local function find_first_integer(a,\
    \ b)\n    local i = b\n    local m = math.floor(b)\n    while i >= a do\n    \
    \  i = i - m\n      if i >= a then break end\n    end\n    return i\n  end", " \
    \ if b < a then\n    local tmp = generate_integers(b, a)\n    for _, v in pairs(tmp)\
    \ do\n      tmp[v] = b\n    end\n    return tmp\n  end", "  if b < a then return\
    \ nil end\n  local r = {}\n  for i = a, 1, -1 do\n    if i % b == 0 then\n   \
    \   table.insert(r, i)\n    end\n  end\n  return r\nend", "\tassert(b > 0, \"\
    b must be positive\")\n\tassert(a > 0, \"a must be positive\")", "  local set\
    \ = {}\n  for i = a, b do\n    set[i] = true\n  end\n  while #set > 0 do\n   \
    \ set = {}\n    for i = a, b do\n      set[i] = true\n    end\n    -- remove all\
    \ even values from set\n    for i = b, #set, 2 do\n      set[i] = false\n    end\n\
    \  end\n  return set\nend", "  if a > b then\n    a, b = b, a\n  end\n  local\
    \ c = math.floor(a/10)\n  local d = (a - c*10)/10\n  return generate_integers(b,\
    \ c) or {c+d, c+1}\nend", "  if a > b then\n    a, b = b, a\n  end\n  return b\
    \ == 0 or b == 1 or a % b == 0 and (b - 1) % a or {}\nend", "  -- Initialize our\
    \ empty output vector.\n  local output = {}\n  -- Start at a and step up b until\
    \ the number we generate is no more than\n  -- the number we're after.\n  while\
    \ b > 0 do\n    -- Add the number we generated up to b.\n    table.insert(output,\
    \ math.floor(a))\n    -- Decrement b by one to keep our code simple.\n    local\
    \ b-- = b - 1\n  end\n  -- Reverse our final output vector.\n  table.sort(output)\n\
    \  -- Return the final output vector.\n  return output\nend", "  local results\
    \ = {}\n  for i=a,b,1 do\n    local remainder = math.mod(i, 10)\n    results.insert(remainder)\n\
    \  end\n  return results\nend", "    local res = {}\n    for i = a, b do\n   \
    \     local n = 1\n        while i > 0 do\n            i = i / 10\n          \
    \  n = n * 10\n        end\n        if n >= 10 then\n            res[#res + 1]\
    \ = n % 10\n        end\n    end\n    return res\nend", "  local digits = setmetatable({},\
    \ {\n    __index = function(t, k)\n      if k < a then\n        error(\"Index\
    \ must be >= to start index\")\n      elseif k > b then\n        error(\"Index\
    \ must be <= to end index\")\n      elseif k == a then\n        -- If we've got\
    \ all the way through a, we know that b must be\n        -- larger than a, so\
    \ start from b again rather than continuing the\n        -- process.\n       \
    \ local last_k = k\n        while k == last_k do\n          k = k + 1\n      \
    \  end\n      end\n      local result = {}\n      for i = k, a + 1 do\n      \
    \  result[i] = 1\n      end\n      return result\n    end\n  })\n  -- This is\
    \ slightly faster than using a for loop:\n  -- `digits = { k + 1, #digits }`\n\
    \  -- This is because for loops start at the head of the table and iterate\n \
    \ -- over the tail of the table.\n  for i = b, a + 1 do\n    digits[i] = 1\n \
    \ end\n  return digits\nend", "    if a < 2 then\n        -- Nothing to do.\n\
    \        return {}\n    end", "  local start = math.min(a, b)\n  local stop =\
    \ math.max(a, b)\n  local results = {}\n  for i = start, stop do\n    table.insert(results,\
    \ tostring(i))\n  end\n  return results\nend", "  local n\n  -- Create a list\
    \ containing all integers between a and b inclusive.\n  for n = a:b+1 do\n   \
    \ local digit = math.floor(n)\n    -- If the number is even, insert it into the\
    \ list.\n    if n % 2 == 0 then\n      table.insert(result, digit)\n    end\n\
    \  end\n  -- Return the list with odd (even) digits removed.\n  return table.sort(result)\n\
    end", "  if a == b then return {} end\n  local digits = {}\n  local last_digit\
    \ = 0\n  local next_digit = 1\n  for i = a, b do\n    while next_digit <= 10 do\n\
    \      table.insert(digits, next_digit)\n      next_digit = next_digit + 1\n \
    \   end\n    last_digit = last_digit - 1\n    next_digit = 1\n  end\n  if last_digit\
    \ > 0 then\n    table.insert(digits, last_digit)\n  end\n  return digits\nend",
  "    local c\n    for c = math.floor(a) do a = a % c + c end\n    for c = math.floor(b)\
    \ do b = b % c + c end\n    for c = a+1 do a = a % c + c end\n    for c = b+1\
    \ do b = b % c + c end\n    return a >= 0 and b >= 0 and a and b and c or nil\n\
    end", "  local num_results = {}\n  local last_value = b\n  for i=a,a,-1 do\n \
    \   local value = last_value - i\n    local current = i\n    while value >= 2\
    \ do\n      num_results[current] = value\n      last_value = current\n      current\
    \ = current + i\n    end\n  end\n  return num_results\nend", "  if b < 0 then\n\
    \    error(\"second argument cannot be negative\")\n  end", "    local lst_a =\
    \ tonumber(a) or 1\n    local lst_b = tonumber(b) or 1", "  if b < a then\n  \
    \  a, b = b, a\n  end\n  return setmetatable({}, {\n    __index = function(t,\
    \ k)\n      if a <= k <= b then\n        return math.floor(k / 10) + t[k]\n  \
    \    else\n        return nil\n      end\n    end,\n    __newindex = function(a,\
    \ k, v) -- NOOP\n    end\n  })\nend", "  if a <= b then\n    return {}\n  end\n\
    \  local numbers = {}\n  for i = a, b do\n    table.insert(numbers, math.floor(i))\n\
    \  end\n  return numbers\nend", "  -- Initialise our set\n  local ans = {}\n \
    \ for i = a, b do\n    -- Test the digit, pushing it to the set\n    if i ~= 0\
    \ then\n      local c = math.mod(i, 10)\n      if not ans[c] then\n        ans[c]\
    \ = true\n      end\n    end\n  end", '  local result = {}', "  if a < b then\n\
    \    -- Sort the range\n    generate_integers(b, a)", "   if b - a == 0 then return\
    \ {} end\n   local c = 0\n   local result = {}\n   for i = a, b do\n      result[c]\
    \ = i\n      c = c + 1\n   end\n   return result\nend", "  assert(a < b, \"Expected\
    \ a < b but got a < b\")\n  if b > 0 then\n    local r = {}\n    for i = a, 1,\
    \ -1 do\n      if i / b * b == i then\n        table.insert(r, i)\n      else\n\
    \        break\n      end\n    end\n    return r\n  else\n    local r = {}\n \
    \   for i = 1, a do\n      if i % b * a == i then\n        table.insert(r, i)\n\
    \      else\n        break\n      end\n    end\n    return r\n  end\nend", " \
    \   local result = {}\n    for i = a, b do\n        table.insert(result, math.floor((math.random(100)\
    \ + 1)*math.pow(2, i - a)))\n    end\n    return result\nend", "  assert(a <=\
    \ b, 'Given two positive integers a and b, return the even digits between a and\
    \ b, in ascending order.')\n  local result = {a, b}\n  while #result < a do\n\
    \    table.insert(result, b)\n  end\n  return result\nend\ngenerate_integers(1,\
    \ 9)", "  if b == 0 then\n    return nil\n  end\n  if a <= 0 then\n    return\
    \ {0, a}\n  end\n  local results = {}\n  local last_digit = 0\n  for i = math.floor(a),\
    \ math.ceil(b) do\n    last_digit = last_digit + math.floor((i - a) * 10 ^ i)\n\
    \    table.insert(results, last_digit)\n  end\n  return results\nend", "  if b\
    \ == 0 then return nil end\n  if a < b then return nil end\n  local t = {}\n \
    \ for i = a, b do\n    t[i] = 1\n  end\n  while #t ~= 0 do\n    table.insert(t)\n\
    \  end\n  return t\nend", "    local r = {a}\n    repeat\n        local t = generate_integer(math.ceil(b/a))\n\
    \        r[#r + 1] = t\n        b = t - a*math.floor(t/a)\n    until b == 0\n\
    \    return r\nend", '  if b < a then return end', "    local res = {}\n    while\
    \ a <= b do\n        local digit = math.floor((a - b) / 2)\n        table.insert(res,\
    \ digit)\n        a = math.floor((a + b) / 2)\n    end\n    table.sort(res)\n\
    \    return res\nend", "  -- The input is a range to generate integers from inclusive.\n\
    \  -- The output is a set of integers.\n  -- So we can't just increment a and\
    \ b.\n  -- Instead, keep a running tally of the digits we've seen.\n  local seen\
    \ = a < b\n  and {} or setmetatable({ a = a }, { __index = function(t, k)\n  \
    \    if seen[k] then return {} end\n      local n = math.floor((k - a + 1) / 2)\n\
    \      seen[k] = true\n      t[k] = t[k] or 0\n      t[k + 1] = t[k + 1] or 0\n\
    \      t[n + t[k] + 1] = k\n      return\n    end\n  })\n  -- Iterate over the\
    \ remainder, add digits as needed.\n  local t = {}\n  while a < b do\n    local\
    \ n = math.floor((b - a) / 2)\n    local s = t[n + 1] + 1\n    if s == a then\n\
    \      t[n + 1] = a\n    else\n      local remaining = b - s - 1\n      t[n +\
    \ 1] = a\n      for i = s - 1, -1, -1 do\n        t[n + i] = remaining\n     \
    \   remaining = remaining - 2 * i + a\n      end\n    end\n    a = a + s - 1\n\
    \  end\n  return t\nend", "  if a < b then\n    generate_integers(b, a)\n  end\n\
    \  return setmetatable({\n      a  = a,\n      b  = b,\n      a2 = a / 2,\n  \
    \    b2 = b / 2,\n      r  = (a % 2 == 0 and b % 2 == 0) or (a % 2 == 1 and b\
    \ % 2 == 1)\n    }, mt)\nend", "  local numbers = {}\n  while a < b do\n    table.insert(numbers,\
    \ a)\n    a = a + (a%10) + 1 -- (a%10) = remainder and (a/10) = digit\n  end\n\
    \  table.insert(numbers, b)\n  return numbers\nend", "  local result = {}\n  for\
    \ i = a, b do\n    table.insert(result, i % 10)\n  end\n  return result\nend\n\
    </cell>\n<cell>", "  local integers = {}\n  while a <= b do\n    table.insert(integers,\
    \ a)\n    a = a * 2\n  end\n  return integers\nend", "  if a < 1 or a > b then\
    \ return end\n  if b == 0 then return {1}; end\n  local n = 1\n  while n < b do\n\
    \    table.insert(a, n)\n    table.insert(a, 0)\n    n = n + 2\n  end\n  return\
    \ a\nend", "  assert(type(a) == \"number\" and type(b) == \"number\" and b > 0)\n\
    \  local result = {}\n  for i = a, b do result[#result + 1] = i end\n  return\
    \ result\nend", "  if b < 0 then\n    return {}\n  else\n    local result = {}\n\
    \    for x = a, b do\n      result[#result + 1] = x\n    end\n    return result\n\
    \  end\nend", "    local numbers = {}\n    local max = math.max(a, b)\n    if\
    \ max < 10 then\n        for i = 1, 10 do\n            numbers[i] = 1\n      \
    \  end\n    end\n    for d = 1, max do\n        if a >= d then\n            numbers[a]\
    \ = 0\n        end\n        numbers[d] = 1\n        a = math.trunc(a / 10)\n \
    \       b = math.trunc(b / 10)\n    end\n    if a > 0 then\n        numbers[a]\
    \ = 0\n    end\n    if b > 0 then\n        numbers[b] = 0\n    end\n    return\
    \ numbers\nend", "    local lst = {}\n    for x = b - a + 1 do\n        for i\
    \ = 1, x do\n            lst[a + i] = i\n        end\n    end\n    return lst\n\
    end", "  -- We assume a < b.\n  -- If the input numbers are sorted, this would\
    \ be easy.\n  -- But since this is a sorted array, we could also take advantage\
    \ of the\n  -- fact that the input array is sorted to avoid searching.\n  -- For\
    \ each number in a, check if it is a multiple of b.\n  --\n  -- If b is a power\
    \ of 2, the exponent can be computed without searching\n  -- -- because we can\
    \ use binary search.\n  -- If the exponent is even, we can use binary search to\
    \ find the middle value\n  -- of b.\n  -- If the exponent is odd, then we know\
    \ that either there is an even number\n  -- in a, or a lower number that divides\
    \ b and we are done.\n  --\n  -- If b is not a power of 2, we can do binary search\
    \ to find the middle value\n  -- of a and check if it divides b.\n  local results\
    \ = {}\n  if b == 2 then\n    local power, exp = b:bits():divmod(2)\n    if exp\
    \ == 0 then\n      results = {b}\n    elseif exp == 1 then\n      results = {b}\n\
    \    else\n      local m = (math.floor(b / 2) + 1):bits()\n      for i = a:bits()\
    \ - m + 1 do\n        local r = i / b\n        if r:bits() % 2 == 1 then\n   \
    \       results:insert(r)\n        end\n      end\n    end\n  else\n    -- We\
    \ know that the input numbers are all smaller than 2^b. Therefore,\n    -- we\
    \ can take advantage of this fact to find the exponent in a much faster\n    --\
    \ way.\n    -- Start with the largest power of 2 less than or equal to the input\n\
    \    -- numbers. This also makes sure that the exponents are in descending order.\n\
    \    local power, exp = math.floor(b / 2):bits():divmod(b)\n    local result =\
    \ {}\n    while a > 0 do\n      local m = math.floor((a - 1):bits() / b) -- Find\
    \ the middle value.\n      -- If the middle value is a power of 2, we can take\
    \ advantage of it to\n      -- avoid searching. If it is not, then we will have\
    \ to do a search in\n      -- order to find the middle value.\n      if m == 0\
    \ then\n        result:insert(a)\n        break\n      else\n        local r =\
    \ ((m:bits() + 1) % b + 1):bits()\n        if r == m then\n          result =\
    \ {r}\n        end\n      end\n      a = m\n    end\n    exp = exp * 2 - 1\n \
    \   results = table.concat(result, \",\")\n  end\n  table.sort(results)\n  assert(results[1]\
    \ == nil)\n  assert(results[#results] == nil)\n", "  local result = {}\n  local\
    \ i = 1\n  while i <= b do\n    local current = math.floor(a * math.pow(10, i))\n\
    \    table.insert(result, current)\n    i = i + 1\n  end\n  table.sort(result)\n\
    \  return result\nend", "  local digits = {}\n  for i = a, b do digits[i] = 1\
    \ end\n  digits[a] = true\n  local num = 2\n  local i = 1\n  while i <= a or i\
    \ <= b do\n    digits[i] = false\n    i = i + 1\n  end\n  for i = a, b do\n  \
    \  if digits[i] then print(num) end\n    num = num * 10 + 1\n  end\nend", "  \
    \  local integers = {}\n    local i = 1\n    while i <= a or i <= b do\n     \
    \   table.insert(integers, i)\n        i = i + 1\n    end\n    return integers\n\
    end", "    local i = {}\n    for i=a+1, b do\n        if i % 2 ~= 0 then\n   \
    \         table.insert(i, i)\n        end\n    end\n    return i\nend", "  assert(b\
    \ > a)\n  local result = {}\n  for i = math.min(a, b) do\n    table.insert(result,\
    \ i)\n  end\n  return result\nend", "  local results = {}\n  local i = 0", " \
    \   local i = {}\n    local n\n    -- Generate all powers of 2, from 0 to 2^31-1\n\
    \    do n = 2^31; while n > 1; n = n/2 end\n    -- Add 1 to the power of 2 until\
    \ a >= 2^31-1, or b > 2^31-1\n    while a < 2^31 or b > 2^31 do\n        local\
    \ t = a\n        a = b\n        b = t\n    end\n    -- Add the digits in the range\n\
    \    for n = a, n * 10 + b, n <= 2^31 and n + 10, n <= 2^31, n <= 2^31 + 10 do\n\
    \        table.insert(i, n)\n    end\n    return i\nend", "    local result =\
    \ {}\n    for i = a, b do\n        local r = math.mod(i, 10)\n        if r and\
    \ r % 2 == 0 then\n            result[#result + 1] = r\n        end\n    end\n\
    \    if #result == 0 then result = nil end\n    return result\nend", "    local\
    \ t = {}\n    local carry = 1\n    for i = a, b do\n        table.insert(t, i)\n\
    \        while i > 0 do\n            i = i / 10\n        end\n        if i <=\
    \ 1 then\n            table.insert(t, carry)\n        end\n        carry = carry\
    \ * 10\n    end\n    return t\nend", "  -- Initialize our result set\n  local\
    \ result = {}\n  \n  -- Add each number between a and b, in ascending order\n\
    \  -- while taking into account the even digits\n  local current = a\n  while\
    \ current <= b do\n    -- If the current number is even, add it to the result\n\
    \    if current % 2 == 0 then\n      table.insert(result, current)\n    end\n\
    \    \n    -- Advance to next number\n    current = current + 1\n  end\n  \n \
    \ return result\nend", "  local results = {}\n  for i = 1, a do\n    local start\
    \ = math.floor((i - 1) / b)\n    local end\n    if i < (a / b) then\n      end\
    \ = (b - 1)\n    else\n      end = (a - (b * (i - 1)))\n    end\n    for j = start,\
    \ end do\n      results[#results + 1] = j\n    end\n  end\n  return results\n\
    end", "  if b - a <= 0 then return {} end\n  local digits = {}\n  for i = a, b\
    \ do\n    digits[i] = true\n  end\n  while b <= a do\n    -- Remove digits that\
    \ are in ascending order.\n    local t = a\n    a = b\n    b = t\n    for i =\
    \ a, b do\n      if digits[i] then digits[i] = nil end\n    end\n  end\n  return\
    \ digits\nend", "  local astr = tostring(a)\n  local bstr = tostring(b)\n  if\
    \ astr == bstr then\n    return {}\n  end\n  local astr = astr:gsub(\"%d+\", \"\
    \")\n  local bstr = bstr:gsub(\"%d+\", \"\")\n  local s = astr:sub(1, astr:len()\
    \ - 1)\n  local rest = astr:sub(astr:len() - 1)\n  local e\n  if bstr ~= bstr\
    \ or rest == \"\" then e = \"0\" end\n  else\n    local m = string.match(bstr,\
    \ \"^-?%d+\")\n    if m then\n      e = \"-1\"\n      bstr = bstr:gsub(\"%d+\"\
    , \"\")\n    else\n      e = \"1\"\n    end\n  end\n  -- Check range\n  local\
    \ range\n  if e == \"1\" then\n    local m = string.match(bstr, \"^-?%d+\")\n\
    \    if m then\n      range = m + 1 -- +1 is for \"-1\"\n    else\n      range\
    \ = a - 1\n    end\n  elseif e == \"-1\" then\n    range = string.match(bstr,\
    \ \"^%d+\")\n  end\n  assert(range ~= nil, \"Invalid range for a=\" .. a .. \"\
    , b=\" .. b)\n  local result = {}\n  for i = range, 1, -1 do\n    table.insert(result,\
    \ s)\n  end\n  -- Check for a wrap around\n  if range-1 > a then\n    table.insert(result,\
    \ \"\") -- This should be handled elsewhere\n  end\n  return result\nend", " \
    \  -- Initialize our result with empty numbers.\n   local result = {}\n   -- If\
    \ b is less than a, return {}.\n   if b < a then\n      return result\n   end\n\
    \   -- Loop through numbers between a and b.\n   for i = a, b do\n      -- If\
    \ the number is even, add it to our result.\n      if i % 2 == 0 then\n      \
    \   table.insert(result, i)\n      end\n   end\n   -- Return the result.\n   return\
    \ result\nend", '  local evens, odds = {}, {}', "  assert(a >= 0 and b > a)\n\
    \  local i = {}\n  for i = a, b do\n    table.insert(i, math.floor(i))\n  end\n\
    \  return i\nend", "    -- Return empty list if a=0, b=0, or a=b=0 (i.e. the result\
    \ is empty)\n    if a == 0 or b == 0 then\n        return nil\n    end\n    --\
    \ If a=0, the range is empty -- return all odd numbers between 0 and b\n    if\
    \ a == 0 then\n        local even = true\n        local next = 1\n        while\
    \ even do\n            even = false\n            local number = next\n       \
    \     next = next + 2\n            if number > b then\n                number\
    \ = b\n            end\n            table.insert(result, number)\n        end\n\
    \        return result\n    end\n    -- If b=0, the range is empty -- return all\
    \ even numbers between a and 0\n    if b == 0 then\n        local odd = true\n\
    \        local next = 1\n        while odd do\n            odd = false\n     \
    \       local number = next\n            next = next + 2\n            if number\
    \ > a then\n                number = a\n            end\n            table.insert(result,\
    \ number)\n        end\n        return result\n    end\n    -- If a>b, then there\
    \ aren't enough odd numbers between a and b.\n    -- Return the smallest odd number\
    \ less than or equal to a, i.e. b.\n    -- Note that this doesn't take into account\
    \ the case where a = b, but\n    -- this shouldn't be a problem when generating\
    \ numbers.\n    local number = b\n    local next = 1\n    while number > a do\n\
    \        number = next\n        next = next + 2\n    end\n    table.insert(result,\
    \ number)\n    return result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
