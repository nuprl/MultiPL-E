name: HumanEval_5_intersperse
language: lua
prompt: "-- Insert a number 'delimeter' between every two consecutive elements of\
  \ input table `numbers'\n-- >>> intersperse({}, 4)\n-- {}\n-- >>> intersperse({1,\
  \ 2, 3}, 4)\n-- {1, 4, 2, 4, 3}\nlocal function intersperse(numbers, delimeter)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = intersperse\n\
  \    lu.assertEquals(candidate({}, 7), {})\n    lu.assertEquals(candidate({5, 6,\
  \ 3, 2}, 8), {5, 8, 6, 8, 3, 8, 2})\n    lu.assertEquals(candidate({2, 2, 2}, 2),\
  \ {2, 2, 2, 2, 2})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    if delimeter == nil then\n        return numbers\n    end\n   \
    \ local result = {}\n    for _, v in ipairs(numbers) do\n        result[#result\
    \ + 1] = v\n    end\n    for i = 1, #result do\n        result[i] = result[i]\
    \ .. delimeter\n    end\n    return result\nend", "  if numbers == nil or not\
    \ numbers or #numbers <= 0 then\n    return numbers\n  end", "\tlocal result =\
    \ {}", "  local result = {}\n  for i = 1, #numbers do\n    table.insert(result,\
    \ numbers[i])\n    table.insert(result, delimeter)\n  end\n  return result\nend",
  "  if numbers == nil then return end\n  local new_number = numbers[1]\n  for i =\
    \ 2, #numbers do\n    new_number = new_number .. delimeter .. numbers[i]\n  end\n\
    \  return new_number\nend", "    local buffer = {}\n    for k, v in pairs(numbers)\
    \ do\n        buffer[k] = v\n    end\n    return table.concat(buffer, delimeter)\n\
    end", "    local newtable = table.copy(numbers)\n    for i = 1, #numbers, 2 do\n\
    \        newtable[i + ((i - 1) / 2)] = numbers[i - 1]\n        newtable[i + ((i\
    \ - 2) / 2)] = numbers[i + (delimeter - 1)]\n    end\n    return newtable\nend",
  "    local numbers_len = #numbers\n    local delimeter_len = #delimeter\n    local\
    \ output = table.Copy(numbers)\n    local i = 1\n    local j = numbers_len", " \
    \ local num_iter = numbers:__iter()\n  local delim_iter = delimeter:__iter()\n\
    \  local out = {}\n  local i = 1\n  repeat\n    out[#out + 1] = num_iter.next().value\n\
    \    i = i + 1\n  until #out >= i\n  while not delim_iter:next() == nil do\n \
    \   table.insert(out, delim_iter.next())\n  end\n  return out\nend", "   local\
    \ results = {}\n   for _, value in pairs(numbers) do\n      table.insert(results,\
    \ value)\n      if table.len(results) > 1 then\n         table.insert(results,\
    \ delimeter)\n      end\n   end\n   return results\nend", "  local result = {}\n\
    \  for i, number in ipairs(numbers) do\n    for j = 1, #result do\n      result[j]\
    \ = number .. delimeter\n    end\n    result[#result + 1] = number\n  end\n  return\
    \ result\nend", "   assert(type(numbers) == 'table', '`numbers' argument must\
    \ be a table')\n   assert(type(delimeter) == 'number', '`delimeter` argument must\
    \ be a number')", "  local result = {}\n  for _, v in ipairs(numbers) do\n   \
    \ result[#result + 1] = v\n  end\n  if #result == 0 then\n    return nil\n  end\n\
    \  result[#result] = delimeter\n  return result\nend", "  local output = { }\n\
    \  for key, value in pairs(numbers) do\n    table.insert(output, value)\n    table.insert(output,\
    \ delimeter)\n  end\n  return output\nend", "   local result = {}\n   for _, v\
    \ in ipairs(numbers) do\n      if #result == 0 then\n         table.insert(result,\
    \ v)\n      else\n         local element = result\n         for _ = 1, #element\
    \ do\n            table.insert(element, v)\n            table.insert(element,\
    \ delimeter)\n         end\n      end\n   end\n   return result\nend", "  local\
    \ nums = numbers[#numbers]\n  local i, j, k\n  local ret = {}\n  for i = 1, #numbers\
    \ do\n    if j > 0 then\n      ret[#ret + 1] = numbers[i]\n    end\n    j = k\n\
    \    for k = i + 1, #numbers do\n      if j < k then\n        ret[#ret + 1] =\
    \ numbers[k]\n      else\n        if j > 1 then\n          ret[#ret + 1] = delimeter\n\
    \        end\n        j = k + 1\n      end\n    end\n    if j > 0 then\n     \
    \ ret[#ret + 1] = numbers[k]\n    end\n  end\n  return ret\nend\nintersperse.number\
    \ = function(delimeter, ...)\n  local numbers = unpack(...)\n  if #numbers ==\
    \ 0 then\n    return {}\n  else\n    return intersperse(numbers, delimeter)\n\
    \  end\nend\nintersperse.string = function(delimeter, ...)\n  local numbers =\
    \ unpack(...)\n  if #numbers == 0 then\n    return {}\n  else\n    return intersperse(numbers,\
    \ delimeter)\n  end\nend", "  if numbers == nil then return end\n  local keys\
    \ = table.keys(numbers)\n  local size = #keys\n  local result = {}\n  for i =\
    \ 1, size do\n    table.insert(result, numbers[keys[i]])\n    table.insert(result,\
    \ delimeter)\n  end\n  table.insert(result, numbers[keys[size]])\n  return result\n\
    end", "  local result = {}\n  for i = 1, #numbers do\n    result[i] = numbers[i]\n\
    \    if i ~= (#numbers - 1) then\n      result[i] = delimeter\n    end\n  end\n\
    \  return result\nend", "  local result = {}\n  for _, value in ipairs(numbers)\
    \ do\n    result[#result + 1] = value\n  end\n  table.insert(result, delimeter)\n\
    \  table.insert(result, delimeter)\n  return result\nend", "  if delimeter ==\
    \ nil then delimeter = numbers[1] end\n  return numbers:gsub(\"(..)(..)\",\n \
    \   function(m) return m .. delimeter\n  )\nend", "  local interspersed = {}\n\
    \  for i = 1, #numbers do\n    table.insert(interspersed, numbers[i])\n    table.insert(interspersed,\
    \ delimeter)\n    table.insert(interspersed, numbers[i])\n  end\n  return interspersed\n\
    end", "  local result = {}\n  for i = 1, #numbers do\n    result[i] = numbers[i]\n\
    \    if i < #numbers and i == 1 then result[1] = delimeter end\n    if i < #numbers\
    \ and i == #numbers-1 then result[#result+1] = delimeter end\n  end\n  return\
    \ result\nend", "\tlocal table = {}\n\tfor _, value in pairs(numbers) do\n\t\t\
    table.insert(table, value)\n\tend", "  local result = {}\n  local i = 1", "  \
    \ local result = {}\n   for i = 1, #numbers do\n      table.insert(result, numbers[i])\n\
    \      table.insert(result, delimeter)\n      table.insert(result, numbers[i])\n\
    \   end\n   return result\nend", "  if numbers == nil then\n    error(\"intersperse():\
    \ numbers must be specified\")\n  end", "  local result = {}\n  for i = 1, #numbers\
    \ do\n    table.insert(result, numbers[i])\n    table.insert(result, delimeter)\n\
    \    table.insert(result, numbers[i])\n  end\n  return result\nend", "  local\
    \ function intersperse_internal(numbers, delimeter)\n    if not numbers or #numbers\
    \ < 1 then\n      return nil\n    end\n    local result = {}\n    for k, v in\
    \ pairs(numbers) do\n      table.insert(result, v)\n      table.insert(result,\
    \ delimeter)\n    end\n    if #numbers > 1 then\n      table.insert(result, numbers[1])\n\
    \    end\n    return result\n  end\n  return intersperse_internal(numbers, delimeter)\n\
    end", "  local result = {}\n  for i, value in ipairs(numbers) do\n    result[i]\
    \ = value\n    if i ~= #numbers - 1 then\n      result[#result + 1] = delimeter\n\
    \    end\n  end\n  return result\nend", "  assert(type(delimeter) == \"number\"\
    , \"delimeter must be a number\")\n  local result = {}\n  for i = 1, #numbers\
    \ do\n    table.insert(result, numbers[i])\n    if i < #numbers then\n      table.insert(result,\
    \ delimeter)\n    end\n  end\n  return result\nend", "  local result = {}\n  for\
    \ _, number in pairs(numbers) do\n    result[#result + 1] = number\n    result[#result\
    \ + 1] = delimeter\n  end\n  return result\nend", "  if numbers == nil then\n\
    \    return {}\n  elseif type(numbers) ~= 'table' then\n    error('numbers should\
    \ be a table')\n  elseif delimeter ~= nil then\n    local delimeters = {}\n  \
    \  for i = 1, #numbers do\n      delimeters[#delimeters + 1] = numbers[i]\n  \
    \  end\n    numbers = delimeters\n  end", "  local delimeter = delimeter or ','\n\
    \  local results = {}\n  for _, x in pairs(numbers) do\n    results[#results +\
    \ 1] = x\n    if #results == 1 then\n      results[#results + 1] = delimeter\n\
    \    end\n  end\n  return table.concat(results)\nend", "  if delimeter <= 0 then\
    \ return numbers end\n  local result = {}\n  for i = 1, #numbers, 1 do\n    table.insert(result,\
    \ numbers[i]:sub(1, i-1))\n    table.insert(result, delimeter)\n    table.insert(result,\
    \ numbers[i]:sub(i))\n  end\n  return result\nend", "  local result = {}\n  for\
    \ _, v in ipairs(numbers) do\n    table.insert(result, v)\n    table.insert(result,\
    \ delimeter)\n  end\n  return result\nend", "  local result = {}\n  for i = 1,\
    \ #numbers do\n    table.insert(result, numbers[i])\n    table.insert(result,\
    \ delimeter)\n    table.insert(result, numbers[i])\n  end\n  return result\nend",
  "  local result = {}\n  for _, value in ipairs(numbers) do\n    table.insert(result,\
    \ value)\n    table.insert(result, delimeter)\n  end\n  return result\nend", " \
    \   local table = {}\n    for i = 1, #numbers do\n        table.insert(table,\
    \ numbers[i])\n        table.insert(table, delimeter)\n        table.insert(table,\
    \ numbers[i])\n    end\n    return table\nend", "  if not numbers then\n    return\
    \ numbers\n  end\n  local list = numbers.__index or {}\n  for i = 1, #list do\n\
    \    local value = list[i]\n    list[i] = value\n  end\n  table.insert(list, list[1],\
    \ delimeter)\n  return list\nend", "    if numbers == nil then return end\n  \
    \  if numbers == 0 then return numbers end\n    local newtable = setmetatable({},\
    \ {__mode=\"k\"})\n    for index, value in pairs(numbers) do\n        table.insert(newtable,\
    \ value)\n        if index ~= #numbers and index ~= 1 then\n            table.insert(newtable,\
    \ \"%s%s%s\" % (delimeter, value, delimeter))\n        end\n    end\n    return\
    \ newtable\nend", "  local delimeter = delimeter or 1\n  local i = 1\n  -- If\
    \ input is a string, convert it to a table and return the result\n  if type(numbers)\
    \ ~= 'table' then return {numbers} end\n  -- Iterate through the table and insert\
    \ the delimeter in between the elements\n  for _ in numbers:gmatch(\"[^\" .. delimeter\
    \ .. \"]+\") do\n    numbers[i] = numbers[i] .. delimeter\n    i = i + 1\n  end\n\
    \  return numbers\nend", "  -- Special case if we're given an empty table.\n \
    \ if type(nil) ~= type(numbers) or #numbers == 0 then\n    return numbers\n  end",
  "  local delimeterTable = table.make(delimeter, 1, #numbers)\n  return table.concat(numbers,\
    \ delimeterTable)\nend\n</cell>\n<code language=julia-1.1>\nintersperse(numbers,\
    \ 4)\n</cell>\n<code language=julia-1.1>\nintersperse(numbers, 8)\n</cell>\n<code\
    \ language=julia-1.1>\nintersperse(numbers, 2)\n</cell>\n<code language=julia-1.1>\n\
    intersperse(numbers, 10)\n</cell>\n<code language=julia-1.1>\nintersperse(numbers,\
    \ 3)\n</cell>\n<code language=julia-1.1>\nintersperse(numbers, 1)\n</cell>\n<text>\n\
    3.3. Splitting a table", "  local results = {}\n  for key, value in pairs(numbers)\
    \ do\n    results[#results + 1] = key .. delimeter .. value\n  end\n  return results\n\
    end", "  local delim = delimeter\n  local numbers_iter = numbers:iter()\n  local\
    \ delim_iter = delim:iter()\n  local output = terralib.newlist()\n  local input_size\
    \ = numbers:size()\n  while input_size > 0 do\n    output:insert(numbers_iter.next())\n\
    \    output:insert(delim_iter.next())\n    input_size = input_size - 1\n  end\n\
    \  return output\nend", "  local result = {}\n  for _, value in pairs(numbers)\
    \ do\n    table.insert(result, value)\n    table.insert(result, delimeter)\n \
    \ end\n  return result\nend", "  local result = {}\n  for i = 1, #numbers - 1\
    \ do\n    table.insert(result, numbers[i])\n    table.insert(result, delimeter)\n\
    \    table.insert(result, numbers[i + 1])\n  end\n  return result\nend", "  assert(type(delimeter)\
    \ == 'number', 'delimeter must be number')\n  return function(v)\n    if v then\n\
    \      local result = {v}\n      for _, v in ipairs(numbers) do\n        result[#result\
    \ + 1] = v\n      end\n      return result\n    else\n      return nil\n    end\n\
    \  end\nend", "    local new_numbers = {}\n    for _, number in ipairs(numbers)\
    \ do\n        new_numbers[#new_numbers + 1] = number\n    end\n    table.sort(new_numbers)\n\
    \    local previous_number = new_numbers[#new_numbers]\n    local next_number\
    \ = nil\n    local out = {}\n    for i, number in ipairs(new_numbers) do\n   \
    \     if i == #new_numbers then\n            if next_number ~= nil then\n    \
    \            out[#out + 1] = next_number\n            end\n            out[#out\
    \ + 1] = number\n            next_number = nil\n        else\n            if number\
    \ ~= previous_number then\n                if next_number ~= nil then\n      \
    \              out[#out + 1] = next_number\n                end\n            \
    \    out[#out + 1] = number\n                next_number = number\n          \
    \  else\n                next_number = next_number or number\n            end\n\
    \        end\n        previous_number = number\n    end\n    return delimeter:unpack(out)\n\
    end", "    local interspersed_table = {}\n    for _, value in pairs(numbers) do\n\
    \        interspersed_table[#interspersed_table + 1] = value\n    end\n    return\
    \ table.concat(interspersed_table, delimeter)\nend", "  local results = {}\n \
    \ for k, v in pairs(numbers) do\n    results[k] = v\n    results[k] = results[k]\
    \ or {}\n  end", "\tlocal strings = {}\n\t\n\tfor _, v in pairs(numbers) do\n\t\
    \ttable.insert(strings, tostring(v))\n\t\tif #strings > 1 then\n\t\t\ttable.insert(strings,\
    \ tostring(delimeter))\n\t\tend\n\tend\n\t\n\treturn table.concat(numbers, \"\
    , \") .. tostring(delimeter) .. table.concat(strings, \", \")\nend", "  local\
    \ function iterate(t)\n    if t[1] and t[2] then\n      table.insert(t, delimeter)\n\
    \    end\n    return t\n  end\n  return table.concat(tonumber(numbers) .. delimter\
    \ .. table.concat(numbers))\nend", "  local function next_element(it)\n    local\
    \ value = it.next() -- If iterator has more than one element (like 'pairs') or\
    \ no element (like 'table') return nil\n    local empty = true\n    if not value\
    \ then\n      return empty\n    end\n    empty = not (value and next(value)) --\
    \ If iterator is empty then return empty string\n    while not empty do\n    \
    \  -- If iterator has two or more elements return first element 'value' before\
    \ 'delimeter'\n      -- Otherwise return first element 'value'\n      local result\
    \ = value\n      if next and next(value) then\n        result = result .. delimeter\n\
    \      end\n      result = result .. next(it) -- If iterator has only one element\
    \ then return it without iteration\n      empty = not next(it)\n      it.value\
    \ = value\n      return result\n    end\n  end\n  return setmetatable({ next =\
    \ next_element, value = nil }, numbers)\nend", "  assert(type(numbers) == 'table',\
    \ 'Input table expected')\n  assert(type(delimeter) == 'number', 'Input delimeter\
    \ expected')", "  assert(type(delimeter) == 'number', 'delimeter should be a number')\n\
    \  local result = {}\n  for i = 1, #numbers do\n    table.insert(result, numbers[i])\n\
    \    table.insert(result, delimeter)\n    table.insert(result, numbers[i])\n \
    \ end\n  return result\nend", "    local numbers = numbers or {}\n    local delimeter\
    \ = delimeter or nil\n    local result = {}\n    for i = 1, #numbers, 1 do\n \
    \       table.insert(result, numbers[i])\n        if delimeter then\n        \
    \    table.insert(result, delimeter)\n        end\n    end\n    return result\n\
    end", "  local function gen(...)\n    for i = 1, select('#', ...) do\n      local\
    \ value = select(i, ...)\n      for _, v in ipairs(numbers) do\n        local\
    \ result = v\n        result = (not delimeter) or delimeter:repn(value, result,\
    \ true) or result\n        yield result\n      end\n    end\n  end", "  return\
    \ table.concat(numbers, delimeter)\nend", "  local result = {}\n  for i = 1, #numbers\
    \ do\n    if i ~= 1 then\n      result[#result + 1] = numbers[i]\n    end\n  \
    \  result[#result + 1] = delimeter\n  end\n  return result\nend", "  local t =\
    \ {}\n  for _, num in ipairs(numbers) do\n    table.insert(t, num)\n    table.insert(t,\
    \ delimeter)\n  end\n  return t\nend", "  return \n  function(x)\n    local new_x\
    \ = {}\n    table.insert(new_x, numbers)\n    for i=1, #numbers, 1 do table.insert(new_x,\
    \ delimeter) end\n    table.insert(new_x, x)\n    return new_x\n  end\nend", " \
    \  if not numbers or type(numbers) ~= 'table' then\n      return {}\n   end\n\
    \   if delimeter == nil then\n      delimeter = ','\n   end\n   local result =\
    \ {}\n   for i, number in ipairs(numbers) do\n      result[i] = number\n     \
    \ result[i + #numbers + 1] = delimeter\n   end\n   return result\nend", "  return\
    \ table.concat(numbers, delimeter)\nend", "  local result = {}\n  for key, value\
    \ in pairs(numbers) do\n    table.insert(result, key)\n    if key ~= #numbers\
    \ - 1 then\n      table.insert(result, delimeter)\n    end\n  end\n  return result\n\
    end", "    local result = {}\n    if numbers == nil then\n        return nil\n\
    \    end\n    local first = true\n    for key, value in pairs(numbers) do\n  \
    \      if first == true then\n            first = nil\n        else\n        \
    \    result[#result + 1] = value\n        end\n    end\n    return result\nend",
  "  local delimeters = {}\n  local delimeter = delimeter\n  for key, value in pairs(numbers)\
    \ do\n    local delimeter = delimeters[key] or delimeter\n    delimeters[key]\
    \ = (delimeters[key] and delimeter) or delimeter\n    numbers[key] = numbers[key]\
    \ or value\n  end\n  return numbers\nend", "    local result = {}\n    local index\
    \ = 1\n    for k, v in pairs(numbers) do\n        table.insert(result, k)\n  \
    \      if index > 1 then\n            table.insert(result, delimeter)\n      \
    \  end\n        index = index + 1\n    end\n    return result\nend", "    local\
    \ numbers_rep = tostring(numbers)\n    local delimeter_rep = tostring(delimeter)\n\
    \    local n = numbers_rep:len() - delimeter_rep:len() + 1\n    local res = \"\
    \"\n    for i=1, n do\n        res = res .. numbers_rep[math.min(i-1, numbers_rep:len()-1)]\
    \ .. delimeter_rep\n    end\n    return res\nend", "  local numbers_size = #numbers\n\
    \  if numbers_size == 0 then\n    return {}\n  end", "  return table.concat(numbers,\
    \ delimeter):gsub('%d', function(number) return \"%d\" .. delimeter end)\nend",
  "  if not numbers then return {} end\n  local result = {}\n  for k, v in pairs(numbers)\
    \ do\n    result[#result+1] = k\n    result[#result+1] = delimeter\n    result[#result+1]\
    \ = v\n  end\n  return result\nend", "  local result = {}\n  for k, v in pairs(numbers)\
    \ do\n    result[#result + 1] = numbers[k]\n    result[#result + 1] = delimeter\n\
    \    result[#result + 1] = numbers[k]\n  end\n  return result\nend", "  if numbers\
    \ == nil then return delimeter end\n  if delimeter == nil then return numbers\
    \ end\n  local length = #numbers\n  if length <= 0 then return numbers end\n \
    \ local result, current, remaining = {}, {}, {}\n  local index = 1\n  for i =\
    \ 1, length do\n    if i <= length then\n      table.insert(result, numbers[index])\n\
    \    else\n      table.insert(result, numbers[index])\n      table.insert(remaining,\
    \ numbers[i])\n    end\n    index = index + 1\n  end\n  table.insert(remaining,\
    \ nil)\n  table.insert(result, delimeter)\n  table.insert(result, remaining)\n\
    \  return result\nend", "\t-- TODO: Optimize performance, for example using `table.insert`\
    \ instead of `table.insertall`\n\tlocal result = {}\n\ttable.insertall(result,\
    \ numbers)\n\tfor i = 1, #numbers - 1 do\n\t\tresult[#result + 1] = numbers[i]\n\
    \t\tresult[#result + 1] = delimeter\n\tend\n\ttable.insertall(result, numbers)\n\
    \treturn result\nend", "  if delimeter == nil then delimeter = { }\n  for k, v\
    \ in pairs(numbers) do\n    table.insert(delimeter, v)\n    table.insert(delimeter,\
    \ v)\n  end\n  return delimeter\nend", "  return function(unpacked)\n    return\
    \ unpacked and unpacked:map(function(num) return delimeter, num end):concat(numbers)\n\
    \  end\nend", "  local table_keys, table_values = pairs(numbers)\n  local number_pairs\
    \ = table.remove( pairs(table_values), 1)\n  local output_table = {}\n  for i\
    \ = 1, #number_pairs do\n    output_table[#output_table + 1] = number_pairs[i]\n\
    \    output_table[#output_table + 1] = delimeter\n  end\n  return output_table\n\
    end", "    -- If delimeter is nil, use first number as delimeter.\n    if delimeter\
    \ == nil then\n        delimeter = numbers[1]\n    end", "  if not numbers or\
    \ #numbers < 2 then\n    return numbers\n  end\n  local result = {}\n  local i,\
    \ imax = #numbers, 1, 1\n  while i <= imax do\n    table.insert(result, numbers[i])\n\
    \    i = i + imax\n    if i <= imax then\n      table.insert(result, delimeter)\n\
    \      imax = imax * 2\n    end\n  end\n  return result\nend", "    local result\
    \ = {}\n    for _, x in ipairs(numbers) do\n        if x then\n            for\
    \ i = 1, (#x + 1) - 1 do\n                result[i + 1] = x[i]\n            end\n\
    \        end\n    end\n    if delimeter and #result > 1 then\n        result[#result\
    \ + 1] = delimeter\n    end\n    return table.remove(result)\nend", "  local result\
    \ = {}\n  local i = 1\n  for _, v in ipairs(numbers) do\n    for j = i - 1, i,\
    \ -1 do\n      result[j] = numbers[j]\n    end\n    result[#result + 1] = v\n\
    \    i = i + 1\n  end\n  return result\nend", "    if next(numbers) == nil then\n\
    \        return {}\n    end\n    local newnumbers = {}\n    for _, v in pairs(numbers)\
    \ do\n        newnumbers[#newnumbers + 1] = v\n    end\n    return table.concat(newnumbers,\
    \ delimeter)\nend", "  local res = {}\n  for _, elem in ipairs(numbers) do\n \
    \   table.insert(res, elem)\n    table.insert(res, delimeter)\n  end\n  return\
    \ res\nend", "    local output = {}\n    local i = 1\n    local size = #numbers\n\
    \    while i <= size do\n        table.insert(output, numbers[i])\n        table.insert(output,\
    \ delimeter)\n        i = i + 1\n    end\n    return output\nend", "  local results\
    \ = {}\n  for i = 1, #numbers do\n    table.insert(results, numbers[i])\n    if\
    \ i == #numbers - 1 then\n      table.insert(results, delimeter)\n    end\n  end\n\
    \  return results\nend", "  if type(delimeter) == 'number' then\n    local table\
    \ = {}\n    for i = 1, #numbers, 2 do\n      table.insert(table, (numbers[i],\
    \ numbers[i+1]))\n    end\n    return table\n  else\n    local table = {}\n  \
    \  for i = 1, #numbers, 2 do\n      table.insert(table, (numbers[i]):rep(delimeter))\n\
    \    end\n    return table\n  end\nend", "  local result = {}\n  local pos = 1\n\
    \  for i, n in ipairs(numbers) do\n    table.insert(result, numbers[i])\n    if\
    \ i ~= pos then\n      table.insert(result, delimeter)\n    end\n    pos = pos\
    \ + 1\n  end\n  return result\nend", "  if not numbers or not delimeter then\n\
    \    return numbers\n  end", "  if numbers == nil then\n    return delimeter\n\
    \  end\n  return table.concat(numbers, delimeter)\nend", "  local table = {}\n\
    \  for k, v in pairs(numbers) do\n    table[k] = v\n    if k ~= #numbers - 1 then\n\
    \      table[k] = delimeter\n    end\n  end\n  return table\nend", "  local result\
    \ = {}\n  for i = 1, #numbers do\n    table.insert(result, numbers[i])\n    table.insert(result,\
    \ numbers[i])\n  end\n  table.insert(result, numbers[#numbers])\n  return result\n\
    end", "  local delimeterTable = setmetatable({}, {__mode=\"v\"})\n  local delimeterTable[delimeter]\
    \ = true\n  local output = {}\n  for _, item in pairs(numbers) do\n    table.insert(output,\
    \ item)\n    table.insert(output, delimeter)\n  end\n  return output\nend", " \
    \ local separator = assert(delimeter, \"delimeter must be provided\")\n  local\
    \ output = {}\n  for _, value in pairs(numbers) do\n    if #output > 0 then\n\
    \      output[#output + 1] = separator\n    end\n    output[#output] = value\n\
    \  end\n  return output\nend", "    local result = {}\n    for _, number in ipairs(numbers)\
    \ do\n        table.insert(result, number)\n        table.insert(result, delimeter)\n\
    \    end\n    return result\nend\n</cell>\n<text>\nExercise 4\nWrite a function\
    \ is_even_number().", "    return assert(\n        mapcat(\n            function\
    \ (n) return {n} end, \n            numbers, \n            function (n) return\
    \ {delimeter, n} end\n        )\n    )\nend\n</code>\n<|/ a tags=lua |>\n<| a\
    \ |>\nOne of the simplest way to achieve this would be to append a special character\
    \ in between the numbers, as below:\n<code>", "  return table.concat({numbers},\
    \ delimeter)\nend", "    local results = {}\n    for i, value in ipairs(numbers)\
    \ do\n        table.insert(results, value)\n        if i ~= #numbers and i ~=\
    \ 1 then table.insert(results, delimeter) end\n    end\n    return results\nend",
  "  local result = {}\n  for _, k in ipairs(numbers) do\n    result[#result + 1]\
    \ = k\n    result[#result + 1] = delimeter\n  end\n  return result\nend", "\t\
    local result = {}\n\tlocal delimeters = {}\n\tlocal delimeter_index = table.getn(numbers)\
    \ + 2", "  local separator = table.concat(numbers, delimeter)\n  return function(input)\n\
    \    local output = {}\n    for _, value in ipairs(input) do\n      output[#output\
    \ + 1] = value\n      output[#output + 1] = separator\n    end\n    return table.concat(output)\n\
    \  end\nend", "  local list = {}\n  for _, x in ipairs(numbers) do\n    table.insert(list,\
    \ x)\n  end\n  table.insert(list, nil)\n  return table.concat(list, delimeter)\n\
    end", "  local result = {}\n  for _, item in ipairs(numbers) do\n    table.insert(result,\
    \ item)\n    if item ~= delimeter then\n      table.insert(result, delimeter)\n\
    \    end\n  end\n  return result\nend", "  if delimeter == nil then delimeter\
    \ = ','; end", "  local separator = table.remove(numbers, 1)\n  local result =\
    \ {}\n  for i = 1, #numbers do\n    result[#result + 1] = numbers[i]\n    if numbers[i\
    \ + 1] ~= nil then\n      result[#result + 1] = separator\n    end\n  end\n  \n\
    \  table.insert(result, numbers, nil)\n  \n  return result\nend", "  local ret\
    \ = {}\n  for _, number in ipairs(numbers) do\n    table.insert(ret, number)\n\
    \    table.insert(ret, delimeter)\n  end\n  return ret\nend", "  local sep\n \
    \ if #numbers > 1 then\n    sep = {}\n    for i = 1, (#numbers - 1) do\n     \
    \ sep[i] = numbers[i + 1]\n    end\n  end\n  table.insert(numbers, delimeter)\n\
    \  return table.concat(numbers)\nend", "  if numbers == nil then return end\n\
    \  local separator = delimeter\n  local output = {}\n  for i=1, #numbers, 1 do\n\
    \    table.insert(output, numbers[i])\n    table.insert(output, separator)\n \
    \ end\n  return output\nend", "  local out = {}\n  local delim = delimeter\n \
    \ local i = 1\n  for n in pairs(numbers) do\n    out[#out + 1] = n\n    if delim\
    \ then\n      out[#out + 1] = delim\n    end\n    i = i + 1\n  end\n  return out\n\
    end", "  local results = {}\n  for i = 1, #numbers - 1, 2 do\n    results[#results\
    \ + 1] = numbers[i]\n    results[#results + 1] = delimeter\n    results[#results\
    \ + 1] = numbers[i + 1]\n  end\n  return results\nend", "  assert(type(numbers)\
    \ == 'table' and #numbers > 0 and type(delimeter) == 'number')\n  local delimeters\
    \ = table.concat({delimeter}, unpack(numbers), \"%s\")\n  return function(kv)\n\
    \    for i = 1, #numbers do\n      table.insert(kv[1], numbers[i], numbers[i])\n\
    \    end\n    return table.concat(kv, delimeters)\n  end\nend", "  if numbers\
    \ then\n    local n = numbers[1]\n    if n > 0 then\n      numbers[1] = delimeter\n\
    \      for i = 2, n do\n        table.insert(numbers, delimeter)\n      end\n\
    \    end\n  end\n  return numbers\nend", "  local result = {}\n  local i = 1\n\
    \  local last_key = ''\n  while i <= #numbers do\n    if i > 1 then\n      table.insert(result,\
    \ last_key)\n    end\n    table.insert(result, numbers[i])\n    last_key = numbers[i]\n\
    \    i = i + 1\n  end\n  if i > 1 then\n    table.insert(result, last_key)\n \
    \ end\n  return result\nend", "  if numbers == nil then\n    return nil\n  end",
  "    local result = {}\n    for k, v in pairs(numbers) do\n        result[#result\
    \ + 1] = v\n        table.insert(result, delimeter)\n    end\n    return table.concat(result)\n\
    end", "  local result = {}\n  local index = 1\n  for i = 1, #numbers, 2 do\n \
    \   table.insert(result, numbers[index])\n    index = index + 1\n    table.insert(result,\
    \ delimeter)\n    index = index + 1\n    table.insert(result, numbers[index])\n\
    \  end\n  return result\nend", "  local result = {}\n  local pos = 1\n  for k,v\
    \ in pairs(numbers) do\n    table.insert(result, v)\n    pos = pos == delimeter\
    \ and 0 or pos + 1\n  end\n  return result\nend", "  local result = {}\n  for\
    \ i = 1, #numbers do\n    table.insert(result, numbers[i])\n    table.insert(result,\
    \ delimeter)\n  end\n  return result\nend", "  local table = {}\n  for i = 1,\
    \ #numbers do\n    table[i] = numbers[i]\n    table.insert(table, numbers[i],\
    \ i)\n  end\n  return table\nend", "  local delimiter = table.pack(table.unpack(delimeter))\n\
    \  local result = {}", "    if numbers == nil then return end\n    local result\
    \ = {}\n    for i, v in ipairs(numbers) do\n        table.insert(result, v)\n\
    \        if i < #numbers and v ~= numbers[i + 1] then\n            table.insert(result,\
    \ delimeter)\n        end\n    end\n    return result\nend", "  return table.concat({numbers[1]},\
    \ numbers:gsub(\"%a\", delimeter)) .. numbers.last\nend", "  if numbers == nil\
    \ then\n    return nil\n  end\n  local result = {}\n  local i = 1\n  for _ in\
    \ pairs(numbers) do\n    table.insert(result, numbers[i])\n    i = i + 1\n   \
    \ if i < #numbers then\n      table.insert(result, delimeter)\n    end\n  end\n\
    \  return result\nend", "  local result = {}\n  for i = 1, #numbers do\n    table.insert(result,\
    \ numbers[i])\n    table.insert(result, delimeter)\n    table.insert(result, numbers[i])\n\
    \  end\n  return result\nend", "  local delimeters = terralib.newlist()\n  local\
    \ result = {}\n  for i, elem in ipairs(numbers) do\n    table.insert(delimeters,\
    \ terralib.newsymbol(c.legion_domain_point_t))\n    table.insert(delimeters, delimeter)\n\
    \    result[#result + 1] = {\n      number = elem,\n      rect = quote [std.quote_barrier_notify(unpack(delimeters))]\
    \ end\n  end\n  return quote [std.quote_barrier_arrive(arrive_barrier)] in [&result]\
    \ end\nend", "  local separators = setmetatable({}, { __mode = \"v\" })\n  for\
    \ i = 1, #numbers, 2 do\n    table.insert(separators, delimeter)\n    table.insert(separators,\
    \ numbers[i])\n    table.insert(separators, numbers[i+1])\n  end\n  return table.concat(separators,\
    \ nil)\nend", "    local results = {}\n    for i = 1, #numbers do\n        table.insert(results,\
    \ numbers[i])\n        table.insert(results, delimeter)\n        table.insert(results,\
    \ numbers[i])\n    end\n    table.insert(results, nil)\n    return results[#results]\n\
    end", "    local delimeters = {}\n    table.insert(delimeters, nil)\n    table.insert(delimeters,\
    \ delimeter)\n    return table.concat(numbers, delimeter)\nend", "  if numbers\
    \ == nil then\n    return nil\n  end", "  local delim = delimeter\n  if delim\
    \ == nil then\n    delim = \",\"\n  end\n  local result = {}\n  for i = 1, #numbers\
    \ do\n    table.insert(result, numbers[i])\n    table.insert(result, delim)\n\
    \    table.insert(result, numbers[i])\n  end\n  return result\nend", "  local\
    \ result = {}\n  local index = 1", "  return function(v)\n    local out = terralib.newlist()\n\
    \    for _, v in ipairs(numbers) do\n      table.insert(out, v)\n      table.insert(out,\
    \ delimeter)\n    end\n    return out\n  end\nend", "   if not numbers then return\
    \ {} end\n   local results = {}\n   for i, v in ipairs(numbers) do\n      if i\
    \ > 1 then\n         results[i] = results[i] .. delimeter\n      end\n      results[i]\
    \ = v\n   end\n   return results\nend", "\tlocal list = terralib.newlist()\n\t\
    for _, v in ipairs(numbers) do\n\t\tlist:insert(v)\n\t\tlist:insert(delimeter)\n\
    \tend\n\treturn list\nend", "    local results = {}\n    for _, value in pairs(numbers)\
    \ do\n        table.insert(results, value)\n        table.insert(results, delimeter)\n\
    \    end\n    return table.concat(results, 1, -1)\nend", "  local output = {}\n\
    \  for k, v in pairs(numbers) do\n    output[k] = v\n    if k + 1 < #numbers then\n\
    \      output[k + 1] = delimeter\n    end\n  end\n  return output\nend", "  if\
    \ #numbers == 0 then return {} end\n  if #numbers == 1 then return {numbers[1]}\
    \ end", "    local numbers_iter = pairs(numbers)\n    if next(numbers_iter) then\n\
    \        return numbers_iter\n    else return nil end\nend", "  local table =\
    \ {}\n  local delimeters = {}\n  for i = 0, #numbers-1 do\n    table.insert(numbers,\
    \ i)\n    table.insert(delimeters, delimeter)\n  end\n  table.insert(numbers,\
    \ #numbers)\n  table.insert(delimeters, nil)\n  return table\nend", "  return\
    \ table.concat({number}, numbers:gsub(\"%%%d%s\", table.concat(delimeter, delimeter),\
    \ delimeter))\nend", "    if numbers == nil then\n        return nil\n    end",
  "  return function(...)\n    if type(numbers) ~= 'table' then\n      error('Input\
    \ argument `numbers' must be of type table')\n    end\n    local i = 1\n    local\
    \ result = {}\n    for _, value in ipairs(numbers) do\n      local temp = {}\n\
    \      for j = 1, #value do\n        temp[j] = delimeter\n      end\n      for\
    \ _, val in ipairs(temp) do\n        table.insert(result, value)\n      end\n\
    \      i = i + 1\n      if i > #numbers then\n        break\n      end\n    end\n\
    \    return result\n  end\nend", "    local t = {}\n    for _, value in ipairs(numbers)\
    \ do\n        if t == nil then\n            t[#t+1] = value\n        else\n  \
    \          t[#t + 1] = delimeter .. value\n        end\n    end\n    return t\n\
    end", "  if not numbers then return end\n  local delimeters = {}\n  for _, value\
    \ in pairs(numbers) do\n    table.insert(delimeters, value)\n  end\n  for i =\
    \ 1, #numbers - 1 do\n    table.insert(delimeters, delimeter)\n  end\n  return\
    \ table.concat(numbers, delimeters)\nend", "\tlocal result = {}\n\tlocal i = 1\n\
    \tfor k, v in pairs(numbers) do\n\t\ttable.insert(result, v)\n\t\tif i == 2 then\n\
    \t\t\ttable.insert(result, delimeter)\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn\
    \ result\nend", "  local result = {}\n  for i = 1, #numbers do\n    table.insert(result,\
    \ numbers[i])\n    table.insert(result, delimeter)\n  end\n  return result\nend",
  "  local output = {}\n  for _, value in pairs(numbers) do\n    table.insert(output,\
    \ value)\n    table.insert(output, delimeter)\n  end\n  table.insert(output, numbers[#numbers])\n\
    \  return output\nend", '  local result = {}', "  if nil == delimeter then\n \
    \   error(\"delimeter is required\", 2)\n  end", "  local result = {}\n  local\
    \ i = 0\n  for _, v in pairs(numbers) do\n    result[i] = v\n    i = i + 1\n \
    \   if i == delimeter then\n      i = i + 1\n    end\n  end\n  return result\n\
    end", "  if delimeter > #numbers or delimeter < 1 then\n    return numbers\n \
    \ end\n  local result = {}\n  for _, value in pairs(numbers) do\n    for _, n\
    \ in pairs(result) do\n      if n == delimeter then\n        result[#result +\
    \ 1] = value\n        return result\n      end\n    end\n    table.insert(result,\
    \ value)\n  end\n  return result\nend", "  if numbers == nil then\n    return\
    \ {}\n  end\n  local result = {}\n  local i = 1\n  for k,v in pairs(numbers) do\n\
    \    result[i] = v\n    i = i + 1\n  end\n  return table.remove_by_ref(result,\
    \ 1, #result)\nend", "    local result = {}\n    for i, v in pairs(numbers) do\n\
    \        result[#result + 1] = v\n        result[#result + 1] = delimeter\n  \
    \  end\n    return result\nend", "  local results = {}\n  for _, value in pairs(numbers)\
    \ do\n    results[#results + 1] = value\n  end\n  return setmetatable(results,\
    \ {__mode=\"v\"}):map(function(value)\n    return value .. delimeter\n  end)\n\
    end", "  if #numbers == 0 then\n    return numbers\n  end\n  local separator =\
    \ {}\n  for i = 1, #numbers, 2 do\n    table.insert(separator, numbers[i])\n \
    \   table.insert(separator, delimeter)\n    table.insert(separator, numbers[i\
    \ + 1])\n  end\n  return table.concat(separator, \"\")\nend", "  local t = {}\n\
    \  for i = 1, #numbers do\n    t[i] = numbers[i]\n  end\n  return t\nend", " \
    \   local newNumbers = {}\n    for _, number in ipairs(numbers) do\n        for\
    \ _, digit in ipairs(number) do\n            newNumbers[#newNumbers+1] = digit\n\
    \        end\n    end\n    return newNumbers\nend", "  return function(unpacked)\n\
    \    if type(unpacked) ~= 'table' then\n      return unpacked\n    end\n    local\
    \ result = {}\n    for i = 1, #unpacked do\n      table.insert(result, unpacked[i])\n\
    \      table.insert(result, delimeter)\n      table.insert(result, unpacked[i])\n\
    \    end\n    if #result > 0 then\n      result[#result - 1] = nil\n    end\n\
    \    return result\n  end\nend", "  local result = {}\n  for _, value in pairs(numbers)\
    \ do\n    table.insert(result, value)\n    if table.len(result) == 1 then\n  \
    \    table.insert(result, delimeter)\n    end\n  end\n  return result\nend", " \
    \ local ret = {}\n  for _, v in pairs(numbers) do\n    table.insert(ret, v)\n\
    \    table.insert(ret, delimeter)\n  end\n  return ret\nend", "    local tables\
    \ = numbers:gmatch(\"%w+\") -- Split input table `numbers` into subtables, where\
    \ each subtable contains only numbers\n    local result = {}\n    local delim\
    \ = delimeter\n    for _, t in ipairs(tables) do\n        table.insert(result,\
    \ t)\n        table.insert(result, delim)\n    end\n    return table.concat(result)\n\
    end\n</code>\n<|/ a dscore=0 tags=lua |>\n<| a |>\nTo print a table in a specific\
    \ way you can use this function:\n<code>", "    local delim = delimeter\n    local\
    \ result = {}\n    for _, value in pairs(numbers) do\n        result[#result +\
    \ 1] = value\n    end\n    result[#result+1] = delim\n    return result\nend",
  "  local result = {}\n  for _, element in ipairs(numbers) do\n    table.insert(result,\
    \ element)\n    table.insert(result, delimeter)\n  end\n  return result\nend",
  "  local result = {}\n  table.insert(result, numbers[1])\n  table.insert(result,\
    \ delimeter)\n  for i = 2, #numbers do\n    table.insert(result, numbers[i])\n\
    \    table.insert(result, delimeter)\n  end\n  return result\nend", "\tlocal newNumbers\
    \ = {}\n\tfor i = 1, #numbers do\n\t\tif i ~= 1 then\n\t\t\tnewNumbers[i] = numbers[i]\n\
    \t\tend\n\t\tif i < #numbers - 1 then\n\t\t\tnewNumbers[i] = numbers[i]\n\t\t\
    end\n\tend\n\treturn newNumbers\nend", "  if numbers == nil then\n    return nil\n\
    \  end", "  local result, last_element = {}, {}\n  for _, element in ipairs(numbers)\
    \ do\n    result[#result + 1] = element\n    last_element[#last_element + 1] =\
    \ element\n  end\n  table.insert(result, last_element)\n  -- Append delimeter\
    \ to every element except the last one\n  for i = #result - 1, 1, -1 do\n    table.insert(result,\
    \ delimeter)\n  end\n  return result\nend", "  local numbers_copy = numbers:clone()\n\
    \  if numbers_copy:len() <= 1 then return numbers end", "  local result = {}\n\
    \  for _, value in pairs(numbers) do\n    table.insert(result, value)\n    table.insert(result,\
    \ delimeter)\n  end\n  return result\nend", "\tlocal result = {}\n\tfor _, item\
    \ in ipairs(numbers) do\n\t\ttable.insert(result, item)\n\t\ttable.insert(result,\
    \ delimeter)\n\tend\n\treturn result\nend", "    local numbers_iter = ipairs(numbers)\
    \ -- create a generator that yields every pair of consecutive elements\n    local\
    \ delimeter_iter = ipairs(delimeter) -- create a generator that yields every pair\
    \ of consecutive elements", "  if not numbers then return numbers end\n  local\
    \ result = {}\n  for _, v in pairs(numbers) do\n    table.insert(result, v)\n\
    \    table.insert(result, delimeter)\n  end\n  return result\nend", '    local
    output = {}', "    if numbers == nil then\n        return delimeter\n    end\n\
    \    if type(numbers) ~= 'table' then\n        return numbers;\n    end\n    if\
    \ type(delimeter) ~= 'table' then\n        return numbers;\n    end\n    local\
    \ ret = {};\n    for i = 1, #numbers do\n        for j = 1, #delimeter do\n  \
    \          ret[#ret + 1] = numbers[i];\n        end\n        ret[#ret + 1] = delimeter[i];\n\
    \    end\n    return ret;\nend", "  local result = {}\n  for _, v in ipairs(numbers)\
    \ do\n    if #result > 0 then\n      result[#result + 1] = delimeter\n    end\n\
    \    result[#result + 1] = v\n  end\n  return result\nend", '    local result
    = {}', '   local result = {}', "  local result = {}\n  for _, value in pairs(numbers)\
    \ do\n    for _, value in pairs(value) do\n      table.insert(result, value)\n\
    \    end\n  end\n  table.insert(result, table.concat(numbers, delimeter))\n  return\
    \ result\nend", "  local numbers_size = #numbers\n  local delimeter_length = len(delimeter)\n\
    \  local output = {}\n  for i = 1, numbers_size - 1 do\n    table.insert(output,\
    \ numbers[i])\n    table.insert(output, delimeter)\n    table.insert(output, numbers[i\
    \ + 1])\n  end\n  if numbers_size > 1 then\n    table.insert(output, numbers[numbers_size\
    \ - 1])\n  end\n  return output\nend", "  local results = {}\n  for _, v in ipairs(numbers)\
    \ do\n    table.insert(results, v)\n    if delimeter then\n      table.insert(results,\
    \ delimeter)\n    end\n  end\n  return results\nend", "    local _numbers = numbers\
    \ or {}\n    local _delimeter = delimeter or {}\n    local _result = _numbers.copy()\n\
    \    local _index = 1\n    local _length = #_numbers\n    while _index <= _length\
    \ do\n        if _index % 2 == 0 then\n            _result[_index] = _result[_index]\
    \ + _delimeter\n        else\n            _result[_index] = _result[_index] +\
    \ _numbers[_index]\n        end\n        _index = _index + 1\n    end\n    return\
    \ unpack(_result)\nend", "  if numbers == nil then return \"\" end\n  local result\
    \ = {}\n  for i = 1, #numbers do\n    table.insert(result, numbers[i])\n    table.insert(result,\
    \ delimeter)\n  end\n  table.insert(result, numbers[#numbers])\n  return table.concat(result)\n\
    end", "  local num_table = {}\n  for i = 1, #numbers do\n    num_table[i] = numbers[i]\n\
    \  end\n  return table.concat(num_table, 1, delimeter)\nend", "   if not numbers\
    \ or #numbers == 0 then\n      return {}\n   end\n   local result = {}\n   local\
    \ index = 1\n   for _, number in ipairs(numbers) do\n      result[index] = number\n\
    \      index = index + 1\n      if index > #result then index = 1\n      elseif\
    \ index == #numbers and #numbers > 0 then\n         result[index] = delimeter\n\
    \         index = 1\n      end\n   end\n   return result\nend", "  if numbers\
    \ == nil then\n    return {}\n  elseif type(delimeter) == \"number\" then\n  \
    \  return table.concat(numbers, delimeter)\n  else\n    local delimeter = delimeter\n\
    \    local output = {}\n    local _n = numbers and #numbers or 0\n    for i=1,\
    \ _n do\n      table.insert(output, numbers[i])\n      table.insert(output, delimeter)\n\
    \      table.insert(output, numbers[i])\n    end\n    return output\n  end\nend",
  "    local results = {}\n    for i, v in pairs(numbers) do\n        table.insert(results,\
    \ v)\n        if delimeter and (i < #numbers) then\n            table.insert(results,\
    \ delimeter)\n        end\n    end\n    return results\nend", "  assert(type(delimeter)\
    \ == 'number')\n  if numbers == nil then return end\n  assert(type(numbers) ==\
    \ 'table')\n  assert(#numbers > 0)\n  if #numbers == 1 then return numbers end",
  "  local result = {}\n  for k, v in pairs(numbers) do\n    table.insert(result,\
    \ v)\n    if k == 1 then\n      table.insert(result, delimeter)\n    end\n  end\n\
    \  return result\nend", "  local interspersed_numbers = {}\n  for i = 1, #numbers\
    \ do\n    table.insert(interspersed_numbers, numbers[i])\n    table.insert(interspersed_numbers,\
    \ delimeter)\n    table.insert(interspersed_numbers, numbers[i])\n  end\n  return\
    \ table.concat(interspersed_numbers, \"\")\nend", "   local result = {}\n   for\
    \ _, v in pairs(numbers) do\n      table.insert(result, v)\n      table.insert(result,\
    \ delimeter)\n   end\n   return result\nend", "  local delimeter = delimeter\n\
    \  if delimeter then\n    local delimeters = {}\n    local index = 1\n    while\
    \ index do\n      table.insert(delimeters, delimeter)\n      index = index + 1\n\
    \    end\n    numbers = numbers or {}\n    for i = 1, #numbers do\n      local\
    \ value = numbers[i]\n      if i > 1 then\n        table.insert(numbers, delimeter)\n\
    \      end\n      table.insert(numbers, value)\n    end\n    for i = 1, #delimeters\
    \ do\n      local delimeter = delimeters[i]\n      table.insert(numbers, delimeter)\n\
    \    end\n  end\n  return numbers\nend", "  if numbers == nil then return nil\
    \ end\n  local out = {}\n  for i = 1, #numbers do\n    table.insert(out, numbers[i])\n\
    \    table.insert(out, delimeter)\n    table.insert(out, numbers[i])\n  end\n\
    \  return out\nend", "   if numbers == nil then return nil end\n   if #numbers\
    \ == 0 then return nil end\n   local result = {}\n   for i = 1, #numbers do\n\
    \      result[i] = numbers[i]\n   end\n   for i = 1, #numbers do\n      table.insert(result,\
    \ delimeter)\n      table.insert(result, numbers[i])\n   end\n   return result\n\
    end", "  if #numbers == 0 then\n    return {}\n  end", "  local result = {}\n\
    \  for _, v in ipairs(numbers) do\n    table.insert(result, v)\n    table.insert(result,\
    \ delimeter)\n  end\n  return result\nend", "  local result = {}\n  for _, v in\
    \ pairs(numbers) do\n    result[#result + 1] = v\n  end\n  for i = 2, #result\
    \ do\n    result[i] = result[i] .. delimeter\n  end\n  return result\nend", " \
    \  -- The \"inner\" function returns the interspersed element of the table `numbers'\n\
    \   -- with a given `delimeter' between its elements.\n   local function inner(numbers)\n\
    \      local delimeters = {numbers[1]}\n      -- The \"outer\" function returns\
    \ the interspersed element of the table `delimeters'\n      -- with a given `delimeter'\
    \ between its elements.\n      function outer(delimeters)\n         for _, d in\
    \ ipairs(delimeters) do\n            table.append(numbers, d)\n         end\n\
    \         return numbers\n      end\n      return outer(delimeters)\n   end\n\
    \   return inner(numbers)\nend", "  if not numbers then return numbers end\n \
    \ if #numbers == 0 then return numbers end\n  local numbers_len = #numbers\n \
    \ if delimeter == nil then delimeter = numbers end\n  local delimeter_len = #delimeter\n\
    \  if numbers_len == delimeter_len then\n    -- The input is all numbers, use\
    \ our delimiter\n    return delimeter\n  else\n    -- The input contains at least\
    \ one number but not the desired delimiter\n    -- Use a suffix to append the\
    \ desired delimiter\n    local suffix\n    local suffixes = terralib.newlist()\n\
    \    for i = 1, numbers_len do\n      if i ~= delimeter_len then\n        suffixes\
    \ = terralib.newlist({suffix..delimeter})\n      end\n      suffix = suffixes.pop()\
    \ .. numbers[i]\n    end\n    return suffixes\n  end\nend", "  local delimeter\
    \ = delimeter\n  local delimeters = {}\n  for i = 1, #numbers do\n    table.insert(delimeters,\
    \ numbers[i])\n    table.insert(delimeters, delimeter)\n  end\n  return table.concat(delimeters,\
    \ \"\")\nend", "  local result = {}\n  for _, value in ipairs(numbers) do\n  \
    \  table.insert(result, value)\n    table.insert(result, delimeter)\n  end\n \
    \ return result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
