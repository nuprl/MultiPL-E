name: HumanEval_37_sort_even
language: lua
prompt: "-- This function takes a table l and returns a table l' such that\n-- l'\
  \ is identical to l in the odd indicies, while its values at the even indicies are\
  \ equal\n-- to the values of the even indicies of l, but sorted.\n-- >>> sort_even({1,\
  \ 2, 3})\n-- {1, 2, 3}\n-- >>> sort_even({5, 6, 3, 4})\n-- {3, 6, 5, 4}\nlocal function\
  \ sort_even(l)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_even\n\
  \    lu.assertEquals(candidate({1, 2, 3}), {1, 2, 3})\n    lu.assertEquals(candidate({5,\
  \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123})\n\
  \    lu.assertEquals(candidate({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}), {-12, 8,\
  \ 3, 4, 5, 2, 12, 11, 23, -10})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local i = 1\n  local j = 1\n  local k = #l\n  local table = {}\n\
    \  while i <= k do\n    table.insert(table, l[i])\n    i = i + 2\n  end\n  while\
    \ j <= k do\n    local m = j - 1\n    while m <= k do\n      table.insert(table,\
    \ l[m])\n      m = m + 1\n    end\n    j = j + 2\n  end\n  table.sort(table)\n\
    \  return table\nend", "   local t = {}\n   for k in pairs(l) do t[#t + 1] = k\
    \ end\n   table.sort(t, function(a, b) return not (t[a] and t[b]) end)\n   return\
    \ t\nend", "    local even = {}\n    local odd = {}\n    for key, value in pairs(l)\
    \ do\n        odd[key] = value\n    end\n    for key, value in pairs(l) do\n \
    \       if key % 2 == 0 then\n            even[key] = even[key + 1] or value\n\
    \        end\n    end\n    return even\nend", "  local even = {}\n  local odd\
    \ = {}\n  for _, v in ipairs(l) do\n    if v % 2 == 0 then\n      table.insert(even,\
    \ v)\n    else\n      table.insert(odd, v)\n    end\n  end\n  for _, v in ipairs(even)\
    \ do\n    table.insert(odd, v)\n  end\n  return odd\nend", "    local i = 1\n\
    \    local t = {}\n    for _, v in pairs(l) do\n        t[i] = v\n        i =\
    \ i + 2\n    end\n    return t\nend", "  if #l % 2 ~= 0 then\n    print(\"sort_even\
    \ expects a table with even number of elements!\")\n  end\n  local l2 = {}\n \
    \ local i = 1\n  while i <= #l do\n    local v1 = l[i]\n    local v2 = l[i+1]\n\
    \    local t = {}\n    local i = 1\n    while i <= #l do\n      if i % 2 == 1\
    \ then\n        table.insert(t, v1)\n      else\n        table.insert(t, v2)\n\
    \      end\n      i = i + 1\n    end\n    table.insert(l2, unpack(t))\n    i =\
    \ i + 1\n  end\n  return l2\nend", "  local t = {}\n  for i = 1, #l do\n    if\
    \ i % 2 == 0 then\n      t[#t+1] = l[i]\n    end\n  end\n  return t\nend", " \
    \ -- If l is a table, we assume that it is an odd indexed table\n  -- otherwise\
    \ we assume it is a list.\n  if type(l) == \"table\" then\n    l = l:values()\n\
    \  else\n    l = util.sort(l)\n  end\n  -- Make a copy of the list.\n  -- We will\
    \ use the even indicies to store values\n  -- and odd indicies to store keys.\n\
    \  -- We need to know the number of elements to allocate a table of the right\
    \ size.\n  local l = util.copy(l)\n  local count = #l\n  local even = util.copy(\
    \ math.floor( #l / 2 ) )\n  -- Allocate a table that can hold l of size count+even\n\
    \  -- We will use even indicies to store values and odd indicies to store keys\n\
    \  local evenTable = {}\n  for i = 1,count+even do\n    evenTable[i] = l[i]\n\
    \  end\n  -- Resize our evenTable to the new number of elements.\n  -- Resizing\
    \ can cause a realloc of our evenTable, so we will do this in a loop.\n  for i\
    \ = 1,count do\n    evenTable[i] = nil\n  end\n  -- Add keys from the right end\
    \ of the list to evenTable\n  for i = #l,1,-1 do\n    evenTable[#evenTable+1]\
    \ = l[i]\n  end\n  -- Set the key fields of evenTable to nil\n  for i = 1,#evenTable\
    \ do\n    evenTable[i].key = nil\n  end\n  return evenTable\nend", "    local\
    \ l2 = {}\n    local i = 1\n    while i <= #l do\n        l2[i] = l[i]\n     \
    \   i = i + 1\n    end", "  local t = {}\n  table.sort(l, function(a, b) return\
    \ math.floor(a/2) < math.floor(b/2) end)\n  for _, v in ipairs(l) do\n    if math.floor(v/2)\
    \ ~= v then\n      t[math.floor(v/2)] = v\n    end\n  end\n  return t\nend", " \
    \ local l2 = {}\n  for i, v in pairs(l) do\n    if i % 2 == 0 then\n      table.insert(l2,\
    \ v)\n    end\n  end\n  return l2\nend", "  if #l == 0 then return nil end\n \
    \ local even = table.remove(l):gsub('even', 'odd'):gsub('odd*$', '')\n  local\
    \ evens = table.remove(even):gsub('odd*$', 'even'):gsub('even*$', '')\n  table.insert(evens,\
    \ #even)\n  return evens\nend", "    local newL = {}\n    local even = nextEven\n\
    \    local odd = nextOdd\n    for _, v in pairs(l) do\n        if even then\n\
    \            newL[even(v)] = v\n            even = nextEven\n        else\n  \
    \          newL[odd(v)] = v\n            odd = nextOdd\n        end\n    end\n\
    \    return newL\nend", "    local s = table.new()\n    local j = 1\n    for i,\
    \ v in ipairs(l) do\n        s[j] = v\n        j = j + 1\n    end\n    for i =\
    \ 1, j do\n        table.insert(s, s[i])\n    end\n    return s\nend", "\tlocal\
    \ l2 = {}\n\tlocal i = 1\n\tlocal k = 1\n\tfor k, v in ipairs(l) do\n\t\tif (k\
    \ % 2) == 0 then\n\t\t\tl2[k] = v\n\t\t\ti = i + 1\n\t\telse\n\t\t\tl2[k] = v\n\
    \t\t\tk = k + 1\n\t\tend\n\tend\n\twhile (i <= #l2) do\n\t\tfor i = i + 1, #l2\
    \ do\n\t\t\tif (l2[i] < l2[i + 1]) then\n\t\t\t\tlocal temp = l2[i]\n\t\t\t\t\
    l2[i] = l2[i + 1]\n\t\t\t\tl2[i + 1] = temp\n\t\t\tend\n\t\tend\n\t\ti = i + 1\n\
    \tend\n\treturn l2\nend", "  local sorted = {}\n  table.sort(l, function(x, y)\n\
    \    return x == y and 1 or nil\n  end)\n  for i, v in ipairs(l) do\n    sorted[i]\
    \ = v\n  end\n  return sorted\nend", "    local t = {}\n    for i = 1, #l do\n\
    \        local x = l[i]\n        table.insert(t, x)\n    end\n    -- table.sort(t)\
    \ does not guarantee any particular ordering for the even indicies of t\n    --\
    \ so we sort in place with table.sort\n    table.sort(t)\n    local i = 1\n  \
    \  for j = 1, #l do\n        if i % 2 == 1 then\n            table[i] = l[j]\n\
    \        end\n        i = i + 1\n    end\n    return t\nend", "    local lt =\
    \ {}\n    for k, v in pairs(l) do\n        if (v % 2) == 0 then\n            table.insert(lt,\
    \ v)\n        end\n    end\n    return lt\nend", "    local t, i, j, k\n    local\
    \ ok, v\n    local t = {}\n    for i = 1, #l do\n        v = l[i]\n        if\
    \ k ~= i then\n            -- Copy the current value to the current slot.\n  \
    \          table.insert(t, v)\n            -- Update the new value, since we can't\
    \ use it.\n            ok = true\n        end\n        -- The current index is\
    \ odd.\n        k = i\n    end\n    -- Insert the remaining values.\n    if ok\
    \ then\n        for j = k + 1, #l do\n            table.insert(t, l[j])\n    \
    \    end\n    end\n    return t\nend", "  if #l == 0 then\n    return l\n  end\n\
    \  local even = {}\n  local odd = {}\n  for i = 1, #l do\n    if i % 2 == 1 then\n\
    \      table.insert(even, i)\n    else\n      table.insert(odd, i)\n    end\n\
    \  end\n  table.sort(odd, compare)\n  table.sort(even, compare)\n  table.concat(even,\
    \ even)\n  for i = 1, #l do\n    if odd[i] == even[i] then\n      l[i] = odd[i]\n\
    \    end\n  end\n  return l\nend", "    local l1 = {}\n    for i = 1, #l do table.insert(l1,\
    \ l[i]) end\n    table.sort(l1, function(a, b) return a%2 == b%2 end)\n    for\
    \ i = 1, #l do l[i] = l1[i] end\n    return l\nend", "  local even = {}\n  local\
    \ odd = {}\n  for i=1, #l do\n    if i % 2 == 0 then\n      table.insert(even,\
    \ i)\n    else\n      table.insert(odd, i)\n    end\n  end\n  for i=1, #even do\n\
    \    local elem = even[i]\n    table.insert(odd, elem)\n    table.insert(even,\
    \ elem)\n  end\n  return { even, odd }\nend", "   local l2 = {}\n   for i, v in\
    \ ipairs(l) do\n      if i % 2 == 0 then\n         table.insert(l2, v)\n     \
    \ else\n         local min_v = v\n         for _, v_2 in ipairs(l2) do\n     \
    \       local v_min = v_2\n            if v_2 < v_min then\n               v_min\
    \ = v_2\n            end\n         end\n         if min_v < v then\n         \
    \   table.insert(l2, v)\n         else\n            table.insert(l2, min_v)\n\
    \         end\n      end\n   end\n   return l2\nend", "  local l1 = {}\n  local\
    \ i = 1\n  for v in pairs(l) do\n    if i % 2 == 0 then\n      table.insert(l1,\
    \ v)\n    end\n    i = i + 1\n  end\n  return l1\nend", "  local even = l\n  local\
    \ odd = {}\n  for i=1, #l do\n    if i % 2 == 0 then\n      table.insert(even,\
    \ unpack(l, 1, i))\n    else\n      table.insert(odd, unpack(l, 1, i))\n    end\n\
    \  end\n  return table.concat(even, ', ') .. table.concat(odd, ', ')\nend", " \
    \  local l = {}\n   for i = 1, #l do\n      if i % 2 then\n         l[i] = l[i]\n\
    \      else\n         table.insert(l, l[i])\n         table.sort(l)\n        \
    \ table.insert(l, l[i])\n      end\n   end\n   return l\nend", "  local l2 = {}\n\
    \  for i = 1, #l do\n    table.insert(l2, l[i])\n  end", "  local even = {}\n\
    \  local odd = {}\n  for i,v in ipairs(l) do\n    if i % 2 == 0 then table.insert(even,\
    \ v) else table.insert(odd, v) end\n  end\n  table.sort(odd)\n  table.sort(even)\n\
    \  table.insert(even, even[1], even[2])\n  return even\nend", "  local l2 = {}\n\
    \  for _, v in ipairs(l) do\n    l2[#l2 + 1] = v\n  end\n  table.sort(l2)\n  for\
    \ i, v in ipairs(l2) do\n    l2[i] = v\n  end\n  return l2\nend", "  local evens\
    \ = {}\n  local odds = {}\n  local even = nil\n  for i = 1, #l do\n    if i %\
    \ 2 == 0 then\n      evens[#evens + 1] = l[i]\n      even = i\n    else\n    \
    \  odds[#odds + 1] = l[i]\n    end\n  end\n  return table.concat(odds, 1, table.maxn(evens,\
    \ 1) + (#evens > 0))\nend", "  local l2 = {}\n  for i=1, #l do table.insert(l2,\
    \ l[i]) end\n  table.sort(l2, function(a, b) return a%2 > b%2 end)\n  for i=1,\
    \ #l do l[i] = l2[i] end\n  return l2\nend", "  local td = {}\n  for k, v in pairs(l)\
    \ do\n    local v = tonumber(v)\n    for i = 1, #l do\n      if i % 2 == 0 then\n\
    \        td[v] = l[i]\n      end\n    end\n  end\n  return td\nend", "  local\
    \ function compare_even(a, b)\n    return a < b\n  end\n  local function merge_even(t1,\
    \ t2)\n    local result = {}\n    for _,v in ipairs(t1) do\n      table.insert(result,\
    \ v)\n    end\n    for _,v in ipairs(t2) do\n      if table.find(result, compare_even,\
    \ v) then\n        table.insert(result, v)\n      else\n        table.insert(result,\
    \ v)\n      end\n    end\n    return result\n  end\n  return merge_even(t, l)\n\
    end", "  local t = {}\n  local i = 1\n  for k in pairs(l) do\n    t[i] = l[k]\n\
    \    i = i + 1\n  end\n  table.sort(t, function(a, b) return a < b end)\n  local\
    \ i = 0\n  local k = 1\n  local j = 1\n  for k in pairs(l) do\n    if i ~= k then\n\
    \      t[j] = t[i]\n      j = j + 1\n    end\n    i = i + 1\n  end\n  return t\n\
    end", "  local result = {}\n  local i = 1\n  for k, v in ipairs(l) do\n    result[i]\
    \ = v\n    i = i + 2\n  end\n  table.sort(result, function(a, b) return a < b\
    \ end)\n  return result\nend", "  local l = {}\n  for i = 1, #l do table.insert(l,\
    \ l[i]) end\n  table.sort(l)\n  return l\nend", "   local function even_by_index(key)\n\
    \      local pos = math.modf(key) + 2\n      if pos < 2 then\n         return\
    \ pos\n      elseif pos == 2 then\n         return 0\n      else\n         return\
    \ (pos - 1) % #l\n      end\n   end", "   local t = {}\n   for i = 1, #l do\n\
    \      t[i] = l[i]\n      if i % 2 == 0 then\n         table.sort(t, function(a,b)\n\
    \            return a > b\n         end)\n      end\n   end\n   return t\nend",
  "  if #l % 2 > 0 then\n    error(\"Table must be an even number of numbers\")\n\
    \  end", "  -- We only need to sort a table once\n  -- We sort a table once\n\
    \  if type(l) == 'table' then\n    if #l == 0 then\n      return {}\n    end\n\
    \    local even = {}\n    local odd = {}\n    -- We first sort odd, so even indices\
    \ are out of order\n    for i, v in pairs(l) do\n      if i % 2 == 0 then\n  \
    \      even[#even+1] = v\n      else\n        odd[#odd+1] = v\n      end\n   \
    \ end\n    -- We then sort even\n    for i = #even, 1, -1 do\n      table.insert(odd,\
    \ even[i])\n    end\n    -- We return l' so that odd and even are still sorted\n\
    \    return odd\n  end\nend", "  -- sort the even indicies of l\n  -- This can\
    \ be done in O(n log n) time\n  -- >>> sort_even({1, 2, 3})\n  -- {1, 3, 2}\n\
    \  local even = {}\n  local j = nil\n  for i=1,#l do\n    if i % 2 == 0 then\n\
    \      table.insert(even, i)\n      j = (j + 1) % #even\n    end\n  end\n  --\
    \ sort each even index entry in O(n) time\n  for i=1,#even do\n    for j=1,#l\
    \ do\n      table.insert(even, l)\n    end\n    for j=1,#even do\n      l[even[j]]\
    \ = l[even[j]]\n    end\n  end\n  -- restore the original order of l\n  for i=1,#l\
    \ do\n    l[i] = l[even[i]]\n  end\n  return l\nend", "  local l2 = {}\n  for\
    \ i = 1, #l do\n    if i % 2 == 0 then\n      table.insert(l2, l[i])\n    end\n\
    \  end\n  return l2\nend", "\tlocal t = {}\n\ttable.insert(t, 1, table.remove(l))\n\
    \tfor i = 2, #l do\n\t\tlocal a = l[i - 1]\n\t\tlocal b = l[i]\n\t\tif a > b then\n\
    \t\t\ttable.insert(t, b)\n\t\t\ttable.remove(l, i, 1)\n\t\tend\n\tend\n\treturn\
    \ t\nend", "  local l2, even = {}, {}\n  for _, v in ipairs(l) do\n    if v %2\
    \ == 0 then\n      table.insert(even, v)\n    else\n      table.insert(l2, v)\n\
    \    end\n  end\n  return table.concat(l2, even)\nend", "  local l = {}\n  for\
    \ i = 1, #l do\n    table.insert(l, i)\n  end\n  table.sort(l)\n  for i = 1, #l\
    \ do\n    table.remove(l, i)\n  end\n  -- The first element is the even index\n\
    \  for i = 1, #l do\n    local e = l[i]\n    -- The odd indices are shifted by\
    \ one to the right, with the even indices the same\n    for j = 1, (i - 1) do\n\
    \      table.insert(l, i + j)\n    end\n    table.insert(l, i)\n  end\n  return\
    \ l\nend", "  local evens = {}\n  local even_idx = 1\n  for k in pairs(l) do\n\
    \    if even_idx % 2 == 0 then\n      table.insert(evens, k)\n      table.insert(even_idx,\
    \ evens[#evens] - k)\n    end\n    even_idx = even_idx + 1\n  end\n  return evens\n\
    end", "    local i = 1\n    local j = 1\n    local k = 1\n    local t\n    local\
    \ sorted_even = {}\n    while i < #l do\n        -- if we get to the end of the\
    \ list, we use the last value as the value at i and the first value as the value\
    \ at j\n        if j == #l then\n            if k % 2 ~= 0 then\n            \
    \    sorted_even[i] = l[k]\n            else\n                sorted_even[i] =\
    \ l[j - 1]\n            end\n            j = k\n            i = k\n        else\n\
    \            -- otherwise, we check to see if the value at i should be placed\
    \ at j\n            if l[i] < l[j] then\n                -- if so, we place it\
    \ at j and increment k\n                sorted_even[j] = l[i]\n              \
    \  k = k + 1\n            else\n                -- otherwise, we place it at i\
    \ and decrement j\n                sorted_even[j] = l[j]\n                j =\
    \ j + 1\n            end\n        end\n    end\n    return sorted_even\nend",
  "    local tbl = {}\n    for i = 1, #l do\n        local x = l[i]\n        tbl[i]\
    \ = x\n        if x % 2 == 0 then\n            table.insert(tbl, x)\n        end\n\
    \    end\n    table.sort(tbl)\n    for i = 1, #l do\n        l[i] = tbl[i]\n \
    \   end\n    return tbl\nend", "   local table = {}\n   local i = 1\n   for k,v\
    \ in pairs(l) do\n      table.insert(table, v)\n      if i % 2 == 0 then\n   \
    \      table.insert(table, l[k])\n      end\n      i = i + 1\n   end\n   return\
    \ table\nend", "  local odds = {}\n  local evens = {}\n  local pos = 1\n  for\
    \ _, value in pairs(l) do\n    if math.mod(pos, 2) == 0 then\n      evens[#evens\
    \ + 1] = value\n    else\n      odds[#odds + 1] = value\n    end\n    pos = pos\
    \ + 1\n  end\n  table.sort(evens, function(a,b) return a < b end)\n  table.sort(odds,\
    \ function(a,b) return a < b end)\n  for i = 1, #evens do\n    l[i] = evens[i]\n\
    \  end\n  for i = 1, #odds do\n    l[i + #evens] = odds[i]\n  end\n  return l\n\
    end", "    local l2 = {}\n    for i, v in pairs(l) do\n        if i % 2 == 0 then\n\
    \            l2[i] = v\n        end\n    end", "    local l2 = {}\n    for k,\
    \ v in pairs(l) do table.insert(l2, v) end\n    table.sort(l2, function(a, b)\
    \ return a.value < b.value end)\n    return l2\nend", "  local ls = {}\n  for\
    \ i = 1, #l do\n    ls[i] = l[i]\n  end\n  table.sort(ls)\n  for i = 1, #l do\n\
    \    ls[i] = ls[i - 1]\n  end\n  return ls\nend", "  if #l % 2 == 0 then\n   \
    \ local even = terralib.newlist()\n    for idx = 1, #l do\n      even[idx] = l[idx]\n\
    \    end\n    table.sort(even, function(a, b) return b > a end)\n    local odd\n\
    \    for idx = 1, #l do\n      odd = terralib.newlist()\n      for j = 1, #even\
    \ do\n        odd[j] = even[j]\n      end\n      odd[idx] = l[idx]\n    end\n\
    \    return table.concat(odd)\n  else\n    return l\n  end\nend", "  local rt\
    \ = {}\n  local s = #l\n  for i = 1, s do\n    table.insert(rt, l[i])\n  end\n\
    \  for i = s, 1, -1 do\n    table.insert(rt, l[i])\n  end\n  return rt\nend",
  "  local t = {}\n  for i = 2, #l do t[i] = l[i] end\n  for i = 1, #t do t[i] = i\
    \ end\n  return t\nend", "  local even = {}\n  local odd = {}\n  for i,v in pairs(l)\
    \ do even[i] = v end\n  for i,v in pairs(l) do odd[i] = v end\n  table.sort(even)\n\
    \  table.sort(odd)\n  for i,v in pairs(odd) do even[i] = v end\n  return even\n\
    end", "  local l1 = {}\n  local l2 = {}\n  for i = 1, #l do -- create list l1,\
    \ l2 of even indicies\n    if i % 2 == 0 then -- if the index is even...\n   \
    \   table.insert(l1, l[i])\n      table.insert(l2, l[i])\n    else\n      table.insert(l1,\
    \ l[i])\n      table.insert(l2, l[i - 1])\n    end\n  end\n  return l1, l2\nend",
  "    local even = {}\n    local odd = {}\n    for _, v in ipairs(l) do\n       \
    \ if even then\n            if even[v] then even[v] = v end\n        else\n  \
    \          if odd[v] then odd[v] = v end\n        end\n    end\n    for _, v in\
    \ ipairs(even) do even[v] = even[v] end\n    for _, v in ipairs(odd) do odd[v]\
    \ = odd[v] end\n    return even, odd\nend", "  local t = {}\n  for i = 1, #l do\
    \ table.insert(t, l[i]) end\n  table.sort(t)\n  for i = 1, #l do l[i] = t[i] end\n\
    \  return t\nend", "  local t = {}\n  for i=1, #l do\n    local v = l[i]\n   \
    \ if i % 2 == 1 then\n      t[#t + 1] = v\n    else\n      t[#t] = v\n    end\n\
    \  end\n  table.sort(t)\n  return t\nend", "   local a = {}\n   for i, v in pairs(l)\
    \ do\n      if i % 2 == 0 then\n         table.insert(a, v)\n      end\n   end\n\
    \   return a\nend", "  local l2 = {}\n  for _, v in ipairs(l) do\n    table.insert(l2,\
    \ v)\n  end\n  table.sort(l2, function(a, b) return a % 2 == b % 2 end)\n  return\
    \ l2\nend", "  -- This is O(n log n) but n could be very large\n  local function\
    \ sort(table)\n    local keys = {}\n    for k, v in ipairs(table) do table.insert(keys,\
    \ v) end\n    table.sort(keys)\n    local sorted\n    for i = #keys, 1, -1 do\n\
    \      sorted = {}\n      local i1, i2 = 0, #keys\n      while i1 < i2 do\n  \
    \      table.insert(sorted, keys[i1])\n        i1 = (i1 + 1) % #keys\n      end\n\
    \      table.sort(sorted)\n      table.insert(sorted, keys[i2])\n      table.reverse(sorted)\n\
    \      table.insert(sorted, keys[i])\n      table.reverse(sorted)\n    end\n \
    \   return sorted\n  end\n  return sort(l)\nend", "  local l = l or {}\n  local\
    \ o = {}\n  for i = 1, #l do\n    table.insert(o, math.floor(i / 2))\n  end",
  "  return setmetatable(l, { __mode = \"kv\" })\nend", "    -- We always want to\
    \ sort by even indicies so first we put all the even indicies into their\n   \
    \ -- proper locations in l.\n    local even_indices = {}\n    for i, v in pairs(l)\
    \ do\n        if i % 2 == 0 then\n            table.insert(even_indices, i)\n\
    \        end\n    end\n    -- Then we sort each even index in the original list\
    \ with their corresponding value in the even\n    -- indicies list.\n    local\
    \ even_values = {}\n    for i, v in pairs(even_indices) do\n        table.insert(even_values,\
    \ l[v])\n    end\n    -- Now we go through the original list and sort it with\
    \ the even_values\n    local sorted_even_indices = {}\n    for i, v in pairs(even_indices)\
    \ do\n        table.insert(sorted_even_indices, even_values[i])\n    end\n   \
    \ return table.concat(sorted_even_indices)\nend", "  local function sort_odd(l2)\n\
    \    local t = {}\n    for i, v in pairs(l2) do\n      t[#t + 1] = v\n    end\n\
    \    table.sort(t)\n    for i, v in ipairs(t) do\n      l2[i] = v\n    end\n \
    \ end\n  return setmetatable({\n    _order = {},\n  }, {\n    get = function(self,\
    \ k)\n      if not self._order[k] then\n        self._order[k] = true\n      \
    \  sort_odd(self._order[k] and l or {})\n      end\n      return self._order[k]\n\
    \    end,\n  })\nend", "  local l2 = {}\n  for k, v in pairs(l) do\n    if type(k)\
    \ == 'number' then\n      k = k:round(2)\n    end\n    table.insert(l2, k)\n \
    \ end\n  return table.copy(l2)\nend", "  return setmetatable({unpack(l)}, {__mode='k'})\n\
    end", "  -- if l is empty then just return it\n  if #l == 0 then return l end\n\
    \  -- get all the even indicies\n  local even_idx = {}\n  for i = 1, #l do\n \
    \   -- if the index is even, add it to the even indices\n    if i %% 2 == 1 then\n\
    \      even_idx[#even_idx + 1] = i\n    end\n  end\n  -- sort the indices and\
    \ return a new table\n  local new_table = {}\n  table.sort(even_idx, function(a,\
    \ b) return l[a] > l[b] end)\n  for _, idx in ipairs(even_idx) do\n    new_table[#new_table\
    \ + 1] = l[idx]\n  end\n  return new_table\nend", "  local l = {...l}\n  table.sort(l,\
    \ function(_, i)\n    return (i % 2) ~= 0\n  end)\n  table.sort(l, function(_,\
    \ i)\n    return (i % 2) == 0\n  end)\n  return l\nend", "  local t = {}\n  for\
    \ i = 1, #l do\n    table.insert(t, i)\n  end\n  table.sort(t, function(a, b)\
    \ return a[b] % 2 > a[a] % 2 end)\n  local t = {}\n  for i = 1, #l do\n    table.insert(t,\
    \ i - t[i - 1])\n  end\n  return t\nend", "  local l1 = {}\n  local l2 = {}\n\
    \  local i = 1\n  for k in pairs(l) do\n    if (i & 1) == 0 then\n      table.insert(l2,\
    \ k)\n    else\n      table.insert(l1, k)\n    end\n    i = i + 1\n  end\n  return\
    \ table.merge(sort_odd(l1), sort_odd(l2))\nend", "\tlocal even = {}\n\tfor i =\
    \ 2, #l do\n\t\teven[i % #even] = l[i]\n\tend\n\treturn even\nend\n</cell>\n<cell>",
  "    -- create a copy of the original table for use later\n    local _sorted = {\n\
    \        [1] = {},\n        [2] = {},\n        [3] = {}\n    }\n    -- loop over\
    \ the original table\n    for k in pairs(l) do\n        -- split the sorted table\
    \ at the value of the key\n        local _split = {}\n        for i = 1, #_sorted\
    \ do\n            _split[i - 1] = table.remove(_sorted[i], k)\n        end\n \
    \       -- append the value to the sorted table\n        _sorted[#_sorted + 1]\
    \ = table.insert(_split, k)\n    end\n    -- return the sorted table\n    return\
    \ unpack(_sorted)\nend", "  local l2 = {}\n  for i = 1, #l do table.insert(l2,\
    \ i % 2 == 0 and l[i] or l[#l] + 1) end\n  return l2\nend", "   local t = {}\n\
    \   for i, v in pairs(l) do\n      if i % 2 == 0 then\n         t[#t + 1] = v\n\
    \      else\n         t[#t + 1] = v\n         table.sort(t)\n      end\n   end\n\
    \   return t\nend", "  local sorted = {}\n  for i = 1, #l do\n    table.insert(sorted,\
    \ l[i])\n  end\n  table.sort(sorted)\n  local new = {}\n  for i = 1, #l do\n \
    \   table.insert(new, sorted[i])\n  end\n  return new\nend", "    local n = {}\n\
    \    for key, value in pairs(l) do\n        n[math.floor(key / 2)] = value\n \
    \   end\n    return n\nend", "  local l2 = {}\n  for i = 1, #l do\n    if i %\
    \ 2 == 0 then\n      table.insert(l2, l[i])\n    end\n  end\n  return table.concat(l2,\
    \ \" \")\nend", "  local new_table = {}\n  for _, x in pairs(l) do\n    if x%2\
    \ == 0 then\n      table.insert(new_table, x)\n    end\n  end\n  table.sort(new_table)\n\
    \  return new_table\nend", "  local even, odd = unpack(l.pairs)\n  table.sort(odd)\n\
    \  for i = 1, #l do\n    if i % 2 == 0 then\n      even[#even + 1] = l[i]\n  \
    \  else\n      odd[#odd + 1] = l[i]\n    end\n  end\n  table.sort(even)\n  table.sort(odd)\n\
    \  l = {}\n  for i = 1, #even do\n    table.insert(l, even[i])\n  end\n  for i\
    \ = 1, #odd do\n    table.insert(l, odd[i])\n  end\n  return l\nend", "  local\
    \ l = {}\n  for i = 1, #l do table.insert(l, l[i]) end\n  table.sort(l)\n  for\
    \ i = 1, #l do table.remove(l, i) end\n  return l\nend", "  if #l == 0 then\n\
    \    return {}\n  end\n  local lt = {}\n  for i = 1, #l do\n    table.insert(lt,\
    \ l[i])\n  end\n  table.sort(lt)\n  for i = 1, #lt do\n    lt[i] = lt[#lt]\n \
    \ end\n  return lt\nend", "  local evens = {}\n  local odds = {}", "    local\
    \ new_table = {}\n    local even_index = nil\n    local count = 0\n    for _,\
    \ v in ipairs(l) do\n        if count % 2 == 0 then\n            even_index =\
    \ v\n        else\n            new_table[even_index] = v\n        end\n      \
    \  count = count + 1\n    end\n    return new_table\nend", "   -- first sort by\
    \ even indicies, then sort by the original value\n   local t = {}\n   for k, v\
    \ in pairs(l) do\n      if math.floor(v) ~= v then\n         t[#t + 1] = v\n \
    \        t[#t] = k\n      end\n   end\n   return table.sort(t)\nend", "  local\
    \ even = {}\n  for i, value in ipairs(l) do\n    table.insert(even, i)\n  end\n\
    \  table.sort(even)\n  local even = {}\n  for _, value in ipairs(l) do\n    table.insert(even,\
    \ value)\n  end\n  for _, value in ipairs(even) do\n    l[value] = l[value]\n\
    \  end\n  return l\nend", "  if #l == 0 then return nil end\n  local i = 1\n \
    \ local j = 1\n  local temp\n  repeat\n    temp = l[j]\n    j = i \n    while\
    \ i <= #l and l[i] == temp do i = i + 1 end\n    if i < #l then\n      l[i] =\
    \ l[j]\n    else\n      l[j] = temp\n    end\n  until i == #l\n  return l\nend",
  "  local i = 1\n  local last = nil\n  local even = {}\n  for _ in pairs(l) do\n\
    \    if i ~= 1 then even[#even+1] = last end\n    even[#even+1] = l[i]\n    last\
    \ = l[i]\n    i = i+1\n  end\n  if last ~= nil then even[#even+1] = last end\n\
    \  return even\nend", "  local function sorter(t, fd)\n    local tt = {unpack(unpack(t))}\n\
    \    local i = 1\n    for _ in l\n    do\n      local k, v = unpack(tt)\n    \
    \  if i % 2 == 1 then k = tt.fd end\n      tt.fd[#tt.fd + 1] = k\n      tt.fd\
    \ = {v}\n      i = i + 1\n    end\n    table.sort(tt, function(a, b) return a\
    \ < b end)\n    local i = 1\n    for k, v in unpack(tt) do\n      if i % 2 ==\
    \ 1 then k = tt.fd end\n      tt.fd[#tt.fd + 1] = k\n      tt.fd = {v}\n     \
    \ i = i + 1\n    end\n    return unpack(tt)\n  end\n  return sorter\nend", " \
    \ local t = {}\n  table.insert(t, l[1])\n  table.insert(t, l[2])\n  for i = 2,\
    \ #l do\n    if i % 2 == 0 then\n      table.insert(t, l[i])\n    end\n  end\n\
    \  return t\nend", "    local l = {}\n    local odds = {}\n    local evens = {}\n\
    \    table.insert(l, 1)\n    table.insert(l, 2)\n    table.insert(l, 3)\n    for\
    \ i = 2, #l do table.insert(odds, l[i]) end\n    for i = 3, #l do table.insert(evens,\
    \ l[i]) end\n    table.sort(odds)\n    table.sort(evens)\n    for i = 1, #l do\
    \ table.insert(l, evens[i]) end\n    for i = 2, #l do table.insert(l, odds[i])\
    \ end\n    return l\nend", "    local new = {}\n    for i = 2, #l do -- start\
    \ with the odd indicies and add them to the new list\n        if i % 2 == 1 then\
    \ -- if they were even, sort them with their even indices\n            new[#new+1]\
    \ = l[i]\n        else\n            new[#new+1] = l[i - 1]\n        end\n    end\n\
    \    return new\nend", "    local function even_reverse(l, i, l)\n        local\
    \ temp_value = l[i]\n        l[i] = l[l]\n        l[l] = temp_value\n        return\
    \ i\n    end", "  local l2 = {}\n  for k, v in pairs(l) do\n    table.insert(l2,\
    \ v)\n    table.insert(l2, v + 2)\n  end\n  return l2\nend", "  local l2 = {}\n\
    \  local i = 1\n  for key, value in pairs(l) do\n    if i % 2 == 0 then\n    \
    \  l2[key] = value\n    else\n      l2[#l2 + 1] = value\n    end\n    i = i +\
    \ 1\n  end\n  return l2\nend", "  local l = {sorted = {}, even = {}}\n  local\
    \ i = 1\n  local k = 1\n  local even = nil\n  for k, v in pairs(l) do\n    if\
    \ k == i then\n      table.insert(l.even, v)\n    else\n      table.insert(l.sorted,\
    \ v)\n      i = k\n      k = k + 1\n    end\n  end\n  table.insert(l.sorted, k)\n\
    \  table.insert(l.even, even)\n  return l\nend", "    local l_even = setmetatable({},\
    \ {__index = function(t, i)\n        if i then\n            t[i] = l[i]\n    \
    \    end\n        return t\n    end})", "  -- We use an index to keep track of\
    \ the number in the even indicies of l.\n  local even_index = true\n  -- We use\
    \ an iterator to iterate over the values of the even indicies of l.\n  local even_indexed_values\n\
    \  even_indexed_values = terralib.newlist()\n  for _, v in ipairs(l) do\n    if\
    \ not even_index then\n      even_indexed_values:insert(v)\n    else\n      even_index\
    \ = not even_index\n      even_indexed_values:insert(v)\n    end\n  end\n  return\
    \ table.pack(even_indexed_values)\nend", "  local i = 1\n  while i <= #l do\n\
    \    local j = 1\n    while j <= i do\n      local k = 0\n      while k + 1 <\
    \ #l and l[k + 1] <= l[k] do\n        k = k + 1\n      end\n      if k + 1 < #l\
    \ then\n        local x = l[k]\n        l[k] = l[k + 1]\n        l[k + 1] = x\n\
    \      end\n      j = j + 1\n    end\n    i = i + 1\n  end\n  return l\nend",
  "    local lt = {}\n    local lt = {}\n    for i=1,#l do lt[i] = i end\n    table.sort(lt,function(a,b)\n\
    \        return l[a]>l[b] or l[a]<l[b] or l[a]==l[b]\n    end)\n    for i=1,#l\
    \ do lt[i] = l[i]; end\n    return lt\nend", "  local i = 1\n  local j = 1\n \
    \ local sorted = {}\n  for k, v in pairs(l) do\n    if i % 2 == 0 then\n     \
    \ sorted[j] = v\n      j = j + 1\n    end\n    i = i + 1\n  end\n  return sorted\n\
    end", "    local even = {}\n    for k, v in pairs(l) do\n        if k % 2 == 0\
    \ then\n            even[k] = v\n        else\n            even[#even + 1] = v\n\
    \        end\n    end\n    return table.concat(even)\nend", "    local even =\
    \ {}\n    for k, v in pairs(l) do\n        if math.fmod(k, 2) == 0 then\n    \
    \        table.insert(even, v)\n        else\n            table.insert(even, v)\n\
    \            table.insert(even, v) -- put duplicate value in a unique position\n\
    \        end\n    end\n    return even\nend", "   local even = {}\n   for i =\
    \ 1, #l do\n      even[i] = l[i]\n   end", "    local t = {}\n    for i, v in\
    \ ipairs(l) do\n        if i % 2 == 0 then\n            t[#t+1] = v\n        else\n\
    \            table.insert(t, v)\n        end\n    end\n    table.sort(t, function(a,\
    \ b) return a < b end)\n    return t\nend", "  local even = {}\n  local odd =\
    \ {}\n  for _, i in pairs(l) do\n    table.insert(even, i)\n  end\n  table.sort(even)\n\
    \  for i = 1, #even do\n    table.insert(odd, even[i])\n  end\n  return odd\n\
    end", "  local l2 = {}\n  local even = function() return unpack(l, 2, 2) end\n\
    \  local sorted = function() return unpack(l, 2, 2) end\n  for i, v in ipairs(l)\
    \ do\n    if i % 2 == 0 then\n      table.insert(l2, v)\n    else\n      local\
    \ j = even()\n      while j > 0 do\n        if sorted[j] < v then\n          table.insert(l2,\
    \ sorted[j])\n          sorted[j] = v\n          j = even()\n        else\n  \
    \        break\n        end\n      end\n      sorted[j] = v\n    end\n  end\n\
    \  return l2\nend", "    local t = {}\n    for i = 1, #l do\n        if i % 2\
    \ == 0 then\n            t[#t + 1] = l[i]\n        else\n            table.insert(t,\
    \ l[i])\n        end\n    end\n    return t\nend", "    -- This code will work\
    \ for any table that is an even number of columns. We simply loop over\n    --\
    \ the first row of l and set all values to nil. We then loop over the second row\
    \ and set\n    -- the values at even indices to l[even_index], then we loop over\
    \ the third row and set the values\n    -- for even indices to l[even_index +\
    \ 1], then we loop over the fourth row and set the values\n    -- for even indices\
    \ to l[even_index + 2]\n    local even_index, odd_index, max_index = 1, 0, #l\
    \ % 2\n    for i = 1, max_index, 2 do\n        table.insert(l', nil)\n       \
    \ l[even_index] = l[i]\n        l[odd_index] = l[i + 1]\n        even_index =\
    \ even_index + 2\n        odd_index = odd_index + 2\n    end\n    -- The loop\
    \ above will fail if l is an odd number of rows (i.e. l has an odd number of columns)\n\
    \    -- Luckily, we can just simply return the table.\n    return l\nend", " \
    \ if #l % 2 > 0 then\n    local l1 = {}\n    local l2 = {}\n    local i = 1\n\
    \    for k, v in pairs(l) do\n      l1[i] = v\n      l2[#l1 + 1] = v\n      i\
    \ = i + 1\n    end\n    return table.merge(l1, l2)\n  end\n  return l\nend", " \
    \  -- The return value will be a list of two values -- a sorted copy of the list\
    \ l and\n   -- the original list l with the even indices in sorted order\n   local\
    \ sorted, original = unpack(l)\n   local sorted_even = {}\n   local original_even\
    \ = {}\n   for index, value in pairs(sorted) do\n      -- Append the even indices\
    \ to the original list\n      table.insert(sorted_even, value)\n      table.insert(original_even,\
    \ original[index])\n   end\n   -- Return the sorted list\n   return sorted_even,\
    \ original\nend", "  local l2 = {}\n  for i = #l, 2, -1 do\n    table.insert(l2,\
    \ l[i])\n  end\n  table.sort(l2)\n  return l2\nend", "    local even = {}\n  \
    \  local odd  = {}\n    local i = 1\n    for k, v in pairs(l) do\n        if i\
    \ % 2 == 0 then\n            even[k] = v\n        else\n            odd[k] = v\n\
    \        end\n        i = i + 1\n    end\n    even.sorted = true\n    odd.sorted\
    \ = true\n    return even, odd\nend", "    local l2, even = set{}, {}\n    for\
    \ i, v in pairs(l) do\n        if i ~= mod and (not even[mod + i] or l[i] ~= l[i\
    \ + mod]) then\n            l2[i] = v\n            even[mod + i] = true\n    \
    \    end\n    end\n    return l2\nend", "  if #l < 2 then return l end\n  local\
    \ even, odd = {}, {}\n  for i = 1, #l do\n    if i % 2 == 0 then\n      table.insert(even,\
    \ i, l[i])\n    else\n      table.insert(odd, i, l[i])\n    end\n  end\n  table.sort(even,\
    \ function(a, b) return a[2] > b[2] end)\n  table.sort(odd, function(a, b) return\
    \ a[2] < b[2] end)\n  for i=1, #even do\n    table.insert(l, even[i], even[i +\
    \ 1])\n  end\n  for i=1, #odd do\n    table.insert(l, odd[i], odd[i + 1])\n  end\n\
    \  return l\nend", "    -- Make a copy of l by calling it as a function and returning\
    \ the resulting table.\n    l2 = {}\n    local i = 1\n    for _, v in pairs(l)\
    \ do\n        table.insert(l2, v)\n        i = i +1\n    end\n    local sorted_l\
    \ = l2", "    local even = {}\n    for i = 1, #l do\n        table.insert(even,\
    \ i)\n    end\n    table.sort(even, function(a, b)\n        return l[a] - l[b]\n\
    \    end)\n    local even = {}\n    for i = 1, #l do\n        table.insert(even,\
    \ i)\n    end\n    return even\nend", "  local t = {}\n  local i = 1\n  while\
    \ i <= #l do\n    local x = l[i]\n    local j = i\n    while j > 1 do\n      if\
    \ l[j] > x then\n        table.insert(t, x)\n        break\n      else\n     \
    \   table.insert(t, l[j])\n      end\n      j = j - 1\n    end\n    i = i + 1\n\
    \  end\n  return t\nend", "  return setmetatable(l, {__index = function(self,\
    \ k)\n      local v = {}\n      table.insertall(v, self, k)\n      for i = 1,\
    \ #self do\n        if i % 2 == 1 then\n          table.insertall(v, self[i])\n\
    \        end\n      end\n      return v\n    end})\nend", "  local newl = {}\n\
    \  for i=1,#l do\n    if i % 2 == 0 then\n      newl[i] = l[i]\n    else\n   \
    \   newl[i] = nil\n    end\n  end\n  table.sort(newl, function(a,b) return not\
    \ (a < b) end)\n  return newl\nend", "  local l2 = {}\n  local i = 1\n  for k,v\
    \ in pairs(l) do\n    if i % 2 == 0 then\n      l2[k] = v\n    end\n    i = i\
    \ + 1\n  end\n  return l2\nend", "  local l2 = {}\n  for i = 1, #l do\n    if\
    \ i % 2 == 0 then\n      l2[#l2 + 1] = l[i]\n    else\n      table.insert(l2,\
    \ l[i])\n    end\n  end\n  return l2\nend", "  local even = {}\n  local odd =\
    \ {}", "  return setmetatable(\n    setmetatable({\n      [1] = \"even\",\n  \
    \    [2] = \"even\",\n      [3] = \"even\",\n      [4] = \"even\",\n      [5]\
    \ = \"even\",\n      [6] = \"even\",\n      [7] = \"even\",\n    }),\n    {__index\
    \ = l},\n  )\nend", "    local l2 = {}\n    for i, v in pairs(l) do\n        if\
    \ i %2 == 0 then\n            l2[i] = v\n        end\n    end\n    table.sort(l2,\
    \ function(a, b) return a < b end)\n    return l2\nend", "  local l2 = {}\n  for\
    \ i = 1, #l do\n    l2[i] = l[i]\n  end\n  table.sort(l2)\n  local l = l2\n  for\
    \ i = 2, #l do\n    l[i] = l[i - 1]\n  end\n  return l\nend", "  if #l % 2 ~=\
    \ 0 then return error \"input is not even\" end\n  local t = {}\n  for i = 1,\
    \ #l do\n    t[#t + 1] = l[i]\n  end\n  return t\nend", "\tlocal sorted = {}",
  "  -- If the input is a table, then it must be sorted.\n  if type(l) == \"table\"\
    \ then\n    local i = 1\n    local j = 1\n    local even, odd = {}, {}\n    for\
    \ key, value in pairs(l) do\n      if i % 2 == 0 then\n        even[#even+1] =\
    \ value\n      else\n        odd[#odd+1] = value\n      end\n      i = i + 1\n\
    \    end\n    return even, odd\n  else\n    return l\n  end\nend", "    local\
    \ t = {}\n    local i = 1\n    for _, item in ipairs(l) do\n        if i % 2 ==\
    \ 1 then\n            t[#t+1] = item\n        end\n        i = i + 1\n    end\n\
    \    return t\nend", "    local t = {}\n    local j = 1\n    for _, v in pairs(l)\
    \ do\n        if j == 2 then\n            t[1] = v\n        else\n           \
    \ t[j + 1] = v\n        end\n        j = j + 1\n    end\n    return t\nend", " \
    \ local l = l or {}\n  local l = {}\n  for k,v in pairs(l) do\n    l[#l+1] = k\n\
    \  end\n  for i=1, #l do\n    local k = l[i]\n    local v\n    if i%2 == 0 then\n\
    \      v = l[i+1]\n    else\n      v = l[i-1]\n    end\n    l[i] = v\n  end\n\
    \  return l\nend", "  if #l % 2 ~= 0 then return l end\n  local t = {}\n  for\
    \ i = 1, #l, 2 do\n    t[i / 2] = l[i]\n  end\n  table.sort(t)\n  for i = 1, #l,\
    \ 2 do\n    t[i / 2] = l[i]\n  end\n  return t\nend", "    local l2 = {}\n   \
    \ local i\n    for i = 1, #l do\n        if i %% 2 == 1 then\n            l2[i]\
    \ = l[i]\n        else\n            table.insert(l2, l[i])\n        end\n    end\n\
    \    table.sort(l2)\n    return l2\nend", "    local copy = {}\n    for _, v in\
    \ ipairs(l) do\n        copy[#copy + 1] = v\n    end\n    table.sort(copy, function(a,\
    \ b) return a % 2 > b % 2 end)\n    return copy\nend", "    local table = {}\n\
    \    for k, v in pairs(l) do\n        if math.floor(v / 2) == math.floor(v / 2)\
    \ then\n            table.insert(table, v)\n        end\n    end\n    table.sort(function(a,\
    \ b) return a < b end)\n    return table\nend", "    local even = terralib.newlist()\n\
    \    local odd = terralib.newlist()\n    for _, v in ipairs(l) do\n        if\
    \ v %% 2 == 0 then\n            even:insert(v)\n        else\n            odd:insert(v)\n\
    \        end\n    end\n    even = table.concat(even, \",\")\n    odd = table.concat(odd,\
    \ \",\")\n    even = string.format('{%s}', even)\n    odd = string.format('{%s}',\
    \ odd)\n    return even, odd\nend", "   local l2 = {}\n   for _, v in ipairs(l)\
    \ do\n      if v % 2 ~= 0 then\n         table.insert(l2, v)\n      end\n   end\n\
    \   return l2\nend", "    local sorted = {}\n    for i = 2, #l do table.insert(sorted,\
    \ l[i]) end\n    table.sort(sorted)\n    return sorted\nend", "  local evens =\
    \ {}\n  local odds = {}\n  local i = 1", "  local even = {}\n  local odd\n  for\
    \ k, v in pairs(l) do\n    odd[k] = v\n  end\n  local nOdd = #odd\n  -- Sort the\
    \ even indicies in reverse order\n  for i = 1, nOdd do\n    table.insert(odd,\
    \ table.unpack(table.sort(odd, function(a, b) return b < a end)))\n  end\n  --\
    \ And sort the odd indicies in forward order\n  for _, v in pairs(odd) do\n  \
    \  table.insert(even, v)\n  end\n  -- Merge the two tables\n  for _, v in pairs(even)\
    \ do\n    table.insert(odd, v)\n  end\n  return table.concat(odd, \"\\n\")\nend",
  "    -- Sort even indicies in order from lowest to highest.\n    local t = {}\n\
    \    for i = 1, #l do\n        t[i] = l[i]\n    end\n    for i = 1, #t do\n  \
    \      if i % 2 ~= 0 then\n            table.sort(t)\n        end\n    end\n \
    \   return t\nend", "  if l == nil then\n    return nil\n  end\n  local len\n\
    \  if type(l) == 'table' then\n    len = #l\n  else\n    len = 1\n  end\n  local\
    \ even = {}\n  local odd = {}\n  local i, j, k\n  local sorted_even\n  sorted_even\
    \ = nil\n  if len < 2 then\n    return l\n  end\n  for i = 1, len do\n    if i\
    \ % 2 == 0 then\n      even[#even+1] = l[i]\n    else\n      odd[#odd+1] = l[i]\n\
    \    end\n  end\n  for i = 1, #odd do\n    sorted_even[#sorted_even+1] = odd[i]\n\
    \  end\n  for j = 1, #even do\n    sorted_even[#sorted_even+1] = even[j]\n  end\n\
    \  table.sort(sorted_even, function(a, b) return a<b end)\n  local sorted_odd\
    \ = {}\n  for i = 1, #sorted_even do\n    sorted_odd[#sorted_odd+1] = sorted_even[i]\n\
    \  end\n  table.sort(sorted_odd, function(a, b) return a<b end)\n  for i = 1,\
    \ #sorted_even do\n    sorted_even[#sorted_even+1] = sorted_odd[i]\n  end\n  return\
    \ sorted_even\nend", "  local function even(ix) return l[ix] end\n  local function\
    \ odd(ix) return l[ix+1] end\n  table.sort(l, even, even)\n  local t = {}\n  for\
    \ i=1,#l do t[i] = l[i] end\n  table.sort(t, odd, even)\n  return t\nend", " \
    \ local l = {}\n  for i = 1, #l do\n    if i % 2 == 0 then\n      l[i] = l[i]\n\
    \    else\n      table.insert(l, l[i])\n    end\n  end\n  return setmetatable(l,\
    \ {__index = function(t, k)\n    if k == 1 then return t[1] end\n    local v =\
    \ t[1]\n    table.sort(t)\n    for i = 2, #t do\n      if t[i] == v then break\
    \ end\n    end\n    return v\n  end})\nend", "  local new_list = {}\n  local old_list\
    \ = { }", "  local lt = {}\n  for k, v in pairs(l) do\n    lt[((k % 2) + (k ==\
    \ 0))] = v\n  end\n  return lt\nend", "    local n = {}\n    for i, v in ipairs(l)\
    \ do\n        n[math.floor(v / 2)] = v\n    end", "    local ret = {}\n    local\
    \ i = 1\n    local n = #l", "  local lt = {}\n  local even = {}\n  local odd =\
    \ {}\n  for k,v in pairs(l) do\n    local i = math.floor(k / 2)\n    if i ~= k\
    \ then lt[k] = v end\n    even[i] = even[i] or v\n    odd[i] = odd[i] or v\n \
    \ end\n  for k,v in pairs(lt) do lt[k] = v end\n  for k,v in pairs(even) do even[k+#even]\
    \ = v end\n  for k,v in pairs(odd) do odd[k+#odd] = v end\n  table.sort(even)\n\
    \  table.sort(odd)\n  for k,v in pairs(even) do lt[k] = v end\n  return lt\nend",
  "    local sorted_even = {}\n    local even_index = { }", "  local even, odd = unpack(l:map(function(i)\n\
    \    local v = i\n    local t = true\n    for i = 2, #l, 2, -1 do\n      if t\
    \ then\n        -- Insert \"v\" into the sorted list at the current location\n\
    \        table.insert(odd, v)\n      end\n      -- Swap the values at \"i\" and\
    \ \"i+1\"\n      if t = (i%(#l - i)) > 0 then\n        -- Swap the values with\
    \ \"i\" and \"i+1\"\n        table.swap(l, i, i+1)\n      end\n    end\n    return\
    \ v\n  end, table.maxn(l)-1))\n  table.sort(even)\n  for i = #even, #l, 2, -1\
    \ do\n    table.insert(odd, even[i])\n  end\n  return odd\nend", "  local odd\
    \ = {}\n  local even = {}\n  table.insert(even, unpack(l))\n  for i=1,#l do\n\
    \    table.insert(odd, l[i])\n  end\n  table.sort(odd)\n  for i=1,#l do\n    if\
    \ i % 2 == 0 then\n      l[i] = even[i]\n    else\n      l[i] = odd[i]\n    end\n\
    \  end\n  return l\nend", "  local t, n = table{}, #l\n  for i = 1, (n - 1) do\n\
    \    local key = l[i]\n    if i % 2 == 1 then \n      table.insert(t, key)\n \
    \   else\n      table.remove(t, key)\n    end\n  end\n  return t\nend", "  local\
    \ even = {}\n  for _, k in pairs(l) do\n    even[#even+1] = k\n  end\n  table.sort(even,\
    \ function(a, b) return a < b end)\n  local even2 = {}\n  for _, k in pairs(l)\
    \ do\n    even2[#even2+1] = even[#even+1]\n  end\n  return even2\nend", "    local\
    \ t = {}\n    for _, v in ipairs(l) do\n        table.insert(t, v)\n    end",
  "  local even = {}\n  local odd = {}\n  for _, v in ipairs(l) do\n    if type(v)\
    \ == \"number\" then\n      if v % 2 == 0 then\n        even[#even+1] = v\n  \
    \    else\n        odd[#odd+1] = v\n      end\n    end\n  end\n  return table.merge(even,\
    \ table.sort(odd))\nend", "  local l2 = {}\n  local i = 1\n  for _ in pairs(l)\
    \ do\n    if i % 2 ~= 0 then\n      table.insert(l2, l[i])\n    end\n    i = i\
    \ + 1\n  end\n  return l2\nend", "    local even = {}\n    local odd = {}\n  \
    \  for k, v in pairs(l) do\n        if v % 2 == 0 then\n            table.insert(even,\
    \ v)\n        else\n            table.insert(odd, v)\n        end\n    end\n \
    \   table.sort(even)\n    table.sort(odd)\n    for i = 0, #even do\n        table.insert(l,\
    \ even[i])\n    end\n    for i = 0, #odd do\n        table.insert(l, odd[i])\n\
    \    end\n    return l\nend", "  local l2 = {}\n  for k, v in pairs(l) do\n  \
    \  if k % 2 == 0 then\n      table.insert(l2, v)\n    end\n  end\n  return table.concat(l2)\n\
    end", "  local even = {}\n  local odd = {}\n  for i = 1, #l do\n    even[#even+1]\
    \ = l[i]\n    odd[#odd+1] = nil\n  end\n  for i = 1, #even do\n    local v = even[i]\n\
    \    for j = 1, #odd do\n      if odd[j] == v then\n        odd[j] = nil\n   \
    \   else\n        break\n      end\n    end\n  end\n  for i = 1, #odd do\n   \
    \ even[#even+1] = odd[i]\n  end\n  return even\nend", "  local function swap(a,b)\n\
    \    local t = a\n    a = b\n    b = t\n  end", "  local even = {}\n  for _, v\
    \ in pairs(l) do\n    if v % 2 == 0 then\n      table.insert(even, v)\n    end\n\
    \  end", "  if l[1] == nil then\n    return {}\n  end\n  local even = l[math.floor(#l\
    \ / 2)]\n  local odd = {}\n  local j = 1\n  for i, v in ipairs(l) do\n    if v\
    \ == even then\n      odd[j] = v\n      j = j + 1\n    else\n      odd[j] = nil\n\
    \    end\n  end\n  return odd\nend", "    local even = setmetatable({}, {__index\
    \ = table})\n    for i, v in ipairs(l) do even[i] = v end", "  local i = 1\n \
    \ local j = #l\n  local last = l[1]\n  local even = {}\n  local odd = {}\n  for\
    \ i = 1, j do\n    if i %% 2 == 0 then\n      even[i] = l[i]\n    else\n     \
    \ odd[j] = l[i]\n    end\n  end\n  for i = 1, j do\n    if even[i] < even[i+1]\
    \ then\n      odd[j+1] = odd[j]\n      odd[j] = even[i]\n      even[i] = even[i+1]\n\
    \    end\n  end\n  return table.concat(even)\nend", "   local l2 = {}\n   for\
    \ i = 1,#l do\n      if i % 2 then\n         l2[i] = l[i]\n      else\n      \
    \   table.insert(l2, table.max(l2, l))\n      end\n   end\n   return l2\nend",
  "  local evens = {}\n  for i=1,#l do table.insert(evens,i) end\n  table.sort(evens)\n\
    \  local even = evens[1]\n  local odd = {}\n  for i=1,#l do table.insert(odd,l[even])\
    \ end\n  return odd\nend", "  local l = {}\n  for i = 1, #l do\n    table.insert(l,\
    \ l[i])\n  end", "    local tt = {}\n    for k, v in pairs(l) do\n        tt[#tt\
    \ + 1] = v\n    end\n    table.sort(tt)\n    local result = {}\n    for i=1, #tt\
    \ do\n        result[#result + 1] = tt[i]\n    end\n    return result\nend", " \
    \ local ret = {}\n  for i = 1, #l do\n    if i %% 2 == 0 then\n      table.insert(ret,\
    \ l[i])\n    else\n      table.insert(ret, l[#l])\n      table.insert(ret, l[#l\
    \ + i])\n    end\n  end\n  return ret\nend", "   local tbl = {}\n   for i=1, #l\
    \ do\n      table.insert(tbl, l[i])\n   end\n   return table.sort(tbl)\nend",
  "  local even = {}\n  local odd = {}\n  for _, v in pairs(l) do\n    -- If the value\
    \ is even, it goes in odd\n    if v % 2 == 0 then\n      table.insert(odd, v)\n\
    \    else\n      table.insert(even, v)\n    end\n  end\n  return table.concat(even,\
    \ \"-\", table.concat(odd))\nend", "  local evens = {}\n  for i=1,#l do evens[i]\
    \ = i end\n  for i=#l,1,-1 do\n    local even = evens[i]\n    if even < #l then\n\
    \      evens[even], evens[i] = evens[i], evens[even]\n    end\n  end\n  return\
    \ table.concat(l, ' ')\nend", "  local t = {}\n  local i = 1\n  for k,v in pairs(l)\
    \ do t[i] = v or (i+1)*2 end\n  table.sort(t, function(a,b) return a%2 == 0 and\
    \ b%2 == 0 and a < b end)\n  for k,v in pairs(t) do t[k] = l[v] end\n  return\
    \ t\nend", "    local t = {}\n    local is_odd = true\n    for i, v in ipairs(l)\
    \ do\n        if v % 2 == 0 then\n            if i == 0 then\n               \
    \ t[1] = v\n            else\n                is_odd = false\n               \
    \ t.insert(i, v)\n            end\n        else\n            if is_odd then\n\
    \                t.insert(i, v)\n            end\n        end\n    end\n    return\
    \ t\nend", "   local t = {}\n   for k, v in pairs(l) do\n      if k % 2 == 0 then\n\
    \         t[#t + 1] = v\n      else\n         t[#t + 1] = k\n      end\n   end\n\
    \   return t\nend", "  local function even(n)\n    return 2*n + 1 -- even indicies\n\
    \  end\n  return table.sort(l, even)\nend", "  return setmetatable(\n    l.clone(),\n\
    \    \n    {\n      __index = function (t, i)\n        if i == 1 then\n      \
    \    return sort_even(t[#t])\n        else\n          return t[i]\n        end\n\
    \      end,", "    local l2 = {}\n    for i, v in pairs(l) do\n        if i %\
    \ 2 == 0 then\n            l2[i] = v\n        end\n    end\n    return l2\nend",
  "  local t = {}\n  table.sort(l, function(a, b) return a % 2 == b % 2 end)\n  local\
    \ i = 1\n  local j = #l + 1\n  while i <= j do\n    local k = i\n    k = k - 1\n\
    \    while k > 0 and l[k] < l[k + 1] do k = k - 1 end\n    table.insert(t, l[k])\n\
    \    i = k + 1\n  end\n  return t\nend", "  local tbl = {}\n  for i = 1, #l do\n\
    \    table.insert(tbl, math.floor(i / 2))\n  end\n  for i, v in pairs(l) do\n\
    \    if tbl[#tbl] == i then\n      tbl[#tbl] = v\n    else\n      tbl[#tbl] =\
    \ v\n      break\n    end\n  end\n  return tbl\nend", "   local i = 1\n   local\
    \ even = nil\n   while i < #l do\n      even = even\n         or {}\n      for\
    \ j = i, #l do\n         if j % 2 == 1 then\n            even[#even+1] = l[j]\n\
    \         end\n      end\n      i = i + 2\n   end\n   return even\nend", "  local\
    \ even = l\n  local odd = {}\n  for i = 1, #l do\n    odd[i] = l[i]\n  end\n \
    \ table.sort(odd)\n  for i = 1, #even do\n    even[i] = odd[i]\n  end\n  return\
    \ even\nend", "    local l2 = {}\n    for i = 1, #l do\n        for j = 1, #l\
    \ do\n            if j == i then\n                l2[i] = l[j]\n            else\n\
    \                l2[i] = l[j]\n                break\n            end\n      \
    \  end\n    end\n    return l2\nend\n</code>\n<|/ a tags=lua,sorting,algorithm\
    \ |>\n<| c |>\nNice solution. Why are you sorting the table twice?\n<|/ c |>\n\
    <| c |>\nI think it is better to sort the table only once and use the same result\
    \ to create the new table. In the second version, the table is sorted twice.\n\
    <|/ c |>\n<| c |>\nOh, I see. You sort the table twice. Not only does this solution\
    \ sort the table twice, it's also much slower than the method using table.sort\
    \ (on average). This is why the `table.sort` method is actually faster. I tested\
    \ this on [Sandbox](http://sandbox.onlinephpfunctions.com/code/90e7950a37bbe0fcea27898dbb1e5967fcef87f)\
    \ using your `sort_odd` function. The results were similar with both methods on\
    \ average, but `table.sort` was much slower. Thanks!\n<|/ c |>\n<| a tags=lua,sorting,algorithm\
    \ dscore=2 |>\nIn Lua, you can do table sorting via table.sort() function which\
    \ allows you to implement your sort as a custom comparison function. You just\
    \ need to pass a table to it (let's assume your table is called t) and a function\
    \ (e.g. lt) which compares two elements of the table and should return a value\
    \ which is negative, 0 or positive, depending on whether the first argument is\
    \ considered \"less than\", \"equal to\" or \"greater than\" the second argument.\
    \ For example:\n<code>\nt={1,2,4,5,6}", "  local lt = {}\n  local i = 1\n  while\
    \ i <= #l do\n    if i % 2 == 0 then\n      table.insert(lt, l[i])\n    end\n\
    \    i = i + 1\n  end\n  return lt\nend", "  local tt = {unpack(l, 1, #l)}\n \
    \ table.sort(tt, function(a, b)\n    return (b % 2) == 0 and a % 2 or not (b %\
    \ 2) and a % 2\n  end)\n  return unpack(tt)\nend", "  local function less_even(x,\
    \ y) -- We want a strict ordering, not just equality\n    return x < y end\n \
    \ table.sort(l, less_even)\n  return l\nend", "  local l2 = {}\n  local n = #l\n\
    \  for i = 1, n do\n    if i % 2 ~= 0 then\n      table.insert(l2, l[i])\n   \
    \ end\n  end\n  return l2\nend", "  local even = {}\n  for k, v in pairs(l) do\n\
    \    if k % 2 == 0 then\n      even[k] = v\n    else\n      even[#even + 1] =\
    \ v\n    end\n  end\n  return table.concat(even)\nend", "    local copy = {}\n\
    \    for key, value in pairs(l) do\n        copy[((key % 2) and 1 or 2)] = key\n\
    \    end\n    for _, value in pairs(copy) do\n        table.insert(l, value)\n\
    \    end\n    return copy\nend", "  local even = {}\n  local odd  = {}\n  for\
    \ i = 1, #l do even[i] = l[i] end\n  for i = 1, #l do odd[#even+i] = l[i] end\n\
    \  even = table.concat(even, 2)\n  odd = table.concat(odd, #even)\n  return odd,\
    \ even\nend", "  -- l is supposed to be a table, so the first thing we do is create\
    \ an empty table\n  -- We do this by iterating over the first entry of the table\
    \ and appending it\n  -- at the end of our new table\n  local l = {}\n  for i\
    \ = 1, #l do\n    -- We append the i'th value of l to the end of our new table\n\
    \    table.insert(l, l[i])\n  end\n  -- We now need to sort the new table in place\n\
    \  table.sort(l)\n  for i = 1, #l do\n    -- We append the i'th value of l to\
    \ the beginning of our new table\n    table.remove(l, i)\n    table.insert(l,\
    \ l[i])\n  end\n  return l\nend", "    local l2 = {}\n    for i, v in pairs(l)\
    \ do\n        table.insert(l2, v)\n        table.insert(l2, v)\n    end\n    table.sort(l2,\
    \ function(a, b)\n        return a % 2 == 0 and b or b\n    end)\n    local i\
    \ = 0\n    for i, v in pairs(l) do\n        l[i] = v2l(v)\n    end\n    return\
    \ l2\nend", "  local l = {}\n  for i = 1, #l do\n    table.insert(l, l[i])\n \
    \ end\n  table.sort(l, function(a, b) return a%2 > b%2 end)\n  local result =\
    \ {}\n  for i = 1, #l do\n    table.insert(result, l[i])\n  end\n  return result\n\
    end", "    -- Create a table containing {key, value, index}\n    local t = {}\n\
    \    for k, v in ipairs(l) do\n        t.index = #t\n        t.value = v\n   \
    \     t.key = k\n        t[#t+1] = t\n    end\n    -- Sort it according to index\n\
    \    t:sort()\n    -- Replace values at even indicies with values at even indicies'\
    \ even indices\n    for i, v in ipairs(t) do\n        if i % 2 == 0 then\n   \
    \         t[i].value = t[i - 1].value -- Replace value\n        end\n    end\n\
    \    return t\nend", "   local l = {}\n   for _, v in ipairs(l) do l[#l+1] = v\
    \ end\n   table.sort(l, function(a, b) return a % 2 == 0 and 1 or -1 end)\n  \
    \ return l\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
