name: HumanEval_114_minSubArraySum
language: lua
prompt: "-- Given a table of integers nums, find the minimum sum of any non-empty\
  \ sub-table\n-- of nums.\n-- Example\n-- >>> minSubArraySum({2, 3, 4, 1, 2, 4})\n\
  -- 1\n-- >>> minSubArraySum({-1, -2, -3})\n-- -6\nlocal function minSubArraySum(nums)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = minSubArraySum\n\
  \    lu.assertEquals(candidate({2, 3, 4, 1, 2, 4}), 1)\n    lu.assertEquals(candidate({-1,\
  \ -2, -3}), -6)\n    lu.assertEquals(candidate({-1, -2, -3, 2, -10}), -14)\n   \
  \ lu.assertEquals(candidate({-9999999999999999}), -9999999999999999)\n    lu.assertEquals(candidate({0,\
  \ 10, 20, 1000000}), 0)\n    lu.assertEquals(candidate({-1, -2, -3, 10, -5}), -6)\n\
  \    lu.assertEquals(candidate({100, -1, -2, -3, 10, -5}), -6)\n    lu.assertEquals(candidate({10,\
  \ 11, 13, 8, 3, 4}), 3)\n    lu.assertEquals(candidate({100, -33, 32, -1, 0, -2}),\
  \ -33)\n    lu.assertEquals(candidate({-10}), -10)\n    lu.assertEquals(candidate({7}),\
  \ 7)\n    lu.assertEquals(candidate({1, -1}), -1)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\t-- Base case\n\tif not nums then\n\t\treturn 0\n\tend", "    if nums\
    \ then\n        local numsSet = {}\n        for _, v in pairs(nums) do numsSet[v]\
    \ = 1 end\n        local minSum, minSumIdx = 0, 1\n        for i = 2, #nums do\n\
    \            local subSum = 0\n            for j = 1, i do\n                subSum\
    \ = subSum + nums[minSumIdx]\n                minSumIdx = minSumIdx + 1\n    \
    \        end\n            if subSum > minSum then\n                minSum = subSum\n\
    \                minSumIdx = i\n            end\n        end\n        return minSum\n\
    \    end\n    return 0\nend", "    assert(#nums > 0, \"Must pass an array greater\
    \ than 0 to the function\")\n    local minSum = #nums\n    for i = 1, #nums do\n\
    \        local subSum = nums[i+1] - nums[i]\n        minSum = math.min(subSum,\
    \ minSum)\n    end\n    return minSum\nend", "  local total = 0 -- Keep track\
    \ of running sum\n  local min = nil -- Keep track of running min\n  for i = 1,\
    \ #nums do\n    local val = nums[i]\n    total = total + val\n    if min == nil\
    \ or val < min then\n      min = val\n    end\n  end\n  return total\nend", " \
    \  local minimum, minimumIndex\n   for i = 1, #nums do\n      minimum, minimumIndex\
    \ = 0, 0\n      for j = 1, i do\n         minimum, minimumIndex = minimum + nums[j],\
    \ minimumIndex\n      end\n      if minimum > 0 then\n         return minimumIndex\n\
    \      end\n   end\n   return nil\nend", "  local minimum = math.inf\n  local\
    \ subTableSize = nil\n  for i = 1, #nums do\n    local subTable = nums[i]:sub(2,\
    \ i - 1)\n    if subTableSize == nil then\n      subTableSize = #subTable\n  \
    \  elseif subTableSize ~= #subTable then\n      return nil\n    end\n    local\
    \ sum = 0\n    for j = 1, #subTable do\n      sum = sum + subTable[j]\n    end\n\
    \    if sum < minimum then\n      minimum = sum\n      subTable = subTable\n \
    \   end\n  end\n  return minimum\nend", "\tlocal min, i = {}, 0\n\tfor i = 1,\
    \ #nums do\n\t\ttable.insert(min, nums[i])\n\t\tfor j = i+1, #nums do\n\t\t\t\
    if j > #nums or nums[j] <= nums[i] then\n\t\t\t\tbreak\n\t\t\telseif nums[i] <\
    \ nums[j] then\n\t\t\t\tbreak\n\t\t\telseif nums[j] < nums[i] then\n\t\t\t\ttable.insert(min,\
    \ nums[j])\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\ttable.sort(min)\n\treturn\
    \ min[1]\nend", "    -- Base case: If there are no more numbers to check, return\
    \ 0\n    if #nums == 0 then\n        return 0\n    end\n    -- Recursive case:\
    \ If the current number is less than the current minimum sum, set it to this number\n\
    \    if nums[1] < minSubArraySum(nums[2:]) then\n        minSubArraySum = nums[1]\n\
    \    end\n    -- Recursive case: If the current number is equal to the minimum\
    \ sum, continue searching\n    if nums[1] == minSubArraySum then\n        minSubArraySum\
    \ = minSubArraySum(nums[2:]) + 1\n    end\nend", "  local ans, sum, num\n  for\
    \ _, num in ipairs(nums) do\n    sum = sum + num\n    if sum > ans then\n    \
    \  ans = sum\n    end\n  end\n  return ans\nend", '  local maxSum = table.max({unpack(nums)})',
  "  if #nums == 0 then return 0 end\n  local minimum = math.inf", "  if #nums ==\
    \ 0 then return 0 end\n  if #nums == 1 then return nums[1] end", "  -- Base case:\
    \ all sub-arrays are empty.\n  if #nums == 0 then\n    return 0\n  end", "  local\
    \ numsSize=#nums\n  local minimum=0\n  local minimumIndex=-1\n  for i=1,numsSize\
    \ do\n    local currentSum=0\n    for j=1,i do\n      local current=nums[j]\n\
    \      local currentSum+=current\n    end\n    local currentMinimum=minimum\n\
    \    if currentSum>currentMinimum then\n      minimum=currentSum\n      minimumIndex=i\n\
    \    end\n  end\n  if minimumIndex>0 then\n    return minimum, minimumIndex\n\
    \  else\n    return minimum, -1\n  end\nend", '  if #nums == 0 then return 0 end',
  "  local subSum = 0\n  for _, num in ipairs(nums) do\n    subSum = subSum + num\n\
    \  end\n  return subSum\nend", "  -- base case\n  if #nums < 1 then\n    return\
    \ 0\n  end", "  -- base case: empty array\n  if not nums then return 0 end", " \
    \ -- Base cases\n  if nums == nil then\n    return 0\n  elseif #nums == 0 then\n\
    \    return nil\n  end\n  if #nums == 1 then\n    return nums[1]\n  end", "  local\
    \ min = nil\n  local pos = 1\n  for i = 1, #nums do\n    local elem = nums[i]\n\
    \    for j = pos, #nums do\n      elem = elem + nums[j] \n      if elem < min\
    \ then\n        min = elem\n      end\n    end\n    pos = pos + 1\n  end\n  return\
    \ min\nend", "  local min = 0\n  local largest, last_largest = math.min(nums[1]),\
    \ math.max(nums[1])\n  local i = 1\n  for i = 1, #nums do\n    local num = nums[i]\n\
    \    largest, last_largest = largest, largest\n    local diff = largest - num\n\
    \    if diff < 0 then\n      largest = largest + diff\n    else\n      largest\
    \ = num\n    end\n  end\n  min = largest - last_largest\n  largest = last_largest\n\
    \  i = 2\n  for i = i, #nums do\n    local num = nums[i]\n    largest = largest\n\
    \    local diff = largest - num\n    if diff < 0 then\n      largest = largest\
    \ + diff\n    else\n      largest = num\n    end\n    min = min + largest - last_largest\n\
    \    last_largest = largest\n  end\n  return min\nend", "  -- Base case\n  local\
    \ function recurse(start, minSum)\n    if start == #nums then\n      return minSum\n\
    \    end\n    -- Find the minimum sub-array of nums[start, start + #nums[start]]\n\
    \    local subArray = recurse(start + 1, minSum)\n    return subArray + nums[start]\n\
    \  end\n  return recurse(1, 0)\nend", "  local maxSum = -1\n  local currSum\n\
    \  local currMinIdx\n  local maxIdx\n  local j\n  for i = 1, #nums do\n    currSum\
    \ = nums[i]\n    if currSum > maxSum then\n      maxSum = currSum\n      currMinIdx\
    \ = i\n    end\n  end\n  -- The last element has nothing to sum\n  if currSum\
    \ > maxSum then\n    return maxSum\n  else\n    -- Add the first element, as all\
    \ remaining elements are >= the sum\n    if currMinIdx > 1 then\n      maxSum\
    \ = maxSum + nums[currMinIdx - 1]\n    end\n    -- Add the remaining elements\n\
    \    for j = 2, #nums do\n      currSum = maxSum + nums[j]\n      if currSum >\
    \ maxSum then\n        maxSum = currSum\n        maxIdx = j\n      end\n    end\n\
    \    return maxSum\n  end\nend", "  if #nums == 0 then\n    return 0\n  end\n\
    \  local maxSum = nums[1]\n  local min = nums[1]\n  local minSum = nums[1]\n \
    \ for i=2,#nums do\n    maxSum = math.max(maxSum + nums[i], nums[i])\n    if maxSum\
    \ < min then\n      min = maxSum\n      minSum = maxSum\n    end\n  end\n  return\
    \ minSum\nend", "  local result = nil\n  local minSum, minIndex = 0, 0\n  for\
    \ i, v in ipairs(nums) do\n    if v ~= 0 then\n      local sum, index = minSubArraySum(nums)\n\
    \      if not result or sum < minSum then\n        minSum, minIndex = sum, index\n\
    \      end\n    end\n    result = v + minSum\n  end\n  return result, minIndex\n\
    end", "   local bestSum = math.min(table.unpack(nums)[1])\n   for i = 2, #nums\
    \ do\n      local sum = bestSum + table.unpack(nums)[i]\n      if sum ~= bestSum\
    \ then\n         return bestSum\n      end\n   end\n   return bestSum\nend", " \
    \ local sum = 0\n  local i = 1", "\tlocal sums = {}\n\tfor _, elem in pairs(nums)\
    \ do\n\t\tlocal minSum = -1\n\t\tfor _, b in pairs(sums) do\n\t\t\tlocal subSum\
    \ = sums[b] + elem\n\t\t\tif subSum < minSum then\n\t\t\t\tminSum = subSum\n\t\
    \t\tend\n\t\tend\n\t\ttable.insert(sums, minSum)\n\tend\n\treturn table.minimum(sums)\n\
    end", "  local minSum = sys.maxsize\n  for i = 1, #nums do\n    local sum = nums[i]\n\
    \    if sum < minSum then\n      minSum = sum\n    end\n  end\n  return minSum\n\
    end", "  local function helper(start, stop)\n    -- Base case\n    if start >\
    \ stop then return stop end\n    -- Recursion\n    local sum = nums[start] + helper(start\
    \ + 1, stop)\n    if sum < nums[stop] then return sum end\n    return helper(start,\
    \ stop - 1)\n  end\n  return helper(0, #nums)\nend", "   local min = nums[1]\n\
    \   local max = nums[1]", "  local i = 0\n  local sum = 0\n  local length = #nums\n\
    \  while i <= length do\n    sum = sum + nums[i]\n    i = i + 1\n  end\n  return\
    \ sum\nend", "  local minSum = -1\n  for _, x in ipairs(nums) do\n    if minSum\
    \ < x and x > minSum then\n      minSum = x\n    end\n  end\n  return minSum\n\
    end", '  local minSum = -1', "  -- Base case\n  if #nums == 0 then\n    return\
    \ 0\n  end", "  local numsLength = #nums\n  assert(numsLength, \"The input table\
    \ is empty\")", "  if #nums <= 1 then return nums[1] else return -Infinity end\n\
    \  local minSum = -Infinity\n  local minSubArray = nil\n  for i = 2, #nums do\n\
    \    local sum = minSubArraySum(nums, i - 1) or -Infinity\n    if sum < minSum\
    \ then\n      minSum = sum\n      minSubArray = nums[i - 2]\n    end\n  end\n\
    \  return minSum\nend", "  assert(#nums == 0)\n  return 0\nend", "    local minimum,\
    \ minimumSum = math.inf, 0\n    for i = 1, #nums do\n        local subSum, newMinimum\
    \ = nums[i]:sub(1,i-1), 0\n        for j = i+1, #nums do\n            subSum,\
    \ newMinimum = subSum + nums[j], newMinimum\n        end\n        if minimum <\
    \ subSum then\n            minimum = subSum\n            minimumSum = newMinimum\n\
    \        end\n    end\n    return minimumSum\nend", "    if #nums < 1 then return\
    \ 0 end\n    local sum, i, j = nums[1], 2, 1\n    for i = 2, #nums do\n      \
    \  sum = sum + nums[i]\n        if sum > j then\n            j = sum\n       \
    \ end\n    end\n    return j\nend", "    local minSum, minIndex = 0, nil\n   \
    \ local i = 0\n    while i <= #nums do\n        local j = i\n        while j <=\
    \ #nums do\n            local sum = nums[i] + nums[j]\n            if sum < minSum\
    \ then\n                minSum = sum\n                minIndex = i\n         \
    \   end\n            j = j + 1\n        end\n        i = i + 1\n    end\n    return\
    \ minIndex\nend", "  -- Base case: empty array\n  if not nums then return 0 end",
  "\tlocal function subarraySum(array, sum, index, subsum)\n\t\tif sum > 0 then\n\t\
    \t\tsum = subsum + array[index]\n\t\telse\n\t\t\tsum = sum + array[index] + 1\n\
    \t\tend\n\t\tif index == #array then\n\t\t\treturn sum\n\t\telse\n\t\t\treturn\
    \ subarraySum(array, sum, index + 1, subsum)\n\t\tend\n\tend\n\tlocal min = math.inf\n\
    \tfor i = 1, #nums do\n\t\tlocal subsum = 0\n\t\tlocal index = i\n\t\twhile subarraySum(nums,\
    \ subsum, index, 0) < min do\n\t\t\tsubsum = 0\n\t\t\tindex = index + 1\n\t\t\
    end\n\t\tmin = subarraySum(nums, subsum, index, 0)\n\tend\n\treturn min\nend",
  "   -- Base case: empty or a single element\n   if #nums == 0 or nums[1] == nil\
    \ then return nums[1] end", "   assert(type(nums) == 'table')\n   assert(#nums\
    \ >= 1)\n   local min = math.abs(nums[1]) + math.abs(nums[#nums]) + nums[2]\n\
    \   for i = 1, #nums do\n      if math.abs(nums[i]) > min then\n         min =\
    \ math.abs(nums[i])\n      end\n   end\n   return min\nend", "\tlocal i = 1\n\t\
    local minSum = nums[1]", "   if #nums <= 0 then\n      return 0\n   end\n   local\
    \ minimum, sum, i, n = math.min(unpack(nums))\n   sum = 0\n   for i = 1, n do\n\
    \      local value = nums[i]\n      if value < minimum then\n         minimum\
    \ = value\n      end\n      sum = sum + value\n      if sum >= n then\n      \
    \   return minimum\n      end\n   end\n   return minimum\nend", "  -- Base case.\n\
    \  if #nums == 1 then\n    return nums[1]", "  local sum = 0\n  local maxSum =\
    \ #nums - 1\n  local i = 2\n  while i <= maxSum do\n    sum = sum + nums[i]\n\
    \    while i < maxSum do\n      if nums[i] > 0 then\n        if sum > 0 then\n\
    \          sum = sum - nums[i]\n        else\n          sum = sum + nums[i]\n\
    \        end\n      else\n        if sum > 0 then\n          sum = sum + nums[i]\n\
    \        end\n      end\n      i = i + 1\n    end\n  end\n  return sum\nend",
  "  if #nums == 0 then\n    return 0\n  elseif #nums == 1 then\n    return nums[1]\n\
    \  else\n    local min = nums[1]\n    for i = 2, #nums do\n      local cur = nums[i]\n\
    \      local nextMin = min\n      min = cur + min\n      if next < cur then\n\
    \        minNext = nextMin\n      end\n    end\n    return min\n  end\nend", '  local
    minSum = math.inf', "    local function dfs(i, v)\n        if i == #nums or v\
    \ == 0 then return v end", "\tlocal min = math.min(unpack(nums))\n\tlocal sum\
    \ = sumSubArray(nums, min)\n\tif sum > 0 then\n\t\treturn min\n\tend\n\treturn\
    \ minSubArraySum(nums)\nend", "    -- Special case: an empty list is a bad input.\n\
    \    if #nums == 0 then return 0 end", "    local function subarray(t)\n     \
    \   local r = {}\n        for i=1, #t do table.insert(r, t[i]) end\n        return\
    \ r\n    end\n    local minSum, lastSum = table.max{}, 0\n    for i = 1, #nums\
    \ do\n        local currentSum = sum(subarray(nums))\n        if currentSum <=\
    \ lastSum then\n            table.insert(minSum, currentSum)\n            lastSum\
    \ = currentSum\n        else\n            table.insert(minSum, lastSum)\n    \
    \        lastSum = currentSum\n        end\n    end\n    return table.max(minSum)\n\
    end", "  -- base case\n  if #nums == 0 then\n    return 0\n  end", "  local min_sum\
    \ = nil\n  for _, num in ipairs(nums) do\n    if min_sum == nil then\n      min_sum\
    \ = num\n    elseif min_sum > num then\n      min_sum = num\n    end\n  end\n\
    \  return min_sum\nend", "   local numTable = {}\n   for i = 1,#nums do\n    \
    \  table.insert(numTable, nums[i])\n   end\n   local min = sys.maxint\n   local\
    \ minSum = 0\n   local i = #numTable\n   while i > 0 do\n      if minSum > 0 and\
    \ minSum + numTable[i - 1] ~= numTable[i] then\n         return nil\n      end\n\
    \      min = math.min(min, numTable[i - 1])\n      minSum = minSum + numTable[i\
    \ - 1]\n      i = i - 1\n   end\n   return min\nend", "  assert(type(nums) ~=\
    \ 'table')\n  if #nums < 1 then return nil end", "  local minSum = math.inf\n\
    \  local i = #nums\n  while i do\n    local newSum = 0\n    local minPos = nil\n\
    \    for j = 1, i do\n      if nums[j] < 0 then\n        newSum = math.max(newSum,\
    \ -nums[j])\n      else\n        newSum = math.max(newSum, nums[j])\n        minPos\
    \ = j\n      end\n    end\n    if newSum < minSum then\n      minSum = newSum\n\
    \      minPos = minPos\n    end\n    i = i - 1\n  end\n  return minSum\nend",
  "    assert(nums[#nums] == nil)\n    local minSum = #nums\n    for i = 2, #nums\
    \ do\n        if nums[i - 1] >= nums[i] then\n            minSum = math.min(minSum,\
    \ nums[i - 1] + nums[i])\n        end\n    end\n    return minSum\nend", "\t--\
    \ Base case: empty list or just one number.\n\tif #nums == 0 then\n\t\treturn\
    \ nums[1]\n\tend\n\t-- Base case: Just one number, find the min of that\n\tif\
    \ #nums == 1 then\n\t\treturn nums[1]\n\tend\n\t-- Base case: At least two numbers,\
    \ find the min of the two subarrays,\n\t-- and add the min of the two subarrays\
    \ minus their sum to it.\n\treturn nums[1] + minSubArraySum(nums[2:])\nend", " \
    \   local maxSum = math.max(table.unpack(nums))\n    local minSum = math.min(table.unpack(nums))\n\
    \    local sum = 0\n    for i = 1, maxSum do\n        local n = table.len(nums)\n\
    \        table.insert(nums, minSum)\n        sum = sum + minSum\n        while\
    \ n > 1 do\n            local n = n - 1\n            table.insert(nums, minSum\
    \ + nums[n])\n            sum = sum + minSum\n        end\n        table.insert(nums,\
    \ minSum)\n    end\n    return sum\nend", "  local total = 0 -- We sum the numbers\
    \ to find the minimum.\n  local minNum = nil -- The smallest number in the array.\
    \ Set this as \n  -- appropriate.\n  for _, num in pairs(nums) do -- Iterate over\
    \ the array.\n    total = total + num -- Add the number to the total. This also\
    \ \n    updates the smallest number seen so far.\n    -- If the current smallest\
    \ number found so far is smaller than the \n    -- current number, then update\
    \ the smallest number seen so far.\n    if total < minNum then\n      minNum =\
    \ total\n    end\n  end\n  return minNum\nend", "    assert(nums:nElement() >\
    \ 0)\n    if nums:nElement() == 1 then\n        return nums:first()\n    end\n\
    \    local minSum = nums:first()\n    for i = 1, nums:nElement() do\n        local\
    \ sum = 0\n        for j = 1, i do\n            sum = sum + nums:getElement(j)\n\
    \        end\n        if sum < minSum then\n            minSum = sum\n       \
    \ end\n    end\n    return minSum\nend", "  assert(type(nums) == 'table', 'Expected\
    \ table for input')\n  assert(#nums > 0, 'Empty input')", "  local sum = 0\n \
    \ local minSum = nil\n  for i = 1, #nums do\n    sum = sum + nums[i]\n    if minSum\
    \ == nil then\n      minSum = sum\n    elseif sum < minSum then\n      minSum\
    \ = sum\n    end\n  end\n  return minSum\nend", "    local sum, minSum, i = 0,\
    \ 0, 0, 1\n    for i = 1, #nums do\n        sum = sum + nums[i]\n        if sum\
    \ < minSum then\n            minSum = sum\n        end\n    end\n    return minSum\n\
    end", "  local sum = 0\n  local minimum = nil\n  for i, v in ipairs(nums) do\n\
    \    if minimum == nil or v < minimum then\n      minimum = v\n    end\n  end\n\
    \  if minimum == nil then\n    return nil\n  end\n  for i, v in ipairs(nums) do\n\
    \    sum = sum + v\n    if sum > minimum then\n      return minimum\n    end\n\
    \  end\n  return minimum\nend", "   -- Base case\n   if #nums == 0 then\n    \
    \  return 0\n   end", "  local sums = {}\n  local index = 0", "    local minSum\
    \ = math.max(nums[1], nums[#nums])\n    for i = 2, #nums do\n        local curSum\
    \ = minSum + nums[i]\n        if curSum <= 0 then\n            return curSum\n\
    \        end\n        minSum = curSum\n    end\n    return minSum\nend", "  if\
    \ #nums < 2 then\n    return 0\n  end\n  local result = math.min(nums[1] + minSubArraySum(nums[2:end]),\
    \ nums[2])\n  for i = 2, #nums do\n    local minimum = minSubArraySum(nums[i ..\
    \ 1]) + nums[i]\n    if minimum > result then\n      result = minimum\n    end\n\
    \  end\n  return result\nend", "  local sum, curSum\n  for curSum = 1, math.max(sum,\
    \ #nums) do\n    sum = 0\n    for _, v in ipairs(nums) do\n      if v == curSum\
    \ then\n        sum = sum + v\n      else\n        break\n      end\n    end\n\
    \  end\n  return sum\nend", "\t-- Base case\n\tif not nums or #nums == 0 then\n\
    \t\treturn 0\n\tend", "  local total = 0\n  local minimum = nil\n  for i = 1,\
    \ #nums do\n    local current = nums[i]\n    local minimum = math.min(current,\
    \ minimum)\n    total = total + current\n  end\n  return minimum\nend", "  if\
    \ nums == nil then return end\n  local minSum, minSumIdx = math.inf, 0\n  local\
    \ function f(x)\n    if x[1] == nil then return end\n    local sum = x[1]:reduce(f,\
    \ x)\n    if sum < minSum then\n      minSum = sum\n      minSumIdx = x[2]\n \
    \   end\n  end\n  for i = 1, #nums do\n    f(i)\n  end\n  return nums[minSumIdx]\n\
    end", "    local min = math.min(...)\n    local i = 1\n    while i < #nums do\n\
    \        if nums[i] < min then\n            min = nums[i]\n        end\n     \
    \   i = i + 1\n    end\n    return min\nend", "    local nSum = 0\n    local currentSum\
    \ = 0\n    for i = 1, #nums do\n        currentSum = currentSum + nums[i]\n  \
    \      if currentSum < 0 then\n            currentSum = currentSum + nums[#nums\
    \ + i]\n        end\n        nSum = nSum + currentSum\n    end\n    return nSum\n\
    end\n</cell>\n<text>\nThis code is an implementation of Kadane's algorithm.",
  "  local function helper(start, end)\n    if start == end then\n      return 0\n\
    \    end\n    if start + 1 == end then\n      return nums[start]\n    end\n  \
    \  local min = helper(start + 1, end)\n    for i = start + 1, end do\n      local\
    \ n = nums[i]\n      if n < min then\n        min = n\n      end\n    end\n  \
    \  return min\n  end\n  return helper(1, #nums)\nend", "  local count = 0\n  local\
    \ minimum = tonumber((math.abs(nums[1]) + math.abs(nums[2])) .. nums[3])\n  for\
    \ i = 1, #nums do\n    local subsum = tonumber((math.abs(nums[i]) + math.abs(nums[i\
    \ + 1])) .. nums[i + 2])\n    if minimum > subsum then\n      minimum = subsum\n\
    \      count = i\n    end\n  end\n  minimum = tonumber(minimum)\n  count = tonumber(count)\n\
    \  if minimum == math.inf then\n    return nil\n  else\n    return minimum, count\n\
    \  end\nend", "    local maxNum = unpack(nums)\n    local sum = 0\n    for i=1,#nums\
    \ do\n        if maxNum[i] > 0 then\n            sum = sum + maxNum[i]\n     \
    \       -- Subtract one if we need to do subtraction\n            if maxNum[i]\
    \ > 1 then\n                sum -= (maxNum[i]-1)\n            end\n        end\n\
    \    end\n    return sum\nend", '  local minSum, minSumIndex', "    local numsLen\
    \ = #nums\n    local minSum = nums[1]\n    for i = 1, numsLen do\n        if nums[i]\
    \ < minSum then\n            minSum = nums[i]\n        end\n    end\n    return\
    \ minSum\nend", "  assert(#nums > 0, 'invalid nums argument: empty table')\n \
    \ local minSum = math.min(unpack(nums))\n  for i = 1, #nums do\n    if nums[i]\
    \ < minSum then\n      minSum = nums[i]\n    end\n  end\n  return minSum\nend",
  "    local maxSum = -math.inf\n    for i = 1, #nums do\n        local sum = sum(nums,\
    \ i)\n        if sum > maxSum then\n            maxSum = sum\n        end\n  \
    \  end\n    return maxSum\nend", "    local function subSum(nums)\n        if\
    \ #nums == 0 then\n            return nil\n        end\n        local n = 0\n\
    \        local min = math.max(nums[#nums])\n        local max = 0\n        for\
    \ i = 1, #nums do\n            n = n + 1\n            local sub = minSubArraySum(nums[#nums]\
    \ + nums[i])\n            if sub == nil then\n                return nil\n   \
    \         end\n            if sub < min then\n                min = sub\n    \
    \        end\n            if sub > max then\n                max = sub\n     \
    \       end\n        end\n        return min\n    end", "  local min = math.min\n\
    \  local result = nil\n  for i = 1, #nums do\n    local temp = sum(nums, i, #nums)\n\
    \    if temp < min then\n      min = temp\n    end\n  end\n  if min ~= 0 then\n\
    \    result = min - sum(nums, 1, #nums)\n  end\n  return result\nend", "  if #nums\
    \ == 0 then return 0 end\n  local minSum = nums[1]\n  for i = 2, #nums do\n  \
    \  minSum = math.min(minSum, nums[i] + minSubArraySum(nums[i+1:]))\n  end\n  return\
    \ minSum\nend", "    local function findSubArraySum(array, n, i)\n        if i\
    \ >= n then return 0 end", '  if #nums == 0 then return 0 end', "   -- A table\
    \ with only one element is considered empty.\n   if #nums == 1 then return nums[1]\
    \ else return nil end\n   -- If all elements are negative, return negative.\n\
    \   if minSubArraySum(nums)<0 then return -minSubArraySum(nums) end\n   -- The\
    \ current minimum sum.\n   local minSum = sys.maxint\n   -- Iterate over the array.\n\
    \   for i=1,#nums do\n      -- If element i is not a number, ignore it.\n    \
    \  if nums[i] ~= number then\n         -- Calculate the sum for this subarray.\n\
    \         local subArraySum = minSubArraySum(nums:sub(1*i,i))\n         -- If\
    \ the sum is not less than the current minimum.\n         if subArraySum ~= nil\
    \ then\n            if subArraySum < minSum then\n               -- Update the\
    \ minimum sum.\n               minSum = subArraySum\n            end\n       \
    \  end\n      end\n   end\n   return minSum\nend", "  -- Base Cases\n  -- 1\n\
    \  if #nums == 1 then\n    return nums[1]\n  end", "  if #nums == 1 then return\
    \ nums[1] end\n  local minSum, curSum = math.inf, nums[1]\n  for i = 2, #nums\
    \ do\n    curSum = curSum + nums[i]\n    if curSum < minSum and curSum > 0 then\n\
    \      minSum = curSum\n    end\n  end\n  return minSum\nend", '  if #nums ==
    0 then return 0 end', "    local ans = math.inf\n    for i = 1, #nums do\n   \
    \     local val = nums[i]\n        if val ~= 0 then\n            local currSum\
    \ = ans - val\n            if currSum > 0 then\n                ans = currSum\n\
    \            else\n                ans = ans\n            end\n        end\n \
    \   end\n    return ans\nend", "  if #nums == 0 then return 0 end\n  local n =\
    \ 0\n  local m = #nums\n  while m > 0 do\n    local t = nums[m]\n    n += t\n\
    \    m -= t\n  end\n  return n\nend", "  if #nums == 0 then return 0 end\n  if\
    \ #nums == 1 then return nums[1] end\n  local minimum = math.max(nums[1])\n  for\
    \ i = 2, #nums do\n    minimum = math.min(minimum, nums[i] + nums[i - 1])\n  end\n\
    \  return minimum\nend", "  -- Base case\n  if #nums == 0 then\n    return 0",
  "    local minSum = math.max(num)\n    for i = 1, #nums do\n        minSum = math.min(minSum,\
    \ nums[i] + minSum)\n    end\n    return minSum\nend", "    local maxSum = math.min(unpack(nums))\n\
    \    local minSum = math.max(unpack(nums))\n    for i = 2, #nums do\n        local\
    \ newMaxSum = maxSum + nums[i]\n        local newMinSum = minSum - nums[i]\n \
    \       if newMaxSum < newMinSum then\n            maxSum = newMaxSum\n      \
    \  else\n            minSum = newMinSum\n        end\n    end\n    return minSum\n\
    end", "  -- Base Case\n  if #nums == 1 then\n    return nums[1]\n  end", "  --\
    \ Base case: if the list is empty return the zero of the proper type.\n  if #nums\
    \ == 0 then return type.getzero(type.gettype(self)) end", "  local min = nil\n\
    \  for i = 1, #nums do\n    local n = i - 1\n    while n >= 0 do\n      if nums[n\
    \ - 1] > nums[i] then\n        n = n - 1\n      else\n        if min == nil then\n\
    \          min = nums[i]\n        elseif nums[i] < min then\n          min = nums[i]\n\
    \        end\n      end\n    end\n  end\n  return min\nend", "  local ans = #nums\n\
    \  local last = nums[ans-1]\n  for i = 1, ans do\n    local current = nums[i]\n\
    \    if current > last then\n      ans = i\n      last = current\n    end\n  end\n\
    \  return last + ans - 1\nend", "  if #nums == 0 then return 0 end\n  if #nums\
    \ <= 1 then return #nums end", "   local sum = 0\n   for i = 1, #nums do\n   \
    \   sum = sum + nums[i]\n      if sum > 0 then\n         return sum\n      end\n\
    \      sum = 0\n   end\n   return 0\nend", "  if #nums == 1 then\n    return nums[1]\n\
    \  end\n  if #nums == 2 then\n    return nums[1] + nums[2]\n  end\n  local results\
    \ = {}\n  local i = 1\n  for n in pairs(nums) do\n    local total = 0\n    for\
    \ j = #results + 1 , i do\n      total = total + results[j]\n    end\n    if total\
    \ <= n then\n      table.insert(results, n)\n    end\n    i = i + 1\n  end\n \
    \ return table.remove(results)\nend", "  local ans = 0\n  for i = 1, #nums do\n\
    \    ans = math.max(ans, nums[i]+minSubArraySum(nums, i, #nums)-nums[i])\n  end\n\
    \  return ans\nend", '  local minimum = math.inf', "  local n = #nums\n  local\
    \ s = 0 -- running sum\n  local minSum = math.inf\n  for i = 1, n do\n    s =\
    \ s + nums[i]\n    if s <= minSum then\n      minSum = s\n    end\n  end\n  return\
    \ minSum\nend", "  local numsStack = setmetatable({}, {__index = _G.__index})\n\
    \  local minSum, minNum\n  local count = 0", "  local minSum, minSumIndex, minSumValue\
    \ = 0, {}, nil\n  local function min(i, sum)\n    if sum < minSum then\n     \
    \ minSum, minSumIndex, minSumValue = sum, i, nums[i]\n    end\n  end\n  table.sort(nums)\n\
    \  for i=1, #nums do\n    local sum, index = 0, i\n    while sum < minSum do\n\
    \      sum, index = sum + nums[index], index + 1\n    end\n    min(index, sum)\n\
    \  end\n  return minSumValue\nend", "   assert(type(nums) == 'table')\n   local\
    \ min = sys.maxint\n   local sum = 0\n   local curr = nil\n   for i, v in pairs(nums)\
    \ do\n      if curr == nil then\n         curr = v\n      else\n         sum =\
    \ sum + curr\n         curr = v\n      end\n      if sum < min then\n        \
    \ min = sum\n      end\n   end\n   return min\nend", "  if #nums == 1 then return\
    \ nums[1] end\n  local total = 0\n  for i = 2, #nums do\n    total = total + nums[i]\n\
    \    if total < 0 then return nil end\n  end\n  return total\nend", "  -- Base\
    \ case: if the array is empty, return 0.\n  if #nums == 0 then\n    return 0\n\
    \  end", '  local min = math.inf', "    local i = 1\n    local sum = nums[i]\n\
    \    while i < #nums do\n        local val = nums[i]\n        sum, i = sum + val,\
    \ i + 1\n    end\n    return sum\nend", "  local ret = 0\n  for i = 1, #nums do\n\
    \    local val = nums[i]\n    ret = val + ret or val\n  end\n  return ret\nend",
  "  local minimum = math.min(nums)\n  local minimums = []\n  for i = 1, #nums do\n\
    \    minimums = minimums + {minimum + nums[i]}\n  end\n  return minimums[#minimums]\n\
    end", "  if nums == nil then return nil end\n  local min = math.min(unpack(nums))\n\
    \  local sum = nil\n  for i = 2, #nums do\n    sum = sum + nums[i]\n    if sum\
    \ < min then\n      min = sum\n    end\n  end\n  return min\nend", "  -- This\
    \ problem can be solved using the following two approaches:\n  -- Approach 1:\
    \ Use two pointers i and j, initialize i to the start of the nums table and\n\
    \  -- to j to the end of nums table. Maintain the invariant:\n  --\n  --\n  --\
    \    table[start] <= table[end] for all start and end\n  --\n  --\n  -- When you\
    \ visit a cell in nums table at index i, add its value to your running min.\n\
    \  -- When you visit a cell in nums table at index j, you subtract the value of\
    \ your running min.\n  -- You then update your running min to the new value at\
    \ the end of nums table if you see a\n  -- \"negative\" value, or to zero if your\
    \ running min is a positive value.\n  --\n  --\n  --\n  -- Approach 2: Start with\
    \ the largest possible sum, intialize to the sum of all values in the\n  -- nums\
    \ table. When you visit a cell in nums table at index i, add its value to your\
    \ running\n  -- sum. When you visit a cell in nums table at index j, subtract\
    \ the value of your running sum from\n  -- your running sum. When you find a negative\
    \ value at index j, update your running sum to 0.", '  local minSoFar = math.max(unpack(nums))',
  "\tlocal numsSorted = table.sort(nums)\n\tlocal minimum = numsSorted[1]", "  --\
    \ Base case: no more numbers\n  if #nums == 0 then\n    return 0\n  end\n  --\
    \ Find the minimum number in the unsorted part\n  local minNum = math.min(nums)\n\
    \  -- Find the minimum subarray that sums to minNum\n  local minSubArray = nil\n\
    \  for i = 1, #nums do\n    local subArray = minSubArray(nums, i, minNum)\n  \
    \  if subArray ~= nil then\n      if subArray[1] + minNum < minNum then\n    \
    \    minSubArray = subArray\n        minNum = subArray[1] + minNum\n      end\n\
    \    end\n  end\n  -- Return the minimum subarray\n  return minSubArray\nend",
  "    if nums == nil then\n        return 0\n    end", "  return #nums <= 0 or min(#nums,\
    \ #nums) >= 4 or\n    select( #nums, math.min(#nums, #nums) - 1, #nums, sum( unpack(nums)\
    \ ) )\nend", "  -- Base case: no subarray to sum\n  if not nums or not next(nums)\
    \ then\n    return 0\n  end\n  -- The first element\n  local min = nums[1]\n \
    \ -- Calculate the sum of first two elements\n  local sum1 = minSubArraySum(nums[2:])\n\
    \  -- For each element after the first two\n  for i = 2, next(nums) do\n    local\
    \ sum2 = minSubArraySum(nums[i:(i+1)])\n    -- If the sum of the subarray is less\
    \ than the sum of the elements,\n    -- then update the minimum value\n    if\
    \ sum1 < sum2 then\n      min = sum2\n    end\n    -- Update the sum for the current\
    \ element\n    sum1 = sum2\n  end\n  -- Return the minimum value\n  return min\n\
    end", "    local best = 0\n    local bestSum = 0\n    for _, v in pairs(nums)\
    \ do\n        bestSum = bestSum + v\n        if bestSum > best then\n        \
    \    best = bestSum\n        end\n    end\n    return best\nend", "  -- Base case\n\
    \  if #nums == 0 then\n    return 0\n  end\n  -- Compute array in reverse order\
    \ and add elements as we go\n  local result = -nums[1]\n  for i = #nums, 1, -1\
    \ do\n    local element = nums[i]\n    result = result + element\n  end\n  --\
    \ Add minimum element\n  local minimum = result\n  for i = #nums, 1, -1 do\n \
    \   minimum = minimum + nums[i]\n  end\n  return minimum\nend", "  -- Base case:\
    \ no non-zero numbers\n  if #nums == 0 then\n    return 0\n  end", "  -- base\
    \ case\n  if not nums then return 0 end", "    local sum = 0\n    local n = #nums\n\
    \    for i=1, n do\n        sum = sum + nums[i]\n    end\n    return sum\nend",
  "  local function helper(nums, lo, hi, sum)\n    if lo == hi then return sum end\n\
    \    if lo == hi - 1 then return helper(nums, lo, hi - 1, sum + nums[lo]) end\n\
    \    local mid = (lo + hi) / 2\n    return helper(nums, lo, mid, helper(nums,\
    \ lo, mid - 1, sum + nums[mid])))\n  end\n  return helper(nums, 1, #nums, 0)\n\
    end", "  -- Base case: if the array is empty, return the empty sum.\n  if #nums\
    \ == 0 then\n    return 0\n  end", "    local numsSum = 0\n    for i = 1, #nums\
    \ do\n        numsSum = numsSum + nums[i]\n    end\n    local currentSum = 0\n\
    \    local currentNumbers = 0\n    for i = 1, #nums do\n        local numbers\
    \ = nums[i]\n        for j = 1, #numbers do\n            local currentSum = currentSum\
    \ + numbers[j]\n            if currentSum < numsSum then\n                currentSum\
    \ = numsSum\n                currentNumbers = currentNumbers + 1\n           \
    \ end\n        end\n    end\n    return currentSum - numsSum\nend", "  local minSum,\
    \ numSum, i, n = 0, nums[1], 1\n  for i = 2, #nums do\n    numSum = numSum + nums[i]\n\
    \    if numSum < minSum then\n      minSum = numSum\n    end\n    n = n + i\n\
    \  end\n  return minSum\nend", "  -- Base case.\n  if #nums == 0 then\n    return\
    \ 0\n  end", "    local sum = 0\n    for i = 1, #nums do\n        sum = sum +\
    \ nums[i]\n    end\n    return sum\nend", "  local sum = 0\n  local index = 1\n\
    \  for i = 1, #nums do\n    local current = nums[i]\n    sum = sum + current\n\
    \    if sum > 0 then\n      if sum < current then\n        sum = current\n   \
    \     index = i\n      else\n        index = i\n        break\n      end\n   \
    \ end\n  end\n  return index\nend", "  local min = math.max(1, #nums)\n  local\
    \ sum = 0", "  -- Base cases\n  if #nums == 1 then\n    return nums[1]\n  end\n\
    \  if #nums == 0 then\n    return 0\n  end", "  if #nums == 0 then\n    return\
    \ 0\n  end\n  local minsum = math.inf\n  local minSubArraySumHelper = function(nums,\
    \ index)\n    if index == #nums then\n      minsum = min(minsum, nums[index][1])\n\
    \      return nil\n    end\n    local left = nums[index]\n    local right = minSubArraySumHelper(nums,\
    \ index + 1)\n    if right ~= nil then\n      minsum = min(minsum, left + right[1])\n\
    \    end\n    return nil\n  end\n  minSubArraySumHelper(nums, 1)\n  return minsum\n\
    end", "  local subSum = 0\n  for i = 1, #nums do\n    local sum = subSum + nums[i]\n\
    \    if sum > subSum then\n      subSum = sum\n    end\n  end\n  return subSum\n\
    end", "  if #nums == 0 then return 0 end\n  local ans = nums[1]\n  for i = 2,\
    \ #nums do\n    local curr = nums[i]\n    local newAns = math.min(ans, curr +\
    \ minSubArraySum(nums[i+1:]))\n    ans = newAns\n  end\n  return ans\nend", " \
    \ if nums == nil then\n    return 0\n  end\n  local i = #nums\n  if i == 0 then\n\
    \    return nums[1]\n  end\n  local min = math.min(nums[1])\n  for j = 1, i do\n\
    \    local current = nums[j]\n    if current > 0 then\n      local next = math.min(nums[j\
    \ + 1] + current, min)\n      min = next\n    end\n  end\n  return min\nend",
  "    local function recurse(arr, i, count)\n        if count == 0 then\n       \
    \     return arr[i]\n        else\n            if arr[i] > arr[i + count] then\n\
    \                recurse(arr, i, count)\n            else\n                recurse(arr,\
    \ i + 1, count - 1)\n            end\n        end\n    end", "    local sums =\
    \ { }\n    for i = 1, #nums do\n        table.insert(sums, 0)\n    end\n    local\
    \ minSum = #sums\n    local minArrayIndex = #nums\n    for i = 1, #sums do\n \
    \       local sum = sums[i]\n        for j = 1, #nums do\n            local num\
    \  = nums[j]\n            sums[i] += num\n            if sums[i] < minSum then\n\
    \                minSum = sums[i]\n                minArrayIndex = j\n       \
    \     end\n        end\n    end\n    return minSum, minArrayIndex\nend", "   \
    \ -- base case: empty array or single element array\n    if #nums == 0 or #nums\
    \ == 1 then\n        return nums[1]\n    end", "  local minSum =math.inf\n  local\
    \ lastSum = math.inf\n  local sum = 0", "  -- If the array is empty, return 0\n\
    \  if not nums then\n    return 0\n  end", "  if #nums == 0 then\n    return 0\n\
    \  end", "  -- Find minimum sum of a subset of given length\n  local function\
    \ minSubArray(length, subset)\n    local minElement = math.inf\n    local minSum\
    \ = math.inf\n    for i = 1, length do\n      if subset[i] < minElement then\n\
    \        minElement = subset[i]\n      elseif subset[i] == minElement then\n \
    \       minElement = math.min(subset[i], minElement)\n      end\n      minSum\
    \ = math.min(minSum, subset[i])\n    end\n    return minSum\n  end", "\tlocal\
    \ minSum = nums[1]\n\tlocal index = 1\n\twhile index <= #nums do\n\t\tlocal sum\
    \ = 0\n\t\t-- Start from next element and add up elements\n\t\tfor i = index,\
    \ #nums do\n\t\t\tsum = sum + nums[i]\n\t\tend\n\t\t-- If total sum smaller than\
    \ current min sum so far\n\t\tif sum <= minSum then\n\t\t\tminSum = sum\n\t\t\
    end\n\t\tindex = index + 1\n\tend\n\treturn minSum\nend", "   local sum = 0\n\
    \   local result\n   for i = 1, #nums do\n      if sum < 0 then\n         sum\
    \ = 0\n      end\n      sum, result = math.max(sum, sum + nums[i])\n   end\n \
    \  return result\nend", "  local sum, i, min_sum\n  min_sum = sum = nums[1]\n\
    \  for i = 2, #nums do\n    sum = sum + nums[i]\n    if sum < min_sum then\n \
    \     min_sum = sum\n    end\n  end\n  return min_sum\nend", "\tlocal minimum\
    \ = math.nan()\n\tfor i = 1, #nums do\n\t\tminimum = minimum and minimum + nums[i]\
    \ or nums[i]\n\tend\n\treturn minimum\nend", "    local min, sum\n    local n\
    \ = #nums\n    for i = 1, n do\n        local value = nums[i]\n        if sum\
    \ == nil then\n            sum = value\n            min = value\n        else\n\
    \            sum = sum + value\n            if sum < min then\n              \
    \  min = sum\n            end\n        end\n    end\n    return min\nend", " \
    \   local numsTable = {}\n    for _, num in pairs(nums) do\n        if numsTable[num]\
    \ == nil then\n            numsTable[num] = true\n        else\n            assert(numsTable[num]\
    \ == false)\n        end\n    end\n    local numsTableLength = #numsTable\n  \
    \  local sum, bestSum = 0, 0\n    for i = 1, numsTableLength do\n        if numsTable[i]\
    \ then\n            bestSum = math.max(bestSum, sum)\n            sum, bestSum\
    \ = 0, 0\n        end\n        sum = sum + nums[i]\n    end\n    return bestSum\n\
    end", "  -- Start with our empty sum so far and an empty sub-array.\n  local sum\
    \ = 0\n  local sub = {}", "   -- base case\n   if #nums == 0 then\n      return\
    \ 0\n   end\n   -- base case 2\n   if #nums == 1 then\n      return nums[1]\n\
    \   end\n   -- recursive case 3\n   local min = math.min(#nums, nums[1])\n   local\
    \ subArray = nums[1..min]\n   return min + minSubArraySum(subArray) -- recursion\n\
    end", "  local function find(s, i)\n    if i > #nums then return nil\n    else\
    \ if i ~= 0 then\n      if nums[i] == s[i - 1] + s[i] then return find(s, i -\
    \ 1)\n      else return find(s, i)\n      end\n    else return s[i - 1] + s[i]\n\
    \    end\n  end\n  return find(nums, #nums)\nend", "    if #nums == 0 then\n \
    \       return 0\n    end\n    local min = math.max(#nums, 2)\n    for i = 1,\
    \ #nums do\n        local j = 1\n        while j + i < #nums do\n            local\
    \ sum = 0\n            for k = 1, #nums do\n                if k > i and nums[k]\
    \ == nums[i] then\n                    sum = sum + nums[k]\n                end\n\
    \            end\n            if sum > min then\n                min = sum\n \
    \           end\n            j = j + 1\n        end\n    end\n    return min\n\
    end", "    local minimumSum, currentSum = math.min(nums), 0\n    for i = 1, #nums\
    \ do\n        local newSum = currentSum + nums[i]\n        if minimumSum > newSum\
    \ then\n            minimumSum, currentSum = newSum, currentSum\n        else\n\
    \            currentSum = 0\n        end\n    end\n    return minimumSum\nend",
  "  -- Base case: empty table\n  if #nums == 0 then\n    return 0\n  end", "    local\
    \ result = nums[1]\n    for i = 2, #nums do\n        result = math.min(result,\
    \ nums[i])\n    end\n    return result\nend", "    local sums = {}\n    for i\
    \ = 0, #nums do\n        table.insert(sums, 0)\n    end", "    local numSum =\
    \ 0\n    for i = 1, #nums do\n        local sum = 0\n        for j = 1, #nums\
    \ do\n            sum = sum + nums[j]\n        end\n        if numSum < sum then\n\
    \            numSum = sum\n        end\n    end\n    return numSum\nend", '    if
    #nums == 0 then return 0 end', "  local function tableMin(tab)\n    local minTab\
    \ = tab[1]\n    for i = 2, #tab do\n      local curTab = tab[i]\n      if not\
    \ curTab then break end\n      if minTab[1] < curTab[1] then\n        minTab =\
    \ curTab\n      end\n    end\n    return minTab\n  end", "  -- Write your code\
    \ here.\n  -- We are trying to find the minimum sum of any sub-array of\n  --\
    \ nums sorted in non-decreasing order.\n  -- In order to do that we are taking\
    \ a temporary array that will\n  -- hold a sum of minimum sum of our sub-array.\n\
    \  -- In order to do that, we will maintain two pointers (start and end) to\n\
    \  -- our current sub-array. Our pointer will move as long as our current\n  --\
    \ sub-array is not empty.", "  local minSum = nums[1]\n  for i = 2, #nums do\n\
    \    local sum = minSum + nums[i]\n    if sum ~= 0 then\n      minSum = sum\n\
    \    end\n  end\n  return minSum\nend", "  if #nums <= 1 then return nums[1] end\n\
    \  local total = 0\n  local minimum = math.abs(nums[1])\n  for i = 2, #nums do\n\
    \    local current = math.abs(nums[i])\n    if current < minimum then\n      minimum\
    \ = current\n    end\n    total = total + current\n  end\n  return minimum + total\n\
    end", "    local function helper(start, end)\n        if start == end then return\
    \ end\n        local value = nums[start]\n        for i = start + 1, end do\n\
    \            value = value + nums[i]\n        end\n        return value\n    end\n\
    \    local i = 1\n    local min = helper(i, i)\n    while i <= #nums do\n    \
    \    if helper(i, i) > min then\n            min = helper(i, i)\n        end\n\
    \        i = i + 1\n    end\n    return min\nend", "\tassert(type(nums) == 'table')",
  "  -- Base Case\n  if #nums == 0 then\n    return 0\n  end", "  if nums == nil then\n\
    \    return nil\n  elseif #nums == 0 then\n    return 0\n  else\n    return math.min(nums[1]\
    \ + minSubArraySum(nums[2:end]))\n  end\nend", "  -- Base case\n  if #nums ==\
    \ 0 then\n    return 0\n  end", "    local result = 0\n    for i = 1, #nums do\n\
    \        local left = nums[i] - 1\n        local right = #nums - 1\n        local\
    \ sum = nums[left]", "\t-- Return infinity if there are no positive numbers.\n\
    \tif not nums or #nums == 0 then return Infinity end", "  -- Base case: empty\
    \ array\n  if #nums == 0 then\n    return 0\n  end\n  -- Sub-case: single-element\
    \ array\n  if #nums == 1 then\n    return nums[1]\n  end\n  -- Find the minimum\
    \ sub-array of non-negative integers that sum to some number\n  -- of positive\
    \ integers. If the sum of the minimum sub-array is already less\n  -- of equal\
    \ than the sum, just return it.\n  --\n  -- This is O(lgN), where lgN is the length\
    \ of the array.\n  local minSum = nums[1]\n  for i = 2, #nums do\n    -- Look\
    \ for a sub-array that sums to a smaller sum\n    local newSum = minSum + nums[i]\n\
    \    if newSum <= 0 then\n      -- If there are no such sub-arrays, return the\
    \ sum.\n      return newSum\n    end\n    -- The sum didn't change much, just\
    \ return it.\n    if newSum < minSum then\n      minSum = newSum\n    end\n  end\n\
    \  return minSum\nend", "   -- Base case\n   if #nums == 0 then\n      return\
    \ 0\n   end", "  if #nums == 0 then\n    return 0\n  end\n  local sum = 0\n  for\
    \ i = 1, #nums do\n    sum = sum + nums[i]\n    if sum < 0 then\n      sum = 0\n\
    \    end\n  end\n  return sum\nend", "\tassert(type(nums) == 'table', 'invalid\
    \ argument type')\n\tlocal result = nil\n\tfor i = 1, #nums do\n\t\tresult = result\
    \ or nums[i]\n\t\tresult = result + minSubArraySum(nums[(i+1):end])\n\tend\n\t\
    return result\nend", "  local sum = 0\n  for i = 1, #nums do\n    sum = sum +\
    \ nums[i]\n    if sum < 0 then\n      sum = sum + nums[i + 1]\n    end\n  end\n\
    \  return sum\nend", "  if #nums == 0 then\n    return 0\n  end\n  local min =\
    \ math.max(nums[1])\n  for i = 2, #nums do\n    local tmp = min + nums[i]\n  \
    \  min = math.min(tmp, min)\n  end\n  return min\nend", "    local m = #nums\n\
    \    if m == 0 then return 0 end\n    local max = nums[m - 1]\n    for i = 1,\
    \ m do\n        local current = nums[i]\n        if current > max then\n     \
    \       max = current\n        end\n    end\n    return max\nend", "  return min({\n\
    \    table.concat({\n      sum = 0,\n      n = 1,\n      k = 0,\n    }, math.min(#nums,\
    \ table.len(nums)))\n  }, function(t)\n    if t.n <= 0 then\n      return nil\n\
    \    end\n    if t.n < t.k then\n      local val = t.sum + nums[t.k]\n      if\
    \ val >= t.sum then\n        t.sum = val\n        t.k = t.k + 1\n      else\n\
    \        t.sum = val\n        t.n = t.n + 1\n      end\n      return nil\n   \
    \ end\n    -- Now t.n > t.k\n    local val = t.sum + nums[t.k]\n    if val > t.sum\
    \ then\n      t.sum = val\n      t.k = t.k + 1\n    else\n      t.n = t.n + 1\n\
    \    end\n    return nil\n  end)\nend", "\tlocal minimum = math.inf\n\tlocal min\
    \ = nil\n\tfor i = 1, #nums do\n\t\tif nums[i] <= minimum then\n\t\t\tminimum\
    \ = nums[i]\n\t\t\tmin = i\n\t\telse\n\t\t\tminimum = minimum - nums[i]\n\t\t\t\
    if minimum < math.inf then\n\t\t\t\tmin = i - 1\n\t\t\t\tbreak\n\t\t\tend\n\t\t\
    end\n\tend\n\tif minimum == math.inf then return math.inf end\n\treturn minimum\n\
    end", "\t-- Return smallest sum of any non-empty sub-array of nums\n\t-- If no\
    \ sub-arrays of nums are possible, return 0\n\tlocal minSum = 0\n\tlocal subArrs\
    \ = {}", '  local minSum = nums[1]', "  local minimum = nums[1]\n  local sum =\
    \ 0", "    local sum, low = 0, math.min(unpack(nums))\n    for i = 1, #nums do\n\
    \        sum = sum + nums[i]\n        low = math.min(low, nums[i])\n    end\n\
    \    return low < 0 and -sum or sum\nend", "  -- Base Case: empty table\n  if\
    \ #nums == 0 then return 0 end\n  \n  -- Base Case: single element\n  if #nums\
    \ == 1 then\n    return nums[1]", "   local minSum = math.inf\n   local currentSum\
    \ = 0\n   for i = 1,#nums do\n      currentSum = currentSum + nums[i]\n      --\
    \ Check if this new sum is smaller than the current minimum\n      if currentSum\
    \ < minSum and currentSum ~= 0 then\n         minSum = currentSum\n      end\n\
    \   end\n   return minSum\nend", "    local function find(start, end)\n      \
    \  if start > end then\n            return 0\n        end\n        if start >\
    \ nums[end] then\n            return find(start + 1, end)\n        end\n     \
    \   if nums[start] > 0 then\n            return find(start, start + 1)\n     \
    \   end\n        return find(start + 1, end + 1)\n    end", "\tlocal i = 0\n\t\
    local minimumSum = 0\n\tlocal size = #nums\n\twhile i < size do\n\t\tlocal element\
    \ = nums[i]\n\t\tif element then\n\t\t\tminimumSum = minimumSum + element\n\t\t\
    \tlocal j = i + 1\n\t\t\twhile j < size do\n\t\t\t\tif nums[j] == element then\n\
    \t\t\t\t\tminimumSum = minimumSum + nums[j]\n\t\t\t\t\tbreak\n\t\t\t\telse\n\t\
    \t\t\t\tminimumSum = minimumSum + nums[j]\n\t\t\t\tend\n\t\t\t\tj = j + 1\n\t\t\
    \tend\n\t\t\ti = j - 1\n\t\tend\n\tend\n\treturn minimumSum\nend", '  assert(#nums
    > 0)', "\tlocal total = 0\n\tfor i, x in ipairs(nums) do\n\t\ttotal = total +\
    \ x\n\tend\n\treturn total\nend", "    local min = nil\n    for i = 1, #nums do\n\
    \        local curSum = 0\n        for j = 1, #nums do\n            curSum = curSum\
    \ + nums[j] \n            if curSum > min then\n                min = curSum\n\
    \            end\n        end\n    end\n    return min\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
