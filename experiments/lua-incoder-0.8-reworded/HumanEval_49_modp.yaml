name: HumanEval_49_modp
language: lua
prompt: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n-- 3\n\
  -- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n--\
  \ 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
  \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101, 101),\
  \ 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
  \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
  \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local m = n % p\n  n = n - m\n  if n > p then\n    n = n - p\n  elseif\
    \ n < 0 then\n    n = n + p\n  end\n  return m\nend", "  if p == 0 then return\
    \ 1 end\n  if p == 1 or n == 0 then return 0 end\n  local q = 2^n - 1\n  -- Use\
    \ Euler's totient function as a fast approximation.\n  -- Avoids loss of precision.\n\
    \  return q * modp(q + 1, p) / p\nend", "  if p < 2 then return n end\n  local\
    \ q = 0\n  if n % p == 0 then\n    for q = 1, p * 2 do\n      local t = n % p\n\
    \      if t > 0 then\n\tn = t - p\n\tbreak\n      end\n      if t < 0 then\n\t\
    n = t + p\n\tbreak\n      end\n      p = p / 2\n    end\n  end\n  return n - (q\
    \ * p)\nend", "\tif n < 0 or p <= 0 then return nil end\n\tif p == 0 then return\
    \ 1 end\n\tif p == 1 then return n end\n\tlocal r = 1\n\twhile n >= p do\n\t\t\
    r = r * p % n\n\t\tn = n - p\n\tend\n\treturn r\nend", "  local m = n / p\n  if\
    \ m < p then return 0 end\n  if m < 1 then return 1 end\n  if p % 2 == 0 then\
    \ return modp(m, p + 1) end\n  return modp(m, p)\nend", "  -- Note: no negative\
    \ number handling\n  -- This is just to make the code clear.\n  -- For performance\
    \ reasons, no optimizations are done.\n  if n <= 0 then return 0 end\n  if p ==\
    \ 0 then return 1 end\n  if p == 1 or p == 2 then return n % p end\n  local m\
    \ = n % p\n  if m ~= 0 and p > m then return modp(m - p, p) end\n  return p\n\
    end", "\tif p == 0 then return 1 end\n\tif n == 0 then return 0 end\n\tif p <\
    \ 2 then return n % p end\n\tlocal r = n % p\n\tif r < p then return modp(n -\
    \ r + 1, p) end\n\treturn modp(n - r, p)\nend", "  local m = n % p\n  if m < 0\
    \ then m = p end\n  if m == 0 then\n    local d = n / p\n    if d > 1 then return\
    \ p end\n    return d\n  end\n  return p\nend", "  if p == 0 then\n    return\
    \ 1\n  end\n  local t = mod1(n, p)\n  if t < n then\n    return t\n  end\n  return\
    \ p\nend", "  local rem = n % p\n  if rem == 0 then\n    return n\n  else\n  \
    \  return modp(rem, p)\n  end\nend", "  if p > 1 then return 1 end\n  if n < p\
    \ then return 0 end\n  n = n - math.floor(n)\n  local r = n % p\n  if r == 0 then\n\
    \    return r + modp(n/p, p)\n  else\n    return r\n  end\nend", "  if p == 0\
    \ or p == 1 then\n    return 1\n  end\n  if n < p then\n    return 0\n  end\n\
    \  if n > p then\n    return modp(n, p - 1)\n  end\n  local res = 1\n  for i =\
    \ 1, p + 1 do\n    res = (res * i) % p\n  end\n  return res\nend", "\tif n ==\
    \ 0 then\n\t\treturn 1\n\tend\n\tif n == p then\n\t\treturn n\n\tend\n\tif p <\
    \ 0 then\n\t\treturn modp(-n, p)\n\tend\n\tif p == 1 or p == -1 then\n\t\treturn\
    \ n\n\tend\n\tlocal r = math.floor(math.log(n) / math.log(p))\n\tlocal a = p **\
    \ r\n\tlocal b = n % p\n\tlocal m = modp(b, a)\n\twhile m == b do\n\t\tb = n %\
    \ p\n\t\tm = modp(b, a)\n\tend\n\treturn m\nend", "\tif p == 0 then\n\t\treturn\
    \ n\n\telse\n\t\tlocal a = (n % p)\n\t\tlocal d = p ~= 0 and p - a or p\n\t\t\
    return modp(a, d)\n\tend\nend", "    if n < 0 then\n        return modp(n + p,\
    \ p)\n    elseif n == 0 then\n        return 0\n    else\n        if p == 1 then\n\
    \            return n\n        else\n            return n % p\n        end\n \
    \   end\nend", "    if p == 0 then\n        return 0\n    end\n    if p == 1 then\n\
    \        return n\n    end\n    if n < 0 then\n        error(\"mod(): Argument\
    \ must be positive\")\n    end\n    if p < 0 then\n        error(\"mod(): Argument\
    \ must be positive\")\n    end\n    if p == 1 or n == 0 then\n        return p\n\
    \    end\n    -- From this point on, we have a finite number to work with.\n \
    \   -- And p < n.\n    -- So if p is prime, return 2^n mod p.\n    -- Otherwise,\
    \ return ((n-p) mod p) + 1 mod p.\n    local ret = 1\n    local sqrt_n = math.floor(math.sqrt(n))\n\
    \    for i = 2, sqrt_n do\n        if n % i == 0 then\n            ret = (n %\
    \ i) + ret % p\n        end\n    end\n    return ret\nend", "\tif p == 0 then\n\
    \t\treturn 1\n\tend\n\tif p == 1 then\n\t\treturn n\n\tend\n\tif n % p == 0 then\n\
    \t\treturn modp(n / p, p)\n\tend\n\treturn 1\nend", "  n = tonumber(n)\n  if n\
    \ ~= n or n < 0 or p ~= p then return nil end\n  p = tonumber(p)\n  if p < 1 or\
    \ p > p then return nil end\n  -- Return 2^n modulo p (be aware of numerics).\n\
    \  if n < p then\n    local n = 2^(n-1)\n    local r = n % p\n    if r < 0 then\n\
    \      r = p - r\n    end\n    if r < 0 then\n      r = 0\n    end\n    return\
    \ r\n  else\n    -- Return 2^(n-p) modulo p.\n    local m = n - p\n    local r\
    \ = m % p\n    if r < 0 then\n      r = p - r\n    end\n    if r < 0 then\n  \
    \    r = 0\n    end\n    return r\n  end\nend", "  if p == 0 then\n    return\
    \ 1\n  elseif n == 0 then\n    return 0\n  elseif n < 0 then\n    return modp(n\
    \ % p, -p) * modp(abs(n), p)\n  else\n    return modp((n % p) + p, p)\n  end\n\
    end", "   if n < 0 then return 0 end\n   if n == 0 then return 1 end\n   if p\
    \ < 2 then return n end\n   if p == 1 then return n end\n   local n = n - 1\n\
    \   while n > 0 do\n      n = n - 1\n      local t = n % p\n      n = math.floor(n/p)\n\
    \      if n > p then n = p - t end\n      t = modp(t, p)\n      if t > n then\
    \ t = n end\n      n = n + 1\n   end\n   return t\nend", "  if n <= 0 then return\
    \ 0 end\n  if p == 1 then return n end\n  local f = math.floor(p)\n  local e =\
    \ p - f\n  if e < 0 then return modp(f, n) end\n  if e == 0 then return n end\n\
    \  local n = n - f + math.floor(e)\n  return modp(n, p)\nend", "   if n == 0 then\
    \ return 0 end\n   if n < 0 then n = -n\n   if p == 0 then return n end\n   if\
    \ p < 0 then p = -p\n   local m = (p + 1) // p\n   return ((n - 1) / m) % m\n\
    end", "    local r = math.pow(n, p)\n    if r == 0 then\n        return n\n  \
    \  elseif p == 0 then\n        return 1\n    else\n        local m = modp(r, (p\
    \ - 1))\n        return m + (n % p)\n    end\nend", "  local ret = 1\n  for i\
    \ = 1, n do\n    ret = ret * p % p\n  end\n  return ret\nend", "  n = tonumber(n)\n\
    \  p = tonumber(p)\n  if n < 0 or p < 0 then return nil end\n  local r = 1\n \
    \ -- Optimization to avoid the inner loops.\n  if p == 0 then return r end\n \
    \ if n == 0 then return 0 end\n  while n ~= 0 do\n    r = r * p % n\n    local\
    \ _, rem = divrem(n, p, n)\n    if rem == 0 then break end\n    n = rem\n  end\n\
    \  return r\nend", "  if n == 0 then return 1 end\n  if p == 0 then return n end\n\
    \  if p < 2 then return n end\n  local a = modp(n % p, p)\n  if p == 2 and n %\
    \ p == 1 then return 1\n  else if a == 1 and n % p == 1 then return 1 end\n  return\
    \ a\nend", "    return (n + p - 1) % p\nend", "  return math.floor(n%p)\nend",
  "  -- assert(n >= 0 and n <= p)\n  if p == 0 then return 0 end\n  local n2 = n *\
    \ n\n  -- assert(n2 >= 0 and n2 <= p)\n  p = p - 1\n  local q1 = (p / 2) % p\n\
    \  local q2 = (p / 2) - q1\n  if q2 > 0 then\n    if q1 < p then\n      -- assert\
    \ q1 * q2 <= p\n      -- return n2 % p\n      return n % p\n    else\n      --\
    \ assert q1 * q2 > p\n      -- return (q1 + p) % p\n      return (q1 + p) % p\n\
    \    end\n  else\n    -- assert q1 * q2 < p\n    -- return (q1 + p) % p\n    return\
    \ (q1 + p) % p\n  end\nend", "\tlocal d, r = p\n\tlocal z = 1\n\tlocal q = p\n\
    \tlocal m = 1\n\twhile n > 0 do\n\t\tq = ((n % q) + q) % q\n\t\tn, d = d, n -\
    \ q * d\n\t\tm = m * z\n\t\tz = z * z\n\tend\n\treturn n % d + (m < p and 1 or\
    \ 0)\nend", "\t-- If n is negative or 0, then return 1 regardless of p.\n\tif\
    \ n < 0 or n % p == 0 then return 1 end\n\t-- Return 1 if (n * p) % p == 0, otherwise\
    \ return 0.\n\treturn n % p == 0\nend", "  if n == 0 then\n    return 1\n  elseif\
    \ n >= p then\n    return 1\n  elseif n < p then\n    -- Compute ((p + 1) // n)\n\
    \    local a = (p + 1) // n\n    -- Compute n % p\n    local r = n % p\n    --\
    \ Return 1 if (r - 1) // p == r\n    return r == 1 or (r - 1) % p == 0\n  else\n\
    \    -- Compute ((p - 1) // n)\n    local a = (p - 1) // n\n    -- Compute n %\
    \ p\n    local r = n % p\n    -- Return 1 if (r - 1) // p == r\n    return r ==\
    \ 1 or (r - 1) % p == 0\n  end\nend", "  local q = math.floor((p - n) / p)\n \
    \ if q < 0 then\n    return 0\n  elseif q > p then\n    return p\n  else\n   \
    \ return q * p + n\n  end\nend", "  if n == 0 then return 1 end\n  local t = n\
    \ - 1\n  local q = modp(t, p)\n  if q == 0 or p == 0 or q == p then return q end\n\
    \  local r = modp(t - q, p)\n  if r == 0 then return q end\n  return r + q end\n\
    end", "  if p == 0 then\n    return 1\n  end\n  if p == 1 or p == 2 or p == 3\
    \ then\n    if n == 1 then\n      return 1\n    end\n    if n < 0 then\n     \
    \ n = -n\n      p = 1\n    end\n    -- Return the smallest power of 2 that is\
    \ less or equal than p.\n    local pow2 = 0\n    local m = math.floor(p/2)\n \
    \   while m ~= 0 do\n      pow2 = pow2 + 1\n      if pow2 > p then\n        pow2\
    \ = p\n      end\n      m = m/2\n    end\n    return n^pow2\n  end\n  -- If the\
    \ exponent is less than -4 or greater than 4 then it is\n  -- either not a power\
    \ of 2 or a result of numeric overflow.\n  -- If it is numerically less than -4\
    \ or greater than 4 then\n  -- a result of numeric overflow or an argument error.\n\
    \  if n >= p-4 and n <= p+4 then\n    return 1\n  end\n  -- Check that the argument\
    \ is a power of 2 and the exponent is within\n  -- range (-4, 4).\n  if n >= 2^p\
    \ then\n    return 1\n  end\n  return 0\nend", "  if n == 0 then\n    return 1\n\
    \  elseif p == 0 or p == 1 then\n    return 0\n  end\n  return modp(n / p, p)\n\
    end", "  if p == 0 then return 0 end\n  local n1 = n % p\n  if n1 == 0 then\n\
    \    -- 0 is always a multiple of p\n    return p\n  elseif n1 == p then return\
    \ p end\n  local p = p % n1\n  local n2 = n % p\n  if n2 == 0 then return modp(n\
    \ + p, p) end\n  p = modp(n, p)\n  if p == 0 then return modp(n + p, p) end\n\
    \  return modp(n + p, p)\nend", "  local m = n % p\n  if m < 0 then\n    m = p\
    \ - m\n  end\n  return m\nend", "\tp = p or 1\n\tlocal dp = p < 1 and p or 1\n\
    \t-- Ensure that dp isn't 0 (a bug in Lua 5.1)\n\tdp = (dp and dp) or 0\n\tif\
    \ n < 0 then\n\t\treturn dp - (n and modp(n - 1, p) or 0)\n\tend\n\tn = n >= dp\n\
    \tand modp(n - dp, p)\n\tor n\nend", "  if n == 0 then return 1\n  else if n ==\
    \ p then return 0\n  else return modp(n - p, p) + 1 end\nend", "  local r = 1\n\
    \  while n > p do\n    if n % p == 0 then\n      return r\n    end\n    r = r\
    \ * p % n\n  end\n  return r\nend", "    local x\n    -- Use an if-else if-else\
    \ chain to implement the algorithm,\n    -- see http://en.wikipedia.org/wiki/Modular_exponentiation#Binary_exponentiation\n\
    \    if p < 2 then return n end\n    if p == 1 then return 1 end\n    if p ==\
    \ 0 then return 0 end\n    x = modp(n/p, p)\n    if x ~= 1 then return x*x end\n\
    \    if n ~= 0 then return n end\n    return 1\nend", "  if n <= p then\n    return\
    \ n\n  else\n    return modp(n - p, p) % p\n  end\nend", "\t-- Return 2^n modulo\
    \ p.\n\t-- >>> modp(4, 5)\n\t-- 0\n\t-- >>> modp(15, 5)\n\t-- 2\n\t-- >>> modp(101,\
    \ 5)\n\t-- 4\n\t-- >>> modp(1001, 5)\n\t-- 2\n\t-- >>> modp(1001, 11)\n\t-- 10\n\
    \t-- >>> modp(1111, 5)\n\t-- 8\n\t-- >>> modp(1111, 11)\n\t-- 16\n\tn = math.abs(n)\n\
    \tp = math.abs(p)\n\t-- Return 2^n modulo p.\n\t-- >>> modp(3, 5)\n\t-- 0\n\t\
    -- >>> modp(3, 11)\n\t-- 8\n\t-- >>> modp(1, 1)\n\t-- 1\n\tif n == 0 then\n\t\t\
    return 1\n\tend\n\tlocal r = 1\n\tif n < p then\n\t\t-- Return the smallest power\
    \ of 2 greater than or equal to n.\n\t\t-- >>> modp(15, 5)\n\t\t-- 2\n\t\t-- >>>\
    \ modp(15, 11)\n\t\t-- 4\n\t\tr = 1\n\telse\n\t\t-- Return the smallest power\
    \ of 2 greater than or equal to p.\n\t\t-- >>> modp(3, 5)\n\t\t-- 0\n\t\t-- >>>\
    \ modp(3, 11)\n\t\t-- 8\n\t\tr = p\n\tend\n\tfor i = 1, n do\n\t\tr = r * p\n\t\
    end\n\treturn r\nend", "\t-- http://oeis.org/A000050\n\tn = n % p\n\tif n >= 0\
    \ then\n\t\tn = p + n\n\telse\n\t\tn = p - n\n\tend\n\treturn n\nend", "  -- https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n\
    \  local m = n % p\n  if m == 0 then\n    return p\n  elseif m > p then\n    return\
    \ modp(m, p)\n  else\n    return modp((m % p) + p, p)\n  end\nend", "  if p ==\
    \ 0 then return 0 end\n  if p == 1 or n == 0 then return n end\n  if p == 2 then\
    \ return n and n or n and n % p\n  else return n % p + modp(n / p, p) end\nend",
  "\tif n == p then\n\t\treturn n\n\tend\n\tif p == 0 then\n\t\tif n == 0 then\n\t\
    \t\treturn 1\n\t\tend\n\t\treturn 0\n\tend\n\tlocal q, r = 0, n % p\n\twhile r\
    \ < p do\n\t\tq = q * p % p + r\n\t\tr = n % p\n\t\tn = n // p\n\tend\n\treturn\
    \ q % p\nend", "  if p == 0 then\n    return 0\n  else\n    local t = math.floor(n/p)\n\
    \    local r = n % p\n    return r + modp(t*p, p)\n  end\nend", "  local d = n\
    \ ^ p\n  return ((d % p) + p) % p\nend", "  return ((n % p) + p) % p\nend", " \
    \ n = n + 1\n  local result = 1\n  while n > 0 do\n    result = result * p % n\n\
    \    n = n - 1\n  end\n  return result\nend", "  if n == 0 then return 0 end\n\
    \  if n < 0 then return modp(abs(n), p) end\n  if p == 0 or p == 1 then return\
    \ n end\n  local m = (n % p) % p\n  return modp(m, p) or modp((n - m) / p, p)\n\
    end", "\tlocal mod = 0\n\tfor i=0,n do\n\t\tmod = mod + 2^(n % p)\n\t\tn = n /\
    \ p\n\tend\n\treturn mod\nend", "  n = n % p\n  -- Return n-1 when n <= p.\n \
    \ return n and n * p - n or n\nend", "\tif p < 2 then\n\t\treturn n\n\tend\n\t\
    if p < 10 then\n\t\treturn n % p\n\tend\n\tif p < 100 then\n\t\treturn (n % p\
    \ + 10) % p\n\tend\n\treturn (n - (n % p + 10)) % p\nend", "  local function gcd(a,\
    \ b)\n    local m = a\n    while m ~= 0 do\n      local q = m % b\n      m = b\n\
    \      b = q\n    end\n    return b\n  end", "  return ((n % p) + p) % p\nend",
  "  if n < 0 then\n    return nil\n  end\n  n = n - 1\n  if n < 1 then\n    if p\
    \ == 0 then\n      return 1\n    end\n    return nil\n  end\n  local t = 1\n \
    \ for i = 2, p do\n    t = t * i -- XOR\n  end\n  return t\nend", "  local modp\n\
    \  if p == 1 then\n    modp = function(n, p)\n      return n\n    end\n  else\n\
    \    -- p ~= 1 case\n    modp = function(n, p)\n      return n % p\n    end\n\
    \  end\n  return modp(n, p)\nend", "    if p == 0 then return 1\n    elseif p\
    \ == 1 or p == 2 then return n\n    else return modp(n - 1, p) - modp(1, p)\n\
    \    end\nend", "  if p == 0 then return 1 end\n  return n % p + modp(n / p, p)\n\
    end", "\tif n == 0 then\n\t\treturn 1\n\tend", "\t-- http://stackoverflow.com/questions/257213/\n\
    \t-- quickly-test-if-a-number-is-divisible-by-another-number\n\tlocal function\
    \ is_factor(n, p)\n\t\treturn math.mod(n, p) == 0 or n % p == 0\n\tend\n\t-- http://en.wikipedia.org/wiki/Modulo_operation\n\
    \tlocal function modrem(n, p)\n\t\treturn math.mod(n, p) / p\n\tend\n\t-- If n\
    \ is prime, return n itself.\n\tif n == 1 or n == p then\n\t\treturn n\n\tend\n\
    \tif n > p and is_factor(p, n - p) then\n\t\treturn nil\n\tend\n\t-- If the first\
    \ factors are larger than p, return nil.\n\tif is_factor(p, 1) then\n\t\treturn\
    \ nil\n\tend\n\t-- If n is not prime, return modrem(n - p, p).\n\treturn modrem(n\
    \ - p, p)\nend", "  if p == 0 then\n    return n\n  end\n  return n % p\nend",
  "  if p == 0 then\n    return n\n  else\n    local q = n % p\n    if q == 0 and\
    \ n ~= 0 then\n      return n\n    else\n      return modp(q, p)\n    end\n  end\n\
    end\n</cell>\n<text>\nExercise 3\nWrite a function for returning the greatest\
    \ common denominator of two numbers.\nTest it on some sample cases.", "  n = tonumber(n)\n\
    \  p = tonumber(p)", "  n = n % p\n  if n == 0 then return 1 end\n  if n > (p\
    \ / 2) then return modp(n - (p / 2), p) end\n  return modp(n + (p / 2), p)\nend",
  "  if p == 0 then return 1 end\n  local r = n % p\n  if r == 0 then return r end\n\
    \  while r > 0 do\n    r = r / p\n    if r == 0 then return r end\n  end\n  return\
    \ r\nend", "  if n == 0 then return 1 end\n  local q = (n % p) - p\n  if q > 0\
    \ then\n    return modp(q, p)\n  else\n    return q\n  end\nend", "  local s =\
    \ math.floor(n/p)\n  return s*p + (n-s*p)\nend", "   if n == 0 then\n      return\
    \ 1\n   end\n   if p == 0 then\n      -- raise error?\n      return nil\n   end\n\
    \   if n <= p then\n      return n\n   end\n   if p == 1 or n <= 1 then\n    \
    \  return 1\n   end\n   -- return 2^n - p % p\n   return modp(n - 1, p) + modp(1,\
    \ p)\nend", "  if n==0 then\n    return 1\n  else\n    local c = n % p\n    if\
    \ c==0 then\n      return modp(n-1, p)\n    else\n      return c\n    end\n  end\n\
    end", "  if p == 0 then\n    return 0\n  elseif n <= 1 then\n    return p\n  else\n\
    \    return n % p + modp(n//p, p)\n  end\nend", "  if n < 0 then return -1\n \
    \ if n > p then return p end\n  if n == 0 then return 0 end\n  local m = math.floor(n/p)\n\
    \  if p*m == n then\n    return p\n  else\n    return modp(m, p)\n  end\nend",
  "  if p == 0 then return 0 end\n  if p == 1 then return 1 end\n  local q = modp(n\
    \ / p, p)\n  if n == 0 then return q end\n  if q == 1 then return q end\n  if\
    \ q % 2 == 0 then return q end\n  return p * q\nend", "  if p == 0 then return\
    \ 1 end\n  if p == 1 then return n end\n  if p == 2 and n >= 0 then\n    -- Fast\
    \ case: odd modulus case.\n    if n % 2 ~= 0 then return n end\n    -- Slow case:\
    \ exact case.\n    if n < 0 then return 1 end\n    -- Slow case: negative dividend\
    \ or 0 dividend.\n    if n < 1 then return 0 end\n    -- Divide using binary method.\
    \ Cheap but suffers.\n    local function bit(n)\n      if n < 0 then return 0\
    \ end\n      local r = 0\n      for i = 7, 1, -1 do\n        r = r + (n % 2) *\
    \ (n >> i)\n        n /= 2\n      end\n      return r\n    end\n    -- Precalculate\
    \ first 4 bits.\n    local r = bit(n / 4) * 3 + bit(n % 4)\n    -- Add remaining\
    \ bits, starting at right and in reverse.\n    local t = n & 0x0F\n    local i\
    \ = 6\n    while t > 0 do\n      r = r + bit(t / 16) * 17 + bit(t % 16)\n    \
    \  t = t & 0x0F\n      i = i - 1\n    end\n    return r\n  end\n  -- Return 2^n\
    \ modulo p (be aware of numerics).\n  return ((2^(n - 1)) * p) % p\nend", "  if\
    \ p == 0 or p == 1 then\n    return n\n  end\n  if n == 0 then return 0 end\n\
    \  if p == 1 then return 1 end\n  local m = n % p\n  n = n - m\n  if n < 0 then\
    \ return m end\n  if m == 0 then return n end\n  return modp(m, p) + modp(n, p)\n\
    end", "\tif n == 0 then return p\n\tend\n\tif p == 0 then return 0\n\tend\n\t\n\
    \tlocal d = n - 1\n\tif d >= p then return 0\n\tend\n\t\n\treturn modp(d, p)\n\
    end", "  if p < 0 then\n    error('modp: p must be positive')\n  end\n  if n >=\
    \ p then\n    return 1\n  end\n  if n == 0 then\n    return 0\n  end\n  if n <\
    \ p then\n    return modp(p - 1, p)\n  end\n  local m = n % p\n  n = n - m\n \
    \ return m == 0 and n or modp(n, p)\nend", "  if p == 0 then return 1 end\n  local\
    \ q = 1\n  repeat\n    q = q * n / p\n    n = n % p\n  until n < 1\n  return q\n\
    end", "  local c = 0\n  while n % p ~= 0 do\n    n /= p\n    c = c + 1\n  end\n\
    \  return c\nend", "   if n < 0 then\n      n = -(n + 1)\n   end\n   if p == 0\
    \ or p == 1 then\n      return n\n   end\n   local result = 1\n   if n <= p then\n\
    \      result = (n % p) + modp(p, n)\n   else\n      result = modp(p, n)\n   end\n\
    \   return result\nend", "\tif n < p then\n\t\treturn modp((n * -1) + 1, p)\n\t\
    else\n\t\treturn n % p\n\tend\nend", "  if p == 0 then return 0 end\n  if n ==\
    \ 0 then return 0 end\n  local n = n - 1\n  while n >= 1 do\n    if p + n < p\
    \ then return n + 1 end\n    if p + n == p then return n end\n    p = p + n +\
    \ 1\n    n = n / 2\n  end\n  return 1\nend", "\tlocal mod\n\tif p == 0 then return\
    \ 0 end\n\tmod = tonumber(tostring(n)) + p\n\tif mod == n then return 1 end\n\t\
    return modp(mod, p)\nend", "  return ((n % p) + p) % p\nend", "    if p == 0 then\n\
    \        return 1\n    end\n    local q = modp(n / p, p)\n    if n ~= 1 and q\
    \ * p > n then\n        return q + 1\n    else\n        return q\n    end\nend",
  "    if n < 0 then\n        return modp(-n, p)\n    end\n    if n == 0 then\n  \
    \      return 0\n    end\n    if p == 0 then\n        return 1\n    end\n    if\
    \ n < p then\n        return modp(n - p, p)\n    end\n    if p*p >= n then\n \
    \       local m = modp(p / 2, p)\n        return m + (n % p)\n    end\n    return\
    \ modp(p, n)\nend", "\tif p == 0 then\n\t\treturn 0\n\telseif n == 1 then\n\t\t\
    return p\n\telse\n\t\treturn modp(n - 1, p * p) % p\n\tend\nend", "  if p == 0\
    \ then\n    if n == 0 then\n      return 0\n    else\n      --print(\"modp(\"\
    \ .. n .. \", \" .. p .. \")\")\n      --print(\"modp(\" .. n .. \", \" .. p ..\
    \ \")\")\n      local x = modp(n / p, p)\n      return x ^ n mod (p - x)\n   \
    \ end\n  else\n    if n < 0 or n > p then\n      return nil\n    end\n    -- print(\"\
    modp(\" .. n .. \", \" .. p .. \")\")\n    -- print(\"modp(\" .. n .. \", \" ..\
    \ p .. \")\")\n    local x = modp(n / p, p)\n    -- print(\"modp(\" .. n .. \"\
    , \" .. p .. \")\")\n    -- print(\"modp(\" .. n .. \", \" .. p .. \")\")\n  \
    \  local y = modp((n % p), p)\n    -- print(\"modp(\" .. n .. \", \" .. p .. \"\
    )\")\n    -- print(\"modp(\" .. n .. \", \" .. p .. \")\")\n    if x < 0 then\n\
    \      return y + x\n    else\n      return x + y\n    end\n  end\nend", "  return\
    \ math.floor((n % p) + p - 1) or p\nend", "  local t = math.abs(n)\n  local q,\
    \ r = div(t, p)\n  if q % 2 == 0 then\n    q = q + 1\n  else\n    q = q - 1\n\
    \  end\n  return n * p + (q < 0 and 1 or q > 0 and -q)\nend", "  local r = 1\n\
    \  while n > p do\n    r = r * p % n\n    n = n / p\n  end\n  return r\nend",
  "  -- This gives the same result as modPow().\n  n = n - 1\n  local q, r = p, \"\
    1\"\n  while true do\n    if n >= p then return q % p end\n    q, r = divmod(q,\
    \ p)\n    n = n - 1\n  end\nend", "  if n <= 0 then return 1 end\n  if n < p then\
    \ return modp(n - p, p) else return n end\nend", "  if p == 0 then\n    return\
    \ 1\n  elseif p == 1 or n == 1 then\n    return n\n  end\n  local modp_m = n %\
    \ p\n  return modp(n - modp_m, p)\nend", "  local r = n % p\n  if r == 0 then\
    \ r = p end\n  if r > p then r = p end\n  return r\nend", "\tif p == 0 then\n\t\
    \treturn n\n\telse\n\t\tlocal q = p / n\n\t\tif p % n ~= 0 then\n\t\t\tq = (q\
    \ * n) + p % n\n\t\tend\n\t\treturn q\n\tend\nend", "\tlocal x\n\tif n == 0 then\
    \ return 1 end\n\tif n == 1 then return 0 end\n\tif p == 0 then return modp(n\
    \ / 2, p) end\n\tif p == 1 then return n end\n\tx = modp(n / p, p)\n\treturn x\
    \ * p + n % p\nend", "  if n < 0 then return 0 end\n  if p == 0 then return 1\
    \ end\n  local a = 1\n  for i = 1, p do\n    if n >= a then return i end\n   \
    \ a = a * 2 % p\n  end\n  return p\nend", "    local r = 0\n    while r < n do\n\
    \        r = r * p % p\n    end\n    return r\nend", "  if p == 0 then return\
    \ 1 end\n  if n == 0 then return 0 end\n  return modp(n // p, p) + n % p\nend",
  "  if n < 0 then\n    error('bad argument for modp(n, p)')\n  end\n  if p == 0 or\
    \ p == 1 then\n    return 1\n  end\n  if n == 0 then\n    return 0\n  end\n  if\
    \ n < p then\n    local q, r = divrem(n, p)\n    return r + modp(q, p)\n  end\n\
    \  -- x % p = q\n  local q = n - p\n  if q % 2 == 0 then\n    return modp(q, p)\n\
    \  end\n  local r, q = divrem(q, 2)\n  return r + modp(q, p)\nend", "  if n <=\
    \ 0 then return 1 end\n  if n >= p then return modp(n div p, p) end\n  local c\
    \ = 1\n  repeat\n    n = n % p\n    -- This should never happen\n    if n == 0\
    \ then break end\n    c = c * p + (n and n % p or n)\n  until false\n  return\
    \ c\nend", "  assert(n > 0 and p, \"Both n and p must be positive\")\n  -- Make\
    \ sure n is a power of 2 so that 2^p works.\n  -- This fixes a bug that caused\
    \ an infinite loop when n was\n  -- a power of 2 and p was a power of 10.\n  n\
    \ = tonumber(string.format(\"%u\", math.floor(n)))\n  p = tonumber(string.format(\"\
    %u\", math.floor(p)))\n  if n == 0 or p == 1 then return 1 end\n  -- The next\
    \ line is a short way of saying \"return 1 if n / p == 1\"\n  -- but without an\
    \ explicit \"else\" clause, Lua will complain about\n  -- an implicit \"else\"\
    \ clause, and in Lua 5.2 that implicit else is\n  -- silently ignored. I suspect\
    \ that it is now an explicit \"else\"\n  -- clause that we have to get rid of.\n\
    \  if p ~= n and n % p ~= 0 then return 1 end\n  if p == 1 then\n    if n == 2\
    \ or n == 3 then return 2 end\n    if n == 4 or n == 5 then return 3 end\n   \
    \ if n == 6 then return 4 end\n    return n\n  end\n  -- Now just deal with the\
    \ special cases where n is not a power of 2.\n  -- The first is when n is divisible\
    \ by p.\n  if n % p == 0 then return n % p end\n  -- The second is when p is divisible\
    \ by n.\n  if p % n == 0 then return n % p end\n  -- And if n is evenly divisible\
    \ by p and p is not evenly divisible\n  -- by n, then it's evenly divisible by\
    \ (p - 1).\n  if p % n == 0 and p == n and n % 2 == 1 then return 0 end\n  --\
    \ Finally, if n is evenly divisible by p but not by p-1 or n is evenly\n  -- divisible\
    \ by (p - 1) but not by n, then it's evenly divisible by p.\n  if p % n == 0 and\
    \ p == n and n % 2 == 1 and p ~= n then\n    return p end\n  return nil\nend",
  "\tif n < 0 or n % p then return 0 end\n\tlocal t = 1\n\twhile t < p do\n\t\tt =\
    \ t * 2\n\tend\n\tn = n % t\n\tif n == 0 then return 1 end\n\treturn t\nend",
  "  n = n % p\n  if n < 0 then\n    return modp(n + p, p)\n  end\n  return n\nend",
  "  if p == 0 then\n    return 1\n  elseif p == 1 then\n    return n\n  elseif p\
    \ == -1 then\n    return -n\n  end\n  if n > 0 then\n    return modp(n-1, p) +\
    \ modp(n-1, p-1)\n  else\n    return modp(n-1, p)\n  end\nend", "  if p == 0 then\
    \ return 0 end\n  if n < p then return n end\n  local nd = n - p\n  if nd <= 0\
    \ then return n end\n  if p == 0 then return 1 end\n  local k = 1\n  repeat\n\
    \    k = k * 2 + 1\n  until k > nd\n  return ((n % p) + p) % p\nend", "  if n\
    \ >= p then return n end\n  if n < p then return modp(n, p - 1) end\n  return\
    \ p % n + 1\nend", "\t-- If n is 0, return 1.\n\t-- If n is less than 0, return\
    \ 0\n\tif n == 0 then\n\t\treturn 1\n\tend\n\t-- If n is greater than or equal\
    \ to p, return 1.\n\tif n >= p then\n\t\treturn 1\n\tend\n\t-- Otherwise, return\
    \ n.\n\treturn n\nend", "  if n < p then\n    return n\n  elseif n == p then\n\
    \    return 0\n  else\n    return modp(n - p, p) + 1\n  end\nend", "  local s\
    \ = bit.band(n, p-1)\n  if s == 0 then return 1 end\n  n = bit.bor(n, p-1)\n \
    \ return s\nend", "  if p == 0 then return 1 end\n  return n * modp((n or 0) -\
    \ 1, p-1)\nend", "  local t = n % p\n  if t == 0 then\n    return 0\n  elseif\
    \ t < 0 then\n    return modp(n - p + 1, p) -- Decrement, round down\n  else\n\
    \    return modp(n, p - 1) -- Increment, round up\n  end\nend", "  if p == 0 then\n\
    \    return 1\n  elseif p == 1 then\n    return n\n  else\n    return n % p\n\
    \  end\nend", "\tif p == 0 then\n\t\treturn 1\n\tend\n\tif n == p then\n\t\treturn\
    \ 0\n\tend\n\tif n <= 0 then\n\t\treturn p - 1\n\tend\n\tlocal result = 1\n\t\
    while n >= p do\n\t\t-- Make sure that all factors are smaller than p.\n\t\tlocal\
    \ t = modp(n, p)\n\t\tresult = result * t + p\n\t\tn = n / t\n\tend\n\treturn\
    \ result\nend", "  -- Shift must be less than or equal to p, and n must be a power\
    \ of 2.\n  -- The result is equal to ((n - 1)^p % p) % p if p is prime,\n  --\
    \ equal to n if p is composite, and equal to (n - 1) % p if p is not prime.\n\
    \  -- Since p is prime, a bit-shift is all that's necessary.\n  -- In other words,\
    \ (p^n) % p doesn't give the required result in all cases.\n  -- (For clarity,\
    \ modpow(4, 8, p) computes ((4-1)^p % p) % p).\n  -- The difference between modpow(5,\
    \ 1, p) and modpow(-5, 1, p)\n  -- is that p must be prime whereas modpow(5, 1,\
    \ p)\n  -- raises a division by 0 error if p is prime, but raises a\n  -- division-by-zero\
    \ error if p is not prime.\n  -- This difference does not matter, since we can\
    \ determine\n  -- whether p is prime or composite by whether n % p == 0 or n %\
    \ p == 1 later.\n  -- Therefore, it's sufficient that p be odd to have a positive\
    \ result.\n  -- If p is not prime, we can simply return n - 1.\n  local shift_bits\
    \ = 1 << (p - 2)\n  return (n >> shift_bits) % p\nend", "  -- Compute and return\
    \ the greatest integer less than or equal to n modulo p.\n  -- See http://rosettacode.org/wiki/Modular_exponentiation#Python\n\
    \  -- For those not familiar with the algorithm, it's basically a\n  -- recursive\
    \ version of the Euclidean algorithm.\n  -- For an explanation see http://rosettacode.org/wiki/Modular_exponentiation#Python\n\
    \  -- >>> modp(20, 10)\n  -- 10\n  -- >>> modp(97, 103)\n  -- 13\n  -- >>> modp(122,\
    \ 103)\n  -- 17\n  -- >>> modp(98, 103)\n  -- 97\n  -- >>> modp(121, 103)\n  --\
    \ 18\n  -- >>> modp(7, 104)\n  -- 1\n  -- >>> modp(2, 104)\n  -- 8\n  -- >>> modp(1,\
    \ 104)\n  -- 1\n  local function pow2(n)\n    local pow2 = 0\n    local i = 2\n\
    \    while i <= n do\n      pow2 = pow2 * i\n      i = i + 1\n    end\n    return\
    \ pow2\n  end\n  -- Initialize result to 1\n  local result = 1\n  -- Initialize\
    \ exponent to 1\n  local exponent = 1\n  -- Initialize modulo to 1\n  local modulo\
    \ = 1\n  -- Initialize n to n (base case)\n  local n = n\n  -- While exponent\
    \ is less than or equal to modulo\n  while exponent <= modulo do\n    -- Get the\
    \ value of pow2 that produces the current result.\n    -- pow2 goes through all\
    \ values in {1, 2, 4, 8, 16, 32, ...}.\n    -- Note that n goes through all values\
    \ in {0, 2, 4, ...}\n    local pow2 = pow2(n)\n    -- Set result to the previous\
    \ result modulo n.\n    result = result % n\n    -- Multiply result by n and decrement\
    \ exponent by 1.\n    local new_exponent = exponent - 1\n    -- Divide result\
    \ by pow2 and decrement modulo accordingly.\n    modulo = modulo / (pow2 % n)\n\
    \    -- Update n to n.\n    n = n\n    -- Set exponent to new_exponent.\n    exponent\
    \ = new_exponent\n  end\n  -- Return result.\n  return result\nend", "  if n ==\
    \ 0 then return p else return modp(n - 1, p) end\n  local p = p or 1\n  local\
    \ t = 1\n  for i = 2, n do\n    t = ((t % p) + p) % p\n  end\n  return t\nend",
  "  if n < 0 then\n    return n % p\n  end\n  if p == 0 then\n    return 0\n  end\n\
    \  if n == 1 then\n    return 1\n  end\n  if n ~= 1 then\n    return modp(n %\
    \ p, p)\n  end\nend", "  if n == 0 then return p\n  if n == p then return n\n\
    \  if p == 0 then return 0\n  if n == p then return 1\n  if p == 0 then return\
    \ 0\n  if n == p and p == 1 then return 1\n  local t = modp(n / p, p)\n  local\
    \ u = n % p\n  if u == 0 then return t\n  if u == p then return t\n  if u == p\
    \ then\n    if t % 2 == 0 then\n      return (3 * t) + 1\n    else\n      return\
    \ (3 * t) + 2\n    end\n  end\nend", "\tlocal d = n - p\n\treturn (d >= 0 and\
    \ d or -d) % p\nend", "  if p == 0 then\n    return 1\n  elseif p == 1 then\n\
    \    return n\n  else\n    return n % p\n  end\nend", "    if p == 0 then\n  \
    \      return 0\n    end\n    local q = 0\n    while n > q do\n        if n %\
    \ p == 0 then\n            return p\n        end\n        q, p = p * p % p + q,\
    \ p\n    end\n    return q\nend", "  if n < 0 then return n end\n  if p == 1 then\
    \ return 1 end\n  if p == 0 then return 0 end\n  if p == 1 then return 1 end\n\
    \  if p == 0 then return 1 end\n  if n % p == 1 then return modp(n / p, p) else\
    \ p end\nend", "  if n < 0 then\n    return modp(n - 1, p)\n  end\n  if n == 0\
    \ then\n    return 1\n  end\n  if p == 0 or p == 1 then\n    return 0\n  end\n\
    \  if n == 1 then\n    return p\n  end\n  local q, r = divrem(n, p)\n  if q >\
    \ 0 then\n    return p * modp(q, p)\n  end\n  local x = modp(r, p)\n  if x % p\
    \ == 1 then\n    return x\n  end\n  return x + (p - 1)\nend", "    local x, y\
    \ = p\n    if n < 0 or n % p ~= 0 then\n        return nil\n    end\n    local\
    \ t = 1\n    while y < p do\n        t = y * y\n        local q = n - t\n    \
    \    if n ~= t then\n            break\n        end\n        x = x * x\n     \
    \   n = q\n    end\n    return x\nend", "  if p < 0 then\n    -- Avoid a negative\
    \ remainder by adjusting the input as usual.\n    local q = 2^n - 1\n    return\
    \ q % p\n  end\n  local q = (n % p) + 1\n  if q > p then\n    -- The input was\
    \ larger than the modulus. Reduce it modulo\n    -- p until it's smaller than\
    \ p (which it always will be)\n    local r = p - q % p\n    q = n + (r - r) %\
    \ p\n  end\n  return q\nend", "  if p == 0 then\n    return 0\n  end\n  local\
    \ d = n - 1\n  while d % p ~= 0 do\n    d /= p\n  end\n  return d\nend", "  local\
    \ r = n % p\n  if r == 0 then\n    return 1\n  else\n    return r + modp(n / p,\
    \ p)\n  end\nend", "    if n <= p then\n        return n - p\n    elseif n <=\
    \ p then return 1 end\n    -- return 1\nend", "  return ((n % p) + p) % p\nend",
  "  if p == 0 then\n    return 0\n  end\n  return ((n % p) + p) % p\nend", "    local\
    \ q, r = divMod(n, p)\n    return q * p + (q > 0 and r or 0)\nend", "    -- Use\
    \ a lookup table to save a multiplication and avoid division.\n    local x = {[1]\
    \ = 0}\n    for i = 2, n do\n        x[i] = x[i-1] + p\n    end\n    return x[n]\n\
    end", "    return n & (p-1)\nend", "  local q = (math.floor(n/p) + 1)*p\n  if\
    \ q == 0 then\n    return q\n  elseif q*p > n then\n    return q\n  else\n   \
    \ return q\n  end\nend", "  local a\n  local b\n  if p == 0 then\n    return 1\n\
    \  else\n    -- If p is a number between 0 and 9 and p is a multiple of 10, then\n\
    \    -- the number p is not a multiple of 10.\n    if math.mod(p, 10) == 0 then\n\
    \      return n % p\n    end\n    -- If p is a multiple of 10 and p is not a multiple\
    \ of 10, then\n    -- the number p is a multiple of 10.\n    if math.mod(p, 10)\
    \ == 0 then\n      return n\n    end\n    -- Get the high part and store it in\
    \ a and b.\n    a, b = n / 10, n % 10\n    -- Check if the high part is a multiple\
    \ of 10 (b).\n    -- If yes, then b is not a multiple of 10.\n    if b == 0 then\n\
    \      return a\n    end\n    -- If the high part is not a multiple of 10, then\
    \ b is a multiple of 10\n    -- and a > 1.\n    if b > 0 then\n      return a\n\
    \    end\n    -- Return the lower part mod p.\n    return a * 10 % p\n  end\n\
    end", "  local d = n % (p - 1)\n  if d == 0 then return 1 end\n  local s = 1 +\
    \ modp(d, p)\n  return n % p == 0 and s or s\nend", "  if p == 0 then return n\
    \ end\n  if p == n then return 0 end\n  local mod = n\n  while (n % p) == 0 do\n\
    \    n = math.floor(n/p)\n    mod = mod * p\n  end\n  return mod\nend", "  if\
    \ p == 0 then\n    return 1\n  elseif n == 0 then\n    return 0\n  elseif p ==\
    \ 1 or n == 1 then\n    return n\n  else\n    return n % p + modp((n - n % p),\
    \ p)\n  end\nend", "  local m = (p + n) % (p - n)\n  return m == 0 and n or m\n\
    end", "  local r = n % p\n  if r == 0 then\n    return 1\n  else\n    return modp(r,\
    \ p + 1) + 1\n  end\nend", "   if n == 0 then\n      return 0\n   else\n     \
    \ return (p-1) * (n % p) + p\n   end\nend", "  if p == 0 then return 1\n  elseif\
    \ p == 1 then return n\n  elseif n >= p then return n % p\n  else return modp(n\
    \ - p, p) + 1 end\nend", "    if n >= p then\n        return p\n    elseif n <\
    \ p then\n        return modp(n - p, p)\n    else\n        return modp((n - p)\
    \ + p, p)\n    end\nend", "  -- Return 2^n modulo p.\n  local r = math.pow(2,\
    \ n)\n  if p == r then\n    return r\n  end\n  local m = math.floor(p * math.log(r)\
    \ / math.log(p))\n  return math.floor(r / math.pow(p, m))\nend", "  n = n - 1\n\
    \  if n == 0 then return 1 end\n  if n == p then return 2 end\n  local f = 0\n\
    \  repeat\n    f += n % p\n    n = n / p\n  until n > 1\n  return f + 1\nend",
  "  -- Make sure n is a number\n  n = tonumber(n)\n  -- Make sure p is a number\n\
    \  p = tonumber(p)\n  -- Return 2^n modulo p (be aware of numerics).\n  -- >>>\
    \ modp(3, 5)\n  -- 3\n  -- >>> modp(1101, 101)\n  -- 2\n  -- >>> modp(0, 101)\n\
    \  -- 1\n  -- >>> modp(3, 11)\n  -- 8\n  -- >>> modp(100, 101)\n  -- 1\n  return\
    \ math.pow(2, n) % p\nend", "  if n and p then return n % p\n  end\n  return 0\n\
    end", "  local function f(n)\n    if n == 0 then return 0 end\n    if n > p then\
    \ return f(n-1) * p + 1 end\n    if n <= p then return f(n-1) * p end\n  end\n\
    \  f(n)\nend", "  local d, r = 0, n\n  -- Handle negatives\n  while n > 0 do\n\
    \    r, d = r + d, r - n % p\n    n, n = n / p\n  end\n  return r\nend", "  if\
    \ n<0 then\n    return 0\n  end\n  if n<p then\n    return 1\n  end\n  local k=0\n\
    \  while n%p==0 and k<p do\n    n = n / p\n    k = k + 1\n  end\n  return k\n\
    end", "    local d\n    if n < 0 then\n        d = modp(-n, p)\n        n = -n\n\
    \    else\n        d = 1\n    end\n    while n % d == 0 do\n        n = n / d\n\
    \        d = d * 10\n    end\n    return n % p\nend", "  if n < 0 then\n    error('negative\
    \ number')\n  end\n  if n < p then\n    return n\n  else\n    return p + modp(n\
    \ - p, p)\n  end\nend", "  local _, q = tonumber(p), tonumber(n)\n  local res\
    \ = 0\n  if q == 0 and n ~= 0 then\n    res = 1\n  end\n  if q == 0 then\n   \
    \ return res\n  end\n  if n % q == 0 then\n    res = math.floor(n/q)\n  end\n\
    \  return res\nend", "  if n == 0 then return p end\n  if p == 0 then return 0\
    \ end\n  local i = 1\n  while i <= n do\n    if n % i == 0 then\n      if i ==\
    \ p then\n        return i - 1\n      else\n        return i\n      end\n    end\n\
    \    i = i + 1\n  end\nend", "  local r = 1\n  while n ~= 0 do\n    r = r * p\
    \ + (n - 1)\n    n = n >> 1\n  end\n  return r\nend", "\tlocal rem = n % p\n\t\
    return p == 0 and rem or modp(rem - p, p)\nend", "  return ((n % p) + p) % p\n\
    end", "  local factor = 1\n  repeat\n    if n >= p then\n      n = n / p\n   \
    \   factor = factor * p\n    end\n  until n > 1\n  return factor\nend", "\tif\
    \ n == 0 then\n\t\treturn 1\n\tend\n\tlocal t = p\n\tlocal d = 0\n\trepeat\n\t\
    \td = t + n % p\n\t\tn = n / p\n\tuntil n > 1\n\treturn d\nend", "\tif p == 0\
    \ then\n\t\treturn n\n\telseif p == 1 then\n\t\treturn n % p\n\telseif p == 2\
    \ then\n\t\treturn ((n % p) + p) % p\n\tend\n\tlocal p = p % p\n\treturn modp(n\
    \ + (p << 1), p)\nend", "  -- If n is a prime then return n (p is a prime).\n\
    \  if p == 1 then\n    return n\n  elseif p == 2 then\n    return pow(2, n, p)\n\
    \  else\n    -- If n is divisible by p then return n/p.\n    -- Otherwise return\
    \ a multiple of the smaller prime p.\n    if p > n then\n      local q = div(n,\
    \ p)\n      return modp(q, p)\n    else\n      local q = div(n, p)\n      return\
    \ q * modp(q, n)\n    end\n  end\nend", "  if n == 0 then return 1 end\n  if n\
    \ == p then return 1\n  local q, r = p*p%n, n\n  while r > 0 do\n    q, r = q*q%p,\
    \ r\n  end\n  return q\nend", "  return n==0 and 1 or p == 0 and 0 or p > 0 and\
    \ n - p or modp(n + (p > 0 and n or 0), p) % p\nend", "  n = n + 1\n  if n < 1\
    \ then return 1 end\n  if n > p then return p end\n  if p > 1 then return modp(n\
    \ / 2, p) end\n  local i = 1\n  while i <= n do\n    if n % i == 0 then return\
    \ i end\n    i = i + 1\n  end\n  return n -- should not happen\nend", "\t-- This\
    \ algorithm is from http://www.numbertheory.org/php/modp.html\n\t-- Am I right\
    \ that modp is O(n) ?\n\t-- The algorithm below is O(log2(n)) but that's not too\
    \ important for us\n\t-- (it's fast enough for all our purposes).\n\t-- The constants\
    \ below were chosen to yield results with 4 decimals of precision.\n\t-- The reason\
    \ we need this function is that if we used `math.floor` we would\n\t-- not get\
    \ the same result as Python which rounds up when `math.floor` is used\n\t-- to\
    \ round numbers like 3.1.\n\tif n < 0 then\n\t\tn = -n\n\t\tp = -p\n\tend\n\t\
    if n == 0 then\n\t\treturn 1\n\tend\n\t-- Round the input to yield a number that\
    \ is O(1) in Python.\n\tlocal function roundup()\n\t\treturn math.floor(n) + math.ceil(n)\
    \ - 1\n\tend", "\tif p == 0 or p == 1 then\n\t\treturn 1\n\tend", "  local m\n\
    \  if p == 0 then\n    return 1\n  elseif p == 1 then\n    return n\n  else\n\
    \    m = modp(n / p, p)\n  end\n  return m + m\nend", "    local n0 = n * p\n\
    \    local n1 = n % p\n    return n0 == 0 and n or n1 ~= 0 and n1 + p or n0\n\
    end", "\tn = math.floor(n)\n\tp = math.floor(p)\n\tif p == 0 then\n\t\treturn\
    \ 1\n\tend\n\tif p == 1 or n == 0 then\n\t\treturn 0\n\tend\n\tlocal d, q = p,\
    \ (n / p)\n\tfor i = 2, q do\n\t\tif n % i == 0 then\n\t\t\td = (d * i) % p\n\t\
    \tend\n\tend\n\treturn d\nend", "  if n == 0 then return p\n  elseif n == p then\
    \ return n\n  else\n    -- Find the smaller of the two numbers that divides n.\n\
    \    -- If there is one that divides n and one that divides p,\n    -- then n\
    \ must be in the range [p, p+k) (here k=p-p%n)\n    -- or in [n, n). Since n is\
    \ at least 1, we can use <= to check this.\n    local m, d = p%n, n\n    while\
    \ m <= d and m <= n and n <= p do\n      m, d = d, m*2\n    end\n    -- Now m\
    \ is strictly less than n.\n    -- Find m, d such that m*d == n. Note that the\
    \ first time through\n    -- the loop we set d = n.\n    local m = n\n    local\
    \ d = 1\n    while m > 1 do\n      d, m = d, m-2\n    end\n    -- Now d is the\
    \ square root of n.\n    -- If n is composite and even, then\n    -- 1 <= d <\
    \ p.\n    -- If n is composite and odd, then\n    -- d < p <= sqrt(p).\n    return\
    \ d <= p and p and d*d <= n or p <= d*n and n <= p\n      and p and p*p <= n or\
    \ n <= p*p and p <= p\nend", "  if p == 0 then return 1\n  elseif p == 1 or p\
    \ == 2 then return n\n  elseif p == -1 then return n / p\n  end\n  local d = 1\n\
    \  local t = modn(n - 1, p + d)\n  if t < p then\n    d, t = t, d\n  end\n  return\
    \ d\nend", "  if n == 0 then\n    return 1\n  end\n  -- Special cases.\n  if n\
    \ < 0 then\n    return p\n  end\n  if p <= 1 then\n    return 1\n  end\n  if n\
    \ == p then\n    return 0\n  end\n  if p < 2 then\n    return 0\n  end", "   \
    \ -- If n is negative, return p.\n    if n < 0 then\n        return p\n    end",
  "\tif n == 0 then\n\t\treturn 1\n\tend\n\tlocal nn = math.abs(n)\n\tif p < 0 then\n\
    \t\tp = -p\n\tend\n\tlocal d = p % nn\n\tif d ~= 0 and nn ~= 0 then\n\t\treturn\
    \ modp(nn - d, p)\n\telse\n\t\treturn n\n\tend\nend", "    -- Special case: when\
    \ n < 0, n % p == 0.\n    if n < 0 then\n        if n % p == 0 then\n        \
    \    return 0\n        else\n            return n % p\n        end\n    end",
  "    if n == 0 then return p else return n % p end\nend", "  return ((n % p) + p)\
    \ % p\nend", "  n = n % p\n  if n > 0 then\n    return modp(n + 1, p)\n  else\n\
    \    return n\n  end\nend", "  assert(n >= 0 and p > 0)\n  if n ~= 0 then\n  \
    \  -- This is faster than math.floor.\n    local r = modpow2(n, p - 1) -- r =\
    \ n mod p (n and p are positive integers).\n    return r + r\n  else\n    return\
    \ 0\n  end\nend", "  return ((n % p) + p) % p\nend", "  if p == 0 then\n    return\
    \ 1\n  end\n  if p == 1 then\n    return n\n  end\n  if n <= p then\n    return\
    \ modp(n - 1, p)\n  end\n  local m = n % p\n  return modp(m, p) + p\nend", " \
    \ return math.floor((n % p) + math.ceil(p))\nend", "  if n <= p then\n    return\
    \ 0\n  end\n  local q = (p + 1) // p\n  if n % q == 0 then\n    return q\n  end\n\
    \  local i\n  local m = 0\n  for i = q - 1, -(p + 1), -1 do\n    m = ((n % p)\
    \ + p) % p\n    n = n // p\n    if m ~= 0 then\n      return i\n    end\n  end\n\
    \  assert(false, \"modp failed\")\nend", "    if n < 0 then\n        return nil\n\
    \    end\n    if n >= p then\n        return n\n    end\n    local rem = n % p\n\
    \    if rem == 0 then\n        return p\n    else\n        return modp(n - rem,\
    \ p)\n    end\nend", "   if n == 0 then\n      return 1\n   elseif n < p then\n\
    \      return n % p\n   else\n      return modp(n - (n % p), p)\n   end\nend",
  "    return math.floor(n / p) * p + p % n\nend", "\tif n == 0 then return 1 end\n\
    \tif n == 1 or n == p then return n end\n\tif n < p then return modp(n - p, p)\
    \ end\n\treturn modp(n - p + (n - 1) % p, p)\nend", "  if p == 0 then\n    return\
    \ 1\n  elseif p == 1 or p == -1 then\n    return n\n  end\n  local m\n  if n >=\
    \ 0 and n <= p then\n    m = n % p\n  else\n    m = -n % p\n    if m >= p then\n\
    \      m = m+p\n    end\n  end\n  return m\nend", "\tassert(p > 0)\n\tassert(n\
    \ >= 0 and n <= p)\n\tlocal n1 = n - ((n ^ p + p) % p) -- n - ((n ^ p + p) % p)\
    \ <=> n % p\n\tif n1 <= 0 then n1 = p end\n\treturn n1\nend", "  if p == 0 then\n\
    \    return 1\n  end\n  if p == 1 or p == 2 or p == 3 then\n    return n % p\n\
    \  end\n  local d = modpow(n, p - 2, p)\n  if d % p ~= 0 and d ~= p then\n   \
    \ return 0\n  end\n  return d\nend", "  n = n - math.floor(n/p)*p\n  if n > p\
    \ then return n else return n end\nend", "  if n < 0 or p < 0 then return nil\
    \ end\n  if n == 0 then return 1 end\n  if p == 1 then return 1 end\n  if p ==\
    \ 2 then return 2 end\n  if p == 3 then return 3 end\n  if p == 4 then return\
    \ 4 end\n  local res = n % p\n  return n - (res < p and res) or modp(n - res,\
    \ p)\nend", "  local b = p - 1;\n  n = n - 1;\n  while n >= b do\n    n, b = b\
    \ * 2, n - b;\n  end;\n  return n;\nend;", "   if n == 0 then\n      return 0\n\
    \   elseif n < 0 then\n      n = -n\n      return modp(-n, p)\n   end\n   return\
    \ n % p\nend", "    -- We assume that n is nonnegative.\n    local r = 0\n   \
    \ while n > p do\n        r = r * 2 % p\n        n = math.floor((n - r) / 2)\n\
    \    end\n    return r\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
