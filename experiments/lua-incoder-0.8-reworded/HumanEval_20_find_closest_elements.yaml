name: HumanEval_20_find_closest_elements
language: lua
prompt: "-- From a supplied table of numbers (of length at least two) select and return\
  \ two that are the closest to each\n-- other and return them in order (smaller number,\
  \ larger number).\n-- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n\
  -- {2.0, 2.2}\n-- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n--\
  \ {2.0, 2.0}\nlocal function find_closest_elements(numbers)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = find_closest_elements\n\
  \    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), {3.9, 4.0})\n  \
  \  lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}), {5.0, 5.9})\n    lu.assertEquals(candidate({1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2}), {2.0, 2.2})\n    lu.assertEquals(candidate({1.0, 2.0,\
  \ 3.0, 4.0, 5.0, 2.0}), {2.0, 2.0})\n    lu.assertEquals(candidate({1.1, 2.2, 3.1,\
  \ 4.1, 5.1}), {2.2, 3.1})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- Only works for two numbers.\n  if #numbers < 2 then\n    return\
    \ {numbers[1]}\n  end", "   assert(#numbers > 1)\n   local biggest, smallest =\
    \ nil, numbers[1]\n   for _, value in ipairs(numbers) do\n      if biggest ==\
    \ nil then biggest = value end\n      if value < smallest then smallest = value\
    \ end\n   end\n   return biggest, smallest\nend", "    local minimum = {}\n  \
    \  for i=1,#numbers do\n        minimum[i] = math.min(numbers[i], minimum[i])\n\
    \    end\n    local minimum2 = {}\n    for i=1,#numbers do\n        minimum2[i]\
    \ = math.min(minimum[i], minimum2[i])\n    end\n    for i=1,#numbers do\n    \
    \    if minimum[i] == minimum2[i] then\n            minimum2[i] = minimum[i]\n\
    \        end\n    end\n    return minimum2, minimum\nend", "  if #numbers < 2\
    \ then return {nil, nil} end\n  local min_diff = nil\n  local min1, min2 = unpack(numbers)\n\
    \  local max1, max2 = unpack(numbers)\n  local i = 1\n  while i <= #numbers do\n\
    \    local diff1 = max1 - min1\n    local diff2 = max2 - min2\n    if diff1 ==\
    \ 0 then\n      if diff2 == 0 then return { min1, max1 } end\n      local i2 =\
    \ i+1\n      while i2 <= #numbers do\n        local diff2 = max2 - numbers[i2]\n\
    \        if diff2 == 0 then return { min2, numbers[i2] } end\n        i2 = i2\
    \ + 1\n      end\n    else\n      if diff2 == 0 then return {min1, max1} end\n\
    \      local i2 = i+1\n      while i2 <= #numbers do\n        local diff1 = max1\
    \ - numbers[i2]\n        if diff1 == 0 then return { numbers[i2], max2 } end\n\
    \        i2 = i2 + 1\n      end\n    end\n    i = i + 1\n  end\nend", "  if #numbers\
    \ < 2 then return {numbers[1]} end\n  local lowest_distance\n  local lowest_number\n\
    \  for _, number in pairs(numbers) do\n    local distance = math.abs(number -\
    \ numbers[1])\n    if lowest_distance == nil or lowest_distance > distance then\n\
    \      lowest_number = number\n      lowest_distance = distance\n    end\n  end\n\
    \  local lowest_number_2 = numbers[#numbers]\n  if lowest_number_2 < lowest_number\
    \ then\n    lowest_number_2 = numbers[1]\n  end\n  return { lowest_number, lowest_number_2\
    \ }\nend", "  if #numbers < 2 then return nil, nil end\n  if #numbers == 1 then\
    \ return {numbers[1]} end", "   if #numbers < 2 then\n      return {}\n   end\n\
    \   local sorted_numbers = table.sort(numbers)\n   local closest_pairs = {}\n\
    \   local closest_pair_index = nil\n   local min_diff = math.inf\n   for i, num\
    \ in ipairs(sorted_numbers) do\n      if i ~= closest_pair_index then\n      \
    \   local pair = table.copy(closest_pairs)\n         pair[1] = num\n         table.insert(pair,\
    \ i)\n         if math.abs(num - pair[1]) < min_diff then\n            closest_pairs\
    \ = pair\n            min_diff = math.abs(num - pair[1])\n            closest_pair_index\
    \ = i\n         end\n      end\n   end\n   if closest_pair_index == nil then\n\
    \      table.insert(closest_pairs, sorted_numbers[1])\n      table.insert(closest_pairs,\
    \ sorted_numbers[#sorted_numbers])\n   end\n   return table.concat(closest_pairs,\
    \ 1)\nend", "    local smallest_number = tonumber(numbers[1])\n    local second_smallest_number\
    \ = tonumber(numbers[2])\n    if smallest_number > second_smallest_number then\n\
    \        second_smallest_number, smallest_number = smallest_number, second_smallest_number\n\
    \    end\n    table.insert(numbers, smallest_number)\n    table.insert(numbers,\
    \ second_smallest_number)\n    return numbers\nend", "  local lower = table.remove(numbers,\
    \ 1)\n  local upper = table.remove(numbers, 1)\n  table.insert(numbers, lower)\n\
    \  table.insert(numbers, upper)\n  local result = {}\n  for _, number in ipairs(numbers)\
    \ do\n    local distance = math.abs(number - lower) + math.abs(number - upper)\n\
    \    table.insert(result, number)\n    if distance < 2 then\n      table.insert(result,\
    \ number)\n    end\n  end\n  return result\nend", "   local best = {numbers[1]}\n\
    \   for idx = 2, #numbers do\n      local dist = numbers[idx] - numbers[1]\n \
    \     if dist < best[1] then\n         best[1] = dist\n         best[2] = numbers[idx]\n\
    \      end\n   end\n   return best\nend", "  assert(#numbers >= 2, 'table must\
    \ have at least two elements')\n  local max_value = numbers[1]\n  local min_value\
    \ = numbers[1]\n  for i = 2, #numbers do\n    if numbers[i] < min_value then\n\
    \      min_value = numbers[i]\n    end\n    if numbers[i] > max_value then\n \
    \     max_value = numbers[i]\n    end\n  end\n  return min_value, max_value\n\
    end", "  assert(#numbers > 0, \"find_closest_elements: Invalid input for numbers:\
    \ nil\")\n  if #numbers < 2 then return {numbers[1]} end\n  local differences\
    \ = table.replicate(#numbers, 0)\n  local max_difference = numbers[1] - numbers[1]\n\
    \  for i = 1, #numbers do\n    differences[i] = numbers[i] - numbers[i + 1]\n\
    \    if differences[i] > max_difference then\n      max_difference = differences[i]\n\
    \    end\n  end\n  local min_diff = max_difference\n  local min_element_index\
    \ = 1\n  local min_element = numbers[1]\n  for i = 1, #numbers do\n    local difference\
    \ = differences[i]\n    if difference < min_diff then\n      min_diff = difference\n\
    \      min_element_index = i - 1\n      min_element = numbers[i]\n    end\n  end\n\
    \  local new_numbers = {min_element}\n  for i = 1, #numbers - 1 do\n    new_numbers[i]\
    \ = numbers[i+1]\n  end\n  new_numbers[#new_numbers+1] = numbers[#numbers]\n \
    \ return new_numbers\nend", "    local closest = nil\n    local min_index = 1\n\
    \    local max_index = 1\n    local min_diff = math.abs(numbers[1] - numbers[2])\n\
    \    for i = 1, #numbers do\n        local diff = math.abs(numbers[i] - numbers[min_index])\n\
    \        if diff < min_diff then\n            closest = numbers[min_index]\n \
    \           min_index = i\n            min_diff = diff\n        elseif diff >\
    \ min_diff then\n            max_index = i\n            min_diff = diff\n    \
    \    end\n    end\n    return {closest,numbers[max_index]} -- return the closest\
    \ two.\nend", "  if #numbers < 2 then\n    return nil\n  end", '    assert(#numbers
    >= 2)', "   if numbers[1] == numbers[#numbers] then\n      return {numbers[1],\
    \ numbers[#numbers]}\n   end\n   local smallest = numbers[1]\n   local largest\
    \ = numbers[#numbers]\n   for i=2,#numbers do\n      local dist  = numbers[i]\
    \ - largest\n      local next  = largest + (largest - smallest) / 2 + dist\n \
    \     if next < smallest then\n         smallest = next\n      elseif next > largest\
    \ then\n         largest = next\n      end\n   end\n   return { smallest, largest\
    \ }\nend", "  return function(table)\n    local min1 = math.min(unpack(table))\n\
    \    local min2 = math.min(unpack(table))\n    for i=1,#table do\n      if min2\
    \ == math.min(unpack(table)) and min1 < min2 then\n        min1, min2 = min2,\
    \ min1\n      end\n    end\n    return table\n  end\nend", "    local max_diff,\
    \ min_diff = numbers[1], numbers[1]\n    for i = 2, #numbers do\n        local\
    \ diff = numbers[i] - numbers[i - 1]\n        if diff > max_diff then\n      \
    \      max_diff = diff\n        elseif diff < min_diff then\n            min_diff\
    \ = diff\n        end\n    end\n    return {numbers[#numbers], numbers[#numbers]\
    \ - min_diff}\nend", '  assert(#numbers >= 2)', "  local smallest, largest = numbers[1],\
    \ numbers[2]\n  local i = 0\n  for i=1,#numbers do\n    local current_smallest\
    \ = numbers[i]\n    local current_largest = numbers[i]\n    if smallest < current_smallest\
    \ then\n      smallest = current_smallest\n    elseif largest > current_largest\
    \ then\n      largest = current_largest\n    end\n  end\n  return smallest ..\
    \ largest\nend", "  local n = #numbers\n  assert(n > 0)\n  local closest = {}\n\
    \  for i = 1, n do\n    local j = i - 1\n    local diff\n    diff = numbers[i]\n\
    \    if j == 1 then diff = diff + numbers[i] end\n    diff = diff + numbers[j]\n\
    \    if diff < numbers[i] then closest[1] = j end\n    if diff > numbers[j] then\
    \ closest[#closest + 1] = i end\n  end\n  return closest\nend", "    local result\
    \ = {}\n    local i = 1\n    while i < #numbers and i < 2 do\n        local min_diff\
    \ = numbers[1] - numbers[i]\n        local j = 1\n        while j < #numbers and\
    \ min_diff > numbers[j] - numbers[i] do\n            local new_diff = numbers[1]\
    \ - numbers[j]\n            if new_diff < min_diff then\n                min_diff\
    \ = new_diff\n            end\n            j = j + 1\n        end\n        if\
    \ min_diff < 0 then\n            table.insert(result, numbers[i])\n          \
    \  table.insert(result, numbers[j])\n        else\n            table.insert(result,\
    \ numbers[j])\n            table.insert(result, numbers[i])\n        end\n   \
    \     i = i + 1\n    end\n    return result\nend", "  assert(#numbers > 1)\n \
    \ assert(numbers[1] <= numbers[#numbers])\n  local closest_to_1, closest_to_2\
    \ = numbers[1], numbers[1]\n  for i = 2, #numbers do\n    local difference = numbers[i]\
    \ - closest_to_1\n    if difference < closest_to_2 then -- smaller is closer\n\
    \      closest_to_2, closest_to_1 = closest_to_1, closest_to_2\n    else\n   \
    \   -- The next element is the closest\n      break\n    end\n  end\n  return\
    \ closest_to_1, closest_to_2\nend", "  -- Find two numbers from the list that\
    \ are the closest to each other.\n  -- Return them in order (smaller number, larger\
    \ number).\n  --\n  -- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n\
    \  -- 2.0\n  -- >>> find_closest_elements({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n  --\
    \ 2.2\n  local function close_element_num(index, number)\n    local closer = numbers[index]\n\
    \    if closer < number then return true end\n    local closer_index = math.abs(index\
    \ - 1)\n    if closer_index == 0 then\n      return true\n    end\n    local closer_index_next\
    \ = math.abs(index + 1)\n    if closer_index_next == numbers[#numbers] then\n\
    \      return true\n    end\n    local closer2 = numbers[closer_index]\n    if\
    \ closer2 < number then return true end\n    local closer2_index = math.abs(closer_index\
    \ - 1)\n    if closer2_index == 0 then\n      return true\n    end\n    local\
    \ closer2_index_next = math.abs(closer_index + 1)\n    if closer2_index_next ==\
    \ numbers[#numbers] then\n      return true\n    end\n    local closer3 = numbers[closer2_index]\n\
    \    if closer3 < number then return true end\n    local closer3_index = math.abs(closer2_index\
    \ - 1)\n    if closer3_index == 0 then\n      return true\n    end\n    local\
    \ closer3_index_next = math.abs(closer2_index + 1)\n    if closer3_index_next\
    \ == numbers[#numbers] then\n      return true\n    end\n    local closer4 = numbers[closer3_index]\n\
    \    if closer4 < number then return true end\n    local closer4_index = math.abs(closer3_index\
    \ - 1)\n    if closer4_index == 0 then\n      return true\n    end\n    local\
    \ closer4_index_next = math.abs(closer3_index + 1)\n    if closer4_index_next\
    \ == numbers[#numbers] then\n      return true\n    end\n    local closer5 = numbers[closer4_index]\n\
    \    if closer5 < number then return true end\n    local closer5_index = math.abs(closer4_index\
    \ - 1)\n    if closer5_index == 0 then\n      return true\n    end\n    local\
    \ closer5_index_next = math.abs(closer4_index + 1)\n    if closer5_index_next\
    \ == numbers[#numbers] then\n      return true\n    end\n    local closer6 = numbers[closer5_index]\n\
    \    if closer6 < number then return true end\n    local clo", "  if not numbers\
    \ then return {0, 1} end\n  local min_value = numbers[1]\n  local max_value =\
    \ numbers[2]\n  for i=3,#numbers do -- Search for min and max from current number.\n\
    \    if numbers[i] < min_value then\n      min_value = numbers[i]\n    end\n \
    \   if numbers[i] > max_value then\n      max_value = numbers[i]\n    end\n  end\n\
    \  if min_value < max_value then\n    local diffs = { [min_value] = max_value\
    \ }\n    for i=min_value+1, max_value do\n      diffs[i - min_value] = (i - min_value)\
    \ * (min_value - max_value)\n      -- Find the element closest to the current\
    \ max and the one closest to current min\n      local closest_element_number =\
    \ diffs[max_value - i]\n      if closest_element_number > 1 then\n        closest_element_number\
    \ = diffs[min_value - closest_element_number - 1]\n      end\n      return {closest_element_number,\
    \ i - closest_element_number}\n    end\n  else\n    local diffs = { [min_value]\
    \ = max_value }\n    for i=min_value+1, max_value do\n      diffs[i - min_value]\
    \ = (i - min_value) * (min_value - max_value)\n      local closest_element_number\
    \ = diffs[max_value - i]\n      local other_element_number = diffs[min_value -\
    \ closest_element_number - 1]\n      if other_element_number > 1 then\n      \
    \  closest_element_number = diffs[min_value - other_element_number - 1]\n    \
    \  end\n      return {closest_element_number, i - closest_element_number}\n  \
    \  end\n  end\nend", "  if #numbers < 2 then\n    return {numbers[1],numbers[1]}\n\
    \  end", "  if #numbers < 2 then\n    return numbers\n  end", "  local best_one,\
    \ best_two = nil, numbers\n  for i = 1, #numbers do\n    local two_best_one\n\
    \    for j = 1, #best_two do\n      local two_best_two\n      for k = 1, #best_one\
    \ do\n        local two_best_three\n        for l = 1, #best_two[best_two[best_two]\
    \ do\n          local two_best_four\n          for m = 1, #best_one[best_one[best_one]\
    \ do\n            local two_best_five\n            for n = 1, #best_two[best_two[best_two]\
    \ do\n              two_best_one = two_best_one or {}\n              two_best_two\
    \ = two_best_two or {}\n              two_best_three = two_best_three or {}\n\
    \              two_best_four = two_best_four or {}\n              two_best_five\
    \ = two_best_five or {}\n              two_best_one[#two_best_one + 1] = best_one[best_one][best_one][best_one][best_one][best_one][best_one][best_one][best_one][best_one]\n\
    \              two_best_two[#two_best_two + 1] = best_two[best_two][best_two][best_two][best_two][best_two][best_two][best_two][best_two][best_two]\n\
    \              two_best_three[#two_best_three + 1] = best_three[best_three][best_three][best_three][best_three][best_three][best_three][best_three][best_three][best_three]\n\
    \              two_best_four[#two_best_four + 1] = best_four[best_four][best_four][best_four][best_four][best_four][best_four][best_four][best_four][best_four]\n\
    \              two_best_five[#two_best_five + 1] = best_five[best_five][best_five][best_five][best_five][best_five][best_five][best_five][best_five][best_five]\n\
    \            end\n          end\n        end\n      end\n    end\n    best_one\
    \ = two_best_one\n    best_two = two_best_two\n  end\n  return best_one, best_two\n\
    end", "  local minimum = {}\n  local maximum = {}\n  for i = 1, #numbers do\n\
    \    minimum[i] = numbers[i]\n    maximum[i] = numbers[i]\n  end\n  table.sort(numbers)\n\
    \  local i = 1\n  while i <= #numbers do\n    local j = (i + 1) % #numbers\n \
    \   if numbers[i] < minimum[j] then\n      minimum[i] = minimum[j]\n    elseif\
    \ numbers[i] > maximum[j] then\n      maximum[i] = maximum[j]\n    end\n    i\
    \ = j\n  end\n  -- Return the closest two numbers as a list of pairs of values.\n\
    \  return minimum, maximum\nend", "  local min_diff\n  local min_element = numbers[1]\n\
    \  local max_element = numbers[#numbers]", "  local smallest_num = tonumber(numbers[1])\n\
    \  local biggest_num = tonumber(numbers[#numbers])\n  if smallest_num == biggest_num\
    \ then\n    return numbers\n  end\n  if smallest_num < biggest_num then\n    table.sort(numbers,\
    \ function(a, b) return (a - b) end)\n  else\n    table.sort(numbers, function(a,\
    \ b) return (b - a) end)\n  end\n  table.insert(numbers, biggest_num)\n  table.insert(numbers,\
    \ smallest_num)\n  return numbers\nend", "    local max_distance = math.abs(numbers[1])\n\
    \    local min_distance = math.abs(numbers[1])\n    local returning\n    for i\
    \ = 2, #numbers do\n        local distance = math.abs(numbers[i])\n        if\
    \ distance < max_distance then\n            min_distance = distance\n        \
    \    returning = numbers[i], numbers[i - 1]\n        elseif distance > max_distance\
    \ then\n            max_distance = distance\n            returning = numbers[i],\
    \ numbers[i - 1]\n        end\n    end\n    return returning\nend", '    if #numbers
    < 2 then return {nil, nil} end', "  local function distance(a, b, c)\n    return\
    \ math.sqrt(math.abs(a - b) ^ 2 + math.abs(b - c) ^ 2)\n  end\n  local function\
    \ find_closest(elements, value)\n    local smallest = 1\n    local index = #elements\n\
    \    while index > 1 do\n      local closest = element(elements[#elements] + smallest)\n\
    \      local current = elements[index]\n      if distance(current) > distance(closest,\
    \ value) then\n        index = #elements\n        smallest = elements[#elements]\
    \ + smallest\n      else\n        smallest = index\n      end\n    end\n    return\
    \ element(elements[#elements])\n  end\n  if #numbers == 1 then\n    return numbers[1]\n\
    \  else\n    return find_closest(numbers, numbers[1])\n  end\nend", "\tlocal min_diff\
    \ = math.abs(numbers[1] - numbers[2])\n\tlocal max_diff = math.abs(numbers[1]\
    \ - numbers[#numbers])\n\tfor i = 2, #numbers, 1 do\n\t\tlocal diff = math.abs(numbers[i]\
    \ - numbers[i - 1])\n\t\tif diff < min_diff then\n\t\t\tmin_diff = diff\n\t\t\
    end\n\t\tif diff > max_diff then\n\t\t\tmax_diff = diff\n\t\tend\n\tend\n\treturn\
    \ numbers[min_diff <= max_diff and 1 or #numbers]\nend", "    local mins = {}\n\
    \    local maxes = {}\n    for i = 1, #numbers do\n        table.insert(mins,\
    \ numbers[i])\n        table.insert(maxes, numbers[i])\n    end\n    table.sort(mins)\n\
    \    table.sort(maxes)", "  -- Get the smaller of the two numbers and a vector\
    \ from that point to the other\n  local closest_smaller = math.min(numbers)\n\
    \  local vector = table.remove(numbers, 1)", "    local closest_elements = {}\n\
    \    for _, num in pairs(numbers) do\n        local closest, distance = nil, nil\n\
    \        for _, num2 in pairs(numbers) do\n            if num2 ~= num then\n \
    \               local d = math.abs(num - num2)\n                if d < distance\
    \ then\n                    distance = d\n                    closest = num2\n\
    \                end\n            end\n        end\n        table.insert(closest_elements,\
    \ closest)\n    end\n    return closest_elements\nend", "  -- Create an array\
    \ of the minimum number and the maximum number in the supplied table\n  local\
    \ min_max = create_array(#numbers)\n  for i = 1, #numbers do\n    min_max[i] =\
    \ math.min(numbers[i], min_max[i])\n  end", "  local smaller, larger, smallest,\
    \ largest, index, middle\n  local function dist(one, other)\n    return math.abs(one\
    \ - other)\n  end\n  assert(#numbers >= 2)\n  smaller, larger = numbers[1], numbers[#numbers]\n\
    \  smallest, largest = smaller, larger\n  index = #numbers - 1\n  middle = (index\
    \ + 1) / 2.0\n  smaller, largest = numbers[middle], numbers[index]\n  smallest,\
    \ largest = smaller, largest\n  local done = false\n  repeat\n    if done then\n\
    \      break\n    end\n    smallest, largest, index = smallest, largest, index\
    \ - 1\n    if largest < smallest then\n      done = true\n      largest, smallest\
    \ = smallest, largest\n      largest, smallest = smaller, largest\n    end\n \
    \   if largest == smallest then\n      -- Return the number itself, since it is\
    \ within range.\n      largest, smaller, index = smaller, largest, index\n   \
    \ end\n  until not done\n  return largest, smaller\nend", "   local smallest,\
    \ smallest_index\n   local largest, largest_index\n   for i=1,#numbers do\n  \
    \    if numbers[i] < smallest then smallest = numbers[i] end\n      if numbers[i]\
    \ > largest then largest = numbers[i] end\n   end\n   if smallest < largest then\
    \ return { smallest, largest } end\n   smallest_index = #numbers + 1\n   largest\
    \ = smallest\n   for i=1,#numbers do\n      local index = (i + smallest_index)\
    \ / 2\n      if numbers[index] < smallest then smallest_index = index end\n  \
    \    if numbers[index] > largest then largest_index = index end\n   end\n   if\
    \ smallest == largest then largest = nil end\n   if smallest ~= largest then\n\
    \      local i = smallest_index\n      while i ~= largest_index do\n         if\
    \ numbers[i] ~= smallest and numbers[i] ~= largest then\n            return {\
    \ numbers[i], numbers[largest_index] }\n         end\n         i = i + ((largest_index\
    \ - smallest_index + 1) / 2)\n      end\n   end\nend", "    local sorted_numbers\
    \ = table.sort(numbers)\n    local closest = sorted_numbers[1]\n    for _, element\
    \ in ipairs(sorted_numbers) do\n        if element < closest then\n          \
    \  closest = element\n        end\n    end\n    return {sorted_numbers[1], closest}\n\
    end", "  local n = #numbers - 1\n  local closest, smaller, larger, current, closest2,\
    \ smaller2, larger2 = {}, {}, {}, {}, {}, {}, {}\n  for i = 1, n do\n    local\
    \ j = i + 1\n    local dist = math.abs(numbers[j] - numbers[i])\n    if i == 1\
    \ then\n      current = numbers[i]\n      closest[i] = numbers[i]\n      smaller[i]\
    \ = numbers[j]\n      larger[i] = current\n      closest2[i] = numbers[j]\n  \
    \    smaller2[i] = numbers[i]\n      larger2[i] = current\n    elseif dist < smallest\
    \ then\n      current = numbers[i]\n      closest[i] = numbers[j]\n      smaller[i]\
    \ = numbers[i]\n      larger[i] = current\n      closest2[i] = numbers[j]\n  \
    \    smaller2[i] = numbers[j]\n      larger2[i] = current\n    elseif dist < smallest\
    \ and current < numbers[j] then\n      current = numbers[i]\n      closest[i]\
    \ = numbers[j]\n      smaller[i] = numbers[i]\n      larger[i] = current\n   \
    \   closest2[i] = numbers[j]\n      smaller2[i] = numbers[j]\n      larger2[i]\
    \ = current\n    else\n      current = numbers[i]\n      closest[i] = numbers[j]\n\
    \      smaller[i] = numbers[j]\n      larger[i] = current\n      closest2[i] =\
    \ numbers[i]\n      smaller2[i] = numbers[i]\n      larger2[i] = current\n   \
    \ end\n  end\n  return { closest = closest, smaller = smaller, larger = larger\
    \ }\nend", "\tassert(#numbers >= 2)\n\tlocal closest = table.remove_by_ref(numbers,\
    \ 0)\n\tlocal closest2 = table.remove_by_ref(numbers, 0)\n\tfor i = 1, #numbers\
    \ do\n\t\tif numbers[i] < closest then\n\t\t\tclosest = numbers[i]\n\t\telseif\
    \ numbers[i] > closest2 then\n\t\t\tclosest2 = numbers[i]\n\t\tend\n\tend\n\t\
    return table.concat {closest2, closest}\nend", "  assert(#numbers > 2, 'Not enough\
    \ arguments')\n  assert(#numbers == 2 or #numbers == 3, 'Too many arguments')",
  "  local first_value = numbers[1]\n  local second_value = numbers[1]\n  -- If there\
    \ are two values, find which one is closest and return\n  if #numbers == 2 then\n\
    \    -- Take the smaller value and swap it with the second value\n    if numbers[1]\
    \ < numbers[2] then\n      first_value, second_value = second_value, first_value\n\
    \    end\n    -- Return them in order\n    return first_value, second_value\n\
    \  end\n  -- Iterate through each pair, find the smallest and largest numbers\
    \ in each\n  -- and return them in order\n  -- The first number is the smallest\
    \ and the second number is the largest\n  for i = 2, #numbers do\n    -- Compare\
    \ the first and the second number\n    if numbers[i] > second_value then\n   \
    \   -- Swap the values\n      second_value, first_value = first_value, second_value\n\
    \    end\n    -- If there are more values to compare, move on\n    if i ~= #numbers\
    \ then\n      -- Compare the last number with the next number\n      if numbers[i]\
    \ > second_value then\n        -- Swap the values\n        second_value, first_value\
    \ = first_value, second_value\n      end\n      -- If there are more values to\
    \ compare, move on\n      if i ~= #numbers then\n        -- Compare the first\
    \ and second number\n        if numbers[i] > second_value then\n          -- Swap\
    \ the values\n          second_value, first_value = first_value, second_value\n\
    \        end\n      end\n    end\n  end\n  -- Return them in order\n  return first_value,\
    \ second_value\nend", "  local smaller, larger = numbers.min, numbers.max\n  local\
    \ smaller_index = #numbers - 1\n  local larger_index = #numbers\n  while smaller_index\
    \ > 0 and larger_index > 0 do\n    local difference = numbers[smaller_index] -\
    \ numbers[larger_index]\n    if difference < 0 then\n      smaller_index = smaller_index\
    \ - 1\n    else\n      larger_index = larger_index - 1\n    end\n  end\n  if smaller_index\
    \ == 0 then\n    return {larger}\n  elseif larger_index == 0 then\n    return\
    \ {smaller}\n  end\n  local smaller_in_range = numbers[smaller_index] <= numbers[smaller_index\
    \ + 1]\n  local larger_in_range = numbers[larger_index] <= numbers[larger_index\
    \ + 1]\n  if smaller_in_range and larger_in_range then\n    return {smaller, larger}\n\
    \  elseif smaller_in_range then\n    return {smaller}\n  elseif larger_in_range\
    \ then\n    return {larger}\n  end\nend", "    assert(numbers[1])\n    local min_value\
    \ = numbers[1]\n    local max_value = numbers[1]\n    for i=1,#numbers do\n  \
    \      if numbers[i] < min_value then\n            min_value = numbers[i]\n  \
    \      end\n        if numbers[i] > max_value then\n            max_value = numbers[i]\n\
    \        end\n    end\n    return min_value, max_value\nend", "    local minimum\
    \ = nil\n    local maximum = nil", "  local pairs = pairs(numbers) -- Turn the\
    \ table of numbers in to a table of pairs\n  local distances = {}\n  local i =\
    \ 1\n  for pair in pairs do\n    distances[i] = math.abs(pair[1]-pair[2])\n  \
    \  i = i + 1\n  end\n  table.sort(distances, function(a,b) return a < b end)\n\
    \  local closest_pair = pairs[distances[#pairs]]\n  return closest_pair[1], closest_pair[2]\n\
    end", '  local closest = {}', "  assert(#numbers >= 2, 'find_closest_elements()\
    \ - received a table of length ' .. #numbers)\n  local min_value = numbers[1]\n\
    \  local max_value = numbers[#numbers]", "  local closest_numbers = {}\n  local\
    \ min_distance = math.min(numbers[1])\n  local max_distance = math.max(numbers[1])\n\
    \  local index = 2\n  while index <= #numbers and max_distance - min_distance\
    \ > 1e-5 do\n    local distance = abs(numbers[index] - min_distance)\n    if distance\
    \ < max_distance then\n      table.insert(closest_numbers, numbers[index])\n \
    \     max_distance = max_distance - distance\n    else\n      min_distance = min_distance\
    \ - distance\n      table.insert(closest_numbers, numbers[index])\n      max_distance\
    \ = math.max(min_distance, math.max(numbers[index]))\n    end\n    index = index\
    \ + 1\n  end\n  return closest_numbers\nend", "  if #numbers < 2 then return {nil,\
    \ nil} end\n  local min = numbers[1]\n  local max = numbers[#numbers]\n  for _,\
    \ v in pairs(numbers) do\n    if v ~= min and v ~= max then min = v end\n  end\n\
    \  local min_index = #numbers - 1\n  local min_value = numbers[min_index]\n  local\
    \ min_value = min or min_value\n  -- If the min value is equal to the max value,\
    \ return the min index and min value.\n  if min == max then return {min_index,\
    \ min_value} end\n  local mid_index = math.floor(#numbers / 2)\n  local mid_value\
    \ = numbers[mid_index]\n  -- If the middle value is equal to the max value, return\
    \ the middle index and middle value.\n  if mid_value == max then return {mid_index,\
    \ mid_value} end\n  -- Otherwise, return the middle value\n  local median = numbers[mid_index]\n\
    \  -- If the max value is greater than the min value, the median is the max value\n\
    \  if min > max then\n    median = max\n    -- If the max value is less than the\
    \ min value, the median is the min value\n  elseif min < max then\n    median\
    \ = min\n    -- If the min value is less than the median value, the median is\
    \ the middle value\n  else\n    median = mid_index\n  end\n  -- Return the median\
    \ and index of the median value\n  return { median, min_value }\nend", "    local\
    \ min_i, min_dist = math.inf, math.inf\n    for i=2,#numbers do\n        local\
    \ dist = math.abs(numbers[i]-numbers[min_i])\n        if dist < min_dist then\n\
    \            min_i, min_dist = i, dist\n        end\n    end\n    return numbers[min_i],\
    \ min_dist\nend", "\tlocal n1, n2 = #numbers, 2\n\tassert(n1 and n2)\n\tassert(n1\
    \ < n2)", "  assert(#numbers >= 2, \"find_closest_elements expects a table of\
    \ numbers (of length at least two).\")\n  local smallest = tonumber(numbers[1])\n\
    \  local largest = tonumber(numbers[1])\n  for i=2,#numbers do\n    local candidate\
    \ = tonumber(numbers[i])\n    smallest = (candidate < smallest) and candidate\
    \ or smallest -- smallest must always be smaller!\n    largest = (candidate >\
    \ largest) and candidate or largest -- largest must always be larger!\n  end\n\
    \  return smallest, largest\nend", "  local function min_distance(a, b) return\
    \ math.abs(a - b) end\n  local sorted_numbers = table.sort(numbers, min_distance)\n\
    \  local closest_numbers = table.rev()\n  local closest_number = sorted_numbers[1]\n\
    \  local closest_distance = sorted_numbers[1]", "  local smallest_value = nil\n\
    \  local second_value = nil", "\tlocal results = {}\n\tlocal smaller, larger =\
    \ numbers\n\twhile smaller ~= larger do\n\t\tlocal smaller_distance = math.sqrt(math.pow(smaller\
    \ - larger, 2))\n\t\tlocal larger_distance = math.sqrt(math.pow(larger - smaller,\
    \ 2))\n\t\tif smaller_distance < larger_distance then\n\t\t\ttable.insert(results,\
    \ smaller)\n\t\t\tsmaller = smaller\n\t\t\ttable.insert(results, larger)\n\t\t\
    else\n\t\t\ttable.insert(results, larger)\n\t\t\tsmaller = larger\n\t\t\ttable.insert(results,\
    \ smaller)\n\t\tend\n\tend\n\treturn results\nend", "  assert(#numbers >= 2)\n\
    \  local small = numbers[1]\n  local large = numbers[1]\n  local small_idx = 1\n\
    \  local large_idx = 1\n  local closest = nil", "  local min_distance = nil\n\
    \  local min_elements = {}\n  for i, v in ipairs(numbers) do\n    local d = math.abs(numbers[i+1]\
    \ - v)\n    if d < min_distance then\n      min_distance = d\n      min_elements\
    \ = {v, numbers[i+1]}\n    end\n  end\n  return min_elements\nend", "   assert(#numbers\
    \ >= 2)\n   local diff1 = math.abs(numbers[1] - numbers[2])\n   local diff2 =\
    \ math.abs(numbers[2] - numbers[3])\n   if diff1 < diff2 then\n      return numbers,\
    \ {numbers[1], numbers[2]}\n   else\n      return numbers, {numbers[2], numbers[3]}\n\
    \   end\nend", "  assert(#numbers >= 2, 'The numbers table is too short (size\
    \ must be at least two)')\n  local smallest, largest = numbers[1], numbers[#numbers]\n\
    \  for i = 2, #numbers do\n    local cur = numbers[i]\n    smallest = smallest\
    \ and math.min(cur, smallest)\n    largest = largest and math.max(cur, largest)\n\
    \  end\n  assert(smallest <= largest, 'The smallest and largest numbers in the\
    \ table must both be greater than the number')\n  assert(smallest > 0, 'The smallest\
    \ number in the table must be greater than zero')\n  return { smallest, largest\
    \ }\nend", "  -- Find the two closest numbers and return them.\n  local function\
    \ less_than(number1, number2)\n    local diff = number1 - number2\n    return\
    \ diff < 0\n  end\n  local minimum = numbers[1]\n  local maximum = numbers[1]\n\
    \  for _, value in pairs(numbers) do\n    if value < minimum then\n      minimum\
    \ = value\n    elseif value > maximum then\n      maximum = value\n    end\n \
    \ end", "  local results = {}\n  for i = 1, #numbers do\n    for j = 1, #results\
    \ do\n      local d = math.abs(numbers[i] - results[j])\n      if d < results[j+1]\
    \ then\n        results[j] = numbers[i]\n        results[j+1] = d\n      end\n\
    \    end\n  end\n  return results\nend", "  -- If there are no numbers return\
    \ a nil list\n  if not numbers or #numbers < 2 then return nil end", "  local\
    \ sorted_numbers = sort_numbers_by_value(numbers)\n  local closest = nil\n  local\
    \ closest_value = sorted_numbers[1][1]\n  for i = 2, #sorted_numbers do\n    local\
    \ this_value = sorted_numbers[i][1]\n    if this_value < closest_value then\n\
    \      closest = sorted_numbers[i - 1][1]\n      closest_value = this_value\n\
    \    elseif this_value > closest_value then\n      closest = this_value\n    end\n\
    \  end\n  return closest\nend", "  local smallest, largest = numbers[1], numbers[1]\n\
    \  for i = 2, #numbers do\n    smallest, largest = smallest, numbers[i] or\n \
    \     ((numbers[i] + largest) -- closest to i\n        or (numbers[i] + 1.0) --\
    \ larger than i\n        or (numbers[i] - 1.0) -- smaller than i\n        )\n\
    \  end\n  return table.sort(numbers, function(a, b) return a < b end)\nend", " \
    \ assert(#numbers > 2)\n  local closest, closed_at = nil, math.huge\n  for _,\
    \ _ in pairs(numbers) do\n    local next_closest, next_closed_at = numbers[#numbers],\
    \ numbers[#numbers]\n    local _, next_closed_at = numbers[#numbers], numbers[#numbers]\n\
    \    if closest ~= nil then\n      local next_closest\n      local dist, dir\n\
    \      local sign, dir\n      if next_closed_at > closest then\n        dist =\
    \ next_closed_at - closest\n        sign = 1\n      else\n        dist = closest\
    \ - next_closed_at\n        sign = -1\n      end\n      if dist <= 0.0 then\n\
    \        local next_closest\n        local dist, dir\n        if next_closed_at\
    \ < closest then\n          dist = closest - next_closed_at\n          dir = 1\n\
    \        else\n          dist = next_closed_at - closest\n          dir = -1\n\
    \        end\n        closest = -math.huge\n        closed_at = next_closed_at\n\
    \      elseif math.huge > dist then\n        closest = -math.huge\n        closed_at\
    \ = next_closed_at\n      else\n        closest = next_closest\n        closed_at\
    \ = next_closed_at\n      end\n      local new_closed_at\n      if math.huge >\
    \ dist then\n        new_closed_at = closest + sign * dir * math.abs(dist)\n \
    \     else\n        new_closed_at = closest - sign * dir * math.abs(dist)\n  \
    \    end\n      closest = (new_closed_at < closed_at) and new_closed_at or closed_at\n\
    \    end\n  end\n  return closest\nend", "  assert(numbers:size() >= 2, 'Invalid\
    \ input')\n  local smallest_num = tonumber(numbers[1]) or numbers[1]\n  local\
    \ biggest_num = tonumber(numbers[2]) or numbers[2]\n  local min_diff\n  for i\
    \ = 2, numbers:size() do\n    local diff = biggest_num - smallest_num\n    if\
    \ diff == 0 then\n      -- This is an equal number, so return it\n      return\
    \ {biggest_num, smallest_num}\n    elseif min_diff == nil then\n      -- This\
    \ is the smallest number, so save it\n      smallest_num = tonumber(numbers[i])\n\
    \      min_diff = diff\n    else\n      -- This is an equal number, so return\
    \ it\n      return {biggest_num, smallest_num}\n    end\n    biggest_num = tonumber(numbers[i])\n\
    \  end\n  -- This is what we return as the closest number\n  -- It should be the\
    \ smallest number if there are multiple equal numbers\n  if min_diff == 0 then\n\
    \    return { biggest_num, smallest_num }\n  else\n    return {smallest_num, biggest_num}\n\
    \  end\nend", "   local i = 1\n   local last_distance = 10^8\n   local result\
    \ = {}\n   while i < #numbers do\n      local distance = math.abs(numbers[i] -\
    \ numbers[i - 1])\n      if distance < last_distance then\n         table.insert(result,\
    \ numbers[i])\n      else\n         local nearest = numbers[i]\n         for j\
    \ = 1, #numbers - 1 do\n            local other_distance = math.abs(numbers[j]\
    \ - nearest)\n            if other_distance < distance then\n               nearest\
    \ = numbers[j]\n            end\n         end\n         table.insert(result, nearest)\n\
    \      end\n      i = i + 1\n      last_distance = distance\n   end\n   return\
    \ result\nend\nreturn find_closest_elements", "  local min = nil\n  local max\
    \ = nil\n  for i=1,#numbers do\n    if min == nil then\n      min = numbers[i]\n\
    \    elseif numbers[i] < min then\n      min = numbers[i]\n    end\n    if max\
    \ == nil then\n      max = numbers[i]\n    elseif numbers[i] > max then\n    \
    \  max = numbers[i]\n    end\n  end\n  table.sort(numbers)\n  return min, max\n\
    end", "  local largest = numbers[1]\n  local smallest = numbers[1]\n  local found\
    \ = {}\n  for i = 1, #numbers do\n    if numbers[i] > largest then\n      largest\
    \ = numbers[i]\n    end\n    if numbers[i] < smallest then\n      smallest = numbers[i]\n\
    \    end\n    table.insert(found, numbers[i])\n  end\n  return largest, smallest,\
    \ found\nend", "  local min_distance = sys.maxfloat\n  local min_distance = numbers[1]\n\
    \  for i = 2, #numbers do\n    local distance = numbers[i] - numbers[i - 1]\n\
    \    if distance < min_distance then\n      min_distance = distance\n    end\n\
    \  end\n  return min_distance\nend", "   local smallest = numbers[1]\n   local\
    \ largest = numbers[1]\n   local i = 1\n   for v in pairs(numbers) do\n      if\
    \ v < smallest then\n         smallest = v\n      elseif v > largest then\n  \
    \       largest = v\n      else\n         i = i + 1\n      end\n   end", "  --\
    \ First find the closest number.\n  local closest = nil\n  for _, value in ipairs(numbers)\
    \ do\n    if closest == nil then\n      closest = value\n    else\n      local\
    \ distance\n      distance = math.abs(value - closest)\n      if distance < math.abs(value\
    \ - closest) then\n        closest = value\n      end\n    end\n  end", "    local\
    \ smallest = nil\n    local largest = nil\n    for _, element in ipairs(numbers)\
    \ do\n        if smallest == nil then\n            smallest = element\n      \
    \      largest = element\n        elseif element < smallest then\n           \
    \ smallest = element\n        elseif element > largest then\n            largest\
    \ = element\n        end\n    end\n    return largest, smallest\nend", "  local\
    \ closest = numbers[1]\n  local result = {}", "    -- Sort is cheaper than binary\
    \ search so do it first.\n    table.sort(numbers)", "    local min_distance =\
    \ math.inf\n    local best_elements = {}\n    local num_elements = #numbers -\
    \ 1\n    for i = 1, num_elements do\n        local distance = math.sqrt(numbers[i]\
    \ * numbers[i] + numbers[i + 1] * numbers[i + 1])\n        if distance < min_distance\
    \ then\n            min_distance = distance\n            best_elements = {numbers[i],\
    \ numbers[i + 1]}\n        end\n    end\n    return best_elements\nend", "\tlocal\
    \ min_val = numbers[1]\n\tlocal max_val = numbers[1]\n\tlocal min_dist = math.pow(10,\
    \ 6)\n\tlocal min_elem = 1\n\tfor i = 2, #numbers do\n\t\tlocal val = numbers[i]\n\
    \t\tlocal dist = math.abs(val - min_val)\n\t\tif dist < min_dist then\n\t\t\t\
    min_val = val\n\t\t\tmin_dist = dist\n\t\t\tmin_elem = i\n\t\telseif dist == min_dist\
    \ then\n\t\t\tif val > min_val then\n\t\t\t\tmin_val = val\n\t\t\t\tmin_elem =\
    \ i\n\t\t\tend\n\t\tend\n\tend\n\treturn {numbers[min_elem], min_val}\nend", " \
    \   local lowest = numbers[1]\n    local largest = numbers[#numbers]\n    local\
    \ i = 1\n    while i < #numbers do\n        local number = numbers[i]\n      \
    \  if number < smallest then smallest = number end\n        if number > largest\
    \ then largest = number end\n        i = i + 1\n    end\n    return largest, smallest\n\
    end", "    local mins = {}\n    local maxs = {}\n    for _, num in ipairs(numbers)\
    \ do\n        mins[num] = nil\n        maxs[num] = nil\n    end", "    assert(#numbers\
    \ > 2, 'find_closest_elements() - table of numbers must be of length >= 2')\n\
    \    assert(type(numbers[1]) == 'number', 'find_closest_elements() - numbers list\
    \ must be a list of numbers')\n    local sorted_numbers = table.sort(numbers)\n\
    \    local closest_index = 1\n    local closest_value = sorted_numbers[1]\n  \
    \  for i = 2, #sorted_numbers do\n        -- The absolute difference between the\
    \ two numbers\n        local difference = sorted_numbers[i] - closest_value\n\
    \        if difference < 0 then\n            -- If the difference between the\
    \ two numbers is a negative one,\n            -- swap them and iterate to the\
    \ right to compare the two numbers,\n            -- and so on.\n            closest_value\
    \ = sorted_numbers[i]\n            closest_index = i\n        else\n         \
    \   -- If the difference between the two numbers is not negative,\n          \
    \  -- compare them to each other and find the smallest difference.\n         \
    \   local smallest_difference = difference\n            local closest_value =\
    \ sorted_numbers[i]\n            -- The index of the smallest difference (closest)\n\
    \            for j = 1, #sorted_numbers do\n                local difference =\
    \ sorted_numbers[j] - closest_value\n                if difference < smallest_difference\
    \ then\n                    smallest_difference = difference\n               \
    \     closest_value = sorted_numbers[j]\n                    closest_index = j\n\
    \                end\n            end\n            closest_index = closest_index\
    \ - 1\n            closest_value = sorted_numbers[closest_index]\n        end\n\
    \    end\n    return {sorted_numbers[closest_index], sorted_numbers[#sorted_numbers]}\n\
    end", "  if #numbers == 1 then return numbers end\n  local smaller, larger = {},\
    \ {}\n  local i = 0\n  local j = 1\n  local closest_distance = nil\n  while i\
    \ < #numbers and j < #numbers do\n    local distance = numbers[i] - numbers[j]\n\
    \    if not closest_distance or distance < closest_distance then\n      smaller[i]\
    \ = numbers[i]\n      larger[j] = numbers[j]\n      closest_distance = distance\n\
    \    else\n      larger[j] = numbers[j]\n    end\n    i = i + 1\n    j = j + 1\n\
    \  end\n  return smaller, larger\nend", "  if not numbers then\n    return false\n\
    \  end\n  assert(#numbers > 0, 'Number of numbers is zero!')\n  local max,min\
    \ = numbers[1],numbers[1]\n  for i = 2, #numbers do\n    if numbers[i] < min then\n\
    \      max = numbers[i]\n      min = numbers[i]\n    elseif numbers[i] > max then\n\
    \      max = numbers[i]\n    end\n  end\n  table.insert(numbers,max)\n  table.insert(numbers,min)\n\
    \  return numbers\nend", "  assert(#numbers >= 2)\n  local best_value = numbers[1]\n\
    \  local best_index = 1\n  for i = 2, #numbers do\n    if numbers[i] ~= best_value\
    \ then\n      local distance = math.abs(best_value - numbers[i])\n      if distance\
    \ < best_value then\n        best_value = distance\n        best_index = i\n \
    \     end\n    end\n  end\n  return numbers[best_index, best_index]\nend", " \
    \ local min = numbers[1]\n  local max = numbers[#numbers]\n  local index = 1\n\
    \  for i = 1, #numbers do\n    -- if we've found a new min or max, then exit early\n\
    \    if min > numbers[i] or max < numbers[i] then\n      min = numbers[index]\n\
    \      max = numbers[i]\n      index = 1\n      break\n    end\n    -- otherwise\
    \ keep incrementing the index until we find one that\n    -- isn't greater than\
    \ the current min or smaller than the current max.\n    -- this way, if we found\
    \ a new min or max already, we can update\n    -- that as we iterate through the\
    \ rest of the numbers\n    index = index + 1\n  end\n  -- if we don't find the\
    \ requested numbers, then return nil\n  return index and {min, max}\nend", " \
    \   local n = table.getn(numbers)\n    local result = {}\n    for i = 1, n do\n\
    \        local closest, closest2 = math.abs(numbers[i] - numbers[i - 1]), math.abs(numbers[i]\
    \ - numbers[i + 1])\n        if closest2 < closest then\n            closest,\
    \ closest2 = closest2, closest\n        end\n        result[i] = closest\n   \
    \ end\n    if n >= 2 then\n        for i = n - 1, 1, -1 do\n            result[i],\
    \ result[i + 1] = result[i + 1], result[i]\n        end\n    end\n    return result\n\
    end", "  local min = numbers[1]\n  local max = numbers[1]", "  local smallest,\
    \ largest = numbers[1], numbers[2]\n  local numbers_to_sort = {}\n  local i =\
    \ 0\n  while i < #numbers do\n    local element = numbers[i]\n    if element <\
    \ smallest then\n      smallest = element\n      numbers_to_sort[1] = element\n\
    \    elseif element > largest then\n      largest = element\n      numbers_to_sort[2]\
    \ = element\n    end\n    i = i + 1\n  end\n  return numbers_to_sort\nend", " \
    \ -- Get the minimum and maximum values in numbers.\n  local minValue, maxValue\
    \ = unpack(table.sort(numbers, function(a,b) return a < b end))\n  -- Return the\
    \ elements in numbers, sorted by distance from minValue.\n  return table.sort(numbers,\
    \ function(v) \n    return math.abs(v - minValue) \n  end)\nend", "\tlocal smallest_number\
    \ = numbers[1]\n\tlocal largest_number = numbers[2]\n\tfor _, number in ipairs(numbers)\
    \ do\n\t\tif number > largest_number then\n\t\t\tlargest_number = number\n\t\t\
    elseif number < smallest_number then\n\t\t\tsmallest_number = number\n\t\telse\n\
    \t\t\tbreak\n\t\tend\n\tend\n\treturn smallest_number, largest_number\nend", " \
    \  local min_num  = numbers[1]\n   local max_num  = numbers[#numbers]", "  --\
    \ Initialize table\n  local minimums = table.Copy(numbers)\n  -- Calculate differences\
    \ between consecutive pairs of elements\n  for idx = 1, #numbers - 1 do\n    minimums[idx]\
    \ = (numbers[idx] + minimums[idx - 1]) / 2.0\n  end\n  -- Find the first two elements\
    \ which differ by less than half the difference between subsequent pairs of elements\n\
    \  local first_two_closest, second_two_closest\n  for idx = 2, #minimums do\n\
    \    if minimums[idx] - minimums[idx - 1] < minimums[idx+1] - minimums[idx] then\n\
    \      first_two_closest = idx\n      break\n    end\n  end\n  return minimums,\
    \ first_two_closest, second_two_closest\nend", "   if #numbers < 2 then return\
    \ {nil, nil} end\n   local function min_func(lhs, rhs)\n      if lhs < rhs then\
    \ return lhs end\n      return rhs\n   end\n   local min_value = numbers[1]\n\
    \   local max_value = numbers[1]\n   for i = 2, #numbers do\n      if numbers[i]\
    \ < min_value then\n         min_value = numbers[i]\n      elseif numbers[i] >\
    \ max_value then\n         max_value = numbers[i]\n      else\n         return\
    \ numbers\n      end\n   end\n   return {min_value, max_value}\nend", "  assert(#numbers\
    \ > 1, 'At least two numbers are required')\n  -- Sort our numbers so we can do\
    \ binary search easier\n  table.sort(numbers)\n  local start = 1\n  local end\
    \ = #numbers - 1", "  return coroutine.wrap(function()\n    local smallest, largest\
    \ = unpack(numbers)\n    if smallest > largest then\n      return nil, nil\n \
    \   end\n    local function findClosestElementsHelper(first, middle, largest)\n\
    \      if smallest < middle then\n        return smallest, middle\n      elseif\
    \ middle < largest then\n        return middle, largest\n      else\n        return\
    \ nil\n      end\n    end\n    local function findClosestElementsHelper(first,\
    \ middle, largest)\n      if smallest < middle then\n        return smallest,\
    \ middle\n      elseif middle < largest then\n        return middle, largest\n\
    \      else\n        return nil\n      end\n    end\n    local function findClosestElementsHelper(first,\
    \ middle, largest)\n      if smallest < middle then\n        return smallest,\
    \ middle\n      elseif middle < largest then\n        return middle, largest\n\
    \      else\n        return nil\n      end\n    end\n    coroutine.resume(coroutine.create(findClosestElementsHelper,\
    \ smallest, largest))\n  end)\nend", "  if #numbers < 2 then return {nil, nil}\
    \ end\n  local max_diff = 0\n  local min_diff = #numbers - 1\n  while min_diff\
    \ > 0 do\n    -- Calculate the smallest change to each of our elements (and add\
    \ it to the largest change)\n    max_diff = max_diff + numbers[min_diff] - numbers[min_diff\
    \ - 1]\n    min_diff = min_diff - 1", "  assert(numbers[1])\n  local function\
    \ distance(a,b)\n    return a:distance(b)\n  end\n  table.sort(numbers, distance)\n\
    \  assert(numbers[1])\n  return numbers[1]\nend", "  local min1, min2 = numbers[1],\
    \ numbers[1]\n  for i = 2, #numbers do\n    local d = math.sqrt(math.pow(numbers[i]\
    \ - min1, 2) + math.pow(numbers[i] - min2, 2))\n    if d < min1 then min1 = d\
    \ end\n    if d > min2 then min2 = d end\n  end\n  return min1, min2\nend", '    assert(#numbers
    >= 2)', "    local result = {}\n    local minimum = nil\n    local maximum = nil",
  "  local smallest = numbers[1]\n  local largest = numbers[1]\n  for i = 2, #numbers\
    \ do\n    local diff = largest-smallest\n    if numbers[i] < smallest then\n \
    \     largest = numbers[i]\n    elseif numbers[i] > largest then\n      smallest\
    \ = numbers[i]\n    end\n  end\n  local diff2 = largest-smallest\n  if diff2 <\
    \ 1e-9 then\n    return {smallest, largest}\n  else\n    return {smallest, largest}\n\
    \  end\nend", "    local closest_numbers = {}\n    local current_number\n    local\
    \ current_distance\n    for i, number in ipairs(numbers) do\n        -- Calculate\
    \ the distance between current and all previous numbers, update it if closer than\
    \ before.\n        current_distance = numbers[1]\n        for _, next_number in\
    \ ipairs(numbers) do\n            if next_number - number < current_distance then\n\
    \                current_distance = next_number - number\n                current_number\
    \ = next_number\n            end\n        end\n        -- Add the current number\
    \ to the table.\n        table.insert(closest_numbers, current_number)\n    end\n\
    \    -- Return the closest numbers in order (smaller number, larger number)\n\
    \    return table.sort(closest_numbers)\nend", "    assert(#numbers > 0)\n   \
    \ local min_index = 1\n    local min = numbers[1]\n    for i = 2, #numbers do\n\
    \        local current_number = numbers[i]\n        if current_number > min then\n\
    \            min_index = i\n            min = current_number\n        end\n  \
    \  end\n    return {numbers[min_index], numbers[#numbers]}\nend", '  assert(#numbers
    > 1)', "\tlocal closest_number = nil\n\tlocal closest_number_distance = nil\n\t\
    local closest = nil\n\tlocal number_length = #numbers\n\tfor i = 1, number_length\
    \ do\n\t\tlocal number = numbers[i]\n\t\tif closest_number ~= nil and closest_number_distance\
    \ ~= nil then\n\t\t\t-- compare numbers to each other\n\t\t\tif closest_number_distance\
    \ > math.sqrt(number * number - closest_number * closest_number) then\n\t\t\t\t\
    closest_number = number\n\t\t\t\tclosest_number_distance = math.sqrt(number *\
    \ number - closest_number * closest_number)\n\t\t\telseif closest_number_distance\
    \ < math.sqrt(number * number - closest_number * closest_number) then\n\t\t\t\t\
    closest_number = number\n\t\t\t\tclosest_number_distance = math.sqrt(number *\
    \ number - closest_number * closest_number)\n\t\t\telse\n\t\t\t\t-- numbers are\
    \ equal - keep comparing\n\t\t\t\tclosest_number = number\n\t\t\t\tclosest_number_distance\
    \ = math.sqrt(number * number - closest_number * closest_number)\n\t\t\tend\n\t\
    \telse\n\t\t\t-- numbers are equal - keep comparing\n\t\t\tclosest_number = number\n\
    \t\t\tclosest_number_distance = math.sqrt(number * number - closest_number * closest_number)\n\
    \t\tend\n\tend\n\tif closest_number ~= nil then\n\t\tclosest = {closest_number,\
    \ closest_number_distance}\n\tend\n\treturn closest\nend", "    local smallest_number\
    \ = numbers[1]\n    local largest_number = numbers[1]\n    for i = 2, #numbers\
    \ do\n        if numbers[i] < smallest_number then\n            smallest_number\
    \ = numbers[i]\n        elseif numbers[i] > largest_number then\n            largest_number\
    \ = numbers[i]\n        else\n            table.insert(numbers, numbers[i])\n\
    \        end\n    end\n    table.sort(numbers)\n    return table.unpack(numbers)\n\
    end", "  local function sort_distance(number)\n    -- If the number is outside\
    \ the range [-1,1]\n    if number < -1 or number > 1 then\n      return nil, nil\n\
    \    end\n    -- If the number is within the range [-1..1] just return the number\n\
    \    local function inner_distance(number)\n      if number < -1 or number > 1\
    \ then\n        return number\n      end\n      return math.abs(number - 1)\n\
    \    end\n    -- Return the distance between the number and the number in the\
    \ range\n    -- (-1..1) and the closest to the number in the range\n    -- [-1..1]\n\
    \    return inner_distance(number), inner_distance(numbers - number)\n  end\n\
    \  -- Sort the given numbers and return the two that are closest\n  local result\
    \ = {}\n  table.sort(numbers, sort_distance)\n  table.insert(result, numbers[1],\
    \ numbers[1])\n  table.insert(result, numbers[#numbers], numbers[#numbers])\n\
    \  return result\nend", "  -- Make sure that we actually have at least two numbers\
    \ to compare.\n  if #numbers < 2 then\n    -- Return an empty set.\n    return\
    \ setmetatable({}, { __index = function(t, k) error(\"Table must have at least\
    \ two elements\", 2) end })\n  end\n  -- Get the smallest two numbers.\n  local\
    \ min1, min2 = unpack(numbers)\n  -- Get the largest two numbers.\n  local max1,\
    \ max2 = numbers[#numbers], numbers[#numbers]\n  -- Iterate through the elements\
    \ and add the new elements to the table.\n  -- If their distance is smaller than\
    \ their previous, change them both.\n  for i = 1, #numbers-1 do\n    -- Get the\
    \ current number. \n    local current_number = numbers[i]\n    -- Get the previous\
    \ number\n    local previous_number = numbers[i+1]\n    -- Get the absolute value\
    \ of the current number to the previous.\n    local current_abs_diff = abs(current_number\
    \ - previous_number)\n    -- If the current number is closer to previous, update\
    \ them.\n    if current_abs_diff < min1 then\n      min2 = min1\n      min1 =\
    \ current_abs_diff\n    elseif current_abs_diff > max1 then\n      max2 = max1\n\
    \      max1 = current_abs_diff\n    end\n    -- We only care about comparing numbers\
    \ that are greater than the previous number. \n    -- Therefore, if this number\
    \ is not greater than the previous number, skip it.\n    if current_number > previous_number\
    \ then\n      continue\n    end\n    -- Add the new number to the table.\n   \
    \ table.insert(numbers, current_number)\n  end\n  -- Return the table.\n  return\
    \ setmetatable({ min1, min2, max1, max2 }, { __index = function(t, k) error(\"\
    Table has missing elements\", 2) end })\nend", "  local smallest, smallest --\
    \ the two numbers with the smallest difference\n  local difference, smallest --\
    \ the difference between those two numbers, and the number with the smallest difference\n\
    \  for _, x in ipairs(numbers) do\n    if smallest == nil or x - smallest < difference\
    \ then\n      difference = x - smallest\n      smallest = x\n    else -- if we\
    \ haven't seen the smallest number yet, check if this new one will make it smaller\n\
    \      if x - smallest < difference then\n        difference = x - smallest\n\
    \        smallest = x\n      end\n    end\n  end\n  return smallest, smallest\n\
    end", "  local results = {}\n  local n = #numbers\n  if n == 0 then\n    return\
    \ results\n  end\n  if n == 1 then\n    table.insert(results, numbers[1])\n  \
    \  return results\n  end", "  local min_diff = math.min(numbers[1])\n  local best_pair\
    \ = nil\n  local num_pairs = 1\n  for i = 2, #numbers do\n    local diff = math.abs(numbers[i]\
    \ - min_diff)\n    if diff < best_diff then\n      num_pairs = num_pairs + 1\n\
    \      best_diff = diff\n      best_pair = i\n    end\n  end\n  table.sort(numbers,\
    \ function(a, b)\n    return math.abs(b - a) < math.abs(min_diff - b)\n  end)\n\
    \  return numbers[best_pair], numbers[num_pairs]\nend", "  local min_value = numbers[1]\n\
    \  local max_value = numbers[1]\n  for i = 2, #numbers do\n    if numbers[i] <\
    \ min_value then\n      min_value = numbers[i]\n    end\n    if numbers[i] > max_value\
    \ then\n      max_value = numbers[i]\n    end\n  end\n  if min_value < max_value\
    \ then\n    return table.remove(numbers, 1, #numbers)\n  else\n    return table.remove(numbers,\
    \ 1, #numbers)\n  end\nend", "  assert(#numbers >= 2, 'Table must have at least\
    \ two elements')\n  local smallest, smallest -- These will be the closer of the\
    \ two elements\n  local largest, largest -- These will be the further", "   assert(#numbers\
    \ >= 2, 'need at least two numbers for closest pair computation')\n   local first_number,\
    \ last_number, closest_numbers = numbers[1], numbers[2], {}\n   for i = 2, #numbers\
    \ do\n      local number = numbers[i]\n      if number < first_number then\n \
    \        first_number = number\n      elseif number > last_number then\n     \
    \    last_number = number\n      else\n         closest_numbers[#closest_numbers\
    \ + 1] = number\n      end\n   end\n   return closest_numbers, first_number, last_number\n\
    end", "    local min1, max1 = numbers[1], numbers[#numbers]\n    local min2, max2\
    \ = numbers[#numbers], numbers[1]\n    if min1 > max2 then\n        min2, max2\
    \ = min1, max1\n    end\n    if min2 ~= min1 then\n        min2, max2 = min1,\
    \ min2\n    end\n    if max2 ~= max1 then\n        min2, max2 = max1, max2\n \
    \   end\n    if min1 < min2 then\n        min2, min1 = min1, min2\n    end\n \
    \   if max1 > max2 then\n        max2, max1 = max1, max2\n    end\n    local min1\
    \ = min1 * -1\n    local min2 = min2 * -1\n    local max1 = max1 * -1\n    local\
    \ max2 = max2 * -1\n    local table = {}\n    for i = 1, #numbers do\n       \
    \ table.insert(table, numbers[i])\n    end\n    return table\nend\ntable.insertall\
    \ = table.insert\nreturn { find_closest_elements = find_closest_elements }\nend",
  "\t-- Return smallest number and the next smallest number in order\n\t-- >>> find_closest_elements({1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2})\n\t-- {1.0, 2.0}\n\t-- >>> find_closest_elements({1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0})\n\t-- {1.0, 2.0}", "   local closest, closest_length\
    \ = nil, 0\n   local length = #numbers\n   local index = math.random(1, length)\n\
    \   while true do\n      if length < 2 then\n         return nil\n      end\n\
    \      local el = numbers[index]\n      local prev_el = numbers[index - 1]\n \
    \     if el == prev_el then\n         -- Same element, skip it\n         index\
    \ = index + 1\n         if index == length then\n            -- We are at the\
    \ end of the array, return the final one\n            return el\n         else\n\
    \            -- Try again\n            continue\n         end\n      elseif el\
    \ > prev_el then\n         -- Need to swap the elements\n         local tmp =\
    \ el\n         el = prev_el\n         prev_el = tmp\n      else\n         -- Nothing\
    \ left to do on this pass, move on\n         break\n      end\n      -- Keep adding\
    \ this element until the list is sorted\n      closest_length = closest_length\
    \ + 1\n      if closest_length < length then\n         closest[closest_length]\
    \ = el\n      else\n         -- The list is sorted, return the smallest two\n\
    \         return closest\n      end\n   end\nend", '  assert(#numbers >= 2)',
  "    local closest = nil\n    local close_index = nil\n    local last_close_index\
    \ = nil\n    for i = 1, #numbers do\n        if numbers[i] < numbers[close_index]\
    \ then\n            closest = numbers[i]\n            close_index = i\n      \
    \      last_close_index = i\n        elseif numbers[i] < numbers[last_close_index]\
    \ then\n            last_close_index = i\n        end\n    end", '  assert(#numbers
    > 1, "The function requires at least two elements")', "  return function(num)\n\
    \    local smallest = numbers[1]\n    local largest = numbers[#numbers]\n    \n\
    \    if num < smallest then\n      largest = num\n    end\n    \n    if num >\
    \ largest then\n      smallest = num\n    end\n    \n    if smallest > largest\
    \ then\n      table.insert(numbers, smallest)\n      table.insert(numbers, largest)\n\
    \    end\n    \n    return largest\n  end\nend", "    local closest_numbers =\
    \ {}\n    local min_number = numbers[1]\n    local max_number = numbers[1]\n \
    \   for i=2,#numbers do\n        local current_number = numbers[i]\n        if\
    \ current_number < min_number then\n            min_number = current_number\n\
    \        elseif current_number > max_number then\n            max_number = current_number\n\
    \        elseif i == 1 then\n            -- Ignore anything larger than the smallest\n\
    \            -- number, and anything smaller than the largest\n            table.insert(closest_numbers,\
    \ current_number)\n        else\n            -- If we've found a new minimum,\
    \ insert the previous\n            -- largest number\n            -- into the\
    \ list at it's correct position\n            if current_number < min_number then\n\
    \                table.insert(closest_numbers, max_number)\n                min_number\
    \ = current_number\n            elseif current_number > max_number then\n    \
    \            table.insert(closest_numbers, min_number)\n                max_number\
    \ = current_number\n            else\n                -- Insert the current number\
    \ into the list at the\n                -- correct position\n                table.insert(closest_numbers,\
    \ current_number)\n            end\n        end\n    end\n    table.insert(closest_numbers,\
    \ max_number)\n    return closest_numbers\nend", "    local smallest, largest\
    \ = numbers[1], numbers[#numbers]\n    local minimum = largest\n    for i = 2,\
    \ #numbers do\n        local cur = numbers[i]\n        if cur < smallest then\n\
    \            smallest = cur\n        elseif cur > largest then\n            largest\
    \ = cur\n        else\n            if smallest < minimum then\n              \
    \  minimum = cur\n            end\n        end\n    end\n    return largest, smallest\n\
    end", "  if not table_len(numbers) then\n    return nil, nil\n  end\n  local minimum\
    \ = numbers[1]\n  local maximum = numbers[table_len(numbers)+1]\n  for _,v in\
    \ pairs(numbers) do\n    if minimum > v then\n      minimum = v\n    end\n   \
    \ if maximum < v then\n      maximum = v\n    end\n  end\n  return minimum, maximum\n\
    end", "\tlocal closest_elements = {}\n\tlocal min_difference = nil\n\tlocal max_difference\
    \ = nil", "    local min, max = numbers[1], numbers[1]\n    for i = 2, #numbers\
    \ do\n        if min > numbers[i] then\n            min = numbers[i]\n       \
    \ end\n        if max < numbers[i] then\n            max = numbers[i]\n      \
    \  end\n    end\n    table.sort(numbers)\n    return min, max\nend", "  local\
    \ min_x = nil\n  local min_y = nil\n  for i = 1, #numbers do\n    -- First try\
    \ the current number\n    local x = numbers[i]\n    local min_x_found = nil\n\
    \    local min_y_found = nil\n    for j = 1, #numbers do\n      -- Now search\
    \ the rest of the table\n      local y = numbers[j]\n      if x > y then\n   \
    \     -- The current number is closer to x than y\n        if min_x == nil then\n\
    \          min_x = x\n          min_x_found = j\n        elseif min_x_found ~=\
    \ nil then\n          -- But we don't need to search further\n          break\n\
    \        end\n      elseif x == y then\n        -- The current number is equally\
    \ close to each other\n        if min_x_found ~= nil then\n          min_y = y\n\
    \          min_y_found = j\n        end\n      else\n        -- The current number\
    \ is closer to y than x\n        if min_y == nil then\n          min_y = y\n \
    \         min_y_found = j\n        elseif min_y_found ~= nil then\n          --\
    \ But we don't need to search further\n          break\n        end\n      end\n\
    \    end\n    if min_x_found ~= nil then\n      -- The current number is the closest\
    \ to x, so store it\n      table.insert(numbers, min_x_found, min_y_found)\n \
    \     -- Remove the found number from the rest of the table since we've found\
    \ a closer one\n      table.remove_by_index(numbers, min_x_found)\n      table.remove_by_index(numbers,\
    \ min_y_found)\n      -- Stop searching the rest of the table since we've found\
    \ a closer one\n      break\n    end\n  end\n  -- Return the found numbers\n \
    \ return table.unpack(numbers, 1, #numbers)\nend", "  local closest_elements,\
    \ smallest_index, largest_index, min_difference\n  local last_smallest, last_largest\
    \ = numbers[1], numbers[1]", "  local closest_so_far = {}\n  local closest_so_far_length\
    \ = -1\n  local closest_element = nil\n  local smallest_distance = math.inf",
  "  local closest1\n  local closest2\n  local closest_idx1\n  local closest_idx2\n\
    \  local min_value\n  local max_value\n  for idx, v in pairs(numbers) do\n   \
    \ min_value = v\n    max_value = v\n    closest1 = closest2 or v\n    closest2\
    \ = v\n    closest_idx1 = closest_idx2 or idx\n    closest_idx2 = idx\n    if\
    \ v < closest1 then\n      closest1 = v\n      closest_idx1 = idx\n    end\n \
    \   if v > closest2 then\n      closest2 = v\n      closest_idx2 = idx\n    end\n\
    \  end\n  if closest2 == closest1 then\n    return closest1, closest2\n  end\n\
    \  if min_value < closest1 then\n    closest1 = min_value\n    closest_idx1 =\
    \ closest_idx2\n  end\n  if max_value > closest2 then\n    closest2 = max_value\n\
    \    closest_idx2 = closest_idx1\n  end\n  if closest1 < closest2 then\n    return\
    \ closest1, closest2\n  end\n  return closest2, closest1\nend", "  local smallest,\
    \ largest = numbers.min, numbers.max\n  local returnVal = {smallest, largest}",
  "  if #numbers <= 1 then\n    return {numbers[1]}\n  end\n  local min_dist = numbers[1]\n\
    \  local min_idx = 1\n  for i = 2, #numbers do\n    local dist = math.abs(numbers[i]\
    \ - numbers[min_idx])\n    if dist < min_dist then\n      min_dist = dist\n  \
    \    min_idx = i\n    end\n  end\n  local ret = {numbers[min_idx], numbers[min_idx]}\n\
    \  if min_idx == #numbers - 1 then\n    ret.table.sort(function(a, b)\n      return\
    \ a - b\n    end)\n  end\n  return ret\nend", "  assert(#numbers > 1)\n  local\
    \ min0, min1 = table.unpack(numbers:select(1, 1))\n  local min2, min3 = table.unpack(numbers:select(2,\
    \ 1))\n  local min4, min5 = table.unpack(numbers:select(3, 1))", "    local closest_elements\
    \ = {}\n    local min_distance = nil\n    local min_distance_element\n    local\
    \ min_distance_element_index\n    for _, element_index in ipairs(numbers) do\n\
    \        -- If no min_distance is set, initialize it\n        if min_distance\
    \ == nil then\n            min_distance = Math.abs(element_index)\n          \
    \  min_distance_element = element_index\n            min_distance_element_index\
    \ = element_index\n        else\n            -- Calculate the distance from the\
    \ current minimum\n            local current_distance = Math.abs(element_index\
    \ - min_distance_element)", "\tlocal min_value = numbers[1]\n\tlocal max_value\
    \ = numbers[1]\n\tfor _, number in pairs(numbers) do\n\t\tif number < min_value\
    \ then\n\t\t\tmin_value = number\n\t\telseif number > max_value then\n\t\t\tmax_value\
    \ = number\n\t\tend\n\tend\n\tlocal min_value_plus_1 = min_value + 1\n\tlocal\
    \ max_value_plus_1 = max_value + 1\n\tif min_value < max_value_plus_1 then\n\t\
    \treturn {min_value, max_value}\n\telse\n\t\treturn {max_value, min_value}\n\t\
    end\nend", "  assert(#numbers >= 2, \"find_closest_elements: Input table must\
    \ have at least two elements.\")\n  local results = {}\n  local smallest, largest,\
    \ smallest_idx, largest_idx = nil, 0, nil, 0\n  for i = 2, #numbers do\n    local\
    \ dist = math.abs(numbers[i] - numbers[smallest_idx])\n    if smallest == nil\
    \ or dist < smallest then\n      smallest, smallest_idx = dist, i\n      largest,\
    \ largest_idx = dist, i\n      results[i] = numbers[i]\n    end\n  end\n  return\
    \ results\nend", "  local function distance(ai, bi)\n    return math.abs(numbers[ai]\
    \ - numbers[bi])\n  end", '  if #numbers < 2 then return {nil, nil} end', "\t\
    local closest_numbers = {}\n\tlocal min_distance = math.abs(numbers[1] - numbers[2])\n\
    \tfor i=2,#numbers do\n\t\tlocal distance = math.abs(numbers[i] - numbers[i -\
    \ 1])\n\t\tif distance < min_distance then\n\t\t\tmin_distance = distance\n\t\t\
    elseif distance == min_distance then\n\t\t\ttable.insert(closest_numbers, numbers[i])\n\
    \t\tend\n\tend\n\treturn closest_numbers\nend", '  local sorted_numbers = table.sort(numbers)',
  "  if #numbers == 0 then\n    return {{}, {}}\n  end", "\tlocal max_val, min_val\
    \ = numbers[1], numbers[#numbers]\n\tlocal min_dist, max_dist = -100, 100\n\t\
    for _, num in pairs(numbers) do\n\t\tlocal dist = abs(num - min_val)\n\t\tif dist\
    \ < min_dist then\n\t\t\tmin_dist, min_val = dist, num\n\t\telseif dist > max_dist\
    \ then\n\t\t\tmax_dist, min_val = dist, num\n\t\tend\n\tend\n\treturn max_val,\
    \ min_val\nend", "  assert(#numbers >= 2)\n  if #numbers == 1 then\n    return\
    \ {numbers[1], numbers[1]}\n  end\n  local min1, min2 = numbers[1], numbers[1]\n\
    \  local min_index = #numbers + 1\n  local max_index = #numbers\n  for i=2,#numbers\
    \ do\n    local curr = numbers[i]\n    local distance = math.abs(curr - min1)\n\
    \    if distance < math.abs(curr - min2) then\n      min2 = curr\n      min_index\
    \ = i\n      min1 = curr\n    else\n      distance = math.abs(curr - min2)\n \
    \     if distance < math.abs(curr - min1) then\n        min2 = curr\n        min_index\
    \ = i\n        min1 = curr\n      else\n        distance = math.abs(curr - min1)\n\
    \        if distance < math.abs(curr - max1) then\n          min1 = curr\n   \
    \       min_index = i\n          max_index = i\n        else\n          min2 =\
    \ curr\n          min_index = i\n          max_index = i\n        end\n      end\n\
    \    end\n  end\n  return {numbers[min_index], numbers[max_index]}\nend", "  --\
    \ The return value.\n  local result = {}\n  -- The index to the last element of\
    \ the table.\n  local index_last = #numbers\n  -- The minimum distance found so\
    \ far.\n  local min_dist = 9999999999\n  -- Iterate through the table backwards,\
    \ starting from the end,\n  -- and find any element that is closest to the previous\
    \ element.\n  for i = index_last - 1, 1, -1 do\n    -- Get the difference between\
    \ this element and the one before.\n    local dist = numbers[i] - numbers[i -\
    \ 1]\n    -- See if this element has a better distance than the one before.\n\
    \    if dist < min_dist then\n      -- Update the result.\n      min_dist = dist\n\
    \      -- Store this element.\n      result[i] = numbers[i]\n    end\n  end\n\
    \  -- Return the result.\n  return result\nend", "  if #numbers < 2 then return\
    \ {nil, nil} end\n  local sorted_numbers = numbers:sort()\n  local smaller, larger\
    \ = sorted_numbers[1], sorted_numbers[#sorted_numbers]\n  if larger < smaller\
    \ then smaller, larger = larger, smaller end\n  local smaller_index, larger_index\
    \ = #sorted_numbers, 1\n  local smaller_element = nil\n  local larger_element\
    \ = nil\n  repeat\n    smaller_element = sorted_numbers[smaller_index]\n    larger_element\
    \ = sorted_numbers[larger_index]\n    smaller_index = smaller_index - 1\n    larger_index\
    \ = larger_index + 1\n  until smaller_index > 0 and larger >= smaller_element\
    \ and larger_index < #sorted_numbers\n  return smaller_element, larger_element\n\
    end", "  if #numbers < 2 then\n    return {}\n  end\n  local min_val = numbers[1]\n\
    \  local max_val = numbers[1]\n  for i = 1, #numbers do\n    if numbers[i] < min_val\
    \ then\n      min_val = numbers[i]\n    end\n    if numbers[i] > max_val then\n\
    \      max_val = numbers[i]\n    end\n  end\n  return {min_val, max_val}\nend",
  "\tassert(#numbers > 1, 'Table of numbers must have at least one value')\n\tlocal\
    \ smallest, largest = nil, math.inf\n\tlocal last_two = numbers[#numbers]\n\t\
    for i = 0, #numbers - 1 do\n\t\tlocal middle = numbers[i] + numbers[i + 1]\n\t\
    \tif middle < smallest then\n\t\t\tsmallest = middle\n\t\telseif middle > largest\
    \ then\n\t\t\tlargest = middle\n\t\tend\n\tend\n\treturn largest, smallest\nend",
  '  if #numbers < 2 then return {} end', "\tlocal min_diff = math.huge\n\tlocal min_number\
    \ = nil\n\tlocal max_number = nil\n\tfor _,n in pairs(numbers) do\n\t\tlocal diff\
    \ = math.abs(n-min_number) or 1\n\t\tif diff < min_diff then\n\t\t\tmin_number\
    \ = n\n\t\t\tmin_diff = diff\n\t\telseif diff > min_diff then\n\t\t\tmax_number\
    \ = n\n\t\tend\n\tend\n\treturn min_number, max_number\nend", "  local mins =\
    \ nil\n  local maxes = nil\n  local min_index = nil\n  local max_index = nil",
  "\tassert(numbers and #numbers >= 2, \"Must pass an array at least two elements.\"\
    )\n\tlocal smallest_difference = math.inf", "  local min = {}\n  local max = {}\n\
    \  local index\n  for _, number in pairs(numbers) do\n    local distance = math.abs(number\
    \ - numbers[1])\n    local min_index = #min + 1\n    if min[min_index] == nil\
    \ then\n      min[min_index] = number\n      min[index] = number\n      max[index]\
    \ = number\n      index = min_index\n    else\n      if min[min_index] ~= nil\
    \ then\n        local distance2 = math.abs(number - min[min_index])\n        if\
    \ distance < distance2 then -- if closer, replace\n          min[min_index] =\
    \ number\n          min[index] = number\n          max[index] = number\n     \
    \     index = min_index\n        else\n          local distance3 = math.abs(number\
    \ - min[index])\n          if distance < distance3 then -- if closer, replace\n\
    \            min[min_index] = number\n            min[index] = number\n      \
    \      max[index] = number\n            index = min_index\n          else\n  \
    \          local distance4 = math.abs(number - max[index])\n            if distance\
    \ < distance4 then -- if closer, replace\n              min[min_index] = number\n\
    \              min[index] = number\n              max[index] = number\n      \
    \        index = min_index\n            else\n              local distance5 =\
    \ math.abs(number - numbers[1])\n              if distance < distance5 then --\
    \ if closer, replace\n                min[min_index] = number\n              \
    \  min[index] = number\n                max[index] = number\n                index\
    \ = min_index\n              end\n            end\n          end\n        end\n\
    \      end\n    end\n  end\n  return min, max\nend", "    if #numbers < 2 then\n\
    \        return {nil, nil}\n    end", "  local function f(ai, aj, x)\n    -- Check\
    \ if x is closer to current element.\n    return math.abs(x - numbers[ai]) < (numbers[ai]\
    \ - numbers[aj])\n  end", "  local min\n  local max\n  local cur\n  local out\
    \ = {}\n  local min_index = 1\n  local max_index = #numbers\n  repeat\n    --\
    \ If there are less than two numbers, don't bother sorting.\n    -- If there are\
    \ two or more, sort the numbers and return them in order.\n    if #numbers < 2\
    \ then return out end", "    assert(#numbers > 1, 'The supplied table of numbers\
    \ is too short to find any pairs.')\n    assert(#numbers < 2, 'The supplied table\
    \ of numbers is too long to find any pairs.')\n    local minimum, maximum = numbers[1],\
    \ numbers[1]\n    for _, value in pairs(numbers) do\n        if value < minimum\
    \ then minimum = value end\n        if value > maximum then maximum = value end\n\
    \    end\n    if minimum > maximum then return nil end\n    return minimum, maximum\n\
    end", "  local smallest_diff\n  local smallest_element\n  local closest_element",
  "    if #numbers < 2 then return {numbers[1]} end\n    local maxs = table.sort(numbers)\n\
    \    local mins = table.sort(table.reverse(numbers))\n    local result = {}\n\
    \    for i, v in ipairs(mins) do\n        if v == maxs[i] then\n            table.insert(result,\
    \ v)\n        else\n            local m, M\n            m, M = find_closest_elements(numbers)\n\
    \            table.insert(result, m)\n        end\n    end\n    return result\n\
    end", "    local sortedNumbers = {}\n    for _, v in pairs(numbers) do\n     \
    \   table.insert(sortedNumbers, v)\n    end\n    table.sort(sortedNumbers)\n \
    \   table.insert(sortedNumbers, sortedNumbers[1])\n    table.insert(sortedNumbers,\
    \ sortedNumbers[#sortedNumbers])\n    return sortedNumbers\nend", "  local sorted,\
    \ sorted_index, smallest, largest_index, largest_value = table.sort(numbers)\n\
    \  for i, v in ipairs(sorted) do\n    if v == smallest then\n      sorted_index\
    \ = 1\n      smallest = v\n    elseif v == largest_value then\n      sorted_index\
    \ = #sorted\n      largest_index = i\n      largest_value = v\n    end\n  end\n\
    \  return sorted, sorted_index, smallest, largest_index, largest_value\nend",
  "    -- If there are no numbers to compare, return nothing.\n    if not numbers\
    \ or #numbers == 0 then\n        return nil\n    end", "  local smallest = numbers[1]\n\
    \  local largest = numbers[1]\n  for i = 2, #numbers do\n    if numbers[i] < smallest\
    \ then\n      smallest = numbers[i]\n    elseif numbers[i] > largest then\n  \
    \    largest = numbers[i]\n    end\n  end\n  return {smallest, largest}\nend",
  "    local nearest_lower = numbers[1]\n    local nearest_upper = numbers[1]\n  \
    \  for i = 2, #numbers do\n        local lower_index = nearest_lower\n       \
    \ local upper_index = nearest_upper\n        local lower_index = math.min(lower_index,\
    \ i)\n        local upper_index = math.max(upper_index, i)\n        if numbers[lower_index]\
    \ > numbers[upper_index] then\n            nearest_lower = lower_index\n     \
    \   else\n            nearest_upper = upper_index\n        end\n    end\n    table.insert(numbers,\
    \ nearest_lower)\n    table.insert(numbers, nearest_upper)\n    return numbers\n\
    end", "  local min1, min2 = numbers[1], numbers[1]\n  for i = 2, #numbers do\n\
    \    min2, min1 = min1, min2\n    if numbers[i] < min1 then\n      min2, min1\
    \ = numbers[i], numbers[i]\n    end\n  end\n  return min1, min2\nend", "  local\
    \ function distance(first,second)\n    return math.abs(first-v) or math.abs(second-v)\n\
    \  end\n  local first,last = numbers[1], numbers[#numbers]\n  return table.sort(numbers,\
    \ function(a,b)\n    return distance(b,a)\n  end)\nend", "  local function distance(number)\n\
    \    return math.abs(number - math.floor(number))\n  end\n  local closest_pair\
    \ = {}\n  for i, number in ipairs(numbers) do\n    for j = i, #numbers do\n  \
    \    if distance(numbers[j]) ~= distance(i) then\n        closest_pair[i] = numbers[j]\n\
    \        break\n      end\n    end\n  end\n  return table.sort(closest_pair)\n\
    end", "\tlocal smallest, largest = table.unpack(numbers)\n\tlocal closest = {}\n\
    \ttable.sort(numbers, function(a, b) return math.abs(a - b) end)\n\ttable.insert(closest,\
    \ numbers[1])\n\ttable.insert(closest, numbers[#numbers])\n\tfor i = 2, #numbers\
    \ do\n\t\tif numbers[i] ~= closest[#closest] then\n\t\t\ttable.insert(closest,\
    \ numbers[i])\n\t\tend\n\tend\n\treturn closest\nend", "  local minimum, maximum\
    \ = numbers.first, numbers.last\n  local minimum_idx = #numbers - 1\n  local minimum_value\
    \ = numbers.last\n  local minimum_value = minimum_value:min()\n  local minimum_value\
    \ = minimum_value:abs()\n  local minimum_value = minimum_value:cdiv(maximum_value)\n\
    \  local minimum_value = minimum_value:cmul(minimum_value)\n  for i, value in\
    \ ipairs(numbers) do\n    minimum_value = minimum_value:cadd((minimum_value:cadd((minimum_value:cdiv((minimum_value:cmul(minimum_value:abs()))):cmul(value))):cmul(minimum_value))\n\
    \    minimum_value = minimum_value:cadd((minimum_value:cdiv(minimum_value:cmul((minimum_value:cmul(minimum_value:abs()))):cmul(value))):cmul(minimum_value))\n\
    \  end\n  minimum_value = minimum_value:cmul(minimum_value)\n  minimum_value =\
    \ minimum_value:cdiv(minimum_value:cmul(maximum_value))\n  return minimum_value:cadd(minimum_value:cmul(minimum_value))\n\
    end", "    -- If all numbers are equal then return all numbers in a set.\n   \
    \ if #numbers == 1 then return numbers end\n    local smallest, largest = math.min(numbers),\
    \ math.max(numbers)\n    local smallerTable = find_closest_elements(\n       \
    \ {smallest} .. {largest})\n    local largerTable = find_closest_elements(\n \
    \       {largest} .. {smallest})\n    local closestTable = smaller .. largest\n\
    \    if #smallerTable > #largerTable then\n        return smallerTable\n    elseif\
    \ #smallerTable < #largerTable then\n        return largerTable\n    else\n  \
    \      return closestTable\n    end\nend", "  if numbers[1] == nil then return\
    \ {nil, nil}\n  elseif numbers[#numbers] == nil then return {nil, numbers[1]}\
    \ end", "\tlocal minimum, maximum = unpack(numbers)\n\tminimum, maximum = minimum,\
    \ math.floor(minimum + 0.5), math.floor(maximum + 0.5)\n\tlocal min = minimum\n\
    \tlocal max = maximum\n\tlocal middle", '  local largest, smallest, smallest_idx,
    largest_idx, i, j', "  -- First, find min/max values in array\n  local minval,\
    \ maxval = unpack(numbers)\n  if minval == maxval then\n    return {minval}\n\
    \  end\n  -- Iterate to find closest pair\n  local pairs = {}\n  local pairindex\
    \ = 0\n  while pairindex < #numbers do\n    -- Compute current distance\n    local\
    \ dist = math.abs(numbers[pairindex] - minval)\n    -- Keep only pairs with minimal\
    \ distance\n    if dist < pairs[#pairs] and dist < maxval then\n      table.insert(pairs,\
    \ {pairindex, dist})\n    end\n    pairindex = pairindex + 1\n  end\n  -- Return\
    \ pairs in order from smallest to largest\n  -- This sorts by pairindex in pairs\
    \ array\n  table.sort(pairs, function(a, b)\n    return a.pairindex < b.pairindex\n\
    \  end)\n  -- Return pairs\n  local output = {}\n  for _, pair in pairs do\n \
    \   table.insert(output, pair)\n  end\n  return output\nend", "  assert(#numbers\
    \ >= 2, 'There must be at least two elements in an array')\n  local closest1,\
    \ closest2 = numbers[1], numbers[1]\n  local i = 2\n  while i <= #numbers do\n\
    \    local d = (closest1 - closest2) / (numbers[i] - numbers[1])\n    if d < 0.1\
    \ then\n      closest2 = numbers[i]\n    else\n      closest1 = numbers[i]\n \
    \   end\n    i = i + 1\n  end\n  return closest1, closest2\nend", "    local sorted_numbers\
    \ = table.sort(numbers)\n    local closest_pairs = {}", "  local closest = {math.min(numbers)}\n\
    \  local closest_number = numbers[#numbers]\n  for i = 1, #numbers do\n    if\
    \ numbers[i] < closest_number then\n      closest[i] = closest[i-1]\n    elseif\
    \ numbers[i] < closest[i] then\n      closest[i] = numbers[i]\n      closest_number\
    \ = numbers[#numbers]\n    end\n  end\n  return closest\nend", "    -- Sort numbers\
    \ descending - as they will be closest to their neighbors.\n    table.sort(numbers,\
    \ function(a, b)\n        return (a < b and -1) -- Return negative when A < B\n\
    \                       or (a > b and 1) -- Return positive when A > B\n    end)\n\
    \    -- If no numbers are supplied, return an empty table of pairs of numbers\
    \ and an empty table.\n    if #numbers == 0 then\n        return {{}, {}}\n  \
    \  end\n    -- Return an empty table if a single number is supplied.\n    if #numbers\
    \ == 1 then\n        return {numbers, {}}\n    end\n    -- Return an empty table\
    \ if the supplied numbers are all equal.\n    if numbers[1] == numbers[#numbers]\
    \ then\n        return {numbers, {}}\n    end\n    -- Return an empty table if\
    \ the supplied numbers are not all equal.\n    -- If the numbers are all different,\
    \ the closest pair to the supplied numbers will be\n    -- returned.\n    local\
    \ i = 1\n    while i <= #numbers - 1 do\n        local diff, diff_pos = math.abs(numbers[i]\
    \ - numbers[i - 1]), i - 1\n        if diff > 0.1 then\n            table.insert(numbers,\
    \ numbers[#numbers])\n            table.remove(numbers, i)\n        else\n   \
    \         local neighbor = numbers[i]\n            table.remove(numbers, i)\n\
    \            table.insert(numbers, neighbor)\n            -- If the supplied numbers\
    \ differ by less than 0.1, we insert them in order of\n            -- nearest\
    \ neighbors so that the closest pair is returned.\n            if diff < 0.1 then\n\
    \                table.insert(numbers, neighbor)\n                table.insert(numbers,\
    \ neighbor)\n                table.insert(numbers, neighbor)\n               \
    \ table.insert(numbers, neighbor)\n                table.insert(numbers, neighbor)\n\
    \            end\n        end\n        i = i + 1\n    end\n    -- Return the numbers\
    \ that are the closest to each other\n    local closest_numbers, closest = numbers[1],\
    \ numbers[1]\n    for i = 2, #numbers do\n        local diff = math.abs(numbers[i]\
    \ - closest)\n        if diff < 0.1 then\n            closest = numbers[i]\n \
    \       elseif diff == 0.1 then\n            -- If they're equal by 10% - insert\
    \ them in order so that\n            -- they end up in the order of the closest\
    \ neighbors.\n            table.insert(closest_numbers, closest)\n           \
    \ table.insert(closest_numbers, closest)\n            table.insert(closest_numbers,\
    \ closest)\n            table.insert(closest_numbers, closest)\n            table.insert(closest_numbers,\
    \ closest)\n        end\n    end\n    return {{closest_numbers, closest}}\nend",
  '  assert(#numbers > 1, "find_closest_elements() requires at least two numbers.")',
  "  local smallest\n  local largest\n  local smallest_index\n  local largest_index\n\
    \  for index, number in pairs(numbers) do\n    local distance = math.abs(number-smallest)\n\
    \    if distance < smallest[1] then\n      smallest = number\n      smallest_index\
    \ = index\n    end\n    distance = math.abs(number-largest)\n    if distance <\
    \ largest[1] then\n      largest = number\n      largest_index = index\n    end\n\
    \  end\n  if smallest_index and largest_index then\n    return {smallest, largest}\n\
    \  else\n    return {}\n  end\nend", "  if #numbers == 1 then\n    return numbers\n\
    \  else\n    local smallest = numbers[1]\n    local largest = numbers[1]\n   \
    \ for i = 2, #numbers do\n      local current = numbers[i]\n      if current <\
    \ smallest then\n        largest = current\n        smallest = current\n     \
    \ elseif current > largest then\n        smallest = current\n      end\n    end\n\
    \    return {smallest, largest}\n  end\nend", "  if #numbers < 2 then return {numbers[1]}\
    \ end\n  local smallest = numbers[1]\n  local largest = numbers[1]\n  local i\
    \ = 1\n  while i < #numbers and numbers[i] ~= numbers[smallest] do\n    smallest\
    \ = numbers[i]\n    i = 1\n  end\n  while i < #numbers and numbers[i] ~= numbers[largest]\
    \ do\n    largest = numbers[i]\n    i = 1\n  end\n  assert(smallest ~= largest)\n\
    \  return {smallest, largest}\nend", "    local min_el, max_el = unpack(numbers)\n\
    \    local min_dist, max_dist = unpack(numbers)", "  if #numbers < 2 then return\
    \ nil end\n  local closest_pairs = {}\n  local diffs = numbers:map(function(x)\n\
    \    return abs(x - numbers[1])\n  end)\n  table.sort(diffs)\n  for i = 1, #diffs\
    \ do\n    local difference = diffs[i]\n    local index = i\n    if #closest_pairs\
    \ >= 2 then\n      if difference < diffs[closest_pairs[#closest_pairs] - 1]\n\
    \      then\n        difference = difference\n        index = closest_pairs[#closest_pairs]\
    \ - 1\n      end\n    end\n    closest_pairs[#closest_pairs] = index\n  end\n\
    \  return closest_pairs\nend", "\tlocal closest1, closest2 = numbers[1][1], numbers[2][1]\n\
    \tfor i = 2, #numbers do\n\t\tif numbers[i][1] < closest1 then\n\t\t\tclosest2\
    \ = closest1\n\t\t\tclosest1 = numbers[i][1]\n\t\telseif numbers[i][1] > closest2\
    \ then\n\t\t\tclosest2 = numbers[i][1]\n\t\tend\n\tend\n\treturn {closest1, closest2}\n\
    end", "  local lower = numbers[1]\n  local higher = numbers[#numbers]", "  local\
    \ best_lower = math.min(numbers:map(function(x) return x:tonumber() end))\n  local\
    \ best_upper = math.max(numbers:map(function(x) return x:tonumber() end))", " \
    \ local smallest = math.min(numbers)\n  local largest = math.max(numbers)\n  return\
    \ {\n    largest = largest,\n    smallest = smallest,\n  }\nend", "  assert(#numbers\
    \ > 1)\n  local closest = {}\n  local current = numbers[1]\n  for _, num in pairs(numbers)\
    \ do\n    local diff = math.abs(num - current)\n    if diff < closest[1] then\n\
    \      closest = {num, diff}\n    elseif diff == closest[1] then\n      table.insert(closest,\
    \ num)\n    end\n    current = num\n  end\n  return closest\nend", "  if not numbers\
    \ or #numbers < 2 then\n    return {}\n  end", "  local smallest = nil\n  local\
    \ largest = nil\n  for _, value in pairs(numbers) do\n    if smallest == nil then\n\
    \      smallest = value\n      largest = value\n      continue\n    end\n    if\
    \ value < smallest then\n      smallest = value\n    end\n    if value > largest\
    \ then\n      largest = value\n    end\n  end\n  return {smallest, largest}\n\
    end", "  local smallest, largest = table.unpack(numbers)\n  table.sort(numbers,\
    \ function(_, key) return key < smallest end)\n  table.sort(numbers, function(_,\
    \ key) return key > largest end)\n  return table.unpack(numbers, 1, table.count(numbers))\n\
    end", "   -- Convert each number into a table of its digits (strings of digits).\n\
    \   local digits = table.reduce(numbers, function(list, n)\n      list[(n and\
    \ tonumber(string(n)) or n)]\n   end, {})\n   local min\n   local max", "\tlocal\
    \ minDistance = numbers[1]\n\tlocal closestElements = {}\n\tlocal closestIndex\
    \ = nil\n\tlocal minElement = numbers[2]\n\tfor i = 1, #numbers do\n\t\tlocal\
    \ elementDistance = numbers[i] - minElement\n\t\t-- if elementDistance < 0 then\
    \ elementDistance = 0 --TODO: Fix this\n\t\tlocal minIndex = 1\n\t\tif elementDistance\
    \ < minDistance then\n\t\t\tminDistance = elementDistance\n\t\t\tclosestElements\
    \ = numbers\n\t\t\tclosestIndex = i\n\t\t\tminElement = elementDistance\n\t\t\
    end\n\tend\n\t-- minDistance should be zero, minElement should also be zero.\n\
    \treturn closestElements, minElement\nend", "  local best_pair = {}\n  local best_distance\
    \ = math.inf\n  local best_index", "  local closest_numbers = {}\n  local smallest_number\
    \ = numbers[1]\n  local biggest_number = numbers[1]", "    local distances = {}\n\
    \    for i = 1, #numbers, 2 do\n        local left = numbers[i]\n        local\
    \ right = numbers[i+1]\n        local dist = math.abs(left - right)\n        table.insert(distances,\
    \ dist)\n    end\n    table.sort(distances)\n    local result = {}\n    for i\
    \ = 1, #numbers do\n        table.insert(result, numbers[distances[i]])\n    end\n\
    \    return result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
