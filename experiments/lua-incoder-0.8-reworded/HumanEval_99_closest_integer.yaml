name: HumanEval_99_closest_integer
language: lua
prompt: "-- Create a function that takes a value (string) representing a number\n\
  -- and returns the closest integer to it. If the number is equidistant\n-- from\
  \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
  -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from zero\
  \ means that if the given number is equidistant\n-- from two integers, the one you\
  \ should return is the one that is the\n-- farthest from zero. For example closest_integer(\"\
  14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\n\
  local function closest_integer(value)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
  \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
  \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
  \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  return math.floor(value / step) + math.ceil(value / -step)\nend",
  "    -- The code below is based on the algorithm in T. K. Rohing's paper:\n    --\
    \ https://research.cs.wisc.edu/tr/papers/Rohing08-Rosenbluth08.pdf\n    local\
    \ closest_integer_index, difference\n    -- We want to find the index closest\
    \ to `value`. If `value` is exactly\n    -- halfway between two integers, we would\
    \ return an index halfway between\n    -- the two integers. If `value` is exactly\
    \ equal to one integer, then we\n    -- should return the integer's index instead.\n\
    \    local first_integer = tonumber(value)\n    local second_integer = tonumber(value)\n\
    \    local diff, closest\n    if tonumber(value) == first_integer then\n     \
    \   if first_integer == second_integer then\n            -- `value` is already\
    \ an integer.\n            return value\n        else\n            -- `value`\
    \ is an integer.\n            return first_integer\n        end\n    elseif first_integer\
    \ == second_integer then\n        -- `value` is a float. Return the closest integer.\n\
    \        closest_integer = first_integer\n        return closest_integer\n   \
    \ end\n    -- We want a value that is halfway between two integers, so we need\n\
    \    -- to check which integer is the closest. Since both integers\n    -- are\
    \ equidistant, we must round the closest one away from zero.\n    diff = abs(first_integer\
    \ - second_integer)\n    if diff < 0.5 then\n        -- The diff is exactly half\
    \ between integers. Round the closest\n        -- integer away from zero.\n  \
    \      closest_integer_index = (first_integer - diff)/2 + 1\n    else\n      \
    \  -- The diff is less than half between integers. Round the closest\n       \
    \ -- integer towards zero.\n        closest_integer_index = (first_integer - diff)/2\n\
    \    end\n    difference = abs(value - closest_integer_index)\n    closest = first_integer\n\
    \    if difference < 0.5 then\n        -- The difference is exactly half between\
    \ integers. Round the\n        -- closest integer away from zero.\n        difference\
    \ = (value - closest_integer_index)/2 + 1\n    else\n        -- The difference\
    \ is less than half between integers. Round the\n        -- closest integer towards\
    \ zero.\n        difference = (value - closest_integer_index)/2\n    end\n   \
    \ if difference < 0.5 then\n        -- If the difference is exactly half, return\
    \ the closest integer.\n        closest = closest_integer_index\n    else\n  \
    \      -- If the difference is less than half, return the closest integer\n  \
    \      -- and add one. Since we rounded away from zero, if the closest\n     \
    \   -- integer was actually halfway between two integers, we would round\n   \
    \     -- it towards zero instead of away from zero.\n        closest = (closest_",
  "  if tonumber(value) == value then\n    return tonumber(value)\n  end", "   if\
    \ value == nil then\n      error('value required')\n   end", "    local function\
    \ closest(i, v)\n        if v == 0 then\n            return i\n        end\n \
    \       if abs(i - v) < 0.001 then\n            return i\n        end\n      \
    \  return v\n    end\n    return closest(math.floor(value), value)\nend", "  local\
    \ sign = math.sign(value)\n  if sign == nil then\n    return 0\n  end", "  local\
    \ function closest()\n    if value == 0 then return 0 end\n    if value ~= value\
    \ then return 0 end\n    local closest, divisor = value, 1\n    while closest\
    \ % divisor ~= 0 and closest > 1 do\n      closest, divisor = closest / divisor,\
    \ divisor + 1\n    end\n    return closest\n  end\n  local function round(value)\n\
    \    return math.round(value / closest()) * closest()\n  end\n  local function\
    \ roundto(value)\n    return round(value / closest())\n  end\n  if type(value)\
    \ == 'string' then\n    return roundto(value)\n  end\n  return round(value)\n\
    end", "\t-- If the value is already an integer, just return it.\n\tif value:type(number)\
    \ == number then\n\t\treturn value\n\tend\n\t-- Otherwise we must convert the\
    \ value to a number.\n\tlocal num = tonumber(value)\n\t-- If it's a negative number,\
    \ make sure that the number returned is positive.\n\tif num < 0 then\n\t\tnum\
    \ = -num\n\tend\n\t-- If we have two integers, we must compare the numbers in\
    \ the opposite\n\t-- directions. We do this by finding their difference, and then\
    \ adding one\n\t-- to whichever is smaller.\n\tlocal diff = num - floor(num)\n\
    \tif diff >= 0 then\n\t\treturn floor(num) + 1 -- add 1 because round up doesn't\
    \ work with negative numbers\n\tend\n\treturn floor(num) -- return the floor number\n\
    end", "  local sign = math.sign(value)\n  local value = math.abs(value)\n  if\
    \ value < 0 then\n    value = -value\n    sign = -sign\n  end\n  local limits\
    \ = util.ipairs(constants.MAX_INTEGER)\n  for _, limit in ipairs(limits) do\n\
    \    if value <= limit then\n      return limit * sign\n    end\n  end\n  -- Return\
    \ zero if it cannot be determined\n  return 0\nend", "\tlocal function distance(v)\n\
    \t\treturn (math.abs(v - value)) + 1\n\tend\n\tlocal function closest_num(num)\n\
    \t\tif num < value then\n\t\t\treturn num\n\t\telse\n\t\t\treturn value\n\t\t\
    end\n\tend", "  local smallest = 0\n  local largest = tonumber(value)\n  while\
    \ largest > smallest do\n    local mid = math.floor((smallest + largest) / 2)\n\
    \    if mid % 2 == 0 then largest = mid\n    else smallest = mid\n    end\n  end\n\
    \  return smallest\nend", "\tif tonumber(value) then\n\t\tlocal digits = tonumber(value)\n\
    \t\tif digits == nil then\n\t\t\treturn nil\n\t\tend", "    if value == nil then\
    \ return 0 end\n    if value == math.floor(value) then\n        if value == 0\
    \ then\n            return value\n        end\n        -- Check if there are two\
    \ numbers equidistant from zero.\n        for i = 1, (#value)-1 do\n         \
    \   if value[i] == 0 then\n                if value[i-1] == 0 then\n         \
    \           return value[i]\n                elseif value[i+1] == 0 then\n   \
    \                 return value[i-1]\n                end\n            end\n  \
    \      end\n    end\n    return tonumber(value)\nend", "  local value_string =\
    \ value:match('^-?%d+%.?%d*$')\n  if value_string then\n    local negative = not\
    \ value_string:match('^-%d+%.?%d*$')\n    if negative then\n      value_string\
    \ = \"-\" .. value_string\n    end\n    local number = tonumber(value_string)\n\
    \    if number then\n      return math.floor(number + 0.5)\n    else\n      return\
    \ nil\n    end\n  end\n  return nil\nend", "  local result\n  local diff", '    local
    num', "  local num = tonumber(value)\n  if num == nil then\n    print(\"'\" ..\
    \ value .. \"' is not a number or NaN\")\n  end\n  if value == nil then\n    print(\"\
    '\" .. value .. \"' is not a number\")\n  end\n  local sign\n  if num < 0 then\n\
    \    sign = -1\n  else\n    sign = 1\n  end", "  -- If the number is less than\
    \ zero, return zero.\n  if value <= 0 then return 0 end\n  -- If it is an integer,\
    \ return it.\n  if type(value) == 'number' and value == value then return value\
    \ end\n  -- If the value is a string, parse it to get a number.\n  if type(value)\
    \ == 'string' then\n    local n = tonumber(value)\n    if n ~= nil then\n    \
    \  return n\n    end\n  end\n  -- If the value is a table, check each row of the\
    \ table.\n  if type(value) == 'table' then\n    local max = 0\n    for i = 1,\
    \ #value do\n      local v = value[i]\n      if type(v) == 'number' then\n   \
    \     v = v + 0\n        if v > max then\n          max = v\n        end\n   \
    \   end\n    end\n    return max\n  end\n  -- If the value is not a number, assume\
    \ it is an equidistant integer.\n  -- In that case, return the farthest from zero.\n\
    \  return math.floor(-value)\nend", "\tlocal closest\n\tlocal mins = math.min(\
    \ value )\n\tlocal maxs = math.max( value )\n\tfor i = mins, maxs do\n\t\tlocal\
    \ ival = i - mins\n\t\tif ival == 0 then\n\t\t\tclosest = i - 1\n\t\t\tbreak\n\
    \t\tend\n\t\tif ival % 1 ~= 0 then\n\t\t\tbreak\n\t\tend\n\t\tclosest  = i\n\t\
    end\n\treturn closest\nend", "  if type(value) ~= 'string' then return value end\n\
    \  local pos = tonumber(value)\n  if value == nil then return pos end\n  if pos\
    \ == nil then return pos end\n  local function closest(num)\n    if tonumber(num)\
    \ == nil then return nil end\n    local dist = tonumber(math.abs(pos - num))\n\
    \    if dist == 0 then return num end\n    return num\n  end\n  local function\
    \ closest(num)\n    if tonumber(num) == nil then return nil end\n    local dist\
    \ = tonumber(math.abs(pos - num))\n    if dist == 0 then return num end\n    return\
    \ num\n  end\n  local function closest(num)\n    if tonumber(num) == nil then\
    \ return nil end\n    local dist = tonumber(math.abs(pos - num))\n    if dist\
    \ == 0 then return num end\n    return num\n  end\n  local function closest(num)\n\
    \    if tonumber(num) == nil then return nil end\n    local dist = tonumber(math.abs(pos\
    \ - num))\n    if dist == 0 then return num end\n    return num\n  end\n  local\
    \ function closest(num)\n    if tonumber(num) == nil then return nil end\n   \
    \ local dist = tonumber(math.abs(pos - num))\n    if dist == 0 then return num\
    \ end\n    return num\n  end\n  local function closest(num)\n    if tonumber(num)\
    \ == nil then return nil end\n    local dist = tonumber(math.abs(pos - num))\n\
    \    if dist == 0 then return num end\n    return num\n  end\n  local function\
    \ closest(num)\n    if tonumber(num) == nil then return nil end\n    local dist\
    \ = tonumber(math.abs(pos - num))\n    if dist == 0 then return num end\n    return\
    \ num\n  end\n  local function closest(num)\n    if tonumber(num) == nil then\
    \ return nil end\n    local dist = tonumber(math.abs(pos - num))\n    if dist\
    \ == 0 then return num end\n    return num\n  end\n  local function closest(num)\n\
    \    if tonumber(num) == nil then return nil end\n    local dist = tonumber(math.abs(pos\
    \ - num))\n    if dist == 0 then return num end\n    return num\n  end\n  local\
    \ function closest(num)\n    if tonumber(num) == nil then return nil end\n   \
    \ local dist = tonumber(math.abs(pos - num))\n    if dist == 0 then return num ",
  "    -- if \"value\" is a string, it must be a number\n    if type(string(value))\
    \ ~= 'number' then return nil end\n    -- round \"value\" to an integer\n    value\
    \ = math.floor(value)\n    -- if \"value\" is equidistant from two integers, round\
    \ it away from zero\n    if value == 0 then\n        value = value + 0.5\n   \
    \ end\n    -- if \"value\" is equidistant from three integers, round it away from\
    \ zero\n    if value == 1 then\n        value = value + 0.75\n    end\n    --\
    \ return the integer that \"value\" represents.\n    return value\nend", "   \
    \ local int_value = tonumber(value)\n    local negative, closest = is_negative(int_value),\
    \ 0\n    if int_value ~= nil then\n        for i=1,math.rep(value:len(),2) do\n\
    \            local int_value_2 = tonumber(value:sub(i,i+1))\n            if negative\
    \ then\n                local rounded = int_value_2 + ((int_value - int_value_2)\
    \ % int_value_2)\n                if rounded == 0 then\n                    closest\
    \ = int_value - int_value_2\n                else\n                    closest\
    \ = int_value_2 + rounded - 1\n                end\n            else\n       \
    \         local rounded = (int_value - int_value_2) % int_value_2\n          \
    \      if rounded == 0 then\n                    closest = int_value + int_value_2\n\
    \                else\n                    closest = int_value_2 - rounded + 1\n\
    \                end\n            end\n            if closest > int_value then\n\
    \                closest = int_value\n            end\n        end\n    end\n\
    \    return closest\nend", "  return math.floor((value - 0.5) + 0.5)\nend", " \
    \   -- If the value doesn't have decimals, just return the value.\n    if not\
    \ string.match(value, \"%.\") then return value end", "    local function compare_floats(v1,\
    \ v2)\n        return tonumber(v1) <= tonumber(v2) and tonumber(v1) or tonumber(v2)\n\
    \    end\n    local function compare_ints(v1, v2)\n        return tonumber(v1)\
    \ <= tonumber(v2) and tonumber(v1) or tonumber(v2)\n    end", "   local precision\
    \ = tonumber(value)\n   if precision == nil then\n      return nil\n   end\n \
    \  local power = math.floor(math.log(precision) / math.log(10))\n   local nearest\
    \ = -math.ldexp(10, power)\n   if math.abs(tonumber(value) - nearest) <= precision\
    \ then\n      return nearest\n   end\n   return value\nend", "  if value == nil\
    \ then return nil end\n  local closest\n  local num = tonumber(value)\n  local\
    \ sign = math.sign(num) -- 1 -> 1, -1 -> -1, 0 -> 0\n  if sign == 0 and num <\
    \ 0 then -- negative and equidistant\n    closest = -num\n  elseif sign ~= 0 and\
    \ num < 0 then -- negative and opposite\n    closest = -num + math.pow(10, math.floor(math.log10(num)))\n\
    \  elseif sign == 0 and num >= 0 then -- positive and equidistant\n    closest\
    \ = num\n  elseif sign ~= 0 and num >= 0 then -- positive and opposite\n    closest\
    \ = (math.pow(10, math.floor(math.log10(num))) + num) / 2\n  else\n    -- If no\
    \ numbers are equidistant from two integers, round away from zero.\n    closest\
    \ = (math.floor(math.abs(num) + 0.5))\n  end\n  return closest\nend", "  local\
    \ int_value = tonumber(value)\n  if int_value <= 0 then return 0 end\n  local\
    \ min = 1\n  local max = #integers\n  while true do\n    local mid = math.floor((min\
    \ + max) / 2)\n    local current = integers[mid]\n    local difference = math.abs(current\
    \ - int_value)\n    if difference < closest_integer_diff then\n      min = mid\n\
    \    elseif difference > closest_integer_diff then\n      max = mid\n    else\n\
    \      return current\n    end\n  end\nend", "  local num = tonumber(value)\n\
    \  if not num then return 0 end\n  if num - 1 == num then return num end\n  local\
    \ ceil, floor\n  if num < 0 then\n    ceil = math.ceil\n    floor = math.floor\n\
    \  else\n    ceil = math.floor\n    floor = math.ceil\n  end", "    local closest\n\
    \    local rounded = tonumber(string.format(\"%g\", value))\n    for _ = 1, math.ceil(#rounded\
    \ / 2) do\n        local difference = rounded - (math.floor(rounded) * 2)\n  \
    \      if difference < 0 then\n            difference = difference * -1\n    \
    \    end\n        if difference < closest then\n            closest = difference\n\
    \        end\n        rounded = math.floor(rounded) * 2\n    end\n    return closest\n\
    end", "\tlocal integer = 0\n\tlocal next_integer = math.floor(value)\n\twhile\
    \ next_integer ~= value and next_integer < integer do\n\t\tinteger = next_integer\n\
    \t\tnext_integer = math.floor(next_integer + 0.5)\n\tend\n\treturn integer\nend",
  "\tlocal closest_integer, _ = _closest(value, math.floor)\n\tlocal closest_integer_diff\
    \ = value - closest_integer\n\treturn closest_integer + (closest_integer_diff\
    \ * 0.5)\nend", "  if value == nil then return nil end\n  value = tonumber(value)\n\
    \  if value == nil then return nil end\n  local function compare_numbers(x1,x2)\n\
    \    if x1 == nil and x2 == nil then\n      return 1\n    end\n    if x1 == nil\
    \ then\n      return -1\n    end\n    if x2 == nil then\n      return 1\n    end\n\
    \    if x1 == x2 then return 0 end\n    if abs(x1 - x2) <= 0.5 then\n      if\
    \ x1 == x2 then\n        return 1\n      else\n        return -1\n      end\n\
    \    else\n      return 1\n    end\n  end\n  if value == 0 then return 0 end\n\
    \  local function is_equidistant(x1,x2)\n    if x1 == x2 then return false end\n\
    \    if x1 == nil or x2 == nil then return false end\n    local function is_equidistant_pair(x1,x2)\n\
    \      if x1 == x2 then return false end\n      if x1 == nil or x2 == nil then\
    \ return false end\n      if x1 > x2 then\n        x1,x2 = x2,x1\n      end\n\
    \      if x2 - x1 > .0001 then\n        return false\n      else\n        return\
    \ true\n      end\n    end\n    if is_equidistant_pair(value,value) then return\
    \ true end\n    local difference = abs(value - x1)\n    if difference < .0001\
    \ then\n      return false\n    else\n      return is_equidistant_pair(x2,x2)\n\
    \    end\n  end\n  -- Handle negative numbers first.\n  if value >= 0 then\n \
    \   if value == 0 then return 0 end\n    local x1,x2 = 1,value\n    while x2 >\
    \ 0 do\n      local diff,mind = compare_numbers(x1,x2)\n      x1 = x2\n      x2\
    \ = mind\n    end\n    if x1 <= value then return x1 else return nil end\n  else\n\
    \    local x1,x2 = value,1\n    while x2 < 0 do\n      local diff,mind = compare_numbers(x1,x2)\n\
    \      x1 = x2\n      x2 = mind\n    end\n    if x2 <= value then return x2 else\
    \ return nil end\n  end\nend", "  -- If value is equidistant, round it away from\
    \ zero.\n  if math.abs(value - math.floor(value)) <= math.abs(value - math.ceil(value))\
    \ then\n    return math.ceil(value)\n  else\n    return math.floor(value)\n  end\n\
    end", "    return math.round(math.abs(value - math.floor(value)))\nend", "   local\
    \ result = 0\n   for i = 1, 10 do\n      if value == math.floor(value / 10) *\
    \ 10 then\n         return math.floor(value / 10)\n      elseif result == 0 then\n\
    \         result = math.floor(value / 10)\n      elseif value == math.floor(value\
    \ / 10) * 10 then\n         return math.floor(value / 10)\n      else\n      \
    \   return math.floor(value / 10) + 10\n      end\n   end\n   return result\n\
    end", "  local function distance(value)\n    if value == nil then return nil end\n\
    \    local diff = value\n    local div = 1\n    local mod = value\n    while mod\
    \ == diff do\n      diff = (diff + diff / div) / 2\n      div = div * 2\n    end\n\
    \    local distance_to_first = diff - mod\n    return distance_to_first\n  end\n\
    \  if value == nil then return nil end\n  local closest_index = distance(value)\n\
    \  if closest_index == nil then return nil end\n  local closest_value = value\n\
    \  local closest_difference = closest_index\n  local closest_difference_index\n\
    \  local closest_difference_value\n  -- Loop through everything from closest_index\
    \ to length\n  -- inclusive. Every time we find a value that is greater than the\n\
    \  -- current value, we've found the smallest difference. We're done\n  -- if\
    \ the smallest difference is zero, meaning that the given number\n  -- is equidistant\
    \ from two integers.\n  while closest_difference ~= 0 and closest_difference ~=\
    \ nil do\n    closest_difference_index = closest_difference\n    closest_difference_value\
    \ = closest_difference\n    closest_difference = distance(closest_value)\n  end\n\
    \  if closest_difference == 0 then\n    return closest_value\n  end\n  return\
    \ closest_difference_value\nend", "  if value == nil then\n    error('Invalid\
    \ argument')\n  else\n    local closest = 1\n    for i = 2, 20 do\n      if math.abs(value\
    \ - closest) < math.abs(value - i) then\n        closest = i\n      end\n    end\n\
    \    return closest\n  end\nend", "    local num\n    local closest_int_lower\
    \ = nil\n    local closest_int_upper = nil", "  local digits = tonumber(value)\n\
    \  if digits == nil then\n    error(\"[closest_integer] could not convert string\
    \ \" .. tostring(value) .. \" to number\", 2)\n  end\n  local digits2\n  local\
    \ exponent\n  if digits < 0 then\n    -- Exponent is positive, values are negative.\n\
    \    -- Determine how many digits there are in the \"negative\" part.\n    exponent\
    \ = math.floor(math.log10(abs(digits)))\n    -- Handle special case where there\
    \ is more than one digit.\n    if exponent == 0 then\n      exponent = 1\n   \
    \ end\n    -- Find the number of digits in the \"positive\" part.\n    digits2\
    \ = digits * math.pow(10, exponent)\n    -- If the number is still negative, then\
    \ just add one to the digit.\n    -- Otherwise, subtract one from the digit.\n\
    \    if digits < 0 then\n      digits2 -= 1\n    end\n    -- Round the digit up\
    \ or down depending on whether the number is\n    -- equidistant from two integers\
    \ or not.\n    if digits2 == digits then\n      digits2 = digits2 - 1\n    else\n\
    \      digits2 = digits2 + 1\n    end\n  else\n    -- Exponent is positive, values\
    \ are positive.\n    -- Determine the number of digits in the \"positive\" part.\n\
    \    digits2 = digits/math.pow(10, abs(exponent))\n    -- Round the digit up or\
    \ down depending on whether the number is\n    -- equidistant from two integers\
    \ or not.\n    if digits2 == digits then\n      digits2 = digits2 - 1\n    else\n\
    \      digits2 = digits2 + 1\n    end\n  end\n  return math.floor(digits2)\nend",
  "  -- Get difference between two values\n  local difference = value - math.floor(value)\n\
    \  -- If difference is zero, then the number is equidistant\n  if difference ==\
    \ 0 then\n    return math.floor(value)\n  else\n    -- If difference is less than\
    \ zero, the number is less than zero\n    -- If difference is more than zero,\
    \ the number is more than zero\n    local sign\n    if difference < 0 then\n \
    \     sign = -1\n    else\n      sign = 1\n    end\n    \n    -- Multiply the\
    \ difference by two to give it an odd rounding effect\n    -- Then divide by two\
    \ to get the correct rounding\n    -- This only works because difference is odd,\
    \ which happens if the\n    -- difference is less than or equal to half of the\
    \ difference between the\n    -- two integers\n    difference = sign * (difference\
    \ * 2) / 2\n    \n    -- Return the round of the difference to the nearest integer\n\
    \    return math.floor(difference)\n  end\nend", "  if value == nil then return\
    \ nil end\n  if value < 0 then value = -value; end", "  local value = tonumber(value)\n\
    \  local is_negative = value < 0\n  local min_value = tonumber(os.getenv('LUAJIT_MIN_VALUE'))\n\
    \  local max_value = tonumber(os.getenv('LUAJIT_MAX_VALUE'))\n  local max_abs\
    \ = math.abs(max_value - min_value)\n  local abs = math.abs(value)\n  local int_part\
    \ = math.trunc(abs)\n  if int_part > max_abs then\n    return min_value + 1\n\
    \  elseif int_part < -max_abs then\n    return min_value - 1\n  else\n    if abs\
    \ <= max_abs then\n      return int_part\n    else\n      local diff = abs - max_abs\n\
    \      if is_negative then\n        return min_value + diff\n      else\n    \
    \    return min_value - diff\n      end\n    end\n  end\nend", "\tif tonumber(value)\
    \ < 0 then return nil end\n\tlocal closest, closestDistance = math.modf(tonumber(value))\n\
    \tlocal distance = tonumber(value:sub(closest)) or 0\n\tif closestDistance < 1\
    \ then\n\t\treturn tonumber(value:sub(closest-distance))\n\telse\n\t\treturn tonumber(value:sub(closest+distance))\n\
    \tend\nend", "  local difference = math.abs(value - math.ceil(value))\n  if difference\
    \ < 0.3 then\n    -- round up to prevent errors from being generated when the\
    \ number\n    -- is close to zero\n    return math.ceil(math.abs(value))\n  elseif\
    \ difference < 0.8 then\n    -- round up if the number is equidistant from two\
    \ integers\n    return math.ceil(math.abs(value))\n  else\n    -- otherwise return\
    \ the value that was closest to the input\n    return math.floor(value)\n  end\n\
    end", "    local number = tonumber(value)\n    if number == nil then\n       \
    \ error()\n    end", "  return math.ceil(value/2)*2\nend", "  local value = tonumber(value)\n\
    \  -- If the number is equidistant from two integers, return the one that\n  --\
    \ comes before the other. For example closest_integer(\"14.5\") should\n  -- return\
    \ 14 and closest_integer(\"-14.5\") should return -14.\n  if value < 0 then\n\
    \    value = -value\n  end\n  return math.floor(value)\nend", "  -- Calculate\
    \ the difference between value and closest integer.\n  local difference = value\
    \ - closest_integer(tostring(value))", '    if value == nil then return nil end',
  "    local function is_integer(x)\n        return type(x) == \"number\"\n    end",
  "  local function is_equidistant(a, b)\n    return math.abs(a - b) < 1e-5\n  end",
  "    local diff1 = value:sub(1,1)\n    local diff2 = value:sub(3,3)\n    local diff3\
    \ = value:sub(5,5)\n    local diff4 = value:sub(7,7)\n    if diff1 == diff2 then\n\
    \        return diff1\n    end\n    if diff1 == diff3 then\n        return diff1\n\
    \    end\n    if diff1 == diff4 then\n        return diff1\n    end\n    if diff2\
    \ == diff3 then\n        return diff2\n    end\n    if diff2 == diff4 then\n \
    \       return diff2\n    end\n    if diff3 == diff4 then\n        return diff3\n\
    \    end\n    return math.floor(value)\nend", "   local number = tonumber(value)\n\
    \   if number == nil then\n      return nil\n   end\n   local result = number\n\
    \   if number < 0 then\n      result = 0 - result\n   end\n   if result == 0 or\
    \ result < number then\n      return nil\n   end\n   if result == number then\n\
    \      return number\n   end", "  -- If the value is an integer, it must be equal\
    \ to itself.\n  if type(value) == \"number\" then\n    return value\n  else\n\
    \    -- If the value is a string, the function expects a value.\n    return math.ceil(math.abs(value\
    \ or 0) / math.abs(value))\n  end\nend", "\t-- If the value is nil, return nil.\n\
    \tif not value then return nil end\n\t-- Create a dictionary that maps values\
    \ to the smallest integer\n\t-- that rounds to it away from zero. i.e. if 14.5\
    \ is the value,\n\t-- then 14 is the smallest integer that rounds to 14 away from\
    \ zero.\n\tlocal numbers_away_from_zero = {}\n\tfor digit, digit in string.gmatch(value,\
    \ '([-]?)(%d%d%d%d)') do\n\t\t-- For each digit, add the number of times that\
    \ digit has\n\t\t-- been rounded away from zero to numbers_away_from_zero.\n\t\
    \ttable.insert(numbers_away_from_zero, tonumber(digit) - tonumber(string.sub(digit,\
    \ 3, -1)))\n\tend\n\t-- Find the smallest number in numbers_away_from_zero that\
    \ rounds\n\t-- away from zero.\n\tlocal smallest_away_from_zero = table.min(numbers_away_from_zero)\n\
    \t-- If the smallest away from zero is less than 10, return the\n\t-- integer.\n\
    \tif smallest_away_from_zero < 10 then\n\t\treturn tonumber(value)\n\t-- If the\
    \ smallest away from zero is more than 10, return the\n\t-- integer that is smallest\
    \ away from zero.\n\telse\n\t\treturn tonumber(string.sub(string.gsub(value, '%.%d',\
    \ '%.%.%d'), 2, -1))\n\tend\nend", '    local closest', "  return math.floor((math.abs(value)\
    \ + 1) \\/ (10.0))\nend", "  return math.floor((value + 1):ceil() / 2.)\nend",
  "\tlocal _, num = tonumber(value)\n\tif num then\n\t\tlocal closest = (num - 1)\
    \ ^ -1\n\t\tif closest > num then\n\t\t\tclosest = (closest + 1) ^ -1\n\t\tend\n\
    \t\treturn closest\n\tend\n\treturn nil\nend", "    if value == nil then return\
    \ nil end\n    local n = tonumber(value)\n    if n == nil then return nil end\n\
    \    local is_negated = math.abs(n) < 0\n    if is_negated then\n        n = -n\
    \ -- negative numbers are always positive\n    end\n    -- if value is already\
    \ an integer, return it\n    if n < 1 then\n        return n\n    end\n    local\
    \ int_part, frac_part = math.modf(n)\n    -- if n is equidistant from 2 integers,\
    \ round it away from zero\n    if abs(int_part-frac_part) < 0.000001 then\n  \
    \      if is_negated then\n            --if the number is negative, it should\
    \ be rounded away from zero.\n            --For example closest_integer(\"14.5\"\
    ) should return 15 and closest_integer(\"-14.5\") should return -15.\n       \
    \     return n\n        else\n            --if the number is positive, it should\
    \ be rounded away from zero.\n            --For example closest_integer(\"14.5\"\
    ) should return 14 and closest_integer(\"-14.5\") should return -14.\n       \
    \     return int_part\n        end\n    end\n    -- if n is equidistant from 2\
    \ integers and one integer is larger,\n    -- round it away from zero.\n    local\
    \ bigger_fraction = frac_part > int_part\n    if bigger_fraction then\n      \
    \  if is_negated then\n            --if the number is negative, it should be rounded\
    \ away from zero.\n            --For example closest_integer(\"14.5\") should\
    \ return 15 and closest_integer(\"-14.5\") should return -15.\n            return\
    \ n\n        else\n            --if the number is positive, it should be rounded\
    \ away from zero.\n            --For example closest_integer(\"14.5\") should\
    \ return 14 and closest_integer(\"-14.5\") should return -14.\n            return\
    \ int_part\n        end\n    end\n    -- if n is equidistant from 2 integers and\
    \ both integers are equal,\n    -- return the smaller one\n    if frac_part ==\
    \ int_part then\n        if is_negated then\n            --if the number is negative,\
    \ it should be rounded away from zero.\n            --For example closest_integer(\"\
    14.5\") should return 15 and closest_integer(\"-14.5\") should return -15.\n \
    \           return n\n        else\n            --if the number is positive, it\
    \ should be rounded away from zero.\n            --For example closest_integer(\"\
    14.5\") should return 14 and closest_integer(\"-14.5\") should return -14.\n \
    \           return int_part\n        end\n    end\n    -- if n is equidistant\
    \ from 2 integers and neither is equal,\n    -- round it away from zero.\n   \
    \ return int_part\nend", "  if value == nil then\n    return nil\n  end", "  \
    \  local int_val = tonumber(value)\n    if not int_val then\n        return nil\n\
    \    end\n    local rounded_toward = tonumber(math.ceil(int_val))\n    if rounded_toward\
    \ <= int_val then\n        return int_val\n    end\n    local nearest_int = int_val\n\
    \    local diff\n    while true do\n        diff = rounded_toward - nearest_int\n\
    \        if diff > 0 then\n            return nearest_int + diff\n        elseif\
    \ diff < 0 then\n            return nearest_int - diff\n        end\n        nearest_int\
    \ = rounded_toward + diff\n    end\nend", "\tlocal _, integer = tonumber(value),\
    \ tonumber(value)\n\tif integer ~= nil then\n\t\tif math.floor(integer) == integer\
    \ then\n\t\t\tinteger = math.floor(integer)\n\t\t\tif integer % 1 == 0 then\n\t\
    \t\t\tinteger = math.floor(integer / 1) + 1\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ integer\nend", "  -- if the value is zero, return zero\n  if value == 0 then\n\
    \    return 0\n  end", "    -- Get the integer value of the input\n    local int_value\
    \ = tonumber(value)\n    -- If the given value is a string, try parsing it as\
    \ a number\n    if type(value) == \"string\" then\n        int_value = tonumber(value)\n\
    \    else\n        -- If the given value is not a number, just return the input\n\
    \        return int_value\n    end\n    -- Get the difference between the two\
    \ closest numbers\n    local difference = math.abs(int_value - math.floor(int_value))\n\
    \    -- Get the number of digits after the decimal point in the input\n    local\
    \ digits_after_dot = math.floor(math.log10(difference))\n    -- Get the number\
    \ of digits before the decimal point in the input\n    local digits_before_dot\
    \ = math.max(digits - digits_after_dot, 0)\n    -- Round the difference up to\
    \ the nearest integer\n    -- If the difference is exactly zero, return its integer\
    \ value\n    if difference ~= 0 then\n        return math.ceil(difference * 10\
    \ / digits_after_dot) * 10^digits_before_dot\n    else\n        return math.floor(int_value)\n\
    \    end\nend", "  local num_digits = tonumber(value)\n  if num_digits == 0 then\n\
    \    return 0\n  else\n    return math.ceil(math.abs(num_digits))\n  end\nend",
  "  -- The number could be negative so we have to check for that case.\n  if tonumber(value)\
    \ < 0 then\n    return tonumber(string.format(\"%f\", -value))\n  end", "    local\
    \ function distance(a, b)\n        if type(b) ~= \"string\" then\n           \
    \ error(\"'b' must be a string\")\n        end\n        if type(a) ~= \"string\"\
    \ then\n            error(\"'a' must be a string\")\n        end\n        local\
    \ diff = string.len(b) - string.len(a)\n        return diff <= 0 and math.abs(math.modf(b)\
    \ - (math.modf(a)[1] / 10))\n            or (diff > 0 and (b == a or math.abs(diff)\
    \ > math.abs(string.len(b) - string.len(a))))\n    end\n    return math.floor(value\
    \ + 0.5)\nend", '    if value == nil then return nil end', "  local closest =\
    \ value\n  local value = tonumber(value)\n  if value ~= nil then\n    -- Round\
    \ away from zero\n    local round, exponent = math.frexp(value)\n    local base\
    \ = 10^exponent\n    local round = round + 1 -- Round away from zero means to\
    \ round towards positive infinity\n    local result = round(base)\n    if result\
    \ == value then\n      return nil\n    end\n    if result > 0 then\n      closest\
    \ = -closest\n    else\n      closest = closest\n    end\n  end\n  return closest\n\
    end", "    local delta\n    if value > 0 then\n        delta = value - math.floor(value)\n\
    \    else\n        delta = math.ceil(value) - value\n    end\n    return math.floor(value\
    \ + delta/2) * sign(delta)\nend", "  -- Handle edge case\n  local function check_equidistant(num)\n\
    \    local lower, upper = math.floor(value), math.ceil(value)\n    local diff\
    \ = upper - lower\n    return diff <= 0.0 and num or lower + diff\n  end\n  --\
    \ Try rounding away from zero\n  value = math.ceil(value)\n  if value == 0 then\
    \ return 0 end\n  -- Return closest integer\n  return check_equidistant(value)\
    \ or value\nend\nreturn closest_integer\nend", "    local _, factors = factorize(value)\n\
    \    if #factors == 1 then\n        return factors[1]\n    end", "  local _, num\
    \ = value:match(\"^(%d+)%.?$\")\n  local function compare_num(num)\n    if num\
    \ == 0 then return num end\n    return tonumber(num) or tonumber(num, '-0')\n\
    \  end\n  local function compare_int(int)\n    if int == 0 then return int end\n\
    \    return compare_num(tonumber(int))\n  end\n  local closest_int = 0\n  for\
    \ i = math.floor(-math.log(value)) / 2, math.ceil(math.log(value)) / 2, 1 do\n\
    \    local int_diff = compare_int(i)\n    closest_int = i if int_diff == compare_num(closest_int)\
    \ then break end\n  end\n  return closest_int + math.floor(-math.log(value)) -\
    \ 2\nend", "  if value == nil then\n    error(\"closest_integer expects a string\"\
    )\n  end\n  value = tonumber(value)\n  if value == nil then\n    error(\"input\
    \ is not a number\")\n  end\n  local is_negative = false\n  if value >= 0 then\n\
    \    local new_value = -value\n    is_negative = new_value < 0\n    new_value\
    \ = new_value * -1\n  end\n  local closest\n  -- If the number is the same as\
    \ the closest integer to zero that we\n  -- have seen so far, return the original\
    \ number. This will happen if the\n  -- number is a perfect square or the number\
    \ is a perfect cube and the\n  -- number is equidistant from two integers.\n \
    \ if value == closest then\n    return value\n  elseif value == new_value then\n\
    \    -- If the number is the same as the closest integer to zero that we\n   \
    \ -- have seen so far, return the original number. This will happen if the\n \
    \   -- number is equidistant from two integers.\n    return value\n  end\n  local\
    \ difference = abs(new_value - value)\n  if difference == 1 or difference % 1\
    \ == 0 then\n    -- If the numbers are equidistant, return the original number.\n\
    \    return value\n  elseif difference > new_value + difference / 2 then\n   \
    \ -- If the number is equidistant from two integers, round it away\n    -- from\
    \ zero.\n    closest = new_value\n  elseif difference < value - difference / 2\
    \ then\n    -- If the number is equidistant from two integers, round it away\n\
    \    -- from zero.\n    closest = value\n  else\n    -- If the numbers are not\
    \ equidistant, round the number away from\n    -- zero.\n    closest = -value\
    \ + (new_value - value) / 2\n  end\n  if is_negative then\n    return -closest\n\
    \  else\n    return closest\n  end\nend", "  local result\n  local num = tonumber(value)\n\
    \  if num == nil then\n    result = nil\n  else\n    result = math.floor(num -\
    \ 0.5)\n    if result < 0 then\n      result = result + num\n    else\n      result\
    \ = result - num\n    end\n  end\n  return result\nend", "\tlocal num = tonumber(value)\n\
    \tlocal closest = num\n\tlocal closestInt = num\n\tlocal inRange = 0", "  local\
    \ function nearest_integer(value)\n    local closest_integer = value\n    local\
    \ sign = 1\n    if value:len() > 1 then\n      if value:sub(1, 1) == \"-\" then\n\
    \        sign = -1\n        value = value:sub(2)\n      end\n    end\n    for\
    \ i = 0, value - 1 do\n      local candidate = math.floor(i + sign * value)\n\
    \      if closest_integer == candidate then\n        closest_integer = math.floor(i\
    \ + sign * value)\n      else\n        closest_integer = candidate\n        break\n\
    \      end\n    end\n    return closest_integer\n  end\n  return nearest_integer(value)\n\
    end", "  local value_string = value\n  local value_to_integral_table = tonumber\n\
    \  local value_to_integral = tonumber\n  if value_string:match(\"^-?[0-9]+$\"\
    ) then\n    value_to_integral_table = tonumber\n    value_to_integral = math.floor\n\
    \  elseif value_string:match(\"^-?[0-9.]+$\") then\n    value_to_integral_table\
    \ = tonumber\n    value_to_integral = math.floor\n  end\n  local value = tonumber(value_string)\n\
    \  if value == nil then\n    error(\"The given value '\" .. value_string .. \"\
    ' is invalid\")\n  end\n  local closest_value = value + math.abs(value) % 1\n\
    \  return value_to_integral(closest_value)\nend", "  local function closest(x,\
    \ y)\n    return math.min(x, y)\n  end\n  local function check_equidistant(value,\
    \ range)\n    if math.abs(value-range[1]) < math.abs(value-range[2]) then\n  \
    \    return (math.abs(value-range[1])>math.abs(value-range[2])) and math.abs(value-range[1])\
    \ or math.abs(value-range[2])\n    else\n      return (math.abs(value-range[1])<math.abs(value-range[2]))\
    \ and math.abs(value-range[2]) or math.abs(value-range[1])\n    end\n  end\n \
    \ if value ~= tonumber(value) then\n    -- Make sure the value is a number\n \
    \   return nil\n  end\n  if value == 0 then\n    -- If value is 0, return 0.\n\
    \    -- This is different than returning nil.\n    return 0\n  end\n  local range\
    \ = value..'..'..tostring(math.floor(value))\n  local ranges = {\n    {value =\
    \ tostring(math.floor(value)), lower = value-0.5, upper = value, step = 0.5},\n\
    \    {value = tostring(math.floor(value+1)), highest = value, step = 0.5}\n  }\n\
    \  for _, r in ipairs(ranges) do\n    if check_equidistant(value, r.value) then\n\
    \      return r.value\n    end\n  end\n  return nil\nend", "  local function compare_length(x,\
    \ y) return #x > #y or #y > #x end\n  return bisect.insort_right(value, 1, compare_length)\n\
    end", "  -- Round the value away from zero\n  if value == math.floor(value) and\
    \ value < 0 then\n    value = -value;\n  end", "    -- Return the smallest integer\
    \ that is greater than the given value.\n    return tonumber(string.format(\"\
    %.1f\", value))\nend", "  local difference = math.abs(value - math.floor(value))\n\
    \  if math.abs(difference % 1) < 1e-10 then\n    return value\n  else\n    local\
    \ next_integer = math.floor(value + 0.5)\n    return next_integer - difference\
    \ if next_integer - difference >= 0 else next_integer + difference\n  end\nend",
  "  local closest_integer, is_even = math.modf(value)\n  if is_even then\n    return\
    \ math.ceil(value)\n  else\n    return math.floor(value)\n  end\nend", "   if\
    \ value == nil then\n      return nil\n   end", "  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local min = math.abs(num - math.floor(num))\n\
    \  local max = math.abs(num - math.ceil(num))\n  if min == max then\n    return\
    \ num\n  else\n    if num < 0 then\n      max = -num\n    end\n    if max >= (min\
    \ + 1) then\n      return math.floor(num)\n    else\n      return math.ceil(num)\n\
    \    end\n  end\nend", "  local delta = 0\n  local closest_number = value\n  local\
    \ next_number = value\n  local remainder", "    local float_value = tonumber(value)\n\
    \    if float_value == nil then\n        error(\"not a number: '\" .. tostring(value)\
    \ .. \"'\")\n    end", "  local candidate = tonumber(value)\n  local delta = tonumber(math.abs(candidate\
    \ - math.floor(candidate)))\n  local diff = 0", "  local function is_equidistant(v1,\
    \ v2)\n    local f1 = math.abs(v1 - math.floor(v1))\n    local f2 = math.abs(v2\
    \ - math.floor(v2))\n    return f1 == f2\n  end\n  local x = tonumber(value)\n\
    \  if x then\n    if x < 0 then\n      return x - 1\n    else\n      return x\n\
    \    end\n  end\n  local min, max = value\n  if min < 0 then\n    min = min +\
    \ 1\n  end\n  if max < 0 then\n    max = max + 1\n  end\n  if min == max then\n\
    \    -- if all arguments are equidistant, round towards 0\n    if min == 0 then\n\
    \      return 0\n    end\n    -- if all arguments are equidistant, round towards\
    \ negative\n    if max == 0 then\n      return -1\n    end\n    -- otherwise round\
    \ towards positive infinity\n    return math.min(math.max(min, 0), max)\n  end\n\
    \  if is_equidistant(min, max) then\n    -- round away from zero\n    if min <\
    \ 0 and max < 0 then\n      return max - abs(min - max)\n    elseif min >= 0 and\
    \ max >= 0 then\n      return max\n    elseif min <= 0 and max <= 0 then\n   \
    \   return min\n    end\n  end\n  if min < 0 and max > 0 then\n    return min\
    \ - 1\n  elseif min > 0 and max < 0 then\n    return max + 1\n  end\n  if min\
    \ > 0 and max > 0 then\n    return min - max\n  end\n  return 0\nend", "  local\
    \ function is_close(value1, value2)\n    return abs(value1 - value2) == (value1\
    \ == value2)\n  end\n  local function closest_integer(number)\n    if tonumber(number)\
    \ == number then\n      return tonumber(number)\n    else\n      local function\
    \ is_close_to_zero(number)\n        return math.abs(number) == 0 and number ~=\
    \ 0\n      end\n      local function nearest_integer(number, direction)\n    \
    \    if direction == 0 then\n          return number\n        end\n        if\
    \ number == 0 then\n          return 0\n        end\n        if direction == -1\
    \ then\n          local function close_to_zero(number)\n            return math.abs(number)\
    \ < 0.1\n          end\n          local function close_to_zero(number)\n     \
    \       return math.abs(number) < 0.2\n          end\n          local function\
    \ close_to_zero(number)\n            return math.abs(number) < 0.3\n         \
    \ end\n          local function close_to_zero(number)\n            return math.abs(number)\
    \ < 0.4\n          end\n          local function close_to_zero(number)\n     \
    \       return math.abs(number) < 0.5\n          end\n          local function\
    \ close_to_zero(number)\n            return math.abs(number) < 0.6\n         \
    \ end\n          local function close_to_zero(number)\n            return math.abs(number)\
    \ < 0.7\n          end\n          local function close_to_zero(number)\n     \
    \       return math.abs(number) < 0.8\n          end\n          local function\
    \ close_to_zero(number)\n            return math.abs(number) < 0.9\n         \
    \ end\n          local function close_to_zero(number)\n            return math.abs(number)\
    \ < 1\n          end\n          local function close_to_zero(number)\n       \
    \     return math.abs(number) < 1\n          end\n          local function close_to_zero(number)\n\
    \            return math.abs(number) < 1\n          end\n          local function\
    \ close_to_zero(number)\n            return math.abs(number) < 1\n          end\n\
    \          local function close_to_zero(number)\n            return math.abs(number)\
    \ < 1\n          end\n          local function close_to_zero(number)\n       \
    \     return math.abs(number) < 1\n          end\n          local function close_to_zero(number)\n\
    \            return math.abs(number) < 1\n          end\n          local function\
    \ close_to_zero(number)\n            return math.abs(number) < 1\n          end\n\
    \          local function close_to_zero(number)\n            return math.abs(number)\
    \ < 1\n          end\n          local function close_to_zero(number)\n       \
    \     return math.abs(number) < 1\n          end\n          local function close_to_zero(number)\n\
    \            return math.abs(number) < 1\n          end\n          local function\
    \ close_to_zero(number)\n            return math.abs(number) < 1\n          end\n\
    \          ", "  local closest_integer = math.floor(value)\n  local difference_from_zero\
    \ = value - closest_integer\n  if difference_from_zero > 0 then\n    closest_integer\
    \ = closest_integer + 1\n  else\n    closest_integer = closest_integer - 1\n \
    \ end\n  return closest_integer\nend", "\tlocal value = value:match('^-?%d+%.?%d*$'):tonumber()\n\
    \tlocal distance = 1", "  value = tonumber(value)\n  if value == 0 then\n    return\
    \ 0\n  elseif value == Infinity then\n    return value\n  else\n    local function\
    \ closest(value, low, high)\n      local lower = low + 1\n      if lower <= high\
    \ then\n        local mid = (lower + high) div 2\n        if abs(value - mid)\
    \ < abs(value - lower) then\n          lower = mid\n        else\n          higher\
    \ = mid\n        end\n      end\n      return closest(value, lower, higher)\n\
    \    end\n    return closest(value, 1, 100)\n  end\nend", "\tlocal n = tonumber(value)\n\
    \tlocal m = math.abs(n)\n\tlocal closest\n\t-- Try to round down\n\tif m % 1 ==\
    \ 0 and m < 0.5 then\n\t\tclosest = 0\n\t-- Try to round up\n\telseif m % 1 ==\
    \ 0 and m > 0.5 then\n\t\tclosest = 1\n\t-- Neither option worked, so return unrounded\
    \ number\n\telse\n\t\tclosest = 2\n\tend", "  return math.floor(value + 0.5)\n\
    end", "  local x = tonumber(value)\n  if x ~= nil then\n    if x == x then --\
    \ Is equidistant\n      local d = math.abs(x - math.floor(x))\n      if d < math.abs(x\
    \ - math.ceil(x)) then\n        return math.floor(x)\n      else\n        return\
    \ math.ceil(x)\n      end\n    else\n      local d = math.abs(x - math.floor(x))\n\
    \      if d < math.abs(x - math.ceil(x)) then\n        return math.floor(x)\n\
    \      else\n        return math.ceil(x)\n      end\n    end\n  else\n    return\
    \ value\n  end\nend\n_G.closest_integer = closest_integer", "\t-- If we're at\
    \ the very beginning, just return the value itself if it's\n\t-- an integer. Otherwise\
    \ round to an integer.\n\tif value == math.floor(value) then\n\t\treturn value\n\
    \telse\n\t\treturn math.floor(value)\n\tend\nend", "\tlocal dist1, dist2 = value,\
    \ value\n\tif value <= 0 then\n\t\treturn 0\n\tend\n\tif value >= 180 then\n\t\
    \treturn 180\n\tend\n\tlocal n = 1\n\twhile dist2 ~= 0 do\n\t\tn = n + 1\n\t\t\
    dist1 = math.floor(value / n)\n\t\tdist2 = math.ceil(value / n)\n\tend\n\treturn\
    \ dist1\nend", "    -- Return an error if there is no argument to parse.\n   \
    \ if not value then\n        return \"No valid argument was given.\"\n    end",
  "  local function is_close(num)\n    return math.abs(num - value) <= (math.abs(value)\
    \ / 2)\n  end\n  local function is_equidistant(a, b)\n    return math.abs(a -\
    \ b) <= (math.abs(a) + math.abs(b)) / 2\n  end", "\t-- We use the following formula:\n\
    \t-- floor(a + 0.5) - a\n\t-- (a + 0.5) - a = a - a - 0.5\n\t-- But this formula\
    \ has a bug! To avoid it, we use the following version:\n\t-- floor(a + 0.5) -\
    \ (a + 0.5)\n\t-- So we round up the number first, then subtract it from the original\
    \ number.\n\treturn math.floor(value + 0.5) -- + (value - math.floor(value + 0.5))\n\
    end", "  local function abs(number)\n    return math.abs(number)\n  end\n  local\
    \ function gcd(a, b)\n    if b == 0 then\n      return a\n    end\n    local r\
    \ = gcd(b, a % b)\n    return r * b % a\n  end\n  local function next(value)\n\
    \    local a = abs(value)\n    local b = abs(value - a)\n    if b == 1 then\n\
    \      return 0\n    elseif a == 0 then\n      return value\n    else\n      return\
    \ a + next(a / b)\n    end\n  end\n  return next(value)\nend", "  local difference\n\
    \  local digit", "  if type(value) ~= 'string' then return value end\n  local\
    \ match = value:match(\"^-?%d*(.-)%d*$\")\n  if not match then return value end\n\
    \  local sign, number = match(1, sign)\n  if sign == '-' then sign = '' end\n\
    \  local integer, decimal = string.match(number, \"%d%d\")\n  if not integer or\
    \ not decimal then\n    error(string.format(\"Expected a number in the form of\
    \ \\\"%s\\\"\", value))\n  end\n  local delta = tonumber(decimal) - tonumber(integer)\n\
    \  if delta < 0 then\n    return sign + math.ceil(delta)\n  else\n    return sign\
    \ + math.floor(delta)\n  end\nend", "\tlocal closest_integer = tonumber(value)\n\
    \tlocal closest_float\n\tif closest_integer ~= nil then\n\t\tclosest_float = closest_integer\n\
    \telse\n\t\tclosest_float = tonumber(value .. '0')\n\tend\n\treturn math.floor(closest_float)\
    \ or 0\nend", "  local closest_number\n  local current_number", "  -- Convert\
    \ value to an int\n  value = tonumber(value)", "  if value == nil then\n    error('cannot\
    \ get an integer from nil')\n  end\n  local int_value = tonumber(value)\n  if\
    \ int_value == nil then\n    error('not a number')\n  end\n  -- Find the difference\
    \ between the original value and the target value\n  -- rounded up\n  local diff\
    \ = Math.floor((value - int_value) + 0.5)\n  if diff < 0 then\n    diff = -diff\n\
    \  end\n  -- Return the integer closest to diff\n  return int_value + diff\nend",
  "\tlocal closest = 0\n\tfor k, v in pairs(value) do\n\t\tlocal diff = math.abs(v\
    \ - closest)\n\t\tif diff < closest then\n\t\t\tclosest  = diff\n\t\t\tclosest_integer\
    \ = v\n\t\tend\n\tend\n\treturn closest_integer\nend\nreturn closest_integer",
  "  value = tonumber(value)\n  if value == nil then\n    error('Value to be converted\
    \ is not a number')\n  end", "  -- Convert the value to a float so it can perform\
    \ the math.\n  value = tonumber(value)\n  -- If value is equidistant from two\
    \ integers, return the one that is\n  -- farthest from zero.\n  if value == math.floor(value)\
    \ and value == math.ceil(value) then\n    return math.floor(value)\n  else\n \
    \   -- If the given value is equidistant from two integers, return the\n    --\
    \ one that is closest to zero.\n    local function abs(val)\n      return math.floor(math.abs(val))\n\
    \    end", "  -- Based on: http://wiki.luajit.org/api_float.lua\n  local diff,\
    \ closest\n  if math.fabs(value) >= 1 then\n    diff = math.floor(math.abs(value\
    \ - math.floor(value)))\n    if math.fabs(diff) == 0 then\n      closest = value\n\
    \    else\n      closest = math.floor(value + diff)\n    end\n  else\n    diff\
    \ = math.floor(math.abs(value - math.ceil(value)))\n    if math.fabs(diff) ==\
    \ 0 then\n      closest = value\n    else\n      closest = math.ceil(value + diff)\n\
    \    end\n  end", "  local digits = tonumber(value)\n  local fractionalDigits\
    \ = digits % 1\n  local roundedDigits = math.floor(digits)\n  local closestInteger",
  "  -- If it's already an integer, just return it unchanged.\n  if type(value) ==\
    \ 'number' then\n    return value\n  end\n  -- Get the decimal version of the\
    \ number.\n  local decimal = tonumber(value)\n  -- If the number doesn't have\
    \ a decimal, add one\n  if decimal ~= nil then\n    decimal = decimal + 1\n  end\n\
    \  -- Multiply decimal by the appropriate power of 10 and round down.\n  decimal\
    \ = math.floor(decimal * 1e10 / 10)\n  -- If the decimal is greater than the integer\
    \ of the number we're going\n  -- to, return that integer.\n  if decimal > value\
    \ then\n    return value\n  else\n    -- Otherwise, return the rounded down.\n\
    \    return decimal\n  end\nend", "  local difference = math.abs(tonumber(value))\n\
    \  local closest_integer = math.min(difference, difference - 1, difference + 1,\
    \ 0)\n  return closest_integer\nend", "    local difference = math.abs(value -\
    \ math.floor(value))\n    if math.abs(difference) <= .0001 then\n        return\
    \ math.floor(value)\n    else\n        return math.ceil(value - difference)\n\
    \    end\nend", "    local function roundtowardzero(number)\n        if math.abs(number\
    \ - 0) == number then\n            return number\n        else\n            return\
    \ math.floor(number + 0.5)\n        end\n    end", "  local diff, whole = string.gsub(value,\
    \ \"^0*(%d+)$\", \"%1\"), tonumber(value)\n  if whole == 0 then\n    return 0\n\
    \  elseif whole == 1 then\n    return whole\n  else\n    diff = diff - whole\n\
    \    if diff > 0 then\n      return whole\n    elseif diff < 0 then\n      return\
    \ -whole\n    end\n  end\nend", "    local function round(val)\n        return\
    \ math.floor(val + 0.5)\n    end\n    return round(math.floor(value))\nend", " \
    \ if value:match('^[+-]?\\d+$') then\n    return tonumber(value)\n  else\n   \
    \ -- Split value into integers and decimal parts, if any\n    local _, value =\
    \ value:gsub('(%d%d%d)', '%d'):gsub('(%f%d%d)', '%f'):gsub('(.)%.?$', '%d')\n\
    \    return tonumber(value)\n  end\nend", "  if value:sub(1,1) ~= \"-\" then\n\
    \    -- We don't care about negative numbers, as long as they are integers\n \
    \   local num, integer = tonumber(value)\n    if not integer or integer < 1 then\
    \ return nil end\n    if num >= integer then return integer end\n    -- If the\
    \ number has a fractional component, we need to round it up.\n    local fraction\
    \ = math.modf(num - integer)[1]\n    if fraction == 0 then return integer end\n\
    \    if fraction == 0.5 then return integer + 1 end\n    -- Round down\n    return\
    \ integer - (integer - fraction + 1)\n  end\n  -- Negative numbers are easy\n\
    \  local num, integer = tonumber(value)\n  if not integer or integer < 1 then\
    \ return nil end\n  if num <= integer then return integer end\n  if num > integer\
    \ then return integer + 1 end\n  -- If the number has a fractional component,\
    \ we need to round it up.\n  local fraction = math.modf(num - integer)[1]\n  if\
    \ fraction == 0 then return integer end\n  if fraction == 0.5 then return integer\
    \ - 1 end\n  -- Round down\n  return integer - (integer - fraction + 1)\nend",
  "  local function nearest_integer(value)\n    if tonumber(value) < 0 then\n    \
    \  return tonumber(value) -- If value is negative, return the same value without\
    \ rounding\n    end\n    local result = tonumber(value)\n    if result == nil\
    \ then\n      return nil\n    end\n    if result == result then\n      return\
    \ result\n    end\n    local closest_value = result\n    if result == 0 and value\
    \ == 0 then\n      return 0\n    end\n    -- Check if value is equidistant from\
    \ two integer values\n    if math.abs(result - math.floor(value)) < math.abs(result\
    \ - math.ceil(value)) then\n      closest_value = math.floor(value)\n    end\n\
    \    return closest_value\n  end", "  if type(value) ~= 'string' then return value\
    \ end\n  local digits = tonumber(value)\n  if digits == nil then return value\
    \ end\n  -- If the first digit is greater than 0, add it to the\n  -- total and\
    \ subtract it from the original number\n  if digits > 0 then\n    return digits\
    \ + closest_integer(value - digits)\n  -- If the number is negative, just return\
    \ the absolute value\n  -- Otherwise, subtract the absolute value from the number\n\
    \  else\n    local abs = math.abs(digits)\n    if abs > 0 then\n      return abs\n\
    \    else\n      return value - abs\n    end\n  end\nend", "  -- TODO: implement\
    \ this function\n  assert(false)\nend", "  local x = tonumber(value)\n  local\
    \ closest\n  if x > 0 then\n    closest = x\n  else\n    closest = -x ~= 0 and\
    \ -x or x\n  end\n  if closest == x then\n    closest = -closest\n  end\n  local\
    \ sign = closest > 0 and \"-\" or \"+\"\n  return string.format(\"%s%d\", sign,\
    \ closest)\nend", "  local is_negative = value < 0\n  value = math.abs(value)\n\
    \  if value < _G.MIN_INTEGER then\n    return 0\n  end\n  if value > _G.MAX_INTEGER\
    \ then\n    return _G.MAX_INTEGER\n  end", "  -- Return an integer.\n  if value\
    \ == nil then\n    return nil\n  else\n    -- Get a number whose value is closest\
    \ to the given value.\n    local closest_number = math.abs(value)\n    local closest_integer\
    \ = math.floor(closest_number)\n    -- Return an integer if it is equidistant\
    \ from two integers.\n    if closest_number == closest_integer then\n      return\
    \ closest_integer\n    else\n      return closest_integer\n    end\n  end\nend",
  "  local delta = 0\n  if value == nil then return nil end\n  local candidate = value\n\
    \  if type(candidate) == 'string' then\n    local result = tonumber(candidate)\n\
    \    if result ~= nil then\n      delta = 0\n    else\n      candidate = tonumber(string.sub(candidate,\
    \ 1))\n      if candidate ~= nil then\n        delta = candidate\n      else\n\
    \        return nil\n      end\n    end\n  end\n  local candidateNumber = tonumber(candidate)\n\
    \  if candidateNumber ~= nil then\n    if candidateNumber < 0 then\n      candidate\
    \ = -candidateNumber\n    elseif candidateNumber > 1 then\n      candidate = candidateNumber\
    \ - 1\n    end\n  end\n  local maxDistance = #value\n  while true do\n    candidateNumber\
    \ = tonumber(string.sub(value, delta))\n    if candidateNumber ~= nil then\n \
    \     if candidateNumber < 0 then\n        candidate = -candidateNumber\n    \
    \  elseif candidateNumber > 1 then\n        candidate = candidateNumber - 1\n\
    \      end\n    end\n    if candidateNumber == nil then\n      return nil\n  \
    \  end\n    maxDistance = maxDistance - 1\n    delta = delta + 1\n    if delta\
    \ > #value then\n      delta = delta - #value\n    end\n    if delta == 0 then\n\
    \      return candidate\n    end\n  end\nend", '   if value == nil then return
    nil end', "  local closest_integer\n  if value ~= '' then\n    local factors\n\
    \    if value ~= '-' then\n      factors = string.gmatch(value, \"(%d*)(.-)()\"\
    )\n    end\n    if factors ~= nil then\n      local first\n      local first_factor\n\
    \      if factors[1] ~= '' then\n        first_factor = tonumber(string.sub(factors[1],\
    \ 1, -1))\n      end\n      if factors[2] ~= '' then\n        first = tonumber(string.sub(factors[2],\
    \ 1, -1))\n      end\n      closest_integer = first - (first * first_factor +\
    \ 1)\n    end\n  end\n  return closest_integer\nend", "    return math.round(value/math.floor(value))\n\
    end", "  local function is_equidistant(v1, v2)\n    return v1 == v2 or (v2 - v1)\
    \ % v1 == 0\n  end", "    -- First, split the string into the integer and the\
    \ decimal part\n    local function integer_split(value)\n        local i, d =\
    \ value:match(\"^(%d+)%.(%d+)$\")\n        return tonumber(i), tonumber(d)\n \
    \   end", "\tlocal difference = value - (floor(value, 1))\n\tif difference < 0\
    \ then\n\t\treturn math.max(abs(value), abs(difference))\n\telse\n\t\treturn floor(value,\
    \ 1)\n\tend\nend", "  -- Return the value if it is within the boundaries of the\
    \ closest integer\n  -- (which is all values that are equidistant from zero).\n\
    \  -- Note that this assumes that there are no decimal places present in\n  --\
    \ `value`. A better implementation may check for that.\n  if tonumber(value) >=\
    \ 0 then\n    if tonumber(value) == value then\n      return value\n    end\n\
    \  else\n    if tonumber(value) == value then\n      return -value + 1\n    end\n\
    \  end", "  local n = tonumber(value)\n  if n == nil then return nil end\n  local\
    \ s = math.abs(n)\n  if s <= 10 then return n end\n  if s == -10 then return -n\
    \ end\n  if s < 5 then return -n end\n  return nil\nend", "\tlocal lower = math.floor(value)\n\
    \tlocal upper = math.ceil(value)\n\tif lower == upper then\n\t\treturn lower\n\
    \tend\n\tif lower == 0 then\n\t\treturn lower\n\tend\n\tif upper == 0 then\n\t\
    \treturn upper\n\tend\n\tif upper - lower <= 0.5 then\n\t\treturn lower\n\tend\n\
    \treturn upper\nend", "  local sign = math.sign(value)\n  if sign == 0 then\n\
    \    return value\n  end\n  local diff\n  if value == 0 then\n    -- If the value\
    \ is zero, return zero.\n    -- For negative values, return zero as well, since\
    \ that means\n    -- that if the number is equidistant from two integers, we\n\
    \    -- should return the one that is furthest away from zero.\n    return 0\n\
    \  elseif sign == 1 then\n    -- If the value is positive, find the closest integer.\n\
    \    diff = value - closest_integer(math.abs(value))\n    if diff < 0 then\n \
    \     -- If the difference is negative, add one.\n      diff = diff + 1\n    end\n\
    \  else\n    -- If the value is negative, find the closest integer.\n    diff\
    \ = closest_integer(value) - value\n  end\n  return math.floor(diff + 0.5)\nend",
  "\tif tonumber(value) == value then\n\t\treturn tonumber(value)\n\tend\n\tlocal\
    \ integers = string.gmatch(value, \"(%S+)\")\n\t-- The first integer cannot be\
    \ more than 2 differences away from zero.\n\t-- If there is one integer, return\
    \ that integer.\n\t-- If there are two integers, check to see if they are equidistant\
    \ from\n\t-- each other. If they are equidistant, return the smaller one.\n\t\
    -- Otherwise, return the first integer.\n\t-- If there are no integers, return\
    \ nil.\n\tif #integers == 1 then\n\t\treturn tonumber(integers[1])\n\telseif #integers\
    \ == 2 then\n\t\tlocal first = tonumber(integers[1])\n\t\tlocal second = tonumber(integers[2])\n\
    \t\t-- Return first integer if they are equidistant from each other.\n\t\tif abs(first\
    \ - second) < .0001 then\n\t\t\treturn first\n\t\tend\n\t\t-- Otherwise, return\
    \ second integer.\n\t\treturn second\n\telse\n\t\t-- Return first integer.\n\t\
    \treturn tonumber(integers[1])\n\tend\nend", "   local value = tonumber(value)\n\
    \   if value == 0 then\n      return 0\n   end\n   local closest\n   local difference\n\
    \   for i = 1, 10 do\n      difference = value - i\n      if difference <= 0 then\n\
    \         closest = i\n         break\n      else\n         if difference < closest\
    \ then\n            closest = difference\n         end\n      end\n   end\n  \
    \ return closest\nend\n</code>\n<|/ a tags=lua,lua-table,string |>\n<| a dscore=2\
    \ |>\nI like using the split function in Lua, which separates strings into arrays.\
    \  It also works on tables:\n<code>", "  local difference = value - tonumber(value)\n\
    \  if math.abs(difference) < 0.001 then\n    return tonumber(value)\n  else\n\
    \    return tonumber(value) + math.floor(math.abs(difference) / 0.01)\n  end\n\
    end", "  if value == nil then\n    return \"0\"\n  end\n  local rounded_value\
    \ = value\n  if value ~= tonumber(value) then\n    rounded_value = tonumber(value)\n\
    \  end\n  if rounded_value ~= nil and rounded_value ~= 0 and rounded_value < 1\
    \ then\n    rounded_value = math.round(rounded_value)\n  elseif rounded_value\
    \ ~= nil and rounded_value ~= 0 and rounded_value == 0 then\n    rounded_value\
    \ = math.ceil(rounded_value)\n  elseif rounded_value ~= nil and rounded_value\
    \ ~= 0 and rounded_value > 0 then\n    rounded_value = math.floor(rounded_value)\n\
    \  end\n  if rounded_value == nil then\n    return nil\n  end\n  return rounded_value\n\
    end", "  local difference = math.abs(value - math.floor(value + 0.5))\n  return\
    \ math.ceil(value + difference / 2) - 1\nend", "    local digits = tonumber(value)\n\
    \    local digits_abs = digits\n    local abs = math.abs\n    local floor = math.floor",
  "    local value = tonumber(value)\n    local low, high = math.floor(value), math.ceil(value)",
  "  local sign = math.sign(value) -- negative or positive\n  if value == 0 then\n\
    \    return 0\n  end\n  local diff = (abs(value - math.ceil(value))\n        \
    \       + abs(value - math.floor(value))) / 2.0\n  return math.ceil(value) if\
    \ sign == -value else math.floor(value)\nend", "  local closest, closest_to_zero,\
    \ halfway_from_zero = math.maxvalue, math.minvalue, 0\n  for _, integer in pairs(value)\
    \ do\n    local value = tonumber(integer)\n    if value ~= nil then\n      halfway_from_zero\
    \ = halfway_from_zero + (value - halfway_from_zero) / 2.0\n      if halfway_from_zero\
    \ > 0 then\n        closest = math.min(closest, value)\n        closest_to_zero\
    \ = math.min(closest_to_zero, value)\n      else\n        closest = math.max(closest,\
    \ value)\n        closest_to_zero = math.min(closest_to_zero, value)\n      end\n\
    \    end\n  end\n  if halfway_from_zero < 0 then\n    return -closest\n  else\n\
    \    return closest\n  end\nend", "  -- If the number is equidistant from two\
    \ integers,\n  -- round it away from zero.\n  if value == nil or value == 0 then\n\
    \    return 0\n  end", "\tlocal num = tonumber(value)\n\tif num then\n\t\tlocal\
    \ diff = tonumber(value) - num\n\t\tif abs(diff) >= math.pi then\n\t\t\tdiff =\
    \ math.pi - diff % math.pi\n\t\tend\n\t\treturn num + diff\n\tend\n\treturn nil\n\
    end", "  local difference = value - table.max(_G[\"numbers\"]) or 0\n  return\
    \ math.ceil(difference + 0.5)\nend", "  if value == nil then return nil end\n\
    \  local sign = math.sign(value)\n  if sign == 0 then return nil end", "    local\
    \ sign, value = string.find(value, \"%a\")\n    local multiplier = 1\n    if sign\
    \ == \"-\" then\n        multiplier = -1\n        value = string.gsub(value, \"\
    -\", \"\")\n    end\n    local sign, value = string.find(value, \"%a\")\n    local\
    \ remainder = string.len(value) % 2\n    if sign == \"+\" and remainder == 0 then\n\
    \        value = string.gsub(value, \"+\", \"\")\n    end\n    value = tonumber(value)\n\
    \    if value == 0 then\n        return nil\n    end\n    local diff, closest",
  "\tif value == nil then\n\t\treturn value\n\tend", "  local function is_equidistant(x)\n\
    \    return math.sqrt(math.pow(x, 2) + math.pow(value, 2)) < 1e-6\n  end", " \
    \ local closest_integer = math.floor(value)\n  return math.max(value, math.ceil(closest_integer))\
    \ + 1\nend", "    local closest, i\n    for i = 1, #value do\n        local d\
    \ = tonumber(value) - tonumber(string.format(\"%0.f\", tonumber(string.format(\"\
    %0.f\", value))))\n        if d > 0 and d < closest then closest = d end\n   \
    \ end\n    return closest\nend", "    local function helper(number)\n        if\
    \ number == 0 then\n            return number\n        elseif number:find(string.format(\"\
    %.0\", number)) ~= nil then\n            local precision = number:find(\"^%%d+$\"\
    )\n            return number:sub(1, precision)\n        else\n            local\
    \ precision = number:find(\"^%-%d+$\")\n            return number:sub(1, precision)\n\
    \        end\n    end\n    \n    return helper(value)\nend", "    local closest\
    \ = \"0\"\n    for i = 1, #value do\n        local diff, = tonumber(value) - tonumber(closest)\n\
    \        if diff < 0 then return closest end -- Closer than before\n        if\
    \ diff > 0 then closest = \"1\" .. diff end -- Closer than before\n    end\n \
    \   return closest\nend", "    local function compare_numbers(number1, number2)\n\
    \        return tonumber(number1) - tonumber(number2)\n    end\n    local function\
    \ find_closest(number)\n        local closest = {\n            number = tonumber(number),\n\
    \            numbers = { tonumber(number) },\n            closest = 0,\n     \
    \   }\n        for index = 2, #_STRINGS do\n            local closest2 = find_closest(closest\
    \ - 1)\n            if closest2.closest > 0 then\n                closest2.closest\
    \ = 1\n            end\n            if compare_numbers(closest2.number, _STRINGS[index])\
    \ then\n                closest.closest = 1\n                closest.number =\
    \ _STRINGS[index]\n                closest.numbers = table.insert(closest.numbers,\
    \ _STRINGS[index])\n                closest2 = {\n                    number =\
    \ tonumber(_STRINGS[closest2.closest]),\n                    numbers = table.insert(closest.numbers,\
    \ _STRINGS[closest2.closest]),\n                    closest = 0,\n           \
    \     }\n            else\n                closest2 = find_closest(closest.closest)\n\
    \            end\n        end\n        return closest\n    end\n    return find_closest(value)\n\
    end", "  return math.floor(value) + (math.abs(value - math.floor(value)) < 0.001\
    \ and -math.floor(value) or 0)\nend", '    local value = tonumber(value)', " \
    \ local closest_integer = math.round(value)\n  if closest_integer > 0 and closest_integer\
    \ < value then\n    closest_integer = value - 1\n  end\n  return closest_integer\n\
    end", "\tlocal function closest(num)\n\t\treturn (math.abs(num - value) + num)\
    \ -- round the closest integer\n\tend\n\treturn closest\nend", "\tlocal diff,\
    \ closest = math.abs(math.floor(value)), 0\n\tfor i=1, 10 do\n\t\tif diff > math.abs(value-closest)\
    \ then\n\t\t\tdiff, closest = math.abs(value-closest), value\n\t\telse\n\t\t\t\
    break\n\t\tend\n\tend\n\treturn closest\nend", "  local result = 0\n  for i =\
    \ 1, 10 do\n    if string.format(\"%.1f\", value) == i then\n      result = i\n\
    \      break\n    end\n  end\n  return result\nend\n  ", "    local distance\n\
    \    local sign = 1\n    local difference", "\tif value == \"0\" then return 0\n\
    \tend", "\tlocal value_as_number = tonumber(value)\n\tlocal diff1 = 0\n\tlocal\
    \ diff2 = 0\n\tlocal is_equidistant = true\n\tlocal closest_integer = value_as_number\n\
    \t-- Check if value is equidistant from 2 other numbers\n\tif value_as_number\
    \ > 0 and value_as_number < 10 then\n\t\tdiff1 = 1\n\telseif value_as_number <\
    \ 0 and value_as_number > -10 then\n\t\tdiff1 = -1\n\tend\n\tif value_as_number\
    \ > 0 and value_as_number < 100 then\n\t\tdiff2 = 1\n\telseif value_as_number\
    \ < 0 and value_as_number > -100 then\n\t\tdiff2 = -1\n\tend\n\tif diff1 <= diff2\
    \ then\n\t\tis_equidistant = true\n\t\tclosest_integer = value_as_number + diff1\n\
    \telse\n\t\tis_equidistant = false\n\t\tclosest_integer = value_as_number + diff2\n\
    \tend\n\tif closest_integer > value_as_number then\n\t\tclosest_integer = value_as_number\n\
    \tend\n\treturn closest_integer\nend", '  if value == "*" then return 0 end',
  "    local difference = math.abs(value - closest_integer(value))\n    if difference\
    \ < 0.5 then\n        return value\n    else\n        return math.ceil(value -\
    \ difference)\n    end\nend", "  if value == nil then\n    error('Value cannot\
    \ be nil')\n  end", "  local difference = math.abs(tonumber(value) - tonumber(value))\n\
    \  if difference < 0.1 then\n    return tonumber(value)\n  elseif difference <\
    \ 1.0 then\n    return tonumber(value) + 1.0\n  elseif difference > 1.0 then\n\
    \    return tonumber(value) - 1.0\n  else\n    return tonumber(value)\n  end\n\
    end", "  -- The value will be a string, so make sure it is one.\n  if type(value)\
    \ ~= 'string' then return end\n  -- First, remove all non-digit characters from\
    \ the value.\n  local digits = value:gsub('%d+', '')\n  -- Next, sort the digits,\
    \ so that any two adjacent digits are in the\n  -- same place.\n  table.sort(digits)\n\
    \  -- Finally, find the value that would be closest to the sorted digits.\n  return\
    \ tonumber(digits):round()\nend", '  local sign, value = string.match(value, "(%a[-+]?)([1-9][0-9]*)")',
  "  -- If the value is an integer, return it as is.\n  if tonumber(value) == tonumber(value)\
    \ then\n    return value\n  end", "    local function abs(n)\n        return math.abs(n)\n\
    \    end\n    local function min(...)\n        return table.unpack(table.sort(...))[1]\n\
    \    end", "  local factors, err = vlua.factors(value)\n  if err then\n    return\
    \ nil, err\n  end\n  -- Sort factors so the one nearest to zero comes first.\n\
    \  table.sort(factors, function(a,b) return math.abs(a) > math.abs(b) end)\n \
    \ local difference\n  for i = #factors\n  do\n    difference = math.abs(factors[i]\
    \ - value)\n    if difference == 0 then\n      -- If the difference is 0 we can\
    \ return the factor that was\n      -- closest to zero, which is what we're after.\n\
    \      return factors[i]\n    end\n    -- If the difference is less than 0, then\
    \ we know that the factor\n    -- was closer to the other factors than the one\
    \ we're currently\n    -- looking at. Thus we return one of the other factors.\n\
    \    if difference > 0 then\n      return factors[i]\n    end\n  end\n  return\
    \ nil, \"Could not find a factor for that number\"\nend", "  if value == nil then\
    \ return nil end\n  local number = tonumber(value)\n  if number == nil then return\
    \ nil end\n  if number < 0 then\n    number = -number\n  end\n  local min_value\
    \ = math.floor(number - 0.5)\n  if min_value == number then\n    -- exact match\n\
    \    return min_value\n  end\n  -- if the value has an 'f' suffix, it's float\n\
    \  local f, suffix, precision = string.find(value, \"f\", 1, true)\n  if suffix\
    \ ~= nil then\n    return math.floor(number - 0.5)\n  end\n  -- otherwise, it's\
    \ decimal\n  local fractional = math.modf(number * 10.0)\n  return math.floor(fractional\
    \ * 10.0 + 0.5)\nend", "  local num = tonumber(value)\n  if num then\n    local\
    \ offset = tonumber(math.abs(num - math.floor(num)))\n    if offset < 0 then\n\
    \      offset = offset + num\n    end\n    return math.floor(num + offset)\n \
    \ end\n  return nil\nend", "  -- First, convert value to a number\n  local value\
    \ = tonumber(value)\n  if value == nil then\n    -- If the given value is not\
    \ a number, return nil\n    return nil\n  elseif value == value then\n    -- If\
    \ the given value is equal to the value, return it.\n    -- This happens if we\
    \ pass it a string representing a number.\n    return value\n  else\n    -- Otherwise,\
    \ get the integer value of the given value\n    local value_integer = math.floor(value)\n\
    \    -- If the integer value is not zero\n    if value_integer ~= 0 then\n   \
    \   -- Get the difference between the given value and the\n      -- integer value\
    \ of the given value\n      local difference_from_value = value - value_integer\n\
    \      -- If difference_from_value is less than zero, return nil\n      if difference_from_value\
    \ <= 0 then\n        return nil\n      else\n        -- Otherwise, return the\
    \ integer value of the given value\n        return value_integer\n      end\n\
    \    else\n      -- Otherwise, if the given value is negative, return nil\n  \
    \    return nil\n    end\n  end\nend", "  local closest_integer = tonumber(math.floor(value))\n\
    \  if closest_integer == value then\n    return value\n  elseif value ~= closest_integer\
    \ then\n    local diff\n    if closest_integer < value then\n      diff = value\
    \ - closest_integer\n      closest_integer = closest_integer\n    else\n     \
    \ diff = closest_integer - value\n      closest_integer = value\n    end\n   \
    \ diff = diff - closest_integer\n    if diff < 0 then\n      return closest_integer\n\
    \    elseif diff > 0 then\n      return closest_integer + math.ceil(diff)\n  \
    \  else\n      return closest_integer\n    end\n  end\nend", "    local sign =\
    \ math.sign\n    if value >= 0 then\n        return sign(value)\n    elseif value\
    \ <= -0 then\n        return -sign(value)\n    else\n        if sign(value) ==\
    \ 0 then\n            error(\"negative numbers not allowed\")\n        end", " \
    \ local sign = math.sign(value)\n  local function is_close(num)\n    local difference\
    \ = math.abs(num - value)\n    return difference < precision and difference ~=\
    \ 0\n  end\n  if sign == 0 then\n    -- If the number is zero, return 0 instead.\n\
    \    return 0\n  elseif sign == 1 then\n    -- If the number is strictly positive,\
    \ return it as is.\n    return value\n  elseif sign == -1 then\n    -- If the\
    \ number is strictly negative, return the negative of the number.\n    return\
    \ -math.abs(value)\n  end", "    local number = tonumber(value)\n    if number\
    \ == number then return number end", "  local closest = None\n  local difference\
    \ = math.abs(tonumber(value))\n  for k, v in pairs(_G) do\n    if v == value then\n\
    \      return v\n    end\n    if difference > tonumber(k) then\n      difference\
    \ = tonumber(k)\n      closest = k\n    end\n  end\n  return closest\nend", " \
    \   local digits = value:gsub(\"%d+\", \"\")\n    local num_digits = #digits",
  "  return math.ceil(value) - math.floor(value)\nend", "  local sign, value = string.match(value,\
    \ \"(-*)([%d]+)\")\n  if sign and sign == \"-\" then\n    value = math.ceil(value)\n\
    \  elseif sign == \"\" then\n    value = math.floor(value)\n  end\n  return value\n\
    end", "    local digits = tonumber(value)\n    if digits == nil then\n       \
    \ return nil\n    end\n    local digits_squared = digits * digits\n    -- The\
    \ square root of the sum of squares is the square root of the sum\n    -- of the\
    \ squares of the digits.\n    local digits_sum = digits_squared + digits_squared\n\
    \    local digits_squares_sum = (digits * digits_squared)\n    local digits_root_sum\
    \ = (digits * digits * 0.5)\n    local root_square_sum = digits_root_sum + digits_root_sum\n\
    \    local result = digits + digits_sum - digits_squares_sum - root_square_sum\n\
    \    if result == 0 then\n        return nil\n    end\n    -- If result is negative\
    \ and there are two integers, return the\n    -- one that is farthest from zero.\n\
    \    if result < 0 and digits == 2 then\n        return math.floor(digits * 0.5)\n\
    \    else\n        return result\n    end\nend", "  local sign = value < 0 then\
    \ (-1) else  1\n  local n = tonumber(value)\n  if tonumber(value) == n then\n\
    \    return n\n  end\n  if n < 0 then\n    local m = math.abs(n)\n    if m ==\
    \ 0 then\n      return sign\n    elseif m % 2 == 0 then\n      return sign * (m\
    \ + math.floor((m - 2) / 2))\n    else\n      return sign * (m + math.floor((m\
    \ + 3) / 2))\n    end\n  else\n    local m = math.abs(n)\n    if m == 0 then\n\
    \      return sign * m\n    else\n      if m % 2 == 0 then\n        return sign\
    \ * (math.floor(m/2) + math.ceil((m-2) / 2))\n      else\n        return sign\
    \ * (math.floor(m/2) + math.ceil((m-2) / 2) + 1)\n      end\n    end\n  end\n\
    end", "  -- If the given value is negative, return it unchanged.\n  -- Note: We\
    \ use tonumber instead of tonumberi because tonumber will\n  --       return 0\
    \ for a string representing a boolean value.\n  local sign\n  if tonumber(value)\
    \ < 0 then\n    return value\n  elseif tonumber(value) == 0 then\n    return 0\n\
    \  end", "    if value == nil then\n        return nil\n    end", "    local function\
    \ abs(x)\n        return math.abs(x)\n    end\n    local function mod(x, n)\n\
    \        return math.modf(x)[1]\n    end\n    -- If the argument is a string representing\
    \ a number then\n    -- convert to a number.\n    local value = tonumber(value)\n\
    \    if not value then\n        error(string.format(\"Value is not a number: %s\"\
    , value))\n    end\n    -- If the given number is equidistant from two integers,\n\
    \    -- return the one that is farthest from zero.\n    if mod(value, 1) > 0.5\
    \ then\n        local difference = abs(value - closest_integer(math.ceil(value)))\n\
    \        if difference > 0.5 then\n            difference = abs(value - closest_integer(math.floor(value)))\n\
    \        end\n        if difference > 0.5 then\n            return closest_integer(value)\n\
    \        end\n    end\n    -- If the number is equidistant from two integers,\
    \ round it\n    -- towards zero.\n    return math.ceil(value)\nend", "  if tonumber(value)\
    \ == value then\n    -- An integer was passed in, just return it.\n    return\
    \ tonumber(value)\n  else\n    -- We need to check if it's a float/double first,\
    \ because then we\n    -- can correctly handle strings like '14.5'.\n    if type(value)\
    \ == \"number\" then\n      local num", "   -- Find the smallest string that is\
    \ greater than the value.\n   -- If there's no such string, return the string\
    \ itself.\n   local str = tonumber(value)\n   if str ~= nil then\n      str =\
    \ string.sub(value, 1, #value)\n      local digits = str:gmatch(\"^%d+(.-)%d+$\"\
    )\n      if digits == nil then\n         return str\n      else\n         local\
    \ fraction = tonumber(digits[1])\n         return tonumber(string.sub(value, 1,\
    \ #value)) + (fraction / tonumber(string.sub(digits, 2)))\n      end\n   end\n\
    end", "  local closest_value = tonumber(value)\n  if tonumber(value) == value\
    \ then\n    error(\"Expected a number\")\n  elseif tonumber(value) < (closest_value\
    \ + 1) then\n    closest_value = tonumber(value) + 1\n  end\n  return closest_value\n\
    end", "  value = tonumber(value)\n  if value == nil then\n    return nil\n  else\n\
    \    local sign = math.sign(value)\n    if sign ~= 0 then\n      value = math.abs(value)\n\
    \    end\n    local max_diff = -value % value\n    local max_diff_index = nil\n\
    \    local i = 0\n    while i < #integers do\n      local diff = abs(integers[i]\
    \ - value)\n      if diff == max_diff then\n        return integers[i]\n     \
    \ elseif diff > max_diff then\n        if i - 1 >= 0 then\n          max_diff\
    \ = diff - abs(integers[i - 1] - value)\n        else\n          max_diff = -diff\
    \ - abs(integers[i + 1] - value)\n        end\n        max_diff_index = i\n  \
    \    end\n      i = i + 1\n    end\n    if max_diff_index ~= nil then\n      return\
    \ integers[max_diff_index]\n    end\n  end\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
