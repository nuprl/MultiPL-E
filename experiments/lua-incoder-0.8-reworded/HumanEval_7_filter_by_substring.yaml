name: HumanEval_7_filter_by_substring
language: lua
prompt: "-- Filter an input table of strings only for ones that contain given substring\n\
  -- >>> filter_by_substring({}, 'a')\n-- {}\n-- >>> filter_by_substring({'abc', 'bacd',\
  \ 'cde', 'array'}, 'a')\n-- {'abc', 'bacd', 'array'}\nlocal function filter_by_substring(strings,\
  \ substring)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = filter_by_substring\n\
  \    lu.assertEquals(candidate({}, 'john'), {})\n    lu.assertEquals(candidate({'xxx',\
  \ 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx'), {'xxx', 'xxxAAA', 'xxx'})\n\
  \    lu.assertEquals(candidate({'xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'},\
  \ 'xx'), {'xxx', 'aaaxxy', 'xxxAAA', 'xxx'})\n    lu.assertEquals(candidate({'grunt',\
  \ 'trumpet', 'prune', 'gruesome'}, 'run'), {'grunt', 'prune'})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tassert(type(strings) == 'table', 'strings should be a table')\n\t\
    assert(type(substring) == 'string', 'substring should be a string')\n\tlocal filtered_table\
    \ = {}\n\tfor key, val in pairs(strings) do\n\t\tif string.find(val, substring,\
    \ 1, true) then\n\t\t\ttable.insert(filtered_table, val)\n\t\tend\n\tend\n\treturn\
    \ filtered_table\nend", "  local filtered_strings = {}\n  for k, v in pairs(strings)\
    \ do\n    if string.find(v, substring) then\n      table.insert(filtered_strings,\
    \ v)\n    end\n  end\n  return filtered_strings\nend", "  if type(strings) ~=\
    \ 'table' then return strings end\n  local result = {}\n  for _, item in ipairs(strings)\
    \ do\n    if string.find(item, substring, 1, true) then\n      result[#result\
    \ + 1] = {item}\n    end\n  end\n  return result\nend", "    if substring == nil\
    \ then\n        strings = {}\n    end\n    local result = {}\n    for _, string\
    \ in ipairs(strings) do\n        if string.find(substring) ~= nil then\n     \
    \       result[#result + 1] = {string}\n        end\n    end\n    return result\n\
    end", "  local filter = {}\n  for k in pairs(strings) do\n    if string.find(k,\
    \ substring) then table.insert(filter, k) end\n  end\n  return filter\nend", " \
    \   local result = {}\n    for _, value in ipairs(strings) do\n        if string.find(value,\
    \ substring) ~= nil then\n            result[#result + 1] = value\n        end\n\
    \    end\n    return result\nend", "  local result = {}\n  for _, value in pairs(strings)\
    \ do\n    if string.sub(value, 1, string.len(substring)) ~= substring then\n \
    \     result[#result + 1] = value\n    end\n  end\n  return result\nend", "\t\
    -- Filter all strings for ones that contain given substring\n\t-- >>> filter_by_substring({'abc',\
    \ 'bacd', 'cde', 'array'}, 'a')\n\t-- {'abc', 'bacd', 'array'}\n\tfor _, string\
    \ in ipairs(strings) do\n\t\tif string.find(substring) then\n\t\t\t-- yield string\n\
    \t\t\ttable.insert(strings)\n\t\tend\n\tend\n\treturn strings\nend", "\tlocal\
    \ result = {}\n\tfor _, string in ipairs(strings) do\n\t\tif string.find(substring,\
    \ 1, true) then\n\t\t\ttable.insert(result, string)\n\t\tend\n\tend\n\treturn\
    \ result\nend", "  if type(strings) ~= 'table' then\n    -- If 'strings' is actually\
    \ a string, pass it through as is.\n    local str = strings\n    strings = {}\n\
    \    strings[str] = true\n  end", "   if type(strings) ~= 'table' then return\
    \ end\n   local result = {}\n   for _, string in ipairs(strings) do\n      if\
    \ string.find(substring, 1, true) then\n         result[#result + 1] = string\n\
    \      end\n   end\n   return result\nend", "  local filtered_strings = {}\n \
    \ for _, string in ipairs(strings) do\n    if string.find(substring) then\n  \
    \    table.insert(filtered_strings, string)\n    end\n  end\n  return filtered_strings\n\
    end", "  if #strings ~= 0 then\n    local filtered_strings = {}\n    for _, string\
    \ in pairs(strings) do\n      if string.find(substring) then\n        table.insert(filtered_strings,\
    \ string)\n      end\n    end\n    return filtered_strings\n  else\n    return\
    \ {}\n  end\nend", "    if not substring then\n        return strings\n    end\n\
    \    local result = {}\n    for _, string in ipairs(strings) do\n        if string.find(substring,\
    \ 1, true) then\n            result[#result +1] = string\n        end\n    end\n\
    \    return result\nend", "  for i, v in ipairs(strings) do\n    if v:find(substring)\
    \ then\n      table.remove(strings, i)\n    end\n  end\n  return strings\nend",
  "  local result = {}\n  for _, v in pairs(strings) do\n    if string.find(v, substring,\
    \ 1, true) then\n      table.insert(result, v)\n    end\n  end\n  return result\n\
    end", "  -- Empty table is the initial state.\n  -- If the table is empty after\
    \ filtering, we can assume that the table is full\n  -- because any empty string\
    \ would have been removed.\n  local filtered_strings = table_from_table({})\n\
    \  -- Iterate over the set of strings for which we filter\n  for _, s in pairs(strings)\
    \ do\n    local new_filtered_strings = table_from_table({})\n    \n    -- Filter\
    \ the set by checking each string against the substring\n    for index, t in pairs(filtered_strings)\
    \ do\n      if string_find(t, substring) then\n        new_filtered_strings[#new_filtered_strings\
    \ + 1] = t \n      end\n    end\n    filtered_strings = new_filtered_strings\n\
    \  end\n  \n  return filtered_strings\nend", "  if type(io.string) == \"table\"\
    \ and substring ~= nil then\n    -- If substring is a table, loop through it and\
    \ build a table.\n    for k, v in ipairs(substring) do\n      strings = filter_by_substring(strings,\
    \ v)\n    end\n  else\n    -- If substring is not a table, just build the string.\n\
    \    strings = string.gsub(strings, \"%$\" .. substring, \"%~\")\n  end\n  return\
    \ strings\nend", "    local filtered_table = {}\n    for _, item in pairs(strings)\
    \ do\n        if substring in item then\n            table.insert(filtered_table,\
    \ item)\n        end\n    end\n    return filtered_table\nend", "  for k, v in\
    \ pairs(strings) do\n    if substring in v then\n      table.remove(strings, k)\n\
    \      -- table.remove(strings, k) -- TODO: remove when stable Lua 5.2 is no longer\
    \ supported\n    end\n  end\n  -- print(\"filtered strings: \", strings)\n  return\
    \ strings\nend", "  assert(type(strings) == 'table', strings)\n  assert(type(substring)\
    \ == 'string', substring)", "  local result = {}\n  for _, string in ipairs(strings)\
    \ do\n    if string.find(substring, 1, true) then\n      result[#result + 1] =\
    \ string\n    end\n  end\n  return result\nend", "  if type(substring) ~= 'string'\
    \ then\n    error('substring must be a string')\n  elseif string.len(substring)\
    \ == 0 then\n    return strings\n  end", "  if type(strings) ~= 'table' then\n\
    \    return strings\n  end\n  local result = {}\n  for _, string in pairs(strings)\
    \ do\n    if string.find(substring, 1, true) then\n      result[#result +1] =\
    \ string\n    end\n  end\n  return result\nend", "  if substring == '' then return\
    \ strings end", "  if type(strings) ~= 'table' then return {} end\n  local substring_table\
    \ = {}\n  for i = 1, #strings do\n    local word = tonumber(strings[i])\n    if\
    \ type(word) == 'string' then\n      if word:find(substring, 1, true) then\n \
    \       substring_table[i] = strings[i]\n      end\n    end\n  end\n  return substring_table\n\
    end", "  return table.reduce(\n    strings,\n    function(output, str)\n     \
    \ if string.find(str, substring) ~= nil then\n        output[#output + 1] = str\n\
    \      end\n      return output\n    end,\n    {1}\n  )\nend", "  local filtered_strings\
    \ = setmetatable({}, {\n      __index = function(t, key)\n          local filtered_strings\
    \ = {}\n          for _, str in pairs(strings) do\n            if str:find(substring)\
    \ ~= nil then\n              table.insert(filtered_strings, str)\n           \
    \ end\n          end\n          return filtered_strings\n      end,\n  })\n  for\
    \ _, str in pairs(strings) do\n    if str:find(substring) ~= nil then\n      table.insert(filtered_strings,\
    \ str)\n    end\n  end\n  return filtered_strings\nend", "    if substring ==\
    \ '' then\n        return strings\n    end\n    local output = {}\n    for i =\
    \ 1, #strings do\n        if strings[i] ~= substring then\n            output[#output\
    \ + 1] = strings[i]\n        end\n    end\n    return output\nend", "  local new_strings\
    \ = {}\n  for _, string in pairs(strings) do\n    for word in string.gmatch(substring,\
    \ \"%w+\") do\n      new_strings[word] = string\n    end\n  end\n  return new_strings\n\
    end", "  local result = {}\n  for _, string in ipairs(strings) do\n    if string.find(substring,\
    \ 1, true) then\n      table.insert(result, string)\n    end\n  end\n  return\
    \ result\nend", "    local filtered = {}\n    for _, value in ipairs(strings)\
    \ do\n        if string.find(value, substring) then\n            table.insert(filtered,\
    \ value)\n        end\n    end\n    return filtered\nend", "  local new_strings\
    \ = terralib.newlist()\n  for _, s in ipairs(strings) do\n    if string.find(s,\
    \ substring, 1, true) ~= nil then\n      table.insert(new_strings, s)\n    end\n\
    \  end\n  return new_strings\nend", "\tassert(type(strings) == \"table\" and #strings\
    \ > 0)\n\tassert(type(substring) == \"string\" and #substring > 0)", "  local\
    \ result = {}\n  for _, str in ipairs(strings) do\n    if str:find(substring)\
    \ == 1 then\n      result[#result + 1] = {str}\n    end\n  end\n  return result\n\
    end", "  if substring == nil then return strings end\n  local pattern = \"^\"\
    ..substring..\"$\"\n  local filtered_strings = {}\n  for _, string in ipairs(strings)\
    \ do\n    if string.find(pattern) then\n      table.insert(filtered_strings, string)\n\
    \    end\n  end\n  return filtered_strings\nend", "\tassert(type(strings) == 'table')\n\
    \tassert(type(substring) == 'string')", "  return table.filter(\n    function(x)\n\
    \      return x:find(substring) ~= nil\n    end,\n    strings\n  )\nend", "  local\
    \ filtered = {}\n  for k, v in pairs(strings) do\n    if string.find(k, v, substring,\
    \ 1, true) then\n      table.insert(filtered, v)\n    end\n  end\n  return filtered\n\
    end", "  return setmetatable({\n      strings = strings,\n      substring = substring,\n\
    \      filter_ = nil,\n  }, { __index = _G and _G.filter_by_substring or nil })\n\
    end", "  local result = {}\n  for _, item in pairs(strings) do\n    if string.find(item,\
    \ substring) then\n      result[#result + 1] = item\n    end\n  end\n  return\
    \ result\nend", "  local result = {}\n  for _, v in ipairs(strings) do\n    if\
    \ v:find(substring) then\n      table.insert(result, v)\n    end\n  end\n  return\
    \ result\nend", "  local result = {}\n  for _, string in ipairs(strings) do\n\
    \    if string.find(substring, 1, true) then\n      result[#result + 1] = string\n\
    \    end\n  end\n  return result\nend", "  if type(strings) == 'table' then\n\
    \    local filtered_strings = {}\n    for i, string in pairs(strings) do\n   \
    \   if string.find(substring, 1, true) then\n        table.insert(filtered_strings,\
    \ string)\n      end\n    end\n    return filtered_strings\n  end\nend", "  --\
    \ Find substring in each string\n  local substrings = terralib.newlist()\n  local\
    \ index = terralib.newlist()\n  local len = #substring\n  for i = 1, #strings\
    \ do\n    for j = 1, #strings[i] do\n      local sub = strings[i][j]\n      if\
    \ sub == substring then\n        table.insert(substrings, sub)\n        table.insert(index,\
    \ j)\n      end\n    end\n  end", "  if type(strings) ~= 'table' then return {}\
    \ end\n  local result = {}\n  for _, s in ipairs(strings) do\n    if substring\
    \ in s then\n      result[#result + 1] = s\n    end\n  end\n  return result\n\
    end", "  local result = {}\n  for _, value in ipairs(strings) do\n    if string.find(value,\
    \ substring) then\n      table.insert(result, value)\n    end\n  end\n  return\
    \ result\nend", "  assert(type(substring) == 'string', \"'substring' argument\
    \ must be a string\")\n  local ret = {}\n  for _, str in ipairs(strings) do\n\
    \    if string.sub(str, 1, string.len(substring)) == substring then\n      table.insert(ret,\
    \ str)\n    end\n  end\n  return ret\nend", "  local filtered_strings = {}\n \
    \ for _, string in pairs(strings) do\n    local match\n    if string.substr:find:find(substring,\
    \ 1, true) then\n      match = true\n    end\n    if match then\n      filtered_strings[#filtered_strings\
    \ + 1] = string\n    end\n  end\n  return filtered_strings\nend", "  local result\
    \ = {}\n  for _, str in pairs(strings) do\n    if string.sub(str,1,string.len(substring))\
    \ == substring then\n      result[#result + 1] = str\n    end\n  end\n  return\
    \ result\nend", "  assert(type(strings) == 'table')\n  assert(type(substring)\
    \ == 'string')\n  local result = {}\n  for _, str in pairs(strings) do\n    if\
    \ string.find(str, substring) then\n      table.insert(result, str)\n    end\n\
    \  end\n  return result\nend", "   local result = {}\n   for _, item in ipairs(strings)\
    \ do\n      if string.find(item, substring) then\n         table.insert(result,\
    \ item)\n      end\n   end\n   return result\nend", "    if not substring then\
    \ return strings end\n    local ret = {}\n    for k, v in pairs(strings) do\n\
    \        if string.find(v, substring, 1, true) then\n            ret[k] = v\n\
    \        end\n    end\n    return ret\nend", "    local result = {}\n    for _,\
    \ string in ipairs(strings) do\n        if string.find(substring, '') ~= nil then\n\
    \            result[#result + 1] = string\n        end\n    end\n    return result\n\
    end", "  local result = {}\n  for i, str in ipairs(strings) do\n    if string.find(str,\
    \ substring) then\n      result[i] = str\n    end\n  end\n  return result\nend",
  "  if type(strings) ~= 'table' then return strings end\n  if string.find(strings,\
    \ '^%s*$') then return strings end\n  -- TODO: this is going to be very inefficient\
    \ (O(n^2))\n  for _, string in ipairs(strings) do\n    if string.find(substring,\
    \ 1, true) == 1 then\n      table.remove(strings, string)\n    end\n  end\n  return\
    \ strings\nend", "  if substring == '' then\n    return strings\n  end", "  local\
    \ result = {}\n  for i = 1, #strings do\n    if string.find(strings[i], substring)\
    \ then\n      table.insert(result, strings[i])\n    end\n  end\n  return result\n\
    end", "    local result = {}\n    for _, v in pairs(strings) do\n        if v:find(string)\
    \ == 1 then\n            table.insert(result, v)\n        end\n    end\n    return\
    \ result\nend", "  local result = {}\n  for _, s in ipairs(strings) do\n    if\
    \ string.find(s, substring, 1, true) ~= nil then\n      table.insert(result, s)\n\
    \    end\n  end\n  return result\nend", "  if typeOf(substring) ~= 'string' then\n\
    \    error('expected a string parameter to filter_by_substring()')\n  end\n  if\
    \ #strings < 1 then\n    return {}\n  end\n  local out = setmetatable({}, {__mode='k'})\n\
    \  for _, v in pairs(strings) do\n    if string.sub(v,1,#substring) == substring\
    \ then\n      out[#out+1] = v\n    end\n  end\n  return out\nend", "  assert(type(strings)\
    \ == 'table', strings)\n  assert(type(substring) == 'string', substring)", " \
    \   local filtered = {}\n    for _, string in ipairs(strings) do\n        if string.find(substring,\
    \ '.') ~= nil then\n            filtered[#filtered + 1] = string\n        end\n\
    \    end\n    return filtered\nend", "  local result = {}\n  for _, string in\
    \ pairs(strings) do\n    string.find(substring):start()\n    if string.find(substring):end()\
    \ then\n      result[#result + 1] = string\n    end\n  end\n  return result\n\
    end", "  local result = {}\n  local count = 0\n  for s in pairs(strings) do\n\
    \    count = count + 1\n    if string.find(s, substring) then\n      result[count]\
    \ = s\n    end\n  end\n  return result\nend", "  for _, str in pairs(strings)\
    \ do\n    if string.find(str, substring) then\n      return strings\n    end\n\
    \  end\n  return {}\nend", "    local result = {}\n    for _, str in pairs(strings)\
    \ do\n        if string.find(str, substring) then\n            result[#result\
    \ + 1] = {str}\n        end\n    end\n    return result\nend", "  local filtered_table\
    \ = {}\n  for _, string in ipairs(strings) do\n    if string.find(string, \"^\"\
    \ .. substring .. \"$\") then\n      table.insert(filtered_table, string)\n  \
    \  end\n  end\n  return filtered_table\nend", "   local filtered_strings = {}\n\
    \   for _, s in ipairs(strings) do\n      if not (s:find(substring)) then break\
    \ end\n      table.insert(filtered_strings, s)\n   end\n   return filtered_strings\n\
    end", "    local result = {}\n    for _, value in ipairs(strings) do\n       \
    \ if string.find(value, substring) then\n            table.insert(result, value)\n\
    \        end\n    end\n    return result\nend", "    local results = {}\n    for\
    \ _, string in ipairs(strings) do\n        if string.find(substring, 1, true)\
    \ then\n            table.insert(results, string)\n        end\n    end\n    return\
    \ results\nend", "  if type(strings) ~= 'table' then\n    error('First argument\
    \ must be a table.')\n  end\n  -- TODO: this can be done more efficiently with\
    \ a binary search than a loop\n  local result = {}\n  for _, string in ipairs(strings)\
    \ do\n    if string.find(string) ~= nil then\n      result[#result +1] = string\n\
    \    end\n  end\n  return result\nend", "  assert(type(strings) == 'table')\n\
    \  assert(type(substring) == 'string')\n  \n  local result = {}\n  for _, string\
    \ in ipairs(strings) do\n    if string.find(substring, 1, true) then\n      result[#result\
    \ + 1] = string\n    end\n  end\n  return result\nend", "  local result = {}\n\
    \  for key, value in pairs(strings) do\n    if value == substring then\n     \
    \ table.insert(result, key)\n    end\n  end\n  return result\nend", "  local filtered_strings\
    \ = {}\n  for k, v in pairs(strings) do\n    if k ~= '' and string.find(k, substring,\
    \ true) then\n      filtered_strings[k] = v\n    end\n  end\n  return filtered_strings\n\
    end", "  local result = {}\n  for _, string in ipairs(strings) do\n    if string.find(substring,\
    \ '.') == nil then\n      result[#result + 1] = string\n    end\n  end\n  return\
    \ result\nend", "    local out = {}\n    for _, s in ipairs(strings) do\n    \
    \    if string.find(s, substring, 1, true) then\n            table.insert(out,\
    \ s)\n        end\n    end\n    return out\nend", "  local filtered_strings =\
    \ {}\n  for _, string in ipairs(strings) do\n    if string.find(substring) then\n\
    \      filtered_strings[#filtered_strings + 1] = string\n    end\n  end\n  return\
    \ filtered_strings\nend", "  local filtered = {}\n  for _, v in pairs(strings)\
    \ do\n    if v:find(string) == 1 then\n      table.insert(filtered, v)\n    end\n\
    \  end\n  return filtered\nend", "  local filtered_strings = {}\n  for _, v in\
    \ ipairs(strings) do\n    local substrings = v:gsub(\"[\" .. substring .. \"]+\"\
    , \"\")\n    if substrings == \"\" then\n      -- If the string doesn't contain\
    \ the substring, filter it out\n      filtered_strings[#filtered_strings + 1]\
    \ = v\n    end\n  end\n  return filtered_strings\nend", "  local filtered_strings\
    \ = {}\n  for key, value in pairs(strings) do\n    if value:find(substring) then\n\
    \      table.insert(filtered_strings, value)\n    end\n  end\n  return filtered_strings\n\
    end", "  local filter = {}\n  for k,v in pairs(strings) do\n    if string.find(v,\
    \ substring, 1, true) then\n      table.insert(filter, v)\n    end\n  end\n  return\
    \ filter\nend", "  if substring == nil then\n    return strings\n  end\n  if typeof(substring)\
    \ ~= 'string' then\n    error('First argument of filter_by_substring must be a\
    \ string.')\n  end\n  local result = {}\n  for i = 1, #strings do\n    if strings[i]\
    \ ~= substring then\n      result[#result + 1] = strings[i]\n    end\n  end\n\
    \  return result\nend", "    local ret = {}\n    for _, v in pairs(strings) do\n\
    \        if string.find(v, substring, 1, true) then\n            ret[#ret + 1]\
    \ = v\n        end\n    end\n    return ret\nend", "    if substring == '' then\
    \ return strings end\n    local filtered_strings = {}\n    for _, _ in pairs(strings)\
    \ do\n        if string.find(_, substring) ~= nil then\n            table.insert(filtered_strings,\
    \ _)\n        end\n    end\n    return filtered_strings\nend", "  local result\
    \ = {}\n  for _, string in ipairs(strings) do\n    if string.find(substring) then\n\
    \      result[#result + 1]=string\n    end\n  end\n  return result\nend", "  return\
    \ setmetatable({\n    strings = strings,\n    substring = substring,\n  }, getmetatable({\n\
    \    strings = strings,\n    substring = substring,\n  }))\nend", "    local filtered_strings\
    \ = {}\n    local i = 1\n    for _, str in pairs(strings) do\n        if string.find(str,\
    \ substring) ~= nil then\n            filtered_strings[i] = str\n            i\
    \ = i + 1\n        end\n    end\n    return filtered_strings\nend", "    local\
    \ result = {}\n    for _, value in pairs(strings) do\n        if value:find(substring)\
    \ ~= nil then\n            result[#result + 1] = value\n        end\n    end\n\
    \    return result\nend", "\tassert(type(strings) == 'table')\n\tassert(type(substring)\
    \ == 'string')\n\tlocal keys = {}\n\tfor k, v in pairs(strings) do\n\t\tif v:find(substring)\
    \ == 1 then\n\t\t\ttable.insert(keys, k)\n\t\tend\n\tend\n\treturn keys\nend",
  "  -- If strings is not provided, return an empty table.\n  if strings == nil then\n\
    \    return {}\n  end", "  local result = {}\n  for _, value in pairs(strings)\
    \ do\n    if value:find(substring) == 1 then\n      table.insert(result, value)\n\
    \    end\n  end\n  return result\nend", "  if type(tonumber(substring)) ~= 'string'\
    \ then\n    error('Substring must be a string')\n  end\n  local result = {}\n\
    \  strings = strings or {}\n  for _, item in pairs(strings) do\n    local substring_index\
    \ = 1\n    for index = 1, #item do\n      if string.sub(item, index, index) ==\
    \ substring then\n        result[#result + 1] = item\n        substring_index\
    \ = substring_index + 1\n      end\n    end\n    if substring_index == #item then\n\
    \      result[#result + 1] = item\n    end\n  end\n  return result\nend", "  \
    \  if substring == nil then\n        strings = {}\n    end\n    local result =\
    \ {}\n    table.insert(strings, true)\n    table.insert(strings, false)\n    for\
    \ _, str in ipairs(strings) do\n        if string.find(str, substring) then\n\
    \            table.insert(result, str)\n        else\n            table.remove(result,\
    \ 1)\n        end\n    end\n    return result\nend", "    if type(strings) ~=\
    \ 'table' then return {} end\n    local output = {}\n    for _, v in pairs(strings)\
    \ do\n        if string.find(v, substring, 1, true) ~= nil then\n            output[#output\
    \ + 1] = v\n        end\n    end\n    return output\nend", "    for _, s in ipairs(strings)\
    \ do\n        if substring in s then\n            return {}\n        end\n   \
    \ end\n    return strings\nend", "  local filtered = {}\n  for _, s in ipairs(strings)\
    \ do\n    if string.find(s, substring) then\n      table.insert(filtered, s)\n\
    \    end\n  end\n  return filtered\nend", "  local result = {}\n  for _, value\
    \ in ipairs(strings) do\n    if value:find(substring) then\n      table.insert(result,\
    \ value)\n    end\n  end\n  return result\nend", "  local substring_index = string.find(strings,\
    \ substring)\n  if substring_index == nil then\n    return nil\n  else\n    strings\
    \ = strings[substring_index]:sub(1, string.len(substring))\n  end \n  return strings\n\
    end", "  local result = {}\n  for _, string in ipairs(strings) do\n    if string.find(substring)\
    \ then\n      result[#result + 1] = string\n    end\n  end\n  return result\n\
    end", "  assert(type(strings) ~= 'table' or #strings == 0, 'strings should be\
    \ a table of strings')\n  assert(type(substring) == 'string', 'substring should\
    \ be a string')\n  local result = {}\n  for _, string in ipairs(strings) do\n\
    \    if string.find(substring, 1, true) ~= nil then\n      result[#result + 1]\
    \ = string\n    end\n  end\n  return result\nend", "  for i = 1, #strings do\n\
    \    if strings[i]:find(substring) ~= nil then\n      return true\n    end\n \
    \ end\n  return false\nend", "    local filtered_table = {}\n    for _, string\
    \ in ipairs(strings) do\n        if string.find(substring, 1, true) ~= nil then\n\
    \            table.insert(filtered_table, string)\n        end\n    end\n    return\
    \ filtered_table\nend", "  for _, v in ipairs(strings) do\n    if v:find(substring)\
    \ then\n      table.remove(strings, v)\n    end\n  end\n  return strings\nend",
  "  local filtered_strings = {}\n  for _,str in pairs(strings) do\n    if string.sub(str,1,#substring)\
    \ == substring then\n      table.insert(filtered_strings, str)\n    end\n  end\n\
    \  return filtered_strings\nend", "  local result = {}\n  for _, str in ipairs(strings)\
    \ do\n    if str:find(substring) == 1 then result[#result+1] = str end\n  end\n\
    \  return result\nend", "    if type(strings) ~= 'table' then return end\n   \
    \ if type(substring) ~= 'string' then return end\n    for i = 1, #strings do\n\
    \        if string.find(strings[i], substring, 1, true) then\n            table.remove(strings,\
    \ i)\n        end\n    end\nend", "  local result = {}\n  for k, v in pairs(strings)\
    \ do\n    if v:sub(1, #substring) == substring then\n      table.insert(result,\
    \ v)\n    end\n  end\n  return result\nend\n</cell>\n<text>\nfilter_by_word\n\
    Filter an input table of strings only for ones that have a given word. Punctuation\
    \ marks such as '.' and '-' are ignored.", "  if type(strings) ~= 'table' then\n\
    \    error('strings should be a table')\n  end\n  local out = {}\n  for _, string\
    \ in ipairs(strings) do\n    if string.find(substring) == 1 then\n      table.insert(out,\
    \ string)\n    end\n  end\n  return out\nend", "  local result = {}\n  for _,\
    \ value in ipairs(strings) do\n    if string.find(value, substring) then\n   \
    \   result[#result +1] = value\n    end\n  end\n  return result\nend", "  local\
    \ result = {}\n  for _, string in ipairs(strings) do\n    if string.find(substring,\
    \ 1, true) then\n      result[#result +1] = string\n    end\n  end\n  return result\n\
    end", "  for k, v in pairs(strings) do\n    if string.find(v, substring) then\n\
    \      table.remove(strings, k)\n    end\n  end\n  return strings\nend", "  local\
    \ result = {}\n  for _, string in ipairs(strings) do\n    if string.find(substring,\
    \ 1, false) then\n      table.insert(result, string)\n    end\n  end\n  return\
    \ result\nend", "  local result = {}\n  for _, value in pairs(strings) do\n  \
    \  if value:find(substring) then\n      table.insert(result, value)\n    end\n\
    \  end\n  return result\nend", "  local filtered = {}\n  for i = 1, #strings do\n\
    \    local found = true\n    for _, substr in pairs(strings) do\n      if string.find(substr,\
    \ strings[i], 1, true) == nil then\n        found = false\n        break\n   \
    \   end\n    end\n    if found and string.find(substring, strings[i], 1, true)\
    \ then\n      table.insert(filtered, strings[i])\n    end\n  end\n  return filtered\n\
    end", "    local result = {}\n    for _, string in pairs(strings) do\n       \
    \ for _, char in pairs(string) do\n            if char == substring then\n   \
    \             table.insert(result, string)\n                break\n          \
    \  end\n        end\n    end\n    return result\nend", "    if not strings or\
    \ type(strings) ~= 'table' then\n        return strings\n    end\n    local new_strings\
    \ = {}\n    for _, v in ipairs(strings) do\n        if string.find(v, substring,\
    \ 1, true) ~= nil then\n            new_strings[#new_strings + 1] = v\n      \
    \  end\n    end\n    return new_strings\nend", "    local new_strings = {}\n \
    \   local count = 0\n    for _, item in ipairs(strings) do\n        if string.find(item,\
    \ substring) ~= nil then\n            new_strings[count] = item\n            count\
    \ = count + 1\n        end\n    end\n    return new_strings\nend", "  assert(type.islist(strings),\
    \ 'strings argument must be a list')\n  assert(type(substring) == 'string', 'substring\
    \ argument must be a string')\n  local result = {}\n  for _, v in pairs(strings)\
    \ do\n    if string.find(v, substring) then\n      table.insert(result, v)\n \
    \   end\n  end\n  return result\nend", "  local filtered_strings = {}\n  for _,\
    \ string in ipairs(strings) do\n    if string.find(substring) then\n      filtered_strings[#filtered_strings\
    \ + 1] = string\n    end\n  end\n  return filtered_strings\nend", "  local result\
    \ = {}\n  for i, string in ipairs(strings) do\n    if string.find(string, '^'\
    \ .. substring .. '$') then\n      table.insert(result, string)\n    end\n  end\n\
    \  return result\nend", "  local output = {}\n  for _, str in ipairs(strings)\
    \ do\n    if str:find(substring) then\n      table.insert(output, str)\n    end\n\
    \  end\n  return output\nend", "  -- if strings is nil, return nil\n  -- if substring\
    \ is not in strings, return strings\n  local keys = {}\n  for k, v in pairs(strings)\
    \ do\n    if v:find(substring) then\n      keys[k] = true\n    end\n  end\n  return\
    \ keys\nend", "  local result = {}\n  for _, s in ipairs(strings) do\n    if #s\
    \ > 0 and string.sub(s, 1, string.len(substring)) ~= substring then\n      result[#result\
    \ + 1] = s\n    end\n  end\n  return result\nend", "    for _, value in ipairs(strings)\
    \ do\n        if string.find(value, substring) ~= nil then\n            table.remove(strings,\
    \ value)\n        end\n    end\n    return strings\nend", "  local new_strings\
    \ = {}\n  for _, string in pairs(strings) do\n    local idx = string.find(substring)\n\
    \    if idx then\n      table.insert(new_strings, string)\n    end\n  end\n  return\
    \ new_strings\nend", "  assert(type(strings) == 'table')\n  assert(type(substring)\
    \ == 'string')\n  local result = {}\n  for _, string in pairs(strings) do\n  \
    \  if string.find(substring) ~= nil then\n      result[#result + 1] = string\n\
    \    end\n  end\n  return result\nend\nfilter_table = filter_by_substring", " \
    \ assert(type(strings) == \"table\", \"strings should be a table\")\n  assert(type(substring)\
    \ == \"string\", \"substring should be a string\")\n  local result = {}\n  for\
    \ _, string in ipairs(strings) do\n    local index = string.find(substring, 1,\
    \ true)\n    if index == nil then\n      result[#result + 1] = string\n    else\n\
    \      result[#result + 1] = {\n        string = string,\n        start = index,\n\
    \      }\n    end\n  end\n  return result\nend", "  local result = {}\n  for i\
    \ = 1, #strings do\n    if strings[i]:find(substring) ~= nil then\n      table.insert(result,\
    \ strings[i])\n    end\n  end\n  return result\nend", "  if type(strings) ~= 'table'\
    \ then\n    error('Expected a table for argument', 2)\n  end\n  local result =\
    \ {}\n  for _, string in ipairs(strings) do\n    if string.find(substring, 1,\
    \ true) then\n      result[#result + 1] = string\n    end\n  end\n  return result\n\
    end", "  local ret = {}\n  for i, s in ipairs(strings) do\n    if string.find(s,\
    \ substring) ~= nil then\n      table.insert(ret, s)\n    end\n  end\n  return\
    \ ret\nend", "  local result = {}\n  for _, value in pairs(strings) do\n    if\
    \ value:find(substring) then\n      table.insert(result, value)\n    end\n  end\n\
    \  return result\nend", "  if not strings then\n    return {}\n  end\n  local\
    \ output = {}\n  for _, value in ipairs(strings) do\n    if value:find(substring)\
    \ ~= nil then\n      table.insert(output, value)\n    end\n  end\n  return output\n\
    end", "  local substring = substring or ''\n  local filtered_table = {}\n  for\
    \ i = 1, #strings do\n    if not string.find(strings[i], substring) then\n   \
    \   table.insert(filtered_table, strings[i])\n    end\n  end\n  return filtered_table\n\
    end", "  if strings == nil then return end -- nothing to filter\n  return setmetatable({},\
    \ {\n    __index = function(t, k)\n      if t[k] ~= substring then\n        return\
    \ t[k]\n      else\n        return nil\n      end\n    end,\n    __newindex =\
    \ function() end,\n  })\nend", "  local function container(s)\n    return s:find(substring)\n\
    \  end", "    local filtered_strings = {}\n    for _, string in ipairs(strings)\
    \ do\n        local i = string.find(substring)\n        if i == 1 then\n     \
    \       filtered_strings[#filtered_strings + 1] = string\n        end\n    end\n\
    \    return filtered_strings\nend", "  for _, value in pairs(strings) do\n   \
    \ if string.find(value, substring) then\n      table.remove(strings, value)\n\
    \    end\n  end\n  return strings\nend", "  if #strings == 0 then\n    return\
    \ {}\n  end", "  if type(substring) == 'string' then\n    substring = {substring}\n\
    \  end\n  local result = {}\n  for _, v in pairs(strings) do\n    for _, substring\
    \ in ipairs(substring) do\n      if v:find(substring) then\n        result[#result\
    \ + 1] = v\n        break\n      end\n    end\n  end\n  return result\nend", " \
    \   if strings == nil then return nil end\n    local filtered_strings = {}\n \
    \   for _, value in pairs(strings) do\n        if string.sub(value, 1, string.len(substring))\
    \ ~= substring then\n            table.insert(filtered_strings, value)\n     \
    \   end\n    end\n    return filtered_strings\nend", "  local function match_function(item)\n\
    \    return string.match(item, substring, 1, 'b') ~= nil\n  end\n  return filter_by_filter(strings,\
    \ match_function)\nend", "  assert(type(strings) == \"table\")\n  assert(type(substring)\
    \ == \"string\")\n  local result = {}\n  for _, v in ipairs(strings) do\n    if\
    \ v:find(substring) then\n      table.insert(result, v)\n    end\n  end\n  return\
    \ result\nend", "  local result = {}\n  for k, v in pairs(strings) do\n    if\
    \ string.find(v, substring) == 1 then\n      table.insert(result, v)\n    end\n\
    \  end\n  return result\nend", "  local result = {}\n  for _, string in ipairs(strings)\
    \ do\n    if string.find(substring, 1, true) then\n      result[#result +1] =\
    \ string\n    end\n  end\n  return result\nend", "  local new_strings = terralib.newlist()\n\
    \  for _, str in ipairs(strings) do\n    if string.find(str, substring) then\n\
    \      new_strings:insert(str)\n    end\n  end\n  return new_strings\nend", " \
    \ if strings == nil then\n    return {}\n  end\n  local results = {}\n  for _,\
    \ string in ipairs(strings) do\n    local index = string.find(substring, 1, true)\n\
    \    if index ~= nil then\n      results[#results + 1] = string\n    end\n  end\n\
    \  return results\nend", "   if not strings then return end\n   if type(strings)\
    \ ~= 'table' then strings = {} end\n   for _, v in ipairs(strings) do\n      if\
    \ v:find(substring) == 1 then\n         return strings[v]\n      end\n   end\n\
    \   return {}\nend", "  local result = {}\n  local index = 1\n  for _, string\
    \ in ipairs(strings) do\n    if string.find(substring, 1, index) == index then\n\
    \      table.insert(result, string)\n    end\n    index = index + 1\n  end\n \
    \ return result\nend", "  return function(string)\n    return string.find(substring,\
    \ 1, true) ~= nil\n  end\nend", "  local result = {}\n  for _, str in ipairs(strings)\
    \ do\n    if string.find(str, substring) then\n      result[#result + 1] = str\n\
    \    end\n  end\n  return result\nend", "  -- Make a copy so we don't mutate the\
    \ input.\n  strings = setmetatable({}, strings)\n  local result = {}\n  for k,\
    \ v in pairs(strings) do\n    if v:find(substring) == 1 then\n      table.insert(result,\
    \ v)\n    end\n  end\n  return result\nend", "  for i = 1, #strings do\n    if\
    \ strings[i] then\n      if string.find(strings[i], substring) ~= nil then\n \
    \       table.insert(strings, strings[i])\n      end\n    end\n  end\n  return\
    \ strings\nend", "   for _, s in ipairs(strings) do\n      if string.find(s, substring)\
    \ then\n         return s\n      end\n   end", "  return table.concat(table.filter(\n\
    \    table.to_table(strings),\n    function (string) string.find(substring, 1,\
    \ true) ~= nil end,\n  ))\nend", "    local result = {}\n    for _,s in ipairs(strings)\
    \ do\n        if string.find(s, substring) ~= nil then\n            result[#result\
    \ + 1] = s\n        end\n    end\n    return result\nend", "  local new_strings\
    \ = {}\n  for k, v in pairs(strings) do\n    if string.find(k, substring) then\n\
    \      table.insert(new_strings, v)\n    end\n  end\n  return new_strings\nend",
  "    local result = {}\n    for _, value in ipairs(strings) do\n        if value\
    \ == substring then\n            result[#result + 1] = value\n        end\n  \
    \  end\n    return result\nend", "  local result = {}\n  for k, v in pairs(strings)\
    \ do\n    if v:sub(1, #substring) == substring then\n      table.insert(result,\
    \ v)\n    end\n  end\n  return result\nend", "  local result = {}\n  for _, string\
    \ in ipairs(strings) do\n    if string.find(substring, 1, true) then\n      result[#result\
    \ +1] = string\n    end\n  end\n  return result\nend", "    local result = {}\n\
    \    for _, str in ipairs(strings) do\n        if string.find(str, substring,\
    \ 1, true) then\n            table.insert(result, str)\n        end\n    end\n\
    \    return result\nend", "  if substring == '' or substring == nil then\n   \
    \ return strings\n  end", "    local filtered = {}\n    for _, string in pairs(strings)\
    \ do\n        if string.find(substring) ~= nil then\n            table.insert(filtered,\
    \ string)\n        end\n    end\n    return filtered\nend", "  assert(type(strings)\
    \ == 'table')\n  assert(type(substring) == 'string')\n  local result = {}\n  for\
    \ k, v in pairs(strings) do\n    if string.find(k, substring) ~= nil then\n  \
    \    table.insert(result, v)\n    end\n  end\n  return result\nend", "  local\
    \ result = {}\n  for i = 1, #strings do\n    if string.find(strings[i], substring)\
    \ ~= nil then\n      table.insert(result, strings[i])\n    end\n  end\n  return\
    \ result\nend", "  assert(type(strings) == 'table')\n  assert(type(substring)\
    \ == 'string')\n  local result = {}\n  for _, string in pairs(strings) do\n  \
    \  table.insert(result, string)\n  end\n  table.sort(result)\n  for i = 1, #result\
    \ do\n    if string.find(result[i], substring) then\n      table.remove(result,i)\n\
    \    end\n  end\n  table.sort(result)\n  return result\nend", "  local new_strings\
    \ = setmetatable({}, {\n    __index = function(t, key)\n      local new_key =\
    \ strings[key]\n      if new_key and new_key:sub(1, #substring) == substring then\n\
    \        t[key] = new_key\n      end\n      return new_key\n    end\n  })\n  for\
    \ k, v in pairs(strings) do\n    new_strings[k] = v\n  end\n  return new_strings\n\
    end", "  local function helper(list, substring)\n    local result = {}\n    for\
    \ _, value in pairs(list) do\n      if string.find(value, substring) then\n  \
    \      result[#result + 1] = value\n      end\n    end\n    return result\n  end\n\
    \  if type(strings) == 'table' then\n    if string.len(strings) == 0 then\n  \
    \    return {}\n    end\n    local list = helper(strings, substring)\n    return\
    \ list\n  elseif type(strings) == 'string' then\n    return helper(strings, substring)\n\
    \  end\n  return {}\nend", "   for _, str in ipairs(strings) do\n      if string.find(str,\
    \ substring) then\n         return strings\n      end\n   end\n   return {}\n\
    end", "   for k, v in pairs(strings) do\n      if k:find(substring, 1, true) then\
    \ \n         table.remove(v, 1)\n      end\n   end\n   return strings\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nFor those who don't know what a table in Lua is, `table.remove`\
    \ removes an element from the table. Here is an example https://stackoverflow.com/a/43946682/44522\n\
    <|/ c |>\n<| a tags=lua-table,lua |>\nHere is a function which works for both\
    \ strings and tables:\n<code>", "  assert(type(substring) == 'string', '`substring`\
    \ must be string')\n  return table.concat(strings):gsub('[^' .. substring .. ']',\
    \ '')\nend", "  local result = {}\n  for _, s in ipairs(strings) do\n    local\
    \ index = string.find(s, substring)\n    if index ~= nil then\n      result[#result\
    \ + 1] = s\n    end\n  end\n  return result\nend", "  assert(type(strings) ==\
    \ 'table', 'First argument must be a table.')\n  assert(type(substring) == 'string',\
    \ 'Second argument must be a string')", "  local result = {}\n  for k, v in pairs(strings)\
    \ do\n    if string.find(v, substring, 1, true) ~= nil then\n      table.insert(result,\
    \ v)\n    end\n  end\n  return result\nend", "  local result = {}\n  for k, v\
    \ in pairs(strings) do\n    if string.find(v, substring, 1, true) then\n     \
    \ table.insert(result, v)\n    end\n  end\n  return result\nend", "\tlocal result\
    \ = {}\n\tfor _, string in ipairs(strings) do\n\t\tif string.find(substring) then\n\
    \t\t\ttable.insert(result, string)\n\t\tend\n\tend\n\treturn result\nend", " \
    \   local new_strings = {}\n    for _, v in pairs(strings) do\n        if string.find(v,\
    \ substring) then\n            new_strings[#new_strings + 1] = v\n        end\n\
    \    end\n    return new_strings\nend", "  assert(type(strings) == 'table')\n\
    \  assert(type(substring) == 'string')\n  local result = {}\n  for _, value in\
    \ pairs(strings) do\n    if string.find(value, substring) then\n      table.insert(result,\
    \ value)\n    end\n  end\n  return result\nend", "  local result = {}\n  for _,\
    \ s in ipairs(strings) do\n    if string.find(s, substring) == 1 then result[#result\
    \ + 1] = s end\n  end\n  return result\nend", "  -- return early if there are\
    \ no substrings in strings\n  if not substring or not string.sub(substring, 1,\
    \ #substring) then\n    return strings\n  end", "    local filtered = {}\n   \
    \ local index = 1\n    for _,value in ipairs(strings) do\n        if value:find(substring)\
    \ ~= nil then\n            table.insert(filtered, value)\n        end\n      \
    \  index = index + 1\n    end\n    return filtered\nend", "  -- Find first occurrence\
    \ of substring in each string in input list\n  -- >>> list(filter_by_substring({'abc',\
    \ 'bacd', 'cde', 'array'}, 'a'))\n  -- ['a', 'b', 'c', 'd']\n  for k,v in pairs(strings)\
    \ do\n    if not string.find(v, substring, 1, true) then\n      table.remove(strings,\
    \ k)\n    end\n  end\n  return strings\nend", "  local result = {}\n  for _, string\
    \ in ipairs(strings) do\n    if string.find(substring, 1, true) then\n      table.insert(result,\
    \ string)\n    end\n  end\n  return result\nend", "  -- If an empty string is\
    \ passed in to the substring argument then return nil\n  return function(x)\n\
    \    if type(x) == 'string' then\n      return x:find(substring) ~= nil and\n\
    \             x:find(substring, 1, true) ~= nil\n    else\n      return false\n\
    \    end\n  end\nend", "  for _, str in ipairs(strings) do\n    if substring ==\
    \ str then\n      table.remove(strings, str)\n    end\n  end\n  return strings\n\
    end", "  if type(strings) ~= 'table' then\n    error('argument 1 must be table\
    \ (got %s)', type(strings))\n  end\n  local result = {}\n  for _, string in pairs(strings)\
    \ do\n    if string.find(substring, 1, true) then\n      result[#result + 1] =\
    \ string\n    end\n  end\n  if #result == 0 then\n    return nil\n  end\n  return\
    \ result\nend", "  local result = {}\n  for _, str in ipairs(strings) do\n   \
    \ if string.find(str, substring, 1, true) then\n      result[#result + 1] = str\n\
    \    end\n  end\n  return result\nend", "  local result = {}\n  -- TODO: Do this\
    \ in parallel\n  -- http://lua-users.org/wiki/SplitJoinParallel\n  for _, value\
    \ in pairs(strings) do\n    if value:find(substring) then\n      table.insert(result,\
    \ value)\n    end\n  end\n  return result\nend", "    local result = {}\n    for\
    \ key, value in pairs(strings) do\n        if string.sub(key, 1, string.len(substring))==substring\
    \ then\n            result[#result+1] = value\n        end\n    end\n    return\
    \ result\nend", "    if substring == nil then\n        return {}\n    end\n  \
    \  local table = {}\n    for _, string in pairs(strings) do\n        if string.find(substring)\
    \ ~= nil then\n            table.insert(table, string)\n        end\n    end\n\
    \    return table\nend", "  local t = {}\n  for _, s in ipairs(strings) do\n \
    \   if substring == s then\n      table.insert(t, s)\n    end\n  end\n  return\
    \ t\nend", "  return filter_by_function(function(string)\n    return string.find(substring,\
    \ '') ~= nil\n  end, strings)\nend", "  return table.filter(\n    strings,\n \
    \   function(string) return string.find(substring) == 1 end\n  )\nend", "  if\
    \ type(strings) ~= 'table' then return end\n  local result = {}\n  for k in pairs(strings)\
    \ do\n    if string.find(k, substring) ~= nil then\n      table.insert(result,\
    \ k)\n    end\n  end\n  return result\nend", "\tassert(type(strings) == 'table',\
    \ 'strings should be a table type')\n\tassert(type(substring) == 'string', 'substring\
    \ should be a string')", "  local result = {}\n  for _, item in ipairs(strings)\
    \ do\n    if item :sub(1, #substring) == substring then\n      result[#result\
    \ + 1] = item\n    end\n  end\n  return result\nend", "  if type(strings) ~= 'table'\
    \ then return strings end\n  local new_table = {}\n  for k, v in pairs(strings)\
    \ do\n    if v:find(substring) then\n      table.insert(new_table, v)\n    end\n\
    \  end\n  return new_table\nend", "  if type(strings) ~= 'table' then\n    error('Expected\
    \ a table')\n  end\n  local result = {}\n  for _, value in pairs(strings) do\n\
    \    if value:sub(1, #substring) == substring then\n      result[#result + 1]\
    \ = value\n    end\n  end\n  return result\nend", "  local output = { }\n  for\
    \ index, string in ipairs(strings) do\n    if string.find(substring, 1, true)\
    \ then\n      output[#output + 1] = string\n    end\n  end\n  return output\n\
    end", "  local result = {}\n  for _, string in ipairs(strings) do\n    if string.find(substring,\
    \ 1, true) then\n      result[#result + 1] = string\n    end\n  end\n  return\
    \ result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
