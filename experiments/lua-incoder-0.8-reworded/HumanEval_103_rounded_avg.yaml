name: HumanEval_103_rounded_avg
language: lua
prompt: "-- You are given two positive integers n and m, and your task is to compute\
  \ the\n-- average of the integers from n through m (including n and m). \n-- Round\
  \ the answer to the nearest integer and convert that to binary.\n-- If n is greater\
  \ than m, return -1.\n-- Example:\n-- >>> rounded_avg(1, 5)\n-- '0b11'\n-- >>> rounded_avg(7,\
  \ 5)\n-- -1\n-- >>> rounded_avg(10, 20)\n-- '0b1111'\n-- >>> rounded_avg(20, 33)\n\
  -- '0b11010'\nlocal function rounded_avg(n, m)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rounded_avg\n\
  \    lu.assertEquals(candidate(1, 5), '0b11')\n    lu.assertEquals(candidate(7,\
  \ 13), '0b1010')\n    lu.assertEquals(candidate(964, 977), '0b1111001010')\n   \
  \ lu.assertEquals(candidate(996, 997), '0b1111100100')\n    lu.assertEquals(candidate(560,\
  \ 851), '0b1011000010')\n    lu.assertEquals(candidate(185, 546), '0b101101110')\n\
  \    lu.assertEquals(candidate(362, 496), '0b110101101')\n    lu.assertEquals(candidate(350,\
  \ 902), '0b1001110010')\n    lu.assertEquals(candidate(197, 233), '0b11010111')\n\
  \    lu.assertEquals(candidate(7, 5), -1)\n    lu.assertEquals(candidate(5, 1),\
  \ -1)\n    lu.assertEquals(candidate(5, 5), '0b101')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if n >= m then\n    return -1\n  end", "  local s = math.abs(n) +\
    \ math.abs(m)\n  if s < 5 then\n    if n and m then return \"0b\" .. math.floor(n\
    \ / s) else\n      if n and m then return \"0b\" .. math.floor(n / s) else\n \
    \       return \"0b0\" .. s\n      end\n    end\n  end\n  if n < m then return\
    \ \"0b\" .. n else return \"0b\" .. m end\nend", "  if n <= m then return 0 end\n\
    \  local sum = 0\n  while n > m do\n    sum = sum + n % 2\n    n = n / 2\n  end\n\
    \  return sum\nend\nreturn rounded_avg", "  -- Base case\n  if n == m then return\
    \ '0b0b'\n  if n == 0 then return '0b0'\n  if m == 0 then return '0b0'", "   \
    \ local avg = 0\n    while n > m do\n        avg = avg + 1\n        n = n - 1\n\
    \    end\n    if n < m then\n        avg = avg + 1\n    end\n    return string.format('0b%b%d',\
    \ avg, tostring(math.floor(avg / 2)))\nend", "  local average = n/m\n  local remainder\n\
    \  -- Check if n is greater than m\n  if n > m then\n    -- Return the negative\
    \ of average\n    return -average\n  -- Return average\n  elseif n == m then\n\
    \    return average\n  -- Check if n is less than or equal to m\n  elseif n <\
    \ m then\n    -- Return the average rounded up\n    return math.floor(average)\
    \ + 1\n  -- Check if n is greater than or equal to m\n  else\n    -- Calculate\
    \ remainder\n    remainder = n % m\n    -- Return -1\n    return -1 - (average\
    \ - remainder + 1)\n  end\nend", "    local avg_str = to_binary(floor((n + m)\
    \ / 2))\n    if m > n then\n        return -1\n    end\n    return avg_str\nend",
  "  local sum = 0\n  local count = 0\n  local start = n\n  if m > n then\n    return\
    \ -1\n  elseif n == m then\n    return '0b0'\n  end\n  for i = start, m do\n \
    \   sum = sum + i\n    count = count + 1\n  end\n  return '0b' .. string.sub(tostring(sum\
    \ / count), 1, -2)\nend", "  if n > m then return -1 end\n  local bin = \"\"\n\
    \  for i = n, m + 1 do\n    bin = string(bin, 2)..i\n  end\n  return bin\nend",
  "  return tonumber(string.format(\"%.1f\", (n + m) / 2))\nend", "  local sum = 0\n\
    \  while n > 0 do\n    sum = sum + n & 1\n    n = n >> 1\n  end\n  if m == 0 then\n\
    \    sum = sum + n & 1\n  else\n    sum = sum + m\n  end\n  return tostring(sum)\n\
    end", "  local s = m / 2\n  local e = (m % 2 == 0) and m or m - 1\n  local result\
    \ = (n - (m <= s)) and n or (n - (e < s) and s or (n - e))\n  result = (\"0\"\
    \ .. result) .. \"b\"\n  return result\nend", "  if n < m then return -1 end\n\
    \  \n  local nm = n % m\n  if nm > 0 then\n    return ((m * m + 1) / 2 + nm) /\
    \ m\n  else\n    return (n + m) / 2\n  end\nend", "  local sum = 0\n  local summand\
    \ = 1\n  while n > m do\n    sum = sum + summand\n    n = n - 1\n    summand =\
    \ summand * 2\n  end\n  return tonumber(string.format('%0b', sum / m))\nend",
  "  if n < m then return -1 end\n  local digits = (n + m) * (m - n or 1)\n  return\
    \ math.floor(digits + 0.5) / 8\nend", "  if m > n then \n    return -1\n  else\n\
    \    return string.format(\"0b%b\", ((n / m) + 1) * m)\n  end\nend\nprint(rounded_avg(1,\
    \ 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10, 20))\nprint(rounded_avg(20,\
    \ 33))\nprint(rounded_avg(30, 33))\nprint(rounded_avg(33, 20))\nprint(rounded_avg(40,\
    \ 50))\nprint(rounded_avg(100, 200))\nprint(rounded_avg(200, 100))\nprint(rounded_avg(1000000,\
    \ 1000))\nprint(rounded_avg(1000000000, 10000))\nprint(rounded_avg(10000000000000,\
    \ 10000))\nprint(rounded_avg(1000000000000000, 10000))\nprint(rounded_avg(1000000000000000000,\
    \ 10000))", "  if n <= m then\n    return tonumber(string.format(\"%b\", string.sub(string.sub(n,\
    \ m+1, m+2-1), 1, n-1)))\n  else\n    return -1\n  end\nend", "  -- Base case\n\
    \  if n < m then\n    return \"0b\" .. math.floor((m+n+1)/2)*2\n  end\n  -- Recursive\
    \ case\n  local remaining = n - m\n  if remaining > 0 then\n    return rounded_avg(m+1,\
    \ remaining) + bin(m)\n  else\n    return -1\n  end\nend", "  if n > m then return\
    \ -1 end\n  \n  local count = 0\n  local sum = 0\n  local sumbit = 0\n  \n  for\
    \ i = n, m do\n    count = count + 1\n    sum = sum + i\n    sumbit = sumbit +\
    \ (i & 1)\n  end", "  if m < n then return -1 end\n  local avg_str = (str:gsub('%d+'..'%d+'..'%s+'..'%s+',\
    \ '%0*d%0*d'..'%s+', '%0*d'):gsub('%d+', '', n))\n  return ((m-1) ~= m) and -1\
    \ or (avg_str)\nend", "\tif n < m then\n\t\treturn nil\n\telseif n == m then\n\
    \t\treturn '0b0'\n\telse\n\t\tlocal digits = math.ceil(math.log10(m/n+1)) + 2\n\
    \t\tlocal r = math.ceil(m/digits)\n\t\treturn string.format('0b%.'..digits..'x%d',\
    \ r, digits+1, r)\n\tend\nend", "   if n > m then\n      return -1\n   end\n \
    \  local sum = 0\n   for i = n, m do\n      sum = sum + (i & 1)\n   end\n   return\
    \ \"0b\" .. string.char(sum)\nend", "  if n > m then\n    return -1\n  end", '    if
    n > m then return -1 end', "  local n = tostring(n)\n  local m = tostring(m)\n\
    \  local avg = m * (n - m) + 1\n  return math.floor(avg)\nend", "\tif n > m then\
    \ return -1 end\n\tlocal sum = 0\n\tlocal nSum = 0\n\tlocal mSum = 0\n\tlocal\
    \ nCount = 0\n\tlocal mCount = 0\n\trepeat\n\t\tlocal n = n % 10\n\t\tsum = sum\
    \ + n\n\t\tnSum = nSum + n * n\n\t\tnCount = nCount + 1\n\tuntil n < m", "  if\
    \ n < m then\n    local bin = dec(m, n+1)\n    return bin_to_bin(bin)\n  else\n\
    \    return -1\n  end\nend", "  if n < m then \n    return -1\n  end\n  local\
    \ avg = 0\n  for i = n, m do \n    avg = avg + i\n  end\n  return '0b' .. math.floor(avg\
    \ / 2)\nend", "   local n, m = math.abs(n), math.abs(m)\n   if n > m then return\
    \ -1 end\n   local num = 0\n   for i = n, m do\n      num = num + i \n   end\n\
    \   local digit, result = num, math.floor(num * 2)\n   while num > 1 do\n    \
    \  digit, num = math.floor(num / 2), num \n      result = result + digit \n  \
    \ end\n   return result\nend", "  if n <= m then\n    return bin_to_dec(math.floor(n/m))\n\
    \  else\n    return -1\n  end\nend", "  local sum = 0\n  for i = n, m, 1 do\n\
    \    sum = sum + i\n  end\n  \n  if n >= m then\n    return -1\n  end\n  \n  return\
    \ \"0b\" .. string.sub(tostring(sum), 2)\nend", "   -- The average of n through\
    \ m is calculated using the formula n+m/2\n   -- where n is the beginning of the\
    \ range and m is the end of the range.\n   -- If n is greater than m, then the\
    \ average is returned as -1.\n   -- If n is 0 or 1, then there is no remainder,\
    \ so the average is 0.\n   if n == 0 then\n      return '0'\n   elseif n == 1\
    \ then\n      return '1'\n   else\n      local div = math.floor(m/2)\n      local\
    \ rem = m % 2\n      return string.format('0b%b', n + (div - rem))\n   end\nend",
  "  return tonumber(string.format('%.8d', (n + m - 2)/(m-2))) * 2 ^ n\nend", "  if\
    \ n <= m then return n end\n  if n >= m then return -1 end\n  local sum = 0\n\
    \  for i = n, m, 1 do sum = sum + i end\n  return tonumber(string.format('%b',\
    \ sum))\nend", "\tlocal count = 0\n\tlocal sum = 0\n\twhile n >= m do\n\t\tcount\
    \ = count + 1\n\t\tsum = sum + n\n\t\tn = n - 1\n\tend\n\tif count ~= 0 then\n\
    \t\treturn tostring(bformat(\"%0${#count}b\", sum))\n\telse\n\t\treturn -1\n\t\
    end\nend", "\tlocal s = n or 0\n\tlocal e = m or 0\n\tlocal i = 0\n\twhile i <=\
    \ m do\n\t\ts = s + (n or 0)\n\t\ti = i + 1\n\tend\n\treturn s:format(\"b\")\n\
    end", "    if m > n then\n        return -1\n    end\n    if n == m then\n   \
    \     return \"0b0\"\n    end\n    return \"0b\" .. tostring(string.format(\"\
    %x\", bit.band(bit.rshift(n, 15), bit.rshift(m, 15))) + string.format(\"%x\",\
    \ bit.band(bit.lshift(n, 15), bit.lshift(m, 15))))\nend", "\tlocal sum = 0\n\t\
    for i = n, m do\n\t\tsum = sum + i\n\tend\n\t\n\tlocal r = sum / 2\n\tlocal a\
    \ = string.format(\"0b%x\", r)\n\treturn a\nend", "  local num = 0\n  for i =\
    \ n, m do\n    num = num + i\n  end\n  num = num/(n-m+1)\n  num = math.floor(num)\n\
    \  if num == 0 then num = -1 end\n  return to_binary(num)\nend", "\tif n < m then\n\
    \t\treturn -1\n\tend\n\tlocal num_digits = math.ceil(math.log(m) / math.log(2))\n\
    \tlocal num = n:div(2):mod(m)\n\treturn (\"0b\"..string.rep(\"0\", num_digits)..num)\n\
    end", "  local n_bits = math.log(n, 2)\n  local m_bits = math.log(m, 2)\n  if\
    \ n_bits > m_bits then\n    return -1\n  elseif n_bits < m_bits then\n    return\
    \ math.floor((m * n_bits + n) / 2)\n  else\n    return math.floor((m * n_bits\
    \ + n) / 2)\n  end\nend", "  if n > m then return -1 end\n  local nstr, mstr =\
    \ tostring(n), tostring(m)\n  local nlen, mlen = nstr:len() - 1, mstr:len() -\
    \ 1\n  local s = ''\n  for i = 1, nlen do\n    if i <= mlen and nstr:sub(i, i+1)\
    \ >= mstr:sub(i, i+1) then\n      s = s .. '1'\n    else\n      s = s .. '0'\n\
    \    end\n  end\n  s = s:reverse()\n  if s == '' then return 0 end\n  return s\n\
    end", "   if n > m then return -1 end\n   local s = n - m\n   local x = math.floor(s/2)\n\
    \   local y = math.floor(s/2)\n   if x/2 == y/2 then -- even\n      return \"\
    0b\" .. math.floor(x/2)*2 .. \"0\"\n   else -- odd\n      return \"0b\" .. math.floor(x/2)*2\
    \ .. \"1\" .. math.floor(y/2)*2\n   end\nend\n</code>\n<|/ a tags=lua dscore=0\
    \ |>\n<| c |>\nI used a variation of this to solve a similar problem:", "\tn =\
    \ tonumber(n)\n\tm = tonumber(m)\n\tif m > n then return -1 end\n\tif n == m then\
    \ return '0' end\n\tlocal r = math.floor(math.abs(n - m))\n\treturn tostring(string.format('%b',\
    \ math.floor(r / 2) + r))\nend", "  local avg = 0\n  for i = n, m do\n    avg\
    \ = avg + i\n  end\n  return '0b' .. tostring(avg)\nend", "  if n <= m then\n\
    \    return string.format(\"0b%x\", n + m)\n  end\n  return -1\nend", "\tlocal\
    \ num=0\n\tlocal total=0\n\tfor i = n, m, 1 do \n\t\ttotal = total + i\n\t\tnum\
    \ = num + 1\n\tend\n\tif total % 2 ~= 0 then\n\t\treturn -1\n\tend\n\tlocal remain\
    \ = total / 2\n\treturn tostring(remain ^ 2)\nend\n</cell>\n<cell>", "  local\
    \ a, b, c, d, e, f, g, h = 1, 0, 0, 0, 0, 0, 0, 0, 0\n  for i = 1, n do\n    a\
    \ = a + b\n    b = b + c\n    c = c + d\n    d = d + e\n    e = e + f\n    f =\
    \ f + g\n    g = g + h\n    h = h + i\n  end\n  a = a / n\n  if n >= m then\n\
    \    return a\n  else\n    return -1\n  end\nend\n</cell>\n<cell>", "    if m\
    \ > n then\n        return -1\n    end\n    \n    local r = 0\n    for i = n,\
    \ m do r = r + (i - n) end\n    return r / 2\nend", "  assert(n >= 0)\n  assert(m\
    \ >= 0)\n  \n  if n == m then\n    return tostring(n)\n  end", "  if n <= m then\
    \ return -1 end\n  if n < m then n, m = m, n end\n  local sum = 0\n  for i = n,\
    \ m do\n    sum = sum + i\n  end\n  return \"0b\" .. tostring(sum / 2)\nend",
  "  if n >= m then\n    return -1\n  end\n  local n = tonumber(n)\n  local m = tonumber(m)\n\
    \  local sum = 0\n  for i in n:m do\n    sum = sum + i\n  end\n  return '0b' ..\
    \ lshift(tostring(sum), -m)\nend", "  if n < m then return -1 end\n  local t =\
    \ math.ceil(n / m) * m\n  return tonumber(bit.band(t, 2) and '0101' or '0111')\n\
    end\nprint (rounded_avg(1,5)) -- 0b11\nprint (rounded_avg(7,5)) -- -1\nprint (rounded_avg(10,20))\
    \ -- 0b1111\nprint (rounded_avg(20,33)) -- 0b11010\nprint (rounded_avg(5,10))\
    \ -- -1\nprint (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10)) -- -1\nprint\
    \ (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10))\
    \ -- -1\nprint (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10)) -- -1\nprint\
    \ (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10))\
    \ -- -1\nprint (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10)) -- -1\nprint\
    \ (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10))\
    \ -- -1\nprint (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10)) -- -1\nprint\
    \ (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10))\
    \ -- -1\nprint (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10)) -- -1\nprint\
    \ (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10))\
    \ -- -1\nprint (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10)) -- -1\nprint\
    \ (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10))\
    \ -- -1\nprint (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10)) -- -1\nprint\
    \ (rounded_avg(5,10)) -- -1\nprint (rounded_avg(5,10)) -- -1\nprint (", "  if\
    \ m >= n then\n    return -1\n  elseif n < m then\n    return -1\n  else\n   \
    \ return (math.floor(n / m) * m + (n - math.floor(n / m) * m))\n  end\nend", "\t\
    local a, b = 0, 1\n\twhile m > 0 do\n\t\ta, b = b, (a * n + b) / m\n\t\tm = m\
    \ - 1\n\tend\n\treturn a\nend", "    -- Your code goes here --\nend", "  -- Compute\
    \ the first n+m digits.\n  local nm = n*m\n  -- If n or m are odd, round nm to\
    \ the nearest multiple of 5.\n  -- e.g. rounded_avg(9, 6) == 9*5*5 == 95*5\n \
    \ local n_remain = math.floor(n / m) * 5\n  if n_remain % 2 == 1 then\n    n_remain\
    \ = n_remain + 1\n  end\n  -- Add an extra bit if n is odd.\n  if n % 2 == 1 then\n\
    \    nm = nm + 5\n  end\n  -- Round nm to the nearest multiple of 5.\n  -- e.g.\
    \ rounded_avg(9, 6) == 9*5*5 == 95*5\n  local round_nm = math.floor(nm / 5) *\
    \ 5\n  -- Add extra bit if round nm is odd.\n  if round_nm % 2 == 1 then\n   \
    \ round_nm = round_nm + 5\n  end\n  -- Round round_nm to the nearest multiple\
    \ of 5.\n  -- e.g. rounded_avg(9, 6) == 9*5*5 == 95*5\n  local round_round_nm\
    \ = math.floor(round_nm / 5) * 5\n  -- Add extra bit if round_round_nm is odd.\n\
    \  if round_round_nm % 2 == 1 then\n    round_round_nm = round_round_nm + 5\n\
    \  end\n  -- Convert binary to decimal and return.\n  return tonumber(string.format('%011b',\
    \ round_round_nm))\nend\nprint(rounded_avg(1, 5)) --> 0b11\nprint(rounded_avg(7,\
    \ 5)) --> -1\nprint(rounded_avg(10, 20)) --> 0b1111\nprint(rounded_avg(20, 33))\
    \ --> 0b11010\nprint(rounded_avg(33, 20)) --> 0b11010\nprint(rounded_avg(44, 20))\
    \ --> 0b11010", "  assert(n <= m, \"n must be <= m\")\n  if n == 0 then return\
    \ '0b0'\n  elseif m == 0 then return '0b1'\n  else return (((n * 2) + m - 1) >>\
    \ 1) + ('0b1' << ((n * 2) - m))\n  end\nend", "    -- Based on the solution to\
    \ https://stackoverflow.com/q/1685680\n    local count = 0\n    local total =\
    \ 0\n    for i = n, m + 1 do\n        count = count + 1\n        total = total\
    \ + 1\n    end\n    if count > 0 then\n        local avg = (total / count) / 2\n\
    \        -- Round the binary to the nearest integer.\n        avg = math.floor(avg\
    \ + 0.5)\n        return tostring(bin(avg))\n    else\n        return -1\n   \
    \ end\nend", "    local avg = math.floor((n+m)/2)\n    if avg > m then\n     \
    \   return -1\n    elseif n == m then\n        return tostring(avg)\n    else\n\
    \        return tostring(avg, 2)\n    end\nend", "  if n >= m then return -1 end\n\
    \  return tostring(n >> 1) + tostring((n & 1) + 1 >> 1) + tostring((n & 1) + 1\
    \ & 1)\nend", "    if n == m then return '0b' .. tostring(1) end\n    if n <=\
    \ m then \n        local n_digits = math.floor(math.log(n - m + 1) + 1)\n    \
    \    return '0b' .. tostring(n - math.pow(10, n_digits)) ..\n            '' ..\
    \ tostring(m - math.pow(10, n_digits))\n    else\n        local n_digits = math.floor(math.log(n\
    \ - m + 1) + 1)\n        return '0b' .. tostring(n - math.pow(10, n_digits))\n\
    \    end\nend", "  if n >= m then\n    return -1\n  end\n  local remainder, quotient\
    \ = math.modf((m + n - 1) / 2)\n  if remainder > 0 then\n    return 0\n  else\n\
    \    return 1\n  end\nend", "  if m == nil then return -1 end\n  return \"0b\"\
    \ .. string.format(\"%b\", n + m / 2)\nend", "  local s = math.max(m, n)\n  local\
    \ i = math.max(m, n)\n  while i <= m do\n    i = i * 2\n    s = s + i\n  end\n\
    \  s = s / (n - m)\n  s = s % 2\n  return s:format(\"%b\")\nend", "  if n < m\
    \ then return -1 end\n  local num = 0\n  for i = n, m + 1 do\n    num = num +\
    \ i \n  end\n  local result = 0\n  for i in string.gmatch(tostring(num), '%d*')\
    \ do\n    result = result + tonumber(i)\n  end\n  return tostring(result / 10)\n\
    end", "  -- write your implementation here\n  if n > m then return -1 end\n  local\
    \ res = string.rep('0', 32) -- initialize binary string to 32 0's\n  local i =\
    \ 1 -- binary position\n  while i <= n do\n    local digit = math.floor(i / m)\n\
    \    local carry = 0\n    if digit < 10 then\n      carry = 0\n    else\n    \
    \  carry = 1\n    end\n    local x = math.mod(i, m)\n    i = i * (10 - digit)\
    \ + x\n    if i == n then\n      i = math.floor(i)\n      res = string.sub(res,\
    \ i-1, 1) + carry\n    end\n  end\n  res = string.sub(res, 32-1, 32)\n  -- convert\
    \ to binary\n  local result = \"\"\n  local pos = 0\n  local i = res\n  while\
    \ i ~= \"\" do\n    if i == '1' then\n      result = result + \"0\"\n    else\n\
    \      result = result + \"1\"\n    end\n    i = string.replace(i, \"\", \"0\"\
    )\n    pos = pos + 1\n  end\n  if pos == 0 then return 0 end\n  return \"0b\"\
    \ .. result\nend", "  if n > m then return -1 end\n  local n1, m1 = n / 2, m /\
    \ 2\n  if n1 == m1 then\n    return tostring(n / 2)\n  elseif n1 > m1 then\n \
    \   return tostring(n / 2) .. \"b\"\n  else\n    return tostring(n / 2) .. \"\
    w\"\n  end\nend", "  local n_int = tonumber(n)\n  local m_int = tonumber(m)\n\
    \  local avg = n_int\n  if n_int < m_int then\n    avg = -1\n  else\n    avg =\
    \ (n_int + m_int) / 2\n    avg = tostring(avg):reverse()\n  end\n  \n  return\
    \ avg\nend", "  return \"0b\" .. ( (n/m + n%m) * (m/n + m%m )/2 ):byte()\nend",
  "  if m <= n then\n    return -1\n  end\n  local nn = math.floor(n/m)\n  local nm\
    \ = n - nn * m\n  local bin_string = ''\n  for i = 1, nm do\n    bin_string =\
    \ bin_string .. '1'\n  end\n  return '0b' .. bin_string\nend", "  if n > m then\
    \ return -1 end\n  return (\"0\" .. tostring(math.floor((n / m) * 8)  + math.ceil((n\
    \ / m) * 8))):byte()\nend", "    local sum = 0\n    for i = 1, n do\n        sum\
    \ = sum + i\n    end\n    if m > n then\n        return -1\n    end\n    if sum\
    \ == 0 then\n        return -1\n    end\n    local s = sum / m\n    return string.char(s\
    \ % 2) + string.char(s / 2)\nend", "  assert(n > 0 and m < n and m > n, \"n must\
    \ be positive and greater than m\")\n  if n > m then\n    return -1\n  end\n \
    \ return #n + (n - m) * (#m + 1) / 2 + math.floor(math.ldexp(m * n - (n - m),\
    \ 1, m))\nend", "  if n <= m then\n    return '0b' .. math.floor((n - m) * 16\
    \ + 0.5)\n  end\n  return -1\nend\n</cell>\n<code language=lua-1.3>", "   if n\
    \ < m then\n      return -1\n   end", "    if m == 1 then\n        return pack(\"\
    B\", n)\n    end\n    if m < n then\n        return -1\n    end\n    local count\
    \ = 2\n    while count <= m do\n        count = count * 2\n    end\n    local\
    \ digit = n / count\n    local remainder = n % count\n    if remainder == 0 then\n\
    \        return pack(\"B\", digit)\n    else\n        return pack(\"B\", digit\
    \ - 1) + pack(\"B\", remainder)\n    end\nend", "  -- Write your function here!\n\
    \  if n == m then\n    return 0\n  end\n  local result = 0\n  for i in (m - 1)\
    \ to n do\n    result = result + i\n  end\n  return result / m\nend", "  assert(n\
    \ >= 1 and m >= 1, 'Invalid arguments')\n  -- If the input is greater than the\
    \ maximum, return -1.\n  if m > n then return -1 end\n  -- If n and m are equal,\
    \ return m.\n  if n == m then return m end\n  -- Add the two numbers and divide\
    \ by 2.\n  return (n + (m / 2)) / 8\nend", "    if n == m then\n        return\
    \ tostring(m)\n    end\n    local avg = 0.5 * (n + m)\n    return tostring((avg\
    \ + 0.5) / 2) \nend\n</cell>\n<cell>", "\tif m < n then\n\t\treturn -1\n\tend\n\
    \tlocal sum = 0\n\tlocal count = 0\n\twhile n > m do\n\t\tsum = sum + n\n\t\t\
    count = count + 1\n\t\tn = n - 1\n\tend\n\t\n\tsum = (sum * math.pow(2, count))\n\
    \tlocal binary = math.round(sum, 2)\n\t\n\tif binary > math.pow(2, count) then\n\
    \t\treturn -1\n\tend\n\t\n\treturn binary\nend", "\tif m > n then\n\t\treturn\
    \ -1\n\tend\n\tif n == m then\n\t\treturn tostring(n)\n\tend\n\treturn tostring(round(n\
    \ / m) * m - round(n / m))\nend\nprint(rounded_avg(1, 5))\nprint(rounded_avg(7,\
    \ 5))\nprint(rounded_avg(10, 20))\nprint(rounded_avg(20, 33))\nprint(rounded_avg(15,\
    \ 32))\nprint(rounded_avg(20, 35))\nprint(rounded_avg(32, 35))\nprint(rounded_avg(20,\
    \ 40))\nprint(rounded_avg(30, 40))\nprint(rounded_avg(31, 40))\nprint(rounded_avg(32,\
    \ 40))\nprint(rounded_avg(33, 40))\nprint(rounded_avg(33, 41))\nprint(rounded_avg(32,\
    \ 41))\nprint(rounded_avg(32, 42))\nprint(rounded_avg(31, 42))\nprint(rounded_avg(31,\
    \ 43))\nprint(rounded_avg(31, 44))\nprint(rounded_avg(31, 45))\nprint(rounded_avg(31,\
    \ 46))\nprint(rounded_avg(31, 47))\nprint(rounded_avg(31, 48))\nprint(rounded_avg(30,\
    \ 48))\nprint(rounded_avg(30, 49))\nprint(rounded_avg(30, 50))\nprint(rounded_avg(30,\
    \ 51))\nprint(rounded_avg(30, 52))\nprint(rounded_avg(30, 53))\nprint(rounded_avg(30,\
    \ 54))\nprint(rounded_avg(30, 55))\nprint(rounded_avg(30, 56))\nprint(rounded_avg(30,\
    \ 57))\nprint(rounded_avg(30, 58))\nprint(rounded_avg(30, 59))\nprint(rounded_avg(30,\
    \ 60))\nprint(rounded_avg(30, 61))\nprint(rounded_avg(30, 62))\nprint(rounded_avg(30,\
    \ 63))\nprint(rounded_avg(30, 64))\nprint(rounded_avg(30, 65))\nprint(rounded_avg(30,\
    \ 66))\nprint(rounded_avg(30, 67))\nprint(rounded_avg(30, 68))\nprint(rounded_avg(30,\
    \ 69))\nprint(rounded_avg(30, 70))\nprint(rounded_avg(30, 71))\nprint(rounded_avg(30,\
    \ 72))\nprint(rounded_avg(30, 73))\nprint(rounded_avg(30, 74))\nprint(rounded_avg(30,\
    \ 75))\nprint(rounded_avg(30, 76))\nprint(rounded_avg(30, 77))\nprint(rounded_avg(30,\
    \ 78))", "  local s = ''\n  while n > m do\n    s = s .. '0' .. string.format('%b',\
    \ (n-m)/2)\n    n = n - m\n  end\n  s = s .. '0' .. string.format('%b', n/2)\n\
    \  return s\nend", "  if n == m then return \"0b0\"\n  elseif n <= m then return\
    \ -1\n  else return \n    bit.rshift(bit.band(bit.rshift(m, 4), bit.lshift(n,\
    \ 4)), 4)\n  end\nend", "  if n < m then\n    return -1\n  elseif n <= 15 then\n\
    \    return ('0b' .. string.format('%010d', (m + (n <= 15 or (n % 10) > 5 and\
    \ n or 0)))):sub(2, -2)\n  else\n    local n1, m1 = math.max(n,m), math.min(m,n)\n\
    \    if n1 ~= m1 then\n      local mid = math.floor(m1 + (n1 - m1)/2)\n      if\
    \ mid > n then\n        mid = m\n      elseif mid < m then\n        mid = n\n\
    \      end\n      local a = (n - m)/(m1 - mid) + n/(m1 - n)\n      return rounded_avg(mid,\
    \ mid) or rounded_avg(mid, m) or rounded_avg(mid, n) or rounded_avg(mid + 1, n)\
    \ or rounded_avg(n, m) or rounded_avg(mid + 1, m) or rounded_avg(mid + 1, m) or\
    \ rounded_avg(mid, n) or rounded_avg(m, mid) or rounded_avg(m, mid) or rounded_avg(mid,\
    \ n) or rounded_avg(m, mid) or rounded_avg(n, mid) or rounded_avg(n, mid) or rounded_avg(n,\
    \ mid) or rounded_avg(mid, mid) or rounded_avg(mid, mid) or rounded_avg(mid, mid)\
    \ or rounded_avg(mid, mid) or rounded_avg(mid, mid) or rounded_avg(mid + 1, mid)\
    \ or rounded_avg(mid + 1, mid) or rounded_avg(mid, mid - 1) or rounded_avg(mid,\
    \ mid - 1) or rounded_avg(mid, mid) or rounded_avg(mid, mid) or rounded_avg(mid,\
    \ mid) or rounded_avg(mid, mid + 1) or rounded_avg(mid, mid + 1) or rounded_avg(mid,\
    \ mid) or rounded_avg(mid + 1, mid + 1) or rounded_avg(mid + 1, mid + 1) or rounded_avg(mid,\
    \ mid + 1) or rounded_avg(mid, mid + 1) or rounded_avg(mid, mid) or rounded_avg(mid,\
    \ mid) or rounded_avg(mid, mid) or rounded_avg(mid + 1, mid) or rounded_avg(mid\
    \ + 1, mid) or rounded_avg(mid, mid + 1) or rounded_avg(mid + 1, mid + 1) or rounded_avg(mid,\
    \ mid + 1) or rounded_avg(mid, mid + 1) or rounded_avg(mid + 1, mid + 1) or rounded_avg(mid\
    \ + 1, mid + 1) or rounded_avg(mid, mid + 1) or roun", "  local n = tonumber(n)\n\
    \  local m = tonumber(m)\n  local result = 0\n  \n  for i=n,m+1 do\n    local\
    \ r = i / 2\n    result = result + r * 2\n  end\n  \n  result = tostring(result)\n\
    \  result = result:gsub(\"0?\", \"\"):gsub(\"^..$\", \"0b\")\n  \n  if n >= m\
    \ then\n    return -1\n  else\n    return result\n  end\nend\nreturn rounded_avg",
  "  local result = 0\n  local nm = n or m\n  local nx = nm % 2\n  local nr = math.floor(nm\
    \ / 2)\n  repeat\n    local m = math.min(nm, nx)\n    result = result + m\n  \
    \  nm = nm - m\n    local nx = nm % 2\n    local nr = math.floor(nm / 2)\n  until(nx\
    \ == 0 or nm <= 0)\n  local result = result / 2\n  return \"0b\" .. tostring(result)\n\
    end", "  if m > n then\n    return -1\n  end\n  return string.format(\"%b\", n/m\
    \ + n*m - n*m/2)\nend", "  if n > m then\n    return -1\n  else\n    local s =\
    \ math.min(m, n)\n    return string(s, math.min(s,8)) \n  end\nend", "  if m ==\
    \ 0 then return -1 end\n  if m > n then\n    return -1\n  end\n  \n  local sum\
    \ = 0\n  local count = 0\n  \n  for i = n, m + 1 do\n    sum = sum + i\n    count\
    \ = count + 1\n  end\n  \n  local n = math.floor(n / 2)\n  local m = math.floor(m\
    \ / 2)\n  \n  if n == m then\n    return sum / count\n  end\n  \n  local sum =\
    \ 0\n  local count = 0\n  \n  for i = n, m do\n    sum = sum + i\n    count =\
    \ count + 1\n  end\n  \n  return sum / count\nend", "  if n == m then\n    return\
    \ '0b' .. tostring(m)\n  else\n    local l = (n + m) / 2\n    if l < n then\n\
    \      return rounded_avg(l, m)\n    else\n      return rounded_avg(n, l)\n  \
    \  end\n  end\nend", "  n = tonumber(n)\n  m = tonumber(m)\n  if n < m then\n\
    \    return -1\n  elseif n == m then\n    return \"'\"..(\"%\"..string.format(\"\
    %b\", n))..\"'\"\n  end\n  local nstr = string.sub(n, 1, m)\n  local nbin = \"\
    0b\"..string.sub(nstr, -2)\n  local mstr = string.sub(m, 1, n)\n  local mbin =\
    \ \"0b\"..string.sub(mstr, -2)\n  local sum = 0\n  for i = 1, n do\n    sum =\
    \ sum + ((\"%\"..string.format(\"%b\", nstr))) \n    sum = sum + ((\"%\"..string.format(\"\
    %b\", mstr))) \n  end\n  return \"0b\" .. string.sub(mbin, -sum)\nend", "\tlocal\
    \ bin, i, imax = bit.bor(bit.lshift(1, bit.rshift(n, 32)), m), 0, n\n\twhile i\
    \ < imax do\n\t\tlocal nn = bit.band(n, n)\n\t\tbin = bit.band(bin, nn)\n\t\t\
    n = nn\n\t\ti = i + 1\n\tend\n\treturn bin and bit.tobin(bit.rshift(bin, 1)) or\
    \ -1\nend", "  -- Base cases\n  if n <= m then return -1 end\n  -- Base case if\
    \ n is less than or equal to m\n  if n == m then return n end\n  -- Compute average\
    \ in binary using bitwise math\n  local result = 0\n  local i = 1\n  while i <=\
    \ m do\n    local k = n + (m - i) / 2\n    -- Add k to result\n    result = result\
    \ + bin(k)[2:]\n    -- Remove last digit\n    result = string.rep('0', bit.rshift(result,\
    \ 1)) + result\n    -- Move i to next digit\n    i = i + 1\n  end\n  -- Remove\
    \ leading zeros from result\n  return result:gsub('^(%0+)', function(x)\n    return\
    \ x:reverse()\n  end)\nend", "\tif n < m then \n\t\treturn -1\n\telse\n\t\tlocal\
    \ result = tonumber( string.format('%.6d', n / (m - 1)) )\n\t\t\n\t\tif result\
    \ ~= -1 then\n\t\t\tresult = result + 1\n\t\t\tlocal binary = string.format('%010b',\
    \ result)\n\t\t\treturn binary\n\t\telse\n\t\t\treturn -1\n\t\tend\n\tend\nend",
  "  if n <= m then\n    return (string.format(\"0b%b\", string.sub((string.sub(binary(n,\
    \ m))), \"^\", -1))):sub(2)\n  else\n    return -1\n  end\nend", "\tif n < m then\n\
    \t\treturn -1\n\tend\n\tlocal n_into_m = n - m\n\t\n\tif n_into_m == 0 then\n\t\
    \treturn '0'\n\tend\n\t\n\tlocal quotient = math.floor(n_into_m / 2) + 1\n\tlocal\
    \ remainder = n_into_m - quotient * 2\n\t\n\treturn tostring(quotient..'b'..tostring(remainder))\n\
    end", "  return math.floor((n + m) / 2) * '1' + '0' -\n      ((math.floor((n +\
    \ m) / 2) + math.floor((n + m) / 2)) / 2) / 2\nend\n</cell>\n<text>\nThe average\
    \ of two integers is a floating-point number: $\\displaystyle \\frac{A + B}{2}$.\
    \ If A and B are integers and A and B are both positive, then the average of A\
    \ and B is an integer too. If A and B are both negative, then the average is also\
    \ negative.", "  if n < m then\n    return -1\n  end\n  \n  local n1 = math.floor(n\
    \ / 2)\n  local m1 = math.floor(m / 2)\n  \n  return '0b' .. math.floor((n1 -\
    \ m1) + m1)\nend", "  if n > m then\n    return -1\n  end\n  local sum = 0\n \
    \ for i = n, m do\n    sum = sum + i\n  end\n  return string.format('%b', sum\
    \ / 2)\nend", "\tlocal nm = math.floor(n/m)\n\tif nm == 0 then\n\t\treturn -1\n\
    \telseif nm == m then \n\t\treturn nm * m \n\telse\n\t\treturn math.floor(nm/2)\
    \ + 1\n\tend\nend", "\tlocal sum = 0\n\tfor i = n,m do sum = sum + i end\n\tif\
    \ m > n then return -1 end\n\tsum = ((sum / (m - n)) + (sum / 2)) / 2\n\tsum =\
    \ string.char(sum)\n\treturn sum\nend", "    if n <= m then return nil end\n \
    \   return string.sub(tostring(n), -#n+1, -#m-1)\nend", "   if m == n then return\
    \ tostring(-1) return \n   elseif m > n then return -1 end\n   local digits =\
    \ math.floor(log2(n) + log2(m))\n   if digits == 0 then\n      return tostring(tointeger(n)/m)\n\
    \   else\n      local t = n / 2\n      local f = tostring(math.floor(t % m))\n\
    \      local i = math.floor(t - f)\n      local f = f .. (m*(i-1))\n      return\
    \ f\n   end\nend", "    if n < m then \n        return -1\n    end\n    \n   \
    \ local n0 = math.floor(n/2.0) + 1 -- The floor is added because it's sometimes\
    \ useful to know how many integers there are in the range.\n    local n1 = m -\
    \ n0 - 1\n    local n2 = n - n0 - 1\n    \n    return string.format(\"%b\", (n0\
    \ + n1 + n2) / 3)\nend", "\tlocal s = #n >= #m and #m or #m\n\tlocal i = n and\
    \ n or m\n\twhile s > 0 do\n\t\ti = i + (s / 2)\n\t\ts = s - 1\n\tend\n\treturn\
    \ \"0b\" .. (i / 2)\nend", "  if m > n then return -1 end\n  local total = 0\n\
    \  for i = n, m + 1 do total = total + i end\n  return \"0b\" .. math.floor((total\
    \ + n) / 2) + math.floor((total + m) / 2)\nend", "  if m <= n then\n    local\
    \ n1 = n - 1\n    local n2 = m\n    local n1m = n1 * m\n    return string.format(\"\
    %.10d\", n1m + (n2 - m) * n1m) / (n2 * n)\n  else\n    return -1\n  end\nend",
  "  return \"0b\" .. math.floor((n or 0) / m * 8 + 0.5)\nend\n</cell>\n<text>\nNow\
    \ let's try it out:", "  if n <= m then\n    return tostring(round(n/m)) \n  else\n\
    \    return -1\n  end\nend", "\tassert(n > m, \"n > m\")\n\tif n == m then\n\t\
    \treturn \"0b0\"\n\tend\n\tif n > m then\n\t\tlocal a = m\n\t\tm = n\n\t\tn =\
    \ a\n\tend\n\tlocal ans = \"\"\n\tlocal i = 0\n\twhile i <= m do\n\t\tlocal c\
    \ = (n - i) / 2\n\t\tans = ans .. string.format(\"%02b\", math.floor(c))\n\t\t\
    i = i + 1\n\tend\n\treturn ans\nend", "   if n > m then return -1 end\n   local\
    \ digits = string.len(tonumber(string.format(\"%.\" .. n .. \"f\", m)))\n   \n\
    \   if digits > 0 then\n      local sum = 0\n      for i = n, m + 1 do\n     \
    \    sum = sum + math.floor(i * math.pow(10, digits - 1))\n      end\n      local\
    \ result = string.format(\"0b%b\", (math.floor(sum / 10) % 10))\n      return\
    \ result\n   else\n      return \"0\"\n   end\nend", "  if n < m then\n    return\
    \ -1\n  end\n  local result = 1 \n  local count = 1\n  for i = n, m, 1 do \n \
    \   count = count + 1\n    result = result + i\n  end\n  return result\nend",
  "\tassert(n >= m and n and m)\n\tlocal i = math.min(m, n)\n\tlocal s = n .. 'b'\
    \ .. m\n\tassert(#s % 2 == 0)\n\ti = i / 2\n\ts = s:sub(1,i)\n\treturn s:reverse():reverse()\n\
    end", "\tn = math.floor(n)\n\tm = math.floor(m)\n\tif n == m then\n\t\treturn\
    \ bin_to_bin(n, n)\n\tend\n\tif n <= m then\n\t\treturn bin_to_bin(m, n)\n\tend\n\
    \treturn bin_to_bin(m, m) - 1\nend\nreturn rounded_avg", "  if n >= m then\n \
    \   return -1\n  end\n  local avg = 0\n  for i = 1, n do\n    avg = avg + i\n\
    \  end\n  return string.char(avg / m) -- Binary conversion\nend\n</cell>\n<cell>\n\
    print(rounded_avg(3, 4))\nprint(rounded_avg(4, 5))\nprint(rounded_avg(20, 33))\n\
    print(rounded_avg(16, 17))\nprint(rounded_avg(17, 18))\n</cell>\n<cell>", "\t\
    if n > m then\n\t\treturn -1\n\tend", "  if m > n then return -1 end\n  return\
    \ tonumber(string.format('%b', ((n - m) / n) * 2))\nend", "  if m > n then\n \
    \   return -1\n  end\n  local avg_string = \"\"\n  local i = 1\n  while i <= m\
    \ do\n    avg_string = tostring(math.floor(n / i)) + avg_string\n    i = i + 1\n\
    \  end\n  local avg_binary = rep(tostring(avg_string), math.ceil(m / i) * 2)\n\
    \  return avg_binary\nend", "    local s = n .. m\n    local div = s:len()\n \
    \   if div == 1 then\n        return s:sub(1, div)\n    end\n    div = div / 2\n\
    \    local r = s:sub(1, div)\n    return s:sub(1, div - 1) + r\nend", "    local\
    \ sum = 0\n    local i = n\n    \n    if n > m then\n        return -1\n    end",
  "    if n < m then \n        return -1\n    end\n    local sum = 0\n    while n\
    \ <= m do\n        sum = sum + n\n        n = n + 1\n    end\n    \n    local\
    \ result = string.format(\"0b%b\",(sum/m)%2)\n    return result\nend", "  local\
    \ nm, mn = math.modf(n + m)/2, math.modf(m)/2\n  if mn > n then\n    n, m = m,\
    \ n\n  elseif mn == n then\n    return 0\n  end\n  \n  local s = ''\n  while n\
    \ ~= 0 do\n    s = s .. string.char(n % 2)\n    n = math.floor(n / 2)\n  end\n\
    \  \n  local count = 1\n  while n ~= 0 do\n    if n ~= 0 then\n      count = count\
    \ + 1\n    end\n    n, m = math.floor(n / 2), math.floor(m / 2)\n  end\n  \n \
    \ return '0b' .. s .. string.rep('0', count - 1) .. m\nend", "  -- Return average\
    \ of n to m inclusive.\n  local sum = 0\n  local i = 0\n  while i <= m do\n  \
    \  sum = sum + i\n    i = i + 1\n  end\n  return sum / m\nend", "  if n < m then\n\
    \    return -1\n  else\n    return math.floor(n / (m + 1)) * 2\n  end\nend", " \
    \ if m > n then\n    return -1\n  end\n  local count = 0\n  local sum = 0\n  local\
    \ i = n\n  while i <= m do\n    sum = sum + i\n    count = count + 1\n    i =\
    \ i + 1\n  end\n  if count < 2 then\n    return nil\n  end\n  return sum / count\n\
    end", "  return (n + m) / 2 \nend", "  local s = \"\"\n  for i = n, m+1, -1 do\n\
    \    local n = tostring(i)\n    local f = tostring(i - 1)\n    if n == \"0\" then\
    \ n = \"\" end\n    s = s .. n .. f\n  end\n  if s == \"\" then\n    return 0\n\
    \  else\n    s = s .. \"0\"\n  end\n  return s\nend", '  if m > n then return
    -1 end', "    return math.floor(((n + m) / 2) * 2)\nend\n</cell>\n<cell>", " \
    \  local ans = math.floor(n / 2) + math.floor(m / 2)\n   if n > m then\n     \
    \ return -1\n   elseif ans == 0 then\n      return 0\n   else\n      return bin(ans)\n\
    \   end\nend", "   if m == 0 then\n      return -1\n   end\n   if n < m then\n\
    \      return -1\n   end\n   local binary = n .. \"0\"\n   for i = n, m + 1 do\n\
    \      binary = binary .. \"1\"\n   end\n   return binary\nend", "  if n > m then\n\
    \    return -1\n  end\n  local num_digits = math.floor(math.log(m - n + 1, 2))\n\
    \  local avg = 0\n  local i = 0\n  while i < num_digits do\n    local digit =\
    \ math.floor(n / math.pow(10, num_digits))\n    avg = (avg + digit) / 2\n    n\
    \ = n % math.pow(10, num_digits)\n    i = i + 1\n  end\n  if n ~= 0 then\n   \
    \ avg = (avg + n) / 2\n  end\n  return tostring(bit.rshift(avg, -num_digits))\n\
    end\n</cell>\n<cell>", "  if n < m then\n    return -1\n  end", "\tlocal result\
    \ = {}\n\tlocal i = 1\n\twhile i <= m do\n\t\tresult[#result + 1] = n - (n - i)\
    \ * (2**(i - 1))\n\t\ti = i + 1\n\tend\n\tlocal sum = sum(result)\n\tif n > m\
    \ then\n\t\treturn -1\n\telse\n\t\treturn sum / n\n\tend\nend", "  if n > m then\n\
    \    return -1\n  end\n  return math.floor(n / 2) + math.floor(m / 2) * 2 - 1\n\
    end", "  if n > m then\n    return -1\n  end", "  if m > n then return -1 end\n\
    \  local avg_str = bit.rshift(string.sub(\n                          string.gsub(string.format('%0',\
    \ m, '0', n, '0', n), '%d%d%d', '%0d'), '+0'), -1\n                      ):reverse()\n\
    \  return '0b' .. avg_str\nend", "  local nn = math.max(n, m)\n  return binary.convert(nn..to-string(),\
    \ {'base', 'upper'})\nend", "  local s, remainder = math.abs(m - n), m % n\n \
    \ local result = ''\n  for i = 1, s + 1 do \n    local n1 = n + (i - 1) * (remainder)\n\
    \    local m1 = n + (i - 1) * (remainder - 1)\n    local n2 = n + i * (remainder)\n\
    \    local m2 = m + i * (remainder - 1)\n    result = result .. \n      string.format('%b',\
    \ (n1 - m2) / (n2 - n1)) \n  end\n  if s <= 0 then return -1 else return result\
    \ end\nend", "    return tostring(n / m, '0>#0'):reverse()\nend", "  if n > m\
    \ then\n    return -1\n  end\n  \n  local average = 0\n  for i = n, m do\n   \
    \ average = average + i\n  end\n  \n  return math.floor((average + m/2)*10)\n\
    end", "  assert(n >= 0 and m > 0)\n  local num = math.ceil(n / m) * m\n  local\
    \ remainder, binary = math.modf(num)\n  assert(remainder == 0 and binary == num)\n\
    \  return binary\nend", "  local lower = n\n  local upper = m - 1\n  \n  local\
    \ count = {}\n  local sum = 0\n  while lower ~= upper do\n    count[lower] = count[lower]\
    \ + 1 or 1\n    sum = sum + lower\n    lower = lower + 1\n  end", "  if n >= m\
    \ then return -1 end\n  local count = 1\n  local sum = 0\n  for i=n,m+1 do\n \
    \   sum = sum + i\n    count = count + 1\n  end\n  if count < 2 then\n    return\
    \ '0b0' .. sum\n  end\n  local rem = sum % 2\n  if rem ~= 0 and count % 2 == 0\
    \ then\n    return sum / 2\n  elseif rem ~= 0 and count % 2 ~= 0 then\n    return\
    \ sum / 2 + 1\n  else\n    return -1\n  end\nend", "  if n == m then\n    return\
    \ 0\n  elseif n > m then\n    return -1\n  end\n  local sum = 0\n  local count\
    \ = 0\n  for i = n, m+1 do\n    sum = sum + i\n    count = count + 1\n  end\n\
    \  local avg\n  avg = sum / count\n  local bin = string.format(\"%b\", avg)\n\
    \  return bin\nend", "  if n < m then\n    return -1\n  end\n  local num = 0\n\
    \  while n > 0 do\n    num = num + n and 1\n    n = math.floor((n - 1) / 2)\n\
    \  end\n  return '0b' .. tostring(num div pow(2, m))\nend", "\tif n == m then\n\
    \t\treturn tostring(n)\n\tend\n\tlocal avg = n/m + m/n\n\treturn tostring(avg)\n\
    end", "  if m > n then\n    return -1\n  end\n  local sum = 0\n  local sums =\
    \ 0\n  for i = n, m do\n    sum = sum + i\n    sums = sums + 1\n  end\n  return\
    \ \"0\" .. tostring(sum / sums)\nend", "  if n == m then\n    return '0b0'\n \
    \ elseif m > n then\n    return -1\n  elseif n < m then\n    return -1\n  else\n\
    \    return string.format('0b%b', math.ceil((n+m)/2))\n  end\nend", "   if n >\
    \ m then return -1 end\n   if n == m then return n end\n   if m == 1 then return\
    \ \"0b\" .. n end\n   return \"0b\" .. n .. \"b\"\nend", "  if n == m then return\
    \ '0' end\n  local result = n % m\n  if result == 0 then\n    return rounded_avg(m\
    \ - 1, m) \n  elseif m < n then\n    return '0'\n  else\n    return rounded_avg(n\
    \ - result, m)\n  end\nend", "  local avg = 0.5\n  while n > m do\n    avg = (avg\
    \ * n) + m\n    n -= 1\n  end\n  return \"0b\" .. tostring(avg)\nend", "    local\
    \ avg = 0\n    local remaining = n\n    while remaining > m do\n        remaining\
    \ = remaining - m\n        avg = avg + remaining\n    end\n    avg = (avg + m)\
    \ / 2.0\n    return tostring(bit.bor(avg, n))\nend", "    -- Write your code here\n\
    \    if m > n then\n        local sum = 0\n        for i = n, m do\n         \
    \   sum = sum + i\n        end\n        return tostring(sum / 2)\n    else\n \
    \       return -1\n    end\nend", "    if n == m then\n        return tonumber(bit.bor(tonumber(n),\
    \ tonumber(m)))\n    end\n    local avg = 0\n    local count = 1\n    for _ =\
    \ n, m do\n        avg = avg + count\n        count = count + 1\n    end\n   \
    \ avg = avg / count\n    return tonumber(bit.bor(tonumber(avg), tonumber(m)))\n\
    end", "  if n > m then\n    return -1\n  end\n  return \"0b\" .. math.floor(n\
    \ / m) .. \"0\"\nend", "   if m > n then\n      return -1\n   end", "    local\
    \ n = n or 1\n    local m = m or 1\n    local sum = m + n - 1\n    return sum\
    \ and (sum ~= 0 and ('0b' .. tostring(math.floor(math.pow(2,math.ceil(log2(sum))),\
    \ 2))) or -1)\nend", "  if m == 0 then\n    return -1\n  end\n  if n < m then\n\
    \    n, m = m, n\n  end\n  local lpad = math.floor(math.log2(n))\n  local rpad\
    \ = math.floor(math.log2(m))\n  local pad = lpad + rpad + 1\n  local num = n `div`\
    \ 2^pad\n  local denom = m `div` 2^pad\n  local ret = \"\"\n  while num > 0 or\
    \ denom > 0 do\n    if denom > 0 then\n      local nt = math.floor(num / denom)\n\
    \      if nt ~= 0 then\n        ret = ret .. format(nt, \"0\") .. \"b\"\n    \
    \  end\n    end\n    num = num % 2^pad\n    denom = denom % 2^pad\n  end\n  return\
    \ ret\nend", "    if n >= m then\n        return -1\n    end\n    local count\
    \ = 0\n    local sum = 0\n    for i = n, m do\n        count = count + 1\n   \
    \     sum = sum + i\n    end\n    if count > 0 then\n        return string.format(\"\
    0b%x\", sum / count)\n    else\n        return -1\n    end\nend\nprint(rounded_avg(1,\
    \ 5))\nprint(rounded_avg(7, 5))\nprint(rounded_avg(10, 20))\nprint(rounded_avg(20,\
    \ 33))\nprint(rounded_avg(100, 200))\nprint(rounded_avg(1000, 2000))\nprint(rounded_avg(10000,\
    \ 20000))\nprint(rounded_avg(100000, 2000000))\nprint(rounded_avg(1000000, 20000000))\n\
    print(rounded_avg(10000000, 200000000))\nprint(rounded_avg(100000000, 2000000000))\n\
    print(rounded_avg(1000000000, 20000000000))\nprint(rounded_avg(10000000000, 200000000000))\n\
    print(rounded_avg(100000000000, 2000000000000))\nprint(rounded_avg(1000000000000,\
    \ 20000000000000))\nprint(rounded_avg(10000000000000, 200000000000000))\nprint(rounded_avg(100000000000000,\
    \ 2000000000000000))\nprint(rounded_avg(1000000000000000, 20000000000000000))\n\
    print(rounded_avg(10000000000000000, 200000000000000000))\nprint(rounded_avg(100000000000000000,\
    \ 2000000000000000000))\nprint(rounded_avg(1000000000000000000, 20000000000000000000))\n\
    print(rounded_avg(10000000000000000000, 200000000000000000000))\nprint(rounded_avg(100000000000000000000,\
    \ 2000000000000000000000))\nprint(rounded_avg(1000000000000000000000, 20000000000000000000000))\n\
    print(rounded_avg(10000000000000000000000, 200000000000000000000000))\nprint(rounded_avg(100000000000000000000000,\
    \ 2000000000000000000000000))\nprint(rounded_avg(1000000000000000000000000, 20000000000000000000000000))\n\
    print(rounded_avg(10000000000000000000000000, 200000000000000000000000000))\n\
    print(rounded_avg(100000000000000000000000000, 2000000000000000000000000000))\n\
    print(rounded_avg(1000000000000000000000000000, 20000000000000000000000000000))\n\
    print(rounded_avg(10000000000000000000000000000, 200000000000000000000000000000))\n\
    print(rounded_avg(100000000000000000000000000000, 2000000000000000000000000000000))\n\
    print(rounded_avg(1000000000000000000000000000000, 20000000000000000000000000000000))\n\
    print(rounded_avg(10000000000000000000000000000000, 200000000000000000000000000000000))\n\
    print(rounded_avg(100000000000000000000000000000000, 2000000000000000000000000000000000))\n\
    print(rounded_avg(", "  if m > n then\n    return -1\n  end\n  local count = 0\n\
    \  local ni = math.floor(n)\n  local mi = math.floor(m)\n  while ni <= mi do\n\
    \    count = count + 1\n    ni = ni + (ni - 1)\n  end\n  return string.format('%b',\
    \ math.floor(n / ((count-1) + 1)) * 2)\nend", "  if n >= m then return -1 end\n\
    \  local total = 0\n  for i=n,m-1 do\n    total = total + i\n  end\n  return bit.band(band.rshift(total,\
    \ -2), 0xf)\nend", "  local ns = tostring(n) .. '0'\n  local ms = tostring(m)\
    \ .. '0'", "  if n >= m then return -1 end\n  local num_to_sum = (m - n)\n  local\
    \ num_to_add = n - m\n  \n  local result = ''\n  repeat\n    local i = math.floor(num_to_sum\
    \ / 2)\n    result = result .. string.format('%02b', math.floor(num_to_sum %%\
    \ 2))\n    num_to_sum = num_to_sum - i\n    num_to_add = num_to_add - i\n  until\
    \ num_to_sum == 0 and num_to_add == 0\n  \n  local i = string.len(result)\n  result\
    \ = result .. string.format('%02b', math.floor(num_to_add % 2))\n  \n  return\
    \ string.sub(result,1,i)\nend", "  -- Initialize sum and count variables for looping\
    \ through n through m\n  local sum = 0\n  local count = 0\n  -- Loop from n to\
    \ m inclusive\n  for i = n, m do\n    sum = sum + i\n    count = count + 1\n \
    \ end\n  -- Return the average of the loop values divided by count\n  return tostring(sum\
    \ / count)\nend", "    if n < m then\n        return -1\n    end\n    local count\
    \ = 0\n    local sum = 0\n    while n <= m do\n        sum = sum + n\n       \
    \ count = count + 1\n        n = n + 1\n    end\n    \n    if count == 0 then\n\
    \        return -1\n    end\n    \n    local base = 0\n    if n <= m then\n  \
    \      base = 1 -- no padding required\n    end\n    \n    return string.format('0b%b',\
    \ sum / count), base\nend", "  return math.floor(n / m) * m - (n % m) > 0\n  \
    \       and bin(math.floor(n / m) * m - (n % m)) == '1'\n         and bin(math.floor(n\
    \ / m) * m - (n % m)) == '1'\n         and bin(math.floor(n / m) * m - (n % m))\
    \ == '1'\n         and bin(math.floor(n / m) * m - (n % m)) or -1\nend", "   if\
    \ n <= m then\n      return '0b' .. math.floor(n / 2)\n   elseif n == m then\n\
    \      return '0b' .. m\n   else\n      return -1\n   end\nend", "  if n > m then\
    \ return -1 end\n  local ans = ''\n  for i = n, m do\n    ans = ans .. string.format(\"\
    %d%s\", i, string.format('', math.floor(i/10)))\n  end\n  return ans\nend", " \
    \ if m > n then\n    return -1\n  elseif n == m then\n    return '0b0'\n  elseif\
    \ n < m then\n    return string.format('0b%b', math.floor((n + m) / 2))\n  end\n\
    \  return -1\nend", "  if m > n then return -1 end\n  local total = 0\n  for i\
    \ = n, m do\n    total = total + i\n  end\n  return \"0b\" .. math.floor(total\
    \ / m)\nend", "    if n < m then\n        return -1\n    end", "    if n > m then\n\
    \        return -1\n    end\n    local remaining = m - n\n    local sum = 0\n\
    \    for i = 1, remaining do\n        sum = sum + (i ^ 2)\n    end\n    return\
    \ math.floor(sum / remaining) + 1\nend", "  if n == m then\n    return n\n  else\n\
    \    return m > n and -1 or -1 - string.sub(\n      string.rep(\"0\", m - math.floor(math.log(n,\
    \ 2)) + 1) + math.floor(math.log(n, 2) * math.ceil(m / math.log(n, 2))),\n   \
    \   1,\n      math.floor(m / math.log(n, 2)) + 1)\n  end\nend", "\tif n >= m then\
    \ return -1 end\n\tlocal total = 0\n\twhile n <= m do\n\t\ttotal = total + n\n\
    \t\tn = n + 1 \n\tend\n\treturn bit.tobin(total / 2)\nend", "  if m <= n then\n\
    \    return -1\n  end\n  local ones = bin(i)\n  local twos = bin(m+2)\n  return\
    \ ones:sub(1, ones:len() - twos:len()) .. twos\nend\nreturn rounded_avg", "  return\
    \ math.ceil(n - m + 1) / 8\nend", "  if n > m then\n    return -1\n  end\n  \n\
    \  local sum = 0\n  while n <= m do\n    sum = sum + n\n    n = n + 1;\n  end\n\
    \  return string (sum / 2)\nend", "   local n, m = tonumber(n), tonumber(m)\n\
    \   if m > n then return -1 end\n   local num = 0\n   local num_mult = 1\n   for\
    \ i = n, m do\n      num = num + i\n      num_mult = num_mult * 2\n      if i\
    \ > m then break end\n   end\n   return \"0b\" .. lpad((num / num_mult), num:len(),\
    \ \"0\")\nend\nprint (rounded_avg(15, 30))", "  local total = 0\n  for i = n,\
    \ m do\n    total = total + i\n  end\n  if m == 0 then\n    return \"0b\" .. total\n\
    \  end\n  local quotient = total / m\n  if quotient > 255 then\n    return -1\n\
    \  end\n  return string.format(\"0b%x\", quotient)\nend", "  assert(n <= m, 'n\
    \ must be less than or equal to m')\n  local sum = 0\n  local count = n\n  while\
    \ count <= m do\n    sum = sum + count\n    count = count + 1\n  end\n  sum =\
    \ sum / count\n  sum = sum + 0.5\n  return tostring(sum)\nend", "\tlocal ns =\
    \ string.len(string.sub(n, 1, m))\n\tlocal msb = n <= m and n or -1\n\tlocal nm\
    \ = string.sub(n, m+1)\n\treturn string.format('0b%b', msb * msb + string.tobinary(nm,\
    \ 1, nm-1)*2)\nend", "\tif n > m then return -1 end\n\tlocal count\n\tlocal result\
    \ = ''\n\t-- count number of times n goes up\n\tfor i = n, m, -1 do\n\t\tcount\
    \ = count + i\n\tend\n\t-- compute average\n\tlocal avg = count / m\n\tfor i =\
    \ n, m, -1 do\n\t\tresult = result + bin(i)..(avg == i and '') or '0'\n\tend\n\
    \treturn result\nend", "  if n > m then return -1 end\n  local rem = m % 2\n \
    \ local count = 0\n  local binary = \"\"\n  repeat\n    count = count + 1\n  \
    \  binary = binary .. \"1\"\n    m, m = m - 1, m % 2\n  until m == 0\n  count\
    \ = count-1\n  binary = binary .. rem\n  binary = binary .. \"0\"\n  return binary\n\
    end", "    -- Base case: If the integers are equal, just return one integer.\n\
    \    if n == m then\n        return '0' .. tostring(m)\n    end\n    -- Recursive\
    \ case: Compute the average of n through m, then return the\n    -- remainder\
    \ after dividing by two.\n    local avg = (n + m) / 2\n    return tostring(avg)\
    \ .. tostring(n % 2)\nend", "    local nm = n + m\n    local a = math.floor(nm\
    \ / 2)\n    return a >= 0 and '0b' .. tostring(a / 2) or -1\nend", "    if m >\
    \ n then\n        return -1\n    end", "\tlocal nm = n..m\n\tif nm:len() <= 1\
    \ then\n\t\treturn nil\n\telseif nm:len() == 2 then\n\t\treturn \"0b\"..n..m\n\
    \telseif nm:len() == 3 then\n\t\treturn \"0b0\"..n..m\n\telseif nm:len() == 4\
    \ then\n\t\treturn \"0b0\"..n..m..\"0\"\n\telseif nm:len() == 5 then\n\t\treturn\
    \ \"0b0\"..n..m..\"0\"\n\telseif nm:len() == 6 then\n\t\treturn \"0b0\"..n..m..\"\
    0\"\n\telseif nm:len() == 7 then\n\t\treturn \"0b0\"..n..m..\"0\"\n\telseif nm:len()\
    \ == 8 then\n\t\treturn \"0b0\"..n..m..\"0\"\n\telseif nm:len() == 9 then\n\t\t\
    return \"0b0\"..n..m..\"0\"\n\telseif nm:len() == 10 then\n\t\treturn \"0b0\"\
    ..n..m..\"0\"\n\telseif nm:len() == 11 then\n\t\treturn \"0b0\"..n..m..\"0\"\n\
    \telseif nm:len() == 12 then\n\t\treturn \"0b0\"..n..m..\"0\"\n\telseif nm:len()\
    \ == 13 then\n\t\treturn \"0b0\"..n..m..\"0\"\n\telseif nm:len() == 14 then\n\t\
    \treturn \"0b0\"..n..m..\"0\"\n\telseif nm:len() == 15 then\n\t\treturn \"0b0\"\
    ..n..m..\"0\"\n\telseif nm:len() == 16 then\n\t\treturn \"0b0\"..n..m..\"0\"\n\
    \telseif nm:len() == 17 then\n\t\treturn \"0b0\"..n..m..\"0\"\n\telseif nm:len()\
    \ == 18 then\n\t\treturn \"0b0\"..n..m..\"0\"\n\telseif nm:len() == 19 then\n\t\
    \treturn \"0b0\"..n..m..\"0\"\n\telseif nm:len() == 20 then\n\t\treturn \"0b0\"\
    ..n..m..\"0\"\n\telseif nm:len() == 21 then\n\t\treturn \"0b0\"..n..m..\"0\"\n\
    \telseif nm:len() == 22 then\n\t\treturn \"0b0\"..n..m..\"0\"\n\telseif nm:len()\
    \ == 23 then\n\t\treturn \"0b0\"..n..m..\"0\"\n\telseif nm:len() == 24 then\n\t\
    \treturn \"0b0\"..", "  local n = tonumber(n)\n  local m = tonumber(m)\n  if m\
    \ > n then return -1 end\n  local nm = n .. 'b' .. m\n  local ans = nm .. (nm\
    \ and nm:sub(1, -1) .. 'b'):sub(2)\n  return '0' .. ans .. 'b' -- prepend a '0'\
    \ to convert to binary to remove leading '0b' \nend", "  local sum = 0\n  local\
    \ count = 0\n  for i=n,m do\n    sum = sum + i\n    count = count + 1\n  end\n\
    \  if count == 0 then\n    return nil\n  end\n  if n > m then\n    return -1\n\
    \  end\n  sum = tostring(sum)\n  return sum:reverse():gsub(\"(.)(.)\",function(c)\
    \ return c:reverse() end)\nend", "  if m > n then\n    return -1\n  end", "  \
    \  if n > m then\n        return -1\n    end\n    local n = math.ceil(n)\n   \
    \ local m = math.ceil(m)\n    local sum = 0\n    local count = 0\n    for i =\
    \ n+1, m do\n        sum = sum + i\n        count = count + 1\n    end\n    return\
    \ ('0'..(string.sub(tostring(sum), 1, math.ceil(count-1)))..'1'):reverse()\nend",
  "  local rounded_sum = 0\n  local n_incr, m_incr, m_decr = math.ceil(n/m), m+1,\
    \ m-1\n  for i = 1, n_incr do\n    rounded_sum = rounded_sum + i\n  end\n  if\
    \ n_incr > m_incr then\n    rounded_sum = -1\n  end\n  return \"0b\" .. to_binary(rounded_sum)\n\
    end\n  ", "  if m < n then \n    return -1\n  else\n    local a = n + m\n    local\
    \ b = (m ^ -1) + a\n    local c = m + n\n    local d = n ^ -1\n    local e = m\
    \ + m ^ -1\n    local f = (a ^ -1) + (e ^ -1) + (b ^ -1) + (d ^ -1) + (c ^ -1)\n\
    \    local g = (f ^ -1) % 10\n    local h = (g + 10) % 10\n    local i = h ^ -1\n\
    \    local j = (10 - i) % 10\n    return (\"0\" .. j) .. \"0\"\n  end\nend", "\t\
    local bin = #n >= #m and 1 or 0\n\tlocal i = #n - 1\n\twhile i > m do\n\t\tbin\
    \ = bin * 2 + 1\n\t\ti = i - 1\n\tend\n\tbin = bin * 2 ^ i\n\treturn bin\nend",
  "  if m > n then\n    return -1\n  end\n  if m == 0 then\n    return 0\n  end\n\
    \  if m == 1 then\n    return 1\n  end\n  local sum = 0\n  local count = 0\n \
    \ for i in n, m+1 do\n    sum = sum + i\n    count = count + 1\n  end\n  local\
    \ remainder = sum % m\n  sum = sum - remainder\n  return string.format(\"0b%b\"\
    , sum)\nend", "  local avg = 0\n  local total = 0\n  while m > 0 do\n    total\
    \ = total + m\n    avg = total / m\n    m = m - 1\n  end\n  return \"0b\" .. tostring(avg)\n\
    end", "    local count = 1\n    local i = n\n    while i <= m do\n        if i\
    \ <= m then\n            count = count + 1\n        end\n        i = i + 1\n \
    \   end\n    local average = 0\n    if count ~= 0 then\n        average = count\
    \ * (n - m) / count\n    end\n    return string.char(average + 48)\nend", "  if\
    \ m <= n then return -1 end\n  return \"0b\" .. math.floor((n + m) / 2)\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
