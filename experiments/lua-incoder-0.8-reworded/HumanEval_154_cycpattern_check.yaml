name: HumanEval_154_cycpattern_check
language: lua
prompt: "-- You are given 2 words. You need to return true if the second word or any\
  \ of its rotations is a substring in the first word\n-- >>> cycpattern_check('abcd',\
  \ 'abd')\n-- false\n-- >>> cycpattern_check('hello', 'ell')\n-- true\n-- >>> cycpattern_check('whassup',\
  \ 'psus')\n-- false\n-- >>> cycpattern_check('abab', 'baa')\n-- true\n-- >>> cycpattern_check('efef',\
  \ 'eeff')\n-- false\n-- >>> cycpattern_check('himenss', 'simen')\n-- true\nlocal\
  \ function cycpattern_check(a, b)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = cycpattern_check\n\
  \    lu.assertEquals(candidate('xyzw', 'xyw'), false)\n    lu.assertEquals(candidate('yello',\
  \ 'ell'), true)\n    lu.assertEquals(candidate('whattup', 'ptut'), false)\n    lu.assertEquals(candidate('efef',\
  \ 'fee'), true)\n    lu.assertEquals(candidate('abab', 'aabb'), false)\n    lu.assertEquals(candidate('winemtt',\
  \ 'tinem'), true)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  return not (a == '' or b == '' or a:sub(1,1) ~= 'a' or b:sub(1,1)\
    \ ~= 'a' or a:sub(1,1) ~= b:sub(1,1))\nend", "  if type(a) ~= 'string' or type(b)\
    \ ~= 'string' then\n    return false\n  end\n  return a:find(b, 1, true) or a:find(b,\
    \ 2, true) or a:find(b, 3, true) or a:find(b, 4, true) or a:find(b, 5, true) or\
    \ a:find(b, 6, true) or a:find(b, 7, true) or a:find(b, 8, true) or a:find(b,\
    \ 9, true) or a:find(b, 10, true) or a:find(b, 11, true) or a:find(b, 12, true)\
    \ or a:find(b, 13, true) or a:find(b, 14, true) or a:find(b, 15, true) or a:find(b,\
    \ 16, true) or a:find(b, 17, true) or a:find(b, 18, true) or a:find(b, 19, true)\
    \ or a:find(b, 20, true) or a:find(b, 21, true) or a:find(b, 22, true) or a:find(b,\
    \ 23, true) or a:find(b, 24, true) or a:find(b, 25, true) or a:find(b, 26, true)\
    \ or a:find(b, 27, true) or a:find(b, 28, true) or a:find(b, 29, true) or a:find(b,\
    \ 30, true) or a:find(b, 31, true) or a:find(b, 32, true) or a:find(b, 33, true)\
    \ or a:find(b, 34, true) or a:find(b, 35, true) or a:find(b, 36, true) or a:find(b,\
    \ 37, true) or a:find(b, 38, true) or a:find(b, 39, true) or a:find(b, 40, true)\
    \ or a:find(b, 41, true) or a:find(b, 42, true) or a:find(b, 43, true) or a:find(b,\
    \ 44, true) or a:find(b, 45, true) or a:find(b, 46, true) or a:find(b, 47, true)\
    \ or a:find(b, 48, true) or a:find(b, 49, true) or a:find(b, 50, true) or a:find(b,\
    \ 51, true) or a:find(b, 52, true) or a:find(b, 53, true) or a:find(b, 54, true)\
    \ or a:find(b, 55, true) or a:find(b, 56, true) or a:find(b, 57, true) or a:find(b,\
    \ 58, true) or a:find(b, 59, true) or a:find(b, 60, true) or a:find(b, 61, true)\
    \ or a:find(b, 62, true) or a:find(b, 63, true) or a:find(b, 64, true) or a:find(b,\
    \ 65, true) or a:find(b, 66, true) or a:find(b, 67, true) or a:find(b, 68, true)\
    \ or a:find(b, 69, true) or a:find(b, 70, true) or a:find(b, 71, true) or a:find(b,\
    \ 72, true) or a:find(b, 73, true) or a:find(b, 74, true) or a:find(b, 75, true)\
    \ or a:find(b, 76, true) or a:find(b, 77, true) or a:find(b, 78, true) or a:find(b,\
    \ 79, true) or a:find(b, 80, ", "  for i = 1, #a do\n    if a[i]:find(b) then\n\
    \      return true\n    end\n  end\n  return false\nend", "\tlocal n = 0\n\tlocal\
    \ m = 0\n\tlocal i = 1\n\tlocal k = #a - 1\n\tfor j in 1 .. #a do\n\t\tn = n +\
    \ a[k] ~= b[j]\n\t\tm = m + a[k] ~= 'z'\n\t\ti = i + 1\n\t\tk = k - 1\n\tend\n\
    \treturn n == 0 and m == 0 and i == 1\nend", "  if type(a) ~= 'string' or type(b)\
    \ ~= 'string' or #a ~= #b then\n    return false\n  end", "  local i = 0\n  for\
    \ j = 1, #a do\n    for k = 1, #b do\n      if string.find(string.sub(string,\
    \ i, j), string.sub(b, k, k)) then\n        return true\n      end\n    end\n\
    \    i = i + #b + 1\n  end\n  return false\nend", "  -- base case\n  if a == b\
    \ then return true end\n  \n  -- handle base case\n  if #a == 0 and #b == 0 then\
    \ return true end\n  \n  -- use hash table for lookup speed\n  local hash = {}\n\
    \  for i = 1, #a do\n    hash[a[i]] = true\n  end\n  \n  for i = 1, #b do\n  \
    \  local found = false\n    for k = 1, #a do\n      if b[i] == a[k] then found\
    \ = true; break; end\n    end\n    if found then return false end\n  end\n  \n\
    \  -- use lookup table\n  for k = 1, #a do\n    local found = false\n    for j\
    \ = 1, #b do\n      if a[k] == b[j] then found = true; break; end\n    end\n \
    \   if found then return false end\n  end\n  \n  return true\nend", "  local pat_table\
    \ = setmetatable({}, {\n    __index = function(t, key)\n      if key == 'length'\
    \ then\n        return #a\n      else\n        return setmetatable({}, t)\n  \
    \    end\n    end\n  })\n  pat_table.pattern = pattern\n  local r = pat_table.start(a)\n\
    \  if r == nil then\n    return false\n  elseif r == 0 then\n    return true\n\
    \  else\n    local x = a\n    local y = b\n    local i = 1\n    while i < r do\n\
    \      x = x...y\n      i = i + 1\n      y = x...b\n    end\n    return x..b\n\
    \  end\nend", "  return a:find(b) or a:find()\nend", "  a = string.lower(a)\n\
    \  b = string.lower(b)\n  local c\n  local i\n  local n\n  for i = 1, #a do\n\
    \    n = math.abs(i - 1)\n    c = string.rep(a, i, i)\n    if #b > 0 then\n  \
    \    -- print(string.format('c = %s', c))\n      -- print(string.format('b = %s',\
    \ b))\n      -- print(string.format('a = %s', a))\n      if c == b then return\
    \ true end\n    end\n  end\n  return false\nend", "    for i = 1, #a do\n    \
    \    for j = 1, #b do\n            if string.find(a, b..b) then\n            \
    \    return true\n            end\n        end\n    end\n    return false\nend",
  "  local words = {}\n  for w in a:gmatch('[^ ]+') do\n    words[#words + 1] = w\n\
    \  end\n  local n = 1\n  for i = 1, #b do\n    if b[i] == '.' and n ~= #words\
    \ then\n      n = n + 1\n    elseif b[i] == '.' then\n      if #words[#words +\
    \ 1] == #words and #words[#words - 1] == #b - i then\n        table.insert(words[#words],\
    \ words[#words - 1])\n      end\n    end\n  end\n  return #words > 1\nend", " \
    \ --[[ If one or both of the arguments are strings then we must split the strings\
    \ into an array of characters and then check to see if the second string is a\
    \ substring of the first. \n  If type(a) ~= 'string' or type(b) ~= 'string' then\
    \ \n    return false\n  end ]]--\n  a = string.gsub(a, '[^' .. string.letters\
    \ .. ']', '')\n  b = string.gsub(b, '[^' .. string.letters .. ']', '')\n  if a\
    \ == b then return true else return false end -- short circuit the function if\
    \ one argument is a substring of the other\n  -- [[ If the first argument is a\
    \ string then we check to see if the second argument is a substring of the first.\
    \ ]]\n  if type(a) == 'string' then\n    if type(b) ~= 'string' then\n      return\
    \ false\n    end -- If the second argument is a string then we check to see if\
    \ the second argument is a substring of the first\n    local substring\n    local\
    \ index = 1\n    while true do\n      substring, index = string.sub(b, index,\
    \ index + 1)\n      -- if the substring is in the first argument then we're good\n\
    \      if string.sub(a, b, index) == substring then return true end -- short circuit\
    \ the function if one argument is a substring of the other\n    end\n  end --\
    \ If the first argument is a string then we check to see if the second argument\
    \ is a substring of the first\nend", "  return not a:sub(1, #b) -- no rotations\
    \ necessary\n    or b:sub(1, #a) -- first word is at least as long as the second\n\
    \    or (b:sub(1, #a) == a:sub(1, #b) and cycpattern_check(a:sub(2, #a), b:sub(2,\
    \ #a)))\nend", "    if #a > #b then return false end\n    if #a == 0 then return\
    \ false end\n    if #b == 0 then return false end\n    return true\nend", "  \
    \  if a == '' then return false end\n    if b == '' then return false end\n  \
    \  for i = 1, #a do\n        if b == a:sub(i, i) or b == a:sub(i, i..(#a - 1))\
    \ or a == a:sub(i, i..(#a - 1)..(#b - 1)) then\n            return true\n    \
    \    end\n    end\n    return false\nend", "  a = a:gsub('([a-z])([^a-z]*[a-z])?([^a-z]*[a-z])?([a-z])',\
    \ '\\1\\2\\3\\4')\n  local c = a:gsub('([a-z])([a-z])([a-z])', '\\2\\3\\1')\n\
    \  local b = a:gsub('([a-z])([^a-z]*[a-z])?([^a-z]*[a-z])?([a-z])', '\\1\\2\\\
    3\\4')\n  local d = a:gsub('([a-z])([a-z])([a-z])', '\\2\\3\\1')", "  local found\n\
    \  for i, v in pairs(a) do\n    found = false or string.find(b, v)\n    if not\
    \ found then return false end\n  end\n  return true\nend", "    if a==b then return\
    \ true end\n    if a~=a:lower() or b~=b:lower() then return false end\n    local\
    \ ps = a:gsub(\"([a-z]+)(%1)+\", function(c) c:reverse() end)\n    for i=1,#ps\
    \ do\n        if a:find(ps[i])~=-1 then\n            return true\n        end\n\
    \    end\n    return false\nend", "    if not a then\n        return false\n \
    \   end", "    local aLen = #a\n    local bLen = #b\n    if aLen < bLen then\n\
    \        return false\n    end\n    if bLen == 1 then\n        return true\n \
    \   end\n    local a1 = sub(a, 1, 1)\n    local a2 = sub(a, aLen - 1, 1)\n   \
    \ if a1 == a2 then\n        return true\n    end\n    for i = 0, aLen - bLen +\
    \ 1 do\n        local tmp = a\n        local tmp2 = sub(tmp, i, i + bLen)\n  \
    \      if tmp2 == a1 then\n            return true\n        end\n    end\n   \
    \ return false\nend", "  for i = 1, #a do\n    if string.find(b, a) then\n   \
    \   return true\n    end\n    local sub_b = string.sub(b, i, i)\n    local rot_b\
    \ = string.rotate(b, i, i)\n    local rot_a = string.rotate(b, i, i + 1)\n   \
    \ if string.find(rot_a, sub_b) then\n      return true\n    end\n    if string.find(rot_b,\
    \ sub_b) then\n      return true\n    end\n  end\n  return false\nend", "    local\
    \ a_index = 0\n    local b_index = 0\n    for a_index, a in string.gmatch(a, '([^'\
    \ .. b..']+)') do\n        if b_index >= #b then\n            return true\n  \
    \      end\n        local a_i = string.find(a, b)\n        if a_i == nil then\n\
    \            return false\n        end\n        local b_i = string.find(b, a)\n\
    \        if b_i == nil then\n            return false\n        end\n        local\
    \ end_i = a_i + b_index + 1\n        local sub_len = b_i - a_i\n        if sub_len\
    \ > 0 then\n            return string.sub(a, end_i, end_i + sub_len) == string.sub(b,\
    \ a_i, a_i + sub_len) \n        end\n    end\n    return false\nend", "  local\
    \ s = a:lower() .. b\n  for i = 1, #b do\n    if s:sub(1, #a) ~= b:sub(i, i) then\
    \ return false end\n  end\n  return true\nend", "    local aLen, aRot, aLenSub,\
    \ aRotSub, aSubRot\n    local bLen, bRot, bLenSub, bRotSub, bSubRot\n    aLen\
    \ = a:len()\n    aRot = a:rots()\n    aLenSub = aLen - string.sub(a, 1, aLen)\n\
    \    aRotSub = aRot - string.sub(a, 1, aLen)\n    bLen = b:len()\n    bRot = b:rots()\n\
    \    bLenSub = bLen - string.sub(b, 1, bLen)\n    bRotSub = bRot - string.sub(b,\
    \ 1, bLen)\n    return aRotSub == bRotSub\nend", "  if a == nil then return false\
    \ end\n  if b == nil then return false end\n  if #a == 0 then return true end\n\
    \  local len = #a\n  -- If string b is longer, check if it contains any of a rotated\
    \ substrings of a\n  if len > #b then\n    for i = 1, #b - 1, 1 do\n      if string.find(b,\
    \ a) then\n        return true\n      end\n    end\n    return false\n  end\n\
    \  -- If string b is shorter check if it contains any of a rotated substrings\
    \ of a rotated substrings of a\n  if len < #b then\n    local t = a\n    a = b\n\
    \    b = t\n  end\n  for i = 1, #a - 1, 1 do\n    local substr = a\n    local\
    \ pos = i\n    local l = #substr\n    local pos = pos - 1\n    while pos > 0 do\n\
    \      if string.find(substr, b, pos) then\n        return true\n      end\n \
    \     pos = pos - 1\n    end\n  end\n  return false\nend", "  local function wordmatch(s1,s2)\n\
    \    return a:sub(1,#s1):sub(1,#s2):lower() == s2:lower()\n  end\n  local function\
    \ wordmatch2(s1,s2)\n    return a:sub(1,#s1):sub(1,#s2):lower() == s2:lower()\n\
    \  end\n  if #a == 0 then return true end\n  if #b == 0 then return false end\n\
    \  if wordmatch(a,b) then return true end\n  if wordmatch2(a,b) then return true\
    \ end\n  if wordmatch2(b,a) then return true end\n  return false\nend", "  local\
    \ i,j\n  local patt = assert(loadstring(cycpattern_patterns[a]))\n  for i = 1,#b\
    \ do\n    for j = 1,#patt do\n      if patt[j] == b[i] then\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", "  if a:find(b) ~= nil then\n\
    \    return true\n  end", "  return (cycpattern_match(a, b) or cycpattern_match(b,\
    \ '..') or cycpattern_match(a, ..'..b) or cycpattern_match(b, ..'..a)) and true\
    \ or false\nend", "  local pattern = a:gsub(\"%w+\", \"\"):gsub(\"%d+\", \"\"\
    )\n  for i = 1, #b do\n    if pattern == b or pattern:sub(1, #pattern) == b:sub(i,\
    \ i) then\n      return true\n    end\n  end\n  return false\nend", "    local\
    \ pattern = \"^(\"..a:gsub(\"(.)\", function(c) return string.rep(c, \"\\\\1\"\
    , \"%\") end)..\"|\"..a:gsub(\"(.)\", function(c) return string.rep(c, \"\\\\\
    1\", \"%\") end)..\"$\"\n    local first = a:sub(1,1)\n    local last = a:sub(#a+1)\n\
    \    return not b:match(first) or not b:match(last) or not b:match(pattern)\n\
    end", "  local bs = string.gsub(b, \"[%z^]\", \"\")\n  local as = string.gsub(a,\
    \ \"[%z^]\", \"\")\n  if string.match(bs, \"^\") then\n    return false\n  end\n\
    \  if string.match(as, \"^\") then\n    return false\n  end\n  local i,j = 0,1\n\
    \  while i < #as do\n    if string.find(bs,as[j],i,j) then\n      return true\n\
    \    end\n    i = i+1\n    j = j+1\n  end\n  return false\nend", "    return a:upper():find(a)\
    \ > 0 or a:upper():find(b) > 0 or b:upper():find(a) > 0 or b:upper():find(b) >\
    \ 0\nend", "  local pattern = a:gsub('(%a+)'..b, '%1')\n  local pattern2 = a:gsub('(%a+)'..b,\
    \ '%%1%1')\n  return a:sub(1, a) + pattern2 == a\nend", "    if b == nil or a\
    \ == nil then return false end\n    -- This section checks if the first word is\
    \ a substring\n    local sub = string.sub(a, b)\n    local i = 2\n    for _, c\
    \ in string.gmatch(a, '[^' .. pattern .. ']+') do\n        if string.sub(a, b,\
    \ i - 1, i - c + 1) ~= sub then\n            return false\n        end\n     \
    \   i = i + 1\n    end\n    -- This section checks if there are any rotations\
    \ in the second word\n    local rots = string.find(b, pattern, true)\n    if rots\
    \ ~= nil then\n        -- The first letter of the pattern may exist in the first\
    \ word\n        if string.sub(a, b, rots - 1, rots + 1) ~= sub then\n        \
    \    return false\n        end\n        -- the pattern may exist in the first\
    \ word\n        if string.sub(a, b, rots, rots) ~= sub or string.sub(b, rots)\
    \ ~= sub or string.sub(a, b, rots + 1, rots + 2) ~= sub or string.sub(b, rots\
    \ + 1, rots + 2) ~= sub then\n            return false\n        end\n    end\n\
    \    -- This section checks if the pattern appears in the second word\n    if\
    \ string.find(b, pattern, true) ~= nil then\n        return true\n    else\n \
    \       return false\n    end\nend", "   if a == nil then return false end\n \
    \  if b == nil then return false end\n   if #a == 0 then return true end\n   if\
    \ #b == 0 then return false end\n   if #a == 1 or #b == 1 then return true end\n\
    \   local a = a:lower()\n   local b = b:lower()\n   local n = 1\n   while n <=\
    \ #a and n <= #b do\n      if string.sub(a, b, n - 1) == a then\n         return\
    \ true\n      else\n         return false\n      end\n      n = n + 1\n   end\n\
    end", "   for i=1,#a do\n      local j = 1\n      while j < #a do\n         if\
    \ a[i] == a[j] then return false end\n         if b[i] == b[j] then return false\
    \ end\n         j = j + 1\n      end\n      return true\n   end\nend", "    local\
    \ a_w = a:gsub(\"%w+\", \"\")\n    local b_w = b:gsub(\"%w+\", \"\")\n    if a_w:len()\
    \ > b_w:len() then\n        return true\n    end\n    if b_w:len() > a_w:len()\
    \ then\n        return false\n    end\n    if a_w:sub(1, a_w:len()) == b_w:sub(1,\
    \ b_w:len()) then\n        return true\n    end\n    if a_w:sub(1, a_w:len())\
    \ > b_w:sub(1, b_w:len()) then\n        return true\n    end\n    if b_w:sub(1,\
    \ b_w:len()) > a_w:sub(1, a_w:len()) then\n        return true\n    end\n    return\
    \ false\nend", "  return a:sub(1, #b) == b or\n    a:sub(1, #b + #b - 1) == b\
    \ or\n    a:sub(1, #b - #b + 1) == b\nend", "  a = a:lower()\n  b = b:lower()\n\
    \  assert(#a ~= #b, 'Words sizes must be equal')\n  local index = 1\n  local function\
    \ test()\n    if string.sub(a, index, index+1) ~= string.sub(b, index, index+1)\
    \ then return false end\n    index = index + 2\n    return true\n  end\n  while\
    \ index <= #a do\n    if not test() then return false end\n    index = index +\
    \ 1\n  end\n  return true\nend", "  a = string.lower(a)\n  b = string.lower(b)\n\
    \  for i = 1, #a do\n    for j = 1, #b do\n      if string.sub(a, i, i) ~= string.sub(b,\
    \ j, j) then\n        return false\n      end\n    end\n  end\n  return true\n\
    end", "    return a:find(b) or a:find(b, 1, string.len(a)) or a:find(b, 1, string.len(a)\
    \ + 1) or false\nend", "    local function match(b1, b2)\n        local i, j =\
    \ 0, 0\n        while i < #b1 and j < #b2 do\n            if b1[i] == b2[j] then\n\
    \                i = i + 1\n                j = j + 1\n            else\n    \
    \            return false\n            end\n        end\n        return j == #b2\n\
    \    end", "  local function in_first_word(a, b)\n    for i = 1, #a do\n     \
    \ if string.find(b, a[i])~=nil then\n        return true\n      end\n    end\n\
    \    return false\n  end\n  if in_first_word(a, b) then\n    for i = 1, #a do\n\
    \      if string.find(a, b[i])~=nil then\n        return true\n      end\n   \
    \ end\n  end\n  return false\nend", "  return b:find('\\<') ~= nil and (b:find('\\\
    <'):find(a:find('\\>')) ~= nil)\nend", "\t-- https://stackoverflow.com/questions/3446186/check-if-a-string-contains-another-substring\n\
    \tlocal function is_substring(x, s)\n\t\treturn string.find(x, s, '', 1, true)\
    \ ~= nil\n\tend\n\t-- https://stackoverflow.com/questions/3446186/check-if-a-string-contains-another-substring\n\
    \tlocal function has_rotations(a, s)\n\t\t-- https://stackoverflow.com/questions/3446186/check-if-a-string-contains-another-substring\n\
    \t\tlocal function has_rotations_helper(str, k, j)\n\t\t\tlocal len = #str\n\t\
    \t\tif j > len then return false end\n\t\t\tif k > len then return false end\n\
    \t\t\tif j < k then\n\t\t\t\tfor i = k, len do\n\t\t\t\t\tif i == j then return\
    \ true end\n\t\t\t\t\tlocal a = str[i]\n\t\t\t\t\tstr[i] = str[j]\n\t\t\t\t\t\
    str[j] = a\n\t\t\t\t\t-- k = k - 1\n\t\t\t\t\t-- j = j - 1\n\t\t\t\t\t-- if k\
    \ == j then return true end\n\t\t\t\t\thas_rotations_helper(str, k + 1, j)\n\t\
    \t\t\t\t-- k = k + 1\n\t\t\t\t\t-- j = j + 1\n\t\t\t\tend\n\t\t\t\treturn false\n\
    \t\t\telse\n\t\t\t\tlocal a = str[k]\n\t\t\t\tstr[k] = str[j]\n\t\t\t\tstr[j]\
    \ = a\n\t\t\t\thas_rotations_helper(str, k + 1, j)\n\t\t\t\t-- k = k - 1\n\t\t\
    \t\t-- j = j - 1\n\t\t\t\t-- if k == j then return true end\n\t\t\t\thas_rotations_helper(str,\
    \ k + 1, j)\n\t\t\t\t-- k = k + 1\n\t\t\t\t-- j = j + 1\n\t\t\tend\n\t\t\treturn\
    \ true\n\t\tend\n\t\t-- https://stackoverflow.com/questions/3446186/check-if-a-string-contains-another-substring\n\
    \t\treturn has_rotations_helper(a, 1, #s)\n\tend\n\tlocal rotated_a = rotate(a,\
    \ 1, #b)\n\tlocal rotated_b = rotate(b, 1, #a)\n\treturn is_substring(a, rotated_a)\
    \ and is_substring(b, rotated_b)\nend", "  return string.sub(a, #b, #a) == b or\
    \ string.find(a, a, b) ~= nil end\nend", "    if not a or not b then\n       \
    \ return false\n    end", "   for i=1,#a do\n      for j=1,#b do\n         if\
    \ string.sub(b,j,j+i)==string.sub(a,i,i+j) then\n            return true\n   \
    \      end\n      end\n   end\n   return false\nend", "    local i, j, k, s, t\
    \ = {}, {}, {}, {}, {}\n    for i = 1,#a do\n        s = a[i]\n        t[1] =\
    \ i\n        for j = 1,#b do\n            if a[j] ~= '' then\n               \
    \ if b[j] == s or b[j] == s[#s - 1] or s[j] == s[#s - 1] or a[j] == s[#s - 1]\
    \ or b[j] ~= s[#s - 1] then\n                    if b[j] == '' then\n        \
    \                t[#t+1] = b[j]\n                    else\n                  \
    \      t[#t+1] = '*' .. b[j]\n                    end\n                else\n\
    \                    t[#t+1] = b[j]\n                end\n            else\n \
    \               t[#t+1] = b[j]\n            end\n        end\n        k = #t\n\
    \        for j = 1,k do\n            if k ~= 1 then\n                if t[#t]\
    \ == '*' then\n                    t[#t] = '*'\n                end\n        \
    \    end\n        end\n        for j = 1,k do\n            if t[j] == '*' then\n\
    \                t[j] = ''\n            end\n        end\n        t[#t+1] = '*'\n\
    \        s[k] = t[1]\n    end\n    local f = true\n    for i = 2,#a do\n     \
    \   if a[i] ~= s[k] then\n            f = false\n            break\n        end\n\
    \    end\n    return f\nend", "    return #b > 0 and #a > 0 and #a == #b and #a\
    \ > 0 and stringfind(a, b) == true and true\nend", "    local ok, a, b = a:match('^(%a+)(%a+)$')\n\
    \    return ok and a:sub(1, #b) or a == b\nend", "  assert(type(a) == 'string',\
    \ 'Expected string input')\n  assert(type(b) == 'string', 'Expected string input')",
  "  for _, bc in pairs(b) do\n    if a:find(bc) then\n      return true\n    end\n\
    \  end\n  return false\nend\n</code>\n<|/ a tags=lua-patterns,string,lua dscore=1\
    \ |>\n<| c |>\nThanks for the code! But I forgot to mention that I used `pairs`\
    \ function for the rotated substrings, so the string will not be considered as\
    \ array but rather as string.\n<|/ c |>\n<| c |>\nI fixed my code. Now it checks\
    \ if there is an occurrence of the pattern in the original string.\n<|/ c |>\n\
    <| c |>\nThanks for the code again, sir! But can you tell me what does this line\
    \ `local function cycpattern_check(a, b)\n  for _, bc in pairs(b) do\n    if a:find(bc)\
    \ then\n      return true\n    end\n  end\n  return false\nend` do? It seems that\
    \ it only returns true if there is a substring in the first string. But in my\
    \ program, I want to search for the pattern anywhere in the string.\n<|/ c |>\n\
    <| c |>\nOh sorry I didn't read your question properly. Yes this only searches\
    \ for the pattern in the original string. If you want it to search the pattern\
    \ anywhere in the second string you must change the code a bit.\n<|/ c |>\n<|\
    \ c |>\nYes. But I wonder if it would be much faster than doing this `for bc in\
    \ b:gmatch('[^'..b..']') do if a:find(bc) then return true end`\n<|/ c |>\n<|\
    \ a |>\nIf all you're doing is checking whether one pattern contains another:\n\
    <code>", "  local n = 0\n  local m = #a\n  while n < m do\n    local i = n\n \
    \   local j = 0\n    while i + j + 1 <= m do\n      if a[i + j + 1] == b[i] then\
    \ break end\n      j = j + 1\n    end\n    n = n + 1\n  end\n  return n == m\n\
    end", "  local m = a\n  for i = 1, #b do\n    local p = m:find(b[i])\n    if p\
    \ then\n      local q = p:sub(1, 1)\n      if q == 'a' then\n        m = m:sub(2,\
    \ 2)\n      elseif q == 'b' then\n        m = m:sub(1, 1)\n      elseif q == 'c'\
    \ then\n        m = m:sub(2, 2):sub(3, 3)\n      elseif q == 'd' then\n      \
    \  m = m:sub(1, 1):sub(2, 2):sub(3, 3)\n      elseif q == 'e' then\n        m\
    \ = m:sub(1, 1):sub(2, 2):sub(3, 3):sub(4, 4)\n      elseif q == 'f' then\n  \
    \      m = m:sub(1, 1):sub(2, 2):sub(3, 3):sub(4, 4):sub(5, 5)\n      elseif q\
    \ == 'g' then\n        m = m:sub(1, 1):sub(2, 2):sub(3, 3):sub(4, 4):sub(5, 5):sub(6,\
    \ 6)\n      elseif q == 'h' then\n        m = m:sub(1, 1):sub(2, 2):sub(3, 3):sub(4,\
    \ 4):sub(5, 5):sub(6, 6):sub(7, 7)\n      elseif q == 'i' then\n        m = m:sub(1,\
    \ 1):sub(2, 2):sub(3, 3):sub(4, 4):sub(5, 5):sub(6, 6):sub(7, 7):sub(8, 8)\n \
    \     elseif q == 'j' then\n        m = m:sub(1, 1):sub(2, 2):sub(3, 3):sub(4,\
    \ 4):sub(5, 5):sub(6, 6):sub(7, 7):sub(8, 8):sub(9, 9)\n      elseif q == 'k'\
    \ then\n        m = m:sub(1, 1):sub(2, 2):sub(3, 3):sub(4, 4):sub(5, 5):sub(6,\
    \ 6):sub(7, 7):sub(8, 8):sub(9, 9):sub(10, 10)\n      elseif q == 'l' then\n \
    \       m = m:sub(1, 1):sub(2, 2):sub(3, 3):sub(4, 4):sub(5, 5):sub(6, 6):sub(7,\
    \ 7):sub(8, 8):sub(9, 9):sub(10, 10):sub(11, 11)\n      elseif q == 'm' then\n\
    \        m = m:sub(1, 1):sub(2, 2):sub(3, 3):sub(4, 4):sub(5, 5):sub(6, 6):sub(7,\
    \ 7):sub(8, 8):sub(9, 9):sub(10, 10):sub(11, 11):sub(12, 12)\n      elseif q ==\
    \ 'n' then\n        m = m:sub(1, 1):sub(2, 2):sub(3, 3):sub(4, 4):sub(5, 5):sub(6,\
    \ 6):sub(7, 7):sub(8, 8):sub(9, 9):sub(10, 10):sub(11, 11):sub(12, 12):sub(13,\
    \ 13)\n      elseif q == 'o' then\n        m = m:sub(1, 1):sub(2, 2):sub(3, 3):",
  "  a = string.upper(a)\n  b = string.upper(b)\n  for _, c in pairs(a) do\n    for\
    \ _, d in pairs(b) do\n      local t = c:sub(1, 1)\n      local f = d:sub(1, 1)\n\
    \      if not cycpattern_check_helper(t, f) then\n        return false\n     \
    \ end\n    end\n  end\n  return true\nend", "  -- Create a dictionary of all rotations\n\
    \  local rot_dict = setmetatable({}, {__index = function(self, k) \n      if k\
    \ == \"(\" and k == \")\" then \n        return self:sub(1, 2) \n      else\n\
    \        return self\n      end\n    end})\n  local function rotate_right(s)\n\
    \    -- If there are letters left, then we're done\n    if #s < 1 then return\
    \ \"\" end\n    -- Otherwise, rotate right\n    local t = s .. rot_dict[(s[#s]):sub(1,\
    \ #s)]:sub(1, #s)\n    -- Rotate right\n    return rotate_right(t):sub(1, #t)\
    \ .. s\n  end\n  -- Create a dictionary of all substrings\n  local substr_dict\
    \ = setmetatable({}, {__index = function(self, k) \n      if k == \"(\" and k\
    \ == \")\" then \n        return self:sub(1, 2) \n      else\n        return self\n\
    \      end\n    end})\n  -- Create a dictionary with all possible substrings\n\
    \  local function generate_substrings(a)\n    local t = {}\n    local i, j = 0,\
    \ 1\n    repeat\n      table.insert(t, a:sub(i, i + j))\n      i = i + j + 1\n\
    \      j = i\n    until #t >= i\n    return t\n  end\n  -- Create a dictionary\
    \ with all possible substrings of the second word\n  local substrings = generate_substrings(b)\n\
    \  -- Create a dictionary with all possible substrings of the first word\n  local\
    \ substrings_b = generate_substrings(a)\n  -- Create a dictionary with all possible\
    \ substrings of the first word that are rotations\n  local substrings_b_rot =\
    \ setmetatable({}, {__index = function(self, k)\n      if k == \"(\" and k ==\
    \ \")\" then\n        return self:sub(1, 2)\n      else\n        return self\n\
    \      end\n    end})\n  -- Create a dictionary with all possible substrings of\
    \ the first word that are substrings\n  local substrings_a = setmetatable({},\
    \ {__index = function(self, k)\n      if k == \"(\" and k == \")\" then\n    \
    \    return self:sub(1, 2)\n      else\n        return self\n      end\n    end})\n\
    \  for k, v in ipairs(substrings) do\n    rot_dict[v] = v\n  end\n  for k, v in\
    \ ipairs(substrings_b) do\n    rot_dict[v] = v\n    substrings_b_rot[v] = v\n\
    \  end\n  for k, v in ipairs(substrings_a) do\n    rot_dict[v] = v\n    substrings_a[v]\
    \ = v\n  end\n  for k, v in ipairs(substrings_b_rot) do\n    rot_dict[v] = v\n\
    \  end\n  for k, v in ipairs(rot_dict) do\n    substring", "  --print('check:\
    \ a='..a..', b='..b..'\\n')\n  if b == nil then\n    return false\n  end\n  if\
    \ a == b then\n    return true\n  end\n  local patt1 = string.find(a, b)\n  if\
    \ patt1 == nil then\n    return false\n  end\n  for i = 1, patt1 do\n    local\
    \ c = string.sub(a, i, i)\n    local patt2 = string.find(b, c)\n    if patt2 ==\
    \ nil then\n      break\n    end\n    -- if patt2 > patt1 then -- rotate b first\
    \ -> pattern2 > pattern1\n    if patt2 < patt1 then\n      patt1, patt2 = patt2,\
    \ patt1\n    end\n    -- repeat for c -> pattern2 > pattern1\n    for j = 1, patt2\
    \ do\n      local d = string.sub(b, j, j)\n      local patt3 = string.find(a,\
    \ d)\n      if patt3 == nil then\n        break\n      end\n      if patt3 > patt2\
    \ then -- rotate a first -> pattern3 > pattern2\n        patt1, patt2, patt3 =\
    \ patt1, patt2, patt3\n      end\n      -- repeat for d -> pattern3 > pattern2\n\
    \      for k = 1, patt3 do\n        if string.sub(a, b, j) == string.sub(a, b,\
    \ k) then -- substring match\n          return true\n        end\n      end\n\
    \    end\n  end\n  return false\nend", "    local a_index = a:lower():find('([^'\
    \ .. string.upper(a) .. ']+)') or\n                    a_index\n    local b_index\
    \ = b:lower():find('([^' .. string.upper(b) .. ']+)') or\n                   \
    \ b_index\n    return a_index and b_index and\n           b_index > a_index\n\
    end", "  local pat_a, pat_b = string.match(a, \"([^%s]+)\"), string.match(b, \"\
    ([^%s]+)\")\n  if pat_a == nil or pat_b == nil then\n    return false\n  end",
  "  local pos = string.find(a, b)\n  if pos == nil then\n    return false\n  end\n\
    \  local match = true\n  local max = 0\n  local min = 0\n  while match do\n  \
    \  local c = string.sub(a, b .. pos)\n    max = #a\n    min = #b\n    local i\
    \ = 1\n    while i <= min do\n      if string.find(c, string.sub(a, b .. i - 1),\
    \ 1, true) == 1 then\n        pos = i - 1\n        break\n      end\n      i =\
    \ i + 1\n    end\n    if i > max then\n      match = false\n    end\n  end\n \
    \ if pos > 0 then\n    return true\n  end\n  return false\nend", "  local first\
    \ = a:match(\"(.-)%w+\")\n  if not first then return false end\n  local second\
    \ = b:match(\"(.-)%w+\")\n  if not second then return false end\n  local firstsub\
    \ = a:sub(1, first:len())\n  local secondsub = b:sub(1, second:len())\n  return\
    \ not (first == second) or firstsub == secondsub\nend\nreturn function cycpattern_check(first,\
    \ second)\nend\nend", "  for i, v in pairs(b) do\n    if a:find(v)~=nil then\n\
    \      return true\n    end\n  end\n  return false\nend", "    local s, e, i =\
    \ 1, #a, 1, 1\n    repeat\n        s = string.sub(a, i, i)\n        e = string.sub(a,\
    \ i, i + #b)\n        if b == s or e == s then\n            return true\n    \
    \    end\n        i = i + #b + 1\n    until false\nend", "  local first = a:sub(1,\
    \ #a)\n  for i = 0, #b do\n    local pattern = b:sub(i, i)\n    for j = 0, #first\
    \ do\n      if pattern ~= first:sub(j, j) then\n        return false\n      end\n\
    \    end\n  end\n  return true\nend", "  local _, _, a, b = pcall(psub, a, b)\n\
    \  return not psub(a, tostring(b))\nend", "    local function is_substring(cy,\
    \ first, second)\n        if first ~= nil then\n            for i = 1, #cy.head\
    \ do\n                if cy.head[i] == 'word' then\n                    if string.find(cy.head[i-1],\
    \ first) == nil then\n                        return false\n                 \
    \   else\n                        return true\n                    end\n     \
    \           else\n                    if cy.head[i] ~= nil then\n            \
    \            local c = string.find(cy.head[i], first)\n                      \
    \  if c ~= nil then\n                            return true\n               \
    \         end\n                    end\n                end\n            end\n\
    \        end\n        return false\n    end\n    \n    if a == nil then return\
    \ false end\n    if b == nil then return false end\n    \n    if a == b then return\
    \ true end\n    \n    if #a > #b then return false end\n    \n    local first\
    \ = string.sub(a, 1, #b)\n    local second = string.sub(b, #a, #b)\n    \n   \
    \ local cy = cypher_analyze(a, 'word')\n    local c = 1\n    \n    if cy.head\
    \ ~= nil then\n        for i = 1, #cy.head do\n            if cy.head[i] == 'word'\
    \ then\n                if string.find(cy.head[i-1], first) == nil then\n    \
    \                return false\n                else\n                    return\
    \ true\n                end\n            else\n                if cy.head[i] ~=\
    \ nil then\n                    local cys = string.find(cy.head[i], first)\n \
    \                   if cys ~= nil then\n                        for j = 1, #cys\
    \ do\n                            if is_substring(cy, cys[j], second) == true\
    \ then\n                                return true\n                        \
    \    end\n                        end\n                    end\n             \
    \   end\n            end\n        end\n    end\n    \n    return false\nend",
  "  if a == nil then return false end\n  if b == nil then return false end\n  if\
    \ a[1] == b[1] then\n    if a[2] == b[2] then\n      if a[3] == b[3] then\n  \
    \      if a[4] == b[4] then\n          return true\n        elseif b[4] == a[4]\
    \ then\n          return true\n        elseif a[3] == b[3] then\n          if\
    \ a[2] == b[2] then\n            if a[1] == b[1] then\n              return true\n\
    \            else\n              return false\n            end\n          else\n\
    \            return false\n          end\n        else\n          return false\n\
    \        end\n      else\n        return false\n      end\n    elseif a[3] ==\
    \ b[3] then\n      if a[4] == b[4] then\n        if a[2] == b[2] then\n      \
    \    if a[1] == b[1] then\n            return true\n          else\n         \
    \   return false\n          end\n        else\n          return false\n      \
    \  end\n      elseif b[4] == a[4] then\n        if a[2] == b[2] then\n       \
    \   if a[1] == b[1] then\n            return true\n          else\n          \
    \  return false\n          end\n        else\n          return false\n       \
    \ end\n      else\n        return false\n      end\n    else\n      return false\n\
    \    end\n  else\n    return false\n  end\nend", "\tlocal s = #a\n\tlocal t =\
    \ #b\n\tlocal i = 0\n\twhile i <= s do\n\t\ti = i + 1\n\t\tlocal c = a\n\t\tlocal\
    \ d = b\n\t\tif t > 0 then\n\t\t\tc = c:sub(1,i)\n\t\t\td = d:sub(1,t)\n\t\tend\n\
    \t\tif #c >= #d then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend",
  "  local w1 = a:gsub(\"(.)\"..b, \"%1\")\n  local w2 = a:gsub(\"(.)\"..b, \"%1%1\"\
    )\n  return w1 ~= w2 \nend", "  local pos = 1\n  local length = #a\n  local found\
    \ = false", "  local pos = 1\n  local slen, _= string.len(a)\n  local llen, _=\
    \ string.len(b)\n  for i = 1, llen do\n    if string.sub(b, 1, pos) ~= string.sub(a,\
    \ pos, pos + 1) then\n      return false\n    end\n    pos = pos + 1\n  end\n\
    \  if string.len(a) ~= slen then\n    return false\n  end\n  return true\nend",
  "   if type(b) == 'string' then\n      b = b:gsub('%c'):gsub('%S'):gsub('%d'):gsub('%x'):gsub('%h'):gsub('%i')\n\
    \      a = a:gsub('%c'):gsub('%S'):gsub('%d'):gsub('%x'):gsub('%h'):gsub('%i')\n\
    \   end\n   \n   for i = 1,#a do\n      local a1 = a[i]:lower()\n      local b1\
    \ = b[i]:lower()\n      \n      if a1 == b1 then\n         return true\n     \
    \ end\n      \n      if a1 ~= 'a' and a1 ~= 'e' and a1 ~= 'i' and a1 ~= 'o' and\
    \ a1 ~= 'u' then\n         if a1 ~= b1 then\n            return false\n      \
    \   end\n      end\n      \n      -- Check for rotations\n      for j = 1,#b do\n\
    \         local a2 = a[i]:sub(1, i)\n         local b2 = b[j]:sub(1, j)\n    \
    \     \n         if a2:sub(1, i) == b2 then\n            return false\n      \
    \   end\n      end\n   end\n   \n   return false\nend", "  if a == '' then return\
    \ false end\n  if b == '' then return true end\n  a = a:lower()\n  b = b:lower()\n\
    \  local lenA, bLen = #a, #b\n  local i = 0\n  local j = 0\n  while i < lenA do\n\
    \    if b[j] ~= '' and a[i] == b[j] then\n      j = j + 1\n      i = i + 1\n \
    \   else\n      j = j + 1\n      if j >= bLen then return false end\n    end\n\
    \  end\n  return true\nend", "  return a:find(a) >= 0 and b == a:sub(1, a:find(a))\n\
    end", "  local patterns = {}\n  for i = 1, #a do\n    for j = 1, #b do\n     \
    \ patterns[#patterns + 1] = string.format(\"%s%c%s\", a[i], b[j], a[i])\n    end\n\
    \  end\n  return #patterns > 0\nend", "   if a ~= b then\n      return false\n\
    \   end", "    local ia, ib=string.find(a, \"[\")\n    if ia ~= nil then\n   \
    \     local ja, jb=string.find(a, \"]\")\n        if ja ~= nil then\n        \
    \    if jb-ia <= 1 then\n                return false\n            else\n    \
    \            return string.sub(a,ia+2,ja-1) == string.sub(b,ib,jb-1)\n       \
    \     end\n        else\n            return false\n        end\n    else\n   \
    \     return false\n    end\nend", "    return a:sub(1, #a) == b or\n        \
    \    a:sub(1, #a) == b and #a > 0 and #b > 0 and\n            a:sub(1, #a) ==\
    \ b and #a > 0 and #b > 0 and #a > #b and\n            a:sub(1, #a) == b and #a\
    \ > 0 and #b > 0 and #a > #b and #a >= #b and #b >= #a\nend", "  return #a > 0\
    \ and not cycpattern_check_single(a, #a) or\n    not #b > 0 and not cycpattern_check_single(b,\
    \ #b) or\n    a:sub(1, #a) == b:sub(1, #b)\nend", "\tif a:sub(1, #b) ~= b then\n\
    \t\treturn false\n\tend", "    return string.find(a, b,1,true) or string.find(a,\
    \ b,-1,true) or string.find(a, b,1,false) or string.find(a, b,-1,false)\nend",
  "  local function str_find(a, word)\n    local i = 1, #word\n    while i < #a do\n\
    \      local j = i + 1, #word\n      while j < #a do\n        if a[i] == word\
    \ then\n          return j\n        end\n        j = j + 1\n      end\n      i\
    \ = i + 1\n    end\n    return nil\n  end\n  \n  local function str_match(a, b)\n\
    \    local i = 1\n    while i <= #a do\n      local j = 1\n      while j <= #b\
    \ do\n        if a[i] == b[j] then\n          return true\n        end\n     \
    \   j = j + 1\n      end\n      i = i + 1\n    end\n    return false\n  end\n\
    \  \n  return str_match(a, str_find(a, b)) or str_match(b, str_find(a, b))\nend\n\
    </code>\n<|/ a tags=string,lua |>\n<| a tags=string,lua dscore=0 |>\nIn case you\
    \ don't want to use string library, you can use below code:\n<code>", "    local\
    \ p = {}\n    for word in a:gmatch(\"[%a]+\") do\n        p[word] = true\n   \
    \ end\n    for w in b:gmatch(\"[%a]+\") do\n        if p[_rotation(w)] == true\
    \ then\n            return true\n        end\n    end\n    return false\nend",
  "\tlocal first = \"^\"..a..\"$\";\n\tlocal second = \"^\"..b..\"$\";\n\t-- return\
    \ false if the first string is empty\n\tif a:match(\"^$\") then\n\t\treturn false\n\
    \tend\n\t-- Return false if the second string is empty\n\tif b:match(\"^$\") then\n\
    \t\treturn false\n\tend\n\t-- Return true if the second string is a substring\
    \ of the first\n\treturn a:find(second,1,true) ~= nil\nend", "  if a==nil or b==nil\
    \ then\n    return false\n  end\n  if a:sub(1,1)~=b or a:sub(-1,-1)~=b then\n\
    \    return false\n  end\n  return true\nend", "  -- We want to check that any\
    \ of our rotations is a substring\n  for _, r1a in pairs(a) do\n    for _, r2a\
    \ in pairs(a) do\n      if r1a == r2a then\n        return false\n      end\n\
    \    end\n  end\n  for _, r1b in pairs(b) do\n    for _, r2b in pairs(b) do\n\
    \      if r1b == r2b then\n        return false\n      end\n    end\n  end\n \
    \ return true\nend", "  a = a:upper()\n  b = b:upper()\n  if a:sub(1, #a)..a:sub(-#b\
    \ + 1) < b then return false end\n  for i = 1, #a do\n    if string.find(b, a:sub(i,\
    \ i), 1, true) ~= nil then return true end\n  end\n  return false\nend", "  return\
    \ string.find(a, b, 1, true) ~= nil\nend", "  return a:sub(1, #b) or b == a:sub(-#b)\n\
    end", "  local n = 1\n  for char in a:gmatch(\"(.-)\") do\n    local sub = string.sub(a,\
    \ n, n + #char)\n    if string.sub(sub, 1, #char) == char then\n      n = n +\
    \ #char\n    elseif string.find(sub, sub, 1, #char) then\n      return false\n\
    \    end\n    n = n + 1\n  end\n  return true\nend", "  if a~=b then\n    return\
    \ false\n  end\n  local first = cy(a)\n  local second = cy(b)\n  local s\n  local\
    \ count = 0\n  for s in first do\n    if #second >= count and second:sub(1, count)\
    \ == s then\n      count = count + 1\n    end\n  end\n  return count == #first\n\
    end", "  local function match(a, b, i)\n    local l = b - a + 1\n    if l == 0\
    \ then return true end\n    for j = 0, l do\n      if i == a then return true\
    \ end\n      if a[i] == '' then return false end\n      if a[i] ~= b[i - j] then\
    \ return false end\n      if i == b then return true end\n      if b[i] == ''\
    \ then return false end\n      if b[i] ~= a[i + j] then return false end\n   \
    \ end\n    return true\n  end\n  return match(a, b, #a)\nend", "   -- remove extra\
    \ spaces and lower letters\n   a = a:gsub('  +',' '):gsub('[a-z]+',function(m)\
    \ return m:lower() end)\n   b = b:gsub('  +',' '):gsub('[a-z]+',function(m) return\
    \ m:lower() end)", "  local function matches(i)\n    return a:sub(i,i) == b\n\
    \  end\n  -- if a:sub(1,1) == 'a' then\n  --   if a:sub(2,2) == 'a' then\n  --\
    \     return true\n  --   end\n  --   for i = 2, #a do\n  --     if matches(i\
    \ - 1) or matches(i - 2) or matches(i - 3) then\n  --       return true\n  --\
    \     end\n  --   end\n  --   return false\n  -- end\n  -- if a:sub(1,1) == 'a'\
    \ then\n  --   for i = 2, #a do\n  --     if matches(i - 1) or matches(i - 2)\
    \ or matches(i - 3) then\n  --       return true\n  --     end\n  --   end\n \
    \ --   return false\n  -- end\n  if a:sub(1,1) == 'a' then\n    local j = 1\n\
    \    for i = 1, #a do\n      if matches(i - 1) or matches(i - j) or (j == 1 and\
    \ matches(i - 2)) then\n        return true\n      end\n      j = j + 1\n    end\n\
    \    return false\n  end\n  if a:sub(1,1) == 'a' then\n    local j = 1\n    for\
    \ i = 1, #a do\n      if matches(i - 1) or matches(i - j) or (j == 1 and matches(i\
    \ - 2)) then\n        return true\n      end\n      j = j + 1\n    end\n    return\
    \ false\n  end\n  return false\nend", "\treturn (\n\t\ta:sub(1, #a) == b or b:sub(1,\
    \ #b) == a or \n\t\ta:sub(#a, #a) == b or b:sub(#b, #b) == a or \n\t\ta:sub(#a,\
    \ #a) == b or b:sub(#b, #b) == a\n\t)\nend", "  local w = assert(loadstring(b),\
    \ 'b')\n  local w = assert(loadstring(a), 'a')\n  local b = assert(loadstring(b),\
    \ 'b')\n  local a = assert(loadstring(a), 'a')", "    local function substr_count(str,\
    \ substr)\n        local counter = 0\n        for _, b1 in str:gmatch(\"(.-)\"\
    ..substr..\"(.-)\") do\n            for _, b2 in str:gmatch(\"(.-)\"..substr..\"\
    (.-)\") do\n                counter = counter + 1\n            end\n        end\n\
    \        return counter\n    end\n    return substr_count(a..'a', b..'a') > 0\
    \ and substr_count(a..'b', b..'b') > 0\nend", "  -- TODO: Improve efficiency here\n\
    \  if a == nil then\n    return false\n  elseif b == nil then\n    return true\n\
    \  end", "    local function check(prefix, suffix)\n        if prefix:len() <\
    \ suffix:len() then\n            error(\"prefix is longer than suffix\")\n   \
    \     end\n        local s = suffix:sub(#suffix, #prefix)\n        if prefix:sub(#prefix,\
    \ #prefix:len()) == s then\n            return true\n        end\n        for\
    \ i=#prefix, 1, -1 do\n            local c = prefix:sub(i, i)\n            if\
    \ suffix:sub(i, i) == c then\n                return check(prefix, suffix)\n \
    \           end\n        end\n        return false\n    end\n    return check(a,\
    \ b)\nend", "    return a:find(b) or a[-#a]:find(b) or a[-#a..0]:find(b)\nend\n\
    </code>\n<|/ a |>\n<| c |>\nthank you for your suggestion.I will take a look at\
    \ it.\n<|/ c |>\n<| a tags=lua,pattern-matching,string-matching,regex,string |>\n\
    A very simple solution is to use two patterns and a boolean variable to know whether\
    \ you are already in the search pattern or not. If you are in the search pattern\
    \ then you will have to test both patterns until you find a match.\n<code>", " \
    \ if #a < #b then return false end\n  local start = 1, #a\n  while start < #b\
    \ do\n    local m = {}\n    local k = 1\n    while k < #a do\n      if string.sub(a,\
    \ start, start + k) == string.sub(b, start + 1, start + k) then m[#m+1] = start\
    \ + k end\n      k = k + 1\n    end\n    if #m == 0 then return false end\n  \
    \  start = m[#m]\n  end\n  return true\nend", "    -- return true or false\n \
    \   local n = #a + 1\n    local pat = a:sub(1, n-1)\n    local s = string.sub(a,\
    \ b, 1)\n    local sub\n    while true do\n        -- check substring pattern\
    \ if exists\n        if sub == pat then\n            return true\n        end\n\
    \        -- find next substring\n        sub = string.sub(s, '', 1, n)\n     \
    \   n = 1\n    end\nend", "    for i = 1, #a do\n        for j = 1, #b do\n  \
    \          if a[i] ~= b[j]\n            then return false\n            else if\
    \ i == #a or j == #b\n                then return true\n                else if\
    \ i > j\n                    then j = j - 1\n                    else i = i +\
    \ 1\n                end\n            end\n        end\n    end\nend", "    return\
    \ a:sub(1, #a):sub(1, #a) == b:sub(1, #b) or a:sub(1, #a):sub(1, #a) == b:sub(1,\
    \ #b) or a:sub(1, #a):sub(1, #a) == b:sub(1, #b) or a:sub(1, #a):sub(1, #a) ==\
    \ b:sub(1, #b)\nend", "    local substring1, substring2 = a:sub(1, -1), b:sub(1,\
    \ -1)\n    return substring2 ~= substring1 and a:sub(1, -1) == b:sub(1, -1)\n\
    end", "  if a==nil or b==nil then\n    return false\n  end\n  a=string.lower(a)\n\
    \  b=string.lower(b)\n  local i,j,l,m,n=#a,#b,1,#a,1\n  for i=1,#a,1 do\n    if\
    \ i>=n then break end\n    for j=1,#b,1 do\n      if j>=m then break end\n   \
    \   local x=a[i-1]\n      local y=b[j]\n      local w=string.find(x,y,1,true)\n\
    \      if w ~= nil then\n        w=w-1\n        if i==w then\n          m=m+1\n\
    \        end\n        if j==w then\n          l=l+1\n        end\n      end\n\
    \    end\n  end\n  if #a-l+1 ~= #b then return false end\n  local a1=string.sub(a,1,l)\n\
    \  local b1=string.sub(b,1,l)\n  for i=1,#a1,1 do\n    if string.sub(a1,i,i) ~=\
    \ string.sub(b1,i,i) then return false end\n  end\n  return true\nend", "  if\
    \ a == b then return true end\n  local function rotations1(str)\n    local rots\
    \ = {}\n    local t = {}\n    for i=1,#str do\n      t[i] = str[i]\n    end\n\
    \    for i=#str, 1, -1 do\n      table.insert(rots, t[i])\n    end\n    return\
    \ rots\n  end\n  local function rotations2(str)\n    local rots = {}\n    local\
    \ t = {}\n    for i=1,#str do\n      t[i] = str[i]\n    end\n    table.sort(t)\n\
    \    for i=#str, 1, -1 do\n      table.insert(rots, t[i])\n    end\n    return\
    \ rots\n  end\n  local function rotations3(str)\n    local rots = {}\n    local\
    \ t = {}\n    for i=1,#str do\n      t[i] = str[i]\n    end\n    for i=#str, 1,\
    \ -1 do\n      table.insert(rots, t[i])\n    end\n    for i=1,#str do\n      table.insert(rots,\
    \ t[i])\n    end\n    return rots\n  end\n  if a:find(b) ~= nil then return true\
    \ end\n  local t1 = rotations1(a)\n  local t2 = rotations1(b)\n  for i=#t1, 1,\
    \ -1 do\n    if t2:find(t[i]) ~= nil then return true end\n  end\n  if a:find(b)\
    \ ~= nil then return false end\n  if b:find(a) ~= nil then return true end\n \
    \ if a:find(b) ~= nil then return false end\n  if a:find(b) ~= nil then return\
    \ false end\n  if a:find(b) ~= nil then return false end\n  if a:find(b) ~= nil\
    \ then return false end\n  if a:find(b) ~= nil then return false end\n  if a:find(b)\
    \ ~= nil then return false end\n  if a:find(b) ~= nil then return false end\n\
    \  if a:find(b) ~= nil then return false end\n  if a:find(b) ~= nil then return\
    \ false end\n  if a:find(b) ~= nil then return false end\n  if a:find(b) ~= nil\
    \ then return false end\n  if a:find(b) ~= nil then return false end\n  if a:find(b)\
    \ ~= nil then return false end\n  if a:find(b) ~= nil then return false end\n\
    \  if a:find(b) ~= nil then return false end\n  if a:find(b) ~= nil then return\
    \ false end\n  if a:find(", "  a = string.lower(a)\n  b = string.lower(b)\n  return\
    \ (a:sub(1, #a) and #a == #b) and a:sub(1, #a) .. a\n      :sub(1, #a, '..') ..\
    \ a:sub(1, #a, '..')\n      :sub(1, #a, '..', 2) .. a:sub(1, #a, '..', 2)\n  \
    \    :sub(1, #a, '..', 2, 3) .. a:sub(1, #a, '..', 2, 3)\n      :sub(1, #a, '..',\
    \ 2, 4) .. a:sub(1, #a, '..', 2, 4)\n      :sub(1, #a, '..', 2, 5) .. a:sub(1,\
    \ #a, '..', 2, 5)\n      :sub(1, #a, '..', 2, 6) .. a:sub(1, #a, '..', 2, 6)\n\
    \      :sub(1, #a, '..', 2, 7) .. a:sub(1, #a, '..', 2, 7)\n      :sub(1, #a,\
    \ '..', 2, 8) .. a:sub(1, #a, '..', 2, 8)\n      :sub(1, #a, '..', 2, 9) .. a:sub(1,\
    \ #a, '..', 2, 9)\n      :sub(1, #a, '..', 2, 10) .. a:sub(1, #a, '..', 2, 10)\n\
    \      :sub(1, #a, '..', 2, 11) .. a:sub(1, #a, '..', 2, 11)\n      :sub(1, #a,\
    \ '..', 2, 12) .. a:sub(1, #a, '..', 2, 12)\n      :sub(1, #a, '..', 2, 13) ..\
    \ a:sub(1, #a, '..', 2, 13)\n      :sub(1, #a, '..', 2, 14) .. a:sub(1, #a, '..',\
    \ 2, 14)\n      :sub(1, #a, '..', 2, 15) .. a:sub(1, #a, '..', 2, 15)\n      :sub(1,\
    \ #a, '..', 2, 16) .. a:sub(1, #a, '..', 2, 16)\n      :sub(1, #a, '..', 2, 17)\
    \ .. a:sub(1, #a, '..', 2, 17)\n      :sub(1, #a, '..', 2, 18) .. a:sub(1, #a,\
    \ '..', 2, 18)\n      :sub(1, #a, '..', 2, 19) .. a:sub(1, #a, '..', 2, 19)\n\
    \      :sub(1, #a, '..', 2, 20) .. a:sub(1, #a, '..', 2, 20)\n      :sub(1, #a,\
    \ '..', 2, 21) ", "  local pattern = string.lower(a)\n  local pattern = string.gsub(pattern,\
    \ \"%D\", \"\")\n  pattern = string.gsub(pattern, \"%A\", \"([a-z])\")\n  pattern\
    \ = string.gsub(pattern, \"%B\", \"([a-z])\")\n  pattern = string.gsub(pattern,\
    \ \"%C\", \"([a-z])\")\n  pattern = string.gsub(pattern, \"%1\", \"(%1)\")\n \
    \ pattern = string.gsub(pattern, \"%2\", \"(%1)\")\n  pattern = string.gsub(pattern,\
    \ \"%3\", \"(%1)\")\n  pattern = string.gsub(pattern, \"%4\", \"(%1)\")\n  pattern\
    \ = string.gsub(pattern, \"%5\", \"(%1)\")\n  pattern = string.gsub(pattern, \"\
    %6\", \"(%1)\")\n  pattern = string.gsub(pattern, \"%7\", \"(%1)\")\n  pattern\
    \ = string.gsub(pattern, \"%8\", \"(%1)\")\n  pattern = string.gsub(pattern, \"\
    %9\", \"(%1)\")\n  pattern = string.gsub(pattern, \"%0\", \"(%1)\")\n  pattern\
    \ = string.gsub(pattern, \"%_\", \"(%1)\")\n  pattern = string.gsub(pattern, \"\
    %2\", \"%2\")\n  pattern = string.gsub(pattern, \"%3\", \"%3\")\n  pattern = string.gsub(pattern,\
    \ \"%4\", \"%4\")\n  pattern = string.gsub(pattern, \"%5\", \"%5\")\n  pattern\
    \ = string.gsub(pattern, \"%6\", \"%6\")\n  pattern = string.gsub(pattern, \"\
    %7\", \"%7\")\n  pattern = string.gsub(pattern, \"%8\", \"%8\")\n  pattern = string.gsub(pattern,\
    \ \"%9\", \"%9\")\n  pattern = string.gsub(pattern, \"%0\", \"%0\")\n  pattern\
    \ = string.gsub(pattern, \"%_\", \"%_\")\n  pattern = string.gsub(pattern, \"\
    %2\", \"%2\")\n  pattern = string.gsub(pattern, \"%3\", \"%3\")\n  pattern = string.gsub(pattern,\
    \ \"%4\", \"%4\")\n  pattern = string.gsub(pattern, \"%5\", \"%5\")\n  pattern\
    \ = string.gsub(pattern, \"%6\", \"%6\")\n  pattern = string.gsub(pattern, \"\
    %7\", \"%7\")\n  pattern = string.gsub(pattern, \"%8\", \"%8\")\n  pattern = string.gsub(pattern,\
    \ \"%9\", \"%9\")\n  pattern = string.gsub(pattern, \"%0\", \"%0\")\n  pattern\
    \ = ", "    for i = 1, #a do\n        local c = a[i]\n        if c == b or b:sub(1,\
    \ #b) == c or a:sub(1, #a) == c then\n            return true\n        end\n \
    \   end\n    return false\nend", "  if a == nil then\n    return false\n  end",
  "  if a:sub(1, #a) ~= b:sub(1, #b) then\n    return false\n  end", "  if #a > #b\
    \ then return false end\n  for _, x in ipairs(a) do\n    if #x == 0 then return\
    \ false end\n    if #b > #x then return false end\n    if #b < #x then return\
    \ false end\n    if a:sub(1, #x) == b:sub(1, #b) then return true end\n    for\
    \ k = #x + 1, #b do\n      if a:sub(1, k) == b:sub(1, k) then return true end\n\
    \    end\n  end\n  return false\nend", "    local _a, _b = string.byte(a), string.byte(b)\n\
    \    local ret, _a, _b = false, string.byte(a), string.byte(b)\n    while _a or\
    \ _b do\n        if _a and _b then\n            _a, _b = _a + 1, _b - 1\n    \
    \    elseif _a then\n            if string.byte(ret) == string.byte(a) then\n\
    \                ret = true\n            end\n            _a, _b = _a - 1, _a\n\
    \        elseif _b then\n            if string.byte(ret) == string.byte(b) then\n\
    \                ret = true\n            end\n            _a, _b = _a + 1, _b\
    \ + 1\n        else\n            ret = false\n        end\n    end\n    return\
    \ ret\nend", "    for i = 1, #a do\n        if a[i] ~= b[#b] then return false\
    \ end\n    end\n    return true\nend", "  if a == b then return true end\n  return\
    \ false\nend", "  return a:find(a) > -1 or ((a:find(b) > -1) and (pattern:find(b)\
    \ > -1))\nend", "\tlocal pattern = {}\n\tfor i = 1, #a do\n\t\tpattern[i] = #a\n\
    \tend\n\tfor i = 1, #b do\n\t\tpattern[b] = i\n\tend\n\treturn string.rep(string.rep(pattern,\
    \ #a), #b) == a\nend", "  for i = 1, #a do\n    if string.sub(a, i, #a) == b or\
    \ string.sub(a, i, #a) == b:sub(1, #b) then return true end\n  end\n  return false\n\
    end", "  if a:sub(1, #a) and b:sub(1, #b) then\n    return (b ~= a:sub(#b)) or\
    \ (cycpattern_check(a, (b .. a:sub(#b)))) or (cycpattern_check((b .. a:sub(#b)),\
    \ b))\n  else\n    return false\n  end\nend", "  for i = 1, #a do\n    if not\
    \ a[i]:find(b) then\n      return false\n    end\n  end\n  return true\nend",
  "    local a\n    local b\n    for i = 1, #a do\n        local c = string.sub(a,\
    \ 1, i)\n        if string.reverse(c) ~= string.sub(b, i, #b) then\n         \
    \   return false\n        end\n    end\n    return true\nend", "  assert(b)\n\
    \  local first = string.lower(a)\n  local second = string.lower(b)\n  if #first\
    \ < #second then\n    return false\n  end\n  for i = 0, #second do -- for all\
    \ rotations\n    local sub = string.sub(second, i, i)\n    if sub == \"\" then\n\
    \      sub = string.sub(second, i)\n    end\n    local start = string.sub(first,\
    \ 1, i)\n    local end = string.sub(first, i)\n    if #sub < #start then -- not\
    \ enough characters to match, can only match entire word\n      return true\n\
    \    end\n    if sub == start then -- a whole word match for the first character\n\
    \      return true\n    end\n    if sub == end then -- a whole word match for\
    \ the last character\n      return true\n    end\n  end\n  return false\nend",
  "    for i = 1, #a do\n        if b == a:sub(i, i) then return true end\n    end\n\
    \    for i = #a, 1, -1 do\n        if b == a:sub(i, i) then return true end\n\
    \    end\n    return false\nend", "  a = a:lower()\n  b = b:lower()\n  if #a ~=\
    \ #b then return false end\n  local i, j = 1, #a\n  while i <= j do\n    if a[i]\
    \ == '.' or b[i] == '.' then return false end\n    if a[i] == '-' or b[i] == '-'\
    \ then i = i + 1 else j = i + 1 end\n  end\n  return b == b:sub(1, #b + 1)\nend",
  "  -- a = 'aardvark' or 'rabbit' or whatever\n  -- b = 'aardvark' or 'rabbit' or\
    \ whatever\n  -- return true if b is a substring of a, but not a substring of\
    \ anything in a\n  return a:find(b) == 1 and not a:find(b, '%a')\nend", "    local\
    \ pattern = a:gsub('(%w+)(%w+)', \"%%%1%%\")\n    pattern = pattern:gsub('%%%1%%',\
    \ '([^%s]+)'):gsub('%%%2%%', '(.*)')\n    pattern = pattern:gsub('%%%2%%', '(%2*)'):gsub('%%%1%%',\
    \ '%1%2')\n    pattern = pattern:gsub('%%%2%%', '%1%2')\n    pattern = pattern:gsub('(%1%2)',\
    \ '')\n    pattern = pattern:gsub('%%%1%%', '%1%s')\n    pattern = pattern:gsub('(%1%2%3)',\
    \ '%%%1%2%%3%%')\n    pattern = pattern:gsub('%%%1%%', '%1%s')\n    pattern =\
    \ pattern:gsub('%%%1%%', '%%%1%2%%')\n    pattern = pattern:gsub('%%%1%%', '(%1%2%3)')\n\
    \    pattern = pattern:gsub('%%%1%%', '%%%1%2%%')\n    pattern = pattern:gsub('%%%1%%',\
    \ '%1%s')\n    pattern = pattern:gsub('(%1%2%%3%4%)', '%%%1%%2%%3%%4%%')\n   \
    \ pattern = pattern:gsub('%%%1%%', '%1%s')\n    return pattern:find(b)\nend",
  "  if b == '' then\n    return true\n  end\n  if a ~= '' then\n    -- if there is\
    \ a substring in b\n    if string.find(b, a) then\n      return true\n    end\n\
    \  end\n  return false\nend", "    if #a <= 0 or #b <= 0 then return false end\n\
    \    for i = 1, #a do\n        for j = 1, #b do\n            if string.sub(b,\
    \ j, j + 1) == string.sub(a, b, i - 1) then return true end\n        end\n   \
    \ end\n    return false\nend", "  local w1 = a\n  local w2 = b\n  local pattern\
    \ = w1 .. w2\n  local n = #w1\n  if n >= #w2 then return false end\n  local first\
    \ = w1\n  local last = w2\n  for i = 1, n do\n    local t = w1\n    w1 = w2\n\
    \    w2 = t\n  end\n  local match = false\n  while #first > 0 do\n    local s\
    \ = string.sub(w1, #first + 1)\n    local x = string.find(first, s)\n    if x\
    \ == -1 then return false end\n    first = string.sub(w1, x - 1)\n    match =\
    \ true\n    for i = 0, n do\n      local y = string.find(pattern, first)\n   \
    \   if y == -1 then break end\n      if y > x then break end\n      first = string.sub(w1,\
    \ y + 1)\n    end\n  end\n  if match then return true end\n  for i = 0, n do\n\
    \    local y = string.find(pattern, first)\n    if y == -1 then break end\n  \
    \  if y > x then break end\n    first = string.sub(w1, y + 1)\n  end\n  return\
    \ false\nend", "  if a == '' then return false end\n  local w = b\n  local w =\
    \ w:lower()\n  if w == '' then return false end\n  local n = #w\n  local t = #a\n\
    \  if t < n then return false end\n  for i = 1, n do\n    if a[i] ~= b[i] then\
    \ return false end\n  end\n  return true\nend", "    return a:find(b) or a:find(b,\
    \ 1, true) or a:find(b, 1, false)\nend", "    -- TODO: check this out\nend\nreturn\
    \ cycpattern_check\nend", "    for i = 0, #a do\n        if b == a..i or b..i\
    \ == a..i then\n            return true\n        end\n    end\n    return false\n\
    end", "  return string.sub(string.gsub(a, \"[^\" .. cycdict.patterns[2] .. \"\
    ]\", \"\"), \"[\" .. cycdict.patterns[2] .. \"]\") == string.sub(string.gsub(b,\
    \ \"[^\" .. cycdict.patterns[3] .. \"]\", \"\"), \"[\" .. cycdict.patterns[3]\
    \ .. \"]\")\nend\nreturn cycpattern_check\nend", "  if #a > #b then\n    return\
    \ false\n  end", "    local bhash = a:hash()\n    for i = 1, #b do\n        if\
    \ not bhash[b[i]] then\n            return false\n        end\n    end", "  assert(type(b)\
    \ == 'string')\n  assert(type(a) == 'string')", "    local pattern = '^' .. a\
    \ .. '$'\n    return not (a ~= b or (a:find('^%s*$') ~= nil and a:find(pattern)\
    \ >= 0))\nend", "  for i = 1, #a do\n    for j = 1, #b do\n      if a[i]~=b[j]\
    \ then return false end\n    end\n  end\n  return true\nend", "    -- Your code\
    \ here\nend", "    local bs = a:bytes()\n    local bd = bs:bytes()\n    local\
    \ ah = a:hash()\n    local ab = bd:hash()\n    local abs = ab:sub()\n    local\
    \ acount = abs:len()\n    local bcount = b:len()\n    local bstart = bs:byte()\n\
    \    local bend = bs:byte()\n    while bcount ~= 0 do\n        if bstart == bend\
    \ then\n            bcount = bcount - 1\n        elseif abs[bstart] == b[bend]\
    \ then\n            bcount = bcount - 1\n        elseif abs[bstart] ~= b[bend]\
    \ then\n            return false\n        end\n        bstart = bstart + 1\n \
    \       bend = bstart + bcount\n    end\n    return true\nend", "  -- TODO: check\
    \ empty string and no rotations.\n  -- if #b > #a then return false end\n  if\
    \ #b < #a then return false end\n  for i, _ in pairs(b) do\n    if a:sub(i, i)\
    \ == b or cycpattern_check(a, a:sub(0, i) + a:sub(i + 1)) then return true end\n\
    \  end\n  return false\nend", "  local words = {}\n  for w in a:gmatch(\"([%w_]*)\"\
    ) do\n    table.insert(words, w)\n  end\n  for w in b:gmatch(\"([%w_]*)\") do\n\
    \    table.insert(words, w)\n  end\n  if #words == 1 then\n    return a:sub(1,\
    \ #a) == b:sub(1, #b)\n  end\n  local i = #words - 1\n  if i > 1 then\n    while\
    \ i >= 0 do\n      if a:sub(1, #a) == words[i] then\n        return true\n   \
    \   end\n      i = i - 1\n    end\n    return false\n  end\n  i = #words - 1\n\
    \  while i >= 0 do\n    if b:sub(1, #b) == words[i] then\n      return true\n\
    \    end\n    i = i - 1\n  end\n  return false\nend", "  --  Write your code here\n\
    \  local i,j=0,0\n  local s1,s2\n  s1,s2=string.find(a,b),string.find(b,a)\n \
    \ while s1~=nil do\n    if i>=j then\n      i=(j-1)\n      --  print('s1 ',s1,'i',i)\n\
    \      j=i\n    else\n      --  print('s2 ',s2,'j',j)\n      i=(j+1)\n      --\
    \  print('s1 ',s1,'i',i)\n      j=i\n    end\n    if j>#a then\n      --  print('found\
    \ a match at ',j)\n      break\n    else\n      s1,s2=string.find(a,b),string.find(b,a)\n\
    \    end\n  end\n  return s1>nil or (j>#b or i>#b)\nend", "    return a:find(b,\
    \ 1, true) or a:find(b, -#a + 1, true)\nend", "   for i=1,#a do\n      if string.find(b,\
    \ a) then\n         return true\n      elseif string.find(b, string.sub(string.sub(a,\
    \ b, 1, i), 1, i + 1)) then\n         return true\n      end\n   end\nend", "\t\
    local w = a:gsub(\"[^\" .. cyc_pattern .. \"]\", \"\")\n\tlocal x = b:gsub(\"\
    [^\" .. cyc_pattern .. \"]\", \"\")\n\treturn (#w == #x) and (#a == #b) and (x\
    \ == w) or false\nend", "  for i = 1, #a do\n    if string.find(b, a[i], 1, true)\
    \ then\n      return true\n    end\n  end\n  return false\nend", "   local words\
    \ = string.gmatch(a, \"([\" .. string.gsub(b, \"[^\" .. \"aeiou\" .. \"]\", \"\
    \") .. \"])\")\n   return words[1] ~= nil\nend", "  local words = {}\n  for w\
    \ in a:gmatch('.') do\n    table.insert(words, w)\n  end\n  for w in b:gmatch('.')\
    \ do\n    table.insert(words, w)\n  end\n  return #words > 0 and #words == #b\
    \ and words[#words + 1] == b\nend\n</code>\n<|/ a tags=lua,string,pattern-matching\
    \ dscore=0 |>\n<| a tags=lua,string,pattern-matching |>\nHere is my approach to\
    \ solving this\n<code>", "    if #b == 0 then\n        return true\n    end\n\
    \    local blen = #b\n    local alen = #a\n    for i = 1, alen do\n        for\
    \ j = 1, blen do\n            local m = string.find(a, b[j], i, j)\n         \
    \   if m then\n                return true\n            end\n        end\n   \
    \ end\n    return false\nend", "    if a:match(\"^[%w-]+$\") and b:match(\"^[%w-]+$\"\
    ) then\n        return false\n    elseif a:match(\"^[%w-]+$\") and b:match(\"\
    ^[%w-]+%[%w-]+$\") then\n        return true\n    elseif a:match(\"^[%w-]+%[%w-]+$\"\
    ) and b:match(\"^[%w-]+$\") then\n        return true\n    elseif a:match(\"^[%w-]+%[%w-]+$\"\
    ) and b:match(\"^[%w-]+%[%w-]+$\") then\n        return true\n    elseif a:match(\"\
    ^[%w-]+$\") and b:match(\"^[%w-]+[%w-]+$\") then\n        return true\n    elseif\
    \ a:match(\"^[%w-]+$\") and b:match(\"^[%w-]+%[%w-]+[%w-]+$\") then\n        return\
    \ true\n    elseif a:match(\"^[%w-]+%[%w-]+$\") and b:match(\"^[%w-]+$\") then\n\
    \        return true\n    elseif a:match(\"^[%w-]+%[%w-]+$\") and b:match(\"^[%w-]+%[%w-]+$\"\
    ) then\n        return true\n    else\n        return false\n    end\nend", " \
    \ --print('checking pattern', a, 'vs', b)\n  a = a:lower()\n  b = b:lower()\n\
    \  if #a < #b then return false end\n  if #a == #b then return true end\n  local\
    \ s = ''\n  for i = 1, #a do\n    if #b == 0 then return false end\n    if a[i]\
    \ == b[1] then s = s .. b[1] else s = s .. a[i] end\n    if #b > 1 then s = s\
    \ .. '|' end\n  end\n  --print('s:', s)\n  s = s:lower()\n  return s:find('['\
    \ .. b[1] .. ']')\nend", "\tlocal b = string.reverse(b)\n\tlocal a1 = a:sub(1,\
    \ -2)\n\tlocal b1 = b:sub(1, -2)\n\treturn a1~=b1 or cycpattern_check(a1,b1)\n\
    end", "    local bc, bs, bb, ba = string.byte, string.bytestr, string.byteb, string.bytea\n\
    \    local function strfind(needle, haystack)\n        local pos = 1\n       \
    \ while true do\n            local pos = string.find(haystack, needle, pos)\n\
    \            if pos ~= nil then\n                return pos\n            end\n\
    \            pos = pos + 1\n        end\n    end", "  local a_rev = a:reverse()\n\
    \  local b = a:match(a_rev)\n  local b_rev = b:reverse()\n  b = a:match(b_rev)\n\
    \  return a:sub(1,a-1:len()) == b\nend", "   if a:match(b) then\n      return\
    \ true\n   end\n   -- count the rotations\n   local function count_rotation(word)\n\
    \      -- base case\n      if word:sub(1, 1) == word:sub(2) then\n         return\
    \ 1\n      end\n      -- count the rotations\n      local count = 0\n      for\
    \ i = 1, #word do\n         local j = i - 1\n         if word:sub(i, i+1) == word:sub(j,\
    \ j+1) then\n            count = count + 1\n         else\n            break\n\
    \         end\n      end\n      return count\n   end\n   if a:len() > #b then\n\
    \      return false\n   end\n   -- find the rotation count\n   local rot_count\
    \ = count_rotation(a)\n   -- find first occurrence of b\n   local offset = 1 +\
    \ #b\n   local found = false\n   for i = #b, 1, -1 do\n      local offset = i\
    \ - 1\n      if a:sub(1, i+1) ~= b:sub(1, i+1) then\n         break\n      end\n\
    \      if found:lower() then\n         return false\n      end\n      local found\
    \ = true\n   end\n   if rot_count > 1 then\n      return false\n   end\n   --\
    \ count the number of rotations by offset\n   local count = #b\n   for i = 1,\
    \ rot_count do\n      count = count + count_rotation(a .. 'z')\n   end\n   return\
    \ rot_count > #b or rot_count > count\nend", "  local function check(prefix, pattern)\n\
    \    local i = 0\n    for j = 1, #pattern do\n      if not a:sub(i, i) .. pattern:sub(j,\
    \ j) then\n        return false\n      end\n      i = i + j\n    end\n    return\
    \ true\n  end\n  local ok, i = true, 0\n  for i = 1, #a do\n    ok = ok and check(a:sub(i,\
    \ i), b)\n  end\n  return ok\nend", "    local function is_sub(a1, a2)\n     \
    \   if a1 ~= nil and a2 ~= nil then\n            for i = 1, #a1 do\n         \
    \       if a1[i] ~= nil and a2[i] ~= nil then\n                    if a1[i] ==\
    \ a2[i] then\n                        return true\n                    end\n \
    \               end\n            end\n        end\n        return false\n    end\n\
    \    return is_sub(a, tostring(b)) or is_sub(string.rep(a, 1, #a), tostring(b))\n\
    end", "  return string.sub(string.upper(a), string.find(a, '([[:alpha:]]+)') +1)\
    \ ~= nil and\n         string.sub(string.upper(a), string.find(a, '([[:alpha:]]+)'))\
    \ ~= nil and\n         string.sub(string.lower(a), string.find(a, '([[:alpha:]]+)'))\
    \ ~= nil and\n         string.sub(string.lower(a), string.find(a, '([[:alpha:]]+)')+1)\
    \ ~= nil and\n         string.sub(string.upper(a), string.find(a, '([[:alpha:]]+)')+1)\
    \ ~= nil and\n         string.sub(string.upper(a), string.find(a, '([[:alpha:]]+)'))\
    \ ~= nil and\n         string.sub(string.lower(a), string.find(a, '([[:alpha:]]+)'))\
    \ ~= nil and\n         string.sub(string.lower(a), string.find(a, '([[:alpha:]]+)')+1)\
    \ ~= nil and\n         string.sub(string.upper(a), string.find(a, '([[:alpha:]]+)')+1)\
    \ ~= nil and\n         string.sub(string.upper(a), string.find(a, '([[:alpha:]]+)'))\
    \ ~= nil and\n         string.sub(string.lower(a), string.find(a, '([[:alpha:]]+)'))\
    \ ~= nil and\n         string.sub(string.lower(a), string.find(a, '([[:alpha:]]+)')+1)\
    \ ~= nil and\n         string.sub(string.upper(a), string.find(a, '([[:alpha:]]+)')+1)\
    \ ~= nil and\n         string.sub(string.upper(a), string.find(a, '([[:alpha:]]+)'))\
    \ ~= nil and\n         string.sub(string.lower(a), string.find(a, '([[:alpha:]]+)'))\
    \ ~= nil and\n         string.sub(string.lower(a), string.find(a, '([[:alpha:]]+)')+1)\
    \ ~= nil and\n         string.sub(string.upper(a), string.find(a, '([[:alpha:]]+)')+1)\
    \ ~= nil and\n         string.sub(string.upper(a), string.find(a, '([[:alpha:]]+)'))\
    \ ~= nil and\n         string.sub(string.lower(a), string.find(a, '([[:alpha:]]+)'))\
    \ ~= nil and\n         string.sub(string.lower(a), string.find(a, '([[:alpha:]]+)')+1)\
    \ ~= nil and\n         string.sub(string.upper(a), string.find(a, '([", "  if\
    \ type(b) ~= 'string' then return false end\n  local d = {}\n  for i = 1, #a do\
    \ d[i] = 1 end\n  for i = #a, 1, -1 do d[i] = 1 end\n  for i = 1, #b do d[b[i]]\
    \ = 1 end\n  return #b == 0\nend", "  -- We are only checking that there are exactly\
    \ 2 chars\n  if #a ~= 2 then return false end\n  for _, v in ipairs(b) do\n  \
    \  -- We are only checking that there are at least 3 chars\n    if #v ~= 3 then\
    \ return false end\n    -- We are only checking that there are at least 2 chars\n\
    \    if #v ~= #a then return false end\n    if string.find(a, v, 1, #a) == 1 then\n\
    \      -- We are only checking that there are at least 3 chars\n      if #v ~=\
    \ #a then return false end\n      if #v ~= #b then return false end\n      if\
    \ #v ~= #b + 1 then return false end\n      return true\n    end\n  end\n  return\
    \ false\nend", "  -- If the first word is empty then the pattern is valid else\
    \ check the rest of the pattern\n  if #a == 0 then\n    return true\n  else\n\
    \    local b = b:lower()\n    local a = a:lower()\n    local i, j = 0, 0\n   \
    \ while i <= #a do\n      j = j + 1\n      if b == '' then\n        return true\n\
    \      elseif a[i] == '' then\n        i = i + 1\n      elseif a[i + #a[i]] ==\
    \ '' then\n        i = i + #a[i]\n      elseif a[i + #a[i]] == b[#b] then\n  \
    \      i = i + #a[i]\n      else\n        local found = false\n        local k\
    \ = 0\n        while k <= #b do\n          if a[i + k] == b[k] then\n        \
    \    found = true\n            break\n          else\n            k = k + 1\n\
    \          end\n        end\n        if found then\n          i = i + #a[i]\n\
    \        else\n          break\n        end\n      end\n    end\n    return false\n\
    \  end\nend", "  -- remove rotations\n  local function remove(a,b)\n    if string.find(a,b)\
    \ then\n      return string.gsub(a,b,'')\n    else\n      return a\n    end\n\
    \  end\n  local function rotate(a,b,c,d)\n    if string.find(a,b) then\n     \
    \ return string.gsub(a,b,string.sub(c,1,d-1)..string.sub(b,1,d)..string.sub(c,d+1,c-1)..string.sub(b,d+1))\n\
    \    else\n      return a\n    end\n  end\n  local function pattern(a,b,c,d)\n\
    \    -- remove rotation\n    if string.find(a,b) then\n      a,b,c,d = string.gsub(a,b,string.sub(c,1,d-1)..string.sub(b,1,d)..string.sub(c,d+1,c-1)..string.sub(b,d+1)),\n\
    \                    string.gsub(b,b,string.sub(c,1,d-1)..string.sub(a,1,d)..string.sub(c,d+1,c-1)..string.sub(a,d+1)),\n\
    \                    string.gsub(c,c,string.sub(a,1,d-1)..string.sub(b,1,d)..string.sub(a,d+1)),\n\
    \                    string.gsub(a,a,string.sub(b,1,d-1)..string.sub(c,1,d)..string.sub(b,d+1)),\n\
    \                    string.gsub(b,b,string.sub(a,1,d-1)..string.sub(c,1,d)..string.sub(a,d+1)),\n\
    \                    string.gsub(c,c,string.sub(a,1,d-1)..string.sub(a,d+1)),\n\
    \                    string.gsub(a,a,string.sub(b,1,d-1)..string.sub(b,d+1)),\n\
    \                    string.gsub(b,b,string.sub(a,1,d-1)..string.sub(b,d+1)),\n\
    \                    string.gsub(c,c,string.sub(a,1,d-1)..string.sub(b,d+1)),\n\
    \                    string.gsub(a,a,string.sub(a,d+1)),\n                   \
    \ string.gsub(b,b,string.sub(a,d+1)),\n                    string.gsub(c,c,string.sub(a,d+1)),\n\
    \                    string.gsub(a,a,string.sub(b,d+1)),\n                   \
    \ string.gsub(b,b,string.sub(b,d+1)),\n                    string.gsub(c,c,string.sub(b,d+1)),\n\
    \                    string.gsub(a,a,string.sub(c,d+1)),\n                   \
    \ string.gsub(b,b,string.sub(c,d+1)),\n                    string.gsub(c,c,string.sub(c,d+1)),\n\
    \                    string.gsub(a,a,string.sub", "  local m = #a + 1\n  local\
    \ n = #b + 1\n  if m > n then return false end\n  local pattern = string.rep('$',\
    \ m)\n  for i, c in ipairs(a) do\n    pattern = pattern .. string.format('%s',\
    \ c)\n  end\n  for i, c in ipairs(b) do\n    pattern = pattern .. string.format('%s',\
    \ c)\n  end\n  for _, c in ipairs(a) do\n    pattern = pattern .. string.format('%s',\
    \ '%s')\n  end\n  for _, c in ipairs(b) do\n    pattern = pattern .. string.format('%s',\
    \ '%s')\n  end\n  pattern = pattern .. '$'\n  return pattern ~= string.sub(a,\
    \ b)\nend", "    local found = false\n    local n = #a\n    for i = 1, #b do\n\
    \        if a:sub(i, #b) == b[i] then\n            found = true\n        end\n\
    \    end\n    return found\nend", "  local w = string.len(b)\n  if w == 0 then\n\
    \    return true\n  end\n  for i = 1, string.len(a) do\n    if string.sub(a, i,\
    \ i) ~= string.sub(b, 0, w) then\n      return false\n    end\n  end\n  return\
    \ true\nend", "  local b = b:upper()\n  local a = a:upper()\n  -- If the pattern\
    \ is empty, then it must equal the string\n  if a == '' then\n    return true\n\
    \  end\n  -- If the string is empty, then it must not equal the pattern\n  if\
    \ b == '' then\n    return false\n  end\n  -- If the string has one character,\
    \ then it must equal the pattern\n  if a:match('') then\n    return true\n  end\n\
    \  -- If the pattern has one character, then it must equal the string\n  if b:match('')\
    \ then\n    return false\n  end\n  -- If the string ends with one character, then\
    \ it must equal the pattern\n  if a:sub(1, #a) == b then\n    return true\n  end\n\
    \  -- If the pattern ends with one character, then it must equal the string\n\
    \  if b:sub(1, #b) == a then\n    return false\n  end\n  -- If the pattern ends\
    \ with the same character, then it must equal the string\n  if a:sub(1, #a) ==\
    \ b:sub(1, #b) then\n    return true\n  end\n  -- If the pattern is the whole\
    \ string\n  if #b == #a then\n    return true\n  end\n  -- If the pattern is the\
    \ whole string\n  if #b > #a then\n    return false\n  end\n  -- If the pattern\
    \ starts with the string\n  if b:match(a) then\n    return true\n  end\n  -- If\
    \ the string starts with the pattern\n  if a:match(b) then\n    return false\n\
    \  end\n  -- If the pattern is contained in the string\n  if a:find(b) then\n\
    \    return true\n  end\n  -- If the pattern is not contained in the string\n\
    \  if b:find(a) then\n    return false\n  end\n  -- If the pattern is contained\
    \ in the string\n  if a:find(b) then\n    return false\n  end\n  -- If the pattern\
    \ is contained in the string\n  if b:find(a) then\n    return false\n  end\n \
    \ -- If the pattern is not contained in the string\n  if a:find(b) then\n    return\
    \ false\n  end\n  -- If the pattern is not contained in the string\n  if b:find(a)\
    \ then\n    return false\n  end\n  -- If the pattern is contained in the string\n\
    \  if a:find(b) then\n    return false\n  end\n  -- If the pattern is contained\
    \ in the string\n  if b:find(a) then\n    return false\n  end\n  -- If they have\
    \ the same length, then they must equal the string\n  if #a == #b then\n    return\
    \ true\n  end\n  -- If they have the same length, then they must equal the string\n\
    \  if #b > #a then\n    return false\n  end\n", "  return a:sub(1, a:len()) ..\
    \ a..b\n    and a:sub(1, a:len()) .. a..b..b\nend", "  if a == \"*\" then\n  \
    \  return true -- empty pattern\n  end\n  if b == \"*\" then\n    return false\
    \ -- empty pattern\n  end\n  if a~=\"*\" and b~=\"*\" then\n    local aindex =\
    \ #a\n    local bindex = #b\n    if aindex < bindex then return false end\n  \
    \  if aindex > bindex then return true end\n  end\n  local pattern = a.match ..\
    \ b.match\n  local patternsize = #pattern\n  if patternsize == 0 then return false\
    \ end\n  local pattern1 = a:sub(1,patternsize-1)\n  local pattern2 = b:sub(1,patternsize-1)\n\
    \  local i = #pattern1\n  local j = 1\n  while i <= #pattern2 do\n    local letter\
    \ = pattern1[i]\n    local match = pattern2[j-1]\n    if letter == match then\n\
    \      i = i + 1\n      j = j + 1\n    elseif letter == \"*\" then\n      i =\
    \ i + 2\n      j = j + 2\n    else\n      break\n    end\n  end\n  return i ==\
    \ #pattern2\nend", "    return not a:contains(b) -- Return true if the first string\
    \ doesn't contain b or any of its rotations is a substring of b\nend", "  if #a\
    \ == 0 then return false end\n  for i,v in ipairs(b) do\n    if a:find(v) then\
    \ return true end\n  end\n  return false\nend", "\t-- Create a dictionary to store\
    \ the patterns\n\tlocal patterns = {}\n\tfor i = 1, #a do\n\t\tpatterns[#patterns\
    \ + 1] = a:sub(i,i)\n\tend\n\tfor i = 1, #b do\n\t\t-- Look for the pattern if\
    \ a substring is in the original string\n\t\t-- If there is a substring then the\
    \ pattern must be true\n\t\tif patterns[#patterns] ~= \"\" then\n\t\t\tfor _,\
    \ pattern in ipairs(patterns) do\n\t\t\t\tif pattern == b:sub(i,i) then\n\t\t\t\
    \t\treturn true\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend",
  "  local s = a:lower():find():reverse()\n  if s then return a:lower():find():reverse()\
    \ <= b:lower() end\n  return a:lower():upper():find(b:lower()) > -1\nend", " \
    \ local i = 0\n  local len = #a\n  while i < len do\n    if a[i] == b[len-i] then\n\
    \      i = len\n    elseif a[i] == '' then\n      return true\n    end\n    i\
    \ = i + 1\n  end\n  return false\nend", "  local w = string.find(a, '^%s*', 2)\n\
    \  local d = string.len(b) - string.len(a:sub(w + 1))\n  if w == -1 then return\
    \ false end\n  if string.find(a, '^%s*%s*$', w + 1, w + d) == 0 then return true\
    \ end\n  for i = 0, d do\n    if string.find(a, '^%s*$') ~= nil then return false\
    \ end\n    if string.find(a, '^%s*%s*$', w + i, w + d + i) == 0 then return true\
    \ end\n  end\n  return false\nend", "    -- Check if the second word is substring\
    \ of first word\n    -- We assume strings are in alphabetical order\n    if string.sub(a,\
    \ b, 1, #a) == string.sub(b, #a) then\n        return true\n    end", "    if\
    \ a == nil or b == nil then return false end\n    if a[1] == b[1] then\n     \
    \   if b[2] == '*' then\n            return true\n        elseif b[2] == '?' then\n\
    \            local first = a[1]\n            local rest = b[2]\n            local\
    \ n = #a\n            repeat\n                if rest == '*' then\n          \
    \          if first:find(rest) == nil then\n                        return false\n\
    \                    end\n                elseif rest == '?' then\n          \
    \          if first:find(rest) ~= nil then\n                        return false\n\
    \                    end\n                end\n            until #a == n + 1\n\
    \            return true\n        end\n    end\nend", "  local ok = true\n  for\
    \ _, substring in pairs(a) do\n    ok = ok and b == substring or not (substring\
    \ and b:sub(1, #substring) == substring)\n    if not ok then break end\n  end\n\
    \  return ok\nend", "  if b == '' then\n    return true\n  end\n  local b_len\
    \ = #b\n  local a_index = 0\n  local b_count = 0\n  while a_index < #a and b_count\
    \ < b_len do\n    if string.sub(a,a_index,a_index + 1) ~= string.sub(b,b_count,\
    \ b_count + 1) then\n      return false\n    end\n    a_index = a_index + 1\n\
    \    b_count = b_count + 1\n  end\n  return true\nend", "  -- for i = 1, #a do\n\
    \  --   if a:sub(1, i) == b:sub(1, i) return true end\n  --   if a:sub(i, #a)\
    \ == b:sub(i, #b) return true end\n  --   if a:sub(1, i) == b:sub(i, #b) return\
    \ true end\n  --   if a:sub(i, #a) == b:sub(1, i) return true end\n  --   if a:sub(1,\
    \ i) == b:sub(i, #a) return true end\n  --   if a:sub(i, #a) == b:sub(i, #b) return\
    \ true end\n  --   if a:sub(1, i) == b:sub(i, #a) return true end\n  --   if a:sub(i,\
    \ #a) == b:sub(1, i) return true end\n  --   if a:sub(1, i) == b:sub(i, #b) return\
    \ true end\n  --   if a:sub(i, #a) == b:sub(i, #b) return true end\n  --   if\
    \ a:sub(1, i) == b:sub(i, #a) return true end\n  --   if a:sub(i, #a) == b:sub(1,\
    \ i) return true end\n  --   if a:sub(i, #a) == b:sub(i, #b) return true end\n\
    \  --   if a:sub(1, i) == b:sub(i, #b) return true end\n  --   if a:sub(i, #a)\
    \ == b:sub(1, i) return true end\n  --   if a:sub(1, i) == b:sub(i, #b) return\
    \ true end\n  --   if a:sub(i, #a) == b:sub(1, i) return true end\n  --   if a:sub(1,\
    \ i) == b:sub(i, #b) return true end\n  --   if a:sub(i, #a) == b:sub(i, #b) return\
    \ true end\n  --   if a:sub(1, i) == b:sub(i, #a) return true end\n  --   if a:sub(i,\
    \ #a) == b:sub(1, i) return true end\n  --   if a:sub(1, i) == b:sub(i, #b) return\
    \ true end\n  --   if a:sub(i, #a) == b:sub(1, i) return true end\n  --   if a:sub(1,\
    \ i) == b:sub(i, #a) return true end\n  --   if a:sub(i, #a) == b:sub(1, i) return\
    \ true end\n  --   if a:sub(1, i) == b:sub(i, #a) return true end\n  --   if a:sub(i,\
    \ #a) == b:sub(1, i) return true end\n  --   if a:sub(i, #a) == b:sub(i, #b) return\
    \ true end\n  --   if a:sub(1, i) == b:sub(i, #b) return true end\n  --   if a:sub(i, ",
  "\tlocal s = string.sub(a,1,string.len(b));\n\tlocal t = '';\n\tfor i=1,string.len(b)\
    \ do\n\t\tt = b[i - 1] .. t;\n\tend\n\treturn string.find(s,t) == 1 or string.find(t,s)\
    \ == 1;\nend", "  return b:match(\"^(\" ..\n    \"(?>\" ..\n      a:gsub(\"(.)\"\
    ..\n        \"(\" ..\n          a..\n        .. (\"%1)\"..\n          a..\n  \
    \      .. (\"%2)\")\n      ..\n    \")\",\n    \"%%d+\") ..\n  \")$\")\nend",
  "  if a == b then return true end\n  local i, j = 1, #a - 1\n  while i <= j do\n\
    \    if a[i] == '' then\n      if b == '' then return true end\n      if i + 1\
    \ <= #a and b[i + #b + 1] == '' then return true end\n    elseif b[i] == '' then\n\
    \      if a[i + #a + 1] == '' then return true end\n    elseif a[i] == '' and\
    \ b[i] == '' then return true end\n    elseif a[i + #a + 1] == '' then return\
    \ false end\n    elseif b[i + #b + 1] == '' then return false end\n    elseif\
    \ a[i] == '' and b[i + #b + 1] == '' then return false end\n    else if a[i] ==\
    \ '' then\n      if #b >= i and #a > i and b[i + #b + 1] == a[i + #a + 1] then\
    \ return true end\n      if #b > i and #a > i and b[i + #b + 1] == a[i + #a +\
    \ 1] then return false end\n    elseif b[i] == '' then\n      if #a >= i and #b\
    \ > i and a[i + #a + 1] == b[i + #b + 1] then return true end\n      if #a > i\
    \ and #b > i and a[i + #a + 1] == b[i + #b + 1] then return false end\n    end\n\
    \    i, j = i + 1, j - 1\n  end\n  return false\nend", '  local ret', "  if b\
    \ == nil then\n    return false\n  elseif b == '' then\n    return true\n  elseif\
    \ a:match('.*%s.*' % b) then\n    return true\n  elseif a:match('.*%s.*' % (b..'$'))\
    \ then\n    return true\n  elseif a:match('.*%s.*' % ((b..'$')..b)) then\n   \
    \ return true\n  elseif a:match('.*%s.*' % (b..'^')) then\n    return true\n \
    \ elseif a:match('.*%s.*' % ((b..'^')..b)) then\n    return true\n  elseif a:match('.*%s.*'\
    \ % ((b..'^')..(b..'^'))) then\n    return true\n  elseif a:match('.*%s.*' % ((b..'^')..(b..'v')))\
    \ then\n    return true\n  elseif a:match('.*%s.*' % ((b..'^')..(b..'v'))) then\n\
    \    return true\n  elseif a:match('.*%s.*' % ((b..'v')..(b..'^'))) then\n   \
    \ return true\n  elseif a:match('.*%s.*' % ((b..'v')..(b..'v'))) then\n    return\
    \ true\n  elseif a:match('.*%s.*' % ((b..'v')..(b..'^'))) then\n    return true\n\
    \  elseif a:match('.*%s.*' % ((b..'v')..(b..'v'))) then\n    return true\n  else\n\
    \    return false\n  end\nend", "  return a:sub(1, #a) == b:sub(1, #b) or cycpattern_check(a\
    \ .. b, reverse b)\nend", "    if type(a) == 'string' then\n        a = a:gsub(\"\
    ^%W\", \"\") -- Remove all non-word characters\n        a = a:gsub(\"[%p%c]+\"\
    , \"\")\n        a = a:gsub(\"[%w%p%c]+\", \"\")\n        a = a:gsub(\"%u\", \"\
    \")\n    end\n    if type(b) == 'string' then\n        b = b:gsub(\"^%W\", \"\"\
    )\n        b = b:gsub(\"[%p%c]+\", \"\")\n        b = b:gsub(\"[%w%p%c]+\", \"\
    \")\n        b = b:gsub(\"%u\", \"\")\n    end\n    if string.find(a, b) then\n\
    \        return true\n    end\n    if string.find(b, a) then\n        return true\n\
    \    end\n    if string.find(a, a) then\n        return true\n    end\n    if\
    \ string.find(b, b) then\n        return true\n    end\n    return false\nend",
  "  if a == '' or b == '' then return false end\n  local i = 1\n  while i <= #b do\n\
    \    for j = 1, #a do\n      if a[j] == b[i] then return true end\n    end\n \
    \   i = i + 1\n  end\n  return false\nend", "    return string.find(a, string.sub(string.lower(b),\
    \ 1, string.len(b)), 1, true) ~= nil\nend", "   assert(b)\n   local first = {}\n\
    \   local second = {}\n   local length = 0\n   local pattern = {}\n   for i =\
    \ 1, #a do\n      table.insert(first, a[i])\n      if i == 1 then\n         table.insert(pattern,\
    \ a[i])\n      else\n         table.insert(pattern, a[i])\n         table.insert(pattern,\
    \ a[i-1]) -- append a rotation\n      end\n   end", "  local substring_check =\
    \ function(a, b)\n    for i = 1, #a do\n      if string.find(b, a) then\n    \
    \    return true\n      end\n    end\n    return false\n  end\n  return string.find(b,\
    \ a) or substring_check(a, b) or substring_check(b, a)\nend", "    local word1\
    \ = a:gsub(\"\\W\", \"\"):lower()\n    local word2 = b:gsub(\"\\W\", \"\"):lower()\n\
    \    if not word1 then\n        return false\n    elseif word2 then\n        --\
    \ If the second word has a length, check that all of its rotations exist in the\
    \ first word\n        if #word2 ~= 0 then\n            if word1 then\n       \
    \         local words = word1:gsub(\"%a\", \"\")\n                -- If the first\
    \ word exists, then check that all rotations exist in the second word\n      \
    \          for i = 2, #words do\n                    local pattern = words[i -\
    \ 2] .. words[i]\n                    if pattern ~= word2 then return false end\n\
    \                end\n            end\n        end\n    end\n    return true\n\
    end", "  local bLen = #b\n  if bLen == 0 then\n    return true\n  end\n  local\
    \ a = a:lower()\n  local bRotation = b:lower()\n  if #bRotation > 1 then\n   \
    \ local tmp = a\n    a = ''\n    for i = 1, #bRotation do\n      a = a .. bRotation[i]\n\
    \    end\n    a = a .. tmp\n  end\n  for i = 1, #a do\n    if a[i] ~= b[i] then\n\
    \      return false\n    end\n  end\n  return true\nend", "  if a ~= nil then\n\
    \    for i = 1, #a do\n      if b == a:sub(i, i) then return true end\n    end\n\
    \  end\n  return false\nend", "    -- if len == 0 then\n    --     return true\n\
    \    -- end\n    -- local s = string.find(a,b)\n    -- if s ~= nil then\n    --\
    \     return true\n    -- end\n    -- local t = string.find(b, a)\n    -- if t\
    \ ~= nil then\n    --     return true\n    -- end\n    -- return false\n    if\
    \ a==b then\n        return true\n    end\n    local i = string.find(a,b)\n  \
    \  if i ~= nil then\n        return true\n    end\n    local j = string.find(b,\
    \ a)\n    if j ~= nil then\n        return true\n    end\n    return false\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
