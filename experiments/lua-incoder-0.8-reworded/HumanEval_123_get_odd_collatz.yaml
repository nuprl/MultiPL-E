name: HumanEval_123_get_odd_collatz
language: lua
prompt: "-- Given a positive integer n, return a sorted table that has the odd numbers\
  \ in collatz sequence.\n-- The Collatz conjecture is a conjecture in mathematics\
  \ that concerns a sequence defined\n-- as follows: start with any positive integer\
  \ n. Then each term is obtained from the \n-- previous term as follows: if the previous\
  \ term is even, the next term is one half of \n-- the previous term. If the previous\
  \ term is odd, the next term is 3 times the previous\n-- term plus 1. The conjecture\
  \ is that no matter what value of n, the sequence will always reach 1.\n-- Note:\
  \ \n-- 1. Collatz(1) is [1].\n-- 2. returned table sorted in increasing order.\n\
  -- For example:\n-- get_odd_collatz(5) returns [1, 5] # The collatz sequence for\
  \ 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n-- >>> get_odd_collatz(5)\n\
  -- {1, 5}\nlocal function get_odd_collatz(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_odd_collatz\n\
  \    lu.assertEquals(candidate(14), {1, 5, 7, 11, 13, 17})\n    lu.assertEquals(candidate(5),\
  \ {1, 5})\n    lu.assertEquals(candidate(12), {1, 3, 5})\n    lu.assertEquals(candidate(1),\
  \ {1})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\t-- assert(n > 0, \"Collatz sequence can only be computed when n >\
    \ 0\")\n\tlocal odd_table = {}\n\todd_table[1] = 1\n\t\n\tfor i=2,n do\n\t\tif\
    \ n % 2 == 0 then\n\t\t\todd_table[i / 2] = odd_table[i / 2] * 3 + 1 \n\t\telse\n\
    \t\t\todd_table[i / 2] = odd_table[i / 2] * 2 \n\t\tend\n\tend\n\treturn odd_table\n\
    end", "  -- Base case\n  if n == 1 then\n    return {1}\n  end\n  \n  -- Get the\
    \ even numbers from the previous terms\n  local odd_list = { }\n  for i = 1, n\
    \ do\n    odd_table.insert(odd_list, i)\n  end\n  \n  -- Calculate the next term\
    \ of the sequence\n  local next_list = {}\n  for _, v in pairs(odd_list) do\n\
    \    if odd_table[v] % 2 == 0 then\n      odd_table[v] = odd_table[v] / 2\n  \
    \    next_table.insert(next_list, odd_table[v])\n    end\n  end\n  \n  -- return\
    \ the table\n  return next_list\nend", "    local collatz = {}\n    local tmp\
    \ = {}\n    if n <= 1 then\n        return {n}\n    else\n        local a = 1\n\
    \        while a < n do\n            if n % 2 == 0 then\n                tmp[a]\
    \ = n\n            else\n                tmp[a] = n / 2 \n            end\n  \
    \          a = a + 1\n        end\n        for i = 1, n do\n            if i %\
    \ 2 == 1 then\n                collatz[i] = tmp[i]\n            else\n       \
    \         collatz[i] = tmp[i] + 1 \n            end\n        end\n    end\n  \
    \  return collatz\nend", "  -- base case\n  if n==1 then\n    return {1}\n  end",
  "\tlocal odd_dict = {}\n\tlocal curr = n\n\tlocal odd_list = []\n\tlocal odd = 0\n\
    \tlocal last_odd = 0", "   assert(n >= 0, \"n must be positive\")\n   local tbl\
    \ = {}\n   if n == 1 then\n      tbl[1] = n\n   else\n      local prev\n     \
    \ for i=1, n do\n         if prev ~= nil then\n            if prev %2 == 0 then\n\
    \               tbl[i+1] = prev + prev\n            else\n               tbl[i+1]\
    \ = prev + prev + 1\n            end\n         else\n            tbl[i+1] = i\n\
    \         end\n         prev = i\n      end\n   end\n   return tbl\nend", "  \
    \  local odd_nums = {}\n    local prev = 1\n    for i=1,n do \n        local curr\
    \ = prev\n        if prev ==1 then prev=1 else\n            if prev%2==0 then\n\
    \                curr = prev\n            else\n                curr = prev/2\n\
    \            end\n        end\n        odd_nums[#odd_nums+1] = curr\n        prev\
    \ = curr \n    end\n    table.sort(odd_nums, function(a,b) return a<b end)\n \
    \   return odd_nums\nend", "  assert(n > 1, 'n must be > 1')\n  local tbl = {}\n\
    \  local n = 1\n  while n ~= 1 do\n    local next_n = n / 2\n    tbl[#tbl + 1]\
    \ = next_n\n    n = next_n\n  end\n  return tbl\nend", "  assert(type(n) == \"\
    number\" , \"Invalid type of 'n'\")\n  local table = {n}\n  for i=2,n,1 do\n \
    \   table[i] = table[i-1] ~= 0 and (table[i-1] % 2 == 0 and table[i-1] or 3*table[i-1]\
    \ + 1) or table[i-1]\n  end\n  return table\nend", "\t-- base case: n = 1\n\t\
    if n == 1 then\n\t\treturn {1}\n\tend", "  assert(n >= 1, 'The n must be greater\
    \ than 0.')\n  local odd_table = {}\n  local cur_val = 1\n  for i = 1, n do\n\
    \    if i % 2 ~= 0 then\n      odd_table[#odd_table + 1] = get_odd_collatz(cur_val\
    \ * 2 % n)\n    else\n      odd_table[#odd_table + 1] = cur_val\n    end\n   \
    \ cur_val = odd_table[#odd_table]\n  end\n  return odd_table\nend", "   if n ==\
    \ 1 then\n      return {1}\n   elseif n % 2 == 0 then\n      return table.insert(get_odd_collatz(n\
    \ / 2), n / 2)\n   else\n      return table.insert(get_odd_collatz((3 * n) + 1),\
    \ ((3 * n) + 1)/2)\n   end\nend", "    local table = {}\n    local last_odd_term\
    \ = 2 * n\n    local last_odd_val = n\n    while true do\n        -- if the previous\
    \ number is odd, we add 1 to the current number\n        if last_odd_val & 1 ~=\
    \ 0 then\n            last_odd_val = last_odd_val + 1\n        else\n        \
    \    -- otherwise, we add half of the previous number\n            last_odd_val\
    \ = last_odd_val >> 1\n        end\n        table.insert(table, last_odd_val)\n\
    \        -- if the current number is odd, we add 1 to the previous number\n  \
    \      if n & 1 ~= 0 then\n            n = n + 1 -- this is an odd number\n  \
    \      else\n            n = n >> 1 -- this is an even number\n        end\n \
    \   end\n    return table\nend", "\tlocal table = {}\n\tlocal next = 1\n\tlocal\
    \ current", "   -- Create a table with n rows. Initialize all rows to 1 initially.\n\
    \   local t = {[1]=1} -- For simplicity, initialize all rows to 1.\n   \n   --\
    \ Update row 1 until the previous term is odd.\n   for i = 1, n do \n      if\
    \ t[i] % 2 == 0 then \n         t[i] = (t[i] / 2)\n      else\n         t[i] =\
    \ (t[i] * 3) + (t[i] / 2)\n      end\n   end\n   -- Return the table.\n   return\
    \ t\nend\n</cell>\n<text>\nTask 4: Count odd numbers less than a threshold\nImplement\
    \ function count_odd_below_threshold that takes an integer n and an integer threshold\
    \ as arguments and returns the number of odd numbers less than the threshold.\
    \ The number should be less than or equal to 10^6.\nFor example, count_odd_below_threshold(5,\
    \ 5) returns 3.", "\tlocal odd_collatz = {}\n\tlocal next_term = (n % 2 == 0 and\
    \ n / 2 or n * 3) + 1\n\tfor i = 0, n do\n\t\tif i ~= 0 then\n\t\t\todd_collatz[#odd_collatz\
    \ + 1] = next_term\n\t\tend\n\t\tnext_term = next_term / 2\n\tend\n\treturn odd_collatz\n\
    end", "  -- Base case\n  if n <= 1 then\n    local result = {n}\n    -- If n >\
    \ 1, the sequence will always reach 1.\n    -- Collatz(n) = { 1 }\n    if n ~=\
    \ 1 then\n      table.insert(result, 1)\n    end\n    return result\n  end", "\t\
    -- Base Cases\n\tif n == 1 then\n\t\treturn {n}\n\tend", "  local odd_table =\
    \ {}\n  local nval = n\n  while nval ~= 1 do\n    local n_val = nval\n    nval\
    \ = n % 2 == 0 and n/2 or 3*n+1\n    odd_table[nval] = n_val\n  end\n  return\
    \ odd_table\nend", "    if n == 1 then\n        return {[1]}\n    end\n    local\
    \ odd_nums = {}\n    for i = 1, n do\n        if i % 2 == 0 then\n           \
    \ odd_nums[i] = odd_nums[i - 1]\n        else\n            odd_nums[i] = odd_nums[i\
    \ - 1] * 3 + 1 -- Collatz's rule: 3x + 1\n        end\n    end\n    return odd_nums\n\
    end", "\tlocal odd_table = {}\n\tlocal odd_table_index = 1\n\twhile n ~= 1 do\n\
    \t\todd_table[odd_table_index] = n\n\t\tif math.mod(n,2) == 0 then\n\t\t\todd_table_index\
    \ = odd_table_index + 1\n\t\telseif math.mod(n,2) == 1 then\n\t\t\todd_table_index\
    \ = 1\n\t\tend\n\t\tn = n/2\n\tend\n\treturn odd_table\nend", "\tlocal odd = {[1]}\n\
    \tlocal next_odd\n\tlocal k\n\tlocal i", "\tlocal odd_table = {}\n\todd_table.__index\
    \ = function(t, n)\n\t\tif n == 1 then\n\t\t\treturn 1\n\t\telse\n\t\t\tif n %\
    \ 2 == 0 then\n\t\t\t\todd_table.nn = odd_table.nn\n\t\t\t\todd_table.nn[#odd_table.nn+1]\
    \ = 2*(n % 2)\n\t\t\t\todd_table.nn = odd_table.nn\n\t\t\telse\n\t\t\t\todd_table.nn\
    \ = odd_table.nn\n\t\t\t\todd_table.nn[#odd_table.nn+1] = 3*(n % 2) + 1\n\t\t\t\
    \todd_table.nn = odd_table.nn\n\t\t\tend\n\t\t\treturn odd_table\n\t\tend\n\t\
    end\n\treturn odd_table\nend", "    local odd_table = {}\n    local odd_table_length\
    \ = #odd_table", "    local tbl = {}\n    for i = 1, n do\n        if n % 2 ==\
    \ 1 then\n            table.insert(tbl, n / 2)\n            n = n / 2 \n     \
    \   else\n            n = n * 3 + 1 \n        end\n    end\n    return tbl\nend\n\
    </cell>\n<code language=julia-1.5>\n# [A] --- Test get_odd_collatz", "\tlocal\
    \ tbl = {}\n\twhile n > 1 do\n\t\ttbl[n] = n\n\t\tn = get_collatz(n)\n\tend\n\t\
    tbl[1] = 1\n\treturn tbl\nend", "\tif n <= 1 then \n\t\treturn {n}\n\tend\n\t\
    if n % 2 == 0 then\n\t\treturn get_odd_collatz(n / 2) + {n}\n\tend\n\treturn get_odd_collatz(3\
    \ * n + 1) + {n}\nend", "  local odd_numbers = {}\n  odd_numbers[1] = n\n  for\
    \ i = 2, n do\n    if n % 2 == 0 then\n      odd_numbers[#odd_numbers + 1] = n\
    \ / 2\n      n = n / 2\n    else\n      n = n * 3 + 1 \n    end\n  end\n  table.sort(odd_numbers)\n\
    \  return odd_numbers\nend\n ", "\t-- Base case\n\tif n == 1 then\n\t\treturn\
    \ {n}\n\tend\n\tlocal next_num\n\tlocal odd_numbers = {}\n\t\n\t-- For each previous\
    \ number, get the next number.\n\tfor i = 1, n do\n\t\t-- Check if this number\
    \ is even\n\t\tif n % 2 == 0 then\n\t\t\t-- Add this number\n\t\t\todd_numbers[i]\
    \ = 1\n\t\telse\n\t\t\t-- Add this number\n\t\t\todd_numbers[i] = n * 2 + 1\n\t\
    \tend\n\tend\n\t\n\t-- Recurse to get the rest of the numbers\n\tfor i = 2, n\
    \ do\n\t\tnext_num = get_odd_collatz(odd_numbers[i])\n\t\tfor _, v in pairs(next_num)\
    \ do\n\t\t\todd_numbers[i] = odd_numbers[i] + v\n\t\tend\n\tend\n\t\n\t-- Return\
    \ the odd numbers\n\treturn odd_numbers\nend", "  local table = {}\n  local n\
    \ = 1\n  local table_size = 1\n  while n ~= 1 do\n    table.insert(table, n)\n\
    \    table.insert(table_size, ((n / 2) % 2 == 0) ? 1 : 3)\n    local tmp_n = ((n\
    \ % 2) == 0) ? n / 2 : 3 * n + 1 \n    n = tmp_n\n  end\n  return table\nend",
  "\tlocal collatz = {}\n\tlocal current_collatz = {}\n\tlocal current_index = 0\n\
    \twhile n >= 1 do\n\t\tif n % 2 == 0 then\n\t\t\tcurrent_collatz[current_index]\
    \ = n\n\t\t\tcurrent_index = current_index + 1\n\t\telse\n\t\t\tcurrent_index\
    \ = 0\n\t\t\tcurrent_collatz[current_index] = n / 2\n\t\t\tcurrent_index = current_index\
    \ + 1\n\t\tend\n\t\tn = current_collatz[current_index] - 1\n\tend\n\t-- for i\
    \ = 1, n do\n\t--     print(i, collatz[i])\n\t-- end\n\treturn collatz\nend",
  "  local odd_collatz = { [1]=1 }\n  for i=1,n,2 do\n    local odd_number = odd_collatz[i-1]\n\
    \    if odd_number % 2 == 0 then\n      odd_collatz[i] = odd_number / 2\n    else\n\
    \      odd_collatz[i] = odd_number * 3 + 1 \n    end\n  end\n  return odd_collatz\n\
    end", "  -- base case\n  if n < 1 then return {n} end\n  \n  -- recursive case\n\
    \  local odds = { n }\n  local next = 1\n  \n  while next < n do\n    -- if previous\
    \ number is even\n    if next % 2 == 0 then\n      -- next number is next number\
    \ divided by 2\n      next = next / 2\n    else\n      -- next number is next\
    \ number multiplied by 3\n      next = next * 3 + 1\n    end", "   -- Base case\n\
    \   if n < 2 then return {n} end", "  local odd = {}\n  local i = 2\n  while i\
    \ <= n do\n    odd.add(i)\n    if i ~= n and i % 2 == 0 then\n      i = i / 2\n\
    \    else\n      i = 3 * i + 1\n    end\n  end\n  return odd\nend", "  -- Base\
    \ case: n must be 1 or less.\n  if n <= 1 then return { 1 } end", "\tlocal odd_table\
    \ = {}\n\tlocal i, v = 1, 1\n\twhile true do\n\t\tif n % 2 == 1 then\n\t\t\todd_table[i]\
    \ = v\n\t\t\tv = v + 1 \n\t\telse\n\t\t\todd_table[i] = v\n\t\t\tv = v * 3 + 1\n\
    \t\tend\n\t\ti = i + 1\n\t\tif i > n then return odd_table end\n\tend\nend", " \
    \ local odd_dict = {}\n  local index = 1\n  while n > 1 do\n    odd_dict[index]\
    \ = n\n    index = index * 2 if n % 2 == 0 then index - 1 else index + 1\n   \
    \ n = n / 2\n  end\n  table.sort(odd_dict)\n  return odd_dict\nend", "    local\
    \ odd_collatz_table = {}\n    local previous_term = 1", "  local odd_collatz =\
    \ {}\n  odd_collatz[1] = 1\n  local i = 2\n  while i <= n do\n    local n_pre\
    \ = odd_collatz[i]\n    odd_collatz[i] = n_pre * 2 + 1\n    i = n_pre\n  end\n\
    \  return odd_collatz\nend", "    if n == 1 then\n        -- The conjecture says\
    \ that we must always have two terms, so just return the list with one number.\n\
    \        return {n}\n    end\n    local odd_list, odd_index = 1, 1\n    local\
    \ function conjecture_index(num)\n        -- Return the current index, or 1, if\
    \ the number is even.\n        return odd_index % 2 == 0 and odd_index or 1\n\
    \    end\n    local function conjecture_term(term)\n        -- Return the next\
    \ term from previous or 1, if even number.\n        return term % 2 == 0 and term\
    \ or 1\n    end\n    local function conjecture_next(odd_num, odd_index)\n    \
    \    -- Return the next odd number from the odd_num.\n        local num = odd_num\
    \ * 3 + 1\n        -- Reset the index to 1, if the number was even.\n        return\
    \ odd_index % 2 == 1 and num or 1\n    end\n    local odd_list, odd_index = 1\n\
    \    for i=2,n do\n        odd_index = odd_index * 2 + 1\n        odd_list = odd_list\
    \ and conjecture_next(odd_list, odd_index) or 1\n    end\n    return odd_list\n\
    end", "  assert(n>0, \"'n' should be a positive integer.\")\n  local odd = {}\n\
    \  local results = {}\n  local i = 1\n  while i <= n do\n    if i%2 == 1 then\n\
    \      table.insert(odd,i)\n    else\n      local next = (i-1) / 2+1\n      table.insert(results,next)\n\
    \    end\n    i = next\n  end\n  table.sort(results)\n  return results\nend",
  "\tlocal odd_list = {}\n\tlocal i = n\n\twhile i ~= 1 do\n\t\tif i %% 2 == 1 then\n\
    \t\t\todd_list.push(i)\n\t\telse\n\t\t\ti = i / 2\n\t\t\todd_list.push(i)\n\t\t\
    end\n\tend\n\treturn odd_list\nend", "  local odd_table = {}\n  if n == 1 then\n\
    \    return {1}\n  elseif n == 2 then\n    odd_table[1] = 1\n    return {1}\n\
    \  elseif n%3 == 0 then\n    odd_table[1] = n/3\n    local i = 2\n    while i\
    \ <= n do\n      odd_table[i] = (3*odd_table[i-1]) + 1\n      i = i + 2\n    end\n\
    \  else\n    odd_table[1] = n\n    local i = 3\n    while i <= n do\n      odd_table[i]\
    \ = (3*odd_table[i-2]) + 1\n      i = i + 2\n    end\n  end\n  return odd_table\n\
    end", "  local collatz = {}\n  local i = 1\n  while i < n do\n    if i % 2 ==\
    \ 0 then\n      collatz[i] = i\n      i = i / 2\n      while i < n and i % 2 ==\
    \ 0 do\n        i = i * 3 + 1 -- Odd numbers are computed using formula 3n + 1\
    \ where n is odd and 3 is for multiplication.\n        collatz[i] = i\n      end\n\
    \    end\n    i = i + 1\n  end\n  return collatz\nend", "   assert(n, \"input\
    \ n cannot be nil\")\n   if n == 1 then\n      return {1}\n   end\n   local odd_count\
    \ = {}\n   local odd_number = {}\n   odd_count = { [1] = 1 }\n   odd_number =\
    \ { [1] = n }\n   for i = 2, n do\n      if odd_count[odd_number[#odd_number]]\
    \ < 2 then\n         odd_count[odd_number[#odd_number]] = odd_count[odd_number[#odd_number]]\
    \ \n      else\n         odd_count[odd_number[#odd_number]] = odd_count[odd_number[#odd_number]]\
    \ \n         odd_number[#odd_number] = odd_number[#odd_number] - 1\n      end\n\
    \   end\n   return odd_number\nend", "    local table = setmetatable({[1] = 1},\
    \ {__index = function(t, n)\n        if n <= 1 then \n            return 1\n \
    \       elseif n % 2 == 0 then\n            local temp = n / 2\n            table.insert(t,\
    \ temp)\n            if temp % 2 == 0 then\n                return get_odd_collatz(temp\
    \ + 1) + temp\n            else\n                return get_odd_collatz(temp +\
    \ 1)\n            end\n        elseif n % 2 == 1 then\n            local temp\
    \ = n / 2\n            table.insert(t, temp)\n            if temp % 2 == 1 then\n\
    \                return get_odd_collatz(temp + 1) + 3 * temp + 1\n           \
    \ else\n                return get_odd_collatz(temp + 1)\n            end\n  \
    \      else\n            error(\"n must be positive integer\")\n        end\n\
    \    end})\n    return table\nend", "  local tt = {[1]}\n  while n ~= 1 do\n \
    \   if n % 2 == 1 then\n      n = n / 2\n      table.insert(tt, n)\n    else\n\
    \      n = ((3 * n) + 1)\n      table.insert(tt, n)\n    end\n  end\n  table.sort(tt)\n\
    \  return tt\nend", "    local odd_list = []\n    for i=1,n do\n        if n %\
    \ 2 == 0 then\n            odd_list[i] = 1\n        else\n            odd_list[i]\
    \ = odd_list[i-1] div 2 + 1\n        end\n    end\n    return odd_list\nend",
  "  -- assert type(n) == int and n > 0\n  -- assert not n or n % 2 == 0 or n % 3\
    \ == 0\n  -- assert not n or n % 2 == 0 or n % 3 == 0", "  if n==1 then return\
    \ {1}\n  else\n    local odds={}\n    for i=1,n do\n      if n%2==0 then \n  \
    \      odds[i]:=n/2\n        n=n/2\n      else\n        odds[i]:=n*3+1\n     \
    \   n=n/2\n      end\n    end\n    return odds\n  end\nend", "\tassert(type(n\
    \ >= 1) and type(n) <= MAX_INT, string.format(\"Parameter n must be integer and\
    \ greater than or equal to 1. Current value is %t\", n))\n\tlocal odd_table =\
    \ {}\n\todd_table.n = 1\n\twhile odd_table.n <= n do\n\t\todd_table.next_term\
    \ = odd_table.n % 2 == 0 and odd_table.n / 2 or odd_table.n * 3 + 1\n\t\todd_table.n\
    \ = odd_table.next_term\n\t\todd_table.next_term = odd_table.next_term / 2\n\t\
    end\n\treturn odd_table\nend", "  if n==1 then return {n} end\n  local table={}\n\
    \  table.insert(table,get_odd_collatz(n-1))\n  table.insert(table,n-1)\n  table.insert(table,get_odd_collatz(3*n+1))\n\
    \  return table\nend", "    -- Base case\n    if n == 1 then\n        return {n}\n\
    \    end\n    -- Recursive case\n    local odd_collatz = setmetatable({}, {__index\
    \ = function(tbl, key)\n        -- If n is even, get next even value\n       \
    \ if n % 2 == 0 then\n            local next_even = n / 2\n            -- If n\
    \ is odd, get next odd value\n        else\n            local next_odd = 2 * n\
    \ + 1 \n        end\n        -- Update n with next value\n        n = next_odd\n\
    \        -- Recursively call get_odd_collatz() on the next odd value\n       \
    \ return tbl[next_odd] or {n} + get_odd_collatz(next_odd)\n    end})\n    return\
    \ odd_collatz\nend", "  -- The collatz sequence for n is [n/2, n/4^2, n/16^2,\
    \ ..., 1], where n is an odd integer.\n  -- For n > 1, the previous term is n/2^k,\
    \ where k is the number of times we've seen n divide evenly.\n  local odd_table\
    \ = {}\n  for k = 1, n do\n    if n % 2 == 0 then\n      odd_table[k + 1] = n\
    \ / 2\n      n = n / 2\n    else\n      odd_table[k + 1] = n * 3 + 1\n      n\
    \ = n / 2 -- The last term should be n / 2^(k-1), where k is the number of times\
    \ we've seen n divide evenly.\n    end\n  end\n  table.sort(odd_table) -- Sort\
    \ the table in increasing order.\n  return odd_table\nend", "   assert(n > 0,\
    \ 'n must be positive')\n   if n == 1 then\n      return {1}\n   end\n   local\
    \ table = {n}\n   local current_n = 1\n   repeat\n      table.insert(table, current_n)\n\
    \      current_n = current_n * 2 if current_n % 2 == 0 then\n      current_n =\
    \ current_n / 2 end\n   until current_n == 1\n   table.insert(table, 1)\n   return\
    \ table\nend", "\tlocal odd_table = {}\n\todd_table[1] = 1\n\tlocal next_term\
    \ = 2\n\tlocal last_term = 1\n\tfor i = 2, n do\n\t\tif last_term % 2 == 0 then\n\
    \t\t\todd_table[i] = last_term * next_term + 1\n\t\telse\n\t\t\todd_table[i] =\
    \ 3 * last_term + next_term + 1\n\t\tend\n\t\tlast_term = next_term\n\t\tnext_term\
    \ = next_term / 2\n\tend\n\treturn odd_table\nend", "  if n < 1 then return {}\
    \ end\n  local t = {}\n  local odd = 1\n  for i = 2, n do\n    local s = t[odd]\n\
    \    if s then t[odd] = i * s + 1 end\n    if s ~= 1 then\n      odd = s - 1 --\
    \ This trick works because odd is always a multiple of 2.\n    end\n  end\n  return\
    \ t\nend", "  if n <= 1 then\n    return {1}\n  end\n  local odd_collatz = {}\n\
    \  odd_collatz[1] = 1\n  local i = 1\n  while i * i <= n do\n    if n % i == 0\
    \ then\n      odd_collatz[i] = n/i\n      i = i + 1\n      odd_collatz[i] = odd_collatz[i]\
    \ * 3 + (n % i)\n    else\n      odd_collatz[i] = n / i\n      i = i + 1\n   \
    \ end\n  end\n  return odd_collatz\nend", "    local odds = []\n    local prev_odds\
    \ = nil\n    \n    -- If the input is positive, then just return the odds\n  \
    \  if n >= 1 then\n        odds = [1]\n        return odds\n    end\n    \n  \
    \  -- If the input is zero, then return a empty table \n    if n == 0 then\n \
    \       return {}\n    end\n    \n    -- If the input is negative, then raise\
    \ an error and return the odds\n    if n < 0 then\n        error()\n    end",
  "  local odd_tbl = setmetatable({}, { __index = table })\n  odd_tbl[1] = n\n  for\
    \ i = 2, n do\n    odd_tbl[i] = odd_tbl[i - 1]\n    if odd_tbl[i % 2] == 0 then\n\
    \      odd_tbl[i] = odd_tbl[i / 2] * 2 + 1\n    end\n  end\n  return odd_tbl\n\
    end", "    local odd_table = {}\n    local x = 1\n    local count = 0\n    local\
    \ odd = 0\n    while x >= n do\n        odd = x\n        x = x ^ 2\n        count\
    \ = count + 1\n    end\n    for i = 1, n do\n        if count == i then\n    \
    \        odd_table.insert(odd)\n            count = 0\n        else\n        \
    \    count = count + 1\n        end\n    end\n    return odd_table\nend", "  \
    \  local odd_table = {}\n    local previous_n = nil\n    local odd_count = 0",
  "   local odd_table = {}\n   if n <= 1 then\n      return odd_table\n   else\n \
    \     odd_table.add(n)\n      local m = n / 2\n      while m > 1 do\n        \
    \ if m % 2 == 0 then\n            odd_table.add(m * 2)\n         else\n      \
    \      odd_table.add(m * 2 + 1)\n         end\n         m = m / 2\n      end\n\
    \      return odd_table\n   end\nend", "    local odd_list = {}\n    local odd_list\
    \ = { [1]=1 }\n    local odds = 0\n    local next_odds = odd_list[1]\n    while\
    \ n ~= 1 do\n        if n % 2 == 1 then\n            odds = odds + 1\n       \
    \     odd_list[odds] = n\n        else\n            odds = odds + 1\n        \
    \    next_odds = next_odds * 3 + odd_list[odds]\n        end\n        n = next_odds\n\
    \    end\n    return odd_list\nend", "    local table = {}\n    if n == 1 then\n\
    \        table[1] = 1\n        return table\n    end\n    local i = 2\n    while\
    \ i < n do\n        if n % 2 == 1 then\n            table.insert(table, n / 2)\n\
    \            n = n / 2\n        else\n            n = 3 * n + 1;\n        end\n\
    \        table.insert(table, i)\n    end\n    return table\nend", "\tlocal odd_nums\
    \ = {}\n\todd_nums[1] = 1\n\tfor i = 2, n do\n\t\tif n % 2 == 0 then\n\t\t\todd_nums[i]\
    \ = odd_nums[n / 2] + 1\n\t\telse\n\t\t\todd_nums[i] = odd_nums[n / 2] * 3 + 1\n\
    \t\tend\n\tend\n\treturn odd_nums\nend", "\tif n < 2 then \n\t\treturn {n} \n\t\
    end\n\tlocal odd_table = {n}\n\tlocal collatz_table = get_odd_collatz(n-1) --\
    \ n times of n until n reaches 1\n\tfor _, v in pairs(collatz_table) do\n\t\t\
    odd_table[v] = odd_table[v] + v\n\tend\n\treturn odd_table\nend", "\tassert(n\
    \ >= 0, \"n should be non-negative integer\")\n\tlocal odd_table = {}\n\tlocal\
    \ next_n = 1\n\tfor i = 1, n do\n\t\tlocal odd_n = next_n\n\t\tnext_n = next_n\
    \ / 2\n\t\tif next_n % 2 == 0 then\n\t\t\todd_table.insert(odd_n)\n\t\tend\n\t\
    end\n\treturn odd_table\nend", "  -- Base case\n  if n==1 then\n    return {1}\n\
    \  end \n  -- If the previous term is even, then the next term is 0.5 times the\
    \ previous term\n  local odd_term = math.floor(n/2)\n  if n%2==0 then\n    odd_term\
    \ = odd_term + 1\n  end\n  -- Return the next odd term in the sequence\n  return\
    \ {odd_term}\nend", "  local odd_table = {}\n  local next_collatz = {}\n  for\
    \ i = 1, n do\n    local odd_number = (n % 2) and 1 or 3 * (n-1) + 1\n    table.insert(odd_table,\
    \ odd_number)\n    next_collatz[i] = odd_number\n    odd_number = odd_number *\
    \ 3 + 1\n    if odd_number > 1 then -- even number\n      odd_number = odd_number\
    \ / 2\n      table.insert(odd_table, odd_number)\n      table.insert(next_collatz,\
    \ odd_number * 2+1)\n      odd_number = odd_number * 3 + 1\n    end\n  end\n \
    \ table.sort(next_collatz)\n  return odd_table\nend", "    -- base case\n    if\
    \ n == 1 or n == 0 then return {1} end\n    -- recursive case\n    local odd_collatz_seq\
    \ = get_odd_collatz(n / 2)\n    table.insert(odd_collatz_seq, n % 2)\n    table.insert(odd_collatz_seq,\
    \ 3 * odd_collatz_seq[#odd_collatz_seq] + 1)\n    return odd_collatz_seq\nend",
  "\tassert(type(num)==\"number\", \"Expected a number\")\n\tif n==1 then\n\t\treturn\
    \ {1}\n\tend\n\tlocal odd_seq={}\n\tfor i =1,n do \n\t\tlocal prev=n\n\t\twhile\
    \ prev ~= 1 do\n\t\t\tassert(prev % 2==0, \"Expected a positive even number\"\
    )\n\t\t\tprev=prev/2\n\t\tend\n\t\todd_seq[i] = prev\n\tend\n\treturn odd_seq\n\
    end", "\t-- Base case - if n is 1, then return [1].\n\tif n == 1 then \n\t\treturn\
    \ {n}\n\tend", "    if n == 1 then return {n}\n    elseif n % 2 == 0 then\n  \
    \      return get_odd_collatz(n / 2) .. {n}\n    else\n        return get_odd_collatz((3\
    \ * n) + 1)\n    end\nend", "\tlocal t = {}\n\tlocal prev = 0", "    local table\
    \ = {}\n    for i = 1, n do table.insert(i, 1) end\n    local odd_nums = {}\n\
    \    local odd_count = 1\n    local i = 1\n    local j = 1\n    while i < n do\n\
    \        if table[i] % 2 == 0 then\n            if j == 1 then\n             \
    \   table.insert(odd_nums, table[i])\n                table.insert(odd_count,\
    \ i)\n            else\n                odd_count = odd_count + 1\n          \
    \      table[j] = table[i]\n                j = j + 1\n            end\n     \
    \   else\n            if odd_count == 2 then\n                odd_nums = odd_nums\
    \ + odd_nums[1]\n                odd_count = 1\n            end\n            i\
    \ = i + 1\n        end\n    end\n    return odd_nums\nend", "  local odd_list\
    \ = []\n  local odd_n = 1\n  while odd_n <= n do\n    if n <= 1 then\n      odd_list\
    \ = odd_list\n    else\n      if n % 2 == 0 then\n        n = n / 2\n      else\n\
    \        n = n * 3 + 1\n      end\n      odd_list = odd_list + {odd_n}\n    end\n\
    \    odd_n = odd_n + 1\n  end\n  table.sort(odd_list, function(a, b) return a<b\
    \ end)\n  return odd_list\nend", "    if n==1 then return {1}\n    elseif n%2==0\
    \ then return {n} -- even number.\n    else\n        local odd_collatz={n}\n \
    \       while n%2==0 do\n            odd_collatz={n}\n            for i=1,n-1\
    \ do\n                odd_collatz={odd_collatz[1]+odd_collatz[1]}\n          \
    \  end\n            n=odd_collatz[1]\n        end\n    end\nend", '  assert(n
    > 0, "The input should be positive.")', "\tlocal odd_table = {}\n\tlocal i = 1\n\
    \twhile i <= n do\n\t\tlocal odd_number = i\n\t\ti = i * 2 if (not ((i % 2) ==\
    \ 0)) else (i + 1) -- If previous number is even, next number is half of it. If\
    \ previous number is odd, next number is 3*(previous number) + 1.\n\t\todd_table[i]\
    \ = odd_number\n\tend\n\ttable.sort(odd_table)\n\treturn odd_table\nend", "  --\
    \ base case: collatz(1) = [1], base case(n) = 1.\n  if n == 1 then\n    local\
    \ tbl = {}\n    tbl[1] = 1\n    return tbl\n  else\n    -- get previous term from\
    \ current term\n    local tbl = {}\n    for i = 2, n do\n      local cur = i\n\
    \      while cur do\n        local res = cur % 2\n        if res == 0 then\n \
    \         cur = (cur - 1) >> 1\n        else\n          cur = (3 * cur + 1) >>\
    \ 1\n        end\n      end\n      table.insert(tbl, cur)\n    end\n    -- return\
    \ result table sorted\n    table.sort(tbl)\n    return tbl\n  end\nend", "   \
    \ local odd_list = []\n    local odd_table = {}\n    odd_table[n] = 1\n    local\
    \ last_odd = 0", "  local table = {}\n  for i = 1, n do\n    local count = 0\n\
    \    while n % 2 == 0 do\n      n = n / 2\n      count = count + 1\n    end\n\
    \    table.insert(table, n)\n    table.insert(table, count * 2)\n    table.insert(table,\
    \ count * 3)\n  end\n  table.sort(table)\n  return table\nend", "  -- Base cases\n\
    \  if n == 1 then return {1}\n  if n == 2 then return {1, 2}", "    local odd_list\
    \ = []\n    while n >= 2 do\n        local tmp, n = n, n / 2\n        if n % 2\
    \ == 0 then\n            odd_list.append(tmp)\n        end\n    end\n    table.sort(odd_list)\n\
    \    return odd_list\nend", "   assert(n >= 0, 'The argument must be a non-negative\
    \ integer.')\n   local table = {}\n   if n == 1 then\n      table[1] = 1\n   \
    \   return table\n   end\n   local t = n\n   while not t % 2 do\n      t = t /\
    \ 2\n   end\n   table.insert(table, t) -- Insert 1\n   local next_term = t\n \
    \  while not next_term % 3 do\n      next_term = next_term / 2 + 1\n   end\n \
    \  table.insert(table, next_term) -- Insert next term\n   return table\nend",
  "  local seq = {}\n  seq[1] = n\n  local i = 1\n  while i <= n do\n    local next\
    \ = seq[i]\n    if next % 2 == 0 then\n      seq[i] = next / 2\n      i = i +\
    \ 1\n    else\n      seq[i] = next * 3 + 1\n      i = i + 1\n    end\n  end\n\
    \  return seq2tbl(seq)\nend\n</cell>\n<cell>", "  local odd_collatz_table = {}\n\
    \  odd_collatz_table[1] = n\n  local next_term = n\n  for i = 2, n do\n    if\
    \ n % 2 == 0 then\n      odd_collatz_table[i] = n / 2\n    else\n      odd_collatz_table[i]\
    \ = 3 * odd_collatz_table[i -1] + 1 -- odd numbers obtained by Collatz conjecture\n\
    \    end\n    next_term = odd_collatz_table[i]\n  end\n  return odd_collatz_table\n\
    end", "\t-- Base Case:\n\t-- If n is 1, return [1], or simply return it.\n\tif\
    \ n == 1 then\n\t\treturn {1}\n\telse\n\t\t-- The odd numbers below n (excluding\
    \ n = 1) are the odd numbers\n\t\t-- of collatz sequence starting from n which\
    \ is divided by 2.\n\t\treturn {n % 2, get_odd_collatz(n / 2)}\n\tend\nend", " \
    \ -- initialize collatz table\n  local table = {}\n  -- Initialize empty current\
    \ list\n  table.current_list = []\n  -- Set first value to a 2\n  table.current_list[1]\
    \ = 2\n  -- Loop while list is not empty and add value to next value\n  while\
    \ table.current_list ~= nil do\n    -- Take next value\n    local current_value\
    \ = table.current_list[#table.current_list]\n    -- Increment value\n    current_value\
    \ = current_value + 1\n    -- Add value to table\n    table.current_list[#table.current_list]\
    \ = current_value\n    -- If value is odd then add value to list\n    if current_value\
    \ % 2 == 1 then\n      table.current_list[#table.current_list] = current_value\
    \ / 2\n    end\n  end\n  return table\nend", "  local odd_list = []\n  -- Base\
    \ case\n  if n <= 1 then\n    return odd_list\n  end\n  -- Get previous odd and\
    \ next odd number\n  local previous_odd, next_odd = n % 2, n % 2\n  -- While loop\
    \ to traverse the sequence\n  while n ~= 1 do\n    -- Get the next odd number\n\
    \    local next_odd = previous_odd + next_odd\n    -- If the next number is even\n\
    \    if next_odd % 2 == 0 then\n      -- Append the next number to list\n    \
    \  odd_list.append(next_odd)\n      -- Set the previous_odd and next_odd to odd\n\
    \      previous_odd, next_odd = next_odd, previous_odd + 1\n    else\n      --\
    \ Append the next number to list\n      odd_list.append(next_odd)\n      -- Set\
    \ the previous_odd and next_odd to even\n      previous_odd = next_odd\n     \
    \ next_odd = 0\n    end\n    -- Update n\n    n = next_odd\n  end\n  -- Return\
    \ sorted list\n  return table.sort(odd_list)\nend", "\tlocal t = {}\n\t-- Base\
    \ case.\n\tif n == 1 then\n\t\treturn t\n\tend\n\t-- Recursive case.\n\tlocal\
    \ odd = 0\n\tlocal n = n\n\tfor i = 1, n do\n\t\tif n % 2 == 0 then\n\t\t\teven\
    \ = n / 2\n\t\t\todd = odd*2 + even\n\t\telse\n\t\t\todd = odd*3 + 1\n\t\tend\n\
    \tend\n\ttable.insert(t, odd)\n\treturn t\nend", "  assert(n >= 1, \"ERROR: n\
    \ should be positive integer\")\n  local odd_table = {}\n  if n == 1 then\n  \
    \  odd_table[1] = 1\n    return odd_table\n  end\n  local last_odd = 1\n  local\
    \ odd_cnt = 0\n  local last_odd_cnt = 0\n  for i = 2, n do\n    local odd_count\
    \ = count_odds(last_odd)\n    odd_cnt = odd_cnt + odd_count\n    if odd_cnt >\
    \ last_odd_cnt then\n      odd_table.insert(odd_cnt)\n    end\n    last_odd =\
    \ last_odd ^ 1\n    last_odd_cnt = odd_cnt\n  end\n  return odd_table\nend", " \
    \ -- We need to return the table sorted in increasing order\n  -- so we reverse\
    \ the order of the key (which is the index) and the value which is the number\
    \ itself\n  -- Since our key is index here, we need to return two values, the\
    \ first is the index and the second is the value\n  return dictsort(n+1, get_collatz(n))\n\
    end", "\t-- base case\n\tif n == 1 then\n\t\treturn {n}\n\telse\n\t\t-- recursive\
    \ case\n\t\tlocal odd_list = get_odd_collatz(n / 2)\n\t\t-- check if the number\
    \ is odd\n\t\tif n % 2 == 1 then\n\t\t\ttable.insert(odd_list, n / 2)\n\t\t\t\
    table.insert(odd_list, n / 2 ^ 1)\n\t\tend\n\t\treturn odd_list\n\tend\nend",
  "   -- Initialize table to store the odd numbers in collatz sequence\n   local odd_collatz\
    \ = {}\n   -- If the input number is even or negative, return empty table\n  \
    \ if n < 0 then\n      return odd_collatz\n   end\n   -- Loop until n reaches\
    \ 1, which means Collatz conjecture is satisfied\n   while n ~= 1 do\n      --\
    \ If n is even, add 1 to next term\n      if n % 2 == 0 then\n         n = n /\
    \ 2\n      -- If n is odd, multiply by 3 and add 1 to next term\n      else\n\
    \         n = n * 3 + 1 \n      end\n      odd_collatz[n] = true\n   end\n   --\
    \ Return table of odd numbers in collatz sequence\n   return odd_collatz\nend",
  "  local odd_table = {}\n  for i = 1, n do\n    if i % 2 == 1 then\n      odd_table.insert(i,\
    \ math.floor(i / 2))\n    end\n  end\n  return odd_table\nend", "\tlocal table\
    \ = {}\n\tlocal count = 1\n\tlocal current\n\twhile n >= 1 do\n\t\tcurrent = n\
    \ % 2 == 0 and n or n*3 + 1\n\t\tcount = count + 1\n\t\ttable[ count ] = current\
    \ \n\t\tn = current \n\tend\n\ttable.sort(function(a,b)\n\t\treturn b - a\n\t\
    end)\n\treturn table\nend", "  local tbl = {}\n  \n  local tbl0 = get_collatz(n)\n\
    \  \n  for i = 1, #tbl0, 2 do\n    local term0 = tbl0[i]\n    local term1 = tbl0[i+1]\n\
    \    \n    local new_term = term0\n    \n    if (term0 == 1) and (term1 == 2)\
    \ then\n      new_term = tbl0[i+2]\n    end\n    \n    tbl[#tbl+1] = new_term\n\
    \  end\n  \n  return tbl\nend", "  -- base case\n  if n == 1 then return {} end\n\
    \  -- recursion\n  local next_n = n / 2 \n  local odd_table = {}\n  odd_table[n]\
    \ = n -- add n to the table\n  if next_n % 2 == 0 then odd_table[next_n] = odd_table[next_n]\
    \ + 1 end -- Add one if next is odd\n  odd_table[n] = odd_table[n] - 1 -- subtract\
    \ 1 from next if next is odd\n  -- sort and return\n  table.sort(odd_table)\n\
    \  return odd_table\nend", "  local odd_table = {}\n  local counter = 1\n  while\
    \ n ~= 1 do\n    if n % 2 == 1 then\n      odd_table.insert(counter)\n      counter\
    \ = counter + math.floor(n/2)\n      n = math.floor(n/2)\n    else\n      odd_table.insert(counter)\n\
    \      counter = counter + 3\n      n = n - 1\n    end\n  end\n  odd_table.insert(counter)\n\
    \  return odd_table\nend\n</cell>\n<code language=julia-1.3>", "    local table\
    \ = {}\n    for i=1,n do\n        table.insert(table, i, collatz(i))\n    end\n\
    \    return table.sort(function(a,b) return a[1] < b[1] end)\nend", "\t-- base\
    \ case\n\tif not n then\n\t\treturn {}\n\telseif n == 1 then\n\t\treturn {n}\n\
    \telse\n\t\tlocal odd_table = {}\n\t\tlocal next_term = (n % 2 == 0) ? n / 2 :\
    \ 3 * n + 1\n\t\todd_table.number = next_term\n\t\todd_table.next = get_odd_collatz(next_term)\n\
    \t\treturn odd_table\n\tend\nend", "  if n == 1 then\n    return {1}\n  end\n\
    \  local odd_table = {}\n  for i = 1, n do\n    if n % 2 == 0 then\n      odd_table[i]\
    \ = n\n      n = n / 2\n    else\n      odd_table[i] = n*3+1 \n      n = n / 2\n\
    \    end\n  end\n  return odd_table\nend", "  local table = {}\n  local i = 0\n\
    \  repeat\n    local value = n / 2\n    if value % 2 == 0 then\n      table.insert(table,\
    \ value)\n    end\n    table.insert(table, n * 3 + 1)\n    i = i + 1\n    local\
    \ next = i / 2\n    while i < next do\n      local tmp = i\n      i = i/2\n  \
    \    i = i + 1\n      n = tmp\n      value = n / 2\n      if value % 2 == 0 then\n\
    \        table.insert(table, value)\n      end\n    end\n  until i == 1\n  table.sort(function\
    \ (a,b)\n    return b - a\n  end)\n  return table\nend", "  -- base case\n  if\
    \ n == 1 then\n    return {1}\n  end", "  local odd_dict = {}\n  if n == 1 then\
    \ return {n} end", "    local odd_number = {}\n    for _,v in pairs(collatz(n)-1)\
    \ do\n        odd_number[v] = odd_number[v] or 0\n        odd_number[v] = odd_number[v]\
    \ + 1 \n    end\n    return odd_number\nend", "    local odd_number_table = {}\n\
    \    if n == 1 then\n        odd_number_table[1] = 1\n    else\n        for i\
    \ = 2, (n or 0) + 1 do\n            local prev_n = i\n            while n % i\
    \ == 0 do\n                n = n / i\n                odd_number_table[prev_n\
    \ + 1] = n\n            end\n        end\n    end\n    return odd_number_table\n\
    end", "  local tbl = {}\n  tbl[1] = n\n  if n ~= 1 then\n    local prev, cur =\
    \ n, 1\n    while prev ~= 1 do\n      prev = cur\n      if prev % 2 == 0 then\n\
    \        cur = prev / 2\n      else\n        cur = prev * 3 + 1 \n      end\n\
    \      table.insert(tbl, cur)\n    end\n  end\n  return tbl\nend", "  local results\
    \ = {}\n  if n == 1 then\n    return { 1 }\n  elseif n >= 2 then\n    local odd_terms\
    \ = get_odd_collatz(math.floor(n/2))\n    for _, v in ipairs(odd_terms) do\n \
    \     local next_term = 2*v\n      results[next_term] = v\n    end\n    table.sort(results,\
    \ function(a, b) return b < a end)\n    return results\n  else\n    return {}\n\
    \  end\nend", "  local odd_number_table = {}\n  -- Base case: n = 1\n  odd_number_table[1]\
    \ = 1\n  -- Recursive step: divide n by 2 and increment the odd numbers until\
    \ n is odd.\n  local previous_term = 1\n  local next_term = 1\n  local last_term\
    \ = 1\n  repeat\n    if n % 2 == 0 then\n      odd_number_table[last_term] = 2\
    \ * previous_term + 1\n      last_term = next_term\n      next_term = previous_term\
    \ + 1\n    else\n      odd_number_table[last_term] = 3 * previous_term + 1\n \
    \     last_term = next_term\n      next_term = previous_term + 1\n    end\n  \
    \  previous_term = next_term\n  until n % 2 == 1\n  return odd_number_table\n\
    end", "  if n < 1 then \n    error(\"n must be positive\")\n  elseif n == 1 then\n\
    \    return {1}\n  else\n    local odd_list = {}\n    for i = 1, n do\n      local\
    \ temp = i\n      while true do\n        local tmp = math.floor((temp % 2) / 2)\n\
    \        if tmp == 1 then break end\n        odd_list[#odd_list + 1] = tmp\n \
    \       temp = tmp\n      end\n    end\n    return odd_list\n  end\nend", "  assert(n\
    \ > 0)\n  local odd_collatz = {}\n  local i = 1\n  local prev = 1\n  while true\
    \ do\n    local temp = prev\n    prev = prev ^ 2\n    if temp % 2 == 1 then\n\
    \      odd_collatz[i] = temp\n      i = i + 1\n    end\n    if temp == prev then\
    \ break end\n  end\n  return odd_collatz\nend", "   if n == 1 then\n      return\
    \ {1}\n   else\n      local odd_table = {}\n      local p = 2\n      while true\
    \ do\n         local new_p = p\n         if n % 2 == 0 then\n            new_p\
    \ = p / 2\n         end\n         odd_table[new_p] = odd_table[new_p] + 1\n  \
    \       if odd_table[new_p] == 2 then\n            p = new_p\n         else\n\
    \            n = n - 1\n         end\n         if n == 1 then\n            return\
    \ odd_table\n         end\n      end\n   end\nend\n</cell>\n<cell>\n%%python",
  "\t-- Base Case\n\tif n == 1 then\n\t\treturn {[1]}\n\tend\n\t-- Iterate until odd\
    \ numbers found\n\tlocal odd_numbers = {}\n\tfor i = 2, n do\n\t\tlocal prev_n\
    \ = i\n\t\twhile prev_n % 2 == 0 do\n\t\t\tprev_n = prev_n / 2\n\t\tend\n\t\t\
    odd_numbers[#odd_numbers + 1] = prev_n\n\tend\n\treturn odd_numbers\nend", " \
    \   local odd_numbers = {}\n    local previous_number = 0\n    local sequence\
    \ = []\n    local current_number = 1\n    while n ~= 0 do\n        if current_number\
    \ % 2 == 0 then\n            odd_numbers[#odd_numbers + 1] = current_number\n\
    \            current_number = current_number / 2\n        else\n            current_number\
    \ = current_number * 3 + 1\n        end\n        sequence = sequence or {}\n \
    \       table.insert(sequence, current_number)\n        n = n / current_number\n\
    \    end\n    return odd_numbers\nend", "  local odd_table = {}\n  local odd_collatz\
    \ = {}\n  for i = 1, n do\n    if n % 2 == 0 then\n      odd_table.push(i)\n \
    \     odd_collatz[i] = get_odd_collatz(n / 2)\n    else\n      odd_table.push(odd_collatz[i])\n\
    \    end\n  end\n  return odd_table\nend", "\tif n <= 0 then\n\t\treturn {n}\n\
    \telseif n % 2 == 0 then\n\t\treturn get_odd_collatz(n / 2)\n\telse\n\t\treturn\
    \ get_odd_collatz((3 * n) + 1)\n\tend\nend", "\tlocal odd_table = {}\n\todd_table.[1]\
    \ = 1\n\tfor i=2,n+1 do\n\t\tif is_even(n / i) then\n\t\t\todd_table[i] = odd_table[i/2]\
    \ * 2 + 1\n\t\telse\n\t\t\todd_table[i] = odd_table[i/2] * 3 + 1\n\t\tend\n\t\
    end\n\treturn odd_table\nend", "\t-- base case: n is odd.\n\tif n % 2 == 0 then\n\
    \t\treturn {n}\n\t-- if n is even, divide by 2 to get the next odd term.\n\telse\n\
    \t\treturn get_odd_collatz(n / 2) \n\t\t   \t.. {n % 2 + 1}\n\tend\nend", "  assert(n\
    \ > 1, 'n should be greater than 1.')\n  local odd_table = {}\n  odd_table[1]\
    \ = 1\n  local n = n\n  repeat\n    if n % 2 == 1 then\n      odd_table[2*n] =\
    \ n\n    else\n      odd_table[2*n+1] = n\n    end\n    n = n/2\n  until n ==\
    \ 1\n  return odd_table\nend", "  local table = {n}\n  repeat\n    table.insert(table,\
    \ (not not n % 2) and n/2 or 3*n+1)\n    local i = table[2]\n    while i ~= 1\
    \ and i ~= n do\n      i = i // 2\n      table.insert(table, i)\n    end\n  until\
    \ n <= 1\n  return table\nend", "  local odd_list = []\n  local next_val = 0\n\
    \  for i = 1, n do\n    if n % 2 == 0 then\n      odd_list[#odd_list + 1] = i\n\
    \      next_val = next_val + 1 / i\n    else\n      odd_list[#odd_list + 1] =\
    \ 3 * next_val + 1 - 1\n      next_val = next_val + 1\n    end\n  end\n  table.sort(odd_list)\n\
    \  return odd_list\nend", "  assert(n > 0, 'n should not be a negative number.')\n\
    \  local tbl = {}\n  local prev = 0\n  for i = 1, n do\n    local next = prev\n\
    \    if next % 2 == 0 then\n      next = next / 2\n    else\n      next = next\
    \ * 3 + 2\n    end\n    prev = next\n    tbl[#tbl+1] = next\n  end\n  return tbl\n\
    end", "\tlocal tbl = {}\n\tfor i = 2, n do tbl[i] = i end\n\tlocal j = 1\n\tfor\
    \ i = 2, #tbl do\n\t\tif tbl[i] % 2 == 1 then\n\t\t\ttbl[i] = 3 * tbl[i] + j\n\
    \t\telse\n\t\t\tj = tbl[i]\n\t\tend\n\tend\n\treturn tbl\nend", "    local odd_list\
    \ = []\n    local n1 = n\n    if n1 ~= 1 then\n        while n1 ~= 1 do\n    \
    \        if n1 % 2 == 0 then\n                n1 = (n1 div 2)\n              \
    \  odd_list.append(n1)\n            else\n                n1 = (n1 * 3)+1\n  \
    \          end\n        end\n    end\n    table.sort(odd_list)\n    return odd_list\n\
    end", "\t-- base case\n\tif n==1 then\n\t\treturn {[1]}\n\telse\n\t\t-- append\
    \ odd number on next row\n\t\tlocal odd_list = {}\n\t\todd_list = odd_list ..\
    \ get_odd_collatz(n-1)\n\t\t-- append even number on next row\n\t\tlocal even_list\
    \ ={}\n\t\teven_list = even_list .. get_even_collatz(n-1)\n\t\t-- append even\
    \ number on next row\n\t\tlocal odd_list_reverse = odd_list\n\t\todd_list_reverse\
    \ = odd_list_reverse .. get_odd_collatz(n-1)\n\t\t-- append odd number on next\
    \ row\n\t\tlocal odd_list_reverse2 = odd_list\n\t\todd_list_reverse2 = odd_list_reverse2\
    \ .. get_odd_collatz(n-1)\n\t\t-- concatenate all rows, and return odd_list\n\t\
    \treturn odd_list .. even_list .. odd_list_reverse .. odd_list_reverse2\n\tend\n\
    end", "  local table = {}\n  local current = 0\n  while n > 1 do\n    local next_current\
    \ = current + 1\n    if next_current % 2 == 0 then\n      table[current] = next_current\n\
    \    else\n      table[current] = next_current * 3 + 1\n    end\n    current =\
    \ next_current\n  end\n  return table\nend", "    if n==1 then\n        return\
    \ {1}\n    end", "  if n==1 then\n    return {[1]}\n  end\n  local odd_collatz={[]}\n\
    \  local prev=n\n  while prev~=1 do\n    if prev%2==0 then\n      odd_collatz:insert(prev/2)\n\
    \      prev=prev/2\n    else\n      prev=prev*(3+prev)\n      odd_collatz:insert(prev)\n\
    \    end\n  end\n  odd_collatz:insert(1)\n  return odd_collatz\nend", "    if\
    \ n == 1 then\n        return {}\n    end\n    local odd_number_list = []\n  \
    \  if n % 2 == 0 then\n        odd_number_list = odd_number_list .. n\n      \
    \  n = n/2\n    else\n        odd_number_list = odd_number_list .. n\n       \
    \ n = (3*n) + 1\n    end\n    for i = 1, n do\n        if n % 2 == 1 then\n  \
    \          odd_number_list = odd_number_list .. n\n            n = (3*n) + 1\n\
    \        else\n            odd_number_list = odd_number_list .. n\n          \
    \  n = n/2\n        end\n    end\n    return odd_number_list\nend", "  if n==1\
    \ then\n    return {1}\n  else\n    local ret={}\n    local cur, prev=n, 1\n \
    \   while cur>1 do\n      prev, cur=cur, prev*2+1\n      if cur%2==0 then ret[#ret+1]=cur\
    \ end\n    end\n    return ret\n  end\nend", "    local table = setmetatable({},\
    \ {__index=function (t) return t end})\n    local result = {}\n    if n > 1 then\n\
    \        local previous = n\n        for i=1,n do\n            local value = previous\
    \ * 2 + 1\n            if value % 2 == 1 then\n                value = value +\
    \ 1\n            end\n            table.insert(result, value)\n            previous\
    \ = value\n        end\n    end\n    return table.concat(result,\",\")\nend",
  "\tlocal table = {}\n\tfor i=1,n do\n\t\ttable.insert(table, i-1)\n\t\tif i % 2\
    \ == 0 then\n\t\t\ttable.insert(table, (3*i)+1)\n\t\telse\n\t\t\ttable.insert(table,\
    \ (3*i)+2)\n\t\tend\n\tend\n\treturn table\nend", "  local odd_collatz = {}\n\
    \  odd_collatz[1] = 1\n  local current = 2\n  local next = 1\n  while next < n\
    \ do\n    if odd_collatz[current] then\n      odd_collatz[current] = next + 1\n\
    \      next = next + 1 / 2\n    else\n      odd_collatz[current] = next * 3 +\
    \ 1\n      next = next * 2 + 1\n    end\n    current = current + 1\n  end\n  return\
    \ odd_collatz\nend", "  local odd = {}\n  for i = 1, n do\n    if n % 2 == 0 then\n\
    \      odd[i] = 1\n      n = n / 2\n    else\n      odd[i] = 3 * odd[i - 1] +\
    \ 2\n    end\n  end\n  return odd\nend", "    local odd_list = []\n    while n\
    \ > 1 do\n        odd_list = odd_list + 1\n        if n % 2 == 0 then n = n /\
    \ 2 else n = n * 3 + 1 end\n    end\n    return odd_list\nend", "    local table\
    \ = {}\n    local odd = 0\n    local step = 1\n    while step ~= 1 do\n      \
    \  odd = 0\n        if n % 2 == 0 then\n            odd = 1\n            n = n\
    \ / 2\n        else\n            n = n * 3 + 1\n        end\n        table.insert(table,\
    \ odd)\n        step = n / step\n    end\n    return table\nend", "    local odd_table\
    \ = {}\n    local previous_term = 1\n    local current_term = 1\n    local i =\
    \ 2\n    while i < n do\n        if n % 2 == 0 then\n            current_term\
    \ = previous_term\n            previous_term = previous_term / 2\n        else\n\
    \            current_term = previous_term\n            previous_term = previous_term\
    \ * 3 + 1\n        end\n        odd_table[i] = current_term\n        i = i + 1\n\
    \    end\n    return odd_table\nend", "  local odd_numbers = {}\n  for i = 1,\
    \ n do\n    if n ~= 1 then\n      if n % 2 == 0 then\n        odd_numbers[#odd_numbers+1]\
    \ = n/2\n      else\n        odd_numbers[#odd_numbers+1] = 3*n + 1\n      end\n\
    \    end\n  end\n  return odd_numbers\nend", "\tlocal odd_collatz_table = {}\n\
    \todd_collatz_table[1] = 1\n\tlocal n_prev = 1\n\tlocal i = 1\n\twhile i <= n\
    \ do\n\t\tlocal n_current = n_prev\n\t\tn_prev = n_current\n\t\tlocal n_next_prev\
    \ = 1\n\t\tif n_prev % 2 == 0 then\n\t\t\tn_next_prev = (n_prev + 1) // 2\n\t\t\
    else\n\t\t\tn_next_prev = n_prev * 3 + 1 \n\t\tend\n\t\tif n_next_prev == n_prev\
    \ then\n\t\t\todd_collatz_table[i] = 1\n\t\telse\n\t\t\todd_collatz_table[i] =\
    \ n_next_prev\n\t\tend\n\t\ti = i + 1\n\tend\n\ttable.sort(odd_collatz_table)\n\
    \treturn odd_collatz_table\nend", "\tlocal sorted_table = {}\n\tlocal i = 1\n\t\
    local previous = 1\n\t\n\twhile i <= n do\n\t\tprevious = i\n\t\ti = previous\
    \ % 2\n\t\t\n\t\tif i == 1 then\n\t\t\tsorted_table[1] = previous\n\t\telse\n\t\
    \t\tsorted_table[i] = previous * 3 + 1\n\t\tend\n\tend", "    local odd_list =\
    \ []\n    local cur_val = 1\n    while cur_val ~= 1 do\n        if cur_val % 2\
    \ == 1 then\n            odd_list[#odd_list + 1] = cur_val\n        end\n    \
    \    cur_val = cur_val / 2\n    end\n    return odd_list\nend", "   if n <= 1\
    \ then return { n }\n   if n%2 == 0 then return get_odd_collatz(n/2)\n   else\
    \              return get_odd_collatz((3*n + 1)/2)\nend", "  local odd_collatz\
    \ = {}\n  if n <= 0 then return odd_collatz end\n  if n == 1 then return { n }\
    \ end\n  local prev_num = n % 2\n  odd_collatz[prev_num] = get_odd_collatz(n /\
    \ 2)\n  if prev_num == 0 then\n    for _, value in ipairs(odd_collatz[prev_num])\
    \ do\n      odd_collatz[prev_num][#odd_collatz[prev_num]+1] = value\n    end\n\
    \  else\n    odd_collatz[prev_num][#odd_collatz[prev_num]+1] = n * 3 + 1\n  end\n\
    \  return odd_collatz\nend", "\t-- The sequence always starts from 1, and we must\
    \ end with 1.\n\tif not n then\n\t\treturn {1}\n\tend", "    local odd_nums =\
    \ {}\n    local collatz = {}\n    local j = 1\n    while n ~= 1 do\n        if\
    \ n % 2 == 0 then\n            odd_nums[j] = n\n        end\n        if j > 1\
    \ then\n            if n % 2 == 1 then\n                n = n/2\n            else\n\
    \                n = n*(3+1)\n            end\n        else\n            n = n/2\n\
    \        end\n        collatz[j] = n\n        j = j + 1\n    end\n    return odd_nums,\
    \ collatz\nend", "  local sorted_table_data = {}\n  local last_even = 1\n  local\
    \ last_odd = 1\n  local next_odd = 3\n  \n  -- Iterate through n terms and add\
    \ them to the table.\n  for i = 1, n do\n    -- Get the current number of the\
    \ sequence.\n    local cur_odd", '   assert(n >= 1)', "  -- Base case:\n  if n\
    \ <= 1 then\n    return {}\n  end", "    local odd_collatz = {}\n    local n2\
    \ = n / 2\n    while n2 ~= 1 do\n        if n % 2 == 0 then\n            odd_collatz[1]\
    \ = n2\n            n2 = n2 / 2\n        else\n            odd_collatz[n2 + 1]\
    \ = (2 * n2) + 1\n            n2 = n2 / 2\n        end\n    end\n    return odd_collatz\n\
    end", "\tlocal result = {}\n\tlocal x = 1\n\tlocal y = 1\n\t\n\twhile n ~= 1 do\n\
    \t\tif n % 2 == 0 then\n\t\t\ttable.insert(result, y)\n\t\t\tn = n / 2\n\t\telse\n\
    \t\t\ttable.insert(result, 2 * x + 1)\n\t\t\ty = y + 1\n\t\tend\n\tend\n\t\n\t\
    return result\nend", "  local odds = {}\n  local t = 1\n  for i = 1, n do\n  \
    \  if t % 2 == 0 then\n      t = t / 2\n    else\n      t = 3 * t + 1\n    end\n\
    \    table.insert(odds, t)\n  end\n  return table.sort(odds)\nend", '    local
    odd_numbers = {1} -- initialize a table with 1 in the first element', "\tlocal\
    \ odd_collatz = {}\n\tlocal odds = 1\n\tlocal even = 1\n\twhile n ~= 0 do\n\t\t\
    if even == n then\n\t\t\todd_collatz[odds] = even\n\t\t\teven = even + 1\n\t\t\
    else\n\t\t\todd_collatz[odds] = n\n\t\t\tn = n/2\n\t\tend\n\t\todds = odds + 1\n\
    \tend\n\todd_collatz[odds] = n\n\treturn odd_collatz\nend", "  if n <= 0 then\n\
    \    return {}\n  end", "   -- Base case 1\n   if n == 1 then\n      return {n}\n\
    \   -- Base case 2\n   elseif n == 2 then\n      return {n, n+1, 3*n}\n   -- Base\
    \ case 3\n   elseif n % 2 == 0 then\n      return {n, 3*n+1}\n   -- Base case\
    \ 4\n   else\n      local odds = {n}\n      local i = 2\n      while i < n do\n\
    \         local p = get_odd_collatz(i)\n         if p[1] == n then\n         \
    \   table.insert(odds, p[2])\n         else\n            table.insert(odds, p[1])\n\
    \         end\n         i = i + 1\n      end\n      return odds\n   end\nend",
  "\tif n == 1 then\n\t\treturn {n}\n\telseif n % 2 == 0 then\n\t\tlocal odd_table\
    \ = get_odd_collatz(math.floor(n/2))\n\t\todd_table.insert(n%2)\n\t\treturn odd_table\n\
    \telse\n\t\tlocal odd_table = get_odd_collatz(math.floor(n/2))\n\t\todd_table.insert(3*n+1)\n\
    \t\treturn odd_table\n\tend\nend", "\tlocal ret={}\n\tfor i=1,n do\n\t\tlocal\
    \ n1=n\n\t\tlocal n2=(n1*3)+1\n\t\tlocal n3=(n2*2)+1\n\t\tlocal n4=(n3*1)+1\n\t\
    \ttable.insert(ret,n4)\n\tend\n\ttable.sort(ret,function(a,b)\n\t\treturn a>b\n\
    \tend)\n\treturn ret\nend", "\tlocal odd_collatz = {}\n\todd_collatz[1] = n\n\t\
    local i = 2\n\twhile i < n do\n\t\tif n % i == 0 then\n\t\t\todd_collatz[i + 1]\
    \ = i\n\t\telse\n\t\t\todd_collatz[i + 1] = n / i\n\t\tend\n\t\ti = i + 2\n\t\
    end\n\ttable.sort(odd_collatz)\n\treturn odd_collatz\nend", "  local ttable =\
    \ {}\n  local n = 1\n  local i = 2\n  while n > 1 do\n    if (n % 2 == 0) then\n\
    \      n = n / 2\n      ttable[i] = n\n      i = i + 1\n    end\n    n = n + 1\n\
    \  end\n  return ttable\nend", "\tlocal odd_table = {}\n\todd_table[1] = 1\n\t\
    local next_odd\n\tlocal current\n\tif n == 1 then\n\t\treturn odd_table\n\tend\n\
    \tcurrent = 1\n\tnext_odd = 2 * current\n\twhile next_odd <= n do\n\t\tif n %\
    \ next_odd > 0 then\n\t\t\todd_table[next_odd] = n\n\t\t\tcurrent = next_odd\n\
    \t\t\tnext_odd *= 2\n\t\telse\n\t\t\tnext_odd *= 3\n\t\tend\n\tend\n\todd_table[n]\
    \ = n\n\treturn odd_table\nend", "  local odd_tbl = {}\n  odd_tbl[1] = n\n  odd_tbl[n]\
    \ = nil\n  while n > 1 do\n    if n % 2 == 0 then\n      n = n / 2\n    else\n\
    \      n = 3 * n + 1 -- The next even term is the next odd term.\n    end\n  \
    \  odd_tbl[n] = odd_tbl[n] or n -- The odd numbers are sorted.\n  end\n  return\
    \ odd_tbl\nend", "\tlocal odd_table = {}\n\tlocal odd_table_value = 1\n\tlocal\
    \ odd_n = n\n\t\n\twhile odd_n ~= 1 do\n\t\todd_table_value = (odd_table_value\
    \ * 2) + odd_n\n\t\todd_n = odd_table_value\n\t\t\n\t\tif odd_n % 2 == 0 then\n\
    \t\t\todd_table.insert(odd_n)\n\t\tend\n\tend\n\t\n\treturn odd_table\nend", " \
    \  -- base case\n   if n == 1 then\n       return {1}\n   end\n   -- recursive\
    \ case\n   local res = get_odd_collatz(n-1)\n   if n % 2 == 0 then\n       res.add(\
    \ n-1 )\n   else\n       res:add( 3*n+1 )\n   end\n   return res\nend", "   if\
    \ n <= 1 then\n      return {}\n   end", "   assert(type(n ~= 'number' or (math.floor(n)\
    \ ~= n) and n) or n == 0, 'n must be a number')\n   local odd_list, even_list,\
    \ prev_term = { 1 }, { 2 }, n\n   repeat\n      even_list.insert(prev_term)\n\
    \      if prev_term % 2 == 0 then\n         odd_list.insert(2 * prev_term + 1)\n\
    \      else\n         odd_list.insert(3 * prev_term + 1)\n      end\n      prev_term\
    \ = odd_list[#odd_list]\n   until prev_term == 1\n   return odd_list\nend\n</cell>\n\
    <cell>", "    local tbl = {}\n    local n = 1\n    while n ~= 1 do\n        if\
    \ n % 2 == 0 then\n            table.insert(tbl, n / 2)\n        end\n       \
    \ if n % 2 == 1 then\n            n = n * 3 + 1\n        end\n    end\n    return\
    \ tbl\nend", "\tlocal odd_collatz = {}\n\todd_collatz[1] = n\n\todd_collatz[#odd_collatz\
    \ + 1] = n\n\todd_collatz[#odd_collatz + 2] = 1\n\todd_collatz[#odd_collatz +\
    \ 3] = n / 2\n\todd_collatz[#odd_collatz + 4] = n / 2 * 3\n\treturn odd_collatz\n\
    end", "  if n == 1 then\n    return { 1 }\n  end", "    local table = {}\n   \
    \ for i=1,n do\n        if i%2==1 then\n            table.insert(table, i)\n \
    \       end\n        while i ~= 1 do\n            if i%2==0 then\n           \
    \     i = i/2 + 1\n            else\n                i = i*3 + 1 \n          \
    \  end\n            table.insert(table, i)\n        end\n    end\n    return table\n\
    end", "  if n == 1 then\n    return {1}\n  end\n  local next_odd\n  local next_even\n\
    \  local next_odd\n  \n  for i = 2, n do\n    if i % 2 == 0 then\n      next_even\
    \ = i \n    else\n      next_odd = i * 3 + 1\n    end\n    table.insert(odd, next_odd)\n\
    \    table.insert(even, next_even)\n  end\n  \n  table.sort(odd, function(a, b)\
    \ return odd_comparator(a, b) end)\n  table.sort(even, function(a, b) return even_comparator(a,\
    \ b) end)\n  return { odd = odd, even = even }\nend", "  local table = {}\n  --\
    \ We know that 1 must be odd, so we only have to consider odd numbers.\n  table.insert(table,\
    \ 1) -- Start with 1 since 1 is even.\n  -- We have seen 1 before so we know the\
    \ answer is 1.\n  table.insert(table, 2) -- 2 goes to 2 before 3, since 2 is even,\
    \ so we now have {1, 2}.\n  -- We have seen 2 before so we know the answer is\
    \ 2.\n  table.insert(table, 3) -- 3 goes to 3 before 5, since 3 is even, so we\
    \ now have {1, 2, 3}.\n  -- We have seen 3 before so we know the answer is 3.\n\
    \  table.insert(table, 5) -- 5 goes to 5 before 10, since 5 is even, so we now\
    \ have {1, 2, 3, 5}.\n  -- We have seen 5 before so we know the answer is 5.\n\
    \  table.insert(table, 8) -- 8 goes to 8 before 15, since 8 is even, so we now\
    \ have {1, 2, 3, 5, 8}.\n  -- We have seen 8 before so we know the answer is 8.\n\
    \  table.insert(table, 15) -- 15 goes to 15 before 22, since 15 is even, so we\
    \ now have {1, 2, 3, 5, 8, 15}.\n  -- We have seen 15 before so we know the answer\
    \ is 15.\n  table.insert(table, 22) -- 22 goes to 22 before 28, since 22 is even,\
    \ so we now have {1, 2, 3, 5, 8, 15, 22}.\n  -- We have seen 22 before so we know\
    \ the answer is 22.\n  table.insert(table, 28) -- 28 goes to 28 before 32, since\
    \ 28 is even, so we now have {1, 2, 3, 5, 8, 15, 22, 28}.\n  -- We have seen 28\
    \ before so we know the answer is 28.\n  table.insert(table, 32) -- 32 goes to\
    \ 32 before 42, since 32 is even, so we now have {1, 2, 3, 5, 8, 15, 22, 28, 32}.\n\
    \  -- We have seen 32 before so we know the answer is 32.\n  table.insert(table,\
    \ 42) -- 42 goes to 42 before 48, since 42 is even, so we now have {1, 2, 3, 5,\
    \ 8, 15, 22, 28, 32, 42}.\n  -- We have seen 42 before so we know the answer is\
    \ 42.\n  table.insert(table, 48) -- 48 goes to 48 before 56, since 48 is even,\
    \ so we now have {1, 2, 3, 5, 8, 15, 22, 28, 32, 42, 48}.\n  -- We have seen 48\
    \ before so we know the answer is 48.\n  table.insert(table, 56) -- 56 goes to\
    \ 56 before 64, since 56 is even, so we now have {1, 2, 3, 5, 8, 15, 22, 28, 32,\
    \ 42, 48, 56}.\n  -- We have ", "    local table = {}\n    if n <= 1 then return\
    \ {n} end\n    for i = 2, n do\n        if n % 2 == 0 then\n            n = n/2\n\
    \        else\n            n = 3*n + 1\n        end\n        table.insert(table,\
    \ n)\n    end\n    return table\nend", "  local table = {}\n  local current =\
    \ n\n  repeat\n    -- The current term is one half of the previous term.\n   \
    \ local next_term = (current % 2) and math.floor( current/2 ) or math.ceil( current/2\
    \ )\n    current = next_term\n    table[ next_term ] = true\n  until current ==\
    \ 1\n  return table\nend", "  local odd_numbers = {}\n  for i = 1, n do \n   \
    \ odd_numbers[i] = i\n  end \n  odd_numbers[1] = nil\n  for i = 2, n do \n   \
    \ if odd_numbers[i] == nil then\n      odd_numbers[i] = odd_numbers[i - 1] * 2\
    \ + 1\n    end \n  end \n  return odd_numbers\nend", "  local odd_collatz = {}\n\
    \  for i = 2, n do\n    if i % 2 == 0 then\n      odd_collatz[#odd_collatz+1]\
    \ = i\n    end\n    if i%2 == 1 and n > i then\n      odd_collatz[#odd_collatz+1]\
    \ = i/2\n    end\n  end\n  return odd_collatz\nend", "  local table = {}\n  for\
    \ i=1,n do\n    if n % 2 == 0 then\n      table.insert(table,math.floor(n/2))\n\
    \      n = math.floor(n/2)\n    else\n      table.insert(table,3*n+1)\n      n\
    \ = math.floor(n/3)\n    end\n  end\n  return table\nend", "    local table =\
    \ {}\n    local n1, n2 = 1, n\n    while n2 > 0 do\n        if n2 % 2 == 0 then\n\
    \            table.insert(table, n1)\n        end\n        n1, n2 = n1, n2 / 2\n\
    \    end\n    return table\nend", "\tif n == 1 then\n\t\treturn {n}\n\tend\n\t\
    local odd_collatz = {}\n\tfor i=1,n do\n\t\todd_collatz[i] = get_odd_collatz(n\
    \ % 2 + 1) * 3 + (n % 2)\n\tend\n\treturn odd_collatz\nend", "    local odd_table_table\
    \ = {}\n    odd_table_table[1] = {}\n    local previous_term = 1\n    for current_term\
    \ = 1 to n do\n        if current_term % 2 == 0 then\n            current_term\
    \ = current_term/2\n        else\n            current_term = current_term * 3\
    \ + 1 \n        end\n        odd_table_table[previous_term] = current_term\n \
    \       previous_term = current_term\n    end\n    return odd_table_table\nend",
  "  if n==1 then\n    return [1]\n  elseif n==0 then\n    return {}\n  elseif n%2==0\
    \ then\n    return get_odd_collatz(n/2)\n  else\n    local ret = {}\n    for x=3,n,2\
    \ do\n      table.insert(ret,(x/2)*3+(x%2))\n    end\n    return ret\n  end\n\
    end", "  local odd_collatz_table = {}\n  odd_collatz_table[1] = 1\n  local prev_val\
    \ = n\n  for i = 2, n do\n    if i % 2 == 0 then\n      odd_collatz_table[i] =\
    \ odd_collatz_table[prev_val]/2 + 1\n      prev_val = odd_collatz_table[i]\n \
    \   else\n      odd_collatz_table[i] = 3*odd_collatz_table[prev_val] + 1\n   \
    \   prev_val = odd_collatz_table[i]\n    end\n  end\n  return odd_collatz_table\n\
    end", "  local t = {}\n  local n = n or 1\n  repeat\n    if n % 2 == 0 then\n\
    \      n = n/2\n    else\n      n = ((3 * n) + 1)\n    end\n    t[#t + 1] = n\n\
    \  until n == 1\n  return t\nend", "  if n == 1 then\n    return {1}\n  end\n\
    \  local odds = {}\n  local next_term\n  while n ~= 1 do\n    next_term = n %\
    \ 2 == 0 and n/2 or 3*n + 1\n    table.insert(odds, next_term)\n    n = next_term\n\
    \  end\n  return odds\nend", "  local odd_collatz = {}\n  odd_collatz[1] = n\n\
    \  -- start from 2\n  for i = 2, n do\n    if n % 2 == 0 then\n      odd_collatz[i]\
    \ = odd_collatz[i-2] + 1 -- odd number so one times the previous one\n    else\n\
    \      odd_collatz[i] = odd_collatz[i-2] * 3 + 1 -- even number so three times\
    \ the previous one\n    end\n  end\n  return odd_collatz\nend", "\tlocal table\
    \ = {}\n\tlocal i = 2\n\twhile i <= n do\n\t\tlocal j = math.floor(math.sqrt(i\
    \ + 1))\n\t\ttable.insert(table, i)\n\t\ti = j\n\tend\n\ttable.sort(function(a,\
    \ b) return a[1] < b[1] end)\n\treturn table\nend", "  local result = {}\n  \n\
    \  -- If the given number is 1, return the list [1] (starting with the number\
    \ 1)\n  if n==1 then \n    result[1]=1\n    return(result)\n  end\n  \n  -- If\
    \ the given number is odd, add 1 to the list and return\n  if n%2 ~=0 then\n \
    \   result[1]=n+1\n    return(result)\n  \n  -- If the given number is even, divide\
    \ it and return the list (with the head divided by two)\n  else\n    result[1]=n/2\n\
    \    return(get_odd_collatz(result[1]))\n  end\nend", "  -- base case\n  if n\
    \ == 1 or n == 2 then\n    return {{n}}\n  end\n  -- base case\n  if n % 2 ==\
    \ 1 then\n    return {{n}}\n  end\n  -- recursive case\n  local odds = table.deepcopy(get_odd_collatz(n\
    \ / 2))\n  for i, v in ipairs(odds) do\n    table.insert(odds, v)\n    table.insert(odds,\
    \ v * 2)\n    table.insert(odds, v + 2)\n  end\n  return odds\nend", "    local\
    \ table = {[1]}\n    local i = 1\n    while i <= n do\n        if isodd(n) then\n\
    \            table[i] = n\n        else\n            n = n / 2\n            table.insert(table,\
    \ n)\n        end\n        i = i + 1\n    end\n    return table\nend", "    local\
    \ table = {}\n    local n = 1\n    while n >= 1 do\n        table.insert(table,\
    \ n)\n        if n % 2 == 1 then\n            n = n / 2\n        else\n      \
    \      n = n * 3 + 1 -- use integer division.\n        end\n    end\n    return\
    \ table\nend", "  local table = {}\n  local i = 2\n  while i <= n do\n    table[i]\
    \ = i\n    if i % 2 == 0 then\n      i = i / 2\n      table.insert(table, i)\n\
    \      table.insert(table, i * 2)\n    elseif i % 2 == 1 then\n      i = i * 3\
    \ + 1\n      table.insert(table, i)\n      table.insert(table, i * 3 + 2)\n  \
    \  end\n  end\n  table.sort(function(x,y) return x > y end)\n  return table\n\
    end", "  -- base case\n  if n == 1 then\n    return [1]\n  end ", "    local table\
    \ = {}\n    table.insert(table, 1)\n    while n ~= 1 do\n        if n % 2 == 0\
    \ then\n            n = n / 2\n        else\n            n = 3 * n + 1 \n    \
    \    end\n        table.insert(table, n)\n    end\n    return table\nend", "\t\
    local odd_collatz = {}\n\tfor i = 2, n do\n\t\tif (not odd_collatz[i]) and (not\
    \ n%2) then\n\t\t\todd_collatz[i] = n\n\t\tend\n\t\tif (not odd_collatz[i]) and\
    \ (not n%2) then\n\t\t\todd_collatz[i] = n\n\t\tend\n\t\tif (odd_collatz[i]) then\n\
    \t\t\todd_collatz[i] = odd_collatz[i] - 1\n\t\tend\n\t\tif (odd_collatz[i]) then\n\
    \t\t\todd_collatz[i] = odd_collatz[i] * (3 ^ odd_collatz[i])\n\t\tend\n\tend\n\
    \treturn odd_collatz\nend", "  local table = {}\n  repeat\n    table.insert(table,\
    \ n)\n    n = n / 2 if n % 2 == 0 then\n  until n == 1\n  return table\nend",
  "    local odd_numbers = {}\n    for i = 1, n do\n        odd_numbers[#odd_numbers\
    \ + 1] = get_odd_collatz(n / 2)\n    end\n    return odd_numbers\nend", "  local\
    \ tbl = {}\n  local n = math.floor(n)\n  if n == 1 then\n    tbl[1] = 1\n  else\n\
    \    tbl[1] = n\n    local m = n / 2\n    while m > 1 do\n      if n % 2 == 0\
    \ then\n        n /= 2\n      else\n        n = 3*n + 1 \n      end\n      tbl[m]\
    \ = n\n      m = n / 2\n    end\n  end\n  return tbl\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
