name: HumanEval_160_do_algebra
language: lua
prompt: "-- Given two tables operator, and operand. The first table has basic algebra\
  \ operations, and \n-- the second table is a table of integers. Use the two given\
  \ tables to build the algebric \n-- expression and return the evaluation of this\
  \ expression.\n-- The basic algebra operations:\n-- Addition ( + ) \n-- Subtraction\
  \ ( - ) \n-- Multiplication ( * ) \n-- Floor division ( // ) \n-- Exponentiation\
  \ ( ** ) \n-- Example:\n-- operator['+', '*', '-']\n-- table = [2, 3, 4, 5]\n--\
  \ result = 2 + 3 * 4 - 5\n-- => result = 9\n-- Note:\n-- The length of operator\
  \ table is equal to the length of operand table minus one.\n-- Operand is a table\
  \ of of non-negative integers.\n-- Operator table has at least one operator, and\
  \ operand table has at least two operands.\nlocal function do_algebra(operator,\
  \ operand)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = do_algebra\n\
  \    lu.assertEquals(candidate({'**', '*', '+'}, {2, 3, 4, 5}), 37)\n    lu.assertEquals(candidate({'+',\
  \ '*', '-'}, {2, 3, 4, 5}), 9)\n    lu.assertEquals(candidate({'//', '*'}, {7, 3,\
  \ 4}), 8)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tif #operand ~= #operator-1 then return nil end\n\tlocal values =\
    \ {}\n\tlocal i = 0\n\twhile i < (#operand) - 1 do\n\t\tlocal j = 0\n\t\twhile\
    \ j < #operator do\n\t\t\tlocal k = 0\n\t\t\twhile k < #operand do\n\t\t\t\tif\
    \ operand[k] == operand[i+k] then -- Check for equality\n\t\t\t\t\tlocal value\
    \ = operator[j]\n\t\t\t\t\tfor m = k, #operand-1 do\n\t\t\t\t\t\tvalue = value\
    \ * operand[m]\n\t\t\t\t\tend\n\t\t\t\t\ttable.insert(values, value)\n\t\t\t\t\
    end\n\t\t\t\tk = k + 1\n\t\t\tend\n\t\t\tj = j + 1\n\t\tend\n\t\ti = i + 1\n\t\
    end\n\treturn values[1]\nend", "  -- We will store results in a separate table\n\
    \  local result = {}\n  -- We will store intermediate results in the table\n \
    \ local intermediate_result = {}\n  -- Iterate through each operand and perform\
    \ algebraic operation\n  for i = 1, #operand do\n    -- Calculate the intermediate\
    \ result\n    intermediate_result[#result + 1] = math.fmod(operand[i], operator[#operator])\n\
    \    -- Perform the operation\n    result[#result + 1] = result[#result + 1] +\
    \ operator[#operator]\n    -- If the next operand is a positive integer, we increment\
    \ the operator index\n    if operand[i] >= 0 then \n      -- Increment the operator\
    \ index\n      -- If it is greater than the length of operator table, return the\
    \ final result\n      -- or else continue to move to the next operand value\n\
    \      while #operator > i do \n\t-- The result will be the final result of the\
    \ expression\n\tif #result > 0 then return result\n      \t-- Go to next operand\
    \ value\n        -- If there is no next operand, then the result will be the initial\
    \ operand value\n        -- Otherwise, we will add the next operand value to the\
    \ result table\n      \telseif #operator == 1 then return operand[i]\n      \t\
    else result[#result + 1] = operand[i] end\n      \t-- Increment operator index\n\
    \        -- We don't need to increment it if it is already equal to the length\
    \ of the operator table\n      \toperator[#operator] = operator[#operator] + 1\
    \ \n      end\n    end\n  end\n  -- Return the final result from the result table\n\
    \  if #result > 0 then return result\n  -- Otherwise, return the initial operand\
    \ value\n  else return operand[1] end\nend", "    local result = {}\n    -- if\
    \ operator is not in operand table - exit\n    if #operand ~= #operator then return\
    \ nil end\n    -- if operator has only one operand (no multiplication or division)\
    \ - exit\n    if #operand == 1 then return operand[#operand] end\n    -- if operand[0]\
    \ is negative, subtract 1 from it\n    if operand[#operand] <= 0 then\n      \
    \  operand[#operand] = -operand[#operand]\n    end\n    -- loop through operator\
    \ table - do algebra operation\n    for idx = 1, #operator do\n        local value\
    \ = operand[#operand] * operator[#operator][idx]\n        if value < 0 then\n\
    \            value = -value\n        end\n        result[#result + 1] = value\n\
    \    end\n    return result\nend", "  -- Operator table is [\u2018+\u2019, \u2018\
    -\u2019, \u2018*\u2019, \u2018/\u2019, \u2018//\u2019, \u2018**\u2019].\n  --\
    \ Operand table is [2, 3, 4].\n  -- We assume that if operand table is empty then\
    \ return 1.\n  -- The basic algebra operations:\n  -- Addition ( + ) \n  -- Subtraction\
    \ ( - ) \n  -- Multiplication ( * ) \n  -- Floor division ( // ) \n  -- Exponentiation\
    \ ( ** ) \n  -- Example:\n  -- operator['+', '*', '-']\n  -- table = [2, 3, 4,\
    \ 5]\n  -- result = 2 + 3 * 4 - 5\n  -- => result = 9", "\t-- Initializing variables\
    \ to empty table to pass to recursive call. \n\tlocal left, right = operand[1],\
    \ operand[2]\n\tlocal rest, table_name = unpack(operand)\n\tlocal operator_name\
    \ = operator[1]", "   -- Write your code here\n   -- Write your code here\n  \
    \ -- Write your code here\n   -- Write your code here\n   -- Write your code here\n\
    \   -- Write your code here\n   -- Write your code here\n   -- Write your code\
    \ here\n   -- Write your code here\n   -- Write your code here\n   -- Write your\
    \ code here\n   -- Write your code here\n   -- Write your code here\n   -- Write\
    \ your code here\n   -- Write your code here\n   -- Write your code here\n   --\
    \ Write your code here\n   -- Write your code here\n   -- Write your code here\n\
    \   -- Write your code here\n   -- Write your code here\n   -- Write your code\
    \ here\n   -- Write your code here\n   -- Write your code here\n   -- Write your\
    \ code here\n   -- Write your code here\n   -- Write your code here\n   -- Write\
    \ your code here\n   -- Write your code here\n   -- Write your code here\n   --\
    \ Write your code here\n   -- Write your code here\n   -- Write your code here\n\
    \   -- Write your code here\n   -- Write your code here\n   -- Write your code\
    \ here\n   -- Write your code here\n   -- Write your code here\n   -- Write your\
    \ code here\n   -- Write your code here\n   -- Write your code here\n   -- Write\
    \ your code here\n   -- Write your code here\n   -- Write your code here\n   --\
    \ Write your code here\n   -- Write your code here\n   -- Write your code here\n\
    \   -- Write your code here\n   -- Write your code here\n   -- Write your code\
    \ here\n   -- Write your code here\n   -- Write your code here\n   -- Write your\
    \ code here\n   -- Write your code here\n   -- Write your code here\n   -- Write\
    \ your code here\n   -- Write your code here\n   -- Write your code here\n   --\
    \ Write your code here\n   -- Write your code here\n   -- Write your code here\n\
    \   -- Write your code here\n   -- Write your code here\n   -- Write your code\
    \ here\n   -- Write your code here\n   -- Write your code here\n   -- Write your\
    \ code here\n   -- Write your code here\n   -- Write your code here\n   -- Write\
    \ your code here\n   -- Write your code here\n   -- Write your code here\n   --\
    \ Write your code here\n   -- Write your code here\n   -- Write your code here\n\
    \   -- Write your code here\n   -- Write your code here\n   -- Write your code\
    \ here\n   -- Write your code here\n   -- Write your code here\n   -- Write your\
    \ code here\n   -- Write your code here\n   -- Write your code here\n   -- Write\
    \ your code here\n   -- Write your code here\n   -- ", "  local result = nil\n\
    \  local length = #operand\n  for i = 1, length - 1 do\n    result = result and\
    \ result or operand[i]\n    if operator[i] ~= nil then\n      local left, right\
    \ = operand[i], operand[i + 1]\n      local operation_function = operator[string.format(\"\
    %s\", tostring(operation_function))]\n      result = operation_function(left,\
    \ right)\n    end\n  end\n  return result\nend", "\tif #operator == 0 then\n\t\
    \treturn operand[1]\n\tend\n\tif #operand == 0 then\n\t\treturn do_algebra(operator,\
    \ operator)\n\tend\n\tlocal res = do_algebra(operator, operand[1])\n\tfor i =\
    \ 2, #operand do\n\t\tlocal temp = do_algebra(operator, operand[i])\n\t\tres =\
    \ operator[operator](res, temp)\n\tend\n\treturn res\nend", "  local operators\
    \ = { }\n  local result  = { }\n  -- Initialization\n  for i = 1, #operand do\n\
    \    operators[#operators + 1] = operator\n  end\n  -- Execute\n  for _, row in\
    \ ipairs(operand) do\n    -- Check whether the row is 0\n    if row == 0 then\n\
    \      return nil\n    end\n    -- If it is, then set result to row itself\n \
    \   -- Otherwise, perform the operation with row\n    for i = #operators, 1, -1\
    \ do\n      -- If this row is 0, stop the execution and return nil\n      if i\
    \ == 1 then\n        return nil\n      end\n      -- Get operator\n      local\
    \ operator = operators[i]\n      -- Get operand\n      local operand  = row\n\
    \      -- Execute the operation\n      -- If it does not exist, stop the execution\
    \ and return nil\n      if operators[#operators] ~= operator then\n        return\
    \ nil\n      end\n      -- Set the result as the result of the operation\n   \
    \   result = operators[#operators].function(result, operand)\n    end\n  end\n\
    \  -- Return result\n  return result\nend", "  local function recursive_evaluation(operand,\
    \ i, result)\n    local op = operator[i]\n    local right = operand[i + 1]\n \
    \   if op == nil then return result end\n    if op == '+' then \n      result\
    \ = result + right\n    elseif op == '-' then \n      result = result - right\n\
    \    elseif op == '*' then \n      result = result * right\n    elseif op == '/'\
    \ then \n      result = result // right\n    elseif op == '**' then \n      result\
    \ = result ** right\n    end\n    return recursive_evaluation(operand, i + 1,\
    \ result)\n  end\n  recursive_evaluation(operand, 0, 0)\nend", "  assert(#operand\
    \ > 1)\n  assert(#operator >= 1)\n  local result = 0\n  for i = 0, #operand -\
    \ 1 do\n    local op = operator[i]\n    local a = operand[i]\n    if op == \"\
    +\" then\n      result = a + result\n    elseif op == \"-\" then\n      result\
    \ = result - a\n    elseif op == \"*\" then\n      result = result * a\n    elseif\
    \ op == \"/\" then\n      result = result / a\n    elseif op == \"//\" then\n\
    \      result = result // a\n    elseif op == \"**\" then\n      result = result\
    \ ^ a\n    end\n  end\n  return result\nend", "   local result = 0\n   local operator_index\
    \ = 1\n   if #operand > 1 then\n      for i = 1, #operand do\n         -- To evaluate\
    \ the expression, the following steps are executed.\n         -- The current operand\
    \ is multiplied by operand table.\n         result = result + operand[i] * operand[i\
    \ - 1]\n         -- The current operator is applied to current operand and result\
    \ and result is added to the result.\n         result = operator[operator_index](result,\
    \ operand[i - 1])\n         operator_index = operator_index + 1\n      end\n \
    \  else\n      result = operand[0] * operator[operator_index]\n      operator_index\
    \ = operator_index + 1\n   end\n   return result\nend\n</cell>\n<code language=julia-0.5>\n\
    @time do_algebra(operator, table)\n</cell>\n<code language=julia-0.5>\n@time do_algebra(operator,\
    \ table)\n</cell>\n<code language=julia-0.5>\n@time do_algebra(operator, table)\n\
    </cell>\n<text>\nProblem 3\nThe aim of this problem is to optimize the arithmetic\
    \ expression given by the first table\ninto the arithmetic expression given by\
    \ the second table. Use the given tables first to build\nthe arithmetic expression\
    \ given by the second table and print the result. Use the given tables\nfirst\
    \ to build the arithmetic expression given by the second table and print the result.",
  "  -- Your code here.\n  return 0\nend", "  -- base case for recursion: stop condition\
    \ reached\n  if #operator == 1 then\n    return \n  end\n  local operator_i =\
    \ #operator\n  local operand_i = #operand\n  -- base case for recursion: operand\
    \ table empty\n  if operand_i == 0 then\n    return \n  end\n  -- base case for\
    \ recursion: operator table empty\n  if operator_i == 0 then\n    return \n  end\n\
    \  local operator = operator[operator_i - 1]\n  local operand = operand[operand_i\
    \ - 1]\n  -- recursive case\n  local result = do_algebra(operator, operand)\n\
    \  -- print operator and operand\n  io.write(operator)\n  io.write(\" = \")\n\
    \  io.write(tostring(operand))\n  -- print result of operation\n  io.write(\"\
    \ = \")\n  io.write(tostring(result))\n  -- return result\n  return result \n\
    end", "  local result = 1\n  for i=1, #operand do\n    local op = operator[i]\n\
    \    local operand1 = operand[i - 1]\n    local operand2 = operand[i]\n    if\
    \ op == '+' or op == '-' then\n      result = result + operand1 -- Addition or\
    \  Subtraction\n    elseif op == '*' or op == '/' then\n      result = result\
    \ * operand1 -- Multiplication\n    elseif op == '**' or op == '//' then\n   \
    \   result = result ^ operand1 -- Floor division\n    elseif op == '^' then\n\
    \      result = result ^ operand2 -- Exponentiation\n    end\n  end\n  return\
    \ result\nend\n</code>\nThen we can write a wrapper function to evaluate an expression\
    \ using the given operator table. Here's an example of how this might work:\n\
    <code>", "    local op1, op2 = unpack(operator)\n    local arg1, arg2 = unpack(operand)\n\
    \    local operators = {}\n    local results = {}\n    for i = 1, arg2 do\n  \
    \      local op1_c = op1\n        local op2_c = op2\n        if i ~= 1 then\n\
    \            if op1 ~= '^' then\n                op1_c = op1 .. '^' .. op2\n \
    \           end\n            if op2 ~= '^' then\n                op2_c = op2_c\n\
    \            end\n        end\n        if op1_c ~= op2_c then\n            results[#results\
    \ + 1] = op1_c .. op2_c\n        else\n            results[#results + 1] = '('\
    \ .. arg1 .. ')' .. op1_c\n        end\n    end\n    return unpack(results)\n\
    end", "  -- The algebric expression\n  local expr\n  \n  -- Get the number of\
    \ operands\n  local num_operands = #operand\n  \n  -- Get the number of operator\n\
    \  local num_operators = #operator\n  \n  -- Get the first operand from the operand\
    \ table\n  local first_operand = operand[1]\n  \n  -- The operand table is one\
    \ operand longer than the operator table. One operand is subtracted from the operand\
    \ table.\n  -- There are n operators, and n-1 = n operands.\n  local sub = num_operands\
    \ - 1\n  \n  -- Iterate through each operator in operator table\n  for i = 0,\
    \ num_operators - 1 do\n    -- Get the first operator from the operator table\n\
    \    local first_operator = operator[i]\n    \n    -- Get the second operand from\
    \ the operand table\n    local second_operand = operand[i + 2]\n    \n    -- Get\
    \ the operation from the operator table\n    local operation = operator[i]\n \
    \   \n    -- Perform the operation\n    local result = first_operand .. first_operator\
    \ .. second_operand\n    \n    -- Perform the operation\n    result = eval(result)\n\
    \    \n    -- Add the result to the current expression\n    expr = expr .. result\n\
    \    \n    -- If the current table has more operands, subtract one from n, which\
    \ becomes the new operand table\n    if sub > 0 then\n      -- Subtract one from\
    \ the number of operands\n      num_operands = num_operands - 1\n      \n    \
    \  -- Subtract one from the table of the operands\n      operand = operand[sub]\n\
    \    end\n  end\n  \n  -- Return the expression\n  return expr\nend", "\tlocal\
    \ operators = operator['+','-','*','/','%','**']\n\tlocal operator_count = #operators\
    \ + 1\n\tlocal result, tmp, next_index\n\tfor i = 1, #operand - 1 do\n\t\tresult\
    \ = result .. operators[next_index] .. operand[i]\n\t\tnext_index = next_index\
    \ + 1 if next_index < operator_count end\n\tend\n\treturn result\nend", "    local\
    \ res = {}\n    for i = 1, #operand do\n        local tmp = {}\n        for j\
    \ = 1, #operator do\n            table.insert(tmp, operator[j])\n        end\n\
    \        table.insert(res, #tmp + operator[#operator - 1] + operand[#operand -\
    \ 1 - i])\n    end\n    return res\nend", "  -- your code here\n  local expr =\
    \ 0\n  for i=1, #operand do\n    local temp = operand[i]\n    if temp == 0 then\n\
    \      error('invalid operand')\n    end\n    expr = expr + temp\n  end\n  for\
    \ i=1, #operator do\n    local temp = operator[i]\n    if temp == '+' or temp\
    \ == '-' or temp == '*' or temp == '/' or temp == '**' then\n      expr = expr\
    \ + temp\n    end\n  end\n  return expr\nend", "    local i, result = 0, {}\n\
    \    local operation_list = {unpack(operator)}\n    local result_table = {unpack(operand)}\n\
    \    local op_length = #operation_list\n    local op_length = #result_table\n\
    \    for i = 1, op_length do\n        if result_table[i] < 1 then\n          \
    \  print(\"Result table contains negative values.\")\n            return nil\n\
    \        end\n        result[#result + 1] = operation_list[i - 1] * result_table[i]\n\
    \    end\n    return unpack(result)\nend", "  local result = 1\n  \n  for i =\
    \ 1, #operand do\n    result = result*operand[i]\n  end\n  \n  local index = 1\n\
    \  \n  for op,v in pairs(operator) do\n    local tmp_result = result\n    \n \
    \   if index == 1 then\n      tmp_result = tmp_result\n    else\n      tmp_result\
    \ = tmp_result ^ operand[index]\n    end\n    \n    index = index + 1\n    result\
    \ = tmp_result\n  end\n  \n  return result\nend", "    local result = 0\n    for\
    \ i = 1, #operand - 1 do\n        local temp_result = operand[i]\n        for\
    \ k = i + 1, #operand do\n            local temp_operand = operand[k]\n      \
    \      temp_result = operator[temp_result, temp_operand]\n        end\n      \
    \  result = result + temp_result\n    end\n    return result\nend", "  assert(#operand\
    \ >= 1, 'operand table has at least one operand')\n  assert(#operator >= 1, 'operator\
    \ table has at least one operator')\n  if #operand == 1 then\n    return operand[0]\n\
    \  end\n  local result = 0\n  for i = 1, #operand do\n    local tmp = operand[i]\
    \ \n    local next_value = 0\n    for j = 1, #operator do\n      tmp = operator[j](\
    \ tmp, next_value)\n      next_value = next_value + 1\n    end\n    result = result\
    \ + tmp\n  end\n  return result\nend", "    local function add_tables(aa, bb)\n\
    \        local result = aa\n        for i = 1, #aa do\n            result = result\
    \ + bb[i]\n        end\n        return result\n    end\n    local function mul_tables(aa,\
    \ bb)\n        local result = 1\n        for i = 1, #aa do\n            result\
    \ = result * bb[i]\n        end\n        return result\n    end\n    local function\
    \ mod_tables(aa, bb)\n        local result = 1\n        for i = 1, #aa do\n  \
    \          result = result % bb[i]\n        end\n        return result\n    end\n\
    \    local function pow_tables(aa, bb)\n        local result = 1\n        for\
    \ i = 1, #aa do\n            result = result ^ bb[i]\n        end\n        return\
    \ result\n    end\n    local function exp_tables(aa, bb)\n        local result\
    \ = 1\n        for i = 1, #aa do\n            result = result ^ bb[i]\n      \
    \  end\n        return result\n    end\n    local function add_table(aa, bb)\n\
    \        return add_tables(aa, bb)\n    end\n    local function mul_table(aa,\
    \ bb)\n        return mul_tables(aa, bb)\n    end\n    local function mod_table(aa,\
    \ bb)\n        return mod_tables(aa, bb)\n    end\n    local function pow_table(aa,\
    \ bb)\n        return pow_tables(aa, bb)\n    end\n    local function exp_table(aa,\
    \ bb)\n        return exp_tables(aa, bb)\n    end\n    local result = add_table(operand[1],\
    \ operand[2])\n    for i = 2, #operand do\n        result = add_table(result,\
    \ mod_table(operator, operand[i]))\n    end\n    return pow_table(result, exp_table(operator,\
    \ operand[2]))\nend", "\tlocal result = operand[1]\n\tlocal length = #operand\n\
    \tfor i = 2, length do\n\t\tresult = operator[operator[1]](result, operand[i])\n\
    \tend\n\treturn result\nend", "\tif #operator == 0 and #operand == 0 then\n\t\t\
    return nil\n\tend\n\t\n\tlocal op\n\tlocal left\n\tlocal right\n\tlocal op1\n\t\
    local op2\n\tlocal val\n\tlocal result\n\t\n\top = operator[1]\n\t\n\tleft = operand[1]\n\
    \tright = operand[2]\n\t\n\tif op == \"+\" then\n\t\tresult = (left + right) \n\
    \telseif op == \"-\" then\n\t\tresult = (left - right) \n\telseif op == \"*\"\
    \ then\n\t\tresult = (left * right) \n\telseif op == \"/\" then\n\t\tresult =\
    \ (left / right) \n\telseif op == \"//\" then\n\t\tresult = (left // right)\n\t\
    elseif op == \"**\" then\n\t\tresult = (left ** right) \n\telse\n\t\terror(\"\
    Unknown operator in \" .. op)\n\tend\n\t\n\treturn result\nend", "  -- base case\n\
    \  if #operand == 1 then\n    return operand[1]\n  end", "    local result = 1\n\
    \    for i = 1, #operand do\n        result = (operator[operand[i]]) * (result\
    \ + operand[i])\n    end\n    return result\nend\n</code>\n<|/ a tags=lua,algorithm\
    \ dscore=0 |>\n<| c |>\nThank you for trying to help me, this is definitely an\
    \ interesting problem and I will try to research it.\n<|/ c |>\n<| a dscore=0\
    \ |>\nSo there are a few things to note:\nFirst, in the question you stated that\
    \ the number of operands is variable and that there can be no more or less than\
    \ 4 operators and a maximum of 4 operands.\nSecond, I believe that the question\
    \ specifically asks you to find the expression and its evaluation as the output\
    \ of a function. So, if you were to write a function that would take a number\
    \ of operands and an operator, you'd have to do some manipulation of the input\
    \ parameters to do what you are looking for. Below is an example of what I mean:\n\
    <code>", "  local result = 0\n  local table_size = #operator\n  assert(#operand\
    \ >= table_size, \"operand table is too short!\")\n  assert(table_size >= 1, \"\
    operator table is too short!\")\n  local num_operands = #operand\n  for i = 1,\
    \ num_operands do\n    -- Perform the operation on the operand.\n    result =\
    \ result + operand[i]\n  end\n  -- Perform the operation.\n  local operation =\
    \ operator[1]\n  result = operations[operation](result, table_size, num_operands)\n\
    \  -- Return the result.\n  return result\nend", "    if #operand == 0 then\n\
    \        return 0\n    end\n    if #operator > #operand - 1 then\n        return\
    \ 0\n    end\n    local expression = 0\n    local op_id = #operand\n    for i=1,\
    \ #operator do\n        local op = operator[i]\n        if op == '-' then\n  \
    \          expression = expression - operand[op_id+1]\n        elseif op == '+'\
    \ then\n            expression = expression + operand[op_id+1]\n        elseif\
    \ op == '*' then\n            expression = expression * operand[op_id+1]\n   \
    \     elseif op == '/' then\n            if #operand == 1 then\n             \
    \   return 0\n            end\n            expression = expression / operand[op_id+1]\n\
    \        elseif op == '//' then\n            if #operand == 1 then\n         \
    \       return 0\n            end\n            expression = expression // operand[op_id+1]\n\
    \        elseif op == '**' then\n            if #operand == 1 then\n         \
    \       return 0\n            end\n            expression = expression ** operand[op_id+1]\n\
    \        end\n        -- Do nothing\n    end\n    return expression\nend", " \
    \  assert(#operator == #operand - 1)\n   local result = 0\n   for i, v in pairs(operand)\
    \ do\n      result = result + operator[i] * v\n   end\n   return result\nend\n\
    </cell>\n<text>\nNow that we have defined the do_algebra function, we can use\
    \ it with the operators table and operand tables to get the desired result:",
  "    local result = 0\n    for i = 1, #operand-1 do\n        result = result + operand[i-1]\
    \ * operator[i]\n    end\n    return result + operand[#operand-1]\nend", "   \
    \ assert(#operand > 1)\n    assert(#operator > 1)", "   if #operator == 0 then\
    \ return 'error wrong number of operands'\n   if #operand == 0 then return 'error\
    \ wrong number of operators'\n   if #operand > #operator then return 'error wrong\
    \ number of operands'\n   if #operator == 1 and #operand == 1 then\n      local\
    \ function evaluate(operator, operand)\n         return operand_table[operator][operand]\n\
    \      end\n      local function add_table(table1, table2)\n         local result\
    \ = {}\n         for i = 1, #table1 do\n            result[i] = evaluate(table1[i],\
    \ table2[i])\n         end\n         return result\n      end\n      local function\
    \ sub_table(table1, table2)\n         local result = {}\n         for i = 1, #table1\
    \ do\n            result[i] = evaluate(table1[i], table2[i])\n         end\n \
    \        return result\n      end\n      local function mul_table(table1, table2)\n\
    \         local result = {}\n         for i = 1, #table1 do\n            result[i]\
    \ = evaluate(table1[i], table2[i])\n         end\n         return result\n   \
    \   end\n      local function div_table(table1, table2)\n         local result\
    \ = {}\n         for i = 1, #table1 do\n            result[i] = table1[i] / table2[i]\n\
    \         end\n         return result\n      end\n      local function exp_table(table1,\
    \ table2)\n         local result = {}\n         for i = 1, #table1 do\n      \
    \      result[i] = table1[i] ** table2[i]\n         end\n         return result\n\
    \      end\n      local function floordiv_table(table1, table2)\n         local\
    \ result = {}\n         for i = 1, #table1 do\n            result[i] = table1[i]\
    \ // table2[i]\n         end\n         return result\n      end\n      local function\
    \ pow_table(table1, table2)\n         local result = {}\n         for i = 1, #table1\
    \ do\n            result[i] = pow(table1[i], table2[i])\n         end\n      \
    \   return result\n      end\n      local result = add_table(operator, operand)\n\
    \      return result\n   elseif #operator == 1 and #operand == 2 then\n      local\
    \ function evaluate(operator, operand)\n         local functions = {\n       \
    \     add, sub_table, mul_table, div_table, exp_table, floordiv_table, pow_table\n\
    \         }\n         return functions[operator](operand_table[operator][operand],\
    \ operand_table[operator][operand])\n      end\n      local function add_table(table1,\
    \ table2)\n         local result = {}\n         for i = 1, #table1 do\n      \
    \      result[i] = evaluate(table1[i], table2[i])\n         end\n         return\
    \ result", "    -- Write your code here\n    local algebric_expr = {}\n    for\
    \ i, v in pairs(operand) do\n        algebric_expr[#algebric_expr+1] = '('..i..')'\n\
    \    end\n    for i, v in pairs(operator) do\n        algebric_expr[#algebric_expr+1]\
    \ = '('..algebric_expr[#algebric_expr+1] .. '+' .. v .. ')'\n    end\n    local\
    \ expression = table.concat(algebric_expr, ' + ')\n    return expression\nend\n\
    print(do_algebra(operator, operand))", "    -- TODO: This solution can only handle\
    \ addition right now.\n    -- TODO: Modify do_algebra to handle other arithmetic\
    \ operators.\n    local tmp_operand = { table.unpack(operand) }\n    local tmp_dest_operator\
    \ = { table.unpack(operator) }\n    local tmp_result_operator = { 0 }\n    local\
    \ tmp_result = { 0 }\n    local tmp_result_operand = { 0 }\n    local tmp_result_operand1\
    \ = { 0 }\n    local tmp_result_operand2 = { 0 }\n    local tmp_result_operand3\
    \ = { 0 }\n    local tmp_result_operand4 = { 0 }\n    local tmp_result_operand5\
    \ = { 0 }\n    local tmp_result_operand6 = { 0 }\n    local tmp_result_operand7\
    \ = { 0 }\n    local tmp_result_operand8 = { 0 }\n    local tmp_result_operand9\
    \ = { 0 }\n    local tmp_result_operand10 = { 0 }\n    local tmp_result_operand11\
    \ = { 0 }\n    local tmp_result_operand12 = { 0 }\n    local tmp_result_operand13\
    \ = { 0 }\n    local tmp_result_operand14 = { 0 }\n    local tmp_result_operand15\
    \ = { 0 }\n    local tmp_result_operand16 = { 0 }\n    local tmp_result_operand17\
    \ = { 0 }\n    local tmp_result_operand18 = { 0 }\n    local tmp_result_operand19\
    \ = { 0 }\n    local tmp_result_operand20 = { 0 }\n    local tmp_result_operand21\
    \ = { 0 }\n    local tmp_result_operand22 = { 0 }\n    local tmp_result_operand23\
    \ = { 0 }\n    local tmp_result_operand24 = { 0 }\n    local tmp_result_operand25\
    \ = { 0 }\n    local tmp_result_operand26 = { 0 }\n    local tmp_result_operand27\
    \ = { 0 }\n    local tmp_result_operand28 = { 0 }\n    local tmp_result_operand29\
    \ = { 0 }\n    local tmp_result_operand30 = { 0 }\n    local tmp_result_operand31\
    \ = { 0 }\n    local tmp_result_operand32 = { 0 }\n    local tmp_result_operand33\
    \ = { 0 }\n    local tmp_result_operand34 = { 0 }\n    local tmp_result_operand35\
    \ = { 0 }\n    local tmp_result_operand36 = { 0 }\n    local tmp_result_operand37\
    \ = { 0 }\n    local tmp_result_operand38 = { 0 }\n    local tmp_result_operand39\
    \ = { 0 }\n    local tmp_result_operand40 = { 0 }\n    local ", "    -- Add your\
    \ implementation here\n    local temp = 1\n    for i = 1, #operand do\n      \
    \  temp = temp * operand[i]\n    end\n    return temp\nend", "  local result =\
    \ operand[1]\n  for i = 2, #operand do\n    result = operator[operator[operand[i-1]]]\
    \ \n  end\n  return result\nend", "  local result = operand[1]\n  for i = 2, #operand\
    \ do\n    result = tableops.binary_ops(result, operand[i], operator)\n  end\n\
    \  return result\nend", "    local operation = operator[1]\n    local operand1\
    \ = operand[1]\n    local operand2 = operand[2]", "\tlocal result = 0\n\tfor i\
    \ = 1, #operand do \n\t\tlocal lhs, rhs = operand[i-1], operand[i]\n\t\tresult\
    \ = result + operators[operator](lhs, rhs)\n\tend\n\treturn result\nend", "\t\
    local result = 0\n\tfor i, v in pairs(operator) do\n\t\tif i == 2 then\n\t\t\t\
    local a, b = operand[1], operand[2]\n\t\t\tif v == \"+\" then\n\t\t\t\tresult\
    \ = result + a\n\t\t\telseif v == \"-\" then\n\t\t\t\tresult = result - a\n\t\t\
    \telseif v == \"*\" then\n\t\t\t\tresult = result * a\n\t\t\telseif v == \"/\"\
    \ then\n\t\t\t\tresult = result / a\n\t\t\telseif v == \"**\" then\n\t\t\t\tresult\
    \ = result ** a\n\t\t\tend\n\t\telse\n\t\t\tif operand[i] == nil then\n\t\t\t\t\
    print(string.format(\"invalid operand[%s] from table for operator[%s]\", v, i))\n\
    \t\t\telse\n\t\t\t\tresult = result + operand[i]\n\t\t\tend\n\t\tend\n\tend\n\t\
    return result\nend\nprint(do_algebra(operator, operand))", "    assert(#operand\
    \ == #operator)\n    assert(#operand > 1)\n    assert(#operator > 0)", "    local\
    \ result_string = \"\"\n    local operator_num = #operator", "\t-- base case:\
    \ empty operator/operand table\n\tif not operator or not operand then\n\t\treturn\
    \ nil, nil\n\tend\n\t\n\t-- base case: operand = nil\n\tif #operand == 0 then\n\
    \t\treturn nil, nil\n\tend\n\t\n\t-- base case: operator = nil\n\tif #operator\
    \ == 0 then\n\t\tlocal result = table[0]\n\t\tfor i = 1, #operand do\n\t\t\tresult\
    \ = operator[#operator + 1](result, operand[i])\n\t\tend\n\t\treturn result, nil\n\
    \tend\n\t\n\t-- base case: operator and operand table lengths differ by 1\n\t\
    if #operator ~= #operand - 1 then\n\t\treturn nil, \"Error: Operator and operand\
    \ table lengths differ by one (operand: \" .. #operand .. \", operator: \" ..\
    \ #operator .. \")\"\n\tend\n\t\n\t-- base case: table lengths match\n\tlocal\
    \ result = table[1]\n\tfor i = 2, #table do\n\t\tlocal operation = table[i]\n\t\
    \tlocal operand = operand[i + 1]\n\t\tif operation == '+' then\n\t\t\tresult =\
    \ operator[#operator + 1](result, operand)\n\t\telseif operation == '-' then\n\
    \t\t\tresult = operator[#operator + 1](result, -operand)\n\t\telseif operation\
    \ == '*' then\n\t\t\tresult = operator[#operator + 1](result, operand)\n\t\telseif\
    \ operation == '/' then\n\t\t\tlocal div = operand\n\t\t\tif not div == 0 then\n\
    \t\t\t\tresult = operator[#operator + 1](result, div)\n\t\t\telse\n\t\t\t\treturn\
    \ nil, \"Error: Floor division by zero\"\n\t\t\tend\n\t\telseif operation == '%'\
    \ then\n\t\t\tlocal div = operand\n\t\t\tif not div == 0 then\n\t\t\t\tresult\
    \ = operator[#operator + 1](result, div)\n\t\t\telse\n\t\t\t\tresult = operator[#operator\
    \ + 1](result, 0)\n\t\t\tend\n\t\telseif operation == '**' then\n\t\t\tlocal exponent\
    \ = operand\n\t\t\tif not exponent == 0 then\n\t\t\t\tresult = operator[#operator\
    \ + 1](result, exponent)\n\t\t\telse\n\t\t\t\treturn nil, \"Error: Exponentiation\
    \ by zero\"\n\t\t\tend\n\t\telse\n\t\t\treturn nil, \"Error: Invalid operator\
    \ in operand table\"\n\t\tend\n\tend\n\treturn result, nil\nend", "  local table_length\
    \ = #operator\n  assert(#operand >= table_length, \"Error: the length of operand\
    \ table must be >= to length of operator table minus one.\" )\n  local result,\
    \ temp1, temp2 = {}, {}, {}\n  for i = 1, table_length do\n    local oper, operand1,\
    \ operand2 = operator[i], operand[i-1], operand[i]\n    if oper == '+' or oper\
    \ == '*' or oper == '-' then\n      temp1[#temp1 + 1] = operand1\n      temp2[#temp2\
    \ + 1] = operand2\n      result = temp1[#temp1 + 1] + temp2[#temp2 + 1]\n    elseif\
    \ oper == '//' or oper == '**' then\n      temp1[#temp1 + 1] = operand1\n    \
    \  temp2[#temp2 + 1] = operand2\n      result = temp1[#temp1 + 1] // temp2[#temp2\
    \ + 1]\n    else\n      error('Error: the operator must be + | - | / | // ** ')\n\
    \    end\n  end\n  return result\nend", "  -- Basic algebra operations:\n  local\
    \ op_plus = {}\n  local op_minus = {}\n  local op_times = {}\n  local op_floordiv\
    \ = {}\n  local op_pow = {}\n  local op_exp = {}\n  local op_sin = {}\n  local\
    \ op_cos = {}\n  local op_tan = {}\n  local op_sinh = {}\n  local op_cosh = {}\n\
    \  local op_tanh = {}\n  local op_sinh2 = {}\n  local op_cosh2 = {}\n  local op_tanh2\
    \ = {}\n  local op_sum = {}\n  local op_div = {}\n  local op_min = {}\n  local\
    \ op_max = {}\n  local op_mod = {}\n  local op_len = {}\n  local op_len2 = {}\n\
    \  local op_size = {}\n  local op_size2 = {}\n  local op_index = {}\n  local op_eq\
    \ = {}\n  local op_neq = {}\n  local op_gt = {}\n  local op_lt = {}\n  local op_gte\
    \ = {}\n  local op_lte = {}\n  local op_and = {}\n  local op_or = {}\n  local\
    \ op_andnot = {}\n  local op_ornot = {}\n  local op_bitand = {}\n  local op_bitor\
    \ = {}\n  local op_bitxor = {}\n  local op_equals = {}\n  local op_noteq = {}\n\
    \  local op_eqeq = {}\n  local op_neqeq = {}\n  local op_isfalse = {}\n  local\
    \ op_istrue = {}\n  local op_branches = {}\n  local op_branches2 = {}", "    local\
    \ operator = operator[1]\n    local operand1 = operand[1]\n    local operand2\
    \ = operand[2]\n    if operator == '+' then\n        return operand1 + operand2\n\
    \    end\n    if operator == '-' then\n        return operand1 - operand2\n  \
    \  end\n    if operator == '*' then\n        return operand1 * operand2\n    end\n\
    \    if operator == '//' then\n        return operand1 // operand2\n    end\n\
    \    if operator == '**' then\n        return operand1 ^ operand2\n    end\nend",
  "\t-- First, find the length of the operand table minus one.\n\tlocal len1 = #operand-1\n\
    \t-- Iterate through the operand table and calculate the result for each one.\n\
    \tfor i = 1, #operand do\n\t\t-- Find the length of operand and operator tables.\n\
    \t\tlocal len2 = #operand+#operator-1\n\t\t-- Find if all the operators in the\
    \ operator table are found in the operand table.\n\t\tif len2 > 0 then\n\t\t\t\
    local flag = true\n\t\t\tfor j = 1, #operator do\n\t\t\t\tlocal found = false\n\
    \t\t\t\tfor k = 1, #operand do\n\t\t\t\t\t-- Find the index of operand and operator\
    \ tables.\n\t\t\t\t\tlocal index = (k-1)*#operand+j\n\t\t\t\t\t-- If the current\
    \ element of the operand table and the current element of the operator table\n\
    \t\t\t\t\t-- are equal.\n\t\t\t\t\tif operand[index] == operand[k] then\n\t\t\t\
    \t\t\tfound = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t--\
    \ Check if the operator is found.\n\t\t\t\tif found then\n\t\t\t\t\tflag = false\n\
    \t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\t-- If the flag is true, then the\
    \ operator is found at index k, and we can start calculating the result.\n\t\t\
    \tif flag then\n\t\t\t\t-- If the result is negative, then the result is also\
    \ negative.\n\t\t\t\tif operator[#operator] == '+' and operand[len1] < 0 then\n\
    \t\t\t\t\toperand[len1] = operand[len1] + operand[len1]\n\t\t\t\t\t-- the operand\
    \ table has one less element, subtract it from operand table\n\t\t\t\t\t-- to\
    \ keep the same length of operand table.\n\t\t\t\t\tlen1 = len1 - 1\n\t\t\t\t\t\
    -- Find the length of the operand table minus one.\n\t\t\t\t\tlocal len2 = #operand-1\n\
    \t\t\t\t\t-- Iterate through the operand table and calculate the result for each\
    \ one.\n\t\t\t\t\tfor i = 1, #operand do\n\t\t\t\t\t\t-- Find the length of operand\
    \ and operator tables.\n\t\t\t\t\t\tlocal len2 = #operand+#operator-1\n\t\t\t\t\
    \t\t-- Find if all the operators in the operator table are found in the operand\
    \ table.\n\t\t\t\t\t\tif len2 > 0 then\n\t\t\t\t\t\t\tlocal flag = true\n\t\t\t\
    \t\t\t\tfor j = 1, #operator do\n\t\t\t\t\t\t\t\tlocal found = false\n\t\t\t\t\
    \t\t\t\tfor k = 1, #operand do\n\t\t\t\t\t\t\t\t\t-- Find the index of operand\
    \ and operator tables.\n\t\t\t\t\t\t\t\t\tlocal index = (k-1)*#operand+j\n\t\t\
    \t\t\t\t\t\t\t-- If the current element of the operand table and the current element\
    \ of the operator table\n\t\t\t\t\t\t\t\t\t-- are equal.\n\t\t\t\t\t\t\t\t\tif\
    \ operand[index] == operand[k] then\n\t\t\t\t\t\t\t\t\t\tfound = true\n\t\t\t\t\
    \t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\
    -- Check if the operator is found.\n\t\t\t\t\t\t\t\tif found then\n\t\t\t\t\t\t\
    \t\t\tflag = false\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\
    \tend\n\t\t\t\t\t\t\t-- If the flag is true, then the operator is found at index\
    \ k, and we can start calculating the result.\n\t\t\t\t\t\t\tif flag then\n\t\t\
    \t\t\t\t\t\t", "  local function add_ops(t1, t2)\n    return t1 + t2 - t1 * t2\n\
    \  end\n  local function sub_ops(t1, t2)\n    return t1 - t2 + t1 * t2\n  end\n\
    \  local function mul_ops(t1, t2)\n    return t1 * t2 \n  end\n  local function\
    \ floor_div_ops(t1, t2)\n    return t1 // t2 \n  end\n  local function exp_ops(t1,\
    \ t2)\n    return t1 ^ t2 \n  end\n  local function pow_ops(t1, t2)\n    return\
    \ t1 ^ t2 \n  end\n  local ops = {add_ops, sub_ops, mul_ops, floor_div_ops, exp_ops,\
    \ pow_ops}\n  local function do_op(op, t1, t2)\n    if ops[op] == nil then\n \
    \     return nil\n    else\n      return ops[op](t1, t2)\n    end\n  end\n  local\
    \ function do_op_with_table(op, t1, t2)\n    if op == nil then\n      return nil\n\
    \    elseif op ~= '*' and op ~= '//' then\n      return do_op(op, t1, t2)\n  \
    \  else\n      local op = op\n      local op = op == '//' and floor_div_ops or\
    \ op == '**' and pow_ops or exp_ops\n      local r = do_op(op, t1, t2)\n     \
    \ if r == nil then\n        return nil\n      elseif op == '*' or op == '//' or\
    \ op == '**' then\n        return r\n      else\n        return do_op_with_table(op,\
    \ r[1], r[2])\n      end\n    end\n  end\n  if #operator == #operand then\n  \
    \  return do_op_with_table(operator[1], operand[1], operand[2])\n  else\n    return\
    \ nil\n  end\nend\n</cell>\n<text>\nProblem 3\nWrite a function that calculates\
    \ the floor division of two integers. Assume that the two integers are greater\
    \ than or equal to 0.", "    if #operand == 0 then\n        return 0\n    end\n\
    \    if #operator == 0 then\n        return 0\n    end\n    if #operand ~= #operator\
    \ then\n        return 0\n    end\n    local result = operand[1]\n    for i =\
    \ 2, #operand do\n        result = operator[operator[i]](result, operand[i])\n\
    \    end\n    return result\nend", "    local new_operand = {}\n    local operators\
    \ = {}", "  local result = nil\n  local len1, len2 = #operator, #operand", " \
    \ if #operator ~= #operand then return false end\n  local function do_operation(operator,\
    \ operand)\n    if type(operator) ~= 'table' then return false end\n    local\
    \ function do_operator(operator)\n      if type(operator) == 'table' then\n  \
    \      local result = {}\n        for i = 1, #operand do\n          table.insert(result,\
    \ do_operation(operator[i], operand[i]))\n        end\n        return result\n\
    \      else\n        return operator[operand]\n      end\n    end\n    return\
    \ do_operator(operator)\n  end\n  return do_operation(operator, operand)\nend",
  "    local new_operator = {}\n    local new_operand = {}\n    -- We keep one operator\
    \ and one operand for now.\n    new_operator[1] = operator[1]\n    new_operand[1]\
    \ = operand[1]\n    -- We start with the second operand and keep looping.\n  \
    \  for i = 2, #operand do\n        -- We find the element in the operator table\
    \ that corresponds to the current operand.\n        local element_index = #new_operator\n\
    \        for k = 1, #operator do\n            if operator[k] == new_operand[i]\
    \ then\n                element_index = k\n                break\n           \
    \ end\n        end\n        -- We add the current operand to the operand table.\n\
    \        new_operand[i] = new_operand[i] + (new_operator[element_index])\n   \
    \     -- We update the operator table.\n        new_operator[element_index] =\
    \ new_operator[element_index] + (-1)\n    end\n    -- We find the element in the\
    \ operator table that corresponds to the first operand.\n    local element_index\
    \ = #new_operator\n    local result = new_operand[1]\n    -- We start with the\
    \ second operator and keep looping.\n    for i = 2, #operator do\n        -- We\
    \ find the element in the operand table that corresponds to the current operator.\n\
    \        local element_index = #new_operand\n        for k = 1, #operand do\n\
    \            if new_operator[k] == new_operand[i - 1] then\n                element_index\
    \ = k\n                break\n            end\n        end\n        -- We add\
    \ the current operator to the operand table.\n        result = new_operator[element_index]\
    \ + ((new_operator[element_index] - 1) * result + new_operand[i - 1])\n      \
    \  -- We update the operator table.\n        new_operator[element_index] = new_operator[element_index]\
    \ + (-1)\n    end\n    return result\nend", "   local res = {}\n   for i = 1,\
    \ #operand do\n      res[i] = operand[i] + operand[#operand + i] \n      -- TODO:\
    \ Evaluate and subtract each operand and store it in res.\n   end\n   return res\n\
    end", "    local result_table = {}\n    local ops = operator\n    for idx, i in\
    \ ipairs(operand) do\n        result_table[idx] = operand[idx] * operand[idx]\n\
    \    end\n    for idx, i in ipairs(ops) do\n        result_table[idx] = result_table[idx]\
    \ ^ operand[idx]\n    end\n    for idx, i in ipairs(operand) do\n        result_table[idx]\
    \ = result_table[idx] ^ operand[idx]\n    end\n    return result_table\nend",
  "\t-- The result of the algebraic operation.\n\tlocal result = nil\n\t-- The operator\
    \ table.\n\tlocal op_table = operator\n\t-- The number of operands.\n\tlocal num_operands\
    \ = #operand\n\t-- The index of the first operand in the operand table.\n\tlocal\
    \ first_operand = 0\n\t-- The index of the operator in the operator table.\n\t\
    local operator_index = nil\n\t-- The index of the last operand in the operand\
    \ table.\n\tlocal last_operand = num_operands - 1", "\t-- Check number of operators\
    \ and operands.\n\tassert(#operator == #operand)\n\t\n\t-- Compute the answer\
    \ and return it.\n\treturn operator[#operator](operand[1], operand[2])\nend\n\
    </cell>\n<text>\n3.1 Tests", "    assert(operator)\n    assert(operand)\n    --\
    \ The length of operator table must be greater than or equal to length of operand\
    \ table minus one.\n    assert(#operator >= #operand)\n    local result = operand[1]\n\
    \    for i=2, #operand do\n        result = operator[operator[result], operand[i]]\n\
    \    end\n    return result\nend", "   local operator_count = #operator\n   local\
    \ result_operator, result_operand", "    assert(#operand == #operator)\n    local\
    \ result = operand[1]\n    for i = 2, #operand do\n        result = operator[operator[result],\
    \ operand[i]]\n    end\n    return result\nend", "\tif operator[1] ~= nil then\
    \ -- If the operator table has at least one operator. \n\t\tlocal operand1 = operand[1]\n\
    \t\tif operand2 ~= nil then -- If the operand table has at least one operand.\n\
    \t\t\tif operator[1] ~= nil then -- If the operator table has at least one operator.\
    \ \n\t\t\t\tlocal operand2 = operand[2]\n\t\t\t\tif operand1 ~= nil then -- If\
    \ the operand table has at least one operand.\n\t\t\t\t\tlocal result = operand1\n\
    \t\t\t\t\tfor i = 2, #operand do -- Loop through all the operands after the first.\
    \ \n\t\t\t\t\t\tresult = operator[operator[1]](result, operand[i]) -- Perform\
    \ the operator on the operand and store the result in result. \n\t\t\t\t\tend\n\
    \t\t\t\t\treturn result\n\t\t\t\telse\n\t\t\t\t\treturn nil\n\t\t\t\tend\n\t\t\
    \tend\n\t\tend\n\tend\nend", "  local nx = #operand - 1\n  local ny = #operand\
    \ - 1\n  local result = operand[1]\n  for i = 2, nx do\n    local tmp = 1\n  \
    \  for j = 1, ny do\n      tmp = (tmp * operand[j]) + result\n    end\n    result\
    \ = operator[#operator](tmp, result)\n  end\n  return result\nend", "\tlocal temp_operand\
    \ = operand[1]\n\tlocal temp_operator = operator[1]\n\tlocal temp_result = operand[1]\n\
    \tlocal op_index = 1\n\tlocal i = 1\n\t\n\twhile i < #operand do\n\t\tif operand[i]\
    \ == 0 then\n\t\t\t-- The result of the expression is 0.\n\t\t\treturn 0\n\t\t\
    else\n\t\t\t-- Add the operand to the result and adjust the operand.\n\t\t\tlocal\
    \ temp = temp_result + temp_operand * temp_operator\n\t\t\ttemp_result = temp\n\
    \t\t\ttemp_operand = operand[i]\n\t\tend\n\t\ti = i + 1\n\tend\n\t\n\t-- The result\
    \ of the expression is temp_result.\n\treturn temp_result\nend", "\t-- Checks\
    \ if the lengths of operator and operand tables match.\n\tif #operator ~= #operand\
    \ then return nil end\n\t\n\t-- Builds the basic algebra expression and return\
    \ the evaluation.\n\tlocal result = operand[1]\n\tfor i = 2, #operand do\n\t\t\
    result = result .. operator[operand[i-1], operand[i]]\n\tend\n\treturn result\n\
    end", "\tif #operand < 2 then\n\t\treturn nil, \"Invalid operand table: missing\
    \ operand\"\n\tend", "\tlocal result = operand[1]\n\tfor _, v in pairs(operand)\
    \ do\n\t\tresult = operator[operator[1]](result, v)\n\tend\n\treturn result\n\
    end", "\t-- Precondition: \n\t-- The length of operator table is equal to the\
    \ length of operand table minus one.\n\t-- Operand is a table of of non-negative\
    \ integers.\n\t-- Operator table has at least one operator, and operand table\
    \ has at least two operands.\n\tlocal operatorLength = table.getn(operator)\n\t\
    local operandLength = table.getn(operand)\n\tlocal length = math.max(operatorLength,\
    \ operandLength)", "   -- The variable 'result' will store the final answer.\n\
    \   local result = nil\n   -- If the operator is nil, then raise an error.\n \
    \  if operator == nil then\n      print('The first parameter must be a table')\n\
    \      return\n   end\n   -- If the operand is nil, then raise an error.\n   if\
    \ operand == nil then\n      print('The second parameter must be a table')\n \
    \     return\n   end\n   -- If both operand and operator are nil, then raise an\
    \ error.\n   if #operator == 0 and #operand == 0 then\n      print('The first\
    \ and second parameters cannot be nil.')\n      return\n   end\n   -- If there\
    \ are not enough operand and operator table, then raise an error.\n   if #operand\
    \ - 1 ~= #operator - 1 then\n      print('The operand and operator tables must\
    \ be of equal length.')\n      return\n   end\n   -- If the length of the operator\
    \ table is less than 2, then raise an error.\n   if #operator < 2 then\n     \
    \ print('The operator table must have at least 2 elements.')\n      return\n \
    \  end\n   -- If the length of the operand table is less than 2, then raise an\
    \ error.\n   if #operand - 1 < 2 then\n      print('The operand table must have\
    \ at least 2 elements.')\n      return\n   end\n   -- Add up the value at each\
    \ index of the operand table and build the expression.\n   for i = 1, #operand\
    \ - 1 do\n      -- Add the value of the current operand to the sum.\n      result\
    \ = result + operand[i-1]\n   end\n   -- Add the value of the current operator\
    \ to the sum.\n   result = result + operator[1]\n   -- Multiply the final result\
    \ by each element of the operand table.\n   for i = 2, #operand do\n      -- Add\
    \ the current value of the operand to the sum.\n      result = result * operand[i]\n\
    \   end\n   -- Return the final result.\n   return result\nend", "    local result\
    \ = {}\n    local num_ops = #operator\n    local num_operands = #operand", " \
    \   local table_length = #operator\n    local result_length = #operand", "\t--\
    \ TODO: Implement the algebric expression\n\treturn nil\nend", "    -- your code\
    \ goes here\nend", "    local result = 0\n    local op_index = 1\n    local op_index2\
    \ = 1\n    local op_index3 = 1\n    local op_index4 = 1", "   local op_length\
    \ = #operator\n   local op_table = { }\n   local op_table_length = #op_table",
  "   local oper = operator[1]\n   local oper2 = operand[1]\n   local oper3 = operand[2]\n\
    \   local oper4 = operand[3]\n   local oper5 = operand[4]\n   local oper6 = operand[5]",
  "    local table = {} -- Table of basic algebra operations\n    local table2 = {}\
    \ -- Table of integers\n    for i=1, #operator do\n        table.insert(table,\
    \ operator[i])\n    end\n    for i=1, #operand do\n        table2.insert(table2,\
    \ operand[i])\n    end\n    local result = 0 -- The answer to the algebraic expression\n\
    \    local i = 0 -- Counter for basic algebra operations\n    local j = 0 -- Counter\
    \ for integers\n    while i < #table and j < #table2 do\n        if table[i] ==\
    \ table2[j] then\n            result = result + (table2[j] * (table[i + 1]))\n\
    \            j = j + 1\n        elseif table[i] == '-' then\n            result\
    \ = result + ((-1) * table2[j])\n            j = j + 1\n        elseif table[i]\
    \ == '+' then\n            result = result + (table2[j])\n            j = j +\
    \ 1\n        elseif table[i] == '*' then\n            result = result + (table2[j]\
    \ * (table[i + 1]))\n            i = i + 1\n        elseif table[i] == '//' then\n\
    \            result = result + (table2[j] / table[i + 1])\n            i = i +\
    \ 1\n        elseif table[i] == '**' then\n            result = result + (table2[j]\
    \ ** table[i + 1])\n            i = i + 1\n        end\n    end\n    return result\n\
    end", "    if operator['+'] == nil then\n        error() -- Operand must have\
    \ at least one element.\n    end\n    if operand['*'] == nil then\n        error()\
    \ -- Operand must have at least one element.\n    end\n    if #operand['-'] >\
    \ #operator['+'] then\n        error() -- Operator must have more that one element.\n\
    \    end\n    if #operand['-'] < #operand['*'] then\n        error() -- Operand\
    \ must have more that one element.\n    end", "  local result = {}\n  local length\
    \ = 1\n  local op = {}\n  while length < #operator do\n    length = length + 1\n\
    \  end\n  while length >= #operand do\n    length = length - 1\n  end\n  local\
    \ j = 0\n  while j < (#operator - 1) do\n    local k = length\n    while k >=\
    \ #operand do\n      k = k - 1\n    end\n    local key = operator[j]\n    if key\
    \ ~= nil then\n      local value = operand[k + 1]\n      result[key] = result[key]\
    \ ~= nil and result[key] + value or value\n    end\n    j = j + 1\n  end\n  return\
    \ result\nend", "\tlocal operand_length = #operand\n\tlocal operator_length =\
    \ #operator", "    assert(type(operator) == 'table')\n    assert(type(operand)\
    \ == 'table')\n    assert(#operand == #operator - 1)\n    assert(#operand > 0)\n\
    \    assert(#operator > 0)", "    local result = 0\n    local length = #operator\n\
    \    for i=1,#operand do\n        local tmp = 0\n        for j=1,#operator do\n\
    \            tmp = tmp + operator[j] * operand[i+1-j]\n        end\n        result\
    \ = result + tmp\n    end\n    return result\nend", "\t-- Return the result of\
    \ algebraic expression.\n\tlocal result = operator[1]\n\t\n\t-- Add operands.\n\
    \tfor i=2,#operand do\n\t\tresult = result + operator[i] * operand[i-1]\n\tend",
  "\tlocal table_size = #operator + 1\n\tlocal result = 0\n\tfor i = 1, table_size-1\
    \ do\n\t\tlocal left = operand[i]\n\t\tlocal right = operand[i+1]\n\t\tlocal operation\
    \ = operator[i]\n\t\tif operation == '+' then\n\t\t\tresult = result + right\n\
    \t\telseif operation == '*' then\n\t\t\tresult = result * right\n\t\telseif operation\
    \ == '-' then\n\t\t\tresult = result - right\n\t\telseif operation == '/' then\n\
    \t\t\tresult = result / right\n\t\telseif operation == '//' then\n\t\t\tresult\
    \ = result // right\n\t\telseif operation == '**' then\n\t\t\tresult = result\
    \ ^ right\n\t\tend\n\tend\n\treturn result\nend", "    -- Operate on each pair\
    \ of operands, one from each table.\n    local ops = {} -- Maps each operator\
    \ to the result of the operation.\n    for _, v in pairs(operand) do\n       \
    \ ops[operator] = v\n    end\n    return ops\nend", "    local operator_index\
    \ = table.getn(operator)\n    local operand2_index = table.getn(operand) - 1 \n\
    \    local result_table = {}\n    local i, operand_value, operator_value\n   \
    \ for i = 1, operand2_index do\n        operand_value = operand[i][2]\n      \
    \  operator_value = operator[operand[i][1]]\n        result_table[i] = operand_value\
    \ * operator_value\n    end\n    return result_table\nend", "    -- Compute the\
    \ evaluation of this expression.\n    local function eval(op1, op2)\n        return\
    \ op1 .. op2 \n    end\n    -- Check if the given operand is valid for the given\
    \ operator.\n    local function is_valid(operand, operator)\n        local valid_operand\
    \ = operators[operator]\n        if not valid_operand then\n            print('Invalid\
    \ operator: ' .. operator)\n        end\n        return valid_operand(operand)\
    \ -- return true if operand is valid.\n    end\n    -- Check if both operands\
    \ are valid.\n    local function is_valid_operands(operand1, operator1, operand2,\
    \ operator2)\n        return is_valid(operand1, operator1) and is_valid(operand2,\
    \ operator2)\n    end\n    -- Compute the final result with the two operands valid\
    \ for the given operator.\n    local function compute(operator, operand1, operand2)\n\
    \        if operators[operator] then\n            return operators[operator](operand1,\
    \ operand2)\n        end\n    end\n    -- Compute the evaluation with the first\
    \ operand valid and the second operand valid.\n    if is_valid_operands(operand[1],\
    \ operator, operand[2], operator) then\n        return compute(operator, operand[1],\
    \ operand[2])\n    end\n    -- Compute the evaluation with the second operand\
    \ valid and the first operand valid.\n    if is_valid_operands(operand[2], operator,\
    \ operand[1], operator) then\n        return compute(operator, operand[2], operand[1])\n\
    \    end\n    -- Otherwise, give an error message.\n    print('Invalid operands:\
    \ ' .. #operand .. ' operands, ' .. #operator .. ' operators.')\n    return nil\n\
    end", "\tlocal function operate(operator, operand1, operand2)\n\t\tif operator\
    \ == '+' and operand1 == nil then\n\t\t\tif operand2 == nil then\n\t\t\t\treturn\
    \ operand2\n\t\t\telse\n\t\t\t\treturn operand1 + operand2\n\t\t\tend\n\t\telseif\
    \ operator == '-' and operand1 == nil then\n\t\t\tif operand2 == nil then\n\t\t\
    \t\treturn -operand2\n\t\t\telse\n\t\t\t\treturn operand1 - operand2\n\t\t\tend\n\
    \t\telseif operator == '*' and operand1 == nil then\n\t\t\tif operand2 == nil\
    \ then\n\t\t\t\treturn operand2\n\t\t\telse\n\t\t\t\treturn operand1 * operand2\n\
    \t\t\tend\n\t\telseif operator == '//' and operand1 == nil then\n\t\t\tif operand2\
    \ == nil then\n\t\t\t\treturn nil\n\t\t\telse\n\t\t\t\treturn floor( operand1\
    \ / operand2 )\n\t\t\tend\n\t\telseif operator == '**' and operand1 == nil then\n\
    \t\t\tif operand2 == nil then\n\t\t\t\treturn operand2\n\t\t\telse\n\t\t\t\treturn\
    \ operand1 ^ operand2\n\t\t\tend\n\t\tend\n\tend", "    local ops = {}\n    for\
    \ i = 1, #operator do table.insert(ops, operator[i]) end\n    local lhs, rhs =\
    \ unpack(unpack(unpack(unpack(unpack(unpack(unpack(unpack(operand)))))))\n   \
    \ local op_count = #ops\n    local result = 0\n    for i = 1, op_count do\n  \
    \      local op = ops[i]\n        local lhs_value = lhs\n        local rhs_value\
    \ = rhs\n        if op == '+' and lhs_value ~= nil and rhs_value ~= nil then\n\
    \            if lhs_value == rhs_value then\n                result = result +\
    \ 1\n            else\n                result = result + lhs_value\n         \
    \   end\n        elseif op == '*' and lhs_value ~= nil and rhs_value ~= nil then\n\
    \            if lhs_value == rhs_value then\n                result = result *\
    \ 1\n            else\n                result = result * lhs_value\n         \
    \   end\n        elseif op == '-' and lhs_value ~= nil and rhs_value ~= nil then\n\
    \            if lhs_value == rhs_value then\n                result = result -\
    \ 1\n            else\n                result = result - lhs_value\n         \
    \   end\n        elseif op == '/' and lhs_value ~= nil and rhs_value ~= nil then\n\
    \            if lhs_value == rhs_value then\n                result = result /\
    \ 1\n            else\n                result = result / lhs_value\n         \
    \   end\n        elseif op == '//' and lhs_value ~= nil and rhs_value ~= nil then\n\
    \            if lhs_value == rhs_value then\n                result = result //\
    \ 1\n            else\n                result = result // lhs_value\n        \
    \    end\n        elseif op == '**' and lhs_value ~= nil and rhs_value ~= nil\
    \ then\n            if lhs_value == rhs_value then\n                result = result\
    \ ^ 1\n            else\n                result = result ^ lhs_value\n       \
    \     end\n        else\n            assert(false, \"Invalid operator in do_algebra.\"\
    )\n        end\n    end\n    return result\nend", "    local result = operand[1]\n\
    \    local i = 2\n    while i < #operand do\n        result = result[operator]\n\
    \        operand[i] = result\n        i = i + 1\n    end\n    return result\n\
    end", "  -- The algebric expression is built here. Each operator and operand is\
    \ paired.\n  local algebric_expr = 'result = ('\n  for _,op in pairs(operator)\
    \ do\n    algebric_expr = algebric_expr..'('..op..' + )'\n  end\n  algebric_expr\
    \ = algebric_expr..')'\n  -- Build operand table and table for basic algebra operations.\n\
    \  local operands = nil\n  local operators = nil\n  -- If there is at least one\
    \ operand and at least one operator, build the operand and operator table.\n \
    \ if #operand > 0 and #operator > 0 then\n    operands = string.rep(\" , \", #operand)\n\
    \    operators = string.rep(\" , \", #operator)\n  end\n  -- If there is at least\
    \ one operand and no operator, build the operand table.\n  if #operand > 0 and\
    \ #operator == 0 then\n    operands = string.rep(\" , \", #operand)\n  end\n \
    \ -- If there is at least one operator and no operand, build the operator table.\n\
    \  if #operand == 0 and #operator > 0 then\n    operators = string.rep(\" , \"\
    , #operator)\n  end\n  -- Build operation expression using the operands and operators\
    \ tables.\n  if #operands > 0 and #operators > 0 then\n    algebric_expr = algebric_expr..operands\n\
    \    algebric_expr = algebric_expr..operators\n  elseif #operands > 0 and #operators\
    \ == 0 then\n    algebric_expr = algebric_expr..operands\n  elseif #operands ==\
    \ 0 and #operators > 0 then\n    algebric_expr = algebric_expr..operators\n  end\n\
    \  -- Execute the expression in standard Lua using pcall.\n  -- The result is\
    \ stored in result.\n  local result = pcall(function()\n    algebric_expr\n  \
    \  local eval\n    local res = {\n      result = nil,\n      err = nil\n    }\n\
    \    eval = assert(load(algebric_expr))\n    if type(eval) == 'function' then\n\
    \      -- Evaluate expression. Return result and nil on error.\n      res[1] =\
    \ eval(unpack(operand))\n      res[2] = nil\n    else\n      -- Evaluate expression.\
    \ Return nil and error on error.\n      res[1] = nil\n      res[2] = assert(string.gsub(eval,\
    \ \"\\n\", \"\"))\n    end\n    return res\n  end)\n  if #result == 1 then\n \
    \   return unpack(result)[1]\n  else\n    return unpack(result)[2]\n", "    if\
    \ #operator > #operand then\n        return nil\n    end\n    if #operator ==\
    \ 1 then\n        return table.remove({operator, operand}, 1)\n    end\n    local\
    \ stack = lists.new()\n    local expression = table.remove({operator, operand},\
    \ 1)\n    local value1 = stack[#stack]:eval(expression)\n    local op\n    for\
    \ i=#operator, 1, -1 do\n        op = operator[i]\n        local value2 = stack[#stack]:eval(expression)\n\
    \        value1 = value1:op(value2)\n        stack[#stack+1] = op\n        stack[#stack]\
    \ = nil\n    end\n    return value1\nend", "\tassert(#operator == #operand)\n\t\
    local result = operand[1]\n\tlocal count = 0\n\tfor i = 2, #operand do\n\t\tlocal\
    \ operator1 = operator[count - 1]\n\t\tlocal operator2 = operator[i]\n\t\tlocal\
    \ operand2 = operand[i]", "  local function is_equal(n1, n2)\n    return n1 ==\
    \ n2 or (type(n1) == 'table' and n1[#n1] == n2[#n2])\n  end\n  local function\
    \ is_less(n1, n2)\n    return n1 < n2 or (type(n1) == 'table' and n1[#n1] < n2[#n2])\n\
    \  end\n  local function is_greater_equal(n1, n2)\n    return n1 >= n2 or (type(n1)\
    \ == 'table' and n1[#n1] >= n2[#n2])\n  end\n  local function is_less(n1, n2)\n\
    \    return n1 < n2 or (type(n1) == 'table' and n1[#n1] < n2[#n2])\n  end\n  local\
    \ function is_greater_equal(n1, n2)\n    return n1 >= n2 or (type(n1) == 'table'\
    \ and n1[#n1] >= n2[#n2])\n  end", "    local result = nil\n    local operator_count\
    \ = #operator\n    local operand_count = #operand\n    local operator_table =\
    \ { }\n    local operand_table = { }\n    local stack = { }\n    local index =\
    \ operand_count - 1\n    while index > 0 do\n        local operator = operator[index]\n\
    \        local operand = operand[index]\n        index = index - 1\n        if\
    \ operator == nil then\n            result = operand\n        else\n         \
    \   local operator_stack = stack[#stack]\n            operator_stack[#operator_stack\
    \ + 1] = operator\n            operator_stack[#operator_stack + 1] = operand\n\
    \            stack[#stack + 1] = operator_stack\n        end\n    end\n    return\
    \ result\nend", "  assert(#operator == #operand - 1)\n  local num_ops = #operator\n\
    \  -- Calculate the number of bits for the expression in question\n  local num_expr_bits\
    \ = #operand * 8", "\tlocal alg_ops = {\n\t\t['+'] = function (a, b) return a\
    \ + b end,\n\t\t['-'] = function (a, b) return a - b end,\n\t\t['*'] = function\
    \ (a, b) return a * b end,\n\t\t['/'] = function (a, b) return a / b end,\n\t\t\
    ['//'] = function (a, b) return a // b end,\n\t\t['**'] = function (a, b) return\
    \ a ** b end,\n\t}\n\tassert(type(operator) == 'table')\n\tassert(type(operand)\
    \ == 'table')\n\tassert(#operator == #operand)\n\tlocal ops = #operator\n\tlocal\
    \ r = 0\n\tlocal x = operand[1]\n\tlocal y = operand[2]\n\tassert(#operand ==\
    \ ops - 1)\n\tassert(#operand == #operator)\n\tassert(#operand == #x)\n\tassert(#operand\
    \ == #y)\n\t\n\tfor i = 1, ops do\n\t\tr = alg_ops[operator[i]](x, y)\n\t\tx =\
    \ y\n\t\ty = r\n\tend\n\treturn r\nend", "    -- Compute the length of the operand\
    \ table minus one.\n    local op_size = #operand\n    -- Initialize the result\
    \ to 0.\n    local result = 0\n    -- Iterate over the number of operators.\n\
    \    for i = 1, #operator do \n        -- Initialize the variables for use in\
    \ the for loop.\n        local left_operand -- The left operand.\n        local\
    \ right_operand -- The right operand.\n        local operator -- The operator.\n\
    \        -- Compute the left operand.\n        if i == 1 then\n            left_operand\
    \ = operand[1]\n        else\n            left_operand = result\n        end\n\
    \        -- Compute the right operand.\n        if i == #operator then\n     \
    \       right_operand = operand[op_size]\n        else\n            right_operand\
    \ = result\n        end\n        -- Compute the operator.\n        operator =\
    \ operators[i]\n        -- Compute the value of the expression.\n        result\
    \ = left_operand .. operator .. right_operand\n    end\n    -- Return the result.\n\
    \    return result\nend", "\t-- First, find the length of the operator table.\n\
    \tlocal table_length = #operator\n\t\n\t-- Check if the length of the operand\
    \ table is equal to the length of the operator table.\n\tif #operand ~= table_length\
    \ - 1 then\n\t\t-- Second, check if each operand is an integer.\n\t\tfor index\
    \ = 1, #operand do\n\t\t\t-- Check if each operand is an integer.\n\t\t\tif type(operand[index])\
    \ ~= 'number' then\n\t\t\t\terror('Invalid operand type!')\n\t\t\tend\n\t\tend\n\
    \t\t-- Third, check if each operand is negative.\n\t\tfor index = 1, #operand\
    \ do\n\t\t\tif operand[index] < 0 then\n\t\t\t\terror('Negative operand is not\
    \ allowed!')\n\t\t\tend\n\t\tend\n\tend", "    local result = 0\n    local ops\
    \ = { }\n    local lastOp = nil\n    for i = 1, #operator do\n        if operator[i]\
    \ ~= nil then\n            lastOp = operator[i]\n            table.append(ops,\
    \ lastOp)\n        end\n    end\n    local lastOpr = nil\n    for i = 1, #operand\
    \ do\n        if operand[i] ~= nil then\n            lastOpr = operand[i]\n  \
    \          table.append(ops, lastOpr)\n        end\n    end\n    if #ops == 0\
    \ then\n        return nil\n    end\n    for i = 1, #ops do\n        local op\
    \ = ops[i]\n        if op == '+' then\n            result = result + lastOpr\n\
    \        elseif op == '-' then\n            result = result - lastOpr\n      \
    \  elseif op == '*' then\n            result = result * lastOpr\n        elseif\
    \ op == '/' then\n            result = result // lastOpr\n        elseif op ==\
    \ '**' then\n            result = result ** lastOpr\n        end\n    end\n  \
    \  return result\nend\n</cell>\n<cell>", "\tlocal results = {}\n\tlocal first_operand\
    \ = operand[1]\n\tlocal first_operator = operator[1]", "    local result = 1\n\
    \    for i = 1, #operand - 1 do\n        result = result + operand [i] * operator[i]\n\
    \    end\n    return result + operand [#operand]\nend", "  local result, length\
    \ = 0, #operand - 2\n  for i = 1, length do\n    local operator = operator[operand[i]]\n\
    \    local left = operand[i + 1]\n    local right = operand[i + 2]\n    local\
    \ operand_left = operand[i + 3]\n    local operand_right = operand[i + 4]\n  \
    \  result = result + operator or left or right or operand_left or operand_right\
    \ or 0\n  end\n  return result\nend", "  local result = nil\n  \n  for i, _ in\
    \ ipairs(operator) do\n    local operator = operator[i]\n    if type(operand[i])\
    \ == 'number' then\n      result = result .. operator .. operand[i]\n    else\n\
    \      assert(operand[i] ~= 'nil')\n      result = result .. operator .. do_algebra(operand[i])\n\
    \    end\n  end\n  \n  return result\nend", "\tlocal operator_name = nil\n\tlocal\
    \ sum = 0\n\tlocal max_index = #operand\n\tfor i=1, max_index do\n\t\tsum = sum\
    \ .. \"(\" .. operand[i] .. \" \" .. operator[i] .. \" \" .. operand[i] .. \"\
    )\"\n\tend\n\treturn sum\nend", "  local table_index = 1\n  local result = operand[1]\n\
    \  \n  while table_index < #operator do\n    if #operand == 1 then\n      if #operator\
    \ == 1 then\n        result = table[table_index](result, operand[table_index][1])\n\
    \      elseif #operator == 2 then\n        result = table[table_index](result,\
    \ operand[table_index][1], operand[table_index][2])\n      else\n        result\
    \ = table[table_index](result, operand[table_index][1], operand[table_index][2],\
    \ operand[table_index][3])\n      end\n    else\n      result = table[table_index](result,\
    \ operand[table_index][1])\n    end\n    table_index = table_index + 1\n  end\n\
    \  \n  return result\nend", "\t-- Get the number of operands.\n\tlocal nOperands\
    \ = #operand\n\t-- Handle empty tables.\n\tif nOperands == 0 then\n\t\treturn\
    \ 0\n\tend\n\t-- Handle single operands.\n\tif nOperands == 1 then\n\t\t-- Get\
    \ the operand value and do the operation.\n\t\tlocal operandValue = operand[1]\n\
    \t\treturn operandValue\n\tend\n\t-- Handle multi-operands.\n\tlocal operation\n\
    \tlocal operandIndex\n\tlocal operandValue\n\tfor operandIndex = 1, nOperands\
    \ do\n\t\t-- Get the operand value.\n\t\toperandValue = operand[operandIndex]\n\
    \t\t-- Determine which operation to perform.\n\t\toperation = operator\n\t\t--\
    \ Handle addition.\n\t\tif operation == '+' then\n\t\t\t-- Perform the addition.\n\
    \t\t\toperation = add_two_numbers(operandValue, operand[operandIndex+1])\n\t\t\
    end\n\t\t-- Handle subtraction.\n\t\tif operation == '-' then\n\t\t\t-- Perform\
    \ the subtraction.\n\t\t\toperation = subtract_two_numbers(operandValue, operand[operandIndex+1])\n\
    \t\tend\n\t\t-- Handle multiplication.\n\t\tif operation == '*' then\n\t\t\t--\
    \ Perform the multiplication.\n\t\t\toperation = multiply_two_numbers(operandValue,\
    \ operand[operandIndex+1])\n\t\tend\n\t\t-- Handle floor division.\n\t\tif operation\
    \ == '//' then\n\t\t\t-- Perform the floor division.\n\t\t\toperation = floor_divide_two_numbers(operandValue,\
    \ operand[operandIndex+1])\n\t\tend\n\t\t-- Handle exponentiation.\n\t\tif operation\
    \ == '**' then\n\t\t\t-- Perform the exponentiation.\n\t\t\toperation = exponentiate_two_numbers(operandValue,\
    \ operand[operandIndex+1])\n\t\tend\n\t\t-- Handle invalid operators.\n\t\tif\
    \ operation ~= '-' and operation ~= '+' and operation ~= '*' and operation ~=\
    \ '//' and operation ~= '**' then\n\t\t\terror('Invalid operation: ' .. operation)\n\
    \t\tend\n\tend\n\t-- Get the final result and return it.\n\treturn operation\n\
    end", "  -- Operator and operand table length must be the same\n  assert(#operator\
    \ == #operand)\n  local result = 1\n  for i = 1, #operand do\n    -- Add the operand's\
    \ element to the current result\n    result = result + operand[i]\n  end\n  --\
    \ Perform the operation\n  for i = 1, #operator do\n    result = result .. operator[i]\n\
    \  end\n  return result\nend\n</cell>\n<code language=julia-0.5>\ndo_algebra(operator,\
    \ table)\n</cell>\n<text>\nExercise 2\nWrite a function to convert an expression\
    \ to infix notation.", "  local ops = {}\n  -- Add operators to the operator table\n\
    \  for i = 1, #operator do\n    local op = operator[i]\n    local n = #operand[i\
    \ + 1]\n    table.insert(ops, op)\n  end\n  -- Add operands to the operand table\n\
    \  for i = 0, #operand - 1 do\n    table.insert(ops, operand[i])\n  end\n  --\
    \ Evaluate the resulting expression using the operator table\n  local result,\
    \ error = parse(ops, #operand)\n  -- Return error if not successful\n  if error\
    \ ~= nil then\n    return nil, error\n  end\n  return result\nend", "\tlocal res\
    \ = {}\n\tlocal length = #operand\n\tlocal i = 0\n\tlocal j = 0", "  -- Return\
    \ the value of the algebraic expression of operator and operand tables. \n  --\
    \ The return value is an integer. The algorithm for do_algebra is given below:\n\
    \  -- First check the length of operator and operand tables:\n  if #operator ~=\
    \ #operand then\n    return nil\n  end\n  -- If both operand and operator tables\
    \ have the same length, and the length is not greater than or \n  -- equal to\
    \ the length of operand table minus one, then return nil.\n  if #operand >= #operator\
    \ + 1 then\n    return nil\n  end\n  -- If the length of operand is equal to 0,\
    \ then return nil.\n  if #operand == 0 then\n    return nil\n  end\n  -- Otherwise,\
    \ loop through the two tables:\n  for i = 1, #operand do\n    -- Calculate the\
    \ value of operand table at the i'th element:\n    local v1 = operand[i]\n   \
    \ -- Calculate the value of operator table at the i'th element:\n    local v2\
    \ = operator[i]\n    -- Multiply the value of operand table at the i'th element\
    \ with the value of operator table \n    -- at the i'th element, and assign the\
    \ result to the variable result.\n    local result = v1 * v2\n    -- Return the\
    \ value of the result table. \n    return result\n  end\nend\n</cell>\n<cell>",
  "    -- Basic algebra operations\n    local function op_add(lhs, rhs)\n        return\
    \ lhs + rhs\n    end\n    local function op_sub(lhs, rhs)\n        return lhs\
    \ - rhs\n    end\n    local function op_mul(lhs, rhs)\n        return lhs * rhs\n\
    \    end\n    local function op_div(lhs, rhs)\n        return lhs // rhs\n   \
    \ end\n    local function op_pow(lhs, rhs)\n        return lhs ^ rhs\n    end\n\
    \    local function op_exp(lhs, rhs)\n        return lhs ^ rhs\n    end\n    --\
    \ Table of non-negative integers\n    local function table_to_array(table)\n \
    \       local result = {}\n        for _, v in ipairs(table) do\n            result[#result+1]\
    \ = v\n        end\n        return result\n    end", "\tlocal op = {}\n\tlocal\
    \ ans = {}\n\tfor i = 1, #operand do\n\t\tlocal temp = {}\n\t\tfor j=1, #operator\
    \ do\n\t\t\ttemp[j] = operator[j]\n\t\tend\n\t\tlocal op1, op2 = operand[1], operand[i]\n\
    \t\tlocal sum = 0\n\t\tif op1 ~= nil then\n\t\t\tsum = op1 + op2\n\t\telseif op2\
    \ ~= nil then\n\t\t\tsum = op2 + op1\n\t\tend\n\t\top[#op + 1] = sum\n\tend\n\t\
    local index = 1\n\tlocal flag = true\n\tlocal sum = 0\n\tlocal sum2 = 0\n\tfor\
    \ i=1, #operand do\n\t\tlocal temp = op[index + 1]\n\t\tif temp ~= nil then\n\t\
    \t\tsum = sum + temp\n\t\telse\n\t\t\tsum2 = sum2 + operand[i]\n\t\tend\n\t\t\
    index = index + 1\n\t\tif flag == false then\n\t\t\tans[#ans + 1] = sum2\n\t\t\
    \tsum2 = 0\n\t\tend\n\tend\n\tif flag == false then\n\t\tans[#ans + 1] = sum2\n\
    \tend\n\treturn ans\nend", "    local result = {}\n    for i=1,#operand-1 do\n\
    \        local value = 1\n        for j=1,#operator do\n            value = value\
    \ * operand[i] - operator[j]\n        end\n        result[#result+1] = value\n\
    \    end\n    result[#result+1] = result[#result+1] \n    return result\nend",
  "    local ops = {}\n    -- We use an associative array.\n    for _, v in pairs(operator)\
    \ do table.insert(ops, v) end\n    -- The operand is always evaluated before other\
    \ operands, so we evaluate it first.\n    local eval_operand = table.unpack(operand)[1]\n\
    \    -- Now we iterate through the operators.\n    for _, v in pairs(ops) do\n\
    \        local operands = {}\n        for _, v2 in pairs(operand) do table.insert(operands,\
    \ v2) end\n        local result = v\n        for _, v2 in pairs(operands) do\n\
    \            result = v(result, v2)\n        end\n        local eval_result =\
    \ v\n        for _, v2 in pairs(operands) do\n            eval_result = v(eval_result,\
    \ v2)\n        end\n        eval_result = eval_operand(eval_result)\n        return\
    \ result\n    end\nend", "\tlocal tmp_operand = operand[1]\n\tlocal tmp_operator\
    \ = operator[1]\n\tlocal tmp_result = tmp_operand .. tmp_operator\n\treturn tmp_result\n\
    end", "  local table_len = len(operator)\n  assert(table_len > 0)", "   \n   --\
    \ Get the length of the two operand tables\n   local op1 = #operand[1] - 1\n \
    \  local op2 = #operand[2] - 1", "    if #operator == 0 or #operand == 0 then\n\
    \        return \"Error: Invalid Arguments.\"\n    end", "    local function check_operand(operand)\n\
    \        local function check_operation(operator)\n            -- Checks if the\
    \ given operator is an algebraic operation.\n            -- An algebraic operation\
    \ is a string containing the symbols '+', '-', '*', '//', and '**'.\n        \
    \    -- An algebraic operation is valid if the symbols in the operand table exist.\n\
    \            -- The symbols are case insensitive.\n            -- Examples of\
    \ valid algebraic operations:\n            -- * + -\n            -- * + - +\n\
    \            -- * + - * + - // \n            local function check_symbol(symbol)\n\
    \                -- Checks if symbol is a valid symbol.\n                -- The\
    \ symbols are case insensitive.\n                -- Note: The symbol is valid\
    \ if symbol.symbol is true.\n                -- Examples of valid symbols:\n \
    \               -- * + -\n                -- * + - +\n                -- * + -\
    \ * + - // \n                if symbol.symbol == true then\n                 \
    \   return true\n                else\n                    return false\n    \
    \            end\n            end\n            -- Checks if the given operator\
    \ is valid.\n            -- Examples of valid symbols:\n            -- * + -\n\
    \            -- * + - +\n            -- * + - * + - // \n            if check_symbol(operator)\
    \ == true then\n                return true\n            else\n              \
    \  return false\n            end\n        end\n        if check_operation(operator)\
    \ == true then\n            -- Operator is valid.\n        else\n            --\
    \ Operator is invalid.\n        end\n    end\n    -- Checks if the given operand\
    \ is valid.\n    if check_operand(operand) == true then\n        -- Operand is\
    \ valid.\n    else\n        -- Operand is invalid.\n    end\nend", "    local\
    \ result = 0\n    for i = 1, #operand do\n        local temp_result = operand\
    \ [i]\n        if #operator > 1 then\n            for j = 1, #operator do\n  \
    \              temp_result = operator[j] (temp_result, operand [i + j])\n    \
    \        end\n        else\n            temp_result = operator[1] (temp_result)\n\
    \        end\n        result = result + temp_result\n    end\n    return result\n\
    end", "  -- Make sure the input tables are the right length\n  if #operand ~=\
    \ #operator then\n    return nil\n  end", "    local function evaluate(operation,\
    \ operand)\n        if operand == nil then\n            error(\"Missing operand.\"\
    )\n        end", "  assert(#operator == #operand)\n  local table = {}\n  for i\
    \ = 0, #operator - 1 do\n    table[i] = operator[i]\n  end\n  table[1] = operator[1]\n\
    \  for i = 2, #operand do\n    table[i] = operand[i]\n  end\n  local result =\
    \ table[1]\n  for i = 3, #table do\n    result = table[i](result)\n  end\n  return\
    \ result\nend", "\tlocal num_operand = #operand\n\tlocal num_operator = #operator\n\
    \tlocal num_table = #operator\n\tif num_operand > num_operator then return nil\
    \ end\n\tif num_operand == num_operator then\n\t\tlocal result = operand[1]\n\t\
    \tfor i=2,num_operand do\n\t\t\tlocal new_result = operand[i] and operand[i] +\
    \ result\n\t\t\tif new_result == nil then return nil end\n\t\t\tresult = new_result\n\
    \t\tend\n\t\treturn result\n\tend\n\tif num_operand < num_operator then\n\t\t\
    local result = operand[1]\n\t\tfor i=2,num_operand do\n\t\t\tlocal new_result\
    \ = operand[num_operator-(i-1)] and result\n\t\t\tif new_result == nil then return\
    \ nil end\n\t\t\tresult = new_result\n\t\tend\n\t\treturn result\n\tend\n\tlocal\
    \ op = operator[1]\n\tlocal i = 1\n\tif #operator == 2 then\n\t\tlocal new_result\
    \ = operand[i] and operand[i] + operand[i-1]\n\t\tif new_result == nil then return\
    \ nil end\n\t\tresult = new_result\n\telseif #operator == 3 then\n\t\tlocal new_result\
    \ = operand[i] and operand[i] * operand[i-1]\n\t\tif new_result == nil then return\
    \ nil end\n\t\tresult = new_result\n\telse\n\t\tfor i=2,num_operand do\n\t\t\t\
    local new_result = operand[num_operator-(i-1)] and operand[i-1]\n\t\t\tif new_result\
    \ == nil then return nil end\n\t\t\tresult = new_result\n\t\tend\n\t\treturn result\n\
    \tend\n\treturn result\nend", "  local expressions = {}\n  local result = 0",
  "  -- Convert operand and operator tables to list of tuples.\n  local operands =\
    \ operand:gsub(\"%w+\", nil):gsub(\"%w+-\", nil):split(\"-\")\n  local operators\
    \ = operator:gsub(\"%w+\", nil):gsub(\"%w+-\", nil):split(\"-\")\n  local operands_count\
    \ = 1\n  local operators_count = 1", "\tlocal result = 0\n\tlocal index\n\tfor\
    \ index, op in ipairs(operator) do\n\t\tresult = result + operand[index] * op\n\
    \tend\n\treturn result\nend", "\tlocal num_operand = #operand\n\tlocal operators\
    \ = #operator\n\tlocal operands = #operand", "\tif type(operator) ~= 'table' then\
    \ \n\t\tprint('error: do_algebra: operator must be a table')\n\t\treturn nil\n\
    \tend", "  -- Get the length of operator and operand table\n  local lenOperator\
    \ = #operator\n  local lenOperand = #operand\n  -- If the length of operator table\
    \ is 1, then only 1 operator will be used\n  if lenOperator == 1 then\n    return\
    \ operand[1]\n  end\n  -- If the length of operand table is 1, then only 1 operand\
    \ will be used\n  if lenOperand == 1 then\n    return do_algebra(operator[1],\
    \ operand[1])\n  end\n  -- The first table is an algebra expression table\n  local\
    \ algebraTable = {}\n  -- The second table is an operand table\n  local operandTable\
    \ = {}\n  -- Initialize the algebra table with basic algebra operations\n  for\
    \ i = 1, lenOperand do\n    algebraTable[i] = '('\n  end\n  for i = 1, lenOperand\
    \ do\n    algebraTable[lenOperand + i] = ')'\n  end\n  -- Initialize the operand\
    \ table with operand values\n  for i = 1, lenOperand do\n    operandTable[i] =\
    \ operand[i]\n  end\n  -- Get the next operator\n  local nextOperator = operator[1]\n\
    \  -- Get the next operand from the operand table\n  local nextOperand = operand[1]\n\
    \  -- If there are no more operands, return 0\n  if nextOperand == nil then\n\
    \    return 0\n  end\n  -- While there are still operands, do the algebraic operation\
    \ and return the result\n  local result = 0\n  while nextOperand ~= nil do\n \
    \   -- Get the next operator\n    local nextOperator = operator[1]\n    -- Get\
    \ the next operand from the operand table\n    local nextOperand = operand[1]\n\
    \    -- If the next operator is nil, stop the loop\n    if nextOperator == nil\
    \ then\n      break\n    end\n    -- Otherwise, do the algebraic operation\n \
    \   local operation = nextOperator[1]\n    local operand1 = algebraTable[lenOperand\
    \ + nextOperator[2]]\n    local operand2 = algebraTable[lenOperand + nextOperand[2]]\n\
    \    result = result + operation * operand1 + operation * operand2\n    -- If\
    \ there are still operands, do the algebraic operation\n    if nextOperand ~=\
    \ nil then\n      -- Get the next operator\n      local nextOperator = operator[1]\n\
    \      -- Get the next operand from the operand table\n      local nextOperand\
    \ = operand[1]\n      -- If the next operator is nil, stop the loop\n      if\
    \ nextOperator == nil then\n        break\n      end\n      -- Otherwise, do the\
    \ algebraic operation\n      local operation = nextOperator[1]\n      local operand1\
    \ = algebraTable[lenOperand + nextOperator[2]]\n", "\t-- The main algorithm for\
    \ building the algebric expression is as follows:\n\t-- 1. Traverse the operand\
    \ table from the second element to the last element, \n\t-- each time popping\
    \ the top element from the operand table and pushing it to the \n\t-- expression\
    \ stack.\n\t-- 2. Keep a temporary result variable and a temporary expression\
    \ stack variable, \n\t-- to hold the intermediate result and expression stack.\n\
    \t-- 3. For each element in the operand table, \n\t-- if the element is an integer\
    \ and larger than 0, then \n\t-- push it to the expression stack; otherwise, if\
    \ the element is an operator, \n\t-- then pop one element from the expression\
    \ stack, and push it to the expression \n\t-- stack; otherwise, if the element\
    \ is a constant integer, then push it to \n\t-- the expression stack as well.\
    \ \n\t-- 4. Finally, pop one element from the expression stack, and push it to\
    \ the \n\t-- expression stack as the result.\n\t\n\t-- Solution 2\n\t-- The solution\
    \ presented here is less efficient in terms of space complexity. \n\t-- In particular,\
    \ it is more costly to repeatedly pop an expression stack element which \n\t--\
    \ we already know is going to be the final result.\n\t\n\t-- Solution 1\n\t--\
    \ We traverse the operand table from right to left, and use a stack to store the\
    \ \n\t-- final result.\n\t\n\tlocal stack = {}\n\tlocal result = 0\n\tlocal i\
    \ = 0\n\t\n\tfor i = #operand, 1, -1 do\n\t\tif operand[i] == nil then break end\n\
    \t\t\n\t\t-- If the operand is an integer, then push it to the expression stack.\n\
    \t\tif type(operand[i]) == \"number\" then\n\t\t\tstack[#stack + 1] = operand[i]\n\
    \t\t-- If the operand is an operator, then pop it from the expression stack, \n\
    \t\t-- and push it to the expression stack.\n\t\telseif type(operand[i]) == \"\
    table\" then\n\t\t\tif operator[#operand[i]] then\n\t\t\t\tstack[#stack + 1] =\
    \ operand[i][#operand[i]]\n\t\t\telse\n\t\t\t\tstack[#stack + 1] = operand[i][1]\n\
    \t\t\t\tstack = stack[#stack]:gsub(\"^\", \"%\"):gsub(\"%\", \"^\")\n\t\t\t\t\
    stack[#stack + 1] = operator[#operand[i]]\n\t\t\tend\n\t\t-- If the operand is\
    \ a constant integer, then push it to expression stack.\n\t\telse\n\t\t\tstack[#stack\
    \ + 1] = operand[i]\n\t\tend\n\tend\n\t\n\treturn stack[#stack]\nend", "\t-- base\
    \ case\n\tif #operand == 1 and #operator == 1 then\n\t\treturn operand[1]\n\t\
    end", "    local result_table = {}\n    local result_index = 1", "  local result\
    \ = 0;\n  for i = 1, #operand do\n    result = result + operand[i] * operator[i];\n\
    \  end\n  return result;\nend", "  if #operand == 0 or #operator == 0 then return\
    \ false end\n  if #operand > #operator then\n    operand = operand[#operand]\n\
    \    operator = operator[#operator]\n  end\n  if #operand == 1 and #operator ==\
    \ 1 then\n    return operand[#operand][operator](operand[#operand])\n  end\n \
    \ return operand[#operand][operator]\nend", "\tlocal operators, operands, results\
    \ = {}, {}, {}\n\tlocal operator, operand = unpack(operator, operand)\n\tassert(operator,\
    \ 'invalid operator')\n\tassert(operand, 'invalid operand')\n\tassert(operand[1],\
    \ 'invalid operand')\n\tassert(#operator == #operand, 'invalid operand')\n\t\n\
    \tfor i = 1, #operand do\n\t\tlocal operation = operator[i]\n\t\tlocal left =\
    \ operand[i - 1]\n\t\tlocal right = operand[i]\n\t\t\n\t\tlocal result_left, result_right\
    \ = left, right\n\t\t\n\t\tif operation == '+' or operation == '-' then\n\t\t\t\
    if left ~= 0 then\n\t\t\t\tif type(left) == 'table' then\n\t\t\t\t\tfor j = 1,\
    \ #left do\n\t\t\t\t\t\tresult_left = result_left + (left[j] * right)\n\t\t\t\t\
    \tend\n\t\t\t\telse\n\t\t\t\t\tresult_left = result_left + right\n\t\t\t\tend\n\
    \t\t\tend\n\t\telseif operation == '*' or operation == '/' or operation == '//'\
    \ then\n\t\t\tif left ~= 0 then\n\t\t\t\tif type(left) == 'table' then\n\t\t\t\
    \t\tfor j = 1, #left do\n\t\t\t\t\t\tresult_left = result_left + (left[j] * right)\n\
    \t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tresult_left = result_left * right\n\t\t\
    \t\tend\n\t\t\tend\n\t\telseif operation == '**' then\n\t\t\tresult_left = result_left\
    \ ^ right\n\t\tend\n\t\t\n\t\toperands[#operands + 1] = result_left\n\t\tresults[#results\
    \ + 1] = result_right\n\tend\n\t\n\treturn results[#results], operands[#operands]\n\
    end", "\tlocal function  build_subterm(operator, operand, i, term)\n\t\tif(i >\
    \ #operand) then\n\t\t\treturn nil\n\t\telse\n\t\t\tterm = operand [i]\n\t\t\t\
    local op_length = #operator\n\t\t\tif(#operand) > i + op_length then\n\t\t\t\t\
    -- If we have more operands than operators, we only have one more operand, so\
    \ we \n\t\t\t\t-- simply return that operand.\n\t\t\t\treturn term\n\t\t\telse\n\
    \t\t\t\tlocal left_operand = build_subterm(operator, operand, i + op_length, term)\n\
    \t\t\t\tif(left_operand == nil) then\n\t\t\t\t\treturn nil\n\t\t\t\telse\n\t\t\
    \t\t\tlocal right_operand = build_subterm(operator, operand, i + op_length + 1,\
    \ term)\n\t\t\t\t\treturn left_operand .. operator[left_operand] .. right_operand\n\
    \t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn build_subterm(operator, operand,\
    \ 0, nil)\nend", "  local basic = {\n    ['+'] = function(v1, v2) return v1 +\
    \ v2 end,\n    ['-'] = function(v1, v2) return v1 - v2 end,\n    ['*'] = function(v1,\
    \ v2) return v1 * v2 end,\n    ['//'] = function(v1, v2) return v1 // v2 end,\n\
    \    ['**'] = function(v1, v2) return v1 ** v2 end\n  }\n  \n  -- Given two tables\
    \ operator, and operand. The first table has basic algebra operations, and \n\
    \  -- the second table is a table of integers. Use the two given tables to build\
    \ the algebric \n  -- expression and return the evaluation of this expression.\n\
    \  -- The basic algebra operations:\n  -- Addition ( + ) \n  -- Subtraction (\
    \ - ) \n  -- Multiplication ( * ) \n  -- Floor division ( // ) \n  -- Exponentiation\
    \ ( ** ) \n  -- Example:\n  -- operator['+', '*', '-']\n  -- table = [2, 3, 4,\
    \ 5]\n  -- result = 2 + 3 * 4 - 5\n  -- => result = 9\n  -- Note:\n  -- The length\
    \ of operator table is equal to the length of operand table minus one.\n  -- Operand\
    \ is a table of of non-negative integers.\n  -- Operator table has at least one\
    \ operator, and operand table has at least two operands.\n  local function do_algebra_basic(operator,\
    \ operand)\n    local basic = {\n      ['+'] = function(v1, v2) return v1 + v2\
    \ end,\n      ['-'] = function(v1, v2) return v1 - v2 end,\n      ['*'] = function(v1,\
    \ v2) return v1 * v2 end,\n      ['//'] = function(v1, v2) return v1 // v2 end,\n\
    \      ['**'] = function(v1, v2) return v1 ** v2 end\n    }\n    \n    -- Given\
    \ two tables operator, and operand. The first table has basic algebra operations,\
    \ and \n    -- the second table is a table of integers. Use the two given tables\
    \ to build the algebric \n    -- expression and return the evaluation of this\
    \ expression.\n    -- The basic algebra operations:\n    -- Addition ( + ) \n\
    \    -- Subtraction ( - ) \n    -- Multiplication ( * ) \n    -- Floor division\
    \ ( // ) \n    -- Exponentiation ( ** ) \n    -- Example:\n    -- operator['+',\
    \ '*', '-']\n    -- table = [2, 3, 4, 5]\n    -- result = 2 + 3 * 4 - 5\n    --\
    \ => result = 9\n    -- Note:\n    -- The length of operator table is equal to\
    \ the length of operand table minus one.\n    -- Operand is a table of of non-negative\
    \ integers.\n    -- Operator table has at least one operator, and operand table\
    \ has at least two operands.\n", "   local result\n   local operator_index = #operator\
    \ + 1\n   local operators = string.gsub(operator, \" \", \"\")", "    local nOperands\
    \ = #operand\n    local nOperators = #operator\n    if nOperators == 0 then\n\
    \        return nil\n    end", "    local result = 1\n    for i = 1, #operand\
    \ do\n        result = result * operand[i]\n    end\n    for i = 1, #operator\
    \ do\n        result = result ^ operand[#operand - i]\n    end\n    return result\n\
    end", "    -- TODO: Your code goes here!\n    -- Hint: Use for loop to iterate\
    \ over the tables and add them up\n    \n    local result = operand[1]\n    for\
    \ i=2,#operand do\n        result = result .. operator[operator[i-1] .. operand[i]]\n\
    \    end\n    -- TODO: Return the result!\nend", "  if #operand == 0 or #operator\
    \ == 0 then\n    return nil\n  end", "    local table = {}\n    local operand_index\
    \ = 1\n    local index = 1\n    for _, item in pairs(operator) do\n        table[item]\
    \ = {}\n        for _, operand in pairs(operand) do\n            local operand_id\
    \ = index + operand_index\n            table[item][operand_id] = operand\n   \
    \         index = operand_id\n        end\n        operand_index = operand_index\
    \ + 1\n    end\n    return table\nend", "    -- Check if both tables have same\
    \ length.\n    assert(#operand == #operator, \"Operand and Operator table length\
    \ are not same.\")\n    -- Loop through each element of the operand table and\
    \ perform the operation.\n    for i=1,#operand do\n        -- The result of the\
    \ operation is equal to the current element of the operand table\n        -- and\
    \ is equal to the result of the previous operation using the current element of\
    \ operand table.\n        local result = operand[i-1]\n        for j=1, #operator\
    \ do\n            -- The result of the operation is equal to the current element\
    \ of the operand table\n            -- and the current element of the operator\
    \ table is equal to the result of the previous\n            -- operation using\
    \ the current element of operand table and the current element of the operator\
    \ table.\n            result = operator[j-1](result, operand[i-1])\n        end\n\
    \        -- Return the result of the operation.\n        return result\n    end\n\
    end", "    local result = 0\n    if #operand == 1 then\n        -- The operand\
    \ has only one operand, so perform the basic algebra operation.\n        local\
    \ operator_found = false\n        for i = 1, #operator do\n            if operator[i]\
    \ == '+' then\n                result = result + operand[i]\n            elseif\
    \ operator[i] == '-' then\n                result = result - operand[i]\n    \
    \        elseif operator[i] == '*' then\n                result = result * operand[i]\n\
    \            elseif operator[i] == '/' then\n                result = result //\
    \ operand[i]\n            elseif operator[i] == '**' then\n                result\
    \ = result ** operand[i]\n            end\n            if result == 0 then\n \
    \               -- Operator is missing operand.\n                result = nil\n\
    \                break\n            end\n        end\n    else\n        -- The\
    \ operand has two operands, so perform the basic algebra operation.\n        local\
    \ operator_found = false\n        for i = 1, #operator do\n            if operator[i]\
    \ == '+' then\n                result = result + do_algebra(operand, operand[i\
    \ + 1])\n            elseif operator[i] == '-' then\n                result =\
    \ result - do_algebra(operand, operand[i + 1])\n            elseif operator[i]\
    \ == '*' then\n                result = result * do_algebra(operand, operand[i\
    \ + 1])\n            elseif operator[i] == '/' then\n                result =\
    \ result // do_algebra(operand, operand[i + 1])\n            elseif operator[i]\
    \ == '**' then\n                result = result ** do_algebra(operand, operand[i\
    \ + 1])\n            end\n            if result == 0 then\n                --\
    \ Operator is missing operand.\n                result = nil\n               \
    \ break\n            end\n        end\n    end\n    return result\nend", "  local\
    \ result = nil\n  local table_length = #operand\n  assert(table_length >= 2)\n\
    \  for i = 0, table_length - 1 do\n    local left_value = operand[i]\n    local\
    \ right_value = operand[i + 1]\n    local operator_value = operator[i]\n    local\
    \ operator_function = operator_functions[operator_value]\n    if not operator_function\
    \ then\n      error(\"Invalid operator value.\")\n    end\n    result = operator_function[left_value,\
    \ right_value]\n  end\n  return result\nend", "\t-- Initialize variables.\n\t\
    local result = nil\n\tlocal left_operand = nil\n\tlocal right_operand = nil\n\t\
    local operand1 = nil\n\tlocal operand2 = nil\n\tlocal operator1 = nil\n\tlocal\
    \ operator2 = nil\n\tlocal operation = nil", "\tif #operand ~= #operator then\n\
    \t\terror()\n\tend", "  local op = operator[1]\n  local operand1 = operand[1]\n\
    \  local operand2 = operand[2]\n  \n  if op == \"+\" then\n    return operand1\
    \ + operand2\n  elseif op == \"-\" then\n    return operand1 - operand2\n  elseif\
    \ op == \"*\" then\n    return operand1 * operand2\n  elseif op == \"/\" then\n\
    \    return operand1 / operand2\n  elseif op == \"//\" then\n    return operand1\
    \ // operand2\n  elseif op == \"**\" then\n    return operand1 ^ operand2\n  end\n\
    end", "    assert(#operand > 1)\n    assert(#operator > 1)\n    assert(#operand\
    \ == #operator + 1)", "   -- Check that the input tables satisfy the requirements\
    \ specified in the problem statement.\n   assert(#operator == #operand - 1)\n\
    \   assert(#table2 > 0)\n   -- Initialize the result to zero.\n   local result\
    \ = 0\n   -- Perform an iterative process in which we keep adding operand table\
    \ elements to the result.\n   for i = 1, #operand do\n      -- Initialize a temporary\
    \ result variable.\n      local tmp_result = 0\n      -- Perform an iterative\
    \ process in which we keep adding table elements to the tmp_result.\n      for\
    \ j = 1, #table2 do\n         -- Add the table element to the temporary result.\n\
    \         tmp_result = tmp_result + table2[j]\n      end\n      -- Perform the\
    \ required operation.\n      result = result + table1[i-1] * tmp_result\n   end\n\
    \   -- Return the result.\n   return result\nend", "   -- Initialize your solution\
    \ here!\n   -- Example: \n   -- result = 0\n   -- Iterate over the two given tables\
    \ (operand, operator). \n   -- Use nested loops here.\n   local function get_operand(operand,\
    \ i)\n      -- Initialize your solution here!\n      -- Example: \n      -- Get\
    \ the first operand value using operand[i]\n      -- Get the current operator\
    \ value using operator[i]\n      -- Get the next operand value using operand[i\
    \ + 1]\n      -- Get the next operator value using operator[i + 1]\n      -- Return\
    \ the current result using result\n      -- Example: \n      -- result = get_operand(operand,\
    \ i)\n      -- return result\n   end\n   local function get_operator(operator,\
    \ i)\n      -- Initialize your solution here!\n      -- Example: \n      -- Get\
    \ the first operator value using operator[i]\n      -- Get the next operator value\
    \ using operator[i + 1]\n      -- Get the next operator value using operator[i\
    \ + 1]\n      -- Return the current result using result\n      -- Example: \n\
    \      -- result = get_operator(operator, i)\n      -- return result\n   end\n\
    \   return \nend", "    assert(#operator == #operand - 1)\n    \n    -- Operator\
    \ table\n    local ops = {}\n    for i = 1, #operator do ops[i] = operator[i]\
    \ end\n    \n    -- Algebraic expression\n    local expr = 0\n    for i = 1, #operand\
    \ do expr = expr .. ops[operand[i]] end", "    local result = nil\n    if #operator\
    \ > 1 then\n        local tempResult = nil\n        local i = 1\n        while\
    \ i <= #operand do\n            local operatorChar = operator[i]\n           \
    \ local operandChar = operand[i]\n            local operandCount = #operand\n\
    \            if operatorChar == '+' then\n                tempResult = tempResult\
    \ + operandChar\n            elseif operatorChar == '-' then\n               \
    \ tempResult = tempResult - operandChar\n            elseif operatorChar == '*'\
    \ then\n                tempResult = tempResult * operandChar\n            elseif\
    \ operatorChar == '/' then\n                if operandChar ~= 0 then\n       \
    \             tempResult = tempResult / operandChar\n                else\n  \
    \                  error('Zero is undefined when dividing a number by zero.')\n\
    \                end\n            elseif operatorChar == '**' then\n         \
    \       if operandChar ~= 0 then\n                    tempResult = tempResult\
    \ ^ operandChar\n                else\n                    error('Zero is undefined\
    \ when raising a number to a power of zero.')\n                end\n         \
    \   else\n                error('Unknown operator: ' .. operatorChar)\n      \
    \      end\n            i = i + 1\n        end\n        result = tempResult\n\
    \    elseif #operand > 0 then\n        local operatorChar = operator[1]\n    \
    \    local operandChar = operand[1]\n        local operandCount = #operand\n \
    \       if operatorChar == '+' then\n            result = operandChar + operandChar\n\
    \        elseif operatorChar == '-' then\n            result = operandChar - operandChar\n\
    \        elseif operatorChar == '*' then\n            result = operandChar * operandChar\n\
    \        elseif operatorChar == '/' then\n            if operandChar ~= 0 then\n\
    \                result = operandChar / operandChar\n            else\n      \
    \          error('Zero is undefined when dividing a number by zero.')\n      \
    \      end\n        elseif operatorChar == '**' then\n            if operandChar\
    \ ~= 0 then\n                result = operandChar ^ operandChar\n            else\n\
    \                error('Zero is undefined when raising a number to a power of\
    \ zero.')\n            end\n        end\n    end\n    return result\nend", " \
    \   local result = operand[1]\n    for i = 2, #operand do\n        result = result\
    \ .. ' ' .. operator[operand[i-1]]\n    end\n    return result .. ' ' .. operator[operand[#operand]]\n\
    end", "  -- Checks if the given operands are in valid ranges\n  assert(#operand\
    \ == #operator)\n  -- If the given operands are in valid ranges, check if the\
    \ given operator\n  -- exists in the operator table.\n  if #operator > 0 then\n\
    \    -- If so, find the index in the operator table with the required operator\n\
    \    local index = #operator\n    for _ = 1, #operand do\n      index = index\
    \ - 1\n      if operator[index] == operand then\n        break\n      end\n  \
    \  end\n    -- If index is negative, invalid range\n    if index < 0 then\n  \
    \    return nil\n    end\n    -- Otherwise, we return the value of the expression.\n\
    \    return operand[index]\n  end\nend", "    assert(#operand >= #operator, \"\
    Operand table must have at least as many elements as operator table.\")\n    local\
    \ num_operands = #operand\n    local num_operators = #operator\n    local result\
    \ = 1\n    \n    for i = 1, num_operands do\n        local current_operand = operand[i]\n\
    \        local operator = operator[i]\n        if current_operand == nil then\n\
    \            if #operand > 1 then\n                -- Result is a floating point\
    \ number\n                local result_val = result\n                result =\
    \ math.floor(result_val / 2)\n                result = result + result_val % 2\n\
    \            else\n                result = nil\n            end\n        elseif\
    \ current_operand ~= nil then\n            -- Evaluate the expression and store\
    \ it\n            result = result * current_operand + operator(result)\n     \
    \   end\n    end\n    \n    -- Return the evaluation result\n    return result\n\
    end", "  local num_operands = #operand\n  local result_operand = nil\n  if num_operands\
    \ == 1 then\n    result_operand = operand[1]\n  elseif num_operands == 2 then\n\
    \    result_operand = operand[1] + operand[2]\n  elseif num_operands == 3 then\n\
    \    result_operand = operand[1] + operand[2] * operand[3]\n  elseif num_operands\
    \ == 4 then\n    result_operand = operand[1] + operand[2] * operand[3] / operand[4]\n\
    \  elseif num_operands == 5 then\n    result_operand = operand[1] + operand[2]\
    \ * operand[3] / operand[4] / operand[5]\n  else\n    -- The length of operator\
    \ table is equal to the length of operand table minus one.\n    -- Operand is\
    \ a table of of non-negative integers.\n    result_operand = operand[1]\n    for\
    \ i = 2, num_operands do\n      result_operand = result_operand + operand[i]\n\
    \    end\n  end\n  return operator[result_operand]\nend", "\tlocal result = operand[1]\n\
    \tfor i=2,#operand,1 do\n\t\tresult = operator[operator[1]](result, operand[i])\n\
    \tend\n\treturn result\nend", "\tif operator[\"+\"] then\n\t\treturn do_arithmetic_sum(operator,\
    \ operand)\n\telseif operator[\"-\"] then\n\t\treturn do_arithmetic_sub(operator,\
    \ operand)\n\telseif operator[\"*\"] then\n\t\treturn do_arithmetic_mul(operator,\
    \ operand)\n\telseif operator[\"//\"] then\n\t\treturn do_arithmetic_floor(operator,\
    \ operand)\n\telseif operator[\"**\"] then\n\t\treturn do_arithmetic_pow(operator,\
    \ operand)\n\tend\nend", "    local result, carry, count = 0, 0, 0\n    local\
    \ index = 1\n    while index <= #operator do\n        local operator_type = operator[index]\n\
    \        if operator_type:sub(0, 1) ~= '^' then\n            local op1, op2 =\
    \ operand[count], operand[count+1]\n            local res = do_algebra(operator_type,\
    \ op1, op2)\n            if operator_type:sub(0, 1)== '+' then\n             \
    \   result = result + res\n            elseif operator_type:sub(0, 1)== '-' then\n\
    \                result = result - res\n            elseif operator_type:sub(0,\
    \ 1)== '*' then\n                result = result * res\n            elseif operator_type:sub(0,\
    \ 1)== '/' then\n                result = result / res\n            elseif operator_type:sub(0,\
    \ 1)== '%' then\n                result = result % res\n            elseif operator_type:sub(0,\
    \ 1)== '^' then\n                result = result ^ res\n            end\n    \
    \        if res  == 0 then\n                result = nil\n                break\n\
    \            end\n        else\n            local op1, op2 = operand[count], operand[count+1]\n\
    \            local res = do_exponentiation(operator_type, op1, op2)\n        \
    \    if res == 0 then\n                result = nil\n                break\n \
    \           end\n        end\n        index = index + 1\n        count = count\
    \ + 2\n    end\n    return result\nend", "    local num_operands = #operand\n\
    \    local num_operators = #operator\n    local result = operand[1]\n    for i=2,num_operands\
    \ do\n        if result[1] == nil then\n            result = nil\n        end\n\
    \        result = operate[operator[i]](result, operand[i])\n    end\n    return\
    \ result\nend", "    local result = nil\n    \n    local first_value = nil\n \
    \   local second_value = nil\n    local operator_count = nil\n    local second_value_count\
    \ = nil\n    local expression = nil\n    local expression_table = {}\n    \n \
    \   if #operand < 2 then\n        print(\"Error operator table: operand table\
    \ must contain at least two elements\")\n        return nil\n    end\n    \n \
    \   if #operator > #operand + 1 then\n        print(\"Error operator table: operator\
    \ table must contain at least two elements\")\n        return nil\n    end\n \
    \   \n    -- Get the first value\n    if #operand > 1 then\n        first_value\
    \ = operand[1]\n    end\n    \n    -- Get the second value\n    if #operand >\
    \ 2 then\n        second_value = operand[2]\n    end\n    \n    -- Get the number\
    \ of operator in the operator table\n    operator_count = #operator\n    \n  \
    \  -- Get the number of operand in the operand table\n    second_value_count =\
    \ #operand\n    \n    -- If the number of operator is 1 then there is no need\
    \ to make use of arithmetic operators.\n    -- In this case, use the 'arithmetic'\
    \ table.\n    if operator_count == 1 then\n        expression = {\n          \
    \  first = first_value,\n            second = second_value,\n            operator\
    \ = '+',\n            position = {\n                first = 1,\n             \
    \   second = 1\n            }\n        }\n        \n        result = first_value\n\
    \    else\n        -- If the number of operator is greater than 1, then use the\
    \ 'arithmetic' table to build\n        -- the expression and then evaluate the\
    \ expression using the operator table.\n        expression_table[1] = make_arithmetic_expression(first_value,\
    \ second_value, operator)\n        \n        for i = 2, operator_count do\n  \
    \          expression_table[i] = make_arithmetic_expression(expression_table[i-1],\
    \ second_value, operator)\n        end\n        \n        result = arithmetic_evaluation(expression_table)\n\
    \    end\n    \n    -- Return the result of the algebraic expression\n    return\
    \ result\nend", "  local result = {}\n  for i = 1, #operand do\n    result[#result+1]\
    \ = operand[i]\n  end\n  for i = 1, #operator do\n    result[#result+1] = result[#result+1]\
    \ + operator[i]\n  end\n  -- remove last value\n  result[#result+1] = result[#result+1]\
    \ - 1\n  return result\nend", "    assert(#operator == #operand - 1)\n    assert(#operand\
    \ > 0)\n    local result = nil\n    local i = 0\n    for i = 1, #operand do\n\
    \        result = result + operator[operand[i-1]](operand[i])\n    end\n    return\
    \ result\nend", "    local expression = nil\n    local length = #operand\n   \
    \ for i = 1, length do\n        local value = operand[i]\n        local operation\
    \ = operator[operand[i-1]]\n        expression = expression == nil and operation\
    \ or expression and expression[operation](value)\n    end\n    return expression\n\
    end", "    assert(#operand == #(operand:len()) - 1 )\n    local result = 0\n \
    \   \n    for i = 0, #operator do\n        local op = operator[i]\n        local\
    \ a1 = operand[i+1]\n        local a2 = operand[i+2]\n        local a3 = operand[i+3]\n\
    \        if op == \"*\" then\n            result = result + (a1 * a2 * a3)\n \
    \       elseif op == \"+\" then\n            result = result + (a1 + a2 + a3)\n\
    \        elseif op == \"-\" then\n            result = result - (a1 - a2 - a3)\n\
    \        elseif op == \"/\" then\n            result = result / (a1 / a2 / a3)\n\
    \        elseif op == \"//\" then\n            result = result % (a1 // a2 //\
    \ a3)\n        elseif op == \"**\" then\n            result = result ** a1 ^ a2\
    \ ^ a3\n        end\n    end\n    \n    return result\nend", "    local result\
    \ = 0\n    for i = 1, #operand do\n        local operand1 = operand[#operand]\n\
    \        local operator1 = operator[#operator]\n        local operand2 = operand[#operand]\n\
    \        local result1 = operand1 operator1 operand2\n        if result1 == nil\
    \ then\n            error(\"Invalid operand for operator \" .. operator1)\n  \
    \      end\n        result = result + result1\n    end\n    return result\nend",
  "   -- Check the length of operand and operator, make sure they are correct.\n \
    \  if #operator ~= #operand then\n      print('Bad operand or operator size. Check\
    \ argument length.') \n      return nil\n   end\n   \n   -- If operand is empty\
    \ return nil.\n   if #operand == 0 then \n      return nil \n   end\n   \n   --\
    \ Initialize stack\n   local stack = {}\n   \n   -- Loop through each operand\
    \ and do operation.\n   for _, value in pairs(operand) do\n      -- Check if there\
    \ are still operators in the stack.\n      if #stack > 0 then\n         -- Get\
    \ top\n         local top=stack[#stack]\n         -- If the operator is valid,\
    \ push the value to the stack and continue\n         if operator[top] == value\
    \ then \n            stack[#stack+1] = value\n            -- Continue with the\
    \ loop\n            continue\n         end\n      end\n      -- If the top is\
    \ nil then it is an error and we return nil\n      if top == nil then \n     \
    \    print('Bad operand or operator size.') \n         return nil\n      end\n\
    \      -- Reverse the current stack.\n      stack[#stack+1] = top\n      -- Get\
    \ the operator\n      local op = operator[top]\n      -- Do the operation\n  \
    \    local new_top = top\n      -- If the stack has multiple value\n      while\
    \ #stack > 1 do\n         -- Do the operation\n         new_top = stack[#stack-1]\
    \ \n         -- Pop the stack\n         stack[#stack] = stack[#stack-1]\n    \
    \     -- Continue with the loop\n         local value = stack[#stack]\n      \
    \   stack[#stack-1] = value\n      end\n      -- Do the operation\n      stack[#stack]\
    \ = new_top\n   end\n   \n   -- The top is nil, an error has occured.\n   if top\
    \ == nil then \n      print('Bad operand or operator size.') \n      return nil\n\
    \   end\n   \n   -- Return the result of the operation, nil if there is an error.\n\
    \   return stack[#stack]\nend", "    -- Start with empty string\n    local result\
    \ = ''\n    -- Loop through the operands and operators in the operands table\n\
    \    for i,v in ipairs(operand) do\n        -- Check if the operand is negative\n\
    \        if v < 0 then\n            result = '-' + result\n        else\n    \
    \        -- Start with empty string\n            result = ''\n            -- Loop\
    \ through the operators in the operator table\n            for j,v in ipairs(operator)\
    \ do\n                -- Add the result to the string\n                result\
    \ = v + result \n                -- If the result is zero or negative, stop\n\
    \                if result == '' or result < 0 then break end\n              \
    \  -- Break loop\n            end\n        end\n    end\n    -- Return the evaluated\
    \ expression\n    return result\nend", "    if #operator ~= #operand then\n  \
    \      return 'Error! Incompatible argument!';\n    end", "  local ops = table.copy(operator)\n\
    \  local res = nil\n  for i=1,#operand do\n    for k=#ops, 1, -1 do\n      local\
    \ op1 = ops[k]\n      local op2 = ops[k+1]\n      if operand[i] ~= nil and operand[i]\
    \ == op1 and operand[i+1] == op2 then\n        res = ops[k] + operand[i+1]\n \
    \       break\n      end\n    end\n  end\n  return res\nend", "  local index =\
    \ 1\n  local result = 0\n  while index <= #operand do\n    local operand_value\
    \ = operand[index]\n    local operand_type = type(operand_value)\n    local operand_value\
    \ = operand_value and operand_value[1] or operand_value\n    if operand_type ==\
    \ 'string' then\n      index = index + 1\n      result = result .. operand_value\n\
    \    elseif operand_type == 'number' then\n      result = result + operand_value\n\
    \    elseif operand_type == 'table' then\n      result = result + (do_algebra(operator,\
    \ operand_value))\n    end\n    index = index + 1\n  end\n  return result\nend",
  "   -- Write your code here\n   local result = 0\n   for _, v in pairs(operator)\
    \ do\n      result = result + operand[v] \n   end\n   return result\nend", "\t\
    local operand1, operand2 = unpack(operand)\n\tlocal result = operand1\n\tfor i\
    \ = 1, #operand1 do\n\t\tlocal operator1, operator2 = unpack(operator)\n\t\tif\
    \ operator1 == \"+\" and operand1[i] < operand2[i] then\n\t\t\tresult = result\
    \ + operand2[i]\n\t\telseif operator1 == \"-\" and operand1[i] > operand2[i] then\n\
    \t\t\tresult = result - operand2[i]\n\t\telseif operator1 == \"*\" and operand1[i]\
    \ * operand2[i] == 0 then\n\t\t\tresult = nil\n\t\telseif operator1 == \"//\"\
    \ and operand1[i] // operand2[i] == 0 then\n\t\t\tresult = nil\n\t\telseif operator1\
    \ == \"**\" and operand1[i] ** operand2[i] == 0 then\n\t\t\tresult = nil\n\t\t\
    end\n\tend\n\treturn result\nend", "   -- Get the size of the operand and operator\
    \ tables.\n   local operator_size, operator_size = #operand, #operator\n   \n\
    \   -- Allocate a result table. Since the first operand is always non-negative,\
    \ \n   -- the result table is of size operator_size + 1.\n   local result = {}\n\
    \   result[operator_size] = 1\n   \n   -- Iterate through the operand table and\
    \ perform the operation.\n   for i=1, operator_size do\n      -- Get the operation\
    \ from operator table.\n      local operation = operator[operand[i]]\n      \n\
    \      -- Iterate through the operand table and perform the operation.\n     \
    \ for j=1, operator_size do\n         -- Get the operation from operator table.\n\
    \         local operand = operand[j]\n         \n         -- If the operands are\
    \ non-negative, perform the operation.\n         if operand ~= 0 then\n      \
    \      result[j] = operation % operand\n            operation = operation // operand\n\
    \         else\n            result[j] = operation\n         end\n      end\n \
    \  end\n   return result\nend\n</cell>\n<text>\nExercise 2: Implement do_algebra,\
    \ given two tables operator, and operand. The first table has basic algebra operations,\
    \ and ", "    local function add_op(x, y) return x + y end\n    local function\
    \ sub_op(x, y) return x - y end\n    local function mul_op(x, y) return x * y\
    \ end\n    local function div_op(x, y) return x / y end\n    local function pow_op(x,\
    \ y) return x ** y end\n    local function exp_op(x, y) return x:exp(y) end",
  "    -- Write your code here.\n    local result_table = {}\n    for i = 1, #operand\
    \ do\n        local result = {}\n        for j = 1, #operator do \n          \
    \  result[#result + 1] = operand[i] - operand[j] * operator[j]\n        end\n\
    \        result_table[#result_table + 1] = result\n    end\n    local result =\
    \ 0\n    for i = 1, #result_table do\n        result = result + result_table[i][1]\n\
    \    end\n    \n    return result\nend", "    local function do_math(operation,\
    \ operand)\n        local operand_a = operand[1]\n        local operand_b = operand[2]\n\
    \        return operand_a .. operation .. operand_b\n    end\n    local function\
    \ do_power(operation, operand)\n        local operand_a = operand[1]\n       \
    \ local operand_b = operand[2]\n        return operand_a .. operation .. operand_b\
    \ .. '^' .. operand_b\n    end\n    local function do_add(operation, operand)\n\
    \        local operand_a = operand[1]\n        local operand_b = operand[2]\n\
    \        return operand_a + operand_b\n    end\n    local function do_subtract(operation,\
    \ operand)\n        local operand_a = operand[1]\n        local operand_b = operand[2]\n\
    \        return operand_a - operand_b\n    end\n    local function do_multiply(operation,\
    \ operand)\n        local operand_a = operand[1]\n        local operand_b = operand[2]\n\
    \        return operand_a * operand_b\n    end\n    local function do_floor(operation,\
    \ operand)\n        local operand_a = operand[1]\n        local operand_b = operand[2]\n\
    \        return operand_a .. operation .. operand_b\n    end\n    local function\
    \ do_exponent(operation, operand)\n        local operand_a = operand[1]\n    \
    \    local operand_b = operand[2]\n        return operand_a .. operation .. operand_b\
    \ .. '^' .. operand_b\n    end\n    local function do_divide(operation, operand)\n\
    \        local operand_a = operand[1]\n        local operand_b = operand[2]\n\
    \        return operand_a .. operation .. operand_b .. '//' .. operand_b\n   \
    \ end\n    local function do_exp(operation, operand)\n        local operand_a\
    \ = operand[1]\n        local operand_b = operand[2]\n        return operand_a\
    \ .. operation .. operand_b .. '^' .. operand_b .. '^' .. operand_b\n    end\n\
    \    local function do_power(operation, operand)\n        local operand_a = operand[1]\n\
    \        local operand_b = operand[2]\n        return operand_a .. operation ..\
    \ operand_b .. '^' .. operand_b .. '^' .. operand_b\n    end\n    local function\
    \ do_mod(operation, operand)\n        local operand_a = operand[1]\n        local\
    \ operand_b = operand[2]\n        return operand_a .. operation .. operand_b ..\
    \ '%' .. operand_b\n    end\n    local function do_and(operation, operand)\n \
    \       local operand_a = operand[1]\n        local operand_b = operand[2]", " \
    \   local result = 0\n    local num = 1\n    local idx = 0", "  -- Operator and\
    \ operand tables have the same length.\n  assert(#operator == #operand)\n  local\
    \ result\n  for i = 1, #operand do \n    -- Convert operand table element into\
    \ integer and evaluate expression.\n    local result_i\n    if #operand == 2 then\n\
    \      -- Operand table has two operands.\n      result_i = operand[i] + operand[i-1]\n\
    \    else\n      -- Operand table has three or more operands.\n      result_i\
    \ = operand[i] + operand[i-1] + operand[i-2]\n    end\n    -- Evaluate expression.\n\
    \    if #operator > 1 then\n      -- Add result of previous step to next step.\n\
    \      result = result + operator[i-1](operand[i-1], operand[i-2]) \n    else\n\
    \      result = result + operator[i-1](operand[i-1]) \n    end\n    -- Put result\
    \ into operand table.\n    operand[i] = result_i\n  end\n  return result\nend",
  "  local result, carry = 0, nil\n  for i = 1, #operator do\n    local carry_tmp,\
    \ operand1, operand2 = operand[i], operand[i+1], operand[i+2]\n    if operand1\
    \ == nil then\n      carry = carry_tmp\n    elseif operand2 == nil then\n    \
    \  carry = do_algebra(operator, operand1) + operand1 + carry\n    else\n     \
    \ result = do_algebra(operator, operand1) + (operand2 .. carry)\n      carry =\
    \ nil\n    end\n    if carry ~= nil then\n      result = nil\n      break\n  \
    \  end\n  end\n  return result + carry\nend", "    local result = 0\n    for i\
    \ = 1, #operand do\n        result = result + operand[i] * operator[#operator][(i-1)%#operator]\n\
    \    end\n    return result\nend\n</code>\n<|/ a tags=lua-table,lua |>\n<| c |>\n\
    `local operators = {['+'] = function(a, b) return a+b end,['-'] = function(a,\
    \ b) return a-b end,['*'] = function(a, b) return a*b end,['/'] = function(a,\
    \ b) return a/b end,['^'] = function(a, b) return a^b end}` and so on\n<|/ c |>\n\
    <| c |>\nThanks for the suggestion, however my tables are much more complex than\
    \ what I posted. I will update my question with more information.\n<|/ c |>\n\
    <| c |>\nThis should still work. The difference is that I'm doing `#operator`\
    \ instead of `#operand` in the line `operator[#operator][(i-1)%#operator]`.\n\
    <|/ c |>\n<| c |>\nIt does! I had a bug in my code, thanks for pointing it out.\
    \ Also, I added a note to my question, saying that the length of operator table\
    \ is equal to the length of operand table minus one.\n<|/ c |>\n<| c |>\n`operators[#operator][(i-1)%#operator]`\
    \ will also work as you originally had it, with one change.\n<|/ c |>\n<| a dscore=0\
    \ tags=lua-table,lua |>\nHere's my solution in Lua 5.1 without using loops. I\
    \ tested it with tables with different sizes.\n<code>", "    -- TODO: Implement\
    \ the do_algebra function\nend", "  -- Calculate the number of columns in both\
    \ operand and operator tables. \n  -- The tables are two dimensional arrays, each\
    \ subscript represents a column. \n  -- for example, operator['+', '*', '*'] represents\
    \ a column with index 1 and \n  -- operand table has two columns whose indices\
    \ are 1 and 2.\n  local number_of_columns = #operand + #operator\n  local result\
    \ = 1\n  for i = 0, #number_of_columns - 1 do \n    local left = operand[i - 1]\n\
    \    local right = operand[i + 1]\n    local operation = operator[i]\n    local\
    \ operation_index = #operator + 1\n    -- if the left column is negative, the\
    \ calculation must be performed using \n    -- floor division. if so, change operation_index\
    \ to reflect this.\n    if operation == '-' then\n      operation_index = 1\n\
    \      operation = '/'\n    end\n    -- perform the calculation and save the result\
    \ in the result table. \n    local result = result + operations[operation_index](left,\
    \ right)\n  end\n  return result\nend\n</textarea></form>", "  local table = {}\n\
    \  local i = #operand\n  for j = 0, i - 1 do\n    table[j] = math.pow(operand[j],\
    \ operator[j])\n  end\n  return table\nend", "   local result = nil\n   for i\
    \ = #operand, 1 do\n      local temp = operand[i]\n      local index = #operand\n\
    \      -- If the current operand is nil, stop here.\n      if operand[i] == nil\
    \ then break end\n      for k = #operator, 1 do\n         -- If the current operator\
    \ is nil, stop here.\n         if operator[k] == nil then break end\n        \
    \ -- If the current operand is nil, stop here.\n         if operand[i] == nil\
    \ then break end\n         -- Do the operation.\n         local temp1 = operand[i-1]\n\
    \         local temp2 = operand[index-1]\n         if operator[k] == '+' then\n\
    \            temp1 = temp1 + temp2\n         elseif operator[k] == '-' then\n\
    \            temp1 = temp1 - temp2\n         elseif operator[k] == '*' then\n\
    \            temp1 = temp1 * temp2\n         elseif operator[k] == '//' then\n\
    \            temp1 = temp1 // temp2\n         elseif operator[k] == '**' then\n\
    \            temp1 = temp1 ** temp2\n         else\n            assert(false,\
    \ 'Unknown operation')\n         end\n      end\n      -- Update the result with\
    \ the new value.\n      result = temp1\n   end\n   return result\nend", "    local\
    \ function get_operator(operator)\n        local operators = operator\n      \
    \  local operands = operand\n        for _, v in pairs(operators) do\n       \
    \     operators[v] = true\n        end\n        for _, v in pairs(operands) do\n\
    \            operands[v] = true\n        end\n        return operators, operands\n\
    \    end\n    local operators, operands = get_operator(operator)\n    local result\
    \ = nil\n    for _, v in pairs(operands) do\n        local t = operators[v]\n\
    \        if t then\n            result = v\n        end\n    end\n    return result\n\
    end", "   local function ops(op, num1, num2)\n      local op1 = operator[op]\n\
    \      local op2 = operator[op + 1]\n      return op1 and op1 and op1(num1, num2)\n\
    \   end", "    local result = 1\n    for i = 1, #operand do\n        result =\
    \ result * (operand[i]) ^ operator[i]\n    end\n    return result\nend", "\tlocal\
    \ result = 1\n\tfor i, v in ipairs(operand) do\n\t\tresult = result .. operator[#operator][v]\n\
    \tend\n\treturn result\nend", "   local result\n   if #operand > #operator then\
    \ \n      result = false\n   else\n      result = operand[1]\n      for i = 2,\
    \ #operand do\n         if operator[#operator - 1] == '+' then\n            result\
    \ = (result + operand[i]) \n         elseif operator[#operator - 1] == '-' then\n\
    \            result = (result - operand[i]) \n         elseif operator[#operator\
    \ - 1] == '*' then\n            result = (result * operand[i]) \n         elseif\
    \ operator[#operator - 1] == '//' then\n            result = (result // operand[i])\
    \ \n         elseif operator[#operator - 1] == '**' then\n            result =\
    \ (result ** operand[i]) \n         else\n            printf(\"This should not\
    \ happen!\\n\")\n         end\n      end\n   end\n   return result\nend", "\t\
    -- We want to store the expression in a table, so we define it as \n\t-- table\
    \ of tables of integers. \n\t-- First we compute the sum of each operand and the\
    \ operator's table:\n\tlocal sum = {}\n\t\n\t-- Go through the operator table\
    \ and sum the numbers for each operand:\n\tfor i, v in pairs(operator) do\n\t\t\
    -- Add the operand's table to the sum table:\n\t\tsum[i] = sum[i] + operand[i]\n\
    \tend\n\t-- Now we can compute the expression using the sum table:\n\t-- We use\
    \ floor division.\n\t-- We compute floor division by dividing the sum by its greatest\
    \ \n\t-- possible value which is equal to 1.\n\tlocal result = {}\n\t-- Go through\
    \ each operand and the sum table, sum them and store the result in the result\
    \ table:\n\tfor i, v in pairs(operand) do\n\t\t-- The result of this operation\
    \ is equal to the sum of the operand and the sum of the operator's table:\n\t\t\
    result[i] = sum[i] / v\n\tend\n\t-- Return the result as table.\n\treturn result\n\
    end", "  assert(#operator >= 1 and #operand >= 2)\n  local result = 1\n  \n  --\
    \ Iterate through each operand and apply operation with it.\n  local i = 1\n \
    \ for _, operand_value in pairs(operand) do\n    local operand_symbol = operator[i-1]\
    \ \n    local operand_value = operand_value or 0\n    local result_value = operand_value\
    \ * result\n    result = result_value\n  end\n  return result\nend", "  -- If\
    \ operand is not of table type throw error.\n  if not is_table(operand) then\n\
    \    error('Operand table is not table')\n  end\n  -- If length of operator table\
    \ is not equal to length of operand table minus one.\n  if not is_table(operator)\
    \ then\n    error('Operator table is not table')\n  end\n  -- Make sure length\
    \ of operator table is equal to length of operand table minus one.\n  if not #operator\
    \ == #operand - 1 then\n    error('Operator and operand tables length must be\
    \ equal')\n  end\n  local result = operand[1]\n  for i = 2, #operand do\n    local\
    \ op = operator[i]\n    local operand1 = operand[i]\n    local operand2 = operand[i-1]\n\
    \    result = result + (op(operand1, operand2) or 0)\n  end\n  return result\n\
    end", "   assert(operator)\n   assert(operand)\n   assert(#operand > 1)\n   assert(#operator\
    \ > 0)\n   assert(#operand == #operator - 1)"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
