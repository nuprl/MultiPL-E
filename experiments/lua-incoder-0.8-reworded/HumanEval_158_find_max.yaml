name: HumanEval_158_find_max
language: lua
prompt: "-- Write a function that accepts a table of strings.\n-- The table contains\
  \ different words. Return the word with maximum number\n-- of unique characters.\
  \ If multiple strings have maximum number of unique\n-- characters, return the one\
  \ which comes first in lexicographical order.\n-- >>> find_max({'name', 'of', 'string'})\n\
  -- 'string'\n-- >>> find_max({'name', 'enam', 'game'})\n-- 'enam'\n-- >>> find_max({'aaaaaaa',\
  \ 'bb', 'cc'})\n-- 'aaaaaaa'\nlocal function find_max(words)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = find_max\n\
  \    lu.assertEquals(candidate({'name', 'of', 'string'}), 'string')\n    lu.assertEquals(candidate({'name',\
  \ 'enam', 'game'}), 'enam')\n    lu.assertEquals(candidate({'aaaaaaa', 'bb', 'cc'}),\
  \ 'aaaaaaa')\n    lu.assertEquals(candidate({'abc', 'cba'}), 'abc')\n    lu.assertEquals(candidate({'play',\
  \ 'this', 'game', 'of', 'footbott'}), 'footbott')\n    lu.assertEquals(candidate({'we',\
  \ 'are', 'gonna', 'rock'}), 'gonna')\n    lu.assertEquals(candidate({'we', 'are',\
  \ 'a', 'mad', 'nation'}), 'nation')\n    lu.assertEquals(candidate({'this', 'is',\
  \ 'a', 'prrk'}), 'this')\n    lu.assertEquals(candidate({'b'}), 'b')\n    lu.assertEquals(candidate({'play',\
  \ 'play', 'play'}), 'play')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  return words[1]\nend", "  -- Use a dictionary to track the max character\
    \ count for each string\n  local max_count = words[1][1]\n  for i = 2, #words\
    \ do\n    local count = words[i][1]\n    if count > max_count then\n      max_count\
    \ = count\n    end\n  end\n  return words[max_count]\nend", "    local max = 0\n\
    \    local word\n    for word in pairs(words) do\n        if word:len() > max\
    \ then\n            max = word:len()\n        end\n    end\n    return max\nend",
  "    local word = words[1]\n    local count = 0\n    for i = 2, #words do\n    \
    \    if words[i] then\n            count = count + 1\n            if count > #word\
    \ then\n                word = words[i]\n            end\n        end\n    end\n\
    \    return word\nend", "  local max\n  local count = #words[1]\n  local word\
    \ = words[1][1]\n  for i = 2, #words do\n    local c = #words[i]\n    if count\
    \ > c and count > max then\n      max = count\n      word = words[i][1]\n    end\n\
    \    count = count-c\n  end\n  return word\nend", "    local max_num, max_char\
    \ = 0, nil\n    for _, word in ipairs(words) do\n        local char_num = #word\n\
    \        if char_num > max_num then\n            max_num, max_char = char_num,\
    \ word\n        end\n    end\n    return max_char\nend", "  -- Write your code\
    \ here.\n  local count = {}\n  for _, word in pairs(words) do\n    count = count\
    \ or {}\n    for letter in string.gsub(word, '[^'..string.char(127)..']') do\n\
    \      count = count[letter] or 0\n      count[letter] = count[letter] + 1\n \
    \   end\n  end\n  return words[count_index(count, words)]\nend", "  local max\
    \ = {}\n  local i = 1", "  -- Initialize max number with first word's number.\n\
    \  local max_number = 0\n  -- Initialize current word as nil.\n  local current\
    \ = nil\n  -- Iterate through all the words in the table.\n  for i = 1, #words\
    \ do\n    -- Iterate through all the letters in the current word.\n    for j =\
    \ 1, #words[i] do\n      -- Initialize count for the current letter to zero.\n\
    \      local count = 0\n      -- Iterate through all the letters in the table.\n\
    \      for k = 1, #words do\n        -- If current letter is equal to the current\
    \ word, then\n        -- increment count.\n        if words[k][j] == words[i][j]\
    \ then\n          count = count + 1\n        end\n      end\n      -- If the count\
    \ for the current letter is maximum, then update the\n      -- current letter\
    \ to current word. Also update the max number if\n      -- count for the current\
    \ letter is maximum.\n      if count > max_number and count > 1 then\n       \
    \ current = words[k]\n      end\n    end\n    -- If the current word is maximum,\
    \ then update the max number.\n    if current == words[i] then\n      max_number\
    \ = max_number + 1\n    end\n  end\n  -- Return current word if max number of\
    \ unique characters is maximum.\n  return current if max_number == #words[1]\n\
    \  -- Return first word which has maximum number of unique characters.\n  -- This\
    \ might not work if all the words have same maximum number of unique\n  -- characters.\n\
    \  return words[1]\nend", "    local max_char = nil\n    local max_count = 0\n\
    \    local max_word = nil\n    for i = 1, #words do\n        local count = 0\n\
    \        for j = 1, #words[i] do\n            count = count + 1\n            if\
    \ words[i][j] == words[i][j] then\n                count = count + 1\n       \
    \     end\n        end\n        if count > max_count then\n            max_char\
    \ = words[i][1]\n            max_count = count\n            max_word = words[i]\n\
    \        end\n    end\n    return max_word\nend", "  if #words == 0 then\n   \
    \ return \"<No words>\"\n  end\n  local result = {}\n  for i = 1, #words do\n\
    \    for j = 1, #words[i] do\n      table.insert(result, words[i][j])\n    end\n\
    \  end\n  table.sort(result, function(a, b) return #a < #b end)\n  if #result\
    \ == 0 then\n    return \"<No words>\"\n  end\n  return result[1]\nend", "   \
    \ local counts = {}\n    for _, word in ipairs(words) do\n        table.insert(counts,\
    \ 1)\n    end\n    local max = table.max(counts)\n    local max_idx = 1\n    for\
    \ _, v in ipairs(counts) do\n        if v == max then\n            max_idx = v\n\
    \        end\n    end\n    return words[max_idx]\nend", "  assert(type(words)\
    \ ~= 'table')\n  local uniques = {}\n  local max = nil", "  return words[#words]\n\
    end", "  local counts = {}\n  for _, word in pairs(words) do\n    table.insert(counts,\
    \ #counts, 0)\n  end\n  for _, word in pairs(words) do\n    counts[#counts][word]\
    \ = counts[#counts][word] + 1\n  end\n  return words[#counts] and\n    counts[#counts][words[#counts]]\
    \ and\n    words[#counts] or\n    words[1]\nend", "  local max = 0\n  local word\
    \ = {}\n  for i = 1, #words do\n    word[#word+1] = words[i]\n    word[#word+1]\
    \ = #words[#word]+1\n    if word[#word] > max then\n      max = word[#word]\n\
    \    end\n  end\n  for i = 1, #words do\n    if max <= word[#word] then\n    \
    \  return words[i]\n    end\n  end\nend", "    local max_count = words[1]\n  \
    \  local max_word = words[1]", "   local m = {}\n   for k, v in pairs(words) do\n\
    \      m[#m+1] = k\n   end\n   table.sort(m, function(a, b) return string.len(a)\
    \ < string.len(b) end)\n   return m[#m]\nend", "  -- Use a set to keep track of\
    \ the unique characters in the string\n  local char_set = {}", "  local max =\
    \ 0 -- Initialize maximum index.\n  local maxchar = 0 -- Initialize maximum character\
    \ count.\n  local index = 1 -- Initialize index for string table.\n  for word\
    \ in words do\n    if #word > max then -- Update maximum index.\n      max = index\n\
    \    end\n    index = index + 1\n    if #word > maxchar then -- Update maximum\
    \ character count.\n      maxchar = #word\n    end\n  end\n  if max == 0 then\
    \ -- If no words have maximum number of unique characters.\n    return nil\n \
    \ end\n  if #words[max] < 1 then -- If only one word has maximum number of unique\n\
    \    --         characters.\n    return nil\n  end\n  -- Return the word with\
    \ maximum number of unique characters.\n  return words[max]\nend", "    local\
    \ max = 0\n    local word", "  local max_count = 0\n  local max_word\n  for _,\
    \ word in pairs(words) do\n    local count = #word\n    if count > max_count then\n\
    \      max_count = count\n      max_word = word\n    end\n  end\n  return max_word\n\
    end", "    -- Write your code here.\nend", "   local max = {}\n   local word\n\
    \   for word in pairs(words) do\n      local count = count_unique(words[word])\n\
    \      if count > max[count] then\n         max[count] = word\n      end\n   end\n\
    \   return max[#max]\nend", "   local max_n = 0\n   local max_idx = nil\n   for\
    \ idx = 1, #words do\n      if words[idx] == words[max_idx] then\n         max_n\
    \ = max_n + 1\n      elseif max_n < words[idx] then\n         max_n = words[idx]\n\
    \         max_idx = idx\n      end\n   end\n   return words[max_idx]\nend", " \
    \   local max_count = -1\n    local max_word = nil\n    for _, word in ipairs(words)\
    \ do\n        local count = 0\n        for char in word do\n            count\
    \ = count + 1\n        end\n        if count > max_count then\n            max_count\
    \ = count\n            max_word = word\n        end\n    end\n    return max_word\n\
    end", "    local count = #words\n    for i = 1, count do\n        local word =\
    \ \"\"\n        local max_count = 0\n        for j = 1, #words do\n          \
    \  -- If current word has the same number of unique characters\n            --\
    \ as the previous word, we can ignore it.\n            -- If this word has the\
    \ maximum number of unique characters, \n            -- we will ignore it regardless\
    \ of order.\n            if #word == #words[j] and\n                word:sub(1,\
    \ #word) == words[j]:sub(1, #word) then\n                count = count - 1\n \
    \               -- This word has the maximum number of unique characters\n   \
    \             -- as the previous one. Keep it.\n                max_count = #words[j]\
    \ + 1\n            end\n        end\n        if max_count == count then\n    \
    \        return word\n        end\n    end\nend", "   local max = tonumber(words[1])\
    \ or 1\n   for i = 2, #words do\n      local count = tonumber(words[i])\n    \
    \  if count > max then\n         max = count\n         words[1] = words[i]\n \
    \     elseif count == max then\n         break\n      end\n   end\n   return words[1]\n\
    end", "    local words = words or {}\n    local max_counts = {}\n    for _,v in\
    \ pairs(words) do\n        table.insert(max_counts, #v)\n    end\n    local max_count\
    \ = #max_counts\n    max_count = max_count ~= 0 and max_count or 1\n    for _,v\
    \ in pairs(words) do\n        table.sort(max_counts, function(a, b) return #v\
    \ > a end,\n            function(a, b) return #v < b end,\n            function(a,\
    \ b) return a < b end)\n        if max_count ~= #max_counts then\n           \
    \ break\n        end\n        max_count = #max_counts\n    end\n    return max_counts\
    \ == max_count and words[max_counts[max_count]]\nend", "    local max = 0\n  \
    \  local word = \"\"\n    for w in words,\n    do\n        local n = 0\n     \
    \   for i = 1, #w do\n            n = n + 1\n            if n == max then\n  \
    \              word = w\n                break\n            end\n        end\n\
    \        if n == max then\n            max = max + 1\n        end\n    end\n \
    \   return word\nend", "    local max = 0\n    local result = nil\n    for w in\
    \ words:gmatch(\"[^%s]+\") do\n        max = math.max(max, #w)\n        if #result\
    \ < max then\n            result = w\n        end\n    end\n    return result\n\
    end", "    local counter = #words\n    local max = words[1]\n    for i = 1, #words\
    \ do\n        if words[i] ~= max then\n            counter = counter - 1\n   \
    \         max = words[i]\n        end\n    end\n    return max if counter ~= 0\
    \ then words[#words] end\nend", "  local max_word = ''\n  local max_count = 0\n\
    \  local word", "  if words == nil then return nil end\n  local max_count = 0\n\
    \  local max_value = words[1]\n  for i = 2, #words do\n    local count = words[#words]\n\
    \    if count > max_count then\n      max_value = words[i]\n      max_count =\
    \ count\n    end\n  end\n  return max_value\nend", "  -- Write your code in Lua\
    \ here\n  local maxChars = { }\n  for _, w in pairs(words) do\n    local count\
    \ = {}\n    for _, c in pairs(w) do\n      count[c] = count[c] or 0\n      count[c]\
    \ = count[c] + 1\n    end\n    local maxKey = table.pairs(count).keyOfMax()\n\
    \    maxChars[w[maxKey]] = true\n  end\n  table.sort(words, function(a, b) return\
    \ #maxChars[a] > #maxChars[b] end) -- a comes first if number of chars\n  return\
    \ table.concat(words)\nend", "  if #words == 0 then\n    return nil\n  else\n\
    \    local max = 0\n    local index\n    for index = 1, #words do\n      local\
    \ char_count = #words[index]\n      if char_count > max then\n        max = char_count\n\
    \        index = index\n      end\n    end\n    return words[index]\n  end\nend",
  "  local max = {}\n  for k, v in pairs(words) do\n    local letters = #v\n    if\
    \ letters > max[letters] then\n      max[letters] = {k, v}\n    end\n  end\n \
    \ local maxCount = 1\n  for i = 1, #max do\n    maxCount = maxCount + max[i][1]\n\
    \  end\n  local sortedKeys = {}\n  for i = 1, #max do\n    table.insert(sortedKeys,\
    \ max[i][1])\n  end\n  table.sort(sortedKeys)\n  return sortedKeys[1]\nend", " \
    \  -- Write your solution here\n   return nil\nend", "   local max = 0\n   local\
    \ best_index = -1\n   for i = 1, #words do\n      local count = 0\n      for j\
    \ = 1, #words[i] do\n         count = count + 1\n         if words[i][j] == words[max][j]\
    \ then\n            count = count + 1\n         end\n         if count > max then\n\
    \            max = count\n            best_index = i\n         end\n      end\n\
    \   end\n   return words[best_index]\nend", "   local max,count = 1,0\n   for\
    \ i,v in pairs(words) do\n      if v~=nil and #v>count then count=#v max=v end\n\
    \   end\n   return max\nend", "    local nums = { }\n    for _, word in ipairs(words)\
    \ do\n        if nums[#nums + 1] ~= nil then\n            if #nums[#nums + 1]\
    \ > #word then -- word comes first\n                return word\n            end\n\
    \        else\n            table.insert(nums, #word + 1)\n        end\n    end\n\
    \    return words[math.min(#words - 1, #nums)]\nend", "  if #words == 0 then\n\
    \    return nil\n  end\n  local keys = {}\n  local maxChars = 0\n  local curChars\
    \ = 0\n  for i = 1, #words do\n    local chars = #words[i]\n    if #keys == 0\
    \ or chars > maxChars then\n      maxChars = chars\n    end\n    if #keys and\
    \ chars == maxChars then\n      table.insert(keys, words[i])\n    else\n     \
    \ keys[#keys + 1] = words[i]\n    end\n  end\n  table.sort(keys)\n  return table.unpack(keys)[1]\n\
    end", "  assert(type(words) == 'table')\n  local unique_chars = #words\n  local\
    \ max_count = 0\n  local best_word\n  for i = 1, #words do\n    if #words[i] ~=\
    \ unique_chars then\n      break\n    end\n    if max_count < unique_chars then\n\
    \      max_count = unique_chars\n      best_word = words[i]\n    end\n    unique_chars\
    \ = unique_chars - 1\n  end\n  return best_word\nend", "  -- Initialize maxcount\
    \ and maxword as empty tables.\n  local maxcount = { }\n  local maxword = { }",
  "    local max = {}\n    for i = 1, #words do\n        local count = {}\n      \
    \  for j = 1, #words[i] do\n            table.insert(count, words[i][j])\n   \
    \     end\n        local maxvalue = -1\n        for k = 1, #count do\n       \
    \     if maxvalue < count[k] then\n                maxvalue = count[k]\n     \
    \           max[k] = words[i][k+1]\n            end\n        end\n    end\n  \
    \  \n    for i = 1, #words do\n        for j = 1, #words[i] do\n            words[i][j]\
    \ = max[words[i][j]]\n        end\n    end\n    return table.concat(max)\nend",
  "  if #words == 1 then\n    return words[1]\n  end", "  local max_chars, best_word,\
    \ best_pos = 0, nil, nil -- The best number of unique characters, and the word\
    \ and the position in the table.\n  table.sort(words, function(a, b) return #a\
    \ == #b end)\n  for _, word in ipairs(words) do -- Loop through each word in the\
    \ list.\n    local curr_chars = 0 -- The number of unique characters in the current\
    \ word.\n    for _, c in ipairs(word) do -- Loop through each character in the\
    \ current word.\n      if curr_chars < #c then -- If current word has enough unique\
    \ characters, increase the current unique characters.\n        curr_chars = #c\n\
    \      else\n        -- If current word has too many unique characters, delete\
    \ the word from our table and continue.\n        if best_chars <= curr_chars then\n\
    \          table.insert(words, best_word) -- Add the current word to the table.\n\
    \          table.insert(words, best_pos) -- Add the current position to the table.\n\
    \          break\n        else\n          table.insert(words, word) -- Add the\
    \ current word to the table.\n          table.insert(words, curr_pos) -- Add the\
    \ current position to the table.\n          break -- The word is too long and\
    \ has too many unique characters, so we must keep it.\n        end\n      end\n\
    \    end\n    local word_with_max_chars = table.remove(words) -- The word with\
    \ the maximum number of unique characters.\n    if word_with_max_chars == best_word\
    \ then\n      best_chars = curr_chars -- The maximum number of unique characters\
    \ in the word is equal to the number of unique characters in the word. Store this\
    \ value.\n    end\n  end\n  return best_word, best_pos\nend", "    local alphabet\
    \ = {}\n    for i, word in ipairs(words) do\n        table.insert(alphabet, word)\n\
    \    end\n    table.sort(alphabet, function(a, b)\n        return #a > #b\n  \
    \  end)\n    for _, word in ipairs(words) do\n        alphabet[#alphabet+1] =\
    \ word\n    end\n    return alphabet[1]\nend", "    local max_count = nil\n  \
    \  local max_word = nil\n    for i, word in ipairs(words) do\n        local count\
    \ = #word\n        if max_count == nil or count > max_count then\n           \
    \ max_count = count\n            max_word = word\n        end\n    end\n    return\
    \ max_word\nend", "    local max = {}\n    local word_length = {}", "  local maxn\
    \ = 0\n  local word = words[1]\n  for _, v in ipairs(words) do\n    if maxn <\
    \ #v then\n      maxn = #v\n      word = v\n    end\n  end\n  return word\nend",
  "    local maxchars = 0\n    local maxchar = ''\n    local sortedkeys = table.sort(words)\n\
    \    for _, v in ipairs(sortedkeys) do\n        local count = 0\n        for _,\
    \ c in pairs(v) do\n            count = count + 1\n        end\n        if count\
    \ > maxchars then\n            maxchars = count\n            maxchar = v\n   \
    \     end\n    end\n    return maxchar\nend", "  local max_count = -1\n  local\
    \ max_word  = nil\n  for _, word in ipairs(words) do\n    if word:gsub('%w+'):gsub(('-'):rep(table.max(table.concat(word:gsub('%w+'):gsub('%d+'):gsub('+'):gsub('-'):gsub('%d-'):gsub('%D'):gsub('%d+'):gsub('%d-'):gsub('%T')):gsub('%d'):gsub('%d-'):gsub('%H'):gsub('%I'):gsub('%M'):gsub('%p'):gsub('%m'):gsub('%s'):gsub('%w'):gsub('%W'):gsub('%d%z'):gsub('%d%S'):gsub('%d%W'):gsub('%d%z%S'):gsub('%z')):gsub('%Z')):gsub('%x'):gsub('%X'):gsub('%o'):gsub('%j')):gsub('^[%z\\\
    [\\]]*$', ''):gsub('^[^%z\\[\\]]*$', ''):gsub('^0*$', ''):gsub('^%$', ''):gsub('^%-%$',\
    \ ''):gsub('^0%$', ''):gsub('^0%-%$', ''):gsub('^%0$', ''):gsub('^%-0$', ''):gsub('^0$',\
    \ ''):gsub('^-0$', ''):gsub('^%0$', ''):gsub('^%-0$', ''):gsub('^%0*$', ''):gsub('^%0%$',\
    \ ''):gsub('^%0*%$', ''):gsub('^%0*0$', ''):gsub('^%0%$', ''):gsub('^%0*%$', ''):gsub('^%0*%*$',\
    \ ''):gsub('^%0%0%$', ''):gsub('^%0%0%0%$', ''):gsub('^%0*0%0%$', ''):gsub('^%0%0%0%$',\
    \ ''):gsub('^%0%0%0*$', ''):gsub('^%0%0%0%0$', ''):gsub('^%0%0%0%0%$', ''):gsub('^%0*0%0%0%$',\
    \ ''):gsub('^%0%0%0%0$', ''):gsub('^%0%0%0%0%$', ''):gsub('^0%0%0%0%$', ''):gsub('^",
  "  local max = 1\n  local max_word\n  for _, word in ipairs(words) do\n    local\
    \ n = #word\n    if n > max then\n      max = n\n      max_word = word\n    end\n\
    \  end\n  return max_word\nend", "  -- Initialize maxcount with number of unique\
    \ characters of first string\n  -- This is used to pick the first string as maxcount\
    \ is initially set to 0\n  local maxcount = words[1][1]\n  -- Initialize max_word\
    \ to the first string\n  local max_word = words[1][2]\n  -- loop over all other\
    \ strings\n  for i = 2, #words do\n    -- Get number of unique characters in the\
    \ current string\n    local count = words[i][2]\n    -- If current string has\
    \ more unique characters, update maxcount\n    if count > maxcount then\n    \
    \  -- update maxcount with number of unique characters in current string\n   \
    \   maxcount = count\n      -- update max_word to the current string\n      max_word\
    \ = words[i][2]\n    end\n  end\n  return max_word\nend", "    local num_chars\
    \ = {}\n    local max_chars = nil\n    for word in words do\n        local num_chars[word]\
    \ = 0\n    end\n    local max_word = nil\n    for word in words do\n        num_chars[word]\
    \ = num_chars[word] + 1\n        if num_chars[word] > max_chars then\n       \
    \     max_chars = num_chars[word]\n            max_word = word\n        end\n\
    \    end\n    return max_word\nend", "  -- base case\n  if #words == 1 then\n\
    \    return words[1]\n  end", "    if words == nil then\n        return nil\n\
    \    end", "  local largest = {}\n  for i = 1, #words do\n    local counts = {}\n\
    \    for j = 1, #words[i] do\n      table.insert(counts, words[i][j])\n    end\n\
    \    largest[i] = counts[1]\n    for j = 2, #counts do\n      if counts[j] > largest[i]\
    \ then\n        largest[i] = counts[j]\n      end\n    end\n  end\n  table.sort(largest)\n\
    \  table.insert(largest, 'zzzzzzzzzz')\n  return largest[2]\nend", "  local counts\
    \ = {}\n  for _, word in pairs(words) do\n    local count = counts[word]\n   \
    \ counts[word] = count or 0\n    counts[word] = counts[word] + 1\n  end\n  --\
    \ return the word with maximum number of unique characters\n  local max\n  for\
    \ word, _ in pairs(counts) do\n    if max and max[2] > counts[word] then\n   \
    \   max = word\n    end\n  end\n  return max\nend", "  assert(type(words) == 'table')\n\
    \  -- We could sort the table by length, but this would be inefficient.\n  local\
    \ max_chars = {}\n  -- Initialize max_chars to include all chars in the table.\n\
    \  for i = 1, #words do\n    max_chars[words[i]] = words[i]\n  end\n  -- Iterate\
    \ through all unique characters in the table.\n  for i = 1, #max_chars do\n  \
    \  -- Iterate through all words in the table.\n    for j = 1, #words do\n    \
    \  -- If the current word has this unique character, increment the counter.\n\
    \      if words[j] == max_chars[i] then\n        max_chars[i] = max_chars[i] +\
    \ 1\n        break\n      -- If the current word does not have the unique character,\
    \ reset the\n      -- counter.\n      elseif words[j] ~= max_chars[i] then\n \
    \       max_chars[i] = words[j]\n      end\n    end\n    -- If we found a word\
    \ with the maximum number of unique characters, return it.\n    if max_chars[i]\
    \ == #words then\n      return max_chars[i]\n    end\n  end\n  return 'unknown'\n\
    end", "  -- Write your code here\n  local max = 0 \n  local max_word = nil\n \
    \ for i=1,#words,1 do \n    local word = words[i]\n    local count = 0\n    for\
    \ j = 1,#word,1 do \n      local c = word:sub(j,j+1)\n      if c:byte() ~= nil\
    \ then\n        count = count + 1\n      end\n    end\n    if count > max then\n\
    \      max = count\n      max_word = word\n    end\n  end\n  return max_word\n\
    end", "  local max = 0\n  local min\n  for _, word in ipairs(words) do\n    if\
    \ max < #word then\n      max = #word\n      min = word\n    end\n  end\n  if\
    \ min ~= \"\" then\n    return min\n  else\n    return \"\"\n  end\nend", "  local\
    \ max = 0\n  local word = {}\n  local keys = {}", "  local maxChar = 0\n  local\
    \ maxWord\n  for _, word in ipairs(words) do\n    local charCount = #word\n  \
    \  if charCount > maxChar then\n      maxChar = charCount\n      maxWord = word\n\
    \    end\n  end\n  if maxWord ~= nil then\n    return maxWord\n  end\n  return\
    \ words[1]\nend", "  local max = 0\n  local index = 1\n  while true do\n    local\
    \ count = 0\n    for _, word in pairs(words) do\n      if count == max then\n\
    \        index = index - 1\n        break\n      end\n      count = count + 1\n\
    \    end\n    if count == max then\n      break\n    end\n    if max > 0 then\n\
    \      max = count - 1\n    end\n  end\n  return words[index]\nend", "  if #words\
    \ == 1 then\n    return words[1]\n  end\n  local maxChars = {}\n  for _, word\
    \ in ipairs(words) do\n    local count = #word\n    for _, c in ipairs(word) do\n\
    \      count = count - 1 -- decrease count by 1\n      if not maxChars[c] then\n\
    \        maxChars[c] = count -- set current count to 1 when the character is encountered\n\
    \      elseif maxChars[c] > count then\n        maxChars[c] = count -- set current\
    \ count to count when the character is encountered\n      end\n    end\n  end\n\
    \  return words[#maxChars]\nend", "  local max_count = 0\n  local max_word\n \
    \ for word, count in pairs(words) do\n    if count > max_count then\n      max_count\
    \ = count\n      max_word = word\n    end\n  end\n  return max_word\nend", "\t\
    local max_c = 0\n\tlocal max_w = nil\n\tlocal max_i = nil\n\tfor i = 1, #words\
    \ do\n\t\tlocal c = #words[i]\n\t\tif c == 0 then\n\t\t\tc = 1\n\t\telse\n\t\t\
    \tc = #words[i] + 1\n\t\tend\n\t\tif c > max_c then\n\t\t\tmax_c = c\n\t\t\tmax_w\
    \ = words[i]\n\t\t\tmax_i = i\n\t\tend\n\tend\n\tif max_c == 0 then\n\t\treturn\
    \ nil\n\tend\n\ttable.sort(words, function(a, b) return #a > #b end)\n\treturn\
    \ max_w\nend", "    local max_chars = #words[1]\n    for _, word in pairs(words)\
    \ do\n        local count = 1\n        for ch in word:gmatch'[^%z]+' do\n    \
    \        if counts[ch] > count then\n                max_chars = ch\n        \
    \    end\n            count = count + 1\n        end\n    end\n    return words[max_chars]\n\
    end", "    local max = {}\n    for _, v in pairs(words) do\n        table.insert(max,\
    \ table.max(v, function(t) return #t end))\n    end\n    return max[1]\nend",
  "\tlocal max_num = 0\n\tlocal max_word\n\tfor _, word in pairs(words) do\n\t\tlocal\
    \ word_len = #word\n\t\tif word_len > max_num then\n\t\t\tmax_num = word_len\n\
    \t\t\tmax_word = word\n\t\tend\n\tend\n\treturn max_word\nend", "    local num_unique\
    \ = 0\n    local num_char = nil\n    local result = nil\n    local i, j = 0, 0\n\
    \    for i = 1, #words do\n        local word = \"\"\n        while word:sub(j,\
    \ j + #word) < words[i] do\n            word = word..words[i]\n        end\n \
    \       num_unique = #word - #words[i] + 1\n        num_char = #word\n       \
    \ if num_unique > num_char then\n            result = word\n        end\n    \
    \    j = j + #word\n    end\n    return result or words[1]\nend", "  local max_count\n\
    \  local max_word\n  for _, word in ipairs(words) do\n    local count = 1\n  \
    \  for _, c in ipairs(word) do\n      if count == max_count then return max_word\
    \ end\n      if c == 'a' then count = count + 1 end\n    end\n    max_count =\
    \ count\n    max_word = word\n  end\n  return max_word\nend", "    if #words ==\
    \ 0 then\n        return nil\n    end\n    local maxLength = 0\n    local maxWord\
    \ = nil\n    for _, word in ipairs(words) do\n        local wordLength = #word\n\
    \        if wordLength > maxLength then\n            maxLength = wordLength\n\
    \            maxWord = word\n        end\n    end\n    return maxWord\nend", " \
    \   -- Base case: if only 1 word, it doesn't matter\n    if #words == 1 then\n\
    \        return words[1]\n    end\n    -- Get a list of all characters in the\
    \ word and use that to compare\n    local chars = words[1]:gsub(\"(.)\", function(x)\n\
    \        return x:byte()\n    end)\n    local m = #chars\n    -- Initialize with\
    \ largest possible value\n    local max = #chars\n    -- Go through other words\
    \ and compare each character with the maximum\n    for i = 2, #words do\n    \
    \    local current_chars = words[i]:gsub(\"(.)\", function(x)\n            return\
    \ x:byte()\n        end)\n        m = #current_chars\n        if m > max then\n\
    \            max = m\n        end\n    end\n    -- Return the largest value\n\
    \    return chars[max]\nend", "  assert(type(words) == 'table')\n  local max_chars\
    \ = {}\n  local max_word = ''\n  local last_index = #words\n  for i = 0, last_index\
    \ do\n    local current_word = words[i]\n    local current_unique_count = count_unique_strings(current_word)\n\
    \    if i == 0 then\n      max_chars = current_unique_count\n      max_word =\
    \ current_word\n    end\n    if current_unique_count > max_chars then\n      max_chars\
    \ = current_unique_count\n      max_word = current_word\n    end\n  end\n  return\
    \ max_word\nend", "  local max_len = 0\n  local max_word\n  for word in pairs(words)\
    \ do\n    local num_chars = #word\n    if num_chars > max_len then\n      max_len\
    \ = num_chars\n      max_word = word\n    end\n  end\n  if max_len > 0 then\n\
    \    return max_word\n  else\n    return nil\n  end\nend", "  -- Initialize variables\n\
    \  local max_len = 0\n  local min_len = #words[1]\n  local word = words[1][1]\n\
    \  -- Iterate through all words\n  for i = 2, #words do\n    -- Get number of\
    \ unique characters\n    local num_unique_chars = 0\n    local letter = words[i][1]\n\
    \    -- Iterate through all characters\n    for j = 1, #letter do\n      -- Check\
    \ if character is unique\n      if letter[j] ~= letter[num_unique_chars] then\n\
    \        num_unique_chars = num_unique_chars + 1\n      else\n        num_unique_chars\
    \ = 1\n      end\n    end\n    -- If number of unique characters is maximum, update\
    \ max length\n    if num_unique_chars == max_len then\n      max_len = num_unique_chars\n\
    \      word = words[i]\n    end\n    -- If number of unique characters is minimum,\
    \ update min length\n    if num_unique_chars < min_len then\n      min_len = num_unique_chars\n\
    \    end\n  end\n  return word\nend", "    local max_count, max_word = 1, nil\n\
    \    for i, word in ipairs(words) do\n        local count = 0\n        for _,\
    \ v in ipairs(word) do\n            count = count + 1\n        end\n        if\
    \ count > max_count then\n            max_count, max_word = count, word\n    \
    \    end\n    end\n    return max_word\nend", "  local max = {}\n  local maxCount\
    \ = 0\n  local maxString = \"\"\n  for i = 1, #words do\n    local count = {}\n\
    \    for j = 1, #words[i] do\n      local count = count[words[i][j]]\n      if\
    \ count == nil then\n        count = 1 \n      elseif count > maxCount then\n\
    \        maxCount = count\n        maxString = words[i][j]\n      else\n     \
    \   count = count + 1\n      end\n      count[words[i][j]] = count\n    end\n\
    \  end\n  -- print(maxCount)\n  -- print(maxString)\n  -- print(max)\n  return\
    \ maxString\nend", "  assert(type(words) == 'table')\n  local max_count = 0\n\
    \  local max_string = ''\n  local word = ''\n  for i, v in ipairs(words) do\n\
    \    count = string.len(v)\n    if count > max_count then\n      word = v\n  \
    \    max_count = count\n    elseif count == max_count then\n      if string.len(v)\
    \ < string.len(max_string) then\n        word = v\n      else\n        max_string\
    \ = word\n      end\n    end\n  end\n  return max_string\nend", "  local max,\
    \ c = nil, 0\n  for _, word in pairs(words) do\n    local count = #word\n    if\
    \ count > c then max, c = word, count end\n  end\n  return max\nend", "\tlocal\
    \ n = #words\n\t-- We use integer representation of character as counters\n\t\
    local max_chars = {}\n\t-- First character of words is used as the starting point\n\
    \tfor i = 1, n do\n\t\tlocal chars = string.gsub(words[i], '%c', '%s')\n\t\t--\
    \ Count the number of unique characters\n\t\tfor j = 1, #chars do\n\t\t\t-- Store\
    \ the counter if it hasn't been seen yet\n\t\t\tif not max_chars[chars[j]] then\n\
    \t\t\t\tmax_chars[chars[j]] = 0\n\t\t\tend\n\t\t\t-- Increment counter\n\t\t\t\
    max_chars[chars[j]] = max_chars[chars[j]] + 1\n\t\tend\n\t\t-- For every other\
    \ word, starting point is the last character in word\n\t\tif i == n then\n\t\t\
    \tfor j = 1, #chars do\n\t\t\t\t-- Store the counter if it hasn't been seen yet\n\
    \t\t\t\tif not max_chars[chars[j]] then\n\t\t\t\t\tmax_chars[chars[j]] = 0\n\t\
    \t\t\tend\n\t\t\t\t-- Increment counter\n\t\t\t\tmax_chars[chars[j]] = max_chars[chars[j]]\
    \ + 1\n\t\t\tend\n\t\tend\n\tend\n\t-- Return the word with maximum number of\
    \ unique characters\n\tlocal max_word = {}\n\tlocal max_count = 0\n\tlocal max_key\
    \ = nil\n\tfor key in pairs(max_chars) do\n\t\tif max_count < max_chars[key] then\n\
    \t\t\tmax_count = max_chars[key]\n\t\t\tmax_word = key\n\t\tend\n\tend\n\tif #max_word+1\
    \ == #words then\n\t\treturn max_word\n\telse\n\t\treturn nil\n\tend\nend", " \
    \ local maxWord = words[1]\n  local maxCharCount = 1\n  for i = 2, #words do\n\
    \    local char = words[i]\n    local count = #words[i]\n    if count > maxCharCount\
    \ or char == maxWord then\n      maxCharCount = count\n      maxWord = char\n\
    \    end\n  end\n  return maxWord\nend", "  -- Your code here!\n  \n  -- Step\
    \ 1: Find number of unique characters in each word.\n  -- >>> find_max({'name',\
    \ 'of', 'string'})\n  -- 3\n  -- >>> find_max({'name', 'enam', 'game'})\n  --\
    \ 2\n  -- >>> find_max({'aaaaaaa', 'bb', 'cc'})\n  -- 3\n  -- >>> find_max({'ab',\
    \ 'cd'})\n  -- 3\n  local max = 1\n  local word = \"\"\n  for _, word in pairs(words)\
    \ do\n    -- Step 2: Find max number of unique characters.\n    -- >>> find_max({'name',\
    \ 'of', 'string'})\n    -- 3\n    -- >>> find_max({'name', 'enam', 'game'})\n\
    \    -- 2\n    -- >>> find_max({'aaaaaaa', 'bb', 'cc'})\n    -- 3\n    -- >>>\
    \ find_max({'ab', 'cd'})\n    -- 3\n    \n    -- Step 3: Get first unique character\
    \ and append it to word.\n    -- >>> find_max({'aaaaaaa', 'bb', 'cc'})\n    --\
    \ 3\n    local count = 0\n    for char in word do\n      if char == word[count]\
    \ then\n        count = count + 1\n      elseif count > max then\n        max\
    \ = count\n        word = word\n      end\n    end\n  end\n  \n  -- Step 4: If\
    \ there are multiple strings with max number of unique characters,\n  -- return\
    \ the one that comes first in lexicographical order.\n  -- >>> find_max({'aaaaaaa',\
    \ 'bb', 'cc'})\n  -- 3\n  -- >>> find_max({'aaaaa', 'bbb', 'ccc'})\n  -- 1\n \
    \ -- >>> find_max({'aaa', 'bbb', 'ccc'})\n  -- 1\n  -- >>> find_max({'aa', 'bbb',\
    \ 'ccc'})\n  -- 1\n  -- >>> find_max({'a', 'bbb', 'ccc'})\n  -- 1\n  return word\n\
    end", "  local max = 0\n  local first = nil", "  local max = {}\n  local i = 1\n\
    \  for k in pairs(words) do\n    if string.len(k) > max[#max] then\n      max[#max]\
    \ = k\n    end\n  end\n  i = #max\n  if i == 1 then\n    return max[1]\n  end\n\
    \  local j = 1\n  while i <= #max do\n    if string.len(max[j]) < string.len(max[i])\
    \ then\n      j = j + 1\n    else\n      return max[j]\n    end\n  end\n  return\
    \ max[1]\nend", "    local max = 0\n    local word = nil\n    for _,v in ipairs(words)\
    \ do\n        local count = 0\n        for i = 1,#v do\n            if v[i] ==\
    \ words[max] then\n                count = count + 1\n            end\n      \
    \  end\n        if count > max then\n            max = count\n            word\
    \ = v\n        end\n    end\n    return word\nend", "    local sorted_words =\
    \ {}\n    local highest_num = 0\n    local highest_word = words[1]\n    local\
    \ word_length = 0\n    for _, word in pairs(words) do\n        word_length = #word\n\
    \        if word_length == 0 then break end\n        sorted_words[word] = sorted_words[word]\
    \ + 1\n        if sorted_words[word] > highest_num then\n            highest_num\
    \ = sorted_words[word]\n            highest_word = word\n        end\n    end\n\
    \    if highest_num == 0 then\n        return highest_word\n    else\n       \
    \ for i = 1, #sorted_words do\n            if sorted_words[i] <= highest_num then\n\
    \                return highest_word\n            end\n        end\n    end\n\
    end", "    local max = 0\n    local maxstring = \"\"\n    for _,word in ipairs(words)\
    \ do\n        local num_unique = string.len(string.gsub(word, '%W', ''))\n   \
    \     if num_unique > max then\n            max = num_unique\n            maxstring\
    \ = word\n        end\n    end\n    return maxstring\nend", "  -- Initially, we\
    \ assume that each word has only one unique character. Then,\n  -- we iterate\
    \ over the words. If a word has more than one unique character,\n  -- we set its\
    \ length to one and check if it comes first in lexicographical\n  -- order. Else,\
    \ we set its length to zero and check if it comes first in\n  -- lexicographical\
    \ order.\n  for _, word in ipairs(words) do\n    local len = #word\n    if len\
    \ > 1 then\n      local index = true\n      -- Check whether the word comes before\
    \ all other words with the same\n      -- number of unique characters.\n     \
    \ for _, w in ipairs(words) do\n        -- If the current word has the same number\
    \ of unique characters as the\n        -- current word, check whether its lexicographical\
    \ order comes before the\n        -- current word.\n        if len == #w then\n\
    \          index = index and #w < #word\n        end\n      end\n      -- If none\
    \ of the words with the same number of unique characters are in\n      -- lexicographical\
    \ order, the word with the maximum number of unique\n      -- characters is returned.\n\
    \      if index then\n        return word\n      end\n    end\n  end\n  return\
    \ nil\nend", "  local max = {value = nil, index = -1}\n  local index = 0\n  for\
    \ i = 1, #words do\n    local count = 0\n    local j = i\n    while words[j] and\
    \ words[j]:sub(count) ~= \"\" do\n      count = count + 1\n      j = j - 1\n \
    \   end\n    if count > max.value then\n      max.value = count\n      max.index\
    \ = i\n    end\n  end\n  return words[max.index]\nend", "  local max_count = 0\n\
    \  local max_word = ''\n  for w in pairs(words) do\n    local c = #w\n    if c\
    \ > max_count then\n      max_count = c\n      max_word = w\n    end\n  end\n\
    \  return max_word\nend", "  if #words <= 1 then\n    return words[1]\n  end",
  "  local max = {}\n  local n = #words\n  for i = 1, n do\n    local maxkey = nil\n\
    \    for j = 1, #words do\n      local char = words[j]\n      if not maxkey or\
    \ (#maxkey and #char > #maxkey) then\n        -- Record the first occurrence of\
    \ char and its position in the string\n        maxkey = char\n        max[1] =\
    \ j\n      end\n    end\n    -- If the current word is the same as one with highest\
    \ number of unique\n    -- characters, replace it.\n    if #maxkey == #words[i]\
    \ then\n      for j = 1, #words do\n        if maxkey == words[j] then\n     \
    \     words[j] = maxkey\n          max[1] = j\n        end\n      end\n      break\n\
    \    end\n  end\n  return words[max[1]]\nend", "  local maxWord = words[1]\n \
    \ local maxCounts = count[maxWord]\n  for i = 2, #words do\n    local word = words[i]\n\
    \    local counts = count[word]\n    if counts > maxCounts then\n      maxCounts\
    \ = counts\n      maxWord = word\n    end\n  end\n  return maxWord\nend", "  local\
    \ chars = {}\n  for i = 1, #words[1] do\n    for j = 1, #words[1] do\n      if\
    \ i > j then\n        table.insert(chars, words[1][i])\n      end\n    end\n \
    \ end\n  table.sort(chars, function(a, b) return a:byte() > b:byte() end)\n  return\
    \ chars[#chars]\nend", "  local max_count = 1\n  local max_word = nil", "  local\
    \ i, max\n  for i, word in ipairs(words) do\n    max = #word\n    for j, letter\
    \ in ipairs(word) do\n      if max > #words[j] then\n        max = #words[j]\n\
    \      end\n    end\n    if max > #words[i] then\n      return word\n    end\n\
    \  end\n  return words[#words]\nend", "    local unique_characters = {}\n    for\
    \ _, word in ipairs(words) do\n        unique_characters[#unique_characters+1]\
    \ = word:gsub('%W','')\n    end\n    unique_characters[#unique_characters+1] =\
    \ '#'\n    table.sort(unique_characters)\n    local maximum = unique_characters[1]\n\
    \    for _, unique in ipairs(unique_characters) do\n        if unique > maximum\
    \ then\n            maximum = unique\n        end\n    end\n    return maximum\n\
    end", "  local chars = #words\n  for i = 1, #words do\n    chars = chars - #words[i]\n\
    \    if chars == 0 then\n      return words[i]\n    end\n  end\nend", "  -- The\
    \ dictionary is not sorted by word length for efficiency reasons.\n  local d =\
    \ {}\n  for i = 1, #words do\n    table.insert(d, words[i])\n  end\n  table.sort(d)",
  "  local max = 0\n  local index = 0\n  for i, v in ipairs(words) do\n    index =\
    \ index + v\n    if max < index then\n      max = index\n    end\n  end\n  return\
    \ words[max]\nend", "    local max_key = '', 0\n    for _, word in ipairs(words)\
    \ do\n        local count, char = word:gsub('(%w+)(%w+)', function(_, first, second)\n\
    \            if first > second then\n                return first, second\n  \
    \          else\n                return second, first\n            end\n     \
    \   end):gsub('(%w+)(%w+)', function(_, first, second)\n            return first\
    \ > second and first or second\n        end):gsub('(%w+)(%w+)', function(_, first,\
    \ second)\n            return first > second and first or second\n        end)\n\
    \        if count > max_key then\n            max_key = count, word\n        end\n\
    \    end\n    return max_key\nend", "    local counters = { }\n    for _, word\
    \ in ipairs(words) do\n        if not counters[word] then\n            counters[word]\
    \ = 1\n        else\n            counters[word] = counters[word] + 1\n       \
    \ end\n    end\n    local max = words[1]\n    for _, word in ipairs(words) do\n\
    \        if counters[word] > counters[max] then\n            max = word\n    \
    \    end\n    end\n    return max\nend", "  -- start with a dummy table\n  local\
    \ tbl = {}\n  for i = 1, #words do\n    for j = 1, #words[i] do\n      local new_tbl\
    \ = { words[i][j] }\n      -- add word to table\n      for k = 1, #tbl do\n  \
    \      if tbl[k].word == words[i][j] then\n          new_tbl.count = tbl[k].count\n\
    \          new_tbl.index = k\n        end\n      end\n      -- add word to table\
    \ if not yet in table\n      if #tbl == 0 then\n        tbl = {}\n        tbl:insert({\n\
    \          word = words[i][j],\n          count = 0,\n          index = 1,\n \
    \       })\n      end\n      -- increment count of this word in table\n      tbl[#tbl]:incr()\n\
    \      -- if the new count is highest so far, replace it with the new count\n\
    \      if tbl[#tbl].count == #tbl then\n        tbl[#tbl].count = tbl[#tbl].count\
    \ + 1\n      end\n    end\n  end\n  -- return the word with highest count\n  return\
    \ tbl[#tbl].word\nend", "\tlocal max = 0\n\tlocal result = nil\n\tfor _, w in\
    \ pairs(words) do\n\t\tlocal c = #w\n\t\tif max < c then\n\t\t\tmax = c\n\t\t\t\
    result = w\n\t\tend\n\tend\n\treturn result\nend", "  -- Write your code here\n\
    \  local n = #words\n  local freq = {}\n  for i = 1, n do\n    local word = words[i]\n\
    \    freq[word] = freq[word] + 1 or 1\n  end\n  for i = 1, n do\n    local word\
    \ = words[i]\n    freq[word] = freq[word] > 1 and freq[word] or 1\n  end\n  for\
    \ i = 1, n do\n    local word = words[i]\n    if freq[word] > 1 then\n      words[i]\
    \ = word\n      freq[word] = freq[word] - 1\n    end\n  end\n  local word\n  for\
    \ word, _ in pairs(freq) do\n    if freq[word] == 0 then\n      return word\n\
    \    end\n  end\nend", "  local max_count = {}\n  local max_word\n  for word in\
    \ words do\n    local count = max_count[word]\n    if count ~= nil then\n    \
    \  if count > max_count then\n        max_count = count\n        max_word = word\n\
    \      end\n    else\n      max_count = count + 1\n      max_word = word\n   \
    \ end\n  end\n  return max_word\nend", "    local max = 0\n    local word = nil\n\
    \    for _, v in pairs(words) do\n        local c = #v\n        if c > max then\n\
    \            max = c\n            word = v\n        end\n    end\n    if word\
    \ then\n        local i = #word\n        local j = #words\n        while i > 0\
    \ and j > 0 do\n            if word[i] > words[j] then\n                word =\
    \ words[i]\n                i = i - 1\n            else\n                word\
    \ = words[j]\n                j = j - 1\n            end\n        end\n    end\n\
    \    return word\nend", "   -- Your code here\n   return nil\nend", "  -- Write\
    \ your code here\n  local max = 0\n  local pos = 1\n  for _, word in pairs(words)\
    \ do\n    if #word > max then\n      max = #word\n      pos = 1\n    end\n   \
    \ pos = pos + 1\n  end\n  \n  if max > 0 then\n    return words[pos]\n  end\n\
    end", "  return assert(words[#words]),\nend", "  -- Create a dictionary with string\
    \ as key and count as value.\n  local word_count = {}\n  for _, word in ipairs(words)\
    \ do\n    table.insert(word_count, word, word_count[word] or 0)\n  end", "   \
    \ local num_chars = {}\n    local max_word = '?'\n    local words_with_num = {}\n\
    \    for k, v in pairs(words) do\n        words_with_num[v] = nil\n        num_chars[#num_chars\
    \ + 1] = 1\n    end\n    for i, word in ipairs(words) do\n        for _, v in\
    \ ipairs(num_chars) do\n            local new_word = word\n            if #new_word\
    \ < #word then\n                new_word = repeat(' ', #word) .. word\n      \
    \      end\n            local new_num_chars = #new_word\n            local new_words_with_num\
    \ = words_with_num\n            if words_with_num[v] == nil then\n           \
    \     words_with_num[v] = {}\n            end\n            for j = #word + 1,\
    \ #new_word do\n                if new_num_chars > num_chars[v + 1] then\n   \
    \                 new_num_chars = num_chars[v + 1]\n                    new_words_with_num[v\
    \ + 1] = {}\n                end\n                new_words_with_num[v + 1][#new_words_with_num[v\
    \ + 1] + 1] = new_word\n            end\n        end\n    end\n    for k, v in\
    \ pairs(words_with_num) do\n        if #v > max_words then\n            max_words\
    \ = (#v > max_words and #v) or 1\n            max_word = v[max_words]\n      \
    \  end\n    end\n    return max_word\nend", "    -- start from end, so we don't\
    \ have to reverse the table later\n    local max_len = nil\n    local max_word\
    \ = nil\n    local word_cnt = 0\n    for i = #words, 1, -1 do\n        word_cnt\
    \ = word_cnt + 1\n        if word_cnt > max_len then\n            max_len = word_cnt\n\
    \            max_word = words[i]\n        end\n    end\n    -- if string has same\
    \ count of characters, return the first one\n    if max_len == word_cnt then\n\
    \        return max_word\n    end\n    -- find the largest string with maximum\
    \ number of unique characters\n    local max_len2 = word_cnt\n    for i = 1, #words\
    \ do\n        -- find the largest string with maximum number of unique characters\n\
    \        local max_len3 = max_len2\n        for j = 1, #words do\n           \
    \ if words[i] != words[j] then\n                max_len3 = max_len3 + 1\n    \
    \        end\n        end\n        if max_len3 > max_len2 then\n            max_len\
    \ = max_len3\n            max_word = words[i]\n        end\n    end\n    return\
    \ max_word\nend", "  local unique_count = #words\n  local max_count = -1\n  local\
    \ max_word = nil\n  for i, word in ipairs(words) do\n    local count = #word\n\
    \    if count > max_count then\n      unique_count = count\n      max_count =\
    \ count\n      max_word = word\n    end\n  end\n  return max_word\nend", "   \
    \ local counter = {}\n    local new_words = {}\n    local max_key\n    local max_count\
    \ = 0", "    if #words == 0 then\n        return '<nil>'\n    end\n    local max\
    \ = nil\n    local maxcount = 1\n    local i = 1\n    while i <= #words and maxcount\
    \ == 1 do\n        if #words[i] ~= maxcount then\n            max = words[i]\n\
    \            maxcount = 1\n        else\n            maxcount = maxcount + 1\n\
    \        end\n        i = i + 1\n    end\n    return max\nend", "    local max\
    \ = {}\n    for k,v in pairs(words) do\n        local cnt = 1\n        for i =\
    \ 1,#v do\n            if v[i] ~= k[i] then\n                cnt = cnt + 1\n \
    \           end\n        end\n        local found = false\n        for i = 1,#max\
    \ do\n            if cnt > max[i] then\n                found = true\n       \
    \         max[i] = cnt\n            end\n        end\n        if found == false\
    \ then\n            table.insert(max, cnt)\n        end\n    end\n    local maxCount\
    \ = max[1]\n    for k = 2,#max do\n        if maxCount > max[k] then\n       \
    \     maxCount = max[k]\n        end\n    end\n    if maxCount == 1 then\n   \
    \     return words[#words]\n    else\n        return max[1]\n    end\nend", " \
    \ local max = 0\n  local i = 0\n  for _, word in pairs(words) do\n    i = i +\
    \ 1\n    max = max + (#word * (#word + 1))/2\n  end\n  return words[i]\nend",
  "    local max = 0\n    local word = nil\n    for _, w in ipairs(words) do\n   \
    \     -- TODO: Use hash table for better performance\n        local count = {}\n\
    \        for char in w:gmatch(\"[^\\n\\r]+\") do\n            count = count[char]\
    \ or 0\n            count[char] = count + 1\n        end", "    -- initialize\
    \ max to 0 for every element\n    local max = {}\n    for i = 1, #words do\n \
    \       -- initialize count to 0 at every element of this list\n        local\
    \ count = {}\n        for j = 1, #words[i] do\n            -- add 1 at every element\
    \ of this list\n            count[j] = count[j] + 1\n        end\n        -- this\
    \ element is new if its count is greater than the max\n        if count[#count]\
    \ > max[#max] then\n            -- if all elements of this list are equal, set\
    \ max to this element\n            if #count == max[#max] then\n             \
    \   max = words[i]\n            else\n                -- otherwise set max to\
    \ the one with the higher count\n                max = words[#count]\n       \
    \     end\n        end\n    end\n    return max\nend", "  local max_len = 0\n\
    \  local max_word\n  for _, word in ipairs(words) do\n    local len = 0\n    for\
    \ _, char in ipairs(word) do\n      len = len + string.byte(char)\n    end\n \
    \   if len > max_len then\n      max_len = len\n      max_word = word\n    end\n\
    \  end\n  return max_word\nend", "  -- initialize table for counting number of\
    \ unique characters\n  local characters = {}\n  for _, word in pairs(words) do\n\
    \    characters[#characters+1] = word\n  end\n  -- sort characters in increasing\
    \ order\n  table.sort(characters)\n  -- get maximum number of unique characters\n\
    \  local max_count = 0\n  local max_word  = words[1]\n  for _, word in pairs(words)\
    \ do\n    -- count the number of unique characters\n    local count = 0\n    for\
    \ _, character in pairs(word) do\n      count = count + characters[count]\n  \
    \  end\n    -- if count is bigger than current maximum, update it\n    if count\
    \ > max_count then\n      max_count = count\n      max_word  = word\n    end\n\
    \  end\n  return max_word\nend", "  local max = 0\n  local key = {}\n  for i =\
    \ 1, #words do\n    for j = 1, #words[i] do\n      local c = words[i][j]\n   \
    \   if not c\n        or #c < 1\n        or (#words[i][j] > max and #c > #key)\n\
    \        or (#words[i][j] == max and #c <= #key)\n      then\n        key = c\n\
    \      end\n    end\n  end\n  return key\nend", "    local max = 0 -- To store\
    \ count of max characters\n    local index = 1 -- To store index for first occurence\
    \ of max characters\n    for _, word in ipairs(words) do\n        local count\
    \ = 0 -- To count unique characters in word\n        for char in word:gmatch(\"\
    (.-)\") do -- For each char in word\n            count = count + 1 -- Increment\
    \ count of unique characters\n        end\n        if count > max then\n     \
    \       max = count -- If count > max, then update max\n            index = 1\
    \ -- Reset index to 1 because we found max number of characters\n        elseif\
    \ count == max then\n            index = index + 1 -- If count == max, increment\
    \ index\n        end\n    end\n    return words[index] -- If index > 1 then max\
    \ number of unique characters\nend", "  local max_chars = nil\n  local max_word\
    \ = nil\n  for _, word in pairs(words) do\n    if word:len() > 0 then\n      local\
    \ count = string.gsub(word, \"[^\" .. string.char(#string.char(\"a\")).. \"]\"\
    , \"\")\n      if count ~= nil and count > max_chars then\n        max_chars =\
    \ count\n        max_word = word\n      end\n    end\n  end\n  if max_chars ==\
    \ nil then\n    return nil\n  end\n  local max_index = nil\n  local max_word =\
    \ nil\n  for index, word in pairs(words) do\n    if word:len() == max_chars and\
    \ max_index == nil then\n      max_index = index\n      max_word = word\n    end\n\
    \  end\n  if max_index == nil then\n    return nil\n  end\n  return max_word\n\
    end", "  local keys = {}\n  local max = -1\n  for _, word in ipairs(words) do\n\
    \    for i = 1, #word do\n      local char = word[i]\n      if not char or not\
    \ keys[char] then\n        keys[char] = 1\n      elseif keys[char] > max then\n\
    \        max = keys[char]\n      end\n    end\n  end\n  if #keys > 0 then\n  \
    \  return table.unpack(keys)[1]\n  else\n    return nil\n  end\nend", "   local\
    \ max_count = 0\n   local max_word\n   for _, word in ipairs(words) do\n     \
    \ if #word > max_count then\n         max_count = #word\n         max_word = word\n\
    \      end\n   end\n   return max_word\nend", "  local counts = {}\n  local max\
    \ = {}\n  local i, j = 0, 0\n  for i, word in ipairs(words) do\n    local count\
    \ = counts[word]\n    if count then\n      count = count + 1\n    else\n     \
    \ counts[word] = 1\n    end\n    if count > max[word] then\n      max[word] =\
    \ count\n    end\n  end\n  local count = 1\n  for _, word in ipairs(max) do\n\
    \    counts[word] = counts[word] + 1\n    count = count + 1\n  end\n  local maxIndex\
    \ = -1\n  for i, word in ipairs(max) do\n    if counts[word] > maxIndex then\n\
    \      maxIndex = counts[word]\n      max[word] = word\n    end\n  end\n  return\
    \ max[maxIndex]\nend", "  local maxn = 0\n  local maxword = \"\"\n  for w in words\
    \ do\n    local n = #w\n    if n > maxn then\n      maxn = n\n      maxword =\
    \ w\n    end\n  end\n  return maxword\nend", "    local result = nil\n    for\
    \ _, word in ipairs(words) do\n        local count = 0\n        for _, char in\
    \ ipairs(word) do\n            count = count + 1\n        end\n        if count\
    \ > result then\n            result = word\n        end\n    end\n    return result\n\
    end", "  assert(type(words) == 'table')\n  local result = words[1][1]\n  local\
    \ count = 1\n  for i = 2, #words do\n    count = count+1\n    if words[i][1] ==\
    \ result then\n      count = count-1\n    elseif count > 1 then\n      result\
    \ = words[i][1]\n      count = count+1\n    end\n  end\n  return result\nend",
  "  local max = {}\n  for i=1, #words do\n    local key = ''\n    local count = 0\n\
    \    for j=1, #words[i] do\n      if key ~= words[i][j] then\n        count =\
    \ count + 1\n        key = words[i][j]\n      end\n    end\n    max[i] = count\
    \ or 1\n  end\n  local i = 1\n  for i=1, #words do\n    local key = ''\n    local\
    \ count = 0\n    for j=1, #words[i] do\n      if key ~= words[i][j] then\n   \
    \     count = count + 1\n        key = words[i][j]\n      end\n    end\n    if\
    \ count>max[i] then\n      max[i] = count\n      words[#words + i] = key\n   \
    \ end\n  end\n  return words[#words]\nend", "  if #words == 1 then\n    return\
    \ words[1]\n  end", "    local max_count = 0\n    local max_word = \"\"\n    for\
    \ word, count in pairs(words) do\n        if count > max_count then\n        \
    \    max_count = count\n            max_word = word\n        end\n    end\n  \
    \  return max_word\nend", "  local wordlist = words[#words]\n  local max = 0\n\
    \  local word\n  for word in wordlist do\n    if words[word] > max then\n    \
    \  max = words[word]\n    end\n  end\n  for word in wordlist do\n    if words[word]\
    \ == max then\n      return word\n    end\n  end\n  return nil\nend", "    local\
    \ max_count = 0\n    local word = {}\n    for _, v in pairs(words) do\n      \
    \  word[#word+1] = v\n    end\n    for _, v in pairs(words) do\n        max_count\
    \ = max_count + 1\n    end\n    for _, v in pairs(words) do\n        for _, v2\
    \ in pairs(words) do\n            if v > v2 then\n                word[#word+1]\
    \ = v\n                word[#word+1] = v\n            end\n        end\n    end\n\
    \    for _, v in pairs(word) do\n        if max_count == 1 then\n            return\
    \ v\n        end\n    end\n    return words[1]\nend", "  local maxCount = 0\n\
    \  local maxWord = \"\"", "    local max_key = ''\n    local max_count = 0\n \
    \   for i=1,#words do\n        local key = table.remove(words)\n        local\
    \ count = #key\n        if count > max_count then\n            max_key = key\n\
    \            max_count = count\n        end\n    end\n    return max_key\nend",
  "  local max = 0\n  for _, word in ipairs(words) do\n    local count = 0\n    for\
    \ char in word do\n      count = count + 1\n      if count > max then\n      \
    \  max = count\n      end\n    end\n  end\n  if max == 0 then\n    return nil\n\
    \  end\n  local result = {}\n  for _, word in ipairs(words) do\n    for i = 1,\
    \ #word do\n      local char = word[i]\n      if not result[char] then\n     \
    \   result[char] = word\n      end\n    end\n  end\n  for char, word in pairs(result)\
    \ do\n    if #word > max then\n      return word\n    end\n  end\n  return nil\n\
    end", "  local max_char = nil\n  local max_word = nil\n  local max_count = 0\n\
    \  for w in words do\n    local c = string.len(w)\n    if c > max_count then\n\
    \      max_count = c\n      max_char = w\n      max_word = w\n    end\n  end\n\
    \  return max_char, max_word\nend", "   local maximum = 0\n   local word\n   for\
    \ word in pairs(words) do\n      if maximum < #word then\n         maximum = #word\n\
    \         return word\n      elseif maximum == #word then\n         return word\n\
    \      end\n   end\nend", "  local max_count = 0\n  local max_str = ''\n  for\
    \ i = 1, #words do\n    local count = table.remove_by_ref(words, i)\n    if count\
    \ > max_count then\n      max_count = count\n      max_str = words[i]\n    end\n\
    \  end\n  return max_str\nend", "  local max = ''\n  for _, word in pairs(words)\
    \ do\n    max = max or word\n    max = max .. string.gsub(word, '[^' .. table.concat(string.gsub(table.concat(word),\
    \ '[^' .. max), '[^' .. max), '?') .. ']', '')\n  end\n  return max\nend", " \
    \ local max\n  local word\n  for word in words,\n    do\n    max = word:gsub('(.)%%(%a+)',\
    \ '%1'):match('(.-)(%a+)') or 0\n  done\n  return words[#words]\nend", "   local\
    \ max_count = 0\n   local max_string = nil\n   for i = 1, #words do\n      local\
    \ count = #words[i]\n      if count > max_count then\n         max_count = count\n\
    \         max_string = words[i]\n      end\n   end\n   return max_string\nend",
  "  return words[#words].key\nend", "    local maximum, current, count = 0, 0, 0\n\
    \    for word in pairs(words) do\n        count = count + 1\n        if word >\
    \ maximum then\n            maximum, current, count = word, word, count\n    \
    \    elseif count == #words then\n            if current ~= word then\n      \
    \          maximum, current = word, word\n            end\n        end\n    end\n\
    \    return maximum\nend", "  local max = 0 \n  for i = 1, #words do\n    local\
    \ count = {}\n    for j = 1, #words[i] do\n      table.insert(count, words[i][j])\n\
    \    end\n    if count > max then\n      max = count\n    end\n  end\n  return\
    \ words[#words][1]\nend", "  -- The key function returns length of unique characters.\n\
    \  -- This key is needed to find the max value.\n  local len = function() return\
    \ #_G[this] end\n  -- The map function adds the new character to a map if it doesn't\
    \ exist.\n  -- If the new character is different than the old one, it increments\
    \ its count.\n  -- If the old character is the same as the new one, it does nothing.\n\
    \  local map = function(self, char, count)\n    if count > 0 and _G[this][#_G[this]]\
    \ != char then\n      _G[this][#_G[this]] = char\n      count = count + 1\n  \
    \  end\n    return count\n  end\n  -- The reduce function reduces the map by choosing\
    \ the max value.\n  local reduce = function(self, acc, item)\n    if item > acc\
    \ then acc = item end\n    return acc\n  end\n  -- The find function looks for\
    \ the character with the max value\n  -- from the map and returns the corresponding\
    \ value.\n  -- The reverse function reverses the map.\n  -- The last function\
    \ is used to choose the element with the maximum value.\n  return reduce(reduce(reduce(reduce(map,\
    \ len()), len, len()), map, len()), #_G[this])\nend", "  local max_chars = -1\n\
    \  local max_words = nil\n  for i = 1, #words do\n    local chars = #words[i]\n\
    \    if chars > max_chars then\n      max_chars = chars\n      max_words = words[i]\n\
    \    end\n  end\n  return max_words\nend", "  local max_word = words[#words]\n\
    \  for i = #words - 1, 1, -1 do\n    local cur_word = words[i]\n    local cur_count\
    \ = #cur_word\n    for j = i + 1, #words do\n      local next_word = words[j]\n\
    \      local next_count = #next_word\n      local count = cur_count + next_count\n\
    \      if count > max_count then\n        max_count = count\n        max_word\
    \ = cur_word\n      end\n    end\n  end\n  return max_word\nend", "  local keys\
    \ = {}\n  for _, word in ipairs(words) do\n    keys[#keys + 1] = word:bytes():len()\
    \ -- TODO: fix memory leak\n  end\n  table.sort(keys)", "   assert(type(words)\
    \ == 'table')\n   local max = {}\n   for _, v in pairs(words) do\n      max[v]\
    \ = #v\n   end\n   for _, v in pairs(words) do\n      for i = #v + 1, 1, -1 do\n\
    \         if max[v] < max[v] then\n            table.remove(words, v)\n      \
    \      table.insert(words, v)\n         end\n      end\n   end\n   return table.concat(words,\
    \ ' ')\nend", "    local max = {}\n    local last_key = {}\n    for _, word in\
    \ ipairs(words) do\n        table.insert(max, #word + 1)\n        table.insert(last_key,\
    \ word)\n    end", "  -- Create an empty hash table to store the maximum word\n\
    \  local max_count = { }\n  -- Iterate through the table\n  for i, word in ipairs(words)\
    \ do\n    -- If the word already exists in the hash table\n    if max_count[word]\
    \ then\n      -- Increment its count by 1\n      max_count[word] = max_count[word]\
    \ + 1\n    else\n      -- Set the word to the max word found in the hash table\n\
    \      max_count[word] = 1\n      -- Keep track of the first found word\n    \
    \  max_word = word\n    end\n  end\n  return max_word\nend", "  local maxs = {}\n\
    \  for i = 1, #words do\n    local max = -1\n    for j = 1, #words[i] do\n   \
    \   if words[i][j] > max then\n        max = words[i][j]\n      end\n    end\n\
    \    if max > 0 then\n      if #maxs > 0 then\n        if maxs[#maxs] > max then\n\
    \          maxs[#maxs] = max\n        else\n          maxs[#maxs] = 1\n      \
    \  end\n      else\n        maxs[#maxs] = max\n      end\n    end\n  end", " \
    \ return words[#words]:gsub('(.)(.)','%2'):gsub('(.)%2','%1')\nend", "    local\
    \ max = {}\n    for _, w in ipairs(words) do\n        table.insert(max, #w)\n\
    \    end\n    table.sort(max, function(a, b)\n        return a < b\n    end)\n\
    \    return max[1]\nend", "    local result = {}\n    local max = -1", "  local\
    \ characters = {}\n  local wordCount = {}\n  local wordIndex = {}\n  for i, word\
    \ in pairs(words) do\n    wordCount[i] = #word\n    table.insert(wordIndex, word)\n\
    \    for _, letter in ipairs(word) do\n      table.insert(characters, letter)\n\
    \    end\n  end", "  local max = 0\n  for i, word in ipairs(words) do\n    if\
    \ word:len() > max then\n      max = word:len()\n    end\n  end\n  for i, word\
    \ in ipairs(words) do\n    if word:len() == max then\n      local char = word:sub(1,\
    \ max)\n      if i == #words and char ~= 'z' then\n        return word\n     \
    \ else\n        return char\n      end\n    end\n  end\nend", "    local max_len\
    \ = -1\n    local max_word = nil\n    for i, word in ipairs(words) do\n      \
    \  local len = #word\n        if max_len < len then\n            max_len = len\n\
    \            max_word = word\n        end\n    end\n    return max_word\nend",
  "  local max\n  local i = #words[1] - 1\n  for j = #words[1], 1, -1 do\n    if #words[1]\
    \ > max then\n      max = #words[1]\n      i = j\n    end\n  end\n  return words[1][i]\n\
    end\n</code>\n<|/ a dscore=0 tags=string,lua,algorithm |>\n<| c |>\nA good answer\
    \ will always have an explanation of what was done and why it was done in such\
    \ a manner, not only for the OP but for future visitors to SO.\n<|/ c |>\n<| a\
    \ tags=string,lua,algorithm |>\n<code>", "    local max_words = words[1]\n   \
    \ local max_word = words[2]\n    for i = #words[1], 1, -1 do\n        local word\
    \ = {}\n        for j = 1, #words[1] do\n            word[j] = words[1][j]\n \
    \       end\n        local unique_words = #unique(word)\n        if unique_words\
    \ > max_words or unique_words == 0 then\n            max_words = unique_words\n\
    \            max_word = word\n        end\n    end\n    return max_word\nend",
  "   local max_count = 0\n   local max_word  = words[1]\n   for w in pairs(words)\
    \ do\n      if #w > max_count then\n         max_count  = #w\n         max_word\
    \  = w\n      end\n   end\n   return max_word\nend", "  -- Build a hash table\
    \ where each key is a unique character and the value\n  -- is the number of times\
    \ the character appears.\n  local num_char = {}\n  for _, word in ipairs(words)\
    \ do\n    for _, c in ipairs(word) do\n      num_char[c] = num_char[c] or 0\n\
    \      num_char[c] = num_char[c] + 1\n    end\n  end\n  -- Get the word with maximum\
    \ number of unique characters.\n  local max_char, max_num = 0, 1\n  for _, c in\
    \ ipairs(num_char) do\n    if num_char[c] > max_num then\n      max_char, max_num\
    \ = c, num_char[c]\n    end\n  end\n  return max_char\nend", "  if #words == 0\
    \ then\n    return nil\n  end\n  local max_number = nil\n  local max_word = nil\n\
    \  for i = 1, #words do\n    local word = words[i]\n    local count = #word\n\
    \    if max_number == nil then\n      max_number = count\n      max_word = word\n\
    \      break\n    end\n    if count > max_number then\n      max_number = count\n\
    \      max_word = word\n    end\n  end\n  return max_word\nend", "  local max_len\
    \ = -1\n  local word\n  for word in words do\n    if max_len < word:len() then\n\
    \      max_len = word:len()\n    end\n  end\n  local index = 1\n  while true do\n\
    \    index = index + 1\n    local found = false\n    for word in words do\n  \
    \    if word:len() == index then\n        found = true\n        break\n      end\n\
    \    end\n    if not found then\n      return word\n    end\n  end\nend", "  local\
    \ max = words[1]\n  for i = 2, #words do\n    if not words[i] then\n      return\
    \ max\n    end\n    if #words[i] < #max then\n      max = words[i]\n    end\n\
    \  end\n  return max\nend\n</cell>\n<code language=julia-1.4>", "  -- Find the\
    \ maximum of the table of words with maximum number of unique characters.\n  local\
    \ maximum = {}\n  for i = 1, #words do\n    local count = 0\n    local word =\
    \ words[i]\n    for j = 1, #word do\n      count = count + 1\n      if maximum[word]\
    \ then\n        if maximum[word] < count then\n          maximum[word] = count\n\
    \        end\n      else\n        maximum[word] = count\n      end\n    end\n\
    \  end\n  -- Return the word with maximum number of unique characters.\n  return\
    \ maximum[table.maxn(maximum)]\nend", "  return assert(\n    words:reduce(function(word,\
    \ maxCount, i)\n      if maxCount > word:len() then\n        return word, maxCount\n\
    \      elseif maxCount == word:len() then\n        return word:sub(1, 1), maxCount\n\
    \      end\n      return word:sub(1, maxCount), maxCount\n    end)\n  )\nend",
  "  -- Your code here\n  local counts = {}\n  for _, word in pairs(words) do\n  \
    \  table.insert(counts, #counts, #word)\n  end\n  table.sort(counts, function(a,\
    \ b) return a > b end)\n  return words[counts[1]]\nend", "  local chars = {}\n\
    \  local max = 0\n  local maxChar = ''", "  local max = 0\n  local result\n  for\
    \ i = 1, #words do\n    local c = #words[i]\n    if max == 0 or c > max then\n\
    \      max = c\n      result = words[i]\n    end\n  end\n  return result\nend",
  "  local num_unique, num_words = {}, {}\n  for _, word in pairs(words) do\n    if\
    \ num_unique[word] then\n      num_words[word] = num_unique[word]\n    else\n\
    \      num_unique[word] = #words[word]\n    end\n  end\n  num_words[#num_words]\
    \ = 0\n  local max_word\n  for _, word in ipairs(num_words) do\n    if num_words[word]\
    \ > num_words[max_word] then\n      max_word = word\n    end\n  end\n  return\
    \ max_word\nend", "    local max_chars = -1\n    local max_word = ''\n    local\
    \ max_char_index = 0\n    for i=1, #words do\n        local char, count = unpack(words[i])\n\
    \        if count > max_chars then\n            max_chars = count\n          \
    \  max_word = words[i]\n            max_char_index = i\n        end\n    end\n\
    \    return max_word\nend\n</cell>\n<cell>\n%%time", "  local max = 0\n  local\
    \ word = ''\n  local i = 1\n  for word in words do\n    if i > max then\n    \
    \  max = i\n    end\n    i = i + 1\n  end\n  if max > 0 then\n    for word in\
    \ words do\n      if tostring(word) == tostring(word:sub(1, max)) then\n     \
    \   return word\n      end\n    end\n  end\nend", "  local max = 0\n  local word\
    \ = \"\"\n  for i = 1, #words do\n    local count = 0\n    for j = 1, #words[i]\
    \ do\n      count = count + 1\n      if count > max then\n        max = count\n\
    \        word = words[i]\n      end\n    end\n  end\n  return word\nend", "\t\
    -- write your code in Lua 5.2\n\t\n\t-- write your code here\n\tlocal wordSet\
    \ = #words[1]\n\tlocal maxIndex = -1\n\tfor i=1,#words do\n\t\tlocal count = 1\n\
    \t\tfor j=1,wordSet-1 do\n\t\t\tif words[i][j] == words[i+1][j] then\n\t\t\t\t\
    count = count + 1\n\t\t\tend\n\t\tend\n\t\tif count > maxIndex then\n\t\t\tmaxIndex\
    \ = count\n\t\tend\n\tend\n\treturn words[maxIndex + 1]\nend", "  local word =\
    \ {}\n  local num_unique = 0\n  for _, word in ipairs(words) do\n    word[#word+1]\
    \ = word\n    num_unique = num_unique + #word\n  end\n  local max_char = max_num_unique(num_unique)\n\
    \  for _, word in ipairs(words) do\n    num_unique = num_unique - #word\n    if\
    \ num_unique < max_char then\n      table.insert(words[#words], word)\n    end\n\
    \  end\n  table.sort(words, function(a, b) return #a == #b end)\n  local max =\
    \ words[#words]\n  return max and max[1] or false\nend", "  local uniques = {}\n\
    \  local max_count = 1\n  for _, word in ipairs(words) do\n    local count = #word\n\
    \    if uniques[word] == nil then\n      uniques[word] = count\n    else\n   \
    \   uniques[word] = count + 1\n      if uniques[word] > max_count then\n     \
    \   max_count = uniques[word]\n      end\n    end\n  end\n  return table.top(uniques)\n\
    end", "  if #words == 0 then\n    return nil\n  end\n  local char_count = tables.new(0)\n\
    \  local words = tables.new()\n  for i = 1, #words do\n    local char = words[i]\n\
    \    if char_count < #char then\n      char_count = #char\n      words[i] = words[#words]\n\
    \    end\n  end\n  return words[#words]\nend", "  assert(words and #words > 0)\n\
    \  local max_len = -1\n  local max_word\n  for _, word in pairs(words) do\n  \
    \  assert(type(word) == 'string')\n    local len = #word\n    if max_len == -1\
    \ or max_len < len then\n      max_len = len\n      max_word = word\n    end\n\
    \  end\n  if max_len == 0 then\n    return nil\n  end\n  table.sort(words, function(a,\
    \ b) return #a == #b && a:bytes() < b:bytes() end)\n  return max_word\nend", " \
    \ local maxCount = 0\n  local maxWord = nil\n  for word, count in pairs(words)\
    \ do\n    if count > maxCount then\n      maxCount = count\n      maxWord = word\n\
    \    end\n  end\n  return maxWord\nend\n</cell>\n<cell>", "  -- Write your solution\
    \ here.\n  local hash = {}\n  local max_len = 1\n  for _, str in pairs(words)\
    \ do\n    for i=1,#str do\n      hash[str:sub(i,i)] = hash[str:sub(i,i)] + 1 \n\
    \      if hash[str:sub(i,i)] > max_len then\n        max_len = hash[str:sub(i,i)]\n\
    \        words_with_max_unique = str\n      end\n    end\n  end\n  return words_with_max_unique\n\
    end", "  local max = 0 \n  local word = {}\n  for _, v in ipairs(words) do\n \
    \   table.insert(word, v)\n    max = max + 1\n  end\n  table.sort(word)\n  if\
    \ #word > max then\n    return word[#word]\n  else\n    return word[1]\n  end\n\
    end", "  -- Write your code here\n  local count = {}\n  for k,v in pairs(words)\
    \ do\n    count[v] = count[v] or 0\n    count[v] = count[v]+1\n  end\n  local\
    \ max = 0,word\n  for k,v in pairs(count) do\n    if v > max then\n      max =\
    \ v\n      word = k\n    end\n  end\n  return word\nend", "  local maxes = {}\n\
    \  for i, word in ipairs(words) do\n    local count = {}\n    for _, c in ipairs(word)\
    \ do\n      count = count or {}\n      count[c] = count[c] or 1\n    end\n   \
    \ maxes[i] = count\n  end\n  for i, word in ipairs(words) do\n    local count\
    \ = {}\n    for _, c in ipairs(word) do\n      count = count or {}\n      count[c]\
    \ = count[c] or 1\n    end\n    local max = 0\n    for k, v in pairs(count) do\n\
    \      if v > max then\n        max = v\n      end\n    end\n    maxes[i] = max\n\
    \  end\n  for i, word in ipairs(words) do\n    local max = 0\n    for k, v in\
    \ pairs(word) do\n      if v > max then\n        max = v\n      end\n    end\n\
    \    maxes[i] = max\n  end\n  for i, word in ipairs(words) do\n    local max =\
    \ words[#words]\n    if #maxes <= i then\n      return word\n    end\n    for\
    \ k, v in pairs(word) do\n      if maxes[k] > max then\n        max = maxes[k]\n\
    \      end\n    end\n    return word\n  end\nend", "  local max = 0\n  for word\
    \ in words do\n    max = max or #word\n    for i=1,#word do max = max > #word\
    \ and i or max end end\n  end\n  return words[max] or words[1]\nend", "  -- Write\
    \ your code here\n  return nil\nend", "  local max_len, max_word = 0, nil\n  for\
    \ i, word in ipairs(words) do\n    local count, max_char = 1, nil\n    for char\
    \ in word:gmatch'(.)'do\n      if count==0 then\n        count = 1:byte(char)\n\
    \      else\n        count = count*256+1:byte(char)\n      end\n    end\n    if\
    \ count>max_len then\n      max_word = word\n      max_len = count\n    end\n\
    \  end\n  return max_word\nend", "    -- Write your solution below:\n    local\
    \ table = {}\n    for i = 1, #words do\n        table.insert(table.unpack(words[i]:gsub('%w+',\
    \ string.format('%s', table.unpack(words[i])):gsub('%w+', '%%s'))))\n    end\n\
    \    table.sort(table.unpack(words))\n    return table.unpack(words[1])\nend",
  "  assert(words and #words == 2, 'Invalid argument: ' .. tostring(words))\n  local\
    \ word = words[1]\n  local count = #word[1]\n  for i = 2, #words do\n    local\
    \ _word = words[i]\n    local count = count + 1\n    for j = 1, #_word do\n  \
    \    if _word[j] ~= word[1][j] then\n        word[1][j] = _word[j]\n        count\
    \ = count + 1\n      end\n    end\n  end\n  return word[1]\nend", "  -- Write\
    \ your solution here\n  local max = 0\n  for i = 1, #words do\n    for j = 1,\
    \ #words[i] do\n      if words[i][j] > max then\n        max = words[i][j]\n \
    \     end\n    end\n  end\n  \n  return words[#words]\nend", "   local max = {}\n\
    \   for _, w in pairs(words) do\n      local count = 0\n      for c in w:gmatch(\"\
    [%z]\") do\n         count = count + 1\n      end\n      if count > max[#max]\
    \ then\n         max[#max] = count\n      end\n   end\n   return max[1]\nend",
  "  -- write your code here\n  return nil\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
