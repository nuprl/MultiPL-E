name: HumanEval_8_sum_product
language: lua
prompt: "-- For a given table of integers, return a table consisting of a sum and\
  \ a product of all the integers in a table.\n-- Empty sum should be equal to 0 and\
  \ empty product should be equal to 1.\n-- >>> sum_product({})\n-- {0, 1}\n-- >>>\
  \ sum_product({1, 2, 3, 4})\n-- {10, 24}\nlocal function sum_product(numbers)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sum_product\n\
  \    lu.assertEquals(candidate({}), {0, 1})\n    lu.assertEquals(candidate({1, 1,\
  \ 1}), {3, 1})\n    lu.assertEquals(candidate({100, 0}), {100, 0})\n    lu.assertEquals(candidate({3,\
  \ 5, 7}), {15, 105})\n    lu.assertEquals(candidate({10}), {10, 10})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local results = {}\n    for _, number in ipairs(numbers) do\n \
    \       table.insert(results, number + number + 1)\n    end\n    local sum = table.sum(results)\n\
    \    local product = 1\n    for _, number in ipairs(numbers) do\n        product\
    \ = product * number\n    end\n    return {sum, product}\nend", "   local sum,\
    \ product = 0, 1\n   for i = 1, #numbers do\n      sum = sum + numbers[i]\n  \
    \    product = product * numbers[i]\n   end\n   return sum, product\nend", " \
    \ if next(numbers) == nil then\n    return {0, 1}\n  end\n  local sum = {}\n \
    \ local product = {}\n  for k, v in pairs(numbers) do\n    table.insert(sum, v)\n\
    \    table.insert(product, v * v)\n  end\n  table.sort(sum)\n  table.sort(product)\n\
    \  local result = {0, 1}\n  local last_value = sum[1]\n  for _, v in pairs(sum)\
    \ do\n    if v ~= last_value then\n      table.insert(result, v)\n      last_value\
    \ = v\n    end\n  end\n  table.sort(result)\n  table.sort(product)\n  for _, v\
    \ in pairs(product) do\n    table.insert(result, v + result[#result])\n  end\n\
    \  return result\nend", "  local sum, product = 1\n  local _numbers = numbers\
    \ or {}\n  for i = 1, #_numbers do\n    sum = sum + _numbers[i]\n    product =\
    \ product * _numbers[i]\n  end\n  return sum, product\nend", "  if #numbers ==\
    \ 0 then\n    return {0, 1}\n  end\n  local sum, product = table.unpack({})\n\
    \  for i = 1, #numbers do\n    sum = sum + numbers[i]\n    product = product *\
    \ numbers[i]\n  end\n  table.insert(sum, 0)\n  table.insert(product, 1)\n  return\
    \ sum, product\nend", "    local sum = 0\n    local product = 1", "  local sum\
    \ = 0\n  local product = 1\n  for _, num in pairs(numbers) do\n    sum = sum +\
    \ num\n    product = product * num\n  end\n  return { sum, product }\nend", " \
    \ local sum, prod = {}, {}\n  for i, v in pairs(numbers) do\n    if v then\n \
    \     sum[i] = sum[i] or 0\n      prod[i] = prod[i] or 1\n      sum[i] = sum[i]\
    \ + v\n      prod[i] = prod[i] * v\n    end\n  end\n  return sum, prod\nend",
  "  local sum_ = 0\n  local product_ = 1\n  for _, number in pairs(numbers) do\n\
    \    sum_ = sum_ + number\n    product_ = product_ * number\n  end\n  return sum_,\
    \ product_\nend", "    local sum, product = numbers.sum, numbers.product\n   \
    \ if numbers.sum ~= nil and numbers.product ~= nil then\n        return sum +\
    \ product, sum * product\n    elseif numbers.sum ~= nil and numbers.product ~=\
    \ nil then\n        return nil, numbers.sum * numbers.product\n    elseif numbers.sum\
    \ ~= nil then\n        return numbers.sum, numbers.product\n    else\n       \
    \ return nil, nil\n    end\nend", "    local sum = {}\n    local product = {}\n\
    \    for _, value in pairs(numbers) do\n        table.insert(sum, value)\n   \
    \     table.insert(product, value * value)\n    end\n    return sum, product\n\
    end", "  local sum, product\n  table.insert(sum, 0)\n  table.insert(product, 1)\n\
    \  for _, v in pairs(numbers) do\n    sum = sum + v\n    product = product * v\n\
    \  end\n  return sum, product\nend", "  if not numbers or #numbers == 0 then\n\
    \    return {0, 1}\n  end", "    local sum = {}\n    local product = 1\n    for\
    \ i = 1, #numbers do\n        sum[i] = sum[i] or numbers[i]\n        product =\
    \ product * numbers[i]\n    end\n    sum[1] = sum[1] or 1\n    product = product\
    \ or 1\n    return sum, product\nend", "  local sum = {}\n  local product = 1\n\
    \  for _, value in pairs(numbers) do\n    sum[value] = sum[value] + 1 -- The sum\
    \ is an integer table, so we can use the `+` operator to add one to the value.\n\
    \    product = product * value\n  end\n  return {sum, product}\nend", "    if\
    \ not numbers then return {0, 1} end\n    local sum = {}\n    local product =\
    \ {}\n    for _, v in pairs(numbers) do\n        table.insert(sum, v)\n      \
    \  table.insert(product, v * v)\n    end\n    return {table.sum(sum), table.product(product)}\n\
    end", "  if not numbers then\n    return { 0, 1 }\n  end\n  local sum = 0\n  local\
    \ product = 1\n  for _, value in pairs(numbers) do\n    sum = sum + value\n  \
    \  product = product * value\n  end\n  return { sum, product }\nend", "    local\
    \ results = {}\n    for i = 1, #numbers do\n        local num = numbers[i]\n \
    \       if num ~= nil then\n            results[i] = num + results[i - 1]\n  \
    \      end\n    end\n    return results\nend", "  if #numbers == 0 then\n    return\
    \ {0, 1}\n  end\n  local result = {}\n  for i = 1, #numbers do\n    table.insert(result,\
    \ numbers[i] + numbers[i - 1] * numbers[i - 1])\n  end\n  return result\nend",
  "  if type(numbers) ~= 'table' then return {0, 1}; end", "    local sum = 0\n  \
    \  local product = 1\n    for _, v in pairs(numbers) do\n        sum = sum + v\n\
    \        product = product * v\n    end\n    return {sum, product}\nend", "  local\
    \ total = 0\n  local product = 1\n  for _, value in pairs(numbers) do\n    total\
    \ = total + value\n    product = product * value\n  end\n  local result = {}\n\
    \  if total > 0 then\n    table.insert(result, total)\n  end\n  if product > 0\
    \ then\n    table.insert(result, product)\n  end\n  return result\nend", "  local\
    \ sum = 0\n  local product = 1\n  for _, v in pairs(numbers) do\n    sum = sum\
    \ + v\n    product = product * v\n  end\n  return {sum, product}\nend", "  local\
    \ sums = {}\n  for _, v in pairs(numbers) do\n    table.insert(sums, v)\n  end",
  "    local sum = 1\n    local product = 1\n    for _, value in pairs(numbers) do\n\
    \        sum = sum + value\n        product = product * value\n    end\n    return\
    \ {sum, product}\nend", "  local sum = 0\n  local product = 1\n  for _, v in pairs(numbers)\
    \ do\n    sum = sum + v\n    product = product * v\n  end\n  return {sum, product}\n\
    end", "   local sum = 0\n   local product = 1\n   for _, value in pairs(numbers)\
    \ do\n      sum = sum + value\n      product = product * value\n   end\n   return\
    \ sum, product\nend", "  if #numbers == 0 then\n    return {0, 1}\n  end\n  local\
    \ sum = 0\n  local product = 1\n  for _, v in ipairs(numbers) do\n    sum = sum\
    \ + v\n    product = product * v\n  end\n  return { sum = sum, product = product\
    \ }\nend", "    if next(numbers) ~= nil then\n        local sum, product = numbers[1],\
    \ 1\n        for _, value in pairs(numbers) do\n            sum = sum + value\n\
    \            product = product * value\n        end\n        return {sum, product}\n\
    \    else\n        return {0, 1}\n    end\nend", "  if numbers == nil then\n \
    \   return {0, 1}\n  else\n    local sum = {}\n    local product = {}\n    for\
    \ k,v in pairs(numbers) do\n      sum[k] = sum[k] or 0\n      product[k] = product[k]\
    \ or 1\n      sum[k] = sum[k] + v\n      product[k] = product[k] * v\n    end\n\
    \    return {sum, product}\n  end\nend", "    local product = 1\n    local sum\
    \ = 0\n    for _, value in pairs(numbers) do\n        sum = sum + value\n    \
    \    product = product * value\n    end\n    return sum, product\nend", "\tlocal\
    \ s = numbers[1]\n\tlocal prod = 1\n\tlocal sum_ = 1", "  local result = {}\n\
    \  local product = 1\n  for _, v in ipairs(numbers) do\n    product = product\
    \ * v\n    result[v] = result[v] or product\n  end\n  if #result == 1 then\n \
    \   return table.remove(result)\n  else\n    return result\n  end\nend", "  local\
    \ sum = 0\n  local product = 1\n  for _, num in ipairs(numbers) do\n    sum =\
    \ sum + num\n    product = product * num\n  end\n  local result = {}\n  result[1]\
    \ = sum\n  result[2] = product\n  return result\nend", "    local result = {}\n\
    \    for _, v in pairs(numbers) do\n        result[#result + 1] = v\n    end\n\
    \    if next(result) == 0 then\n        return result\n    end\n    result[1]\
    \ = 1\n    return result\nend", "\tlocal sum, product = 1, 1\n\tfor _, value in\
    \ pairs(numbers) do\n\t\tsum = sum + value\n\t\tproduct = product * value\n\t\
    end\n\treturn sum, product\nend", "    local sum = {}\n    local product = 1\n\
    \    for _, n in pairs(numbers) do\n        sum[#sum + 1] = n\n        product\
    \ = product * n\n    end\n    return sum, product\nend", "    if #numbers == 0\
    \ then\n        return {0, 1}\n    end", "    local totals = {}\n    local product\
    \ = 1\n    for _, value in pairs(numbers) do\n        total = total + value\n\
    \        product = product * value\n        table.insert(totals, total)\n    end\n\
    \    table.insert(totals, product)\n    return totals\nend", "  if #numbers ==\
    \ 0 then\n    return {}\n  end", "    local sum = 0\n    local product = 1\n \
    \   for _, value in pairs(numbers) do\n        sum = sum + value\n        product\
    \ = product * value\n    end\n    return sum, product\nend\n</cell>\n<text>\n\
    Practice Part 2\nThe function below takes a list of numbers and returns a table\
    \ of products for each number. Your function should return a table with the number\
    \ of entries equal to the length of the list passed in. The table should be indexed\
    \ by number then by product. For instance, if the list passed in is {1, 2, 3,\
    \ 4}, then your function should return a table with entries {1, 4, 9, 16}.", " \
    \ local sum = 0\n  local product = 1\n  for k, v in pairs(numbers) do\n    sum\
    \ = sum + v\n    product = product * v\n  end\n  sum, product = sum or 0, product\
    \ or 1\n  return {sum = sum, product = product}\nend", "   local sum = 1\n   local\
    \ product = 1\n   for _, i in ipairs(numbers) do\n      sum = sum + i\n      product\
    \ = product * i\n   end\n   return {sum, product}\nend", "  if #numbers == 0 then\
    \ return {0, 1} end\n  local result = {}\n  local product = 1\n  for i = 1, #numbers\
    \ do\n    table.insert(result, sum + product)\n    product = product * numbers[i]\n\
    \  end\n  return result\nend", "  local sum = 0\n  local product = 1\n  local\
    \ i = 1\n  while i <= #numbers do\n    local nn = numbers[i]\n    if nn ~= nil\
    \ then\n      sum = sum + nn\n      product = product * nn\n    end\n    i = i\
    \ + 1\n  end\n  return sum, product\nend", "    local sum = 1\n    local product\
    \ = 1\n    for _, v in pairs(numbers) do\n        sum, product = sum + v, product\
    \ * v\n    end\n    return sum, product\nend\n</cell>\n<text>\nExercise 9\nThe\
    \ following function takes a list of names and returns their first names. You\
    \ can then use the list as the argument for a function that returns the first\
    \ name of a name.", "    if type(numbers) == nil then\n        return {0, 1}\n\
    \    end\n    local sum = 1\n    local product = 1\n    for _, v in pairs(numbers)\
    \ do\n        sum = sum + v\n        product = product * v\n    end\n    return\
    \ {sum, product}\nend", "  local product = 1\n  local sum = 0\n  for i, v in ipairs(numbers)\
    \ do\n    sum = sum + v\n    product = product * v\n  end\n  return sum, product\n\
    end", "  if next(numbers) == nil then\n    return {0, 1}\n  end\n  local sum =\
    \ 1\n  local product = 1\n  for i = 1, #numbers do\n    sum = sum + numbers[i]\n\
    \    product = product * numbers[i]\n  end\n  assert( sum == 0 and product ==\
    \ 1 )\n  return { sum, product }\nend", "  if next(numbers) ~= nil then\n    return\
    \ sum_product(next(numbers)) + numbers[1] * numbers[#numbers]\n  end\n  return\
    \ {}\nend", "   local sum, product = {}, {}\n   for _, num in ipairs(numbers)\
    \ do\n      table.insert(sum, num)\n      table.insert(product, num)\n   end\n\
    \   table.sort(sum)\n   table.sort(product)\n   return sum, product\nend", "\t\
    if type(tonumber(numbers)) ~= 'table' then\n\t\treturn numbers\n\tend", "    if\
    \ next(numbers) ~= nil then\n        local sum, product = numbers.value, 1\n \
    \       for i = 2, #numbers do\n            sum = sum + numbers.i\n          \
    \  product = product * numbers.i\n        end\n        return {sum, product}\n\
    \    end\n    return {0, 1}\nend", "   if type(numbers) ~= 'table' then return\
    \ numbers, numbers end\n   local sum = {}\n   local product = 1\n   for key, value\
    \ in pairs(numbers) do\n      local sum = sum + value\n      product = product\
    \ * value\n   end\n   return sum, product\nend", "  local sum, product = 1\n \
    \ for _, value in pairs(numbers) do\n    sum = sum + value\n    product = product\
    \ * value\n  end\n  if sum == 0 then\n    sum = 1\n  end\n  if product == 1 then\n\
    \    product = 1\n  end\n  return {sum, product}\nend", "    local sum, product\
    \ = 0, 1\n    for _, num in ipairs(numbers) do\n        sum = sum + num\n    \
    \    product = product * num\n    end\n    return sum, product\nend", "  if numbers\
    \ == nil then\n    return nil\n  end", "    local sum = 0\n    local product =\
    \ 1\n    for _, value in pairs(numbers) do\n        sum = sum + value\n      \
    \  product = product * value\n    end\n    return {sum, product}\nend", "  local\
    \ sum = 0\n  local product = 1\n  for k, v in pairs(numbers) do\n    sum = sum\
    \ + v\n    product = product * v\n  end\n  return {sum, product}\nend", "    local\
    \ sum = 0\n    local product = 1", "  local sum = 0\n  local product = 1\n  for\
    \ _, v in pairs(numbers) do\n    sum = sum + v\n    product = product * v\n  end\n\
    \  return {sum, product}\nend", "    local sum = 0\n    local product = 1\n  \
    \  for _, number in pairs(numbers) do\n        sum = sum + number\n        product\
    \ = product * number\n    end\n    return {sum, product}\nend", "    if not numbers\
    \ then\n        return {0, 1}\n    end\n    local sum = 0\n    local product =\
    \ 1\n    for _, v in ipairs(numbers) do\n        sum = sum + v\n        product\
    \ = product * v\n    end\n    return {sum, product}\nend", "    if next(numbers)\
    \ ~= nil then\n        local sum, product = numbers[1][1], numbers[1][1]\n   \
    \     for _, v in pairs(numbers) do\n            sum = sum + v\n            product\
    \ = product * v\n        end\n        return sum, product\n    end\n    return\
    \ 0, 1\nend", "  local sum_ = 0\n  local product_ = 1\n  for i = 1, #numbers do\n\
    \    local n = numbers[i]\n    sum_ = sum_ + n\n    product_ = product_ * n\n\
    \  end\n  table.insert(numbers, sum_)\n  table.insert(numbers, product_)\n  local\
    \ function helper(numbers)\n    local sum, product = sum_product(numbers)\n  \
    \  if #numbers == 1 then\n      return sum, product\n    else\n      local last_sum\
    \ = sum\n      local last_product = product\n      local last_number = numbers[#numbers]\n\
    \      local last_sum_, last_product_ = helper(numbers)\n      local ratio = (last_sum_\
    \ - last_sum) / (last_product_ - last_product)\n      for i = 1, #numbers do\n\
    \        numbers[i] = (numbers[i] + last_sum) / ratio\n      end\n      return\
    \ ratio, ratio * last_number\n    end\n  end\n  return helper(numbers)\nend",
  "    if not numbers then return {0, 1} end\n    local sum = 0\n    local product\
    \ = 1\n    for _, v in pairs(numbers) do\n        sum = sum + v\n        product\
    \ = product * v\n    end\n    return {sum, product}\nend\n</cell>\n<cell>", " \
    \  local sum = 0\n   local product = 1\n   for _, value in pairs(numbers) do\n\
    \      sum = sum + value\n      product = product * value\n   end\n   return sum,\
    \ product\nend", "    local sum = 1\n    local product = 1\n    for _, v in pairs(numbers)\
    \ do\n        sum = sum + v\n        product = product * v\n    end\n    return\
    \ sum, product\nend", "  return setmetatable(numbers, {\n    __add = function(self,\
    \ other)\n      local result = {}\n      for i, v in ipairs(numbers) do\n    \
    \    result[i] = v + other[i]\n      end\n      return result\n    end,\n    __mul\
    \ = function(self, other)\n      local result = {}\n      for i, v in ipairs(numbers)\
    \ do\n        result[i] = v * other\n      end\n      return result\n    end\n\
    \  })\nend", "  if numbers == nil then\n    return {{}, 1}\n  elseif type(numbers)\
    \ == 'table' then\n    local sum = {}\n    local product = 1\n    for k in pairs(numbers)\
    \ do\n      sum[k] = sum[k] + numbers[k]\n      product = product * numbers[k]\n\
    \    end\n    return sum, product\n  else\n    return nil, 1\n  end\nend", " \
    \ if #numbers == 0 then\n    return {0, 1}\n  end\n  local sum = 1\n  local product\
    \ = 1\n  for i = 1, #numbers do\n    sum = sum + numbers[i]\n    product = product\
    \ * numbers[i]\n  end\n  return { sum, product }\nend", "\tif numbers then\n\t\
    \tlocal sum, prod = {}, 1\n\t\tfor i = 1, #numbers do\n\t\t\ttable.insert(sum,\
    \ numbers[i])\n\t\t\tprod = prod * numbers[i]\n\t\tend\n\t\treturn {sum, prod}\n\
    \telse\n\t\treturn {{}, 1}\n\tend\nend", "  local sum, product = 0, 1\n  for _,\
    \ value in pairs(numbers) do\n    sum = sum + value\n    product = product * value\n\
    \  end\n  return { sum = sum, product = product }\nend", "  if numbers == nil\
    \ then\n    return {}\n  end", "  local sum, product = numbers.sum, numbers.product\n\
    \  if not sum then\n    sum = 0\n  end\n  if not product then\n    product = 1\n\
    \  end\n  for key, value in pairs(numbers) do\n    sum = sum + value\n    product\
    \ = product * value\n  end\n  return sum, product\nend", "\tlocal sum = {}\n\t\
    local product = {}\n\tfor _, n in pairs(numbers) do\n\t\ttable.insert(sum, sum[n]\
    \ + n)\n\t\ttable.insert(product, product[n] * n)\n\tend\n\treturn { sum = sum,\
    \ product = product }\nend", "   local result = {}\n   for _, v in pairs(numbers)\
    \ do\n      result[v] = result[v] + v\n   end\n   for _, v in pairs(result) do\n\
    \      result[v] = result[v] * v\n   end\n   return result\nend", "  if numbers\
    \ == nil then\n    return {}, {}\n  end\n  local product = {}\n  local sum = {}\n\
    \  local i = 0\n  for _ in pairs(numbers) do\n    local elem = numbers[i]\n  \
    \  if next(sum) == nil then\n      sum[elem] = elem\n      product[elem] = elem\n\
    \    else\n      local last = next(sum)\n      sum[last] = (sum[last] * last)\
    \ + elem\n      product[elem] = (product[elem] * elem) - last\n    end\n    i\
    \ = i + 1\n  end\n  table.sort(sum)\n  table.sort(product)\n  return sum, product\n\
    end", "  local sum = 0\n  local product = 1\n  for _, value in pairs(numbers)\
    \ do\n    sum = sum + value\n    product = product * value\n  end\n  return {\
    \ sum = sum, product = product }\nend", "   local result = {}\n   local number_table\
    \ = numbers or {}\n   if next(number_table) == nil then\n      result[#result]\
    \ = 1\n      return result\n   end\n   result[#result + 1] = 1\n   local running_total\
    \ = next(number_table)\n   for i = 2, #number_table do\n      running_total =\
    \ running_total * next(number_table)\n      result[#result + 1] = running_total\n\
    \   end\n   return result\nend", "  local sum\n  if next(numbers) == nil then\n\
    \    sum = {0, 1}\n  else\n    local product = 1\n    for _, value in ipairs(numbers)\
    \ do\n      sum = sum + value\n      product = product * value\n    end\n  end\n\
    \  return sum, product\nend", "    local sums = {}\n    local products = {}\n\
    \    for _, number in pairs(numbers) do\n        if number == 0 then\n       \
    \     table.insert(sums, 0)\n            table.insert(products, 1)\n        else\n\
    \            local index = #sums\n            table.insert(sums, sums[index] +\
    \ number)\n            table.insert(products, products[index] * (number - 1))\n\
    \        end\n    end\n    return table.unpack(table.concat(sums, '+')),  table.unpack(table.concat(products,\
    \ '*')) \nend", "  local sum = 0\n  local product = 1\n  for _, v in pairs(numbers)\
    \ do\n    sum = sum + v\n    product = product * v\n  end\n  return sum, product\n\
    end", "  if numbers then\n    local sum = 0\n    local product = 1\n    for _,\
    \ v in pairs(numbers) do\n      sum = sum + v\n      product = product * v\n \
    \   end\n    return sum, product\n  end\n  return 0, 0\nend", "  local results\
    \ = {}\n  for i = 1, #numbers do\n    results[#results + 1] = 0\n    results[#results\
    \ + 1] = results[#results + 1] + numbers[i]\n  end\n  results[#results + 1] =\
    \ 1\n  return table.concat(results)\nend", "  if numbers == nil then\n    return\
    \ nil\n  end\n  local product = 1\n  local sum = 0\n  for _, n in pairs(numbers)\
    \ do\n    sum = sum + n\n    product = product * n\n  end\n  return sum, product\n\
    end", "  local sum = 0\n  local product = 1\n  for _, value in pairs(numbers)\
    \ do\n    sum = sum + value\n    product = product * value\n  end\n  return sum,\
    \ product\nend", "  if #numbers == 0 then\n    return {0, 1}\n  end\n  local sum_\
    \ = numbers[1]\n  local prod = numbers[1]\n  for i = 2, #numbers do\n    sum_\
    \ = sum_ + numbers[i]\n    prod = prod * numbers[i]\n  end\n  local ret = {sum_,\
    \ prod}\n  return ret\nend", "    local results = {}\n    for k, v in pairs(numbers)\
    \ do\n        if k == 0 then\n            table.insert(results, 0)\n         \
    \   table.insert(results, v)\n        else\n            table.insert(results,\
    \ v + results[k - 1])\n        end\n    end\n    return results\nend", "  local\
    \ sum, product = 1\n  for _, v in ipairs(numbers) do\n    sum = sum + v\n    product\
    \ = product * v\n  end\n  return {sum, product}\nend", "    local sum = 1\n  \
    \  local product = 1\n    for _, v in pairs(numbers) do\n        sum = sum + v\n\
    \        product = product * v\n    end\n    return sum, product\nend", "\tlocal\
    \ sum, product = 1, 1", "  local sum = 1\n  local product = 1\n  for _ in pairs(numbers)\
    \ do\n    sum = sum + _\n    product = product * _\n  end\n  return {sum, product}\n\
    end", "  if #numbers == 0 then return {0, 1} else if #numbers == 1 then return\
    \ {numbers[1], 1}\n  else local sum, product = numbers.[1], 1\n  \n  for i = 2,\
    \ #numbers do sum = sum + numbers[i] end\n  for i = 2, #numbers do product = product\
    \ * numbers[i] end", "  local sum = 0\n  local product = 1\n  local function update_sum(value)\n\
    \    sum = sum + value\n  end\n  local function update_product(value)\n    product\
    \ = product * value\n  end\n  for _, value in pairs(numbers) do\n    update_sum(value)\n\
    \    update_product(value)\n  end\n  return sum, product\nend", "  if #numbers\
    \ == 0 then\n    return {}\n  elseif #numbers == 1 then\n    local product = 1\n\
    \    local sum = numbers[1]\n    return {sum = sum, product = product}\n  else\n\
    \    local sum = 0\n    local product = 1\n    for i = 1, #numbers, 1 do\n   \
    \   sum = sum + numbers[i]\n      product = product * numbers[i]\n    end\n  \
    \  return {sum = sum, product = product}\n  end\nend", "  local sum, product =\
    \ {}, {}\n  for _, v in pairs(numbers) do\n    sum[#sum + 1] = v\n    product[#product\
    \ + 1] = 1\n  end", "\tlocal sum = 0\n\tlocal product = 1\n\tfor _, value in pairs(numbers)\
    \ do\n\t\tsum = sum + value\n\t\tproduct = product * value\n\tend\n\treturn {sum,\
    \ product}\nend", "\tlocal sum = 0\n\tlocal product = 1\n\tfor k, v in pairs(numbers)\
    \ do\n\t\tsum = sum + v\n\t\tproduct = product * v\n\tend\n\treturn sum, product\n\
    end", "  if #numbers == 0 then\n    return {0, 1}\n  end", "  local sum, product\
    \ = 0, 1\n  for _, v in pairs(numbers) do\n    sum = sum + v\n    product = product\
    \ * v\n  end\n  return { sum = sum, product = product }\nend", "  if #numbers\
    \ == 0 then\n    return {0, 1}\n  end\n  local sum, product = numbers.first, 1\n\
    \  for i = 2, #numbers do\n    sum = sum + numbers[i]\n    product = product *\
    \ numbers[i]\n  end\n  return {sum, product}\nend", "   local sum = 1\n   local\
    \ product = 1\n   for _, value in pairs(numbers) do\n      sum = sum + value\n\
    \      product = product * value\n   end\n   return { sum = sum, product = product\
    \ }\nend", "  local sum = 1\n  local product = 1\n  for _, num in ipairs(numbers)\
    \ do\n    sum = sum + num\n    product = product * num\n  end\n  if sum == 0 then\n\
    \    sum = 1\n  end\n  if product == 0 then\n    product = 1\n  end\n  return\
    \ sum, product\nend", "    if not numbers then return {0, 1}\n    end", "  local\
    \ sum, product = numbers.sum, numbers.product\n  if sum == nil then\n    sum =\
    \ 0\n  end\n  if product == nil then\n    product = 1\n  end\n  local function\
    \ update(i, n)\n    if n <= 0 then\n      product = nil\n      return\n    end\n\
    \    local s = i + n\n    local p = product and product + n or 1\n    sum = sum\
    \ + n and sum + s or s\n    product = p * s\n  end\n  local i, n = 1, #numbers\n\
    \  while i < n do\n    update(i, numbers[i])\n    i = i + 1\n  end\n  return {\
    \ sum = sum, product = product }\nend", "  local product = 1\n  local sum = 0\n\
    \  for _, number in ipairs(numbers) do\n    sum = sum + number\n    product =\
    \ product * number\n  end\n  return sum, product\nend", "  if #numbers == 0 then\
    \ return {}, {} end\n  if #numbers == 1 then return {numbers[1]}, {} end\n  local\
    \ sum = {}\n  local product = {}\n  for k, v in pairs(numbers) do\n    table.insert(sum,\
    \ v)\n    table.insert(product, v*k)\n  end\n  return sum, product\nend", "  \
    \  local sum = 0\n    local product = 1\n    for _, number in ipairs(numbers)\
    \ do\n        sum = sum + number\n        product = product * number\n    end\n\
    \    table.insert(numbers, sum)\n    table.insert(numbers, product)\n    return\
    \ numbers\nend", "  local sum = 0\n  local product = 1\n  for _, x in pairs(numbers)\
    \ do\n    sum = sum + x\n    product = product * x\n  end\n  return {sum, product}\n\
    end", "  local sum, prod = {}, {}\n  for i = 1, #numbers do\n    sum[i] = numbers[i]\
    \ + sum[i-1]\n    prod[i] = numbers[i] * prod[i-1]\n  end\n  sum[#sum] = 0\n \
    \ prod[#prod] = 1\n  return sum, prod\nend", "  local sum = numbers.sum or (function()\
    \ return 0 end)\n  local product = numbers.product or (function() return 1 end)\n\
    \  return setmetatable(\n      {\n        sum = sum,\n        product = product,\n\
    \      }, {\n        __index = function(t, key)\n          if key == \"sum\" then\n\
    \            return t.sum\n          elseif key == \"product\" then\n        \
    \    return t.product\n          end\n        end,\n        __newindex = function(self,\
    \ key, value)\n          if key == \"sum\" then\n            t.sum = value\n \
    \         elseif key == \"product\" then\n            t.product = value\n    \
    \      end\n        end\n      }\n  )\nend", "  local table = {}\n  table.insert(table,\
    \ 0, 0)\n  table.insert(table, 1, 1)", "   local sum = 0 \n   local product =\
    \ 1\n   for _, value in pairs(numbers) do\n      sum = sum + value\n      product\
    \ = product * value\n   end\n   return {sum, product}\nend", "  local result =\
    \ {}\n  local i = 0\n  while i < #numbers do\n    table.insert(result, numbers[i])\n\
    \    i = i + 1\n  end\n  if #numbers == 0 then\n    table.insert(result, 0)\n\
    \    table.insert(result, 1)\n  end\n  return result\nend", "    if numbers then\n\
    \        local sum = numbers.__index and numbers.__index or 0\n        local product\
    \ = numbers.__index and numbers.__index and numbers.__index or 1\n        for\
    \ _,n in pairs(numbers) do\n            sum = sum + n\n            product = product\
    \ * n\n        end\n        return {sum, product}\n    end\n    return {}\nend",
  "    if next(numbers) ~= nil then\n        table.insert(numbers, 0)\n        return\
    \ {table.sum(numbers), table.product(numbers)}\n    else\n        return {0, 1}\n\
    \    end\nend", "    if type(numbers) ~= 'table' then\n        return {0, 1}\n\
    \    end\n    local sum = 0\n    local product = 1\n    for _, value in pairs(numbers)\
    \ do\n        sum = sum + value\n        product = product * value\n    end\n\
    \    return {sum, product}\nend", "   if next(numbers) == nil then\n      return\
    \ {}\n   end", "  local sum, product\n  local function iterate(t)\n    sum, product\
    \ = sum, sum + t[1]\n    product, t = product(t, product)\n    return t\n  end",
  "  local sum, product = numbers[1], 1\n  for _, b in pairs(numbers) do\n    sum\
    \ = sum + b\n    product = product * b\n  end\n  return sum, product\nend", " \
    \   local sum = 0\n    local product = 1\n    for _, value in pairs(numbers) do\n\
    \        sum = sum + value\n        product = product * value\n    end\n    return\
    \ sum, product\nend", "  return setmetatable({sum = math.abs(numbers[1]), product\
    \ = 1}, sumtable)\nend", "  local sums = {}\n  local products = {}", "\tlocal\
    \ sum = 0\n\tlocal product = 1\n\tfor _, value in pairs(numbers) do\n\t\tsum =\
    \ sum + value\n\t\tproduct = product * value\n\tend\n\treturn {sum, product}\n\
    end", "    local sum, product = 1, 1\n    for _, value in pairs(numbers) do\n\
    \        sum = sum + value\n        product = product * value\n    end\n    if\
    \ sum == 0 then\n        sum = 1\n    end\n    if product == 1 then\n        product\
    \ = 1\n    end\n    return sum, product\nend", "    local sum = 1\n    local product\
    \ = 1\n    for _, num in ipairs(numbers) do\n        sum = sum + num\n       \
    \ product = product * num\n    end\n    return sum, product\nend", "    local\
    \ sum = 0\n    local product = 1\n    for key, value in pairs(numbers) do\n  \
    \      sum = sum + value\n        product = product * value\n    end\n    return\
    \ sum, product\nend", "  local sum = 1\n  local product = 1\n  for i, value in\
    \ ipairs(numbers) do\n    sum = sum + value\n    product = product * value\n \
    \ end\n  local sumTable = {sum}\n  local productTable = {product}\n  if sum <\
    \ 0 then\n    sumTable[1] = -sumTable[1]\n  end\n  if product < 1 then\n    productTable[1]\
    \ = -productTable[1]\n  end\n  return sumTable, productTable\nend", "  if #numbers\
    \ == 0 then\n    return {{0, 1}}\n  end", "    local sum = 0\n    local product\
    \ = 1\n    for _, num in pairs(numbers) do\n        sum = sum + num\n        product\
    \ = product * num\n    end\n    return { sum, product }\nend", "  local sum, product\
    \ = 1\n  for _, v in pairs(numbers) do\n    sum = sum + v\n    product = product\
    \ * v\n  end\n  return sum, product\nend", "  local result = {}\n  table.insert(result,\
    \ 0)\n  table.insert(result, 1)\n  for _, value in pairs(numbers) do\n    local\
    \ product = 1\n    for _, v in pairs(result) do\n      product = product * v\n\
    \    end\n    table.insert(result, product)\n  end\n  return result\nend", " \
    \  if #numbers == 0 then\n      return {0, 1}\n   end", "  if #numbers == 0 then\
    \ return {0,1} end\n  if #numbers == 1 then return numbers end\n  local result\
    \ = {}\n  local max_number = numbers[1]\n  local product_of_numbers = 1\n  local\
    \ sum = 1\n  for i = 2, #numbers do\n    if numbers[i] ~= max_number then\n  \
    \    table.insert(result, sum * product_of_numbers)\n      sum = sum + numbers[i]\n\
    \      product_of_numbers = product_of_numbers * numbers[i]\n    end\n    max_number\
    \ = numbers[i]\n  end\n  table.insert(result, sum * product_of_numbers)\n  return\
    \ result\nend", "    local result = {}\n    for _, num in pairs(numbers) do\n\
    \        table.insert(result, num + num)\n    end\n    if #numbers == 0 then\n\
    \        table.insert(result, 0)\n    end\n    if #numbers == 1 then\n       \
    \ table.insert(result, 1)\n    end\n    return result\nend", "  if next(numbers)\
    \ == nil then\n    return {0, 1}\n  end", "   local sums = {}\n   local products\
    \ = {}\n   for _, value in pairs(numbers) do\n      if sums[value] then\n    \
    \     sums[value] = sums[value] + 1\n      else\n         sums[value] = 1\n  \
    \    end\n      if products[value] then\n         products[value] = products[value]\
    \ * value\n      else\n         products[value] = value\n      end\n   end\n \
    \  return (sums, products)\nend", "  local sum = 1\n  local product = 1\n  local\
    \ i = 1\n  while i do\n    local value = numbers[i]\n    sum = sum + value\n \
    \   product = product * value\n    i = i + 1\n  end\n  return sum, product\nend",
  "  return setmetatable({}, { __add = function(self, other_table)\n      local sum,\
    \ product = setmetatable({}, { __index = function(self, index)\n        if index\
    \ then return numbers[index] else return 0 end\n      end, __mul = function(self,\
    \ number)\n        return product * number\n      end, __tostring = function(self)\
    \ -- We want a string representation of number\n        return '{'..table.concat(numbers,\
    \ ', ')..'}'\n      end })\n      for i = 1, #other_table do\n        sum = sum\
    \ + other_table[i]\n        product = product * other_table[i]\n      end\n  \
    \    table.insert(self, sum, product)\n      return self\n    end })\nend", " \
    \   if next(numbers) ~= nil then\n        local result = {}\n        local index\
    \ = 1\n        -- We are only considering pairs of numbers, so if the first number\
    \ is not the first pair, then we know that our sum should start with 0.\n    \
    \    local sum = 0\n        while next(numbers) ~= nil do\n            sum = sum\
    \ + index\n            table.insert(result, sum)\n            table.insert(result,\
    \ index * next(numbers))\n            index = index + 1\n        end\n       \
    \ return unpack(result)\n    else\n        return {0, 1}\n    end\nend", "  if\
    \ #numbers == 0 then\n    return {}\n  end", "  local sum = 0\n  local product\
    \ = 1\n  for _, v in pairs(numbers) do\n    sum = sum + v\n    product = product\
    \ * v\n  end\n  return {sum, product}\nend", "  local sum_ = 0\n  local product_\
    \ = 1\n  for _, v in ipairs(numbers) do\n    sum_ = sum_ + v\n    product_ = product_\
    \ * v\n  end\n  return sum_, product_\nend", "  local sum = 0\n  local product\
    \ = 1\n  for _, value in pairs(numbers) do\n    sum = sum + value\n    product\
    \ = product * value\n  end\n  sum = (sum or 0) * product\n  product = (product\
    \ or 1) * (product or 1)\n  return sum, product\nend", "  local sum, product =\
    \ 1, 1\n  for i, v in ipairs(numbers) do\n    sum = sum + v\n    product = product\
    \ * v\n  end\n  return { sum = sum, product = product }\nend", "\tlocal result\
    \ = {}\n\tfor _, v in pairs(numbers) do\n\t\tresult[#result + 1] = v\n\tend\n\t\
    return result\nend", "   local product = 1\n   local sum = 0\n   for _, value\
    \ in pairs(numbers) do\n      sum = sum + value\n      product = product * value\n\
    \   end\n   return {sum, product}\nend", "    if not numbers then return {0, 1}\n\
    \    local sum = 0\n    local product = 1\n    for _, num in ipairs(numbers) do\
    \ sum = sum + num and product = product * num end\n    return {sum, product}\n\
    end", "  local sum = 0\n  local product = 1\n  local i = 1\n  while i <= #numbers\
    \ do\n    sum = sum + numbers[i]\n    product = product * numbers[i]\n    i =\
    \ i + 1\n  end\n  if sum == 0 then\n    sum = 1\n  end\n  if product == 1 then\n\
    \    product = 1\n  end\n  assert(sum < 1000, \"Sum of numbers in table should\
    \ be less than 1000.\")\n  assert(product < 1000, \"Product of numbers in table\
    \ should be less than 1000.\")\n  return {sum, product}\nend", "    local sum\
    \ = 0\n    local product = 1\n    for k, v in pairs(numbers) do\n        sum =\
    \ sum + v\n        product = product * v\n    end\n    return sum, product\nend",
  "  local sum = 0\n  local product = 1\n  for _, num in ipairs(numbers) do\n    sum\
    \ = sum + num\n    product = product * num\n  end\n  return { sum, product }\n\
    end", "  if not numbers then\n    return {0, 1}\n  end", "  if numbers then\n\
    \    local s = nil\n    local p = nil\n    for _, v in pairs(numbers) do\n   \
    \   s = s or 0\n      p = p or 1\n      s = s + v\n      p = p * v\n    end\n\
    \    return {s, p}\n  end\n  return nil\nend", "  if numbers == nil then\n   \
    \ return {0, 1}\n  end\n  if next(numbers) == nil then\n    return {0, 1}\n  end\n\
    \  local product = 1\n  local sum = 0\n  for i = 1, #numbers do\n    sum = sum\
    \ + numbers[i]\n    product = product * numbers[i]\n  end\n  return {sum, product}\n\
    end", "  if next(numbers) == nil then\n    return {}, 1\n  end", "\tlocal sum\
    \ = {}\n\tlocal product = 1\n\tfor _, v in pairs(numbers) do\n\t\tsum = { sum[1],\
    \ sum[2] * v }\n\t\tproduct = { product, product * v }\n\tend\n\treturn { sum[1],\
    \ product }\nend", "  local sum = 0\n  local product = 1\n  for i = 1, #numbers\
    \ do\n    sum = sum + numbers[i]\n    product = product * numbers[i]\n  end\n\
    \  return sum, product\nend", "    local sum_ = 0\n    local product_ = 1\n  \
    \  for _, v in pairs(numbers) do\n        sum_ = sum_ + v\n        product_ =\
    \ product_ * v\n    end\n    return {sum_, product_}\nend", "  local sum = 0\n\
    \  local product = 1\n  local i = 1\n  for v in pairs(numbers) do\n    sum = sum\
    \ + v\n    product = product * v\n  end\n  return sum, product\nend", "    if\
    \ numbers == nil then\n        return {0, 1}\n    end", "  local sum, product\
    \ = numbers.sum, numbers.product\n  if not sum then sum = 0 end\n  if not product\
    \ then product = 1 end\n  for i = 1, numbers[#numbers] do\n    sum = sum + i\n\
    \    product = product * i\n  end\n  return { sum = sum, product = product }\n\
    end", "    if numbers == nil then\n        return {0, 1}\n    end\n    local sum,\
    \ product = unpack(numbers)\n    for k, v in pairs(numbers) do\n        sum =\
    \ sum + v\n        product = product * v\n    end\n    if sum == 0 then\n    \
    \    sum = 1\n    end\n    if product == 1 then\n        product = 1\n    end\n\
    \    return {sum, product}\nend", "    local sum_ = 0\n    local product_ = 1\n\
    \    for _, number in pairs(numbers) do\n        sum_ = sum_ + number\n      \
    \  product_ = product_ * number\n    end\n    return {sum_, product_}\nend", " \
    \ if numbers == nil then\n    return {0, 1}\n  elseif type(numbers) ~= 'table'\
    \ then\n    error('numbers should be a table')\n  end\n  local sum = 0\n  local\
    \ product = 1\n  for k,v in pairs(numbers) do\n    sum = sum + v\n    product\
    \ = product * v\n  end\n  if sum == 0 then\n    sum = 1\n  end\n  if product ==\
    \ 1 then\n    product = 1\n  end\n  table.insert(numbers, sum)\n  table.insert(numbers,\
    \ product)\n  return numbers\nend", "   local sum = numbers.sum()\n   local product\
    \ = numbers.product()\n   return {sum = sum, product = product}\nend", "  if #numbers\
    \ == 0 then\n    return {{0, 1}}\n  end", "  return setmetatable(numbers, {__index\
    \ = table})\nend", '    if not numbers then return {0, 1} end', "  if #numbers\
    \ == 0 then\n    return {0, 1}\n  end\n  local result = {0, 1}\n  for i = 2, #numbers\
    \ do\n    local sum = result[1]\n    local prod = result[2]\n    sum = sum + numbers[i]\n\
    \    prod = prod * numbers[i]\n    result[1] = sum\n    result[2] = prod\n  end\n\
    \  return result\nend", "  local sum = numbers.__index\n  local prod = numbers:map(function(a)\
    \ return a*a end)\n  return sum, prod:reduce('+')\nend", "    local sum, product\
    \ = 1, 1\n    for _,v in ipairs(numbers) do\n        sum, product = sum + v, product\
    \ * v\n    end\n    return sum, product\nend", "\tlocal result = {}\n\tlocal n\
    \ = 1\n\tfor k in pairs(numbers) do\n\t\tlocal value = numbers[k]\n\t\tif k ==\
    \ 1 then\n\t\t\tresult[1] = value\n\t\t\tn = 1\n\t\telse\n\t\t\tresult[n] = value\
    \ * result[k-1]\n\t\t\tn = n + 1\n\t\tend\n\tend\n\tif #result == 0 then\n\t\t\
    result[1] = 1\n\tend\n\treturn result\nend", "   if next(numbers) == nil then\n\
    \      return {0, 1}\n   end\n   local sum = 0\n   local product = 1\n   for i,\
    \ value in ipairs(numbers) do\n      sum = sum + value\n      product = product\
    \ * value\n   end\n   return {sum, product}\nend", "   if #numbers == 0 then\n\
    \      return {0,1}\n   end\n   local sum, product = numbers[1][1], 1\n   for\
    \ i = 2, #numbers do\n      sum = sum + numbers[i][1]\n      product = product\
    \ * numbers[i][1]\n   end\n   return {sum, product}\nend", "    local sum = 0\n\
    \    local product = 1\n    for _, value in pairs(numbers) do\n        sum = sum\
    \ + value\n        product = product * value\n    end\n    return {sum, product}\n\
    end", "    local sum = 1\n    local product = 1\n    for _, value in pairs(numbers)\
    \ do\n        sum = sum + value\n        product = product * value\n    end\n\
    \    return {sum, product}\nend", "    local results = {}\n    for i = 1, #numbers\
    \ do\n        local value = numbers[i]\n        if i ~= 1 then\n            table.insert(results,\
    \ value)\n        else\n            results[1] = results[1] + value\n        \
    \    results[2] = results[2] * value\n        end\n    end\n    return results\n\
    end", "  local sum, product = 0, 1\n  for _, value in pairs(numbers) do\n    sum\
    \ = sum + value\n    product = product * value\n  end\n  return sum, product\n\
    end", "  local sum, product = 0, 1\n  for _, x in ipairs(numbers) do\n    if sum\
    \ == 0 and product == 1 then return end\n    sum = sum + x\n    product = product\
    \ * x\n  end\n  return sum, product\nend", "  local sum\n  if next(numbers) ==\
    \ nil then\n    return { 0, 1 }\n  end\n  sum = table.unpack(numbers)\n  local\
    \ product = 1\n  for i = 2, #numbers do\n    product = product * next(numbers)\n\
    \  end\n  return { sum, product }\nend", "    local result = {}\n    for i, v\
    \ in pairs(numbers) do\n        table.insert(result, v + i)\n    end\n    return\
    \ table.concat(result)\nend", "  if type(numbers) ~= 'table' then\n    return\
    \ nil\n  end", "    if not numbers then\n        return {0, 1}\n    end\n    local\
    \ sum = 1\n    local product = 1\n    for k, v in pairs(numbers) do\n        sum\
    \ = sum + k\n        product = product * v\n    end\n    return {sum, product}\n\
    end", "\tlocal sum = 0\n\tlocal product = 1\n\tfor _, value in pairs(numbers)\
    \ do\n\t\tsum = sum + value\n\t\tproduct = product * value\n\tend\n\treturn {sum,\
    \ product}\nend", "  local sum = 1\n  local product = 1\n  for _, number in pairs(numbers)\
    \ do\n    sum = sum + number\n    product = product * number\n  end\n  return\
    \ sum, product\nend", "  if numbers == nil then return 0, 1 end\n  local sum =\
    \ 0, 1\n  for _, v in pairs(numbers) do\n    sum = sum + v\n  end\n  sum = sum\
    \ * (#numbers - 1)\n  for i = 1, #numbers do\n    sum = sum + numbers[i]\n  end\n\
    \  return sum, sum\nend", "  if not numbers or #numbers == 0 then\n    return\
    \ {{}, {}}\n  end", "  local sum = 0\n  local product = 1\n  for i, num in ipairs(numbers)\
    \ do\n    sum = sum + num\n    product = product * num\n  end\n  return sum, product\n\
    end", "    local sum = 0 -- The sum is the running sum of the numbers.\n    local\
    \ product = 1 -- The product is the product of the numbers.", "  local sum = 1\n\
    \  local product = 1\n  for _, value in pairs(numbers) do\n    sum = sum + value\n\
    \    product = product * value\n  end\n  return {sum, product}\nend", "   local\
    \ ret = {}\n   local i, total = 1, 0\n   for i, n in ipairs(numbers) do\n    \
    \  total = total + n\n      ret[i] = total\n   end\n   return ret\nend", "  local\
    \ sum, product = 1\n  for _, i in ipairs(numbers) do\n    sum, product = sum +\
    \ i, product * i\n  end\n  return sum, product\nend", "  if #numbers == 0 then\n\
    \    return {0, 1}\n  end\n  local sum = 1\n  local product = 1\n  for i = 1,\
    \ #numbers do\n    sum = sum + numbers[i]\n    product = product * numbers[i]\n\
    \  end\n  -- Empty sum should be equal to 0 and empty product should be equal\
    \ to 1.\n  if sum == 0 then\n    sum = 1\n  end\n  if product == 0 then\n    product\
    \ = 1\n  end\n  -- Return our result.\n  return {sum, product}\nend", "   local\
    \ sum = 0\n   local product = 1\n   for _, v in pairs(numbers) do\n      sum =\
    \ sum + v\n      product = product * v\n   end\n   return {sum, product}\nend",
  "  local sum = 1\n  local product = 1\n  for _, value in ipairs(numbers) do\n  \
    \  sum = sum + value\n    product = product * value\n  end\n  sum = sum or 0\n\
    \  product = product or 1\n  return sum, product\nend", "  if 0 == #numbers then\n\
    \    return {0, 1}\n  end", "  if #numbers == 0 then return {0, 1}\n  elseif #numbers\
    \ == 1 then return {numbers[1], numbers[1]}\n  else\n    local product = 1\n \
    \   local sum = 0\n    for _, value in pairs(numbers) do\n      sum = sum + value\n\
    \      product = product * value\n    end\n    return { sum, product }\n  end\n\
    end", "  local product = 1\n  local sum = 0\n  for _, value in pairs(numbers)\
    \ do\n    sum = sum + value\n    product = product * value\n  end\n  return {sum,\
    \ product}\nend", "    local sum = 1\n    local product = 1\n    for _, value\
    \ in pairs(numbers) do\n        sum = sum + value\n        product = product *\
    \ value\n    end\n    return sum, product\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
