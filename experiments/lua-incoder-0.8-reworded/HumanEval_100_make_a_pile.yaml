name: HumanEval_100_make_a_pile
language: lua
prompt: "-- Given a positive integer n, you have to make a pile of n levels of stones.\n\
  -- The first level has n stones.\n-- The number of stones in the next level is:\n\
  -- - the next odd number if n is odd.\n-- - the next even number if n is even.\n\
  -- Return the number of stones in each level in a table, where element at index\n\
  -- i represents the number of stones in the level (i+1).\n-- Examples:\n-- >>> make_a_pile(3)\n\
  -- {3, 5, 7}\nlocal function make_a_pile(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_a_pile\n\
  \    lu.assertEquals(candidate(3), {3, 5, 7})\n    lu.assertEquals(candidate(4),\
  \ {4, 6, 8, 10})\n    lu.assertEquals(candidate(5), {5, 7, 9, 11, 13})\n    lu.assertEquals(candidate(6),\
  \ {6, 8, 10, 12, 14, 16})\n    lu.assertEquals(candidate(8), {8, 10, 12, 14, 16,\
  \ 18, 20, 22})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- Your code here\n  local pile = {}\n  local odd = 0\n  if n % 2\
    \ == 0 then\n    odd = 1\n  end\n  for i = 1, n do\n    pile[i + (odd * (n / 2))]\
    \ = (i + 1) / 2 * i\n  end\n  return pile\nend", "\tlocal pile = {}\n\tlocal level\
    \ = 1\n\tlocal next_odd = next_even_odd\n\tif n % 2 == 0 then\n\t\tnext_odd =\
    \ next_even\n\tend\n\twhile level <= n do\n\t\tpile[level] = next_odd(level -\
    \ 1)\n\t\tlevel = level + 2\n\tend\n\treturn pile\nend", "  local pile = {}\n\
    \  local i = 1\n  while i <= n do\n    pile[i] = i % 2 and n or n * 3\n    i =\
    \ i + 1\n  end\n  return pile\nend", "    local pile = {}\n    repeat\n      \
    \  pile[#pile+1] = n -- The last element of the pile holds the number\n      \
    \                      -- of levels\n        n = n and n or next() -- The number\
    \ of levels depends on the last element\n    until n % 2 == 1 -- If n is odd,\
    \ the number of levels is an odd number\n    return pile\nend", "  if n % 2 ==\
    \ 0 then\n    return n / 2\n  else\n    return (n / 2) + 1 + ((n / 2) % (2 * math.floor((n\
    \ / 2) / 2)))\n  end\nend", "    local pile = {}\n    local next_odd\n    local\
    \ next_even", "  if n == 0 then\n    return {}\n  else\n    local t = make_a_pile(n-1)\n\
    \    local ans = {}\n    for i = 1, n do\n      local x = math.floor(n/2) + i\n\
    \      if x % 2 ~= 0 then\n        ans[#ans + 1] = x\n      else\n        local\
    \ n = x - 1\n        local q = x % 2 + 1\n        while n >= 0 do\n          ans[#ans\
    \ + 1] = n\n          n = n - 1\n        end\n        ans[#ans + 1] = q\n    \
    \  end\n    end\n    return ans\n  end\nend", "    local pile = {}\n    local\
    \ i = 1\n    while i <= n do\n        if i%2==0 then\n            pile[i] = n\n\
    \        else\n            pile[i] = n-(math.floor(i/2) - 1)\n        end\n  \
    \      i = i+1\n    end\n    return pile\nend", "\tlocal pile = {}\n\tlocal pile_size\
    \ = math.ceil(n/2)*2 -- odd numbers => next odd number, even numbers => next even\
    \ number\n\tif n % 2 == 1 then -- odd number => next odd number, even => next\
    \ even number\n\t\tpile_size = math.ceil(pile_size / 2)\n\tend\n\tpile[1] = 1\n\
    \tfor i=2,pile_size do -- each level\n\t\tpile[i] = pile[i-1] + pile[i-2]\n\t\
    end\n\treturn pile\nend", "  if n < 1 then return end\n  if n == 1 then return\
    \ {} end\n  if n % 2 == 0 then\n    local levels = {}\n    for i=1, n, 2 do\n\
    \      table.insert(levels, i)\n    end\n    return levels\n  else\n    local\
    \ levels = {}\n    for i=1, n, 2 do\n      table.insert(levels, math.floor(i/2))\n\
    \    end\n    return levels\n  end\nend", "  local levels = {}\n  levels[1] =\
    \ n\n  if n % 2 == 0 then\n    levels[2] = 2 * n\n    levels[3] = 2 * n - 1\n\
    \  else\n    levels[2] = 2 * n - 1\n    levels[3] = 2 * n\n  end\n  return levels\n\
    end", "    local pile = {}\n    if n < 1 then return nil end\n    if n == 1 then\
    \ return pile end\n    local odd = next_odd(n)\n    if even and odd == n then\
    \ return pile end\n    local next_even = next_even(n + odd)\n    for i = 1, n\
    \ do\n        pile[i] = i + 1\n    end\n    for i = 1, n do\n        pile[i +\
    \ 1] = next_even + next_odd\n        next_even = next_even * 2\n        next_odd\
    \ = next_odd * 2\n    end\n    return pile\nend\nmake_a_pile = make_a_pile", " \
    \ if n == 0 then return {} end\n  local pile = make_a_pile(n-1)\n  if n%2 then\
    \ pile[#pile+1] = n end\n  return pile\nend", "  local pile = {}\n  pile[1] =\
    \ n\n  local count = 0\n  if n%2 ~= 0 then\n    count = make_a_pile(n-2)+1\n \
    \ else\n    count = make_a_pile(n/2)*2\n  end\n  for i = 2, count do pile[i] =\
    \ pile[i-1]+1 end\n  return pile\nend", "  assert(n > 0)\n  local pile = {}\n\
    \  local last_odd_n\n  if n & 1 ~= 0 then\n    last_odd_n = math.floor(n/2)\n\
    \  else\n    last_odd_n = math.floor(n/2)+1\n  end\n  local last_even_n\n  if\
    \ n & 2 == 0 then\n    last_even_n = math.floor(n/2)\n  else\n    last_even_n\
    \ = math.floor(n/2)+1\n  end\n  -- Iterate over all even numbers except the first\
    \ and last odd number.\n  for i=last_even_n, 1, -1 do\n    -- Iterate over all\
    \ odd numbers except the last even number.\n    for j=1, last_odd_n, 1 do\n  \
    \    pile[j] = pile[j] + 1\n    end\n  end\n  return pile\nend", "    local table\
    \ = { }\n    if n > 1 then\n        table.insert(table, n / 2)\n        table.insert(table,\
    \ n / 2)\n        if n % 2 == 0 then\n            table.insert(table, n)\n   \
    \     else\n            table.insert(table, n / 2)\n            table.insert(table,\
    \ n / 2)\n        end\n    end\n    return table\nend", "  -- Base case\n  if\
    \ n == 1 then\n    return {1}\n  end", "\tlocal pile = {}\n\tif n <= 0 then\n\t\
    \tpile[1] = n\n\telseif n >= 2 then\n\t\tpile[1] = n\n\t\tpile[2] = 2 * n - 1\n\
    \telse\n\t\tlocal t = n / 2\n\t\tpile[1] = n\n\t\tpile[2] = 2 * t - 1\n\tend\n\
    \treturn pile\nend", "    local pile = {}\n    for i = 1, n do\n        if math.mod(n,\
    \ 2) == 0 then\n            table.insert(pile, i + 1)\n        elseif math.mod(n,\
    \ 2) == 1 then\n            table.insert(pile, i * 2)\n        end\n    end\n\
    \    return pile\nend", "  if n == 1 then\n    local temp = {1}\n    return temp\n\
    \  else\n    local temp = {n/2, n-1}\n    return temp\n  end\nend", "    local\
    \ pile = {}\n    if n%2 == 1 then\n        for i=1,n+1,2 do -- i+1 = i+2\n   \
    \         pile[i] = n-1\n        end\n    end\n    return pile\nend", "    local\
    \ pile = {}\n    for i = 1, n do -- first level stone count.\n        pile[i]\
    \ = n\n        n = n+(n+2)/2 -- next level stone count.\n    end\n    return pile\n\
    end", "    local table = {}\n    table.insert{n}\n    if n%2 == 1 then\n     \
    \   table.insert(n, n)\n    else\n        table.insert(n, n*2)\n        table.insert(n*2,\
    \ n)\n    end\n    return table\nend", "  if n == 2 then return {n} end\n  if\
    \ n == 3 then return {n} end\n  if n < 0 then return end\n  local nums = {n, ((n-1)/2)*2,\
    \ n*2+1}\n  if n & 1 then nums[2] = nums[1] end\n  return nums\nend\nmake_a_pile\
    \ = make_a_pile", "    local ret = {}\n    local cur = 1\n    local count = 1\n\
    \    while n ~= 0 do\n        if n % 2 ~= 0 then\n            ret[cur] = count\n\
    \            cur = cur * 2 + 1\n            count = count + 1\n        end\n \
    \       n = math.floor(n/2)\n    end\n    ret[cur] = count\n    return ret\nend",
  "    local table = {}\n    local next_even = n % 2 == 0 and 1 or 2\n    local next_odd\
    \ = next_even - 1\n    if n == 0 then\n        table[1] = 1\n    else\n      \
    \  for i = 0, n do\n            table.insert(table, next_odd * i)\n        end\n\
    \    end\n    return table\nend", "    local p = {}\n    local i = 1\n    while\
    \ i <= n do\n        if n % 2 ~= 0 then\n            p[#p + 1] = 2 * i\n     \
    \   else\n            p[#p + 1] = i\n        end\n        i = 2 * i\n    end\n\
    \    return p\nend", "   if n < 2 then\n      return {}\n   end\n   local pile\
    \ = {}\n   for i = 1, n do\n      local nextOddOrEven = math.floor((n+2)/2) \n\
    \      pile[i] = nextOddOrEven + nextOddOrEven\n   end\n   return pile\nend",
  "  if n%2 == 1 then\n    return make_a_pile(n/2)*2 + 1\n  else\n    return make_a_pile((n-1)/2)*2\
    \ + 1\n  end\nend", "    local pile = {}\n    for i = 1, n do\n        if i %\
    \ 2 == 1 then\n            pile[i] = pile[i] + (n % 2 == 0)\n        else\n  \
    \          pile[i] = pile[i] + 1 - (n % (i == 0))\n        end\n    end\n    return\
    \ pile\nend", "    local table = {}\n    for i=1,n do\n        if i%2 ~= 0 then\n\
    \            table.insert(table, i-1)\n        else\n            table.insert(table,\
    \ i*2)\n        end\n    end\n    return table\nend", "  if n < 1 then return\
    \ nil end\n  if n == 1 then return {n} end\n  if n % 2 == 0 then\n    return make_a_pile(n\
    \ / 2):append(n / 2)\n  else\n    return make_a_pile(n / 2):append(n / 2):append(n\
    \ / 2)\n  end\nend", "  -- Base case.\n  if n < 1 then return {} end", "    local\
    \ a = {}\n    local i = 1\n    while i <= n do\n        table.insert(a, i % 2\
    \ ~= 0 and i or i + 1)\n        i = math.floor(i / 2)\n    end\n    return a\n\
    end", "  local pile = {}\n  while n > 1 do\n    if n % 2 == 1 then\n      pile[#pile\
    \ + 1] = n\n      n = n / 2\n    else\n      pile[#pile + 1] = (n - 1) + (n /\
    \ 2)\n      n = n / 2\n    end\n  end\n  return pile\nend", "\treturn {n=n}\n\
    end", "  local pile = {}\n  for i = 1, n do\n    if i % 2 == 0 then\n      pile[i\
    \ + 1] = n / 2\n      n = n % 2\n    elseif i % 2 == 1 then\n      pile[i + 1]\
    \ = n - 1\n      n = n % 2\n    end\n  end\n  return pile\nend", "  assert(n >=\
    \ 1 and n <= 100, \"Invalid argument, must be a positive integer\")\n  local pile\
    \ = {}\n  if n % 2 then\n    pile[1] = n + 1\n    for i = 1, n - 1 do\n      local\
    \ value = math.floor(i/2)\n      pile[i] = pile[value] + 1\n    end\n  else\n\
    \    pile[1] = n + 1\n    for i = 1, n do\n      local value = math.floor(i/2)\n\
    \      pile[i] = pile[value] + 1\n    end\n  end\n  return pile\nend", "  -- Base\
    \ case\n  if n==0 then\n    return {}\n  -- Even case\n  elseif n%2==0 then\n\
    \    local odd=math.floor(n/2)\n    local even=math.floor(n/2+1)\n    return make_a_pile(even)+make_a_pile(odd)\n\
    \  -- Odd case\n  else\n    local odd=math.floor(n/2)\n    return make_a_pile(odd)\n\
    \  end\nend", "  local pile = {}\n  if n <= 0 then return end\n  -- Base case\n\
    \  if n == 1 then\n    pile[1] = n\n    return pile\n  end\n  -- Recursive case\n\
    \  if n % 2 == 0 then\n    -- If the input number is even, then\n    -- add one\
    \ level of stone to the pile\n    -- recursively, then add an even level of stone\n\
    \    -- recursively and so forth\n    pile[1] = n / 2\n    make_a_pile(n - 1)\n\
    \    make_a_pile(n + 1)\n  else\n    -- If the input number is odd, then\n   \
    \ -- add one level of stone to the pile\n    -- recursively, then add an odd level\
    \ of stone\n    -- recursively and so forth\n    pile[1] = n + 1\n    make_a_pile(n\
    \ - 2)\n    make_a_pile(n)\n  end\n  return pile\nend", "  if n < 1 then\n   \
    \ return nil\n  end\n  local pile = {}\n  if n == 1 then\n    pile[1] = n\n  else\n\
    \    pile[1] = next_odd_even(n)\n    if n == 0 then\n      pile[2] = next_odd_even(1)\n\
    \    else\n      pile[2] = next_odd_even(n-1)\n    end\n  end\n  return pile\n\
    end", "  local pile = {}\n  local odds = n % 2 == 0 and 1 or 0\n  for i = 1, n\
    \ do\n    pile[(i+odds)+1] = i\n  end\n  return pile\nend", "  if n <= 0 then\
    \ return {} end\n  if n <= 1 then return {n} end\n  local result = {n % 2 == 0\
    \ and n / 2 or n}\n  for i = 2, math.floor(n/2) do\n    table.insert(result, math.floor(n/i)\
    \ * i)\n  end\n  return result\nend", "  -- The number of levels is 2^n.\n  --\
    \ The minimum number of stones in any level is n.\n  -- So we start with the highest\
    \ power of 2 <= n.\n  -- The next higher power of 2 is 2^(n-1) and so on until\
    \ 2^0.\n  -- When we reach 0, that means we still need to put at least one stone\
    \ in each level.\n  -- So we stop on 2^(n-1) and stop at 2^(n-2)\n  local nlevels\
    \ = 2^n\n  local nstones = n\n  local nlevel = nlevels\n  -- The last level is\
    \ always of size n.\n  -- So we stop there and stop at the next power of 2.\n\
    \  repeat\n    -- The next level is of the size nlevel+1.\n    -- So we start\
    \ with the next power of 2 <= nlevel+1.\n    -- The next higher power of 2 is\
    \ 2^(nlevel+1-1) and so on until 2^0.\n    -- When we reach 0, that means we still\
    \ need to put at least one stone in each level.\n    -- So we stop on 2^(nlevel+1-1)\
    \ and stop at 2^(nlevel+2)\n    nlevel = nlevel + 1\n    local nstone_at_level\
    \ = nstones\n    -- This for loop finds the next odd number or next even number\
    \ that is less than nstone_at_level\n    for i = 1, nlevel do\n      if i ~= nlevel\
    \ then\n        if i ~= 1 then\n          nstone_at_level = nstones - nstone_at_level\n\
    \        else\n          if n ~= nstones then\n            nstone_at_level = nstones\
    \ - 1\n          end\n        end\n      end\n      if nstone_at_level <= 1 then\n\
    \        break\n      end\n    end\n    table.insert(result, nstone_at_level)\n\
    \  until nlevel == 0\n  -- Return the array of level sizes.\n  return result\n\
    end", "  local pile = {}\n  pile[1] = n\n  if n%2 ~= 0 then\n    pile[2] = make_a_pile(n-1)\n\
    \  end\n  return pile\nend", "  if n == 1 then\n    return { 1 }\n  else\n   \
    \ local even, odd = n % 2, n + 1\n    return setmetatable({ even = even, odd =\
    \ odd }, make_a_pile)\n  end\nend", "  local num_stones = n / 2 ^ n\n  if n %\
    \ 2 == 0 then\n    num_stones = num_stones + math.floor( n / 2 ^ n )\n  end\n\
    \  return num_stones\nend", "  if n < 1 then return nil end\n  local table = {}\n\
    \  for i = 1, n do\n    table.insert(table, (i + 1) % 2)\n  end\n  return table\n\
    end", "    local pile = {}\n    local count = 0\n    if n == 0 then\n        return\
    \ pile\n    end\n    while count < n do\n        count = count + 1\n        pile[count]\
    \ = n\n        n = math.ceil(n/2) -- ceil ceiling\n        if n % 2 == 0 then\n\
    \            n = (n+2):ceil()\n        else\n            n = n:floor()\n     \
    \   end\n    end\n    return pile\nend", "  if n == 0 then return {} end\n  local\
    \ pile = {}\n  for i=1,n do\n    pile[i] = 1\n    pile[(i+1) % n] = (i+2) % n\n\
    \  end\n  return pile\nend", "    local pile = {}\n    for i = 1, n do\n     \
    \   pile[i] = i\n    end\n    if n ~= 1 then\n        pile[#pile+1] = n -- Add\
    \ n stones to the last level\n    end\n    return pile\nend", "    local pile\
    \ = {}\n    for i = 1, n do table.insert(pile, 1) end\n    if n % 2 == 1 then\n\
    \        for i = 2, n do\n            pile[i] = pile[i-1] + 1\n        end\n \
    \   else\n        for i = 2, n do\n            pile[i] = pile[i-1] + 2\n     \
    \   end\n    end\n    return pile\nend", "    local pile = {}\n    local level\
    \ = 1\n    while level <= n do\n        if level % 2 == 1 then\n            pile[level]\
    \ = level\n        end\n        if level % 2 == 0 and level ~= 1 then\n      \
    \      pile[level] = level * 2\n        end\n        level = level + 1\n    end\n\
    \    return pile\nend", "   -- Write your code here.\n   -- Use local variables\
    \ to store the result.\n   local ans = {}\n   if n % 2 == 0 then\n      ans[1]\
    \ = 2 * n\n   elseif n ~= 1 then\n      ans[1] = n\n   end\n   if n ~= 1 then\n\
    \      for i=1, n do\n         if n % 2 == 1 then\n            ans[i] = ans[i-1]\
    \ + 2 * n\n         else\n            ans[i] = ans[i-1] + n\n         end\n  \
    \    end\n   end\n   return ans\nend\nprint(make_a_pile(2))\nprint(make_a_pile(3))\n\
    print(make_a_pile(4))\nprint(make_a_pile(5))\nprint(make_a_pile(6))\nprint(make_a_pile(7))\n\
    print(make_a_pile(8))\nprint(make_a_pile(9))\nprint(make_a_pile(10))\nprint(make_a_pile(11))\n\
    print(make_a_pile(12))\nprint(make_a_pile(13))\nprint(make_a_pile(14))\nprint(make_a_pile(15))\n\
    print(make_a_pile(16))\nprint(make_a_pile(17))\nprint(make_a_pile(18))\nprint(make_a_pile(19))\n\
    print(make_a_pile(20))\nprint(make_a_pile(21))\nprint(make_a_pile(22))\nprint(make_a_pile(23))\n\
    print(make_a_pile(24))\nprint(make_a_pile(25))\nprint(make_a_pile(26))\nprint(make_a_pile(27))\n\
    print(make_a_pile(28))\nprint(make_a_pile(29))\nprint(make_a_pile(30))\nprint(make_a_pile(31))\n\
    print(make_a_pile(32))\nprint(make_a_pile(33))\nprint(make_a_pile(34))\nprint(make_a_pile(35))\n\
    print(make_a_pile(36))\nprint(make_a_pile(37))\nprint(make_a_pile(38))\nprint(make_a_pile(39))\n\
    print(make_a_pile(40))\nprint(make_a_pile(41))\nprint(make_a_pile(42))\nprint(make_a_pile(43))\n\
    print(make_a_pile(44))\nprint(make_a_pile(45))\nprint(make_a_pile(46))\nprint(make_a_pile(47))\n\
    print(make_a_pile(48))\nprint(make_a_pile(49))\nprint(make_a_pile(50))\nprint(make_a_pile(51))\n\
    print(make_a_pile(52))\nprint(make_a_pile(53", "  local table = {}\n  for i =\
    \ 1, n do table[i] = i end\n  return table\nend", "  local p = {} -- A pile of\
    \ n levels has n+1 elements\n  -- Add the top level:\n  table.insert(p, 1)\n \
    \ -- Add levels as needed:\n  for k = 2, #p do\n    table.insert(p, table.floor((math.floor(n/k)\
    \ + 1)*k))\n  end\n  return p\nend", "  if n < 1 then return nil end\n  local\
    \ pile = {}\n  for i = 1, n do\n    if n % 2 == 0 then\n      pile[i] = n\n  \
    \    n = n / 2\n    else\n      pile[i] = n + 1 - (n / 2)\n      n = n / 2\n \
    \   end\n  end\n  return pile\nend", "  if n <= 1 then return {n} end\n  if n\
    \ mod 2 ~= 0 then\n    return make_a_pile(n/2) .. {n} .. make_a_pile(n/2) -- n\
    \ is even\n  else\n    return make_a_pile(n/2) .. {n} .. make_a_pile(n-1)\n  end\n\
    end", "  -- Base case.\n  if n < 1 then return {} end\n  -- If n is even, just\
    \ count the odd numbers.\n  if n % 2 == 0 then return {n} end\n  -- Otherwise,\
    \ if n is odd, count the numbers between the next even and the\n  -- next odd\
    \ number.\n  local result = make_a_pile(n-1) + make_a_pile(n-1)\n  local count\
    \ = 0\n  for i = 2, (n - 1) + 1, 2 do\n    if i % 2 == 1 then count = count +\
    \ 1 end\n  end\n  return result\nend", "  -- Base case.\n  if n < 2 then return\
    \ {} end\n  -- For odd n we add odd-number stones.\n  if n % 2 == 0 then\n   \
    \ local pile = {}\n    for i=1,n do\n      pile[i] = i\n    end\n    -- For even\
    \ n we add even-number stones.\n  else\n    local pile = {n = n}\n    -- For odd-n\
    \ we add odd-number stones and we add that many even-number\n    -- stones.\n\
    \    for i=1,n/2+1 do\n      pile[i] = i * 2 + 1\n    end\n  end\n  return pile\n\
    end", "    local p = {}\n    local odds = n\n    for i = 1, n do\n        if i\
    \ ~= 1 then\n            odds = math.floor((odds + 1) / 2)\n        end\n    \
    \    p[i] = odds\n    end\n    return p\nend", "    if n == 0 then\n        return\
    \ {}\n    end", "  local pile = {}\n  for _ = 1, n do\n    table.insert(pile,\
    \ math.floor((math.floor(n/2) + 1)::int))\n    n, n = math.modf(n)\n  end\n  return\
    \ pile\nend", "\tlocal pile = {}\n\tlocal even, odd = false, false\n\tif n%2 ~=\
    \ 0 then\n\t\teven = true\n\t\tn = n/2\n\tend\n\tfor i=1,n do\n\t\tif even then\n\
    \t\t\tpile[i] = n\n\t\t\teven = false\n\t\telse\n\t\t\tpile[i] = n - odd\n\t\t\
    \todd = true\n\t\tend\n\tend\n\treturn pile\nend\nmake_a_pile(7)", "  local function\
    \ odd(x)\n    if x % 2 ~= 0 then\n      return x\n    else\n      return x + 1\n\
    \    end\n  end", "  if n == 1 then\n    return {n}\n  elseif n % 2 == 1 then\n\
    \    return {n % 2 + 1}\n  else\n    return {n % 2 + 1}\n  end\nend\nprint(make_a_pile(2))",
  "    local pile = {}\n    local i = 0\n    for i = 1, n do\n        if i%2 == 1\
    \ then\n            pile[i] = n\n        else\n            pile[i] = n-1\n   \
    \     end\n    end\n    return pile\nend\nmake_a_pile = make_a_pile", "    local\
    \ pile = {}\n    local index = 1\n    for i = 1, n do\n        if math.mod(n,\
    \ 2) == 1 then\n            pile[index] = i\n            index = index + 1\n \
    \       else\n            pile[index] = (i + 1) * (i-1)/2\n            index =\
    \ index + 1\n        end\n    end\n    return pile\nend", "  if n == 0 then return\
    \ {} end\n  local pile = make_a_pile(n-1)\n  pile[#pile+1] = n % 2\n  return pile\n\
    end", "    local results = {}\n    local odd = n % 2\n    local even = n / 2",
  "  if n == 0 then return {} end\n  if n % 2 == 0 then\n    return make_a_pile(n\
    \ / 2):insert(n % 2 + 1, make_a_pile(n - n % 2 + 1))\n  else\n    return make_a_pile(n\
    \ / 2):insert(n % 2 + 1, make_a_pile(n - n % 2 + 1):insert(n % 2 + 1, make_a_pile(n\
    \ - n % 2 + 2)))\n  end\nend", "  if n==0 then\n    return {}\n  elseif n==1 then\n\
    \    return {n}\n  else\n    local r = make_a_pile(n-1)\n    return setmetatable({},\
    \ { __index = function(t, k)\n      if t[k] then\n        return t[k] + r[k]\n\
    \      else\n        return r[k]\n      end\n    } })\n  end\nend", "  local pile\
    \ = {}\n  for i = 1, n do pile[i] = n end\n  if n % 2 == 1 then\n    for i = n,\
    \ 1, -1 do\n      pile[i] = math.floor(i/2)\n    end\n  end\n  return pile\nend",
  "   if n <= 1 then return {n} end\n   local first_level = make_a_pile(n/2) + {math.floor(n/2)}\n\
    \   local next_level = make_a_pile(n-math.floor(n/2)) + {math.floor(n/2)}\n  \
    \ return first_level + next_level\nend", "    local levels = { n }\n    local\
    \ next_levels = { n % 2 }", "  local npile = {}\n  if n == 2 then return npile\
    \ end\n  if n % 2 == 0 then\n    npile[1] = n\n    make_a_pile(n-2)\n    npile[2]\
    \ = npile[1] -- move to next level\n    make_a_pile(n/2)\n    npile[1] = npile[2]\
    \ -- move to next level\n  else\n    npile[1] = n\n    make_a_pile(n-2)\n    npile[2]\
    \ = npile[1]\n  end\n  return npile\nend\n</cell>\n<cell>", "  if n == 0 then\n\
    \    return {}\n  elseif n <= 0 then\n    return nil\n  else\n    local pile =\
    \ make_a_pile(n/2) + {n % 2 == 0}\n    return pile\n  end\nend", "    local pile\
    \ = {}\n    for i = 1, n do\n        if i%2 then\n            pile[i] = n+1\n\
    \        else\n            pile[i] = n\n        end\n    end\n    return pile\n\
    end", "  -- Base case\n  if n < 2 then\n    return {}\n  -- Recursive case\n \
    \ else\n    local odd, even = n % 2 == 0, n % 2 == 1\n    local a = make_a_pile(n\
    \ / 2)\n    local b = make_a_pile((n - odd) / 2) or a\n    local c = make_a_pile((n\
    \ - even) / 2) or b\n    if even then\n      a[#a+1] = #a + 1\n      b[#b+1] =\
    \ #b + 1\n      c[#c+1] = #c + 1\n    end\n    return a\n  end\nend", "   if n%2\
    \ == 0 then\n      return {}\n   else\n      return {(n-1)/2}\n   end\nend\nprint(make_a_pile(3))",
  "  -- We are looking for the last odd number after n is odd. We can find it by\n\
    \  -- repeatedly taking an odd number starting from n and counting the number\n\
    \  -- of times an even number starts before n divides by 2.\n  -- This can be\
    \ done using arithmetic progressions:\n  -- n + 2 * (n - 1) / 2 = n + 2(n - 1)\
    \ / 2 = n * (n + 1) // 2.\n  --\n  -- We can use that to calculate the number\
    \ of elements in the last level:\n  return math.ceil(n * (n + 1) // 2)\nend",
  "  if n==1 then\n    return {}\n  end\n  local n2 = n / 2\n  if n mod 2 == 0 then\n\
    \    return make_a_pile(n2) + make_a_pile(n2 + 1)\n  else\n    return make_a_pile(n2)\
    \ + (n2 - 1) * 2\n  end\nend", "  local table = {}\n  for i = 1, n do\n    if\
    \ i % 2 == 0 then\n      table.insert(table, i)\n    else\n      table.insert(table,\
    \ 2 * i)\n    end\n  end\n  return table\nend", "   -- Base case: an empty pile.\n\
    \   if n == 0 then\n      return {}\n   else\n      -- If n is odd, next odd number\
    \ is the last odd number.\n      -- If n is even, next even number is the last\
    \ even number.\n      local nextOdd\n      local nextEven\n      if n and n ~=\
    \ 0 then\n         if n % 2 == 1 then\n            nextEven = n / 2\n        \
    \    nextOdd = n % 2\n         else\n            nextOdd = n / 2\n           \
    \ nextEven = (n - nextOdd) / 2\n         end\n      end\n      -- Build the table.\n\
    \      local pile = {}\n      for i in nextOdd, nextEven, n + 1 do\n         table.insert(pile,\
    \ i)\n      end\n      return pile\n   end\nend", "  assert(n > 0, 'make_a_pile:\
    \ n should be positive')\n  assert(n % 2 == 0, 'make_a_pile: n should be odd')\n\
    \  local pile = {}\n  for i = 0, n do\n    pile[i] = i\n  end\n  local evens =\
    \ math.floor(n/2)\n  for i = 1, evens do\n    pile[i] = pile[2*i+1]\n    pile[2*i+1]\
    \ = 0\n  end\n  local odds = n - evens\n  for i = 1, odds do\n    pile[i] = pile[2*i]\n\
    \    pile[2*i] = 0\n  end\n  return pile\nend", "  local p = {}\n  repeat\n  \
    \  p[#p + 1] = n % 2 == 0 and n or n + 2 % 4\n    n = math.floor(n/2)\n  until\
    \ n == 0\n  return p\nend", "  local pile = {}\n  repeat\n    pile[#pile + 1]\
    \ = n % 2 == 0 and n or n + 1;\n    n /= 2;\n  until n ~= 0;\n  return pile\n\
    end", "    local stones = {n}\n    local i = 0\n    repeat\n        stones[i]\
    \ = n % 2 == 0 and (stones[i - 1] + 1) or stones[i - 1]\n        i = math.floor(i/2)\n\
    \    until not i\n    stones = stones[1..end] -- Skip first element, which is\
    \ n\n    return stones\nend\n</cell>\n<code language=julia-1.5>\n@assert make_a_pile(5)\
    \ == {3, 5, 7}\n@assert make_a_pile(6) == {3, 7, 11, 15}\n@assert make_a_pile(7)\
    \ == {3, 7, 11, 15, 23}\n@assert make_a_pile(8) == {3, 7, 11, 15, 23, 37}\n</cell>\n\
    <text>\nExercise 2: Replacing Stones\nYou have a royal pile. The royal pile has\
    \ n stones.\nYou remove one stone from the pile using your remove_stone(n) function.\n\
    The new number of stones in the pile is:", "  if n == 0 then\n    return {}\n\
    \  elseif n == 2 then\n    return {{2, 4}}\n  elseif n == 3 then\n    return {{3,\
    \ 5}, {1, 1}, {1, 2}, {1, 1}, {2, 3}}\n  end\n  local pile = {}\n  for i = 0,\
    \ n-1 do\n    pile[i] = n\n    if math.floor(n/2) == math.floor(n/2) then\n  \
    \    pile[i+1] = math.floor(n/2)\n    else\n      pile[i+1] = math.floor(n/2)+1\n\
    \    end\n  end\n  return pile\nend", "    local result = {}\n    local odd_flag\
    \ = (n % 2)\n    local pile = {}\n    local i = 1\n    while i <= n do\n     \
    \   if odd_flag then\n            pile[i] = n\n            odd_flag = (odd_flag\
    \ and (not (i % 2)))\n        else\n            pile[i] = i * 2\n            odd_flag\
    \ = (odd_flag and (not (i % 2)))\n        end\n        i = i + 1\n    end\n  \
    \  for i = 1, n do\n        result[i] = pile[i]\n    end\n    return result\n\
    end", "  local pile = {}\n  repeat\n    table.insert(pile, n)\n    n, n = math.floor(n/2),\
    \ 2*n\n  until n>0\n  return pile\nend", "  -- Base case: n is 0 or 1.\n  if n\
    \ == 0 or n == 1 then\n    return nil\n  end\n  -- The odd case: n is odd.\n \
    \ if n % 2 == 1 then\n    return make_a_pile(n * 2) + make_a_pile((n + 1) div\
    \ 2)\n  else\n    -- The even case: n is even.\n    return make_a_pile((n + 1)\
    \ div 2) + make_a_pile(n * 2)\n  end\nend\n</cell>\n<cell>", "    if n == 0 then\
    \ return {} end\n    local result = make_a_pile(n - 2)\n    if n % 2 == 1 then\n\
    \        result[#result + 1] = 2\n    else\n        result[#result + 1] = 1\n\
    \    end\n    return result\nend", "  if n == 0 then\n    return {}\n  end", " \
    \ if n == 0 then\n    return {}\n  elseif n == 1 then\n    return {n}\n  else\n\
    \    local pile = {}\n    local next_odd\n    local next_even\n    if n & 1 then\n\
    \      next_odd = 2\n      next_even = n - 2\n    else\n      next_odd = 1\n \
    \     next_even = n - 1\n    end", "  -- The empty pile\n  local pile = {}\n \
    \ -- A helper function which returns a list of levels given an odd number n\n\
    \  local function get_level_list_helper(n)\n    local level_list, level_counter\
    \ = {}, 1\n    for x = 1, n do\n      table.insert(level_list, level_counter)\n\
    \      level_counter = level_counter + 1\n      if n%2 == 0 then level_counter\
    \ = level_counter + 1 end\n    end\n    return level_list\n  end", "    local\
    \ pile = {}\n    local n = n - 1\n    while n > 1 do\n        if math.mod(n, 2)\
    \ == 1 then\n            n = math.ceil(n)\n        else\n            n = math.floor(n)\n\
    \        end\n        table.insert(pile, n)\n    end\n    return pile\nend", " \
    \ -- The function should return an array of n numbers.\n  assert(n >= 0)\n  local\
    \ a = {}\n  if n <= 1 then\n    return a\n  end\n  -- If n is odd, next level\
    \ is odd.\n  if n mod 2 == 1 then\n    table.insert(a, n)\n  else\n    -- If n\
    \ is even, next level is even.\n    local next_odd = (n-1)/2\n    table.insert(a,\
    \ next_odd)\n    if next_odd % 2 == 1 then\n      table.insert(a, next_odd+1)\n\
    \    end\n  end\n  -- Iterate over the array, adding each element to the previous\
    \ level's count.\n  local k = 1\n  for i = 2, #a do\n    table.insert(a, a[k]+a[i])\n\
    \    k = k + 1\n  end\n  return a\nend", "  assert(n >= 1)\n  if n == 1 then\n\
    \    return {1}\n  end\n  local result = {}\n  local count = (n % 2 == 0) or (n\
    \ % 2 == 1)\n  -- If n is odd, then the number of stones in the first level is\
    \ (n+1)/2.\n  -- If n is even, then the number in the first level is n/2.\n  --\
    \ Therefore, the number of stones in the next level is (n-(n%2))/2.\n  result[#result+1]\
    \ = ((n + 1) % 2 == 0) or ((n + 1) % 2 == 1)\n  -- The next level is (n+1)/2 stones.\n\
    \  result[#result+1] = count and ((n + 1) / 2) or n + 1\n  -- Repeat for next\
    \ level and so on.\n  return table.concat(result, \", \")\nend", "\t-- base case\n\
    \tif n < 0 then\n\t\terror('make_a_pile: n should be a postive integer')\n\tend\n\
    \t-- base case\n\tif n == 0 then\n\t\treturn {0, 0, 0, 0, 0, 0, 0}\n\tend", " \
    \ local count = {}\n  for i = 1, n do\n    count[i+1] = i\n    count = count and\
    \ count or {}\n  end\n  return count\nend", "  local next_odd, next_even = 1,\
    \ 2\n  if n > 0 then\n    if n & 1 then\n      next_even = n / 2\n    else\n \
    \     next_odd = n % 2\n    end\n  end\n  return next_odd, next_even\nend", " \
    \   if n == 2 then\n        return {n}\n    end", "    local npile = tonumber(n)\n\
    \    if not npl(npile) then return nile end\n    local table = {}\n    for i =\
    \ 1, npile, 2 do\n        table.insert(table, ((i % 2) * n + i/2) % n)\n    end\n\
    \    return table\nend", "  local table = {}\n  if n <= 0 then return end\n  if\
    \ n == 1 then table.insert(table, n) end\n  if n % 2 == 0 then\n    table.insert(table,\
    \ math.floor(n/2))\n    table.insert(table, math.floor((n+1)/2))\n  else\n   \
    \ table.insert(table, n)\n  end\n  return table\nend", "  if n == 1 then\n   \
    \ return {n}\n  end\n  if n % 2 ~= 0 then\n    return {n*2}\n  else\n    return\
    \ {n*3, n*3+1}\n  end\nend", "  local pile = {}\n  for i = 1, n do\n    if math.mod(i,\
    \ 2) == 0 then\n      table.insert(pile, i)\n    else\n      local next = math.floor(i/2\
    \ + 1)\n      if next > n then next = 0\n      else if next == n then next = i+1\
    \ end\n      table.insert(pile, next)\n    end\n  end\n  return pile\nend", " \
    \ assert(n >= 0, 'n should be positive')\n  local pile = setmetatable({}, { __index\
    \ = {} })\n  assert(n > 0, 'n should be positive')\n  pile[1] = n\n  pile[2] =\
    \ n - 1\n  -- if n is odd, return next odd number\n  if n % 2 == 1 then\n    pile[3]\
    \ = (2 * n) + 3\n  -- if n is even, return next even number\n  else\n    pile[3]\
    \ = (2 * n) + 1\n  end\n  return pile\nend", "  local table = { }\n  local i =\
    \ 1\n  while i <= n do\n    table[i] = (i + 1) % 2 == 0 and n or i\n    i = i\
    \ + 1\n  end\n  return table\nend", "  assert(n >= 0, \"make_a_pile requires a\
    \ non-negative integer\")\n  if n <= 1 then return { [1] = n } end\n  if n % 2\
    \ == 0 then\n    local result = make_a_pile(n/2)\n    for i = 2, n do\n      result[math.floor(n/2)\
    \ + 1] = result[i] + 1\n    end\n    return result\n  else\n    local result =\
    \ {[n/2]}\n    for i = 2, math.floor(n/2) do\n      result[i] = result[i] + 1\n\
    \    end\n    return result\n  end\nend", "  if n <= 1 then return {n} end\n \
    \ if n%2 == 0 then\n    local p = {}\n    local i = 1\n    while i <= n do\n \
    \     p[i] = n / i\n      i = 2 * i\n    end\n    return p\n  else\n    local\
    \ p = {}\n    local i = 3\n    while i <= n do\n      p[i] = n / i\n      i =\
    \ i * 2\n    end\n    return p\n  end\nend", "    local pile = {}\n    for i =\
    \ 1, n do\n        if n % 2 == 1 then\n            table.insert(pile, n)\n   \
    \     else\n            table.insert(pile, n - math.floor(n/2))\n        end\n\
    \        n = math.floor(n/2)\n    end\n    return pile\nend", "  -- Base case\n\
    \  if n == 1 then return {n} end\n  -- Recursive case\n  local next = (math.floor(n/2)\
    \ + math.floor(n/2))/2\n  local pile = {n -1}\n  for i = 1, n do pile[i] = pile[i-1]\
    \ + next end\n  return pile\nend\nprint(make_a_pile(4))\nprint(make_a_pile(5))\n\
    print(make_a_pile(6))", "    local pile = {}\n    for i = 1, n do\n        pile[i]\
    \ = (i + 1) & 1\n    end\n    return pile\nend", "  if n == 2 then\n    return\
    \ {3}\n  elseif n == 3 then\n    return {4, 6, 8}\n  elseif n < 3 then\n    return\
    \ {n}\n  else\n    local odd, even\n    odd = n / 2\n    even = n % 2\n    local\
    \ p1, p2, p3\n    p1, p2  = make_a_pile(odd), make_a_pile(even)\n    return p1\
    \ + p2 + {p2}\n  end\nend", "   if n >= 4 then\n      local n = n - 4\n      return\
    \ make_a_pile(n) + make_a_pile(n) + make_a_pile(n) + make_a_pile(n)\n   elseif\
    \ n >= 2 then\n      local n = n - 2\n      return make_a_pile(n) + make_a_pile(n)\
    \ + make_a_pile(n)\n   else\n      local n = 1\n      return n\n   end\nend",
  "  assert(n >= 1)\n  local pile = {}\n  if n % 2 == 1 then\n    pile[#pile+1] =\
    \ n\n  else\n    for i = 1, n do\n      pile[#pile+1] = math.floor((i+1)/2) +\
    \ math.floor(i/2) % 2\n    end\n  end\n  return pile\nend", "    local pile =\
    \ {}\n    local count = tonumber(n)\n    if n % 2 == 1 then\n        pile[1] =\
    \ 1\n    else\n        count = 1\n    end\n    for i = 1, (n - 1) / 2 do\n   \
    \     count = count + 1\n        if i % 2 == 1 then\n            count = count\
    \ + 1\n        end\n    end\n    for i = 1, (n - 1) / 2 do\n        pile[i] =\
    \ pile[i] + count\n    end\n    return pile\nend", "  if n == 1 then\n    return\
    \ [1]\n  else\n    local count\n    if n % 2 == 0 then\n      count = make_a_pile(n-1)\n\
    \      count = count * 2 + 1\n    else\n      count = make_a_pile(n-1)\n     \
    \ count = count + 2\n    end\n    return count\n  end\nend", "  local pile = {}\n\
    \  for i = 1, n do -- make n levels\n    if math.modf(i)[1] ~= 0 then -- odd\n\
    \      table.insert(pile, i)\n      table.insert(pile, i+1)\n    else\n      table.insert(pile,\
    \ i)\n    end\n  end\n  return pile\nend", "  -- Base case.\n  if n < 1 then\n\
    \    return {}\n  end\n  -- Create a table to store the result.\n  local pile\
    \ = {}\n  -- The first level is n stones.\n  pile[1] = n\n  -- The next level\
    \ is n + (n-1)/2, and so on.\n  for i = 2, n do\n    pile[i] = pile[i - 1] + i\
    \ / 2\n  end\n  return pile\nend", "  local pile = {}\n  for i = 1, n, 2 do\n\
    \    pile[i] = (i + 1) * ((i + 1) % 2 > 0 and i + 1 or i)\n  end\n  return pile\n\
    end", "    local pile = {}\n    local i = 1\n    while i <= n do\n        table.insert(pile,\
    \ n + i - 1)\n        if math.fmod(n, 2) == 0 then\n            i = i + 1\n  \
    \      else\n            i = i + 2\n        end\n    end\n    return pile\nend",
  "    local pile = {}\n    for i = 1, n do\n        if n%2 == 0 then\n          \
    \  table.insert(pile, (i+1)/2)\n        else\n            table.insert(pile, (i+3)/2)\n\
    \        end\n    end\n    return pile\nend", "  local p = {}\n  for i = 1, n\
    \ do\n    if i % 2 == 1 then\n      p[i + 1] = i - 1\n    else\n      p[i + 1]\
    \ = i + 1 - (n / 2)\n    end\n  end\n  return p\nend", "  -- If the number is\
    \ odd, just add one to the answer.\n  if n%2 == 1 then\n    return n+1\n  -- If\
    \ the number is even, first add one to the answer\n  else\n    -- If the number\
    \ is even, add one to the odd number\n    return make_a_pile(n-1)+1\n  end\nend",
  "  local pile = {}\n  if n == 2 then\n    pile[1] = 3\n    pile[2] = 5\n    pile[3]\
    \ = 7\n  elseif n%2 == 0 then\n    local even = make_a_pile(n/2)\n    pile[1]\
    \ = even + n/2\n    pile[2] = n/2\n    pile[3] = even\n  else\n    local odd =\
    \ make_a_pile(n-1)\n    pile[1] = odd + 1\n    pile[2] = n/2\n    pile[3] = odd\n\
    \  end\n  return pile\nend", "  local pile = {}\n  if n%2==0 then\n    local num\
    \ = math.floor(n/2)\n    for i=1,num do\n      pile[i] = num\n    end\n  end\n\
    \  if n%2~=0 then\n    local num = math.floor(n/2)\n    local next = math.ceil(n/2)\n\
    \    for i=1,num do\n      pile[i] = pile[next]\n      next = next + 1\n    end\n\
    \  end\n  return pile\nend", "    local pile = {}\n    local odd = 0\n    local\
    \ even = 1\n    for i = 1, n do\n        local level = n / i\n        local rest\
    \ = n % i\n        if rest == 0 then\n            pile[level] = pile[level] or\
    \ even or odd\n        else\n            pile[level] = pile[level] or odd\n  \
    \      end\n        odd = odd + 1\n        even = even + 2\n    end\n    return\
    \ pile\nend", "  local t = {}\n  for i = 1, n do\n    if i%2 then table.insert(t,1)\
    \ else table.insert(t,i+1) end\n  end\n  return t\nend", "  if n == 0 then\n \
    \   return nil\n  elseif n % 2 == 0 then\n    return make_a_pile(n / 2)\n  else\n\
    \    return make_a_pile((3 * n) + 1)\n  end\nend", "\tlocal p = {}\n\tlocal odd\
    \ = 0\n\tlocal even = 0\n\tlocal count = 0\n\tif n % 2 == 1 then\n\t\tcount =\
    \ n\n\telse\n\t\tcount = math.floor(n/2)\n\tend\n\tfor i = 1, count do\n\t\tif\
    \ n % 2 == 0 then\n\t\t\tp.even = even\n\t\t\teven = even + 2\n\t\telse\n\t\t\t\
    p.odd = odd\n\t\t\todd = odd + 2\n\t\tend\n\tend\n\treturn p\nend", "  if n==0\
    \ then\n    return {}\n  else\n    local a = make_a_pile(n-1)\n    if n%2 then\
    \ table.insert(a, n) end\n    return a\n  end\nend", "  local next_even, next_odd\
    \ = 2, 3\n  local pile = {}\n  if n == 0 then\n    return pile\n  elseif n % 2\
    \ == 0 then\n    return make_a_pile(n / 2) * next_even\n  else\n    return make_a_pile(n\
    \ / 2) * next_odd\n  end\nend", "    local pile = {}\n    local index = 1\n  \
    \  for i = 1, n do\n        if i%2 == 0 then\n            index = index * 2 +\
    \ 1\n        else\n            index = index * 2 + 2\n        end\n        pile[index]\
    \ = pile[index] + 1\n    end\n    return pile\nend", "  local pile = {}\n  for\
    \ i = 1, n do\n    if n and ((n % 2) ~= 0) then\n      pile[#pile+1] = i\n   \
    \   n = math.floor(n/2)\n    else\n      pile[#pile+1] = i\n    end\n  end\n \
    \ return pile\nend", "  if n == 0 then\n    return {}\n  elseif n == 1 then\n\
    \    local stones = {}\n    for i = 1, n do\n      table.insert(stones, i)\n \
    \   end\n    return stones\n  else\n    local max_odd, max_even, current_level\n\
    \    current_level = make_a_pile(n / 2)\n    max_odd, max_even = n, n\n    while\
    \ max_odd > 0 and max_even > 0 do\n      if max_odd % 2 == 0 then\n        max_even\
    \ = max_even / 2\n      else\n        max_odd = max_odd / 2\n      end\n     \
    \ table.insert(current_level, 0)\n    end\n    return current_level\n  end\nend",
  "  local p = {}\n  if n == 1 then\n    return {{n}}\n  elseif n % 2 == 0 then\n\
    \    table.insert(p, make_a_pile(n/2))\n    table.insert(p, make_a_pile(n/2 +\
    \ 1))\n  else\n    table.insert(p, make_a_pile(n/2))\n  end\n  return p\nend",
  "  -- Return table\n  local pile = {}\n  local index = 1\n  local count = 1\n  --\
    \ Loop until we've reached the desired level\n  while index + 1 <= n do\n    --\
    \ If n is odd, add an odd number\n    if n % 2 ~= 0 then\n      pile[index + 1]\
    \ = count + 1\n      count = count + 1\n    -- If n is even, add an even number\n\
    \    else\n      pile[index + 1] = count * 2\n      count = count * 2\n    end\n\
    \    -- Increment the index\n    index = index + 1\n  end\n  return pile\nend",
  "    local pile = {}\n    local i = 1\n    local count = 0\n    while i <= n do\n\
    \        if i % 2 == 1 then\n            count = count + 1\n        end\n    \
    \    pile[i] = count\n        i = i + 1\n    end\n    return pile\nend\nmake_a_pile(1)\n\
    make_a_pile(2)\nmake_a_pile(4)\nmake_a_pile(5)\nmake_a_pile(6)\nmake_a_pile(8)\n\
    make_a_pile(10)\nmake_a_pile(13)\nmake_a_pile(16)\nmake_a_pile(20)\nmake_a_pile(25)\n\
    make_a_pile(29)\nmake_a_pile(33)\nmake_a_pile(38)\nmake_a_pile(42)\nmake_a_pile(47)\n\
    make_a_pile(53)\nmake_a_pile(58)\nmake_a_pile(63)\nmake_a_pile(68)\nmake_a_pile(72)\n\
    make_a_pile(77)\nmake_a_pile(82)\nmake_a_pile(87)\nmake_a_pile(92)\nmake_a_pile(97)\n\
    make_a_pile(102)\nmake_a_pile(108)\nmake_a_pile(114)\nmake_a_pile(119)\nmake_a_pile(125)\n\
    make_a_pile(130)\nmake_a_pile(137)\nmake_a_pile(143)\nmake_a_pile(148)\nmake_a_pile(154)\n\
    make_a_pile(159)\nmake_a_pile(165)\nmake_a_pile(170)\nmake_a_pile(177)\nmake_a_pile(183)\n\
    make_a_pile(188)\nmake_a_pile(194)\nmake_a_pile(199)\nmake_a_pile(205)\nmake_a_pile(211)\n\
    make_a_pile(217)\nmake_a_pile(223)\nmake_a_pile(227)\nmake_a_pile(233)\nmake_a_pile(238)\n\
    make_a_pile(244)\nmake_a_pile(249)\nmake_a_pile(255)\nmake_a_pile(261)\nmake_a_pile(267)\n\
    make_a_pile(273)\nmake_a_pile(278)\nmake_a_pile(284)\nmake_a_pile(289)\nmake_a_pile(295)\n\
    make_a_pile(301)\nmake_a_pile(307)\nmake_a_pile(313)\nmake_a_pile(318)\nmake_a_pile(324)\n\
    make_a_pile(329)\nmake_a_pile(335)", "  -- If n is even, then return 2n+1 numbers.\n\
    \  -- If n is odd, then return 2n+1 numbers.\n  return math.mod(n, 2) == 0 and\
    \ {n + 1, 1, 2} or {n, 1, math.floor(n/2)}\nend", "  if n==0 then\n    return\
    \ {}\n  else\n    local even, odd = 0, 0\n    local pile = {}\n    for i=1,n do\n\
    \      if i%2==0 then\n        even = even+i\n      else\n        odd = odd+i\n\
    \      end\n    end\n    pile[1] = even+odd\n    for i=2,n do\n      local count\
    \ = 1\n      if i%2==0 then\n        count = even+odd\n      else\n        count\
    \ = odd+even\n      end\n      pile[i] = count\n    end\n    return pile\n  end\n\
    end", "    local pile = {}\n    local n1 = math.floor(n/2)\n    if n1~=n then\n\
    \        pile[1] = n1\n    end\n    for i = 2, n do\n        local n2 = (n-i)\
    \ % 2\n        if n2 ~= 0 then\n            pile[i+1] = n1 + n2\n        end\n\
    \        n1 = n2\n    end\n    return pile\nend", "  if n == 0 then\n    return\
    \ {}\n  end", "  -- base case\n  if n<1 then return {} end", "  assert(n>0 and\
    \ n%2 == 1, \"n must be positive and odd\")\n  local pile = {}\n  if n == 1 then\n\
    \    pile[1] = n\n    return pile\n  end\n  local next = (n / 2)\n  if next%2\
    \ ~= 0 then\n    next = next - 1\n  end\n  local count = 0\n  local j = 1\n  while\
    \ j <= n do\n    count = count + (next*2 + j)\n    j = j + next\n    next = next\
    \ + next\n  end\n  pile[1] = count\n  return pile\nend", "  assert(n >= 1)\n \
    \ if n == 2 then\n    local table = {n}\n    table[2] = n\n    return table\n\
    \  end\n  local table = {n}\n  local i = 3\n  while i <= (n - 1) do\n    table.insert(table,\
    \ i)\n    i = i + (n / 2)\n  end\n  return table\nend", "  local levels = setmetatable({},\
    \ { __index = setmetatable({}, { __index = null }) })\n  levels[1] = n\n  if n\
    \ ~= 0 then\n    levels[#levels + 1] = (n - 1) / 2 + (n % 2 == 0)\n  end\n  return\
    \ levels\nend", "  local pile = {}\n  local current = 1\n  for i = 1, n do\n \
    \   if n % 2 == 0 then\n      pile[i] = current + 1\n      current = current +\
    \ 1\n    else\n      current = current + 2\n    end\n  end\n  return pile\nend",
  "  local pile = { }\n  for i=1, n do\n    table.insert(pile, i)\n  end\n  pile[math.floor(n/2)]\
    \ = n - (not n%2)\n  return pile\nend", "    local result = {}\n    result[1]\
    \ = 0 -- add 0th element\n    for i = 2, n do\n        if i % 2 == 0 then\n  \
    \          result[i] = result[i/2] + 2\n        else\n            result[i] =\
    \ result[i/2] + 1\n        end\n    end\n    return result\nend", "  if n % 2\
    \ == 1 then\n    return make_a_pile(n / 2) + make_a_pile(n / 2 + 1) + 1\n  else\n\
    \    return make_a_pile(n / 2) + make_a_pile(n / 2) + 1\n  end\nend", "  if n\
    \ <= 1 then\n    return 1\n  elseif n <= 3 then\n    return n + make_a_pile((n-1)\
    \ / 2) * 2\n  else\n    return make_a_pile((n-1) / 2) + make_a_pile((n-1) / 2)\
    \ + make_a_pile((n-1) / 2)\n  end\nend", "  if n == 0 then\n    return {}\n  elseif\
    \ n == 1 then\n    return {1}\n  elseif n%2 == 0 then\n    return make_a_pile(math.floor(n/2))\
    \ + make_a_pile(n-2)\n  else\n    return make_a_pile(n-2) + make_a_pile(n-1)\n\
    \  end\nend", "    local pile = { n=n }\n    for i=1,n do\n        pile[i] = i\n\
    \    end\n    table.sort(pile)\n    return pile\nend", "   if n == 0 then\n  \
    \    return nil\n   end", "  assert(n>0, \"n must be positive\")\n  local pile\
    \ = {}\n  -- If the number of stones is odd, then the next odd number of a pile\
    \ is the\n  -- last odd number plus one.\n  if n%2 ~= 0 then\n    table.insert(pile,\
    \ n - 1)\n  else\n    -- If the number of stones is even, then the next even number\
    \ of a pile is\n    -- the last even number minus one.\n    pile[#pile] = n -\
    \ 1\n  end\n  return pile\nend", "  local pile = {}\n  repeat\n    table.insert(pile,\
    \ n)\n    n = math.floor(n/2) or 1\n  until n < 1\n  return pile\nend", "  if\
    \ n == 2 then return {2, 5}\n  elseif n == 3 then return {3, 7}\n  elseif n <\
    \ 2 then return {n} end", "  if n == 0 then return {} end\n  local pile = {}\n\
    \  for i = 1, n do\n    if i ~= n % 2 then\n      table.insert(pile, math.floor(i))\n\
    \    end\n  end\n  return pile\nend", "  -- Base case\n  if n < 0 then\n    return\
    \ {}\n  end\n  -- Recursive case\n  if n < 2 then\n    return {{n}}\n  else\n\
    \    -- Odd case\n    -- Find next odd number\n    local next_odd = math.ceil(n/2)\n\
    \    -- Return current level plus\n    return {next_odd + 1}\n  end\nend", " \
    \ if n <= 0 then\n    return {}\n  elseif n == 1 then\n    return {n}\n  elseif\
    \ n % 2 == 0 then\n    return make_a_pile(n/2) + make_a_pile((n+1)/2)\n  else\n\
    \    return make_a_pile(n/2) - make_a_pile((n+1)/2)\n  end\nend", "  local pile\
    \ = {}\n  local level = 0\n  while n > 0 do\n    if math.modf(n) == 0 then\n \
    \     level = level + 1\n      pile[level] = n\n    end\n    if math.modf(n) ~=\
    \ 0 then\n      n = math.floor(n/2)\n    end\n  end\n  return pile\nend", "  local\
    \ pile = {}\n  for i = 1, n do\n    if i%2 == 0 then\n      pile[i] = n\n    \
    \  n = n/2\n    else\n      pile[i] = n/2\n      n = n*3\n    end\n  end\n  return\
    \ pile\nend", "  local pile = {}\n  for i = 1, n do\n    if i % 2 == 0 then\n\
    \      table.insert(pile, n / 2)\n    else\n      table.insert(pile, n)\n    end\n\
    \  end\n  return pile\nend", "    local pile = {}\n    local odd, even = 1, 2\n\
    \    local level = 1\n    while level <= n do\n        pile[level] = even\n  \
    \      even = odd * 2\n        odd = even + 1\n        level = level + 1\n   \
    \ end\n    return pile\nend", "    local pile = {}\n    local next_odd, next_even\n\
    \    if n%2 == 0 then\n        next_odd = n+1\n        next_even = n+2\n    else\n\
    \        next_odd = n\n        next_even = n+1\n    end\n    for i = 1, next_even\
    \ do\n        pile[i] = next_odd\n        next_odd = next_odd+2\n    end\n   \
    \ return pile\nend", "  local pile = setmetatable({}, { __index = setmetatable({},\
    \ { __index = setmetatable({}, { __index = function() return setmetatable({},\
    \ { __index = function() return {} end}) end}) }) })\n  pile[1] = n\n  if n %\
    \ 2 == 0 then\n    pile[2] = math.floor(n/2)\n  else\n    pile[2] = math.floor(n/2)\
    \ + 1\n  end\n  for i = 3, #pile, 2 do\n    pile[i] = pile[i-1] + pile[i-2]\n\
    \  end\n  return pile\nend", "  if n == 0 then return {} end\n  if n % 2 == 1\
    \ then n = n * 3 + 1\n  else n = n * 3\n  end -- end if", "  local pile = {}\n\
    \  if n % 2 == 0 then\n    for i = 1, n do\n      table.insert(pile, math.ceil(n/2)*2\
    \ +\n                      math.min(math.floor(n/2), math.ceil(n/2)))\n    end\n\
    \  else\n    table.insert(pile, n)\n  end\n  return pile\nend", "  -- Base case\n\
    \  -- We make 2 levels if n is even\n  if n % 2 == 1 then\n    local pile = {n}\n\
    \    -- Add the next odd number\n    pile:insert(n * 2)\n    -- Add the next even\
    \ number\n    pile:insert(n * 2 + 1)\n    -- Return the complete pile\n    return\
    \ pile\n  -- Else n is odd\n  else\n    local pile = make_a_pile(n / 2)\n    --\
    \ Add the next odd number\n    pile:insert(n * 2 + 1)\n    -- Return the complete\
    \ pile\n    return pile\n  end\nend", "  -- Base case: n equals zero.\n  if n==0\
    \ then return {} end", "  assert(n > 1)\n  assert(n % 2 == 1)\n  local table =\
    \ {}\n  repeat\n    table[n] = n + 1\n    n += math.floor(n/2)\n  until n >= 2\n\
    \  return table\nend", "  -- Write your code here.\n  local pile = {}\n  for i\
    \ = 1, n do\n    if math.mod(n, 2) == 0 then\n      pile[i] = pile[i] + 1\n  \
    \  else\n      pile[i] = pile[i] + 2\n    end\n  end\n  return pile\nend", " \
    \   local stones = tonumber(n) * tonumber(math.floor(n/2))\n    local next_odd\
    \ = tonumber(math.floor((n/2)-1))\n    if n % 2 == 1 then\n        next_even =\
    \  (n/2) + 1\n    else\n        next_even =  (n/2)\n    end\n    return stones,\
    \ next_odd, next_even\nend", "  if n <= 0 then return {} end\n  local pile = {}\n\
    \  local levels = 1\n  repeat\n    pile[levels] = n\n    levels = levels + 1\n\
    \  until n == math.floor((n + 1) / 2)\n  table.insert(pile, levels)\n  table.sort(pile)\n\
    \  return pile\nend", "  if n == 0 then\n    return {}\n  elseif n == 1 then\n\
    \    return {1}\n  elseif n == 2 then\n    return {{3, 5}, {4, 5}, {5, 5}}\n \
    \ elseif n%2 == 1 then\n    return {{n+1, n-1}}\n  else\n    local pile1 = make_a_pile(n-1)\n\
    \    local pile2 = {}\n    for k,v in pairs(pile1) do\n      table.insert(pile2,\
    \ v+1)\n    end\n    return pile2\n  end\nend", "    local pile = n -- initialize\n\
    \    local i\n    for i=1, n do\n        if n%2 == 1 then\n            pile =\
    \ pair(pile, i+1)\n        end\n        n = math.floor(n/2)\n    end\n    return\
    \ pile\nend", "  local pile = {}\n  local n1 = math.ceil(n)\n  if n ~= n1 then\n\
    \    table.insert(pile, #pile, n1)\n  end\n  local remainder = n % 2\n  if remainder\
    \ == 0 then\n    local n2 = math.floor(n/2)\n    table.insert(pile, #pile, n2)\n\
    \  end\n  return pile\nend", "  local pile = {}\n  if n == 1 then\n    pile[1]\
    \ = 1\n    return pile\n  end\n  local odd\n  if n % 2 == 1 then\n    odd = n\n\
    \  else\n    odd = n + 1 -- odd number of next level\n  end\n  local even\n  if\
    \ n % 2 == 0 then\n    even = n\n  else\n    even = n + 1 -- even number of next\
    \ level\n  end\n  for i = odd, even do\n    pile[i] = i\n  end\n  return pile\n\
    end", "   if n==0 then\n      return {n}\n   end\n   if n%2==0 then\n      return\
    \ {n}\n   end\n   local ret={}\n   for i=1,n,2 do\n      table.insert(ret, i)\n\
    \   end\n   return ret\nend", "    local num_pile = {}\n    if n == 2 then\n \
    \       num_pile[1] = n\n    else if n%2 == 0 then\n        num_pile[1] = make_a_pile((n+1)/2)\
    \ -- odd numbers even.\n        num_pile[2] = make_a_pile((n+2)/2) -- even numbers\
    \ odd.\n    else\n        num_pile[1] = make_a_pile((n+1)/2) -- odd number odd.\n\
    \        num_pile[2] = make_a_pile((n+2)/2) -- even number even.\n        num_pile[3]\
    \ = n -- odd number even.\n    end\n    return num_pile\nend", "  local pile =\
    \ {}\n  local index = 1\n  if n%2 == 0 then\n    -- even\n    index = 2\n  else\n\
    \    -- odd\n    index = 2\n  end\n  for i = 1, n do\n    pile[index] = pile[index]\
    \ + 1\n    index = index + 1\n  end\n  return pile\nend", "  if n == 0 then\n\
    \    return {}\n  else\n    local even, odd = (n%2 == 0), true\n    local i\n\
    \    for i = 1, n do -- i\n      if odd then\n        if even == true then\n \
    \         even = false\n        else\n          odd = false\n        end\n   \
    \   else\n        if even == true then\n          even = false\n        else\n\
    \          odd = true\n        end\n      end\n      table.insert(result, i+1)\n\
    \    end\n    return result\n  end\nend", "  local p = {}\n  local i = 2\n  while\
    \ i <= n do\n    table.insert(p, i)\n    i = 2 * i + 1\n  end\n  return p\nend",
  "  if n == 1 then\n    return {n}\n  end", "  -- base case\n  if n == 1 then\n \
    \   return {1}\n  -- odd n\n  elseif n%2 == 0 then\n    local next_odd_n = math.ceil(n\
    \ / 2)\n    local next_even_n = n - next_odd_n\n    local pile = {}\n    for i\
    \ = 1, next_odd_n do\n      pile[(i + 1)%#pile] = n\n    end\n    for i = 1, next_even_n\
    \ do\n      pile[(i + 1)%#pile] = 2 * n\n    end\n    return pile\n  -- even n\n\
    \  else\n    local next_even_n = math.ceil(n / 2)\n    local pile = {}\n    for\
    \ i = 1, next_even_n do\n      pile[(i + 1)%#pile] = 2 * n\n    end\n    return\
    \ pile\n  end\nend\nmake_a_pile(5)\nmake_a_pile(8)", "  assert(n, 'n should be\
    \ positive')\n  assert(n % 2 == 0, 'n should be odd')\n  \n  local pile = {}\n\
    \  for i=1,n,2 do\n    pile[i+1] = i\n  end", "  assert(n > 0)\n  local pile =\
    \ {}\n  for i = 0, n-2 do\n    pile[i] = i + ((i == n-2) and 0 or 1)\n  end\n\
    \  return pile\nend", "\t-- base case\n\tif n == 0 then return {}\n\t-- odd case\n\
    \tif n ~= math.floor(n) then return make_a_pile(math.floor(n)) + make_a_pile(n-math.floor(n))\n\
    \t-- even case\n\treturn make_a_pile(math.floor(n)) + make_a_pile(n-math.floor(n))\n\
    end", "    local count = {}\n    local counts = make_a_pile(n-1)\n    if n % 2\
    \ == 0 then\n        count[1] = (n+1) * counts[1]\n        counts[2] = (n+1) *\
    \ counts[2]\n    else\n        count[1] = n * counts[1]\n        counts[2] = n\
    \ * counts[2]\n    end\n    for i = 3, #counts do\n        count[i] = counts[i-1]\
    \ + counts[i-2]\n    end\n    return count\nend", "  local res = {}\n  if n ==\
    \ 2 then\n    res[1] = n\n    return res\n  end\n  if n <= 0 then\n    return\
    \ res\n  end\n  local odd_p = true\n  if math.floor(n/2) == math.floor(n/2) then\n\
    \    odd_p = false\n  end\n  while n >= 2 do\n    table.insert(res, n % 2)\n \
    \   n = math.floor(n/2)\n    if odd_p then\n      if n % 2 ~= 0 then\n       \
    \ n = n / 2\n      else\n        n = math.ceil(n/2)\n      end\n    end\n  end\n\
    \  return res\nend", "\tlocal pile = {}\n\tfor i = 0, n-1 do\n\t\tpile[i] = (i+2)\
    \ % n + 1\n\tend\n\treturn pile\nend", "  -- Base case\n  if n <= 0 then\n   \
    \ return {0}\n  end", "  if n < 1 then return nil end\n  local pile = {}\n  if\
    \ n % 2 == 0 then\n    for k = 1,(n-1)/2 do\n      pile[k] = pile[k] + n\n   \
    \ end\n  end\n  if n % 2 == 1 then\n    for k = 1,(n-1)/2 do\n      pile[k] =\
    \ pile[k] + n + 1\n    end\n  end\n  return pile\nend", "  local pile = {}\n \
    \ for i = 1, n do\n    pile[i] = i % 2 == 0 and i or i - 1\n  end\n  return pile\n\
    end", "  local pile = {}\n  if n == 2 then\n    pile[1] = 1\n  elseif n % 2 ==\
    \ 0 then\n    pile[1] = make_a_pile(n-1) + 1 -- add 1 as next odd number\n   \
    \ pile[2] = make_a_pile(n/2) -- divide by 2 to get even number\n  else\n    pile[1]\
    \ = make_a_pile(n/2) + 1 -- add 1 as next even number\n  end\n  return pile\n\
    end", "  if n <= 1 then\n    return {}\n  end\n  local count = 1\n  if n % 2 ==\
    \ 1 then\n    count = count + 2\n  end\n  if n % 3 == 1 then\n    count = count\
    \ + 3\n  end\n  return { [count] = n }\nend", "  -- Your code here\n  \n  -- This\
    \ would be a good place to use an array\n  -- local pile = {}\n  \n  -- Start\
    \ looping through the pile array\n  for i = 1, n do\n    if i % 2 == 0 then\n\
    \      pile[i] = i+1\n    else\n      pile[i] = math.floor(i/2)\n    end\n  end\n\
    \  \n  return pile\nend\n</cell>\n<code language=ocaml-jupyter>\n# %load \"../testing/test.ml\"\
    \nopen MyTests\n</cell>\n<code language=ocaml-jupyter>\nlet _ = assert (make_a_pile(3)\
    \ == {3, 5, 7})\n</cell>\n<code language=ocaml-jupyter>\nlet _ = assert (make_a_pile(4)\
    \ == {3, 7, 9, 11})\n</cell>\n<code language=ocaml-jupyter>\nlet _ = assert (make_a_pile(10)\
    \ == {3, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43})\n</cell>\n<code language=ocaml-jupyter>\n\
    let _ = assert (make_a_pile(11) == {3, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53})\n</cell>\n<code language=ocaml-jupyter>\nlet _ = assert (make_a_pile(15)\
    \ == {3, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 65, 71})\n</cell>\n\
    <code language=ocaml-jupyter>\nlet _ = assert (make_a_pile(16) == {3, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 65, 71, 73, 79, 83, 89, 97, 101,\
    \ 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181,\
    \ 191, 193, 197, 199})\n</cell>\n<code language=ocaml-jupyter>\nlet _ = assert\
    \ (make_a_pile(17) == {3, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 65, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149,\
    \ 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227})\n</cell>\n\
    <code language=ocaml-jupyter>\nlet _ = assert (make_a_pile(20) == {3, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 65, 7", "  local pile = {}\n  for\
    \ i=1, n do \n    table.insert(pile, math.random(math.floor(i/2), math.floor(i/2)))\n\
    \  end\n  return pile\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
