name: HumanEval_132_is_nested
language: lua
prompt: "-- Create a function that takes a string as input which contains only square\
  \ brackets.\n-- The function should return true if and only if there is a valid\
  \ subsequence of brackets \n-- where at least one bracket in the subsequence is\
  \ nested.\n-- >>> is_nested('[[]]')\n-- true\n-- >>> is_nested('[]]]]]]][[[[[]')\n\
  -- false\n-- >>> is_nested('[][]')\n-- false\n-- >>> is_nested('[]')\n-- false\n\
  -- >>> is_nested('[[][]]')\n-- true\n-- >>> is_nested('[[]][[')\n-- true\nlocal\
  \ function is_nested(string)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_nested\n\
  \    lu.assertEquals(candidate('[[]]'), true)\n    lu.assertEquals(candidate('[]]]]]]][[[[[]'),\
  \ false)\n    lu.assertEquals(candidate('[][]'), false)\n    lu.assertEquals(candidate('[]'),\
  \ false)\n    lu.assertEquals(candidate('[[[[]]]]'), true)\n    lu.assertEquals(candidate('[]]]]]]]]]]'),\
  \ false)\n    lu.assertEquals(candidate('[][][[]]'), true)\n    lu.assertEquals(candidate('[[]'),\
  \ false)\n    lu.assertEquals(candidate('[]]'), false)\n    lu.assertEquals(candidate('[[]][['),\
  \ true)\n    lu.assertEquals(candidate('[[][]]'), true)\n    lu.assertEquals(candidate(''),\
  \ false)\n    lu.assertEquals(candidate('[[[[[[[['), false)\n    lu.assertEquals(candidate(']]]]]]]]'),\
  \ false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tassert(string.find('[]') ~= nil)\n\tassert(string.find('[[]') ~=\
    \ nil)\n\tassert(string.find('[[[]') ~= nil)\n\treturn string.find('[]]') ~= nil\n\
    end", "  if string:find('[%[%]%]') then\n    return true\n  else\n    return false\n\
    \  end\nend", "    local i = 1, #string\n    while i < #string do\n        if\
    \ string[i] == '[' then\n            if string[i - 1] == ']' then\n          \
    \      i = i + 2\n            elseif string[i + 1] == ']' then\n             \
    \   i = i + 1\n            else\n                return false\n            end\n\
    \        elseif string[i] == ']' then\n            if string[i - 1] == '[' then\n\
    \                i = i + 2\n            elseif string[i + 1] == '[' then\n   \
    \             i = i + 1\n            else\n                return false\n    \
    \        end\n        else\n            return false\n        end\n    end\n \
    \   return true\nend", "\tlocal bracket_stack = { } -- Stack of found brackets\n\
    \tlocal open_brackets = 0 -- Number of open brackets\n\tlocal depth = 0\n\tfor\
    \ i = 1, #string do\n\t\tlocal character = string.sub(i, i)\n\t\t\n\t\tif character\
    \ == '[' then\n\t\t\tif open_brackets == 0 then\n\t\t\t\tdepth = depth + 1\n\t\
    \t\telse\n\t\t\t\topen_brackets = open_brackets - 1\n\t\t\tend\n\t\telseif character\
    \ == ']' then\n\t\t\tif open_brackets > 0 then\n\t\t\t\topen_brackets = open_brackets\
    \ - 1\n\t\t\telse\n\t\t\t\tdepth = depth - 1\n\t\t\tend\n\t\telseif open_brackets\
    \ > 0 then\n\t\t\topen_brackets = open_brackets + 1\n\t\telse\n\t\t\treturn false\n\
    \t\tend\n\t\t\n\t\tif open_brackets == depth then\n\t\t\ttable.insert(bracket_stack,\
    \ character)\n\t\tend\n\tend\n\t\n\tif #bracket_stack == 0 then\n\t\treturn true\n\
    \telse\n\t\treturn false\n\tend\nend", "   local open_bracket = string.sub( string,\
    \ '[', '[#' )\n   local close_bracket = string.sub( string, '#', '[#' )\n   \n\
    \   for i = 1, string.len(open_bracket) do\n      local open_bracket = string.sub(\
    \ open_bracket, i, i )\n      local close_bracket = string.sub( close_bracket,\
    \ i, i )\n      \n      if open_bracket ~= close_bracket then\n         return\
    \ false\n      end\n   end\n   \n   return true\nend", "\t-- Check if the string\
    \ is empty or nil\n\t-- If the string is empty or nil, we return true\n\tif string\
    \ == nil or string == \"\" then\n\t\treturn true\n\tend\n\t-- If the string is\
    \ valid\n\tif string.find(string, \"[\") == nil or string.find(string, \"]\")\
    \ == nil then\n\t\treturn false\n\tend\n\t-- Go through each character in string\
    \ and count the number of \n\t-- opening and closing brackets\n\tlocal bracket_count\
    \ = 1\n\tfor i = 1, string.len(string) do\n\t\tif string.find(string, \"[\", i)\
    \ > 0 then\n\t\t\tbracket_count = bracket_count + 1\n\t\telseif string.find(string,\
    \ \"]\", i) > 0 then\n\t\t\tbracket_count = bracket_count - 1\n\t\tend\n\tend\n\
    \tif bracket_count == 0 then\n\t\treturn true\n\telse\n\t\treturn false\n\tend\n\
    end", "    if string == nil then return end\n    if string:match('^%[(%.-)]*$')\
    \ == nil then return false end\n    local has_nested = false\n    for i = 0, #string\
    \ do\n        local c = string:sub(i, i)\n        if c == '[' then\n         \
    \   has_nested = has_nested or is_nested(string:sub(i+1, i+2))\n        elseif\
    \ c == ']' then\n            has_nested = has_nested and not is_nested(string:sub(i+1,\
    \ i+1))\n        end\n    end\n    return has_nested\nend", "\tlocal index = #string\n\
    \tlocal nestedBrackets = 0\n\twhile index >= 1 do\n\t\tif string[index] ~= '['\
    \ then\n\t\t\tnestedBrackets = 0\n\t\telse\n\t\t\tnestedBrackets = nestedBrackets\
    \ + 1\n\t\t\tif nestedBrackets > 1 then\n\t\t\t\treturn false\n\t\t\tend\n\t\t\
    end\n\t\tindex = index - 1\n\tend\n\treturn true\nend", "\t-- Write your code\
    \ here\n\tlocal start, finish = 1, string\n\twhile start <= finish do\n\t\tlocal\
    \ start_pos = stringfind(string, start, string.sub(string,start+1,start+2), true)\n\
    \t\tif start_pos then\n\t\t\tlocal finish_pos = stringfind(string, ']', string.sub(string,start+1,start+start_pos-1),\
    \ true)\n\t\t\tif finish_pos then\n\t\t\t\tstart = start_pos+1 \n\t\t\telse\n\t\
    \t\t\treturn false\n\t\t\tend\n\t\telse\n\t\t\treturn false\n\t\tend\n\tend\n\t\
    return true\nend", "\tif string == nil then\n\t\treturn false\n\tend\n\tlocal\
    \ opening_count = 1\n\tlocal closing_bracket_count = 1\n\tlocal is_nested = false\n\
    \tlocal i = 1\n\twhile i < #string do\n\t\tif string[i] == '[' then\n\t\t\topening_count\
    \ = opening_count + 1\n\t\telseif string[i] == ']' then\n\t\t\topening_count =\
    \ opening_count - 1\n\t\t\tif opening_count == 0 then\n\t\t\t\tis_nested = is_nested\
    \ and true\n\t\t\telseif opening_count > 0 then\n\t\t\t\tclosing_bracket_count\
    \ = closing_bracket_count + 1\n\t\t\tend\n\t\tend\n\t\ti = i + 1\n\tend\n\tif\
    \ opening_count == 0 then\n\t\tis_nested = false\n\tend\n\treturn is_nested and\
    \ closing_bracket_count > 0\nend", '    local open_bracket, close_bracket = 1,
    1', "  return string.match('^%[(%[%)%]$') ~= nil \nend", "\t-- Test for balanced\
    \ brackets\n\t-- Nested brackets are not allowed\n\t-- (e.g. [[[]])\n\tlocal open\
    \ = string.find(\"[\")\n\tlocal close = string.find(\"]\", open + 1)\n\treturn\
    \ (close - open)", "  -- Define the function using the standard pattern matching\
    \ syntax\n  local function is_nested_(...)\n    -- The function should return\
    \ true if and only if there is a valid subsequence of brackets \n    -- where\
    \ at least one bracket in the subsequence is nested.\n    -- >>> is_nested_('[[]]')\n\
    \    -- true\n    -- >>> is_nested_('[]]]]]]][[[[[]')\n    -- false\n    -- >>>\
    \ is_nested_('[][]')\n    -- false\n    -- >>> is_nested_('[]')\n    -- false\n\
    \    -- >>> is_nested_('[[][]]')\n    -- true\n    -- >>> is_nested_('[[]][[')\n\
    \    -- true\n    local open_brackets, close_brackets = string\n      :gmatch('%[[]')\n\
    \      :gsub('[[]]', '')\n      :gsub('[[]]', '%s+') -- Slurp unnecessary white\
    \ space.\n      :gsub('[[]]', '%s+')\n      :gsub('[[]]', '%s+')\n      :gsub('[[]]',\
    \ '%s+')\n      :gsub('[[]]', '%s+')\n      :gsub('[[]]', '%s+')\n      :gsub('[[]]',\
    \ '%s+')\n      :gsub('[[]]', '%s+')\n      :gsub('[[]]', '%s+')\n      :gsub('[[]]',\
    \ '%s+')\n      :gsub('[[]]', '%s+')\n      :gsub('[[]]', '%s+')\n      :gsub('[[]]',\
    \ '%s+')\n      :gsub('[[]]', '%s+')\n      :gsub('[[]]', '%s+')\n      :gsub('[[]]',\
    \ '%s+')\n      :gsub('[[]]', '%s+')\n      :gsub('[[]]', '%s+')\n      :gsub('[[]]',\
    \ '%s+')\n      :gsub('[[]]', '%s+')\n      :gsub('[[]]', '%s+')\n      :gsub('[[]]',\
    \ '%s+')\n      :gsub('[[]]', '%s+')\n      :gsub('[[]]', '%s+')\n      :gsub('[[]]',\
    \ '%s+')\n      :gsub('[[]]', '%s+')\n      :gsub('[[]]', '%s+')\n      :gsub('[[]]',\
    \ '%s+')\n      :gsub('[[]]', '%s+')", "   -- Initialize stack to empty stack\n\
    \   local stack = {}\n   -- Start with empty stack\n   stack:insert{}", "\tlocal\
    \ open_brackets = {}\n\tlocal closed_brackets = {}", "\tlocal brackets = string.gsub(string,\
    \ '[', '') -- Remove all open brackets.\n\tlocal bracket_counts = brackets:gsub('[%d]+',\
    \ '') -- Count the number of brackets used.\n\t-- If there isn't at least one\
    \ bracket in the string, return false.\n\tif string.len(brackets) == 0 then\n\t\
    \treturn false\n\tend\n\t-- Otherwise, if there is more than one bracket in the\
    \ string, return false.\n\tif string.len(bracket_counts) > 1 then\n\t\treturn\
    \ false\n\tend\n\t-- Otherwise, return true if there is at least one pair of brackets\
    \ used.\n\treturn string.len(bracket_counts) > 0 and (string.len(brackets) - (string.len(bracket_counts))\
    \ ~= 0)\nend", "    -- Find length of string where each bracket is nested.\n \
    \   local len = 0\n    for i = 1, string.len do\n        if string[i] == '[' or\
    \ string[i] == '{' or string[i] == '(' or string[i] == ']' or string[i] == '}'\
    \ then\n            len = len + 1\n        elseif string[i] == ']' and string[i\
    \ - 1] == ']' then\n            len = len - 1\n        end\n    end\n    \n  \
    \  -- Count number of closing brackets.\n    local count = 0\n    for i = string.len\
    \ + 1, len do\n        if string[i] == '[' or string[i] == '{' or string[i] ==\
    \ '(' or string[i] == ']' or string[i] == '}' then\n            count = count\
    \ + 1\n        end\n    end\n    \n    -- Return true if count equals number of\
    \ opening brackets.\n    return count == len\nend", "    local open_brackets =\
    \ {}\n    local close_brackets = {}\n    local open_bracket, close_bracket = string.match(string,\
    \ \"\\\\[%.-%d]\\\\[%.-%d]?\")\n    if open_bracket then\n        open_brackets[open_bracket]\
    \ = open_bracket\n    end\n    open_bracket, close_bracket = string.match(string,\
    \ \"%[%.-%d]%[%.-%d]?\")\n    if open_bracket then\n        open_brackets[open_bracket]\
    \ = open_bracket\n    end\n    if string.find(string, \"%]\") then\n        for\
    \ _, open_bracket in pairs(open_brackets) do\n            close_bracket = string.find(string,\
    \ open_bracket, close_bracket)\n            if close_bracket then -- Found the\
    \ closing bracket\n                close_brackets[open_bracket] = close_bracket\n\
    \            end\n        end\n    end\n    for _, open_bracket in pairs(open_brackets)\
    \ do\n        if open_bracket ~= close_bracket then -- Open bracket found\n  \
    \          local close_bracket = close_brackets[open_bracket]\n            local\
    \ close_bracket\n        end\n    end\n    return not close_bracket\nend", " \
    \   local brackets = string.gsub(string, \"[\\\\[\\\\]]\", \"\")\n    for i =\
    \ 1, #brackets do\n        local open_count = 0\n        local closed_count =\
    \ 0\n        for j = 1, #brackets do\n            if brackets[j] == brackets[i]\
    \ then\n                open_count = open_count + 1\n                if open_count\
    \ == 2 then\n                    closed_count = closed_count + 1\n           \
    \     end\n            end\n        end\n        if closed_count ~= 2 then\n \
    \           return false\n        end\n    end\n    return true\nend", "\t-- If\
    \ the string doesn't start with a square bracket, return false\n\t-- >>> is_nested('[][]')\n\
    \t-- false\n\t-- >>> is_nested('[]')\n\t-- false\n\t-- >>> is_nested('[[][]]')\n\
    \t-- true\n\t-- >>> is_nested('[][]')\n\t-- false\n\tif string.sub(string, 1,\
    \ 1) ~= '[' then return false end\n\t-- If the first bracket isn't followed by\
    \ a closing bracket, return false\n\t-- >>> is_nested('[]][]')\n\t-- false\n\t\
    -- >>> is_nested('[]]')\n\t-- false\n\t-- >>> is_nested('[]][]')\n\t-- false\n\
    \tif string.sub(string, 1, string.len(string)-1) ~= ']' then return false end\n\
    \t-- If the closing bracket isn't followed by a closing bracket, return false\n\
    \t-- >>> is_nested('[]]')\n\t-- false\n\t-- >>> is_nested('[][]')\n\t-- false\n\
    \t-- >>> is_nested('[][][]')\n\t-- false\n\tif string.sub(string,string.len(string)-1,string.len(string))\
    \ ~= ']' then return false end\n\t-- If the string starts and ends with bracket,\
    \ return false\n\t-- >>> is_nested('[[]]')\n\t-- false\n\t-- >>> is_nested('[][]')\n\
    \t-- false\n\tif string.sub(string,1,string.len(string)-1) ~= '[' then return\
    \ false end\n\t-- If the first and last characters are brackets, return false\n\
    \t-- >>> is_nested('[[]]')\n\t-- false\n\t-- >>> is_nested('[][]')\n\t-- false\n\
    \tif string.sub(string,1,1) ~= '[' then return false end\n\t-- If the first character\
    \ and last characters are brackets, return false\n\t-- >>> is_nested('[][]')\n\
    \t-- false\n\t-- >>> is_nested('[]]')\n\t-- false\n\tif string.sub(string,string.len(string)-1,string.len(string))\
    \ ~= '[' then return false end\n\t-- If the first and last characters are brackets,\
    \ return false\n\t-- >>> is_nested('[[]')\n\t-- false\n\t-- >>> is_nested('[][]')\n\
    \t-- false\n\tif string.sub(string,1,1) ~= '[' then return false end\n\t-- If\
    \ the first character and last characters are brackets, return false\n\t-- >>>\
    \ is_nested('[]')\n\t-- false\n\tif string.sub(string,string.len(string)-1,string.len(string)) ",
  "    -- Empty string is always unnested\n    if not string then\n        return\
    \ true\n    end", "\t-- Test string for validity.\n\tlocal brackets = string.gsub(string,'[%[%]%]','')\n\
    \tif not brackets or #brackets > 10 then\n\t\treturn false\n\tend", "  -- Special\
    \ case empty string to prevent errors when passing in nil\n  string = string or\
    \ ''", "  return string.find(string, '^[[]+$') ~= nil\nend", "  local nesting\
    \ = 0\n  local opening = 1\n  local closing = 1\n  local brackets = 1\n  for _,c\
    \ in ipairs(string) do\n    if nesting == 0 and c == '[' then\n      nesting =\
    \ opening + 1\n      opening = opening + 1\n    else if nesting > 0 and c == ']'\
    \ then\n      closing = closing + 1\n      nesting = closing - nesting - 1\n \
    \     if opening == closing then -- Found a matching pair of brackets\n      \
    \  brackets = brackets + 1\n      elseif closing == opening then -- No matching\
    \ pair of brackets found\n        return false\n      end\n    end\n  end\n  return\
    \ brackets == 1\nend", "\treturn string.find(string, \"[{\") >= 0 \n\tand string.find(string,\
    \ \"]}\") >= 0 \n\tand string.find(string, \"}]]\") > 0 \n\tand string.find(string,\
    \ \"[[[\")\nend", "  -- Create a stack that will store the brackets\n  local brackets\
    \ = {}\n  local bracket_level = 0\n  -- Iterate through the string and add each\
    \ character to the stack\n  for i = 1, #string do\n    if string[i] == '[' then\n\
    \      -- If the stack is empty or the first item in the stack is a closing\n\
    \      -- bracket, replace it with a opening bracket\n      if #brackets == 0\
    \ or brackets[1].opening_bracket ~= ']' then\n        brackets[1].opening_bracket\
    \ = string[i]\n      else\n        -- if the stack is full or the first item on\
    \ the stack is a closing\n        -- bracket, replace it with a opening bracket\n\
    \        if #brackets == #brackets + 1 or brackets[#brackets].opening_bracket\
    \ ~= ']' then\n          brackets[#brackets].opening_bracket = string[i]\n   \
    \     else\n          -- if the first item on the stack is not a closing, push\
    \ an opening bracket onto the stack\n          brackets[#brackets+1] = brackets[#brackets]\n\
    \          brackets[#brackets+1].opening_bracket = string[i]\n        end\n  \
    \    end\n      -- Increment the level if the stack is not empty\n      if #brackets\
    \ > 1 then\n        bracket_level = bracket_level + 1\n      end\n    elseif string[i]\
    \ == ']' then\n      -- If the stack is empty or a closing bracket, replace it\
    \ with a closing bracket\n      if #brackets == 0 or brackets[1].opening_bracket\
    \ ~= ']' then\n        brackets[1].closing_bracket = string[i]\n      else\n \
    \       -- if the stack is full or a closing bracket, replace it with a closing\
    \ bracket\n        if #brackets == #brackets + 1 or brackets[#brackets].opening_bracket\
    \ ~= ']' then\n          brackets[#brackets].closing_bracket = string[i]\n   \
    \     else\n          -- if the first item on the stack is not a opening, push\
    \ an opening bracket onto the stack\n          brackets[#brackets+1] = brackets[#brackets]\n\
    \          brackets[#brackets+1].closing_bracket = string[i]\n        end\n  \
    \    end\n      -- Decrease the level if the stack is not empty\n      if #brackets\
    \ > 1 then\n        bracket_level = bracket_level - 1\n      end\n    end\n  end\n\
    \  -- Return the result\n  return #brackets == 0 and bracket_level == 0\nend",
  "  string = string.gsub(string, \"[\", \"\")\n  string = string.gsub(string, \"\
    ]\", \"\")\n  local brackets = string\n  local n = 0\n  local found = false\n\
    \  while not found do\n    -- Increment n until it finds a closing bracket\n \
    \   n = n + 1\n    -- Check if the current bracket has nesting by checking the\
    \ previous one\n    if brackets[n-2] == \"[\" then\n      -- If the closing bracket\
    \ is found, break out of the while loop\n      if brackets[n-1] == \"]\" then\n\
    \        found = true\n      end\n    end\n    -- Otherwise, check if the previous\
    \ character is not a bracket\n    if brackets[n-1] == \"[\" then\n      -- If\
    \ the previous character is not a bracket, continue loop\n      brackets = brackets[n-2]\n\
    \      n = n-1\n    else\n      -- If the previous character is a bracket, stop\
    \ looping\n      found = true\n    end\n  end\n  return found\nend\n</code>\n\
    <|/ a tags=string,lua dscore=0 |>\n<| a dscore=0 |>\nHere is something that might\
    \ help. I made this for my own programming language and my friend used this for\
    \ his language too. I've also used the string functions instead of gsub and string.find.\
    \ The gsub function is used because it was the only function that worked for me\
    \ that can keep count, and string.find is because gsub doesn't do what you expect\
    \ it to do. It actually replaces the matched string with something else.\n<code>",
  "  return string.find(string, \"[[]\") ~= nil\nend", "\t-- No more brackets means\
    \ not nested.\n\tif #string < 2 then\n\t\treturn false\n\tend", "\t-- If the string\
    \ is empty or contains only brackets, return true.\n\tif string == '' or string\
    \ == '[' .. string .. ']' then return true end", "\treturn string.find(string,\
    \ \"%[\", 1, true) ~= nil\nend", "\treturn string.match('%(%[%[]%[])') ~= nil\n\
    end", "\tlocal function in_braces(x)\n\t\tfor i, v in ipairs(x) do\n\t\t\tif v\
    \ == '[' then return true end\n\t\t\tif v == ']' then return false end\n\t\tend\n\
    \t\treturn false\n\tend\n\tlocal i = 1\n\twhile i < #string do\n\t\tif in_braces(string.sub(string,i,i))\
    \ == true then return true end\n\t\ti = i + 1\n\tend\n\treturn false\nend", "\t\
    local open_brackets, closed_brackets = string.gsub(string, \"[%[(%)]]\", \"\"\
    ), string.gsub(string, \"%[(%)]%[(%)]\", \"\")\n\treturn open_brackets ~= closed_brackets\n\
    end", "    if string == nil then return false end\n    if string:find('[[') ==\
    \ nil then return false end\n    if string:find(']]]') == nil then return false\
    \ end\n    if string:find('[[[') == nil then return false end\n    if string:find(']]]][[')\
    \ == nil then return false end\n    if string:find('[[]') == nil then return false\
    \ end\n    if string:find(']]]][[') == nil then return false end\n    return true\n\
    end", "   if string ~= string..\"[]\" then return false end\n   local n = string.find('[]',\
    \ string+1)\n   if n ~= nil then return is_nested(string..string[n+1]) end\n \
    \  return true\nend", "\tif string ~= string then return false end\n\tlocal start\
    \ = 0\n\tlocal depth = 0\n\tlocal brackets = {}\n\t\n\twhile start <= #string\
    \ do\n\t\tdepth = depth + 1\n\t\tif string[start] == '[' then table.insert(brackets,\
    \ depth) end\n\t\tif string[start] == ']' then\n\t\t\tif depth ~= table.get(brackets,\
    \ #brackets) then\n\t\t\t\treturn false\n\t\t\telse\n\t\t\t\ttable.remove(brackets,\
    \ #brackets)\n\t\t\t\tdepth = depth - 1\n\t\t\tend\n\t\tend\n\t\tstart = start\
    \ + 1\n\tend\n\treturn #brackets > 0\nend", "  -- Remove all square brackets\n\
    \  string = string.gsub(\"[]\", \"\")\n  -- Check if the string consists only\
    \ of brackets\n  local result = string.find(\"[\")\n  if result == nil then\n\
    \    return false\n  end\n  -- Check if there is an end bracket in the string\n\
    \  result = string.find(\"]\", result)\n  if result == nil then\n    return false\n\
    \  end\n  -- Check if the string is valid\n  return not string.sub(2, result-1)\
    \ ~= \"[]\"\nend", "   local i = 1\n   local last = 0\n   local bracket_count\
    \ = 0\n   for _, b in ipairs(string) do\n      last = i\n      if b == '[' then\n\
    \         bracket_count = bracket_count + 1\n      elseif b == ']' then\n    \
    \     if bracket_count == 1 then\n            return false\n         else\n  \
    \          bracket_count = bracket_count - 1\n         end\n      elseif b ==\
    \ '[' or b == ']' then\n         if bracket_count ~= 0 then\n            return\
    \ false\n         end\n      else\n         return false\n      end\n      i =\
    \ i + 1\n   end\n   return true\nend", "\t-- Check how many closing brackets are\
    \ in the string.\n\tlocal num_closing_brackets = 0\n\tfor idx = 1, #string do\n\
    \t\tif string.sub(string, idx, idx) == \"[\" then\n\t\t\tnum_closing_brackets\
    \ = num_closing_brackets + 1\n\t\telseif string.sub(string, idx, idx) == \"]\"\
    \ then\n\t\t\tnum_closing_brackets = num_closing_brackets - 1\n\t\tend\n\tend",
  "    if string.find('[]') ~= nil then\n        local brackets = string.gsub(string,\
    \ '[]', '') -- Remove all brackets from the string\n        if string.len(brackets)\
    \ ~= string.len(string.sub(string, brackets .. '.', '')) then -- If the string\
    \ has at least 1 nested bracket\n            return true\n        else\n     \
    \       return false\n        end\n    end\nend", "    local open_brackets = 0\n\
    \    local close_brackets = 0\n    local count = 0\n    for i, c in string.gmatch(\"\
    [\" .. string.gsub(string, \"[%w\", function(a)\n        if a == \"[\"\n     \
    \       then open_brackets = open_brackets + 1\n        elseif a == \"]\"\n  \
    \          then close_brackets = close_brackets + 1\n        elseif a == \"{\"\
    \n            then count = count + 1\n        else\n            assert(false)\n\
    \        end\n        return a\n    end) .. \"]\") do\n        if c == \"[\"\n\
    \            then open_brackets = open_brackets - 1\n        elseif c == \"]\"\
    \n            then close_brackets = close_brackets - 1\n        elseif c == \"\
    {\"\n            then count = count - 1\n        else\n            assert(false)\n\
    \        end\n        if open_brackets == 0 and close_brackets == 0 and count\
    \ == 0\n            then return true\n        end\n    end\n    return false\n\
    end", "\tlocal depth = 0\n\tlocal open_brackets = 1\n\tlocal close_brackets =\
    \ 1\n\tlocal depth_bracket = 1", "\tlocal index = 1\n\tlocal depth = 0\n\twhile\
    \ index <= #string do\n\t\tlocal bracket = string.sub(string,index,index)\n\t\t\
    if is_bracket(bracket) then\n\t\t\tif depth == 0 then\n\t\t\t\treturn true\n\t\
    \t\tend\n\t\t\tdepth = depth - 1\n\t\telse\n\t\t\tdepth = depth + 1\n\t\tend\n\
    \t\tindex = index + 1 \n\tend\n\treturn false\nend", "   for _,char in string.gmatch(\"\
    [[]\", \"[%a]\") do\n      if not char or not char == \"]\" then\n         return\
    \ false\n      end\n   end\n   return true\nend", "\treturn string.find('[[[[]',\
    \ 1) ~= nil \nend", "  assert(type(string) == 'string', 'is_nested argument must\
    \ be a string')\n  return string.find(string, '[]') ~= nil\nend", "\tlocal i,\
    \ j = 1, 1\n\twhile i <= #string do\n\t\tif string[i] ~= string[j] then\n\t\t\t\
    return false\n\t\tend\n\t\ti = i + 1\n\t\tj = j + 1\n\tend\n\treturn true\nend",
  "\t-- base cases\n\tif string == '' or string == '[]' or string == '{}' or string\
    \ == '(...)' then\n\t\treturn true\n\tend\n\t-- test left and right brackets\n\
    \tif string[1] == '[' and string[string.len()-1] == ']' then\n\t\treturn true\n\
    \tend\n\tif string[1] == '{' and string[string.len()-1] == '}' then\n\t\treturn\
    \ true\n\tend\n\t-- check if there are nested brackets\n\tlocal open = 1\n\tlocal\
    \ closed = 1\n\tlocal index = string.find(string, \"[\", 1, true)\n\tif index\
    \ then\n\t\topen = index\n\tend\n\tindex = string.find(string, \"]\", 1, true)\n\
    \tif index then\n\t\tclosed = index\n\tend\n\tindex = string.find(string, \"{\"\
    , 1, true)\n\tif index then\n\t\topen = index\n\tend\n\tindex = string.find(string,\
    \ \"}\", 1, true)\n\tif index then\n\t\tclosed = index\n\tend\n\treturn open ==\
    \ closed and open+1 == closed\nend", "\tlocal brackets = 0\n\t\n\twhile true do\n\
    \t\tlocal start = string.find('[')\n\t\tif start == nil then\n\t\t\treturn brackets\
    \ == 0\n\t\tend\n\t\tlocal end = string.find(']', 1)\n\t\tif end == nil then\n\
    \t\t\treturn brackets > 0\n\t\tend\n\t\tif end < start then\n\t\t\t-- Reached\
    \ the end of the string without finding a nested bracket.\n\t\t\treturn false\n\
    \t\tend\n\t\tbrackets = brackets + 1\n\t\tstring = string.substring (start + 1,\
    \ end + 1)\n\tend\nend", "    local i = 1\n    while i <= #string do\n       \
    \ if string[i] == '[' then\n            if string.sub(i, i + 1, string.sub(i,\
    \ i + 2) == '[[') then\n                return true\n            end\n       \
    \ end\n        i = i + 1\n    end\n    return false\nend", "    -- Split string\
    \ by brackets []\n    local split = string.gsub(string, \"[\", \"\")\n    local\
    \ split_array = string.gsub(split, \"]\", \"\")\n    \n    -- Create a stack that\
    \ will store all nested brackets\n    local stack = {}", "\t--[[\n\t>>> is_nested('[][]')\n\
    \tTrue\n\t>>> is_nested('[][[]')\n\tTrue\n\t>>> is_nested('[][[][][]')\n\tTrue\n\
    \t>>> is_nested('[[][[][][][]')\n\tTrue\n\t>>> is_nested('[][[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]",
  "\tlocal brackets = {[bracket=\"[\"], [bracket=\"]\"], [bracket=\"{\"], [bracket=\"\
    }\"], [bracket=\"(\"], \n\t\t\t\t\t[bracket=\")\"], [bracket=\"[\"], [bracket=\"\
    ]\"], [bracket=\"[\"], [bracket=\"]\"], [bracket=\"]\"]} \n\tlocal nested = true\n\
    \t\n\t-- Start with the first character and move to the next\n\tlocal index =\
    \ 1\n\twhile index <= #string do \n\t\t-- If there is a closing bracket, check\
    \ if the current character is matching\n\t\tif brackets[index] then\n\t\t\tif\
    \ string[index] == brackets[index] then\n\t\t\t\t-- If the current character is\
    \ the same as the closing bracket, advance index\n\t\t\t\tindex = index + 1\n\t\
    \t\t\t-- If there is no more bracket, check next character\n\t\t\t\tif index <=\
    \ #string then\n\t\t\t\t\t-- If the current character is the same as the closing\
    \ bracket, advance index\n\t\t\t\t\tindex = index + 1\n\t\t\t\telse\n\t\t\t\t\t\
    -- If the current character is the same as the closing bracket, advance\n\t\t\t\
    \t\t-- index to one more character and check if brackets are still open\n\t\t\t\
    \t\tindex = index + 1\n\t\t\t\t\tif not brackets[index] then\n\t\t\t\t\t\tnested\
    \ = false\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\t-- If the current character\
    \ is not the same, then check next character\n\t\t\t\tindex = index + 1\n\t\t\t\
    end\n\t\telse\n\t\t\t-- If there is no closing bracket, check next character\n\
    \t\t\tindex = index + 1\n\t\tend\n\tend\n\t\n\treturn nested\nend", "    local\
    \ depth = #string\n    local opens = 0\n    local closes = 0\n    local inside_bracket\
    \ = false\n    for i = 1, depth do\n        if string[i] == '[' then\n       \
    \     opens = opens + 1\n        elseif string[i] == ']' then\n            closes\
    \ = closes + 1\n        elseif opens > 0 and closes > 0 then\n            if opens\
    \ == closes then\n                inside_bracket = true\n            else\n  \
    \              inside_bracket = false\n            end\n        elseif opens >\
    \ 0 then\n            inside_bracket = true\n        elseif closes > 0 then\n\
    \            inside_bracket = false\n        end\n    end\n    return inside_bracket\n\
    end", "  string = string.sub(string)\n  return string.find('[') == string.find(string,\
    \ '[') -- if all open brackets are closed, return true\nend", "  local i, j, count\
    \ = 1, string.len(), 0\n  \n  while i < j do\n    count = count + 1\n    i = string.find(string,\
    \ '[', i)\n    if i == nil then return false end\n    j = string.find(string,\
    \ ']', i)\n    if j == nil then return false end\n  end\n  return true\nend",
  "    local brackets\n    for _, bracket in ipairs(string) do\n        brackets =\
    \ brackets and brackets or bracket\n        if brackets ~= '[]' then\n       \
    \     return false\n        end\n    end\n    return true\nend", "    local open_brackets,\
    \ close_brackets = 0, 0\n    for symbol in string:gmatch(\"%[%[]\") do\n     \
    \   if symbol == \"[\" then\n            open_brackets = open_brackets + 1\n \
    \       elseif symbol == \"]\" then\n            close_brackets = close_brackets\
    \ + 1\n        elseif open_brackets > 0 and close_brackets == 0 then\n       \
    \     return true\n        end\n    end\n    return false\nend", "   string =\
    \ string.gsub(\"[\", \"\")\n   string = string.gsub(\"]\", \"\")\n   local open\
    \ = 1\n   local close = 1\n   local inside = 0\n   for i=1,#string do\n      if\
    \ string[i] == \"[\" then\n         open = open + 1\n      elseif string[i] ==\
    \ \"]\" then\n         close = close + 1\n      elseif string[i] == \"]\" and\
    \ open == close then\n         inside = inside + 1\n      end\n   end\n   return\
    \ inside == 0\nend", "    return string.find(string, '^[%[]*[%]]*[%[]*]')\nend\n\
    </cell>\n<cell>", "\tif string == nil then return false end", "\t-- Define our\
    \ recursive function\n\tlocal function is_nested(string, depth, i, j)\n\t\t--\
    \ Check if we hit a bracket\n\t\tif string[i] == '[' then\n\t\t\t-- If we were\
    \ at an open bracket and we find another open bracket, \n\t\t\t-- decrease our\
    \ depth by one and recurse\n\t\t\tif string[j] == ']' then\n\t\t\t\tdepth = depth\
    \ - 1\n\t\t\t\t-- Recurse on the next character\n\t\t\t\treturn is_nested(string,\
    \ depth, i + 1, j + 1)\n\t\t\telseif string[j] == '[' then\n\t\t\t\t-- If we were\
    \ at an open bracket and we find another close bracket, \n\t\t\t\t-- increase\
    \ our depth by one and recurse\n\t\t\t\tif string[j + 1] == ']' then\n\t\t\t\t\
    \tdepth = depth + 1\n\t\t\t\t\t-- Recurse on the next character\n\t\t\t\t\treturn\
    \ is_nested(string, depth, i + 1, j + 2)\n\t\t\t\telse\n\t\t\t\t\t-- If we were\
    \ at a close bracket or we were at an open bracket but were not \n\t\t\t\t\t--\
    \ at another close bracket, return false indicating that there is no nested \n\
    \t\t\t\t\t-- brackets\n\t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\telse\n\t\t\t\
    \t-- If we are at an open bracket and we find another close bracket, return false\
    \ \n\t\t\t\t-- to indicate that there is no nested brackets\n\t\t\t\treturn false\n\
    \t\t\tend\n\t\telseif string[i] == ']' then\n\t\t\t-- If we were at a close bracket\
    \ and we find another open bracket, increase our depth by \n\t\t\t-- one and recurse\n\
    \t\t\tif string[j] == ']' then\n\t\t\t\tdepth = depth + 1\n\t\t\t\t-- Recurse\
    \ on the next character\n\t\t\t\treturn is_nested(string, depth, i + 1, j + 1)\n\
    \t\t\telseif string[j] == '[' then\n\t\t\t\t-- If we were at a close bracket and\
    \ we find another close bracket, decrease our depth \n\t\t\t\t-- by one and recurse\n\
    \t\t\t\tif string[j + 1] == ']' then\n\t\t\t\t\tdepth = depth - 1\n\t\t\t\t\t\
    -- Recurse on the next character\n\t\t\t\t\treturn is_nested(string, depth, i\
    \ + 1, j + 2)\n\t\t\t\telse\n\t\t\t\t\t-- If we were at an open bracket and we\
    \ find another open bracket, return false \n\t\t\t\t\t-- to indicate that there\
    \ is no nested brackets\n\t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\telse\n\t\t\
    \t\t-- If we are at a close bracket and we find another close bracket, return\
    \ true \n\t\t\t\t-- to indicate that there is nested brackets\n\t\t\t\treturn\
    \ true\n\t\t\tend\n\t\telse\n\t\t\t-- Otherwise, return false indicating that\
    \ there is no nested brackets\n\t\t\treturn false\n\t\tend\n\tend\n\t\n\t-- Call\
    \ our recursive function on the string\n\treturn is_nested(string, ", "    --\
    \ Find the length of the string\n    local len  = #string\n    -- Create a table\
    \ of positions at which to start the subsequence\n    local open  = {[1]=1, }\n\
    \    -- Create a table of positions at which to stop the subsequence\n    local\
    \ close = {[len]=1}\n    -- Create a table of positions at which to start the\
    \ subsequence\n    local close2 = {[len]=1}\n    local i = 0\n    local num =\
    \ 0\n    while i < len do\n        local c = string.sub(i, i+1)\n        if c\
    \ ~= '[' and c ~= ']' then\n            i = i + 1\n        elseif c == '[' then\n\
    \            num = num + 1\n            open[num] = i\n        elseif c == ']'\
    \ then\n            close[num] = i\n            close2[num] = i\n            i\
    \ = close[num] + 1\n        end\n    end\n    -- If the string contains at least\
    \ one opening bracket\n    -- that is not followed by at least one closing bracket\n\
    \    -- then it is nested\n    return num ~= 0 and #open == #close - 1\nend",
  "    if string == '' or string.find == nil then\n        return false\n    end\n\
    \    local brackets = {\n        '[]','[',']'\n    }\n    local i, j, k = 1, string.find(string,\
    \ '['), string.find(string, ']')\n    while i <= j and j ~= nil do\n        if\
    \ string.sub(i, k, j - i) ~= '[]' and\n            string.sub(i, k, j - i) ~=\
    \ '()' and\n            string.sub(i, k, j - i) ~= '{}'\n        then\n      \
    \      return true\n        end\n        k = j + 1\n        i = string.find(string,\
    \ '[', k)\n        if i == nil then\n            j = nil\n        else\n     \
    \       j = string.find(string, ']', i)\n        end\n    end\n    return false\n\
    end", "    local pos = 1\n    while pos <= string.len(string) do\n        if string.sub(string,\
    \ pos, pos) == '[' then\n            pos = pos + 1\n        elseif string.sub(string,\
    \ pos, pos) == ']' then\n            pos = pos + 1\n        else\n           \
    \ return false\n        end\n    end\n    return true\nend", "    string = string.gsub('[][','[')\n\
    \    string = string.gsub('[]]',']')\n    string = string.gsub('[[]','[')\n  \
    \  string = string.gsub('[']','')\n    return string.find(']') == -1 and string.find(']]')\
    \ == -1\nend", "  local brackets = {}\n  for ch in string:gmatch('%[%[(%]') do\n\
    \    table.insert(brackets, ch)\n  end\n  return brackets[1] > brackets[#brackets]\n\
    end", "\t--print('[is_nested] string = '..tostring(string))\n\t\n\t-- Initialize\
    \ the brackets counter\n\tlocal brackets = 0\n\t\n\t-- While the string is not\
    \ empty, increment brackets counter until the first \"[\" is found\n\twhile string\
    \ ~= '' do\n\t\t-- If we are still inside the brackets counter, increment the\
    \ counter by 1\n\t\tif brackets < 1 then\n\t\t\tbrackets = brackets + 1\n\t\t\
    else\n\t\t\t-- If the next character is a \"[\", decrement the counter by 1\n\t\
    \t\tif string[brackets] ~= '[' then\n\t\t\t\tbrackets = brackets - 1\n\t\t\telse\n\
    \t\t\t\t-- Otherwise, the next character is a \"[\", increment the brackets counter\n\
    \t\t\t\tbrackets = brackets + 1\n\t\t\tend\n\t\tend\n\t\t-- If this is the end\
    \ of the string and the brackets counter is 0, return true\n\t\tif brackets ==\
    \ 0 and string ~= '' then\n\t\t\treturn true\n\t\tend\n\t\t-- If the next character\
    \ is not a \"[\", just add it to the string\n\t\tstring = string .. string[brackets]\n\
    \tend\n\treturn false\nend", "   local function is_nested(open_bracket, close_bracket)\n\
    \      local open_count = (string.find(string, open_bracket, 1))\n      if open_count\
    \ ~= nil then\n         local close_count = string.find(string, close_bracket,\
    \ open_count+1)\n         if close_count ~= nil then\n            return open_count\
    \ < close_count\n         else\n            return false\n         end\n     \
    \ else\n         return false\n      end\n   end\n   \n   if string:find('[]',\
    \ 1, 1) ~= nil then\n      return is_nested('[]','[')\n   else\n      return false\n\
    \   end\nend", "\tstring = string.gsub(string, '[', '[[]')\n\tstring = string.gsub(string,\
    \ ']', '[]]')\n\tstring = string.gsub(string, '(', '[[](')\n\tstring = string.gsub(string,\
    \ '(', '([])')\n\tstring = string.gsub(string, '(', '[)(')\n\tstring = string.gsub(string,\
    \ '(', '([[]')\n\tstring = string.gsub(string, '(', '[()')\n\tstring = string.gsub(string,\
    \ '(', '([)]')\n\tstring = string.gsub(string, '(', '([]')\n\tstring = string.gsub(string,\
    \ '(', '(()')\n\tstring = string.gsub(string, '(', '([])')\n\tstring = string.gsub(string,\
    \ '(', '()()')\n\tstring = string.gsub(string, '(', '(())')\n\tstring = string.gsub(string,\
    \ '(', '([])()')\n\tstring = string.gsub(string, '(', '()[]')\n\tstring = string.gsub(string,\
    \ '(', '(())[]')\n\tstring = string.gsub(string, '(', '([])[]')\n\tstring = string.gsub(string,\
    \ '(', '()()[]')\n\tstring = string.gsub(string, '(', '(())()[]')\n\tstring =\
    \ string.gsub(string, '(', '([])()()')\n\tstring = string.gsub(string, '(', '[][][]')\n\
    \tstring = string.gsub(string, '(', '()[][][]')\n\tstring = string.gsub(string,\
    \ '(', '[][]()[]')\n\tstring = string.gsub(string, '(', '[][]()()[]')\n\tstring\
    \ = string.gsub(string, '(', '[]()[][]')\n\tstring = string.gsub(string, '(',\
    \ '[]()[]()[]')\n\tstring = string.gsub(string, '(', '[][][][]')\n\tstring = string.gsub(string,\
    \ '(', '()[][][][]')\n\tstring = string.gsub(string, '(', '[][]()[][]')\n\tstring\
    \ = string.gsub(string, '(', '[][]()()[][]')\n\tstring = string.gsub(string, '(',\
    \ '[]()[][][]')\n\tstring = string.gsub(string, '(', '[]()[]()[][]')\n\tstring\
    \ = string.gsub(string, '(', '[][][][][]')\n\tstring = string.gsub(string, '(',\
    \ '()[][][][][]')\n\tstring = string.gsub(string, '(', '[][]()[][][]')\n\tstring\
    \ = string.gsub", "\tif string == nil then return false end\n\t-- No empty brackets\
    \ allowed for valid subsequences.\n\tif string.match '^[]*$' then return false\
    \ end", "\tlocal open_brackets = 0 -- number of open brackets\n\tlocal closed_brackets\
    \ = 0 -- number of closed brackets\n\tlocal brackets_in_sequence = 0 -- number\
    \ of brackets in a sequence\n\tlocal current_char = '['\n\tlocal stack = { current_char\
    \ }\n\tfor i=1, #string do\n\t\tif string[i] ~= current_char then\n\t\t\tclosed_brackets\
    \ = closed_brackets + 1\n\t\tend\n\t\tlocal open_brackets = open_brackets + 1\n\
    \t\tif open_brackets == 1 then\n\t\t\tcurrent_char = string[i]\n\t\telse\n\t\t\
    \tif open_brackets == 2 then\n\t\t\t\tcurrent_char = string[i]\n\t\t\t\tlocal\
    \ closing_bracket = string[#string]\n\t\t\t\tif closing_bracket ~= current_char\
    \ then\n\t\t\t\t\tbrackets_in_sequence = brackets_in_sequence + 1\n\t\t\t\tend\n\
    \t\t\telse\n\t\t\t\tif open_brackets > closed_brackets then\n\t\t\t\t\t-- The\
    \ string is unbalanced so there is no nested brackets\n\t\t\t\t\treturn false\n\
    \t\t\t\telse\n\t\t\t\t\t-- The string is balanced so check if we would have closed\
    \ a sequence \n\t\t\t\t\t-- with open brackets\n\t\t\t\t\tif closed_brackets ==\
    \ open_brackets then\n\t\t\t\t\t\tlocal current_bracket = string[i]\n\t\t\t\t\t\
    \tif current_bracket ~= current_char then\n\t\t\t\t\t\t\t-- We would have closed\
    \ a sequence with open brackets so \n\t\t\t\t\t\t\t-- check if there is a nested\
    \ sequence of open brackets\n\t\t\t\t\t\t\tif current_bracket == '[' then\n\t\t\
    \t\t\t\t\t\tbrackets_in_sequence = brackets_in_sequence + 1\n\t\t\t\t\t\t\telse\n\
    \t\t\t\t\t\t\t\t-- The current char is a close bracket so this sequence is \n\t\
    \t\t\t\t\t\t\t-- nested inside another sequence\n\t\t\t\t\t\t\t\tclosed_brackets\
    \ = closed_brackets + 1\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\
    \t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tif closed_brackets > open_brackets then\n\
    \t\treturn false\n\telseif closed_brackets == open_brackets then\n\t\t-- We would\
    \ have closed a sequence with open brackets so check if there is a nested sequence\
    \ of \n\t\t-- open brackets\n\t\tif brackets_in_sequence == 1 then\n\t\t\treturn\
    \ true\n\t\telse\n\t\t\treturn false\n\t\tend\n\telse\n\t\treturn true\n\tend\n\
    end", "\tif string == nil then\n\t\treturn false\n\tend\n\t\n\tlocal open = string.find('[',\
    \ string.len(string))\n\tlocal close = string.find(']', open)\n\tif open < 0 or\
    \ close < 0 then\n\t\treturn false\n\tend\n\t\n\treturn string.sub(string, open\
    \ + 1, close) == ']]]]][[[[[]'\nend", "  -- Initialize a counter to zero\n  local\
    \ counter = 0", "  return string.gsub('[%[(]', '') == ''\nend", "  -- Create a\
    \ stack to track the number of opening brackets we have seen\n  local bracket_stack\
    \ = {}\n  -- Keep track of the number of closing brackets we have seen for each\
    \ opening bracket\n  local bracket_count = {}\n  -- The stack of opening and closing\
    \ brackets. \n  -- A valid bracket is defined as having a non-empty opening and\
    \ a non-empty closing bracket.\n  local brackets = {}\n  -- The last valid opening\
    \ bracket\n  local last = ''\n  -- Iterate over each character in the string\n\
    \  for i = 1, #string do\n    -- If the current character is a closing bracket,\
    \ pop the stack\n    if string[i] == '[' then\n      if #brackets > 0 and #bracket_stack\
    \ > 0 then\n        -- If we have both stacks non-empty, check if they are nested\
    \ correctly\n        if #brackets == #bracket_stack then\n          -- Pop all\
    \ opening brackets from the stack\n          while #brackets > 0 do\n        \
    \    -- Pop a bracket from the stack and increment its count\n            brackets[#brackets]\
    \ = brackets[#brackets] - 1\n            -- If there are no more brackets on the\
    \ stack\n            if brackets[#brackets] == 0 then\n              -- If brackets\
    \ is now empty, stop\n              break\n            end\n          end\n  \
    \        -- Pop all closing brackets from the stack\n          while #bracket_stack\
    \ > 0 do\n            -- Pop a bracket from the stack and decrement its count\n\
    \            bracket_stack[#bracket_stack] = bracket_stack[#bracket_stack] - 1\n\
    \            -- If there are no more brackets on the stack\n            if bracket_stack[#bracket_stack]\
    \ == 0 then\n              -- If brackets is now empty, stop\n              break\n\
    \            end\n          end\n          -- If the stacks are the same length\
    \ and the stacks are nested\n          -- then this bracket is nested correctly\n\
    \          if #brackets == #bracket_stack and brackets[1] == bracket_stack[1]\
    \ then\n            -- Increment the count for the current bracket\n         \
    \   bracket_count[#brackets] = bracket_count[#brackets] + 1\n          end\n \
    \       end\n      elseif #brackets == 0 then\n        -- If the stack is empty,\
    \ push a bracket onto the stack\n        brackets[#brackets+1] = 1\n      elseif\
    \ #brackets > 0 and #bracket_stack == 0 then\n        -- If there are brackets\
    \ on the stack, but no brackets on the stack...\n        -- ...then push a bracket\
    \ onto the stack\n        brackets[#brackets+1] = 1\n      ", "   -- Initialize\
    \ the counter\n   local nesting = 0\n   \n   -- Iterate over every character in\
    \ the string\n   for i = 1,#string do\n      -- Increment the counter\n      nesting\
    \ = nesting + 1\n      \n      -- Check if the current character is a closing\
    \ bracket or end of string\n      if string[i] == '[' or string[i] == ']' or string[i]\
    \ == '}' then\n         -- Decrement the counter\n         nesting = nesting -\
    \ 1\n         \n         -- Check if we reached the desired number of brackets\n\
    \         if nesting == 0 then\n            return true\n         end\n      end\n\
    \   end\n   return false\nend", "   for i = 1, #string do\n      local c = string[i]\n\
    \      if c == '[' or c == '{' then\n         return true\n      end\n      if\
    \ c == '}' or c == ']' then\n         return false\n      end\n   end\n   return\
    \ true\nend", "\t-- Check for any opening (\n\t-- >>> is_nested('[[[][]')\n\t\
    -- true\n\t-- >>> is_nested('[][][[]][][][]')\n\t-- true\n\t-- >>> is_nested('[[[[]][]]][][][[][][][]')\n\
    \t-- true\n\t-- >>> is_nested('[[[[]][]]][][][][[][][')\n\t-- true\n\t-- >>> is_nested('[[[[]][]]][][][][[][][][[]')\n\
    \t-- true\n\t-- >>> is_nested('[[[[]][]]][][][][[][][[][]')\n\t-- false\n\t--\
    \ >>> is_nested('[[[[]][]]][][][][[][][[][][]')\n\t-- false\n\t-- >>> is_nested('[[[[]][]]][][][][[][][[][][]')\n\
    \t-- false\n\t-- >>> is_nested('[[[[]][]]][][][][[][][[][][][]')\n\t-- false\n\
    \t-- >>> is_nested('[[[[]][]]][][][][[][][[][][[][][][]')\n\t-- false\n\t-- >>>\
    \ is_nested('[[[[]][]]][][][][[][][[][][[][][][][][][][][]')\n\t-- false\n\t--\
    \ >>> is_nested('[[[[]][]]][][][][[][][[][][[][][[][][][[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]",
  "  local bracket_stack = {}\n  for char in string:gmatch'[[]' do\n    table.insert(bracket_stack,\
    \ char)\n  end\n  local function count_brackets(stack, count)\n    if not stack\
    \ then\n      return count\n    end\n    count = count + 1\n    if stack[#stack]\
    \ == '[' then\n      return count_brackets(stack[#stack], count)\n    end\n  \
    \  if stack[#stack] == '}' then\n      count = count - 1\n    end\n    return\
    \ count_brackets(stack[#stack], count)\n  end\n  return count_brackets(bracket_stack,\
    \ 1) == 1\nend\nis_nested = make_wrapper(is_nested)", "    local index = 0\n \
    \   while index <= #string do\n        if string[index] ~= '[' then\n        \
    \    if string[index] ~= ']' then\n                return false\n            end\n\
    \        end\n        index = index + 1\n    end\n    return true\nend", "   \
    \ local start = 1 -- To account for the first bracket in the string\n    local\
    \ nesting = 0\n    while start <= string.len(string) do\n        local end = start\
    \ + 1\n        while end <= string.len(string) and string[end] ~= '[' do\n   \
    \         end = end + 1\n        end\n        if end <= string.len(string) then\n\
    \            nesting = nesting + 1\n            start = end + 1\n        else\n\
    \            nesting = nesting - 1\n            if nesting == 0 then\n       \
    \         return true\n            end\n        end\n    end\n    return false\n\
    end", "    local pattern = '^(\\[(?:[^\\]]+\\]){0,%d}\\])*$' % string.len()\n\
    \    return string.find(string, pattern, true) ~= nil\nend", "    return string.gsub('[[]]','').gsub('[[]','')..string.gsub('[[]]','')\n\
    end", "\tlocal stack = {}\n\tlocal pos = 0\n\tlocal inBrackets = false", "\t--\
    \ Create a stack of lists to track all brackets.\n\tlocal stack = {}\n\t-- Loop\
    \ over the string\n\tfor i,c in string.gmatch('%[[]') do\n\t\t-- If the current\
    \ character is a left bracket\n\t\tif c == '[' then\n\t\t\t-- Add it to the stack\n\
    \t\t\tstack[#stack+1] = c\n\t\telse\n\t\t\t-- If the current character is a right\
    \ bracket\n\t\t\tif c == ']' then\n\t\t\t\t-- Remove the last item on the stack\
    \ if it matches right bracket\n\t\t\t\tif stack[#stack] == ']' then\n\t\t\t\t\t\
    stack[#stack] = nil\n\t\t\t\telse\n\t\t\t\t\t-- Remember this item for later\n\
    \t\t\t\t\tstack[#stack+1] = c\n\t\t\t\tend\n\t\t\telse\n\t\t\t\t-- Otherwise there\
    \ must be a closing bracket\n\t\t\t\tprint('Error: Mismatched brackets in string:\
    \ ', string)\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\tend\n\t-- If the stack\
    \ is empty the string does not contain nested brackets\n\treturn #stack > 0\n\
    end", "    local brackets = {{open = '[', close = ']'}} -- Set of brackets\n \
    \   return string.find(string, \"[%[a%d%z%s]\") ~= nil -- Check for an open bracket\n\
    end", "\t-- Create a stack to store all opening brackets.\n\tlocal stack = {}\n\
    \t-- For each character in the string:\n\tfor i=1,#string do\n\t\t-- If the character\
    \ is the opening bracket:\n\t\tif string[i] == '[' then\n\t\t\t-- If the opening\
    \ bracket is not the outermost opening bracket:\n\t\t\tif stack[#stack] ~= nil\
    \ then\n\t\t\t\t-- Pop the opening bracket from the stack and push it on the stack.\n\
    \t\t\t\tstack[#stack]:insert(i)\n\t\t\telse\n\t\t\t\t-- Push the opening bracket\
    \ onto the stack.\n\t\t\t\tstack[#stack] = i\n\t\t\tend\n\t\t-- If the character\
    \ is the closing bracket:\n\t\telseif string[i] == ']' then\n\t\t\t-- If the opening\
    \ bracket is the outermost opening bracket:\n\t\t\tif stack[#stack] == i then\n\
    \t\t\t\t-- Pop the outermost opening bracket from the stack and push it on the\
    \ stack.\n\t\t\t\tstack[#stack]:insert(i)\n\t\t\telse\n\t\t\t\t-- If there are\
    \ no more opening brackets in the stack, then the sequence is nested.\n\t\t\t\t\
    if #stack == 0 then\n\t\t\t\t\treturn true\n\t\t\t\tend\n\t\t\t\t-- Pop the last\
    \ bracket.\n\t\t\t\tlocal last = stack[#stack]\n\t\t\t\t-- If the last bracket's\
    \ closing bracket is the current opening bracket:\n\t\t\t\tif last[last]:equal(i)\
    \ then\n\t\t\t\t\t-- Pop the last bracket.\n\t\t\t\t\tstack[#stack]:insert(last)\n\
    \t\t\t\telse\n\t\t\t\t\t-- Otherwise, there is an extra opening bracket.\n\t\t\
    \t\t\treturn false\n\t\t\t\tend\n\t\t\tend\n\t\t-- If the character is the asterisk:\n\
    \t\telseif string[i] == '*' then\n\t\t\t-- If the opening bracket is not the outermost\
    \ opening bracket:\n\t\t\tif stack[#stack] ~= nil then\n\t\t\t\t-- Pop the asterisk\
    \ from the stack and push it on the stack.\n\t\t\t\tstack[#stack]:insert(i)\n\t\
    \t\telse\n\t\t\t\t-- Push the asterisk onto the stack.\n\t\t\t\tstack[#stack]\
    \ = i\n\t\t\tend\n\t\t-- If the character is the ampersand:\n\t\telseif string[i]\
    \ == '&' then\n\t\t\t-- If the opening bracket is not the outermost opening bracket:\n\
    \t\t\tif stack[#stack] ~= nil then\n\t\t\t\t-- Pop the ampersand from the stack\
    \ and push it on the stack.\n\t\t\t\tstack[#stack]:insert(i)\n\t\t\telse\n\t\t\
    \t\t-- Push the ampersand onto the stack.\n\t\t\t\tstack[#stack] = i\n\t\t\tend\n\
    \t\t-- If the character is the pipe:\n\t\telseif string[i] == '|' then\n\t\t\t\
    -- If the ", "\treturn (string.find('[[[']) == 0)\nend", "   local n = string.find(string,'[')\n\
    \   if n ~= nil then\n      if string.find(string,']',n+1) ~= nil then\n     \
    \    return true\n      else\n         return false\n      end\n   else\n    \
    \  return true\n   end\nend", "\treturn string.find(string, \"%s*(.-)%s*\") ~=\
    \ nil\nend", "    local result = true\n    for _,c in string.gmatch(string, '%b[]')\
    \ do\n        result = result and c == '[' and string.find(string, '%b[][%b',\
    \ _, 1) or c == ']' and string.find(string, '%b[][%b]', _, -1) or c == ']'\n \
    \   end\n    return result\nend", "\tif string.find(string, '%[[]') ~= nil then\n\
    \t\treturn true\n\telse\n\t\treturn false\n\tend\nend", "\t-- Return the index\
    \ where a square bracket is first found within the string.\n\tlocal function find_first_bracket(string,\
    \ index)\n\t\tindex = index or 1\n\t\tlocal bracket = string.sub(string,index+1,index+2)\n\
    \t\tlocal start = index+3\n\t\tlocal stop\n\t\tif string.find(bracket,'[',index+1)\
    \ then\n\t\t\t-- If a string is found within brackets, continue scanning the string\
    \ until\n\t\t\t-- another square bracket is found or the end of the string is\
    \ reached.\n\t\t\tstop = (string.find(bracket,'[',index+2))-1\n\t\telse\n\t\t\t\
    -- If a string is found outside of brackets, return -1 indicating that\n\t\t\t\
    -- the string is not within brackets.\n\t\t\treturn -1\n\t\tend\n\t\treturn start,\
    \ stop\n\tend", "\t-- Base case\n\tif not string then\n\t\treturn false\n\tend",
  "\t-- (1) Remove all brackets from the string.\n\tstring = string.gsub('[[]','')\n\
    \t-- Remove all nested brackets from the string.\n\tstring = string.gsub('[[][]','[]')\n\
    \t-- Return the string after removing all unnecessary brackets.\n\treturn string.gsub('[[]]','')\n\
    end", "\tif string == '' or string == '[' then return false end\n\tlocal index\
    \ = 1\n\twhile string.sub(string,index,index+2) == '[]' do\n\t\tindex = index\
    \ + 2\n\tend\n\t\n\treturn string.sub(string,1,index) == '['\nend", "  -- First\
    \ split the string into brackets.\n  local brackets = string.gsub(string, '[',\
    \ ' ')\n  local brackets = string.gsub(brackets, ']', ' ')\n  -- If the number\
    \ of opening and closing brackets in the string is even, then\n  -- there are\
    \ no nested brackets.\n  if string.len(brackets) % 2 == 0 then\n    return false\n\
    \  end\n  -- Otherwise, try and split each bracket into a subsequence until you\
    \ find one\n  -- where each bracket is nested. \n  -- If any subsequence contains\
    \ more than one open and close bracket,\n  -- then there is a nested bracket sequence.\n\
    \  local nested = false\n  local subsequences = {}\n  for i = 1, string.len(brackets)\
    \ do\n    local opening_brackets, closing_brackets = string.match(brackets, \n\
    \                                                '%%.-([%[]%]%.-)')\n    if opening_brackets\
    \ ~= nil then\n      -- If the next opening bracket has a closing bracket, then\n\
    \      -- there was a nested bracket sequence\n      nested = nested or string.len(closing_brackets)\
    \ > 0\n      subsequences[i] = opening_brackets\n    end\n  end\n  -- If this\
    \ was the first nested bracket sequence, then there is no\n  -- nested brackets.\
    \ \n  if not nested and subsequences[1] ~= nil then\n    return false\n  end\n\
    \  -- If this was a nested bracket sequence and there was no closing bracket,\n\
    \  -- then there is no nested brackets.\n  if nested and string.len(subsequences[1])\
    \ == 0 then\n    return false\n  end\n  -- Otherwise, there are nested brackets.\n\
    \  return true\nend", "\tif string.sub(1, 1)==\"[\" then\n\t\treturn string.sub(string.sub(1,\
    \ string.len(1)-1), string.len(1)) == \"[\" \n\telse\n\t\treturn string.sub(1,\
    \ string.len(1)-1) == \"[\" \n\tend\nend", "\tlocal index = string.find('[[')\n\
    \tif index == nil then\n\t\treturn false\n\telse\n\t\treturn string.find(string,\
    \ '[]]', index+2) ~= nil\n\tend\nend", "\tlocal start = 1\n\twhile start <= #string\
    \ do\n\t\tlocal open_count = 0\n\t\tlocal close_count = 0\n\t\tlocal close = 0\n\
    \t\twhile start <= #string do\n\t\t\tif string[start] == '[' then\n\t\t\t\topen_count\
    \ = open_count + 1\n\t\t\telseif string[start] == ']' then\n\t\t\t\tclose_count\
    \ = close_count + 1\n\t\t\t\tif open_count == close_count then\n\t\t\t\t\tclose\
    \ = close + 1\n\t\t\t\tend\n\t\t\tend\n\t\t\tstart = start + 1\n\t\tend\n\t\t\
    if open_count ~= close_count or close ~= 0 then\n\t\t\treturn false\n\t\tend\n\
    \tend\n\treturn true\nend", "\tlocal pos = 1\n\tlocal bracket = 0\n\tlocal bracket_count\
    \ = 0\n\tlocal stack = { string }\n\tfor i=1,#string do -- Search for opening\
    \ bracket\n\t\tif string[i] == '[' then -- New opening bracket\n\t\t\tbracket\
    \ = bracket + 1\n\t\telseif string[i] == ']' then -- Closing bracket\n\t\t\tbracket\
    \ = bracket - 1\n\t\t\tif bracket < 0 then -- Error check\n\t\t\t\treturn false\n\
    \t\t\telseif bracket == 0 then -- Check if there are nested brackets\n\t\t\t\t\
    -- Add closing bracket to the stack\n\t\t\t\tlocal current_string = stack[#stack]\n\
    \t\t\t\tif current_string[pos] == '[' or current_string[pos] == ']' then\n\t\t\
    \t\t\tstack[#stack] = string[#string] -- Replace current string with closing bracket\n\
    \t\t\t\tend\n\t\t\t\t-- Check if there are any remaining opening brackets in the\
    \ stack\n\t\t\t\tlocal open_brackets = 0\n\t\t\t\tfor index=#stack,1,-1 do\n\t\
    \t\t\t\tif stack[index] == '[' then\n\t\t\t\t\t\topen_brackets = open_brackets\
    \ + 1\n\t\t\t\t\tend\n\t\t\t\t\tif stack[index] == ']' then\n\t\t\t\t\t\topen_brackets\
    \ = open_brackets - 1\n\t\t\t\t\tend\n\t\t\t\t\tif open_brackets == 0 then\n\t\
    \t\t\t\t\treturn true -- Valid subsequence\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\
    end\n\t\tend\n\t\tpos = pos + 1\n\tend\n\treturn false\nend", "    if string==\"\
    []\" or string==\"[][]\" or string==\"[][][]\" or string==\"[][][][][]\" or string==\"\
    [][][][][][][][][]\" then\n        return true\n    else\n        return false\n\
    \    end\nend", "    local nesting_levels = { } -- tracks number of open/closed\
    \ brackets\n    local open_brackets = {  } -- stores number of brackets open at\
    \ each nesting level\n    for i,c in ipairs(string) do\n        if c == '[' then\n\
    \            nesting_levels[#nesting_levels+1] = 1\n            open_brackets[#open_brackets+1]\
    \ = 1\n        elseif c == ']' then\n            nesting_levels[#nesting_levels+1]\n\
    \            if nesting_levels[#nesting_levels+1] == 1 then\n                nesting_levels[#nesting_levels+1]\
    \ = 0\n                open_brackets[#open_brackets+1] = open_brackets[#open_brackets+1]\
    \ - 1\n            end\n        elseif nesting_levels[#nesting_levels] == 1 then\n\
    \            nesting_levels[#nesting_levels] = 0\n            open_brackets[#open_brackets+1]\
    \ = open_brackets[#open_brackets+1] + 1\n        end\n    end\n    return #open_brackets\
    \ > 0\nend", "  -- Initialize our return value\n  local result = true", "\tlocal\
    \ nested, i, j, open = 0, 1, 1, 0\n\tfor j = 1, #string do\n\t\tif string[j] ==\
    \ '[' then\n\t\t\tnested = nested + 1\n\t\t\tif nested == 1 then\n\t\t\t\topen\
    \ = open + 1\n\t\t\tend\n\t\telseif string[j] == ']' then\n\t\t\tnested = nested\
    \ - 1\n\t\t\tif nested < 0 and open == 0 then\n\t\t\t\treturn false\n\t\t\tend\n\
    \t\t\topen = open - 1\n\t\tend\n\tend\n\treturn true\nend", "   -- TODO: implement\
    \ here\nend", "  local n = 1\n  repeat\n    local open_bracket = string.find(string,\
    \ '[', n)\n    local close_bracket = string.find(string, ']', n)\n    if open_bracket\
    \ ~= nil and close_bracket ~= nil then return false end\n    n = open_bracket\
    \ + 1 -- The next position in string is the position right after the closing bracket\n\
    \  until open_bracket ~= nil or close_bracket ~= nil end\n  return true\nend",
  "    -- Special cases.\n    if string == '[' then\n        return true\n    elseif\
    \ string == '{' then\n        return true\n    elseif string == '(' then\n   \
    \     return true\n    elseif string == '}' then\n        return true\n    end",
  "    -- TODO: Your code here\nend", "\treturn not string.find(string, \"%[(%a%[[]))-\"\
    ))\nend", "  return string.find(string, '[{') == 0 or string.find(string, '{')\
    \ == 0 or\n    string.find(string, '[') == 0 or string.find(string, ']') == 0\
    \ or\n    string.find(string, '(') == 0 or string.find(string, ')') == 0 or\n\
    \    string.find(string, '<') == 0 or string.find(string, '>') == 0 or\n    string.find(string,\
    \ '{') == 0 or string.find(string, '}') == 0 or\n    string.find(string, '[')\
    \ == 0 or string.find(string, ']') == 0 or\n    string.find(string, '<') == 0\
    \ or string.find(string, '>') == 0 or\n    string.find(string, '>') == 0 or string.find(string,\
    \ '<') == 0\nend", "\tlocal open_bracket = string.find(string, '[')\n\tlocal close_bracket\
    \ = string.find(string, ']')\n\t\n\treturn (open_bracket and close_bracket)\n\
    end", "    if string == nil then\n        return nil\n    end", "  local index\
    \ = 0\n  -- If the string contains at least one non-bracket character it must\
    \ contain at least one nested bracket.\n  -- Otherwise it contains no nested bracket.\n\
    \  return (string:sub(1, 1) ~= '[') and (index:match('^([[]]*)$') == nil)\nend",
  "\tlocal brackets = string.gsub(string, '[]', '{}')\n\tlocal nesting = string.gsub(brackets,\
    \ '{{', '}')\n\treturn nesting ~= '{}'\nend", "   -- Start with a false boolean\
    \ value.\n   -- The goal is to find the first position\n   -- where a string contains\
    \ only square brackets,\n   -- then increment the counter value \n   -- by 1 so\
    \ that it points to the next \n   -- position that contains only brackets.\n \
    \  -- Then move the counter to that position.\n   -- If the counter reaches the\
    \ end of string without \n   -- finding a match, we return false.\n   if string\
    \ == \"\" then\n      return false\n   end", "   -- Create a stack by splitting\
    \ the string into characters and adding the characters\n   -- onto a stack.\n\
    \   local stack = {}\n   for symbol in string.gmatch(\"[^]]+\") do table.insert(stack,symbol)\
    \ end", "    local opens = string\n    local open_index = 1\n    local closed\
    \ = {}\n    local open", "\t-- Base case\n\tif not string then\n\t\treturn false\n\
    \tend", "    -- No substring of the brackets contains another bracket.\n    if\
    \ string == '[]' then\n        return true\n    end\n    -- Iterate from the left\
    \ until we find a bracket.\n    for i=1, #string-1 do\n        if string[i] ~=\
    \ '[' or string[i+1] ~= '[' then\n            return false\n        end\n    end\n\
    \    -- Iterate from the right until we find a bracket.\n    for i=#string+1,\
    \ #string do\n        if string[i] ~= ']' or string[i-1] ~= ']' then\n       \
    \     return false\n        end\n    end\n    -- Iterate from the left until we\
    \ find an opening.\n    for i=1, #string-1 do\n        if string[i] ~= '[' then\n\
    \            return false\n        end\n    end\n    return true\nend", "   --\
    \ to determine if there are nested brackets\n   local open_brackets, closed_brackets\
    \ = 0, 0\n   for i=1,#string do\n      if string[i] == '[' then\n         open_brackets\
    \ = open_brackets + 1\n      elseif string[i] == ']' then\n         closed_brackets\
    \ = closed_brackets + 1\n      elseif open_brackets > closed_brackets then\n \
    \        return true\n      end\n   end\n   return false\nend", "\t-- Only square\
    \ brackets\n\tstring = string.gsub('[[]','')\n\t-- Nested brackets must have the\
    \ same length\n\tlocal brackets_count = string.find('[','[',1,string.find(string,'[',1,true))\n\
    \tif brackets_count ~= string.len(string) or string.find(string,'[',1,true) ~=\
    \ nil then\n\t\treturn false\n\tend\n\t-- If brackets are balanced, this substring\
    \ will contain at least one nested bracket\n\tlocal balanced_brackets = string.gsub(string,'(',''):gsub(')',''):gsub('[',''):gsub(']',''):gsub(']',')')\n\
    \t-- If balanced, all brackets are closed\n\tif string.find(balanced_brackets,'(',1,true)\
    \ ~= nil then\n\t\treturn true\n\tend\n\treturn false\nend", "    -- Write your\
    \ code here.\nend", "\tstring = string.string\n\tlocal i, j, k, l, m, n, o, p\n\
    \ti = j = k = l = m = n = o = p = nil\n\tif string.find(string, \"[\") ~= nil\
    \ then return true end\n\tfor k = string.len(string, 1, string.length - 1), p\
    \ = 1, string.length - 1 do\n\t\t-- Check if we find an opening bracket.\n\t\t\
    if string.sub(string,k,k) == \"[\" then \n\t\t\tif string.find(string, \"[\",\
    \ p + 1, k) ~= nil then \n\t\t\t\t-- We found a bracket inside the bracket. Now\
    \ check if there are nested brackets within this bracket.\n\t\t\t\tfor l = string.len(string,\
    \ 1, k - 1), m = 1, k - 1 do\n\t\t\t\t\tif string.sub(string,m,m) == \"[\" then\
    \ \n\t\t\t\t\t\tif string.find(string, \"[\", m + 1, m) ~= nil then return true\
    \ end\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\treturn true\n\t\t\tend\n\
    \t\tend\n\tend\n\treturn false\nend", "   for idx = 1, #string do\n      local\
    \ c = string.sub(string,idx,idx)\n      if c == '[' then return true end\n   \
    \   if c == '{' or c == '(' then return false end\n   end\n   return false\nend",
  "\t-- Create a stack of brackets.\n\tlocal brackets = {}\n\t\n\t-- Go through the\
    \ string, and go through each character in turn.\n\tfor i, v in pairs(string)\
    \ do\n\t\t-- If the character is \"[\", push onto the stack.\n\t\tif v == '['\
    \ then\n\t\t\ttable.insert(brackets, 1)\n\t\t-- If the character is \"]\", remove\
    \ 1 from the stack of brackets.\n\t\telseif v == ']' then\n\t\t\tif table.remove(brackets,\
    \ 1) == 0 then return false end\n\t\t-- If the character is not \"[\" or \"[\"\
    , just count the brackets.\n\t\telse\n\t\t\ttable.insert(brackets, v)\n\t\tend\n\
    \tend\n\t\n\t-- No nested brackets\n\tif #brackets == 0 then return true end\n\
    \t\n\t-- More than 1 nested bracket\n\treturn #brackets > 1\nend", "  return string.find(string,\
    \ '[') == -1 or string.find(string, ']') == -1\nend", "\tlocal i, j, l = 1, #string,\
    \ 1, 1\n\t\n\twhile i < j do\n\t\tif string[i] == '[' then\n\t\t\tif string[j]\
    \ == ']' then\n\t\t\t\tj = j + 1\n\t\t\telse\n\t\t\t\ti = i + 1\n\t\t\t\tj = j\
    \ + 1\n\t\t\tend\n\t\telseif string[i] == ']' then\n\t\t\ti = i + 1\n\t\t\tj =\
    \ j - 1\n\t\telse\n\t\t\tl = l + 1\n\t\tend\n\tend\n\t\n\treturn l > 1\nend",
  "\tlocal bracket_pattern = '^[%[%(%+%-]+%)%]%(%+%-)]%-[%%(%-)]*$'\n\tlocal nested\
    \ = false\n\tstring.gsub(string, \"[%[%(%+%-]+%)%]%(%+%-)\", function (bracket)\n\
    \t\tif nested then return false end\n\t\tif string.find(bracket, \"[%[%(%+%-]+%)%]%(%+%-)]\"\
    , 1, true, true) then\n\t\t\tnested = true\n\t\tend\n\tend)\n\treturn nested\n\
    end", "\t-- Create a copy of the string so that we can modify it\n\tlocal copy\
    \ = string\n\t-- Search for the first and last bracket pair\n\tlocal first = true\n\
    \tlocal last = true\n\tlocal firstLast = false\n\t-- Count number of brackets\
    \ in string\n\tlocal brackets = 0\n\twhile first or last do\n\t\t-- Check if we\
    \ are at a bracket\n\t\tif first then\n\t\t\t-- If we are at the first bracket,\
    \ skip to the next bracket\n\t\t\tif last then\n\t\t\t\t-- We have found the last\
    \ bracket. Stop searching for more brackets.\n\t\t\t\tfirst = false\n\t\t\telse\n\
    \t\t\t\t-- We are NOT at the last bracket. Look ahead to find first bracket\n\t\
    \t\t\tlast = true\n\t\t\t\tfirstLast = copy\n\t\t\t\tbrackets = brackets + 1\n\
    \t\t\tend\n\t\telseif last then\n\t\t\t-- If we are at the last bracket, skip\
    \ to the first bracket\n\t\t\tif first then\n\t\t\t\t-- We have found the first\
    \ bracket. Stop searching for more brackets.\n\t\t\t\tlast = false\n\t\t\telse\n\
    \t\t\t\t-- We are NOT at the first bracket. Look behind to find last bracket\n\
    \t\t\t\tfirst = true\n\t\t\t\tfirstLast = copy\n\t\t\t\tbrackets = brackets +\
    \ 1\n\t\t\tend\n\t\telseif copy == '[' then\n\t\t\t-- If we are at a bracket,\
    \ skip to the next bracket\n\t\t\tif last then\n\t\t\t\tlast = false\n\t\t\telse\n\
    \t\t\t\t-- We are NOT at the last bracket. Look ahead to find first bracket\n\t\
    \t\t\tlast = true\n\t\t\t\tfirstLast = copy\n\t\t\t\tbrackets = brackets + 1\n\
    \t\t\tend\n\t\telseif copy == ']' then\n\t\t\t-- If we are at a bracket, skip\
    \ to the next bracket\n\t\t\tif first then\n\t\t\t\tfirst = false\n\t\t\telse\n\
    \t\t\t\t-- We are NOT at the last bracket. Look behind to find last bracket\n\t\
    \t\t\tfirst = true\n\t\t\t\tfirstLast = copy\n\t\t\t\tbrackets = brackets + 1\n\
    \t\t\tend\n\t\tend\n\t\t-- Move to the next bracket\n\t\tif brackets > 0 then\n\
    \t\t\tlocal nextCopy = copy:sub(1,1)\n\t\t\tif nextCopy == ']' then\n\t\t\t\t\
    brackets = brackets - 1\n\t\t\telseif nextCopy == ']' then\n\t\t\t\tbrackets =\
    \ brackets - 1\n\t\t\telseif nextCopy == ']' then\n\t\t\t\tbrackets = brackets\
    \ - 1\n\t\t\telseif nextCopy == '[' then\n\t\t\t\tbrackets = brackets - 1\n\t\t\
    \tend\n\t\tend\n\tend\n\t-- Return the result\n\treturn firstLast == '['\nend",
  "\treturn string.find(string, '[[]') ~= nil\nend", "    local stack = {}\n    for\
    \ i = 1, #string do\n        if string.sub(string, i, i) ~= ']' then\n       \
    \     stack[#stack+1] = string.sub(string, i, i)\n        end\n    end\n    if\
    \ stack[1] == '[' then\n        stack[1] = ']'\n    elseif stack[1] == ']' then\n\
    \        stack[1] = ']'\n        stack[#stack+1] = '['\n    elseif stack[#stack+1]\
    \ == '[' then\n        stack[#stack+1] = ']'\n        stack[#stack+1] = '['\n\
    \    end\n    return stack[1] == '[' and stack[#stack+1] == ']'\nend", "\tif string\
    \ == nil then return false end\n\tlocal count = 1\n\tlocal open = 0\n\tlocal close\
    \ = 0\n\tlocal pos = 0\n\twhile pos < string.leng do\n\t\tlocal c = string.sub(string,\
    \ pos, pos)\n\t\tcount = count + 1\n\t\tif open == 0 and c == '[' then\n\t\t\t\
    open = count\n\t\telseif open == count and c == '[' then\n\t\t\topen = count\n\
    \t\telseif close == 0 and c == '}' then\n\t\t\tclose = count\n\t\telseif close\
    \ == count and c == '}' then\n\t\t\tclose = count\n\t\tend\n\t\tpos = pos + 1\n\
    \tend\n\tif close ~= open then\n\t\treturn false\n\tend\n\tlocal pos = 0\n\tlocal\
    \ close = 0\n\tlocal open = 0\n\tlocal brackets = ''\n\twhile pos < string.leng\
    \ do\n\t\tlocal c = string.sub(string, pos, pos)\n\t\tcount = count + 1\n\t\t\
    if open == 0 and c == '[' then\n\t\t\topen = count\n\t\telseif open == count and\
    \ c == '[' then\n\t\t\topen = count\n\t\telseif close == 0 and c == '}' then\n\
    \t\t\tclose = count\n\t\telseif close == count and c == '}' then\n\t\t\tclose\
    \ = count\n\t\telseif close == 0 and c == '[' then\n\t\t\tclose = count\n\t\t\
    elseif open == count and c == ']' then\n\t\t\topen = count\n\t\telseif open ==\
    \ count and c == ']' then\n\t\t\topen = count\n\t\telse\n\t\t\tbrackets = brackets\
    \ .. c\n\t\tend\n\t\tpos = pos + 1\n\tend\n\tif close ~= open then\n\t\treturn\
    \ false\n\tend\n\tbrackets = brackets .. ']'\n\treturn brackets\nend", "    if\
    \ string == '' then\n        return false\n    end\n    \n    local stack = {}\n\
    \    for i = 1, #string do\n        if string.sub(i, i, i) == '[' then\n     \
    \       stack = stack ~= nil and stack or {}\n            table.insert(stack,\
    \ string.sub(i, i, i))\n        elseif string.sub(i, i, i) == ']' then\n     \
    \       stack = stack and stack[#stack] or nil\n            if stack == nil then\n\
    \                return false\n            else\n                stack[#stack]\
    \ = nil\n            end\n        end\n    end\n    return true\nend", "    if\
    \ not string then return false end\n    \n    local open_brackets = 0 -- Number\
    \ of open brackets\n    local open_brackets_stack = {} -- Stack of open brackets\n\
    \    for i = 0, #string do\n        local character = string.sub(string,i,i)\n\
    \        if character == '[' then\n            open_brackets = open_brackets +\
    \ 1\n            open_brackets_stack[open_brackets] = character\n        elseif\
    \ character == ']' then\n            open_brackets = open_brackets - 1\n     \
    \       if open_brackets < 0 then\n                return false\n            end\n\
    \            local open_character = open_brackets_stack[open_brackets]\n     \
    \       open_brackets_stack[open_brackets] = nil\n            if character ~=\
    \ open_character then\n                return false\n            end\n       \
    \ end\n    end\n    return true\nend", "  return string.gsub('%s+','').gsub('[[]%]','[')\
    \ ~= string\nend", "\treturn string.find(string, '[[]') ~= nil\nend", "    local\
    \ brackets = '[]'\n    local open = 0\n    for i = 1, #string do\n        if string.sub(string,i,i)\
    \ == brackets then\n            open = open + 1\n        elseif open == 0 then\n\
    \            return false\n        end\n    end\n    return open == 1\nend", " \
    \   local opening_brackets = 0\n    for i,c in string.gmatch( string, \"%[[]\"\
    \ ) do\n        if c == \"[\" then\n            opening_brackets = opening_brackets\
    \ + 1\n        elseif c == \"]\" then\n            opening_brackets = opening_brackets\
    \ - 1\n        elseif opening_brackets == 0 then\n            return false\n \
    \       end\n    end\n    return opening_brackets == 0\nend", "    if string ==\
    \ nil then return nil end\n    local open_brackets = string.gsub(string, \"[\"\
    , \"\")\n    local close_brackets = string.gsub(string, \"]\", \"\")\n    local\
    \ open_brackets_count = string.len(open_brackets)\n    local close_brackets_count\
    \ = string.len(close_brackets)\n    local brackets_count = open_brackets_count\
    \ + close_brackets_count\n    local count = brackets_count + 1\n    return open_brackets_count\
    \ ~= close_brackets_count and\n           open_brackets_count > 0 and open_brackets_count\
    \ ~= brackets_count and\n           open_brackets_count < close_brackets_count\
    \ and\n           close_brackets_count > 0 and close_brackets_count ~= brackets_count\
    \ and\n           brackets_count ~= 0\nend", "    -- Check for empty string.\n\
    \    if string == '' then\n        return true\n    end\n    \n    -- Check for\
    \ opening bracket.\n    if string.sub(1, 1) == ']' then\n        return is_nested(string.sub(1,\
    \ 2))\n    end\n    \n    -- Check for closing bracket.\n    if string.sub(1,\
    \ 1) == ']' then\n        return is_nested(string.sub(1, 2))\n    end\n    \n\
    \    -- Check for opening bracket.\n    if string.sub(1, 2) = '[' then\n     \
    \   return is_nested(string.sub(2, 3))\n    end\n    \n    -- Check for closing\
    \ bracket.\n    if string.sub(1, 2) = '[' then\n        return is_nested(string.sub(2,\
    \ 3))\n    end\n    \n    -- Check for opening bracket.\n    if string.sub(1,\
    \ 1) = '[' then\n        return is_nested(string.sub(2, 2))\n    end\n    \n \
    \   -- Check for closing bracket.\n    if string.sub(1, 1) = '[' then\n      \
    \  return is_nested(string.sub(2, 2))\n    end\n    \n    -- Check for closing\
    \ bracket.\n    if string.sub(1, 2) = '{' then\n        return is_nested(string.sub(3,\
    \ 4))\n    end\n    \n    -- Check for opening bracket.\n    if string.sub(1,\
    \ 2) = '{' then\n        return is_nested(string.sub(3, 4))\n    end\n    \n \
    \   -- Check for closing bracket.\n    if string.sub(1, 1) = '{' then\n      \
    \  return is_nested(string.sub(3, 2))\n    end\n    \n    -- Check for closing\
    \ bracket.\n    if string.sub(1, 2) = '(' then\n        return is_nested(string.sub(3,\
    \ 4))\n    end\n    \n    -- Check for opening bracket.\n    if string.sub(1,\
    \ 2) = '(' then\n        return is_nested(string.sub(3, 4))\n    end\n    \n \
    \   -- Check for closing bracket.\n    if string.sub(1, 1) = '(' then\n      \
    \  return is_nested(string.sub(3, 2))\n    end\n    \n    -- Check for closing\
    \ bracket.\n    if string.sub(1, 1) = '[' then\n        return is_nested(string.sub(2,\
    \ 3))\n    end\n    \n    -- Check for closing bracket.\n    if string.sub(1,\
    \ 2) = '[' then\n        return is_nested(string.sub(2, 3))\n    end\n    \n \
    \   -- Check for closing bracket.\n    if string.sub(1, 1) = '{' then\n      \
    \  return is_nested(string.sub(3, 4))\n    end\n    \n    -- Check for closing\
    \ bracket.\n    if string.sub(1, 2) = '(' then\n        return is_nested(string.sub(3,\
    \ 4))\n    end\n    \n    -- Check for closing bracket.\n    if string.sub(1,\
    \ 1) = '(' then\n        return is_nested(string.sub(3, 2))\n    end\n    \n \
    \   -- Check for closing bracket.\n    if string.sub(1, 1) = '[' then\n", "  local\
    \ start, index, stack = 0, 1, {}\n  while index <= #string do\n    if string[index]\
    \ == '[' then\n      table.insert(stack, string[index])\n      index = index +\
    \ 1\n    elseif string[index] == ']' then\n      if stack[#stack] == string[index]\
    \ then\n        start = start + 1\n      else\n        return false\n      end\n\
    \      index = index + 1\n    else\n      return false\n    end\n  end\n  return\
    \ start == 0\nend", "\treturn string.find(string, '^%[(%[[][%][]%]]*)%]') ~= nil\n\
    end", "\tif string == nil then return end\n\tlocal open_brackets, close_brackets\
    \ = 0, 0\n\t\n\tfor c, c in string:gmatch(\"[%[]\") do\n\t\tif c == '[' then open_brackets\
    \ = open_brackets + 1 \n\t\tif c == ']' then close_brackets = close_brackets +\
    \ 1 \n\tend", "   -- A valid subsequence is either a bracket nesting one more\
    \ time or more times, \n   -- or an opening or closing bracket\n   return (string.find(string,\
    \ \"[[\") == 1) or (string.find(string, \"]]\") == string.len(string) - 1) or\
    \ (string.find(string, \"{\") == string.find(string, \"}\"))\nend", "\tlocal count\
    \ = 0\n\tfor i = 1, #string do\n\t\tif string[i] ~= '[' and string[i] ~= ']' then\n\
    \t\t\treturn false\n\t\tend\n\t\tcount = count + 1\n\tend\n\treturn count % 2\
    \ == 1\nend", "\t-- A valid sequence must contain at least one bracket in the\
    \ subsequence and \n\t-- all the brackets in the sequence must be nested.\n\t\
    -- An empty string is an invalid sequence.\n\tif string == '' or string == '[]'\
    \ then\n\t\treturn false\n\tend\n\t-- An invalid sequence must not contain any\
    \ brackets.\n\t-- An empty string is an invalid sequence.\n\tif string.find(string,\
    \ '[]') then\n\t\treturn false\n\tend\n\t-- A valid sequence must contain at least\
    \ one nested bracket.\n\t-- An empty string is an invalid sequence.\n\tif string.find(string,\
    \ '[{]') then\n\t\treturn true\n\tend\n\t-- An invalid sequence must not contain\
    \ any nested brackets.\n\t-- An empty string is an invalid sequence.\n\tif string.find(string,\
    \ '[{]') == 1 then\n\t\treturn false\n\tend\n\treturn is_nested(string:sub(1,\
    \ string.find(string, '[')-1))\nend", "\tlocal open_bracket = '['\n\tlocal close_bracket\
    \ = ']'\n\tlocal open_brackets = string.gsub(string, open_bracket, '|')\n\tlocal\
    \ close_brackets = string.gsub(string, close_bracket, '|')\n\treturn (open_brackets\
    \ == '|')\nend", "  local brackets = string.gsub(string, '[]', '{}')\n  brackets\
    \ = string.gsub(brackets, '{', '{}')\n  brackets = string.gsub(brackets, '}',\
    \ '{}')\n  brackets = string.gsub(brackets, '{}', '{}')\n  brackets = string.gsub(brackets,\
    \ '{}', '{}')\n  return string.find(brackets, '{}') == nil\nend", "    local pattern\
    \ = \n        '^[[\\[]*\\[?\\[\\[?[[\\[]*\\]?\\]?\\]?\\]?\\]?$';\n    \n    local\
    \ result = string.find(string, pattern);\n    return result ~= nil and string.len(result)\
    \ == string.len(string) - string.len(pattern);\nend", "   -- TODO: Implement this\
    \ function\n   return true\nend", "\t-- Start by checking if there's an even number\
    \ of brackets\n\tif string.find(string, '[') ~= nil then\n\t\tlocal open_bracket\
    \ = string.find(string, '[')\n\t\tlocal close_bracket = string.find(string, ']')\n\
    \t\tif open_bracket ~= nil and close_bracket ~= nil then\n\t\t\t-- The string\
    \ contains at least two brackets\n\t\t\treturn true\n\t\telseif open_bracket ~=\
    \ nil and not ((close_bracket ~= nil and open_bracket < close_bracket)) then\n\
    \t\t\t-- The string contains at least one bracket\n\t\t\treturn false\n\t\telse\n\
    \t\t\t-- The string contains no brackets\n\t\t\treturn true\n\t\tend\n\telse\n\
    \t\t-- The string has no brackets\n\t\treturn false\n\tend\nend", "\tlocal pos\
    \ = 1\n\tlocal open_count = 0\n\tlocal close_count = 0\n\t\n\twhile pos < #string\
    \ do\n\t\t\n\t\tif string[pos] == '[' then\n\t\t\topen_count = open_count + 1\n\
    \t\telseif string[pos] == ']' then\n\t\t\tclose_count = close_count + 1\n\t\t\
    end\n\t\t\n\t\tpos = pos + 1\n\tend\n\t\n\tif open_count == close_count then\n\
    \t\treturn true\n\telse\n\t\treturn false\n\tend\nend", "    return string.find(string,\
    \ '[]') ~= nil\nend", "    if string.find(string, '^[' .. [[[']) then\n      \
    \  return true\n    end\n    return false\nend", "  return not (string.find(string,\
    \ '[') ~= nil)\nend", "    local bracket_open = 0\n    local bracket_close = 0\n\
    \    for i = 1, #string do\n        -- If the current character is a '[' then\
    \ increment the counter of open brackets.\n        if string[i] == '[' then\n\
    \            bracket_open = bracket_open + 1\n        -- If the current character\
    \ is a ']' then decrement the counter of close brackets.\n        elseif string[i]\
    \ == ']' then\n            bracket_close = bracket_close - 1\n        end\n  \
    \  end\n    return (bracket_open == 0 and bracket_close == 0)\nend", "\t-- Check\
    \ to make sure there's at least one bracket\n\tlocal brackets = string.match(\"\
    [^[\\\\]]+\")\n\tif brackets == nil then\n\t\treturn false\n\tend\n\t\n\t-- If\
    \ there are brackets in the string, check to see if there are enough brackets\
    \ to match the \n\t-- number of brackets in the string. \n\tif #brackets > #string\
    \ then \n\t\treturn false\n\tend\n\t\n\t-- Create a list that will contain all\
    \ of the brackets.\n\tlocal bracketslist = {}\n\tfor i = 1, #string do\n\t\t--\
    \ Add each bracket to the list.\n\t\tbracketslist[#bracketslist + 1] = brackets[i]\n\
    \tend\n\t\n\t-- Sort the list to ensure that all the brackets are in order.\n\t\
    table.sort(bracketslist)\n\t\n\t-- Loop through each bracket in the list. If there\
    \ are brackets inside brackets, it will\n\t-- be nested brackets.\n\tfor i = 1,\
    \ #bracketslist - 1 do\n\t\t-- Find the number of brackets in the list.\n\t\t\
    local numbrackets = #bracketslist[i + 1]\n\t\t\n\t\t-- If the number of brackets\
    \ is equal to the length of the list, then there should be no\n\t\t-- brackets\
    \ inside brackets.\n\t\tif numbrackets == #bracketslist[i + 1], then\n\t\t\treturn\
    \ false\n\t\tend\n\tend\n\t\n\t-- The loop has completed, so the string contains\
    \ at least one bracket that isn't nested.\n\treturn true\nend", "    return string.find(string,\
    \ '[', '') == 1\nend", "  string = string.gsub('[([]]|[[]]', '', string) -- Remove\
    \ any nested square brackets\n  if string ~= '[]' then return false end -- No\
    \ invalid brackets present\n  return string.gsub('(%S+)', '' .. string) ~= '[]'\
    \ -- Remove any nested brackets recursively\nend", "    local brackets = {}\n\
    \    for i = 1, #string do\n        if string.sub(i, i + 1) ~= string.sub(string:sub(i,\
    \ i), i + 1) then\n            brackets[string.sub(i, i + 1)] = true\n       \
    \ elseif string.sub(i, i + 1) ~= '[' and string.sub(i, i + 1) ~= ']' then\n  \
    \          return false\n        end\n    end\n    return #brackets == 0\nend",
  "\tlocal open_brackets = false\n\tlocal closed_brackets = false\n\tlocal found_a_pair\
    \ = false\n\tlocal is_open = false\n\tlocal is_closed = false\n\tfor i, c in string.gmatch(string,\
    \ '[^[]') do\n\t\tassert(c ~= '[')\n\t\tassert(c ~= ']')", "   local index, char\
    \ = string.find(string, \"[]\")\n   if index == nil then\n      index = string.len(string)\n\
    \   end\n   if char == \"[\" then\n      return true\n   elseif char == \"]\"\
    \ and string.sub(string, index - 1, index) == \"[\" then\n      return true\n\
    \   elseif char == \"]\" and string.sub(string, index - 1, index) == \"]\" then\n\
    \      return true\n   else\n      return false\n   end\nend", "    if not string\
    \ then\n        error('string parameter is required')\n    end\n    \n    local\
    \ n = string.find(string, '[', 1, 1)\n    return n and n > 0 \nend", "\tlocal\
    \ pos = 1\n\tlocal n = 1\n\twhile n > 0 do\n\t\tlocal bracket = string.sub( string,\
    \ pos, pos + 1 )\n\t\tif bracket ~= ']' then return false end\n\t\tpos = pos +\
    \ 1\n\t\tn = n - 1\n\tend\n\treturn true\nend", "\tlocal bracket_count = {}\n\t\
    for bracket in string:gmatch'[([]') do bracket_count[bracket] = bracket_count[bracket]\
    \ + 1 end\n\treturn bracket_count[']'] == bracket_count['[']\nend", "\tlocal stack\
    \ = {string[1]}\n\tlocal depth = 1\n\tlocal found = 0\n\t\n\twhile depth > 0 do\n\
    \t\tif stack[1] ~= '[' and stack[1] ~= ']' then\n\t\t\treturn false\n\t\tend\n\
    \t\t\n\t\tif stack[1] ~= '[' then\n\t\t\tfound = 1\n\t\t\tstack = stack[1]\n\t\
    \t\tdepth = depth + 1\n\t\telse\n\t\t\tif stack[2] == '[' then\n\t\t\t\tfound\
    \ = found + 1\n\t\t\t\tstack = stack[2]\n\t\t\t\tdepth = depth + 1\n\t\t\telseif\
    \ stack[2] == ']' then\n\t\t\t\tfound = found + 1\n\t\t\t\tstack = stack[2]\n\t\
    \t\t\tdepth = depth + 1\n\t\t\telse\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\
    \tend\n\t\n\treturn found > 0\nend\n</cell>\n<text>\nExercise 11: Write a function\
    \ that takes a string as input and outputs a string with the square brackets removed.\n\
    The function should take a string input such as\n'[[][]]'\nand output a string\n\
    '[]'\nIf the input is not valid, a message should be displayed\nsuch as 'Input\
    \ must be a square bracket sequence'", "    local stack = {}\n    for letter in\
    \ string:gmatch'[^[]+'  do\n        table.insert(stack, letter)\n    end\n   \
    \ \n    local function is_nested_recursive(stack)\n        local brackets = stack[1]\n\
    \        \n        if #stack < 2 then return false end\n        \n        for\
    \ i = 1, #stack do\n            local current = stack[i]\n            if current\
    \ == '[' then\n                local is_nested = is_nested_recursive({brackets\
    \ .. current})\n                if is_nested then return false end\n         \
    \   elseif current == ']' then\n                return is_nested({brackets ..\
    \ current})\n            elseif current == '}' then\n                if #stack\
    \ == 1 then return false end\n            elseif current == ']' then\n       \
    \         local is_nested = is_nested_recursive({brackets .. current})\n     \
    \           if is_nested then return false end\n            end\n        end\n\
    \        \n        return true\n    end\n    \n    return is_nested_recursive(stack)\n\
    end", "\tlocal position = 0\n\twhile position < string.len() do\n\t\tposition\
    \ = string.find(string, '[', position)\n\t\tif not position then\n\t\t\treturn\
    \ false\n\t\tend", "    local i = 0\n    local openings = 0\n    local closings\
    \ = 0\n    \n    while i < string and openings < closings do\n        if string[i]\
    \ == '[' then\n            openings = openings + 1\n        end\n        if string[i]\
    \ == ']' then\n            closings = closings + 1\n        end\n        i = i\
    \ + 1\n    end", "  -- Your code here\nend", '    if not string then return nil
    end', "  return string.find(string, \"%[\")\nend", "\tif string.match(\"^%[(%[%{%)]%)}%]$\"\
    ) then\n\t\treturn true\n\tend", "\tlocal stack = {}\n\tfor i = 1, #string do\n\
    \t\tif string[i] == '[' then\n\t\t\ttable.insert(stack, string[i])\n\t\telseif\
    \ string[i] == ']' then\n\t\t\tlocal popped = table.remove(stack)\n\t\t\tif not\
    \ popped then\n\t\t\t\treturn false\n\t\t\telseif popped ~= '[' then\n\t\t\t\t\
    return false\n\t\t\telseif #stack == 0 then\n\t\t\t\treturn true\n\t\t\telse\n\
    \t\t\t\treturn false\n\t\t\tend\n\t\telse\n\t\t\tassert(false)\n\t\tend\n\tend\n\
    end", "  -- Write your code here.\n  return true\nend", "\t-- Create a stack to\
    \ keep track of the open brackets.\n\tlocal stack = {}", "    string = string.gsub('[[]]',\
    \ '') -- remove all brackets\n    local nesting = true\n    local nest = 0\n \
    \   local opening = string.find('[')\n    while nesting do\n        if opening\
    \ < 0 then return false end\n        nesting = string.find('[', opening + 1)\n\
    \        nest = nest + 1\n        if opening < 0 then return false end\n     \
    \   opening = string.find('[', opening + 1)\n    end\n    return nest == 0\nend\n\
    </cell>\n<text>\nExercise: Find a pattern where you expect the string to be nested,\
    \ but you find a pattern where it is not", "   if string.find(string, '[]') then\n\
    \      return true\n   else\n      return false\n   end\nend", "  -- If there\
    \ are no open brackets return false\n  if string.len() <= 1 then return false\
    \ end\n  \n  -- If there are no nested brackets return true\n  if string.sub(string,\
    \ 1, string.len() - 2).find('[]') == 0 then return true end\n  \n  -- Go through\
    \ the string and check if the opening bracket is followed by a closing bracket\n\
    \  local open_brackets = string.find(string, '[')\n  -- Return true if there is\
    \ at least one pair of brackets\n  return open_brackets > 0 and not string.find(string,\
    \ ']', open_brackets + 1)\nend", "  -- Write your code here\n  local match = {{}}\n\
    \  for i = 1, #string do\n    if string.sub(string,i,i) == '[' then\n      if\
    \ string.sub(string,i-1,i) ~= '[' then return false end\n      table.insert(match,\
    \ {i, i})\n    else\n      if string.sub(string,i-1,i) ~= ']' then return false\
    \ end\n      table.insert(match, {i, i})\n    end\n  end", "  -- First, remove\
    \ the first and last brackets\n  string = string.sub(1, string.len() - 1)\n  \n\
    \  -- If the string begins and ends with brackets, return true\n  if string.match('[')\
    \ ~= nil and string.match(']') ~= nil then\n    return true\n  end\n  \n  -- Else,\
    \ return false since the string is not valid\n  return false\nend", "  return\
    \ string.find(string, '[[[')]~= nil\nend", "   local openings, closings = string:gsub(\"\
    ^%[(%[())%*%?%*]\", \"\\0\"):gsub(\"%([%[())%*%?%*]\", \"\\0\"):gsub(\"%*%?%*%[(%[())%*%?%*]\"\
    , \"\\0\"):gsub(\"%[(%[())%*%?%*]\", \"\\0\")\n   \n   if not openings or not\
    \ closings then\n      return false\n   end", "\tassert(type(string) == 'string')\n\
    \t-- A subsequence is a valid subsequence of brackets where \n\t-- at least one\
    \ bracket in the subsequence is nested.\n\treturn string.find('[[]') ~= nil\n\
    end", "\t-- Return true if the input string contains only square brackets.\n\t\
    -- Otherwise, return false.\n\t-- This function uses a brute force approach to\
    \ check all possible substrings of square brackets.\n\t-- It checks if the starting\
    \ character is { or [ and then checks if the ending character is } or ].\n\t--\
    \ If the starting character is a [ or {, then the ending character is a ].\n\t\
    -- If the starting character is a {, then the ending character is a }.\n\t-- The\
    \ starting and ending characters are checked by calling is_nested() with the starting\
    \ and ending characters.\n\t-- This approach is O(n^2) in time and space.\n\t\
    -- Time Complexity: O(n^2).\n\t-- Space Complexity: O(n).\n\t-- At the beginning\
    \ of each iteration, there are n^2 calls to is_nested() where n is the length\
    \ of the input string.\n\t-- At the end of each iteration, there are n calls to\
    \ is_nested() where n is the length of the input string.\n\t-- Thus, each iteration\
    \ takes O(n^2) time and O(n) space.\n\t-- If the input string contains only square\
    \ brackets, then it takes O(n) time only.", "    local open = 0\n    local close\
    \ = 0\n    local length = 0\n    local result = false\n    while true do\n   \
    \     local opening = string.find('[', open+1, length+1)\n        local closing\
    \ = string.find(']', open+1, length+1)\n        \n        if opening ~= nil then\n\
    \            close = opening\n            length = closing + 1\n            local\
    \ open = 0\n        elseif closing ~= nil then\n            open = closing + 1\n\
    \            length = string.len(string) - close - 1\n        else\n         \
    \   length = string.len(string) - open\n        end\n        \n        if open\
    \ >= close then\n            if length >= 1 then\n                result = true\n\
    \            else\n                result = false\n            end\n         \
    \   break\n        end\n    end\n    return result \nend", "\t-- Create a stack\
    \ to hold the brackets we are checking\n\tlocal stack = {\n\t\t[0] = 0,\n\t\t\
    [1] = string[1],\n\t}\n\t-- Loop while there are still brackets\n\twhile true\
    \ do\n\t\t-- If we run out of brackets, then we know there is a valid subsequence\n\
    \t\tif stack[#stack] == 0 then\n\t\t\treturn true\n\t\tend", "\tif string == nil\
    \ then\n\t\tprint('String is nil')\n\t\treturn nil\n\tend", "\tstring = string.trim()\n\
    \t-- Find a matching opening bracket\n\tlocal open_bracket = 1\n\tfor i = 1, #string\
    \ do\n\t\tif string[i] == '[' then\n\t\t\topen_bracket = open_bracket + 1\n\t\t\
    elseif string[i] == ']' then\n\t\t\topen_bracket = open_bracket - 1\n\t\tend\n\
    \t\tif open_bracket == 0 then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\n\
    end", "\tlocal function helper(string, index, open_close)\n\t\topen_close = open_close\
    \ or 0\n\t\tlocal open = string.find(string, \"[\", index)\n\t\tif open == nil\
    \ then\n\t\t\treturn open_close == 0\n\t\tend\n\t\tif string.sub(string,open-1,open)\
    \ == \"[\" then\n\t\t\tlocal close = string.find(string, \"]\", open+1)\n\t\t\t\
    if close == nil then\n\t\t\t\treturn open_close == 0\n\t\t\tend\n\t\t\treturn\
    \ helper(string, open + 1, close - open + 1) and\n\t\t\t\thelper(string, close\
    \ + 1, open_close)\n\t\tend\n\t\treturn open_close == open_close + 1\n\tend\n\t\
    return helper(string,1,0)\nend", "    local opening_brackets = 0\n    for index,\
    \ char in string.gmatch( string, \"%S+\") do\n        if opening_brackets == 0\
    \ and char == \"[\" then\n            opening_brackets = opening_brackets + 1\n\
    \        elseif opening_brackets > 0 and char == \"[\" then\n            opening_brackets\
    \ = opening_brackets - 1\n        elseif opening_brackets == 0 and char == \"\
    ]\" then\n            return true\n        elseif opening_brackets > 0 and char\
    \ == \"]\" then\n            opening_brackets = opening_brackets - 1\n       \
    \ end\n    end\n    return false\nend", "    -- Define the pattern of the brackets\
    \ \n    local bracket_pattern = '[[]]'\n    local open_bracket, close_bracket\
    \ = string.match(bracket_pattern, '%S')\n    local open_count = 1\n    local close_count\
    \ = 1\n    -- Loop through characters and check whether there is a closing bracket\n\
    \    for index, char in string.gmatch(string, '%S') do\n        if char == open_bracket\
    \ then\n            open_count = open_count + 1\n        elseif char == close_bracket\
    \ then\n            close_count = close_count + 1\n        end\n        if open_count\
    \ == close_count then\n            return true\n        end\n    end\n    return\
    \ false\nend", "    local index = 1\n    while index:find(string, \"[\", index)\
    \ do\n        index = index + 1 \n    end\n    if index == #string then\n    \
    \    return true \n    else \n        return false \n    end\nend", "    if not\
    \ string then\n        return nil\n    end", "  if string == '[]' then\n    return\
    \ true\n  end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
