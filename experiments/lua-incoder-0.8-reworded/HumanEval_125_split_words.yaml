name: HumanEval_125_split_words
language: lua
prompt: "-- Given a string of words, return a table of words split on whitespace,\
  \ if no whitespaces exists in the text you\n-- should split on commas ',' if no\
  \ commas exists you should return the number of lower-case letters with odd order\
  \ in the\n-- alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n-- Examples\n\
  -- >>> split_words('Hello world!')\n-- {'Hello', 'world!'}\n-- >>> split_words('Hello,world!')\n\
  -- {'Hello', 'world!'}\n-- >>> split_words('abcdef')\n-- 3\nlocal function split_words(txt)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = split_words\n\
  \    lu.assertEquals(candidate('Hello world!'), {'Hello', 'world!'})\n    lu.assertEquals(candidate('Hello,world!'),\
  \ {'Hello', 'world!'})\n    lu.assertEquals(candidate('Hello world,!'), {'Hello',\
  \ 'world,!'})\n    lu.assertEquals(candidate('Hello,Hello,world !'), {'Hello,Hello,world',\
  \ '!'})\n    lu.assertEquals(candidate('abcdef'), 3)\n    lu.assertEquals(candidate('aaabb'),\
  \ 2)\n    lu.assertEquals(candidate('aaaBb'), 1)\n    lu.assertEquals(candidate(''),\
  \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if txt == nil then return nil end\n  if tbl.get(txt) ~= nil then\
    \ return txt end\n  local txt = string.gsub(txt, ' ', '')\n  local count = 1\n\
    \  local words = {}\n  local last_index = 1\n  for i = 1, #txt do\n    local c\
    \ = string.sub(txt, i, i)\n    if c ~= ',' and c ~= '\\cK' then\n      words[#words\
    \ + 1] = string.sub(txt, last_index, i - 1)\n      last_index = i + 1\n      if\
    \ c ~= ' ' and c ~= '\\cK' and c ~= '\\cM' and c ~= '\\cJ' then\n        count\
    \ = count + 1\n      end\n    end\n  end\n  if last_index <= #txt then\n    words[#words\
    \ + 1] = string.sub(txt, last_index, #txt)\n  end\n  return words\nend", "  local\
    \ words = {}\n  local len = 1\n  for w in string.gmatch(txt, \"([^,]+)(%d+)\"\
    ) do\n    table.insert(words, w)\n    len = len + #w\n  end\n  if len % 2 == 1\
    \ then\n    local letters = {}\n    for letter = string.lower('a'):ord('z') do\n\
    \      table.insert(letters, letter)\n    end\n    for i = 1, len do table.insert(words,\
    \ letters[i]) end\n    local odd = 0\n    for i = 1, len do\n      if odd == 1\
    \ then\n        table.insert(words, letters[i])\n      else\n        table.insert(words,\
    \ '#' .. letters[i])\n      end\n      odd = (odd + 1) % (#letters)\n    end\n\
    \  end\n  return words\nend", "\tlocal n = txt:len()\n\t-- If there is no whitespace\
    \ split on commas\n\tif txt:sub(n - 1, n) == '' and txt ~= '' and txt ~= nil then\n\
    \t\treturn {txt}\n\t-- Otherwise split on whitespace\n\telseif n ~= '' then\n\t\
    \t-- Split on commas if any commas exist\n\t\tif txt:sub(n - 1, n) == ',' then\n\
    \t\t\treturn {txt}\n\t\t-- Otherwise split on whitespace\n\t\telse\n\t\t\treturn\
    \ {txt:sub(n - 1, n)}\n\t\tend\n\t-- If the text is empty or nil, return an empty\
    \ table\n\telse\n\t\treturn {}\n\tend\nend", "  local splitter = {}\n  for i =\
    \ 1,#txt do\n    local word = string.lower(string.sub(txt,i,i))\n    if word ==\
    \ \"\" then\n      splitter[#splitter+1] = word\n    elseif word ~= \"\" then\n\
    \      splitter[#splitter+1] = word\n    end\n  end\n  return table.concat(splitter)\n\
    end", '    local words = { }', "    local i, word, count, words = 1, {}, 0, {}\n\
    \    while true do\n        word = txt:sub(i, i)\n        if word:sub(1,1) ==\
    \ ' ' then\n            count = count + 1\n        elseif ',' ~= word then\n \
    \           words[#words + 1] = word\n        end\n        i = i + 1\n       \
    \ if i == #txt then break end\n    end\n    return count, words\nend", "   --\
    \ remove non-letters\n   local txt = txt:gsub('[^a-z ]', '') -- remove all non-letters\n\
    \   -- split into words\n   local ws = txt:gsub(' ','+'):gsub('+','|+'):gsub('\\\
    |\\+','|'):gsub('\\|+', '|')\n   local words = {}\n   for w in ws:gmatch'([^|]+)'do\
    \ words[#words+1] = w end\n   return words\nend", "    -- No words found\n   \
    \ if not txt then return {} end\n    local words = {}\n    -- Split on whitespace\
    \ and commas\n    local words = split(txt, '[, ]')\n    -- Only lowercase odd\
    \ letters exist in the text\n    -- Only letters with an even order exists in\
    \ the text\n    if not words[1] then\n        words = words:gsub('[^a-z]', function(c)\
    \ return string.char(tonumber(c) + 2) end)\n        -- Only lowercase odd letters\
    \ exist in the text\n        -- Only letters with an even order exists in the\
    \ text\n        if words[1] then\n            words = words:gsub('[^a-z]', function(c)\
    \ return string.char(tonumber(c) + 1) end)\n        end\n    end\n    -- Remove\
    \ empty words\n    -- Remove trailing commas\n    -- Remove empty words\n    --\
    \ Remove trailing commas\n    -- Return words\n    return words\nend", "  if txt\
    \ == '' then\n    return {}\n  end", "\t-- Write your solution here\n\treturn\
    \ nil\nend", "  if string.find(txt, '%s') == nil then\n    return 1\n  else\n\
    \    local words = {}\n    for w in string.gmatch(txt, '[^%s]+') do\n      table.insert(words,\
    \ w)\n    end\n    return #words\n  end\nend", "  -- The first time we see a non-space\
    \ character, we know that we have found a word.\n  local tbl = {}\n  local curr\
    \ = txt\n  local idx\n  while true do\n    -- If the current character is a space,\
    \ skip it.\n    if curr ~= ' ' then\n      idx = #curr\n      tbl[idx] = curr\n\
    \    else\n      -- Otherwise, we found a word.\n      if #tbl == 0 then\n   \
    \     return tbl\n      else\n        return nil\n      end\n    end\n    -- Get\
    \ the next character.\n    local c = string.sub(curr, idx+1, idx)\n    curr =\
    \ string.sub(curr, idx)\n    -- Skip commas, if we're not between non-space characters.\n\
    \    if c ~= ',' then\n      idx = #curr\n      tbl[idx] = c\n    end\n  end\n\
    end", "    return setmetatable({}, {\n        __index = function(t, k)\n     \
    \       local words = nil\n            local whitespace_index = string.find(txt,\
    \ \" \")\n            if whitespace_index then\n                words = string.sub(txt,\
    \ 1, whitespace_index)\n            else\n                words = string.gsub(txt,\
    \ \"[,]+\", \",\")\n            end\n            local odd_words = {}\n      \
    \      local i = #words\n            while i > 0 do\n                local odd_word\
    \ = string.lower(words[i])\n                if not odd_words[odd_word] then\n\
    \                    odd_words[odd_word] = 1\n                else\n         \
    \           odd_words[odd_word] = odd_words[odd_word] + 1\n                end\n\
    \                i = i - 1\n            end\n            return odd_words\n  \
    \      end\n    })\nend", "\tlocal words = { }", "  local counts = {}\n  local\
    \ wl = {}\n  local ws = {}\n  for w in txt:gmatch(\"[^A-Za-z]+\") do\n    if #ws\
    \ > 0 and ws[1] ~= w then\n      ws[#ws + 1] = ws[1]\n    end\n    table.insert(ws,\
    \ w)\n  end\n  table.sort(ws)\n  for i = 1, #ws do\n    if #wl < #ws then\n  \
    \    table.insert(wl, ws[i])\n      table.insert(counts, 0)\n    elseif ws[i]\
    \ ~= ws[i - 1] and ws[i] ~= ws[i - 1]:lower() then\n      table.insert(wl, ws[i])\n\
    \      table.insert(counts, #counts)\n    end\n  end\n  return wl, counts\nend",
  "  -- remove whitespaces, commas and split the words with commas ','\n  -- then\
    \ remove the last character from every word and add it to the last word\n  --\
    \ if the word ends with whitespace then don't add it\n  -- if there are only lower-case\
    \ letters then add them to the word\n  -- if the word contains only digits and\
    \ letters then add it to the word\n  -- Example\n  -- split_words('hello world!')\n\
    \  -- 'hello', 'world!'\n  -- split_words('Hello world!')\n  -- 'Hello', 'world!'\n\
    \  -- split_words('Hello,world!')\n  -- 'Hello', 'world!'\n  -- split_words('abcdef')\n\
    \  -- 'abcdef'\n  -- split_words('abc')\n  -- 'abc'\n  -- split_words('ab12')\n\
    \  -- 'ab12'\n  -- split_words(' ab 12')\n  -- 'ab', '12'\n  -- split_words('ab\
    \ 12')\n  -- 'ab', '12'\n  -- split_words('ab123')\n  -- 'ab123'\n  -- split_words('ab12')\n\
    \  -- 'ab', '12'\n  -- split_words(' ab ')\n  -- 'ab'\n  -- split_words(' ab12')\n\
    \  -- 'ab', '12'\n  -- split_words('ab ')\n  -- 'ab'\n  -- split_words('ab')\n\
    \  -- 'ab'\n  -- split_words('ab12')\n  -- 'ab', '12'\n  -- split_words('a b123')\n\
    \  -- 'a', 'b', '123'\n  -- split_words('ab123')\n  -- 'ab123'\n  -- split_words('')\n\
    \  -- ''\n  -- split_words(' ')\n  -- ''\n  -- split_words('a')\n  -- 'a'\n  --\
    \ split_words('a ')\n  -- 'a'\n  -- split_words('a b')\n  -- 'a', 'b'\n  -- split_words('a\
    \ b c')\n  -- 'a', 'b', 'c'\n  -- split_words('a b123')\n  -- 'a', 'b123'\n  --\
    \ split_words('a b 123')\n  -- 'a', 'b', '123'\n  -- split_words(' ab 12')\n \
    \ -- 'ab', '12'\n  -- split_words(' ab12')\n  -- 'ab', '12'\n  -- split_words('\
    \ ab123 ')\n  -- 'ab123'\n  -- split_words(' ab123 456 ')\n  -- '", "    local\
    \ tbl = {}\n    local split = {\n        [' '] = 1, \n        ['.'] = 1, \n  \
    \      ['!'] = 1, \n        ['?'] = 1, \n        ',', \n        ' ', 1, \n   \
    \     '.', 1, \n        '!', 1, \n        '?', 1, \n        ' ', 1, \n       \
    \ '.', 1, \n        '!', 1, \n        '?', 1, \n        ' ', 1, \n        '.',\
    \ 1, \n        '!', 1, \n        '?', 1, \n        ' ', 1, \n        '.', 1, \n\
    \        '!', 1, \n        '?', 1, \n        ' ', 1, \n        '.', 1, \n    \
    \    '!', 1, \n        '?', 1, \n    }\n    for w in string.gmatch(txt, \"([^%s]+)\"\
    ) do\n        table.insert(tbl, w:lower())\n    end\n    return #tbl\nend", " \
    \ -- The table we will return\n  local result = {}\n  -- The index of current\
    \ letter in the alphabet\n  local letter_idx\n  -- For each letter in the input\n\
    \  for letter_idx = 1, #txt - 1 do\n    -- Split on spaces if spaces exists\n\
    \    if ' ' ~= txt[letter_idx] then\n      -- Split on commas if commas exists\n\
    \      if ',' ~= txt[letter_idx] then\n        -- Split on spaces if spaces exists\n\
    \        if ' ' ~= txt[letter_idx + 1] then\n          -- Split on commas if commas\
    \ exists\n          if ',' ~= txt[letter_idx + 1] then\n            -- Split on\
    \ spaces if spaces exists\n            if ' ' ~= txt[letter_idx + 2] then\n  \
    \            -- Split on commas if commas exists\n              if ',' ~= txt[letter_idx\
    \ + 2] then\n                -- Split on spaces if spaces exists\n           \
    \     if ' ' ~= txt[letter_idx + 3] then\n                  -- Split on commas\
    \ if commas exists\n                  if ',' ~= txt[letter_idx + 3] then\n   \
    \                 -- Split on spaces if spaces exists\n                    if\
    \ ' ' ~= txt[letter_idx + 4] then\n                      -- Split on commas if\
    \ commas exists\n                      if ',' ~= txt[letter_idx + 4] then\n  \
    \                      -- Split on spaces if spaces exists\n                 \
    \       if ' ' ~= txt[letter_idx + 5] then\n                          -- Split\
    \ on commas if commas exists\n                          if ',' ~= txt[letter_idx\
    \ + 5] then\n                            -- Split on spaces if spaces exists\n\
    \                            if ' ' ~= txt[letter_idx + 6] then\n            \
    \                  -- Split on commas if commas exists\n                     \
    \         if ',' ~= txt[letter_idx + 6] then\n                               \
    \ -- Split on spaces if spaces exists\n                                if ' '\
    \ ~= txt[letter_idx + 7] then\n                                  -- Split on commas\
    \ if commas exists\n                                  if ',' ~= txt[letter_idx\
    \ + 7] then\n                                    -- Split on spaces if spaces\
    \ exists\n                                    if ' ' ~= txt[letter_idx + 8] then\n\
    \                                      -- Split on commas if commas exists\n \
    \                                       if ',' ~= txt[letter_idx + 8] then\n \
    \                                         -- Split on spaces if spaces exists\n\
    \                                          if ' ' ~= txt[letter_idx + 9] then\n\
    \                                            -- Split on commas if commas exists\n\
    \                                            if ',' ~", "\tlocal t = {}\n\tlocal\
    \ count = 0\n\tfor word in string.gmatch(txt, '([^,]+)(%S+)?') do\n\t\tcount =\
    \ count + 1\n\t\tif count % 2 == 1 then\n\t\t\tt[#t + 1] = word\n\t\tend\n\tend\n\
    \tlocal new = {}\n\tfor i = #t do\n\t\tif i % 2 == 1 then\n\t\t\tnew[#new + 1]\
    \ = string.lower(t[i])\n\t\tend\n\tend\n\treturn #new > 0 and new or count\nend",
  "    local table = {}\n    local nwords = 0\n    local letters = \"\"\n    for w\
    \ in txt:gmatch(\"([^ ,]+)\"..patterns.whitespace_or_commas) do\n        if w\
    \ ~= \"\" and w:match(patterns.whitespace_or_commas) == nil then\n           \
    \ table.insert(table, nwords + 1)\n            table.insert(table, letters)\n\
    \            table.insert(table, w)\n            nwords += 1\n            letters\
    \ = w\n        else\n            table.insert(table, nwords + 1)\n           \
    \ table.insert(table, letters)\n        end\n    end\n    table.insert(table,\
    \ nwords + 1)\n    table.insert(table, letters)\n    return table\nend", "\tlocal\
    \ tbl = {}\n\tlocal i = 1\n\tfor w in txt:gmatch(\"[^A-Za-z0-9]+\") do\n\t\ttbl[i]\
    \ = w\n\t\ti = i + 1\n\tend\n\tif i ~= #txt then\n\t\tfor i = i + 1, #txt do\n\
    \t\t\ttbl[i] = tbl[i]..','\n\t\tend\n\tend\n\treturn tbl\nend", "    local words\
    \ = txt:gsub('([^ ])', ',$1'):gsub('(.)', function(c) return string.format('%c',\
    \ c) end):gsub('^,*|,*$', '')\n    return #words == 0 and '' or words\nend", " \
    \  local words = string.gsub(txt, \"([^ ])\", \" \")\n   words = string.gsub(words,\
    \ \"( )\", \" \")\n   return words\nend", "    return split(txt, ' ') if txt ~=\
    \ '' and not txt == '0' end\nend", "  local words = {}\n  local count = 0\n  for\
    \ w in string.gmatch(txt, \"[^,]+\") do\n    if w ~= '' then\n      count = count\
    \ + 1\n      words[#words + 1] = w\n    end\n  end\n  if count % 2 == 1 then\n\
    \    words[#words + 1] = string.gsub(string.lower(string.gsub(words, \" \", \"\
    \")), \",\", \"\")\n  end\n  return words\nend", "  local t = {}\n  local w =\
    \ string.gsub(txt, \" \", \"\")\n  if w ~= \"\" then table.insert(t, w) end\n\
    \  w = string.gsub(txt, \",\", \"\")\n  if w ~= \"\" then table.insert(t, w) end\n\
    \  local letters = {}\n  for i = 1, #t do\n    table.insert(letters, string.lower(string.sub(t[i],\
    \ 1, #t[i])))\n  end\n  return #letters, letters\nend", "    local words = { }\n\
    \    local w = {}\n    local n = #txt\n    for i = 1, n do\n        local c =\
    \ txt:sub(i,i)\n        if c == ' ' then\n            table.insert(words, unpack(w))\n\
    \            w = {}\n        else\n            w[#w+1] = c\n        end\n    end\n\
    \    if #w > 0 then\n        table.insert(words, unpack(w))\n    end\n    return\
    \ words\nend", "  local words = { }\n  for _,w in ipairs(string.gmatch(txt, \"\
    [^ ]+\")) do\n    table.insert(words, string.lower(w))\n  end\n  return table.concat(words)\n\
    end", "    local i, len, tl = 1, #txt, {}\n    while true do\n        i = i +\
    \ 2\n        if i > len then\n            break\n        end\n        tl[i] =\
    \ txt[i]\n        tl[i + 1] = txt[i + 1]\n    end\n    return tl\nend", "  local\
    \ result = {}\n  local last_pos = 0\n  local last_char_pos = 0\n  -- find the\
    \ longest word\n  for i, v in ipairs(txt:gsub('(%S+)()', function(c)\n    table.insert(result,\
    \ v)\n    last_pos = last_pos + 1\n    last_char_pos = last_char_pos + 1\n   \
    \ return ''\n  end)\n  do\n    if last_char_pos % 2 == 1 then\n      table.insert(result,\
    \ txt:sub(1, last_pos))\n    end\n    last_char_pos = 0\n  end\n  -- if there\
    \ is a last word add it\n  if last_pos > 0 then\n    table.insert(result, txt:sub(1,\
    \ last_pos))\n  end\n  return result\nend", "  local words = {}\n  local idx =\
    \ 0\n  local count = #txt\n  if count > 0 then\n    for i = 1, count do\n    \
    \  words[idx] = txt:sub(i, i)\n      idx = idx + 1\n      if idx > #txt then break\
    \ end\n    end\n  end\n  return words\nend", "  local n = #txt\n  local txt =\
    \ txt or 'abcdef'\n  local ret = {}\n  while n ~= 0 do\n    ret[#ret+1] = string.sub(txt,1,n-1)\n\
    \    n = n-1\n  end\n  n = #ret\n  while n ~= 0 do\n    -- append odd characters\n\
    \    for i = #ret to #ret+n do\n      ret[i] = ret[i] .. string.sub(ret,i,i)\n\
    \    end\n    n = n-1\n  end\n  return ret\nend", "\tlocal tbl = {}\n\tfor _,\
    \ word in ipairs(txt:gsub(' ', ',')):gmatch('(.-)%w+') do\n\t\ttbl[word] = true\n\
    \tend\n\ttable.sort(tbl, function(a,b) return #a < #b end)\n\tlocal even = #tbl%2\
    \ == 0\n\tlocal evens = tbl\n\treturn evens and evens[#tbl] or #tbl\nend", " \
    \   local words = {}\n    local num_comma = 0\n    for word in txt:gmatch(\"[%w-]+\"\
    ) do\n        num_comma = num_comma + 1\n        table.insert(words, word)\n \
    \   end\n    if #words == 0 then\n        return num_comma\n    else\n       \
    \ return words\n    end\nend", "\tlocal num_words = 1\n\tlocal word = txt:sub(1,1)\n\
    \twhile word ~= '' do\n\t\tnum_words = num_words + 1\n\t\tword = word:sub(2)\n\
    \tend\n\treturn num_words\nend", "    if string.len(txt) == 0 then return {} end\n\
    \    local lower = string.lower(txt)\n    local count = #lower\n    local result\
    \ = {}\n    for i=1,count do\n        if string.find(lower,',',i,true) ~= nil\
    \ then\n            result[#result+1] = string.sub(lower,0,i)\n            lower\
    \ = string.sub(lower,i+1)\n        elseif string.find(lower,'!',i,true) ~= nil\
    \ then\n            result[#result+1] = string.sub(lower,0,i)\n            lower\
    \ = string.sub(lower,i+1)\n        else\n            result[#result+1] = string.sub(lower,0,i)\n\
    \        end\n    end\n    result[#result+1] = lower\n    return result\nend",
  "  if txt ~= '' then\n    local res = {}\n    local count = 1\n    local last_letter\n\
    \    local count1\n    for letter in string.gmatch(txt, \"[%a%A]+\") do\n    \
    \  if last_letter ~= 'a' then\n        res[#res + 1] = \"[\" .. letter .. \"]\"\
    \n      else\n        res[#res + 1] = letter .. \"[\" .. letter .. \"]\"\n   \
    \   end\n      last_letter = letter\n      count = count + 1\n    end\n    if\
    \ count1 % 2 == 1 then\n      res = res[#res + 1]\n    end\n    return res\n \
    \ else\n    return 0\n  end\nend", "    -- Check for empty string.\n    if not\
    \ txt then return nil end", "  local counts = {}\n  for word in string.gmatch(txt,\
    \ \"([^,]*)\") do\n    local word = string.lower(word)\n    table.insert(counts,\
    \ word)\n  end\n  return counts\nend", "\tlocal words = {}\n\tlocal count = 0",
  "  local res = {}\n  local i = 1\n  local wl\n  while true do\n    wl = txt:sub(i,\
    \ i + 1)\n    if wl == '' then break end\n    i = i + 2\n    if i <= #txt then\n\
    \      res[#res + 1] = wl\n    end\n  end\n  if i ~= #txt then\n    res[#res +\
    \ 1] = txt:sub(i)\n  end\n  return res\nend", "  -- This helper function splits\
    \ the given txt string into words using either whitespaces or commas\n  if txt:match('%S')\
    \ then\n    local words = txt:gsub('%S+', function(word)\n      return word:lower()\n\
    \    end)\n    words = {words[1]} -- Remove the leading space\n    if words[2]\
    \ then\n      words = {words[1], words[2]} -- Remove the comma and space\n   \
    \ end\n    return words\n  elseif txt:match('%W') then\n    local words = txt:gsub('%W+',\
    \ function(word)\n      return word:lower()\n    end)\n    words = {words[1]}\
    \ -- Remove the leading space\n    return words\n  else\n    return 1\n  end\n\
    end", "  local whitespaces = stringx.splitn(\" \", txt)\n  local words = stringx.splitn(\"\
    \ \", txt)\n  local num_lowercases = string.len(string.gsub(words, \"[%a]\", \"\
    \"))\n  if num_lowercases < 1 then\n    num_lowercases = 0\n  end\n  return {\"\
    [\" .. num_lowercases}\n    .. table.concat(whitespaces, \" \")\n    .. table.concat(words,\
    \ \" \")\n    .. {\"]\"}\nend", "\t-- remove leading whitespace\n\ttxt = txt:gsub('^%s*(.-)%s*$','%1')\n\
    \t-- remove trailing whitespace\n\ttxt = txt:gsub('%s*(.-)$','%1')\n\t-- remove\
    \ commas from the text\n\ttxt = txt:gsub(',',' ')\n\t-- remove excess whitespace\n\
    \ttxt = txt:gsub('%s+',' ')\n\t-- remove empty strings from the text\n\ttxt =\
    \ txt:gsub('%s*$','')\n\t-- remove all whitespace\n\ttxt = txt:gsub('%s+',' ')\n\
    \t-- remove all non-word characters\n\ttxt = txt:gsub('[^ a-z A-Z]+','')\n\t--\
    \ remove all spaces\n\ttxt = txt:gsub(' ','')\n\treturn txt:gsub('([a-z])([A-Z])',\n\
    \t\tfunction (s1, s2, s3)\n\t\t\treturn string.format('%s%s%s', s1, s3, '%s%s')\n\
    \t\tend)\nend", "    local words = txt:gsub('.-', ' ', true)\n    local whitespace\
    \ = string.gsub(words, '^%s+', '')\n    local commas = string.gsub(words, '%s+,',\
    \ '%s+,')\n    if commas then\n        return table.concat(table.split(commas))\n\
    \    elseif whitespace then\n        return table.concat(table.split(whitespace))\n\
    \    end\n    return words\nend", "\t-- Check if whitespace exists in text\n\t\
    if string.find(txt:gsub(' ', ''), '') then\n\t\treturn {string.gsub(' ', '', txt)}\n\
    \tend\n\t-- Check if commas exists in text\n\tif string.find(txt:gsub(',', ''),\
    \ '') then\n\t\treturn {string.gsub(',', '', txt)}\n\tend\n\t-- Check if there\
    \ is any odd order letter in text\n\treturn string.gsub(txt:gsub('[A-Za-z]', '[%1]'):gsub('[a-z]',\
    \ '[%1]'):gsub('[A-Za-z]', '[%1]'):gsub('[a-z]', '[%1]'), '%%d', txt):gsub('%%d',\
    \ '')\nend\nreturn {\n\tsplit_words = split_words,\n}\nend", "  -- split on whitespaces\n\
    \  local words = txt:gsub(\" \", \"\")\n  -- split on commas\n  words = words:gsub(\"\
    ,\", \" \")\n  -- convert lower-case letters to upper-case letters\n  -- split\
    \ on letters with odd order\n  -- return words as a list of strings\n  return\
    \ words:gsub(\"[a-z]\", function(c) c:upper() end)\nend", "    local count = 1\n\
    \    local output = {}\n    for w in string.gmatch(txt, '([^,]+)')\n        do\n\
    \            table.insert(output, string.lower(w))\n            count = count\
    \ + 1\n        end\n    end\n    return count, output\nend", "    local _words\
    \ = txt:gmatch(\"([^,]+)\")\n    local _letters = {}\n    for idx = 1, #_words\
    \ do\n        table.insert(_letters, _words[idx]:lower())\n    end\n    table.sort(_letters)\n\
    \    return #_letters, #_words > 0 and _letters[#_letters] or false\nend", " \
    \ local split = {}\n  local letters = {}\n  local count = 1\n  for w in string.gmatch(txt,\
    \ \"[%S]+\") do\n    if not letter then\n      count = string.len(w) + count\n\
    \      split[count] = w\n    else\n      if string.find(letters, w) then\n   \
    \     count = string.len(w) + count\n        split[count] = w\n      else\n  \
    \      letters[#letters + 1] = w\n      end\n    end\n  end\n  return split\n\
    end", "  local w = {}\n  for i = 1, string.len(txt) do\n    local c = string.sub(txt,\
    \ i, i)\n    if c == '' then\n      w[#w+1]\n    else\n      if c ~= ',' then\n\
    \        w[#w+1] = c\n      else\n        if #w % 2 == 1 then\n          w[#w+1]\
    \ = string.sub(txt, i+1, i)\n        end\n      end\n    end\n  end\n  return\
    \ w\nend", "    local ws = true\n    local w = {}\n    for i, v in pairs(txt:gmatch(\"\
    [%w\\1-]([%w\\1-%*]+[%w\\1-%*]+)\"..\n                                       \
    \         \"|[%w\\1-%*]+[%w\\1-%*]+[%w\\1-%*]+[%w\\1-%*]+[%w\\1-%*]+\"))\n   \
    \     if v ~= nil then\n            if ws then\n                ws[#w+1] = v\n\
    \                ws = false\n            else\n                w[1] = v\n    \
    \        end\n        end\n    end\n    if ws then\n        w[#w+1] = txt\n  \
    \      ws = false\n    end\n    return w\nend", "   local splits = {}\n   for\
    \ w in string.gmatch(txt, '([^ ]+)') do \n      table.insert(splits, w)\n   end\n\
    \   return #splits\nend", "  local words = {}\n  local words = txt:gmatch('[^\
    \ ]+') -- splits words based on any number of spaces\n  if #words < 1 then return\
    \ #words end -- returns number of words\n  local alpha = 0\n  for i = 1, #words\
    \ do\n    if words[i] <= 'z' then\n      alpha = alpha + 1\n    end\n  end\n \
    \ alpha = alpha - 1\n  for i = 1, #words do\n    if words[i] <= 'z' then\n   \
    \   words[i] = words[i] + string.char(alpha) -- adds alpha to each word\n    end\n\
    \  end\n  return #words\nend", "   local i, n = 0, 1\n   if txt ~= nil then\n\
    \      local tbl = {}\n      for i = 1, #txt, 1 do\n         if txt[i] ~= nil\
    \ then\n            if tbl[i] then\n               tbl[i] = tbl[i] .. ' ' .. txt[i]\n\
    \            else\n               tbl[i] = txt[i]\n            end\n         end\n\
    \      end\n      return tbl\n   else\n      return nil\n   end\nend", "  local\
    \ ws = ''\n  local num_lower = 0\n  for i = 1, #txt do\n    local ch = string.sub(txt,\
    \ i, i)\n    if ws == '' then ws = ch end\n    if ch == ' ' then ws = '' end\n\
    \    if ch == ',' then\n      if num_lower % 2 then\n        ws = ws .. ','\n\
    \      end\n    end\n    num_lower = num_lower + 1\n  end\n  if ws == '' then\n\
    \    return 1\n  else\n    return num_lower\n  end\nend", "  if string.find(txt,\
    \ \"%s\") then\n    return string.gsub(txt, \"%s\", \" \")\n  else\n    return\
    \ txt:gmatch(\"[%z]\")\n  end\nend", "  local letters = {}\n  for w in string.gmatch(txt,\
    \ \"[^'\\\\t\\\\n]+\") do\n    table.insert(letters, string.lower(w))\n  end\n\
    \  return letters\nend", "    local w = {}\n    for w in string.gmatch(txt, '%w+')\
    \ do end\n    return #w > 0 and w or nil\nend", "    local words = {}\n    local\
    \ counter = 1\n    for i = 1, #txt do\n        if txt:sub(i, i+1) ~= ' ' then\n\
    \            words[counter] = txt:sub(i, i+1)\n            counter = counter +\
    \ 1\n        else\n            counter = counter + 1\n        end\n    end\n \
    \   return words\nend", "  local words = { }\n  local comma = 0\n  local lowercase\
    \ = 0\n  for _, _char in string.gmatch(txt, \"([^,]+)\") do\n    lowercase = lowercase\
    \ + 1\n    if _char ~= ',' then\n      words[#words + 1] = string.sub(_char, 2,\
    \ #_char)\n    else\n      comma = comma + 1\n    end\n  end\n  if comma > 0 then\n\
    \    words[#words + 1] = words[#words] .. ',' .. chr(ord('a') + lowercase - 1)\n\
    \  end\n  return words\nend", "  local num_words = {}\n  for w in string.gmatch(txt,\
    \ \"([^ ,]+)\") do\n    num_words[#num_words + 1] = camel_case(w)\n  end\n  return\
    \ table.concat(num_words, ',')\nend", "    -- Return an empty table if no words\
    \ exist\n    if not txt then return end\n    -- Split on commas\n    local words\
    \ = txt:gsub(\"([^ ])\", \",\")\n    -- Return an empty table if no words exist\n\
    \    if not words then return end\n    -- Split on whitespace\n    words = words:gsub(\"\
    ([^ ])\", \"%s\")\n    -- Return an empty table if no words exist\n    if not\
    \ words then return end\n    -- Return words with an even index\n    return (words+1)%26\
    \ -- Count the number of words\nend", "    local words = {}\n    local i = 0\n\
    \    while i <= #txt do \n        local letter = string.sub(txt, i, i)\n     \
    \   if letter ~= '' then\n            table.insert(words, letter)\n        end\n\
    \        i = i + 1\n    end \n    return words\nend", "  if txt == '' then\n \
    \   return {}\n  else\n    local words = txt:gmatch(\"([%z]+)[%z%w*]\") and {\
    \ txt:sub(1, #txt - 1) } or txt:gmatch(\"[%z%w*]\")\n    return words\n  end\n\
    end", "  local words = txt:gsub(' ','+'):gsub('%c+', function(c)\n    if c:sub(1,1)\
    \ == 'a' then return 'b' end\n    if c:sub(1,1) == 'b' then return 'c' end\n \
    \   if c:sub(1,1) == 'c' then return 'd' end\n    if c:sub(1,1) == 'd' then return\
    \ 'e' end\n    if c:sub(1,1) == 'e' then return 'f' end\n    if c:sub(1,1) ==\
    \ 'f' then return 'g' end\n    if c:sub(1,1) == 'g' then return 'h' end\n    if\
    \ c:sub(1,1) == 'h' then return 'i' end\n    if c:sub(1,1) == 'i' then return\
    \ 'j' end\n    if c:sub(1,1) == 'j' then return 'k' end\n    if c:sub(1,1) ==\
    \ 'k' then return 'l' end\n    if c:sub(1,1) == 'l' then return 'm' end\n    if\
    \ c:sub(1,1) == 'm' then return 'n' end\n    if c:sub(1,1) == 'n' then return\
    \ 'o' end\n    if c:sub(1,1) == 'o' then return 'p' end\n    if c:sub(1,1) ==\
    \ 'p' then return 'q' end\n    if c:sub(1,1) == 'q' then return 'r' end\n    if\
    \ c:sub(1,1) == 'r' then return 's' end\n    if c:sub(1,1) == 's' then return\
    \ 't' end\n    if c:sub(1,1) == 't' then return 'u' end\n    if c:sub(1,1) ==\
    \ 'u' then return 'v' end\n    if c:sub(1,1) == 'v' then return 'w' end\n    if\
    \ c:sub(1,1) == 'w' then return 'x' end\n    if c:sub(1,1) == 'x' then return\
    \ 'y' end\n    if c:sub(1,1) == 'y' then return 'z' end\n    if c:sub(1,1) ==\
    \ 'z' then return 'a' end\n    if c:sub(1,1) == 'a' then return 'b' end\n    return\
    \ c\n  end)\n  return #words>1 and words or nil\nend", "  if txt == nil or txt\
    \ == \"\" then\n    return {}\n  end\n  local splits = table.new();\n  local words\
    \ = string.gsub(txt,\" \",\"\");\n  local alpha\n  for alpha=1,string.len(words)\
    \ do\n    if string.sub(words,alpha,alpha+1) ~= \"\" then\n      table.insert(splits,string.sub(words,alpha,alpha+1))\n\
    \    end\n  end\n  return splits\nend", "\tlocal tbl = {}\n\tlocal count = 0",
  "\tlocal words = ''\n\tfor c in string.gmatch(txt, '([^%s]+)') do\n\t\twords = words\
    \ .. c\n\tend\n\treturn words\nend", "    local spaces = string.gsub(txt, \"[%z\\\
    1-\\127]+\", \"\")\n    if spaces == \"\" then\n        return string.gsub(txt,\
    \ \"([a-z])([A-Z])\", \"%1 %2\") or string.len(string.lower(string.sub(txt, 1,\
    \ 1)))\n    else\n        spaces = string.gsub(spaces, \",\", \" \")\n       \
    \ return string.gsub(spaces, \"[%z\\1-\\127]+\", \" \")\n    end\nend", "  --\
    \ Split on whitespace\n  local tbl = {}\n  for w in string.gmatch(txt, '([^ ]+)')\n\
    \  do\n    table.insert(tbl, w)\n  end\n  -- Split on commas\n  for i = 1, #tbl\n\
    \  do\n    if tbl[i] ~= ',' then\n      tbl[i] = tbl[i]:lower()\n    end\n  end\n\
    \  return #tbl\nend", "  local letters = {}\n  local count = 0\n  for word in\
    \ string.gmatch(txt, '[^ ]+') do\n    count = count + 1\n    table.insert(letters,\
    \ word:lower())\n  end\n  if count % 2 == 1 then\n    table.insert(letters, string.sub(txt,\
    \ count / 2))\n  end\n  return count\nend", "  local w, n = 1, #txt\n  local tbl\
    \ = {}\n  local c = 0\n  repeat\n    tbl[w] = txt\n    w = w + 1\n    txt = txt:gsub('([A-Z][a-z]+)([A-Z][a-z]+)(?![A-Z][a-z]+$)','%1%%2'):gsub('([A-Z][a-z]+)([^A-Z])','%1%%2'):gsub('([^A-Z])([A-Z][a-z]+)','%1%%2'):gsub('([^A-Z])([A-Z][a-z]+)(?![A-Z][a-z]+$)','%1%%2')\n\
    \    local len = #txt\n    if len > 0 then\n      c = c + len\n    end\n  until\
    \ len == 0\n  return tbl, c, w\nend", "    local w = {}\n    for w in string.gmatch(txt,\
    \ \"([^ ]+)\")\n    do\n        w[#w+1] = w\n    end\n    return #w + 1\nend",
  "  local counts = {}\n  local splits = {}\n  for _, v in pairs(txt) do\n    local\
    \ l = v\n    if #l > 0 then\n      if not splits[#splits + 1] or #splits[#splits\
    \ + 1] > #l then\n        splits[#splits+1] = {}\n      end\n      for i = 1,\
    \ #l do\n        if #splits[#splits + 1] < #l then\n          splits[#splits +\
    \ 1] = {}\n        end\n        if i ~= 1 and i ~= #l - 1 then\n          table.insert(splits[#splits\
    \ + 1], string.lower(v))\n        end\n      end\n    end\n    table.insert(counts,\
    \ #splits)\n  end\n  return counts\nend", "    -- if there are no whitespaces\
    \ then we split on commas, otherwise we split on spaces\n    local words = {}\n\
    \    local i = 0\n    local num_letters = 0\n    local letter\n    for letter\
    \ in string.gmatch(txt, '([^ ]+) ') do\n        words[#words + 1] = letter\n \
    \       num_letters = num_letters + 1\n    end\n    if num_letters % 2 ~= 0 then\n\
    \        return words\n    else\n        return words,string.len(txt) - num_letters\n\
    \    end\nend", "  local word_count = {}\n  local word_dict = {}\n  for i,letter\
    \ in pairs(string.gmatch(string.lower(txt), '%[a-df-z]+'))\n    do\n      word_count[letter]\
    \ = word_count[letter] + 1\n      table.insert(word_dict, letter)\n    end\n \
    \ return word_count, word_dict\nend", "\tlocal words = { }\n\tlocal comma = 0\n\
    \tlocal lowcase_count = 0\n\tfor char in txt:gmatch('[^,]+') do\n\t\tif char ==\
    \ ',' then\n\t\t\tcomma = comma + 1\n\t\telse\n\t\t\ttable.insert(words, char)\n\
    \t\t\tlowcase_count = lowcase_count + 1\n\t\tend\n\tend\n\tif comma > 0 then\n\
    \t\ttable.insert(words, ',')\n\t\tlowcase_count = lowcase_count + 1\n\tend\n\t\
    if lowcase_count % 2 == 1 then\n\t\twords[#words + 1] = tostring(ord('a') + lowcase_count\
    \ / 2)\n\tend\n\treturn words\nend", "    local t = {}\n    for _, _ in ipairs(txt:gmatch(\"\
    ([^%s]+)\") do\n        t[#t + 1] = string.lower(_)\n    end)\n    return t\n\
    end", "  local t = {}\n  for word in txt:gmatch'([^ ,]+)' do\n    table.insert(t,\
    \ word)\n  end\n  return #t\nend", "\t-- Split on spaces, commas ',' if no commas\
    \ exists\n\t-- Split on spaces, commas ',' if no commas exists\n\t-- Split on\
    \ spaces, commas ',' if no commas exists\n\treturn string.gsub(txt, ',', '') or\
    \ string.gsub(txt, ' ', '') or 1\nend", "\t-- Return string if no white spaces\
    \ exist\n\tif string.find(txt, ' ') ~= nil then\n\t\treturn string.gsub(txt, '\
    \ ', '') \n\t-- Return string if no commas exist\n\telseif string.find(txt, ',')\
    \ ~= nil then\n\t\treturn string.gsub(txt, ',', '') \n\t-- Return number of characters\
    \ with odd order in the alphabet\n\telse\n\t\treturn #string.gsub(txt, '([a-z])\\\
    1', '[#1]')\n\tend\nend", "    local split = {}\n    for i = 1, #txt do\n    \
    \    for j = 1, string.len(txt[i]) do\n            local l = string.lower(string.sub(txt[i],\
    \ j, j + 1))\n            table.insert(split, l)\n        end\n    end\n    return\
    \ split\nend", "   local result = {}\n   for word in string.gmatch(txt, \"([^,]+):(.*$)\"\
    ) do\n      table.insert(result, word)\n   end\n   return #result\nend", "  local\
    \ words = {}\n  for word in string.gmatch(txt, '([^ \\t\\n]+') do\n    table.insert(words,\
    \ word)\n  end)\n  if string.find(txt, ' ') then\n    for word in string.gmatch(txt,\
    \ ' ') do\n      table.insert(words, word)\n    end\n  end\n  if #words == 0 then\n\
    \    words = {string.lower(txt)}\n  end\n  if #words == 0 then\n    return 1\n\
    \  end\n  if #words > 1 then\n    table.sort(words)\n  end\n  local n = #words\
    \ - 1\n  if n % 2 == 1 then\n    n = n + 1\n  end\n  local oddcount = 0\n  for\
    \ i = 1, n do\n    local letter = string.sub(words[i], 1, 1)\n    if letter ==\
    \ \"a\" then\n      oddcount = oddcount + 1\n    elseif letter == \"b\" then\n\
    \      oddcount = oddcount + 1\n    elseif letter == \"c\" then\n      oddcount\
    \ = oddcount + 1\n    elseif letter == \"d\" then\n      oddcount = oddcount +\
    \ 1\n    elseif letter == \"e\" then\n      oddcount = oddcount + 1\n    elseif\
    \ letter == \"f\" then\n      oddcount = oddcount + 1\n    end\n  end\n  return\
    \ oddcount\nend", "  local tbl = { }\n  local i = 0\n  local cnt = 0\n  local\
    \ len = string.len(txt)\n  for c = 1, len do -- each character\n    if string.sub(txt,\
    \ c) == ',' then tbl[#tbl+1] = string.sub(txt, i, c) -- append comma\n      i\
    \ = c -- skip comma\n    elseif string.lower(string.sub(txt, i, c)) == string.lower(string.sub(txt,\
    \ i, c))\n      and string.sub(txt, i, c) ~= 'a'\n      and string.sub(txt, i,\
    \ c) ~= 'z'\n      and string.sub(txt, i, c) ~= 'a'\n      and string.sub(txt,\
    \ i, c) ~= 'z'\n    then\n      tbl[#tbl+1] = string.sub(txt, i, c)\n      cnt\
    \ = cnt + 1\n    end\n  end\n  if cnt % 2 ~= 0 then return string.sub(txt, i -\
    \ 1, #txt) end\n  for i = 1, #tbl do\n    if tbl[i] ~= tbl[i] then\n      return\
    \ string.sub(txt, i - 1, #txt)\n    end\n  end\n  return cnt\nend", "  return\
    \ {}\nend", "    local words = txt:gsub(' ', ''):gsub('[,]+', ' ')\n    return\
    \ words:gsub(' ', ''):gsub('([a-z]\\d)', '%d'):gsub('\\%d', '%d'):gsub('[a-z]%d',\
    \ '%d'):gsub('%d$', ''):gsub('^%d', '')\nend", "    local words = {}\n    local\
    \ word_count = 1\n    local word_count_by_type = {}\n    local chars = string.gsub(txt,'.','')\
    \ -- removes periods, also removes spaces from start\n    local length = string.len(chars)\n\
    \    local last_word_end = 0\n    local last_char_end = 0\n    local char_code\
    \ = 0\n    local current_word = ''\n    local current_char = 'a'\n    -- Find\
    \ all characters in string and record them in a table\n    for i = 1,length do\n\
    \        char_code = string.sub(chars,i,i)\n        current_char = string.sub(current_word,0,1)\n\
    \        -- If the current character does not equal the current character code\
    \ then that means a new word has been reached\n        if char_code ~= char_code\
    \ then\n            table.insert(words,current_word)\n            table.insert(word_count,1)\n\
    \            table.insert(word_count_by_type,char_code)\n            current_word\
    \ = ''\n            table.insert(chars,char_code)\n            char_code = 'a'\n\
    \            current_char = string.sub(current_word,0,1)\n        else\n     \
    \       -- If there is a space in the string then insert a comma\n           \
    \ if char_code == ' ' then\n                table.insert(words,current_word)\n\
    \                table.insert(word_count,1)\n                table.insert(word_count_by_type,char_code)\n\
    \                current_word = ''\n                table.insert(chars,char_code)\n\
    \                char_code = 'a'\n                current_char = string.sub(current_word,0,1)\n\
    \            else\n                table.insert(current_word,char_code)\n    \
    \        end\n        end\n    end\n    -- Append last word into the words table\
    \ if it exists\n    if #current_word > 0 then\n        table.insert(words,current_word)\n\
    \        table.insert(word_count,1)\n        table.insert(word_count_by_type,char_code)\n\
    \    end\n    -- Remove spaces from start and end of string\n    local start_string\
    \ = string.sub(chars,1,1)\n    local end_string = string.sub(chars,#chars)\n \
    \   -- Return word count and string\n    return table.concat(words,' '), start_string,\
    \ end_string, table.concat(word_count_by_type,' ')\nend\n</cell>\n<cell>", " \
    \   if not txt or #txt == 0 then\n        return {}\n    end", "  local words\
    \ = {}\n  local i = 0\n  for char in txt:gmatch(\"%w\") do\n    i = i + 1\n  \
    \  if i == 1 then\n      words[#words + 1] = char\n    else\n      words[#words\
    \ + 1] = char\n    end\n  end\n  return #words > 0 and words or nil\nend", " \
    \   if txt ~= '' then\n        local t = {}\n        local words = split(txt,\
    \ ' ')\n        for _, w in pairs(words) do\n            table.insert(t, lower(w))\n\
    \        end\n        return t\n    end\n    return 0\nend", "   -- Your code\
    \ here\n   txt = string.gsub(txt,' ','')\n   if string.find(txt,'%S') ~= nil then\
    \ \n       txt = string.gsub(txt,'[%S]','')\n       if string.find(txt,'%S') ~=\
    \ nil then \n           txt = string.gsub(txt,'%S','')\n       end\n   end\n \
    \  if string.find(txt,'%s') ~= nil then \n       txt = string.gsub(txt,'%s','')\n\
    \   end\n   if string.find(txt,'%S') ~= nil then \n       txt = string.gsub(txt,'%S','')\n\
    \   end\n   if string.find(txt,'%s') ~= nil then \n       txt = string.gsub(txt,'%s','')\n\
    \   end\n   if string.find(txt,'%S') ~= nil then \n       txt = string.gsub(txt,'%S','')\n\
    \   end\n   if string.find(txt,'%s') ~= nil then \n       txt = string.gsub(txt,'%s','')\n\
    \   end\n   if string.find(txt,'%S') ~= nil then \n       txt = string.gsub(txt,'%S','')\n\
    \   end\n   if string.find(txt,'%s') ~= nil then \n       txt = string.gsub(txt,'%s','')\n\
    \   end\n   if string.find(txt,'%S') ~= nil then \n       txt = string.gsub(txt,'%S','')\n\
    \   end\n   if string.find(txt,'%s') ~= nil then \n       txt = string.gsub(txt,'%s','')\n\
    \   end\n   if string.find(txt,'%S') ~= nil then \n       txt = string.gsub(txt,'%S','')\n\
    \   end\n   if string.find(txt,'%s') ~= nil then \n       txt = string.gsub(txt,'%s','')\n\
    \   end\n   if string.find(txt,'%s') ~= nil then \n       txt = string.gsub(txt,'%s','')\n\
    \   end\n   if string.find(txt,'%S') ~= nil then \n       txt = string.gsub(txt,'%S','')\n\
    \   end\n   if string.find(txt,'%s') ~= nil then \n       txt = string.gsub(txt,'%s','')\n\
    \   end\n   if string.find(txt,'%s') ~= nil ", "  local words = txt:gsub(\",\"\
    , \" \"):gsub(\"\\W+\", \" \"):gsub(\" $\", \"\")\n  return words\nend", "\t--\
    \ split on all whitespace, commas and commas, return results as string\n\t--\t\
    first count number of occurrences of all characters\n\tlocal i, j, k, l, m, n,\
    \ o, p\n\ti = j = k = l = 0\n\tm = n = o = p = nil\n\tlocal chars = {}\n\tfor\
    \ c = 1, #txt do\n\t\tchar = txt[c]\n\t\tchars[char] = chars[char] or 1\n\tend\n\
    \tfor k, chars in pairs(chars) do\n\t\tif chars == 1 then\n\t\t\ti = i + 1\n\t\
    \telseif chars > 1 then\n\t\t\tj = j + 1\n\t\tend\n\tend\n\tk = k - 1\n\tfor l,\
    \ chars in pairs(chars) do\n\t\tif chars == 1 then\n\t\t\tm = m + 1\n\t\telseif\
    \ chars > 1 then\n\t\t\tn = n + 1\n\t\tend\n\tend\n\tl = l - 1\n\tfor m, chars\
    \ in pairs(chars) do\n\t\tif chars == 1 then\n\t\t\to = o + 1\n\t\telseif chars\
    \ > 1 then\n\t\t\tp = p + 1\n\t\tend\n\tend\n\tm = m - 1\n\t-- find number of\
    \ lower-case letters with odd order in the alphabet, ord('a') = 0, ord('b') =\
    \ 1, ...\n\t-- ord('z') = 25\n\treturn i * j + m * n + o * p\nend", "  local result\
    \ = {}\n  local count = txt:gsub('^%s+', function(x)\n    local s = string.lower(x)\n\
    \    table.insert(result, s)\n    return ''\n  end)\n  \n  if count == 0 then\n\
    \    return 1\n  end\n  \n  return count\nend", "\tlocal result = {}\n\t-- remove\
    \ spaces (tabs, newlines etc.)\n\ttxt = txt:gsub(' ', '')\n\t-- add commas if\
    \ necessary and remove commas if there is only one word\n\tif txt:sub(1,1):find(',')\
    \ then\n\t\tfor word in txt:gmatch('[^,]+') do\n\t\t\tresult[#result + 1] = word\n\
    \t\tend\n\telse\n\t\t-- split on commas\n\t\tfor word in txt:gmatch('[^,]+') do\n\
    \t\t\tresult[#result + 1] = word\n\t\tend\n\tend\n\treturn result\nend", "  --\
    \ Initialize an empty list of words.\n  local words = {}", "  local words = {\
    \ }\n  for w in txt:gmatch('(%S+)') do\n    if words[w] ~= nil then\n      words[w]\
    \ = words[w] or 1\n      words[w] = words[w] + 1\n    else\n      words[w] = 1\n\
    \    end\n  end\n  return words\nend", "  local word_table = {}\n  local word_count\
    \ = 1\n  local whitespace_count = 0\n  local comma_count = 0\n  local new_words\
    \ = {}\n  local new_word = \"\"\n  local new_word_len = 0\n  local new_word_len2\
    \ = 0\n  local last_word = \"\"\n  local last_word_len = 0\n  local last_word_len2\
    \ = 0\n  for w in txt:gmatch(\"[^ ]+\") do\n    if w ~= \"\" then\n      if whitespace_count\
    \ == 0 then\n        word_count = word_count + 1\n        last_word = w\n    \
    \  elseif whitespace_count == 1 then\n        word_count = word_count + 1\n  \
    \      last_word = last_word .. w\n      elseif whitespace_count == 2 then\n \
    \       word_count = word_count + 1\n        last_word = last_word .. \",\" ..\
    \ w\n      else\n        word_count = word_count + 1\n        whitespace_count\
    \ = whitespace_count + 1\n        new_word = new_word .. w\n      end\n      if\
    \ w ~= \"\" and w ~= \",\" then\n        whitespace_count = whitespace_count +\
    \ 1\n      else\n        whitespace_count = 0\n      end\n    end\n  end\n  if\
    \ last_word ~= \"\" then\n    if whitespace_count > 0 then\n      word_count =\
    \ word_count + 1\n    end\n    if whitespace_count == 1 then\n      word_count\
    \ = word_count + 1\n    end\n    if whitespace_count == 2 then\n      word_count\
    \ = word_count + 1\n    end\n    if whitespace_count == 3 then\n      word_count\
    \ = word_count + 1\n    end\n  end\n  for i = 1,word_count do\n    local word_len\
    \ = 0\n    local word_len2 = 0\n    if i <= word_count then\n      word_len =\
    \ last_word_len + #last_word\n    else\n      word_len = #new_word\n    end\n\
    \    if i <= word_count then\n      word_len2 = #new_word\n    else\n      word_len2\
    \ = #new_word\n    end\n    new_word_len = new_word_len + word_len\n    new_word_len2\
    \ = new_word_len2 + word_len2\n    if i <= word_count then\n      table.insert(new_words,\
    \ new_word)\n      new_word = \"\"\n    else\n      table.insert(new_words, new_word\
    \ .. \",\")\n      new_word = \"\"\n    end\n    if i <= word_count then\n   \
    \   last_word = \"\"\n    else\n      last_word = last_word .. \",\" .. #last_word\n\
    \    end\n  end\n  table.insert(new_words, new_word)\n  return new_words\nend",
  '  local alphabet = string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.',
  "   -- The 'words' variable will contain the words\n   -- This variable is declared\
    \ outside the loop because we do not want the function to redeclare it every time\
    \ the loop runs\n   -- The variable is declared outside of the loop because if\
    \ we declare it inside the loop the variable is reinitialized with the next element\
    \ of the for loop\n   local words = {}\n   -- We have to find the length of txt\
    \ because it is possible to have an empty string passed as input\n   -- In this\
    \ case, an empty string will have the length of 1 so we will add one to our index\n\
    \   -- to find the actual length of the string\n   local index_of_length = 1\n\
    \   -- Now we start searching the string\n   for i = 1, #txt do\n      -- If the\
    \ current character is a space, we add it to the words table with the current\
    \ word being an empty string\n      if txt[i] == ' ' then\n         table.insert(words,\
    \ {})\n         -- If the current character is a space, we add it to the words\
    \ table with the current word being an empty string\n      elseif i == #txt then\n\
    \         -- We insert 'index_of_length' to the words table with the current word\
    \ being an empty string\n         table.insert(words, {})\n         -- We increment\
    \ our index\n         index_of_length = index_of_length + 1\n      -- If the current\
    \ character is not a space or we are at the end of the string then we insert 'index_of_length'\
    \ to the words table\n      else\n         -- We insert 'index_of_length' to the\
    \ words table with the current word being an empty string\n         table.insert(words,\
    \ {})\n         -- We increment our index\n         index_of_length = index_of_length\
    \ + 1\n      end\n   end\n   -- We return the words table\n   return words\nend",
  "   -- split the given string on whitespace\n   local words = txt:gmatch('([^ ])')\n\
    \   -- if no whitespace exist then split on comma\n   if not words then\n    \
    \  return txt:gsub(',', '%a')\n   else\n      return words\n   end\nend", "\t\
    local ret = {}\n\tlocal words = {''}\n\tfor i = 1, #txt do\n\t\ttable.insert(words,\
    \ string.sub(txt, 1, i))\n\tend\n\tlocal i = 0\n\tfor _, w in pairs(words) do\n\
    \t\tret[i] = w\n\t\ti = i + 1\n\tend\n\treturn ret\nend", "   if #txt == 0 then\
    \ return {} end\n   local num_letters = #txt\n   local letters = {}\n   for i\
    \ = 1, num_letters do\n      if txt:sub(i, i) = \"\" then \n         break\n \
    \     else\n         table.insert(letters, txt:sub(i, i))\n      end\n   end\n\
    \   return letters\nend", "    -- Remove whitespace from the text\n    local txt\
    \ = txt:gsub(' ', '')\n    -- Split the text on commas\n    local tbl = txt:gsub(',',\
    \ ' ')\n    -- Count the lower-case letters with odd order in the alphabet\n \
    \   local count = 1\n    for c in tbl:gmatch('a') do\n        if ord(c) then\n\
    \            count = count + 1\n        end\n    end\n    -- Return words split\
    \ on whitespace if no whitespaces\n    if not txt then return {} end\n    -- If\
    \ no commas exist return the number of lower-case letters with odd order in the\
    \ alphabet\n    if count ~= 1 then return count end\n    -- Return the words\n\
    \    return tbl\nend", "\tlocal words = {}\n\tlocal letters = {}\n\tlocal count\
    \ = 0\n\tfor i = 1, #txt do -- loop over each char in the string\n\t\tcount =\
    \ count + 1\n\t\tif count % 2 == 0 then -- even letters only\n\t\t\tif letters[i\
    \ - 1] ~= '' then\n\t\t\t\ttable.insert(words, letters[i - 1])\n\t\t\tend\n\t\t\
    else\n\t\t\ttable.insert(words, tostring(txt:sub(i, i):lower()))\n\t\tend\n\t\t\
    letters[count] = tostring(txt:sub(i, i))\n\tend\n\tlocal newwords = {}\n\tfor\
    \ i = 1, #words do\n\t\tif words[i] == '' then -- remove empty strings\n\t\t\t\
    words[i] = nil\n\t\telse\n\t\t\ttable.insert(newwords, words[i])\n\t\tend\n\t\
    end\n\treturn newwords\nend", "  -- Initialize variables\n  local num_words =\
    \ 0\n  local word_table = {}", "    local words = { }\n    local chars = {}\n\
    \    for i = 1, #txt do\n        -- Convert letters to lowercase\n        local\
    \ char = string.sub(txt, i, i)\n        char = string.lower(char)", "  if type(txt\
    \ == 'string') then\n    return txt:gsub(' ', ',')\n  end\n  return #txt + 1\n\
    end", "\tlocal words = { }\n\tlocal comma_idx\n\tlocal word_idx\n\tlocal new_word",
  "    local w = {}\n    local i = 0\n    local last_index = -1\n    local last_char\n\
    \    local has_comma = false\n    for last_char, last_index in string.gsub(txt,\
    \ \"([^A-Za-z]+|[^A-Za-z]+,?)\", function (c)\n        has_comma = has_comma or\
    \ c == ','\n        if has_comma then w[#w + 1] = w and w[#w + 1] or '' end\n\
    \        w[#w + 1] = c or last_char\n        if c == ' ' then return '' end\n\
    \    end) do\n        w[#w + 1] = w and w[#w + 1] or ''\n    end\n    if has_comma\
    \ then w[#w + 1] = w and w[#w + 1] or '' end\n    return w\nend", "  if txt:match('\
    \ -- ') then\n    return {'-- ', txt:match(' -- ')}\n  elseif txt:match(',') then\n\
    \    return txt:match(',')\n  else\n    local s = ''\n    local i, l = 1, #txt\n\
    \    local odd = 0\n    while i <= l do\n      i = i + 1\n      if not s[i] then\n\
    \        return s:sub(1, i - 1)\n      end\n      if s[i]:byte() ~= ' ' then\n\
    \        odd = odd + 1\n      end\n    end\n    if odd % 2 == 1 then\n      local\
    \ count = 0\n      local _i, _l = 1, #txt\n      for _i = 1, _l do\n        if\
    \ txt[_i]:byte() ~= ' ' then\n          count = count + 1\n        else\n    \
    \      return txt:sub(1, i)\n        end\n      end\n      return count\n    end\n\
    \  end\nend", "  if txt == '' then\n    return {}\n  elseif ',' ~= txt:sub(1,1)\
    \ then\n    -- split on commas\n    return string.gsub(txt, \"([^\" .. alphabet(string.lower(txt))\
    \ .. \"]+)\", \",\" .. alphabet(string.lower(string.sub(txt,1,1))))\n  else\n\
    \    -- split on whitespaces\n    local words = string.gsub(txt, \"[ ]+\", \"\
    \ \")\n    local wordlist = words:gsub(\"([\" .. alphabet(string.lower(string.sub(words,\
    \ 1, 1))) .. \"]+)\", \" \" .. alphabet(string.lower(string.sub(words, 1, 1))))\n\
    \    local count = string.find(wordlist, \" \")\n    return wordlist:sub(1, count\
    \ + 1)\n  end\nend", "  if txt == '' then\n    return nil\n  end\n  local words\
    \ = { }\n  local num_comma = 0\n  for i = 1, #txt do\n    local c = txt:sub(i,\
    \ i)\n    if c == ',' then\n      num_comma = num_comma + 1\n    elseif c ~= ''\
    \ and num_comma == 1 then\n      num_comma = 0\n      table.insert(words, c)\n\
    \    end\n  end\n  return words\nend", "   local whitespace_pos = txt:find(\"\
    \ \")\n   if whitespace_pos == nil then\n      return string.rep(\" \", txt:len())\n\
    \   end\n   local commas_pos = txt:find(\",\")\n   if commas_pos == nil then\n\
    \      return txt:gsub(\"%S+\", \" \"):gsub(\"[%z%s]+\", function(s)\n       \
    \  if s == \"-\" or s == \"\u2013\" then\n            return \"\"\n         end\n\
    \         if s == \"\" then\n            return \"\"\n         end\n         local\
    \ count = {}\n         for i, v in pairs(s:gsub(\"[^%w]\", \"\")) do\n       \
    \     count[i] = count[i] + 1\n         end\n         for k, v in pairs(count)\
    \ do\n            if v % 2 == 1 then\n               return k\n            end\n\
    \         end\n      end)\n   else\n      return txt:gsub(\"%S+\", \" \"):gsub(\"\
    [%z%s]+\", function(s)\n         if s == \"-\" or s == \"\u2013\" then\n     \
    \       return \"\"\n         end\n         if s == \"\" then\n            return\
    \ \"\"\n         end\n         local count = {}\n         for i, v in pairs(s:gsub(\"\
    [^%w]\", \"\")) do\n            count[i] = count[i] + 1\n         end\n      \
    \   for k, v in pairs(count) do\n            if v % 2 == 0 then\n            \
    \   return k\n            end\n         end\n      end)\n   end\nend", "\tlocal\
    \ words = {}", "\tlocal tab = {}\n\tlocal n = #txt\n\tif n >= 1 then\n\t\ttab[1]=txt:sub(1,1)\n\
    \tend\n\tfor i = 2, n do\n\t\ttab[i] = txt:sub(i,i)\n\tend\n\tif n == 1 then\n\
    \t\treturn tab\n\telseif n >= 2 then\n\t\tlocal w = txt:sub(n,n)\n\t\tif w ~=\
    \ \"\" then\n\t\t\treturn split_words(w) .. \",\" .. tab\n\t\telse\n\t\t\treturn\
    \ tab\n\t\tend\n\tend\nend", "  local splitter = {}\n  local words = string.gsub(txt,\
    \ \" \", \"\")\n  splitter[1] = words[1]\n  -- Remove consecutive commas\n  splitter[2]\
    \ = string.gsub(words[2], \",\", \".\")\n  -- Remove consecutive periods\n  splitter[3]\
    \ = string.gsub(words[3], \".\", \"\")\n  -- Remove leading periods\n  splitter[4]\
    \ = string.gsub(splitter[3], \"^.\", \"\")\n  -- Remove any words with a single\
    \ character\n  splitter[5] = string.gsub(splitter[4], \"^[^a-zA-Z]\", \"\")\n\
    \  return string.gsub(splitter[5], \".\", \",\")\nend", "  local counts = {}\n\
    \  for i = 1, string.len(txt) do\n    local char = string.sub(txt,i,i)\n    counts[string.lower(char)]\
    \ = counts[string.lower(char)] or 1\n  end\n  return counts\nend", "  if txt ==\
    \ \"hello\" then return {\"hello\"} end\n  if string.sub(txt,1,1) ~= '#' then\
    \ return txt:gsub(\"%S+\", \" \"):gsub(\"^%s+\", \"\"):gsub(\"[%-]+\", \" \"):gsub(\"\
    \  +\", \" \") end\n  local word_table = {}\n  for word in txt:gmatch(\"[%-]+\"\
    ) do\n    table.insert(word_table, word)\n  end\n  return word_table\nend", " \
    \ local num_commas = 0\n  local num_whitespaces = 0\n  local num_lowcase_odd =\
    \ 0\n  local num_lowcase_even = 0\n  local table = {}\n  for c in string.gmatch(txt,\
    \ '([^,]+)')\n  do\n    local lower = string.lower(c)\n    if lower == c then\n\
    \      table.insert(table, c)\n      if c ~= string.lower(string.sub(c, 1, 1))\
    \ then\n        num_lowcase_even = num_lowcase_even + 1\n      else\n        num_lowcase_odd\
    \ = num_lowcase_odd + 1  \n      end\n      num_lowcase_even = num_lowcase_even\
    \ + 1\n    elseif num_commas == 0 then\n      table.insert(table, num_whitespaces)\n\
    \      table.insert(table, num_commas + c)\n      num_commas = num_commas + 1\n\
    \    elseif num_whitespaces == 0 and num_commas == 1 then\n      table.insert(table,\
    \ num_whitespaces)\n      table.insert(table, num_commas + c)\n      num_commas\
    \ = num_commas + 1\n    elseif num_whitespaces == 0 and num_commas > 1 then\n\
    \      table.insert(table, num_whitespaces)\n      table.insert(table, num_commas\
    \ + c)\n      num_commas = num_commas + 1\n    elseif num_whitespaces == 0 then\n\
    \      table.insert(table, num_whitespaces)\n      table.insert(table, num_commas\
    \ + c)\n      num_commas = num_commas + 1\n      num_whitespaces = num_whitespaces\
    \ + 1\n    elseif num_commas == 1 then\n      table.insert(table, num_whitespaces)\n\
    \      table.insert(table, num_commas + c)\n      num_commas = num_commas + 1\n\
    \      num_whitespaces = num_whitespaces + 1\n    end\n  end\n  return table\n\
    end", "   local words = {}\n   local word = ''\n   local count = 0\n   local letter\
    \ = ''\n   for letter, count in pairs(txt:gmatch'(%a+)') do\n      if word ==\
    \ '' then\n         word = letter\n      else\n         if count == 1 then\n \
    \           words[#words+1] = word\n         else\n            words[#words+1]\
    \ = word .. letter\n         end\n         word = ''\n         count = 0\n   \
    \   end\n   end\n   if word ~= '' then\n      words[#words+1] = word\n   end\n\
    \   return words\nend", "    return txt:gsub(\"[%w]+\", function(word) return\
    \ word:lower() end)\nend", "   local words = { }\n   local w = {}\n   local word_count\
    \ = 1\n   for i = 1, #txt do\n      local c = string.sub(txt, i, i)\n      if\
    \ not w then\n         w[#w + 1] = c\n      elseif c == ' ' then\n         word_count\
    \ = word_count + 1\n         w[word_count] = c\n      else\n         w[word_count]\
    \ = c\n         table.insert(words, table.concat(w, ' '))\n         word_count\
    \ = 1\n         w = {}\n      end\n   end\n   table.insert(words, table.concat(w,\
    \ ' '))\n   return words\nend", "  return string.rep(\" \",  string.len(txt))\
    \ .. string.gsub(txt, \"([^\" .. string.char(string.byte(\"a\"),string.byte(\"\
    z\")) .. \"]+)\", string.char(\"a\"))\nend", "    if txt == '' then\n        return\
    \ {}\n    end", "   -- Remove non-alphanumeric characters\n   txt = string.gsub(txt,\
    \ \"[^a-zA-Z0-9]+\", \"\")\n   -- If we have at least one whitespace character\
    \ replace it with commas\n   if not string.find(txt, \"%s*\") then\n      txt\
    \ = string.gsub(txt, \" \", \",\")\n   end\n   -- return number of letters with\
    \ odd order\n   return #string.gsub(txt, \"[%a..%s]\", function(c)\n      return\
    \ string.sub(c, -1, 1)\n   end) - 1\nend", "    local words = string.gsub(txt,\
    \ \"[^ a-zA-Z]\", function (w) \n        return w:lower() \n    end)\n    return\
    \ string.gsub(words, \"[,-]+\", \", \")\nend", "   local words = {}\n   for word\
    \ in string.gmatch(txt, '[^ ]+') do\n      if words[word] == nil then\n      \
    \   words[word] = 1\n      else\n         words[word] = words[word] + 1\n    \
    \  end\n   end\n   return words\nend", "    -- Handle edge case first\n    if\
    \ not txt then return {} end", "  local split_words = table.new()\n  for word\
    \ in string.gmatch(txt, '([^ \\n]+)?') do\n    split_words[#split_words + 1] =\
    \ word\n  end\n  return split_words\nend", "   if txt:match(\"^%s+$\") then return\
    \ { txt } end\n   if txt:match(\"^%s+\") then\n      local words = txt:gsub(\"\
    (%S+)\", function(word)\n         if word:find(\"^[%Z%a%A%b%B%c%C%d%D%e%E%f%F%g%G%H%I%j%J%k%K%l%L%m%M%n%N%o%O%p%P%q%Q%r%R%s%S%t%T%u%U%v%V%w%W%x%X%y%Y%z%Z%\"\
    ) then return word end\n         if word:find(\"^[%Z%a%A%b%B%c%C%d%D%e%E%f%F%g%G%H%I%j%J%k%K%l%L%m%M%n%N%o%O%p%P%q%Q%r%R%s%S%t%T%u%U%v%V%w%W%x%X%y%Y%z%Z%$\"\
    ) then return word end\n         if word:find(\"^%z%z\") then return word end\n\
    \         if word:find(\"^%z$\") then return word end\n         if word:find(\"\
    ^%z\") then return word end\n         if word:find(\"^%Z%z\") then return word\
    \ end\n         if word:find(\"^%Z%z$\") then return word end\n         if word:find(\"\
    ^%Z$\") then return word end\n         if word:find(\"^%z%$\") then return word\
    \ end\n         if word:find(\"^%z%\") then return word end\n         if word:find(\"\
    ^%z%z\") then return word end\n         if word:find(\"^%z\") then return word\
    \ end\n         if word:find(\"^%$\") then return word end\n         if word:find(\"\
    ^%\") then return word end\n         if word:find(\"^%A\") then return word end\n\
    \         if word:find(\"^%a\") then return word end\n         if word:find(\"\
    ^%B\") then return word end\n         if word:find(\"^%b\") then return word end\n\
    \         if word:find(\"^%C\") ", "  return string.gmatch(txt, \"[%a]+\")\nend",
  "\tlocal tbl = {}\n\tlocal alpha = {}\n\tlocal last_index = {}\n\t-- Count the letters\
    \ in the alphabet\n\tfor idx = 0, #ALPHABET do\n\t\talpha[ALPHABET[idx]] = true\n\
    \tend\n\tfor idx = 1, #txt do -- Iterate through the text\n\t\tlocal word = string.sub(txt,\
    \ idx, #txt) -- Slice the string from idx to last index\n\t\tif word == \"\" then\
    \ break end\n\t\tlocal space_index = string.find(word, \" \") -- Find the first\
    \ space (index) where the string can contain spaces\n\t\tif space_index ~= nil\
    \ then -- If there is a space in the string\n\t\t\t-- Put the string in the first\
    \ element of the table\n\t\t\ttbl[1] = word\n\t\t\t-- Remove the first element\
    \ of the table and append the rest of the string to the end of the table\n\t\t\
    \tfor idx = 2, #txt do tbl[idx] = string.sub(txt, idx, #txt) end\n\t\telse --\
    \ If there are no spaces in the string\n\t\t\t-- Put the string in the first element\
    \ of the table\n\t\t\ttbl[1] = word\n\t\t\t-- Append the rest of the string to\
    \ the end of the table\n\t\t\tfor idx = 2, #txt do tbl[idx] = word end\n\t\tend\n\
    \tend\n\t-- Remove the letters that weren't in the alphabet\n\tfor idx = 1, #tbl\
    \ do\n\t\ttbl[idx] = tbl[idx]:sub(ALPHABET[#ALPHABET])\n\tend\n\treturn tbl\n\
    end", "    return txt:gmatch('([^,]*)(%s*(.-)%s*$)'):totable()\nend", "  local\
    \ words = { }\n  for i = 1, #txt do\n    words[i] = txt:sub(i,i)\n  end\n  local\
    \ len = #words\n  if len == 1 then\n    return words[1]\n  end\n  if len > 0 then\n\
    \    local chars = {}\n    local split = 0\n    local count = 0\n    for i = 1,\
    \ len do\n      if words[i]:sub(1,1) ~= ',' then\n        char = words[i]:sub(1,1)\n\
    \        if char:lower() ~= char:upper() then\n          chars[count] = char\n\
    \          count = count + 1\n        end\n      else\n        split = split +\
    \ 1\n        words[i] = words[i]:sub(2,#words[i])\n      end\n    end\n    if\
    \ split > 0 then\n      chars[count] = chars[count]:sub(1)\n      count = count\
    \ + 1\n    end\n    if count % 2 ~= 0 then\n      chars[count-1] = chars[count-1]:upper()\n\
    \    end\n    for i = 1, #words do\n      words[i] = chars[i]\n    end\n  end\n\
    \  return words\nend", "  local w = {}\n  local words = txt:gsub('%w', ''):gsub('[^a-zA-Z]',\
    \ '')\n  for i = 1, #words do\n    w[i] = words[i]\n  end\n  if #w % 2 == 1 then\n\
    \    table.insert(w, words[#words])\n  end\n  return w\nend", "    return txt:gsub('[^'..string.lower(string.letters())\
    \ .. ']+', function(x)\n        return x:gsub('%z'):reverse():sub(1,2):reverse():sub(1,1)\n\
    \    end)\nend", "  if txt ~= '' then\n    local num_commas = 0\n    local num_spaces\
    \ = 0\n    local num_lowers = 0\n    local num_uppers = 0\n    local num_digits\
    \ = 0\n    local num_alpha = 0\n    local num_alpha_inverse = 0\n    local result\
    \ = {}\n    for i = 1, #txt do -- For each character in the string.\n      local\
    \ character = string.sub(txt, i, i)\n      if character == ',' then num_commas\
    \ = num_commas + 1 end\n      if character == ' ' then num_spaces = num_spaces\
    \ + 1 end\n      if character >= 'a' and character <= 'z' then num_lowers = num_lowers\
    \ + 1 end\n      if character >= 'A' and character <= 'Z' then num_uppers = num_uppers\
    \ + 1 end\n      if character >= '0' and character <= '9' then num_digits = num_digits\
    \ + 1 end\n      if character >= 'a' and character <= 'z' or character >= 'A'\
    \ and character <= 'Z' then\n        num_alpha = num_alpha + 1\n      end\n  \
    \    if character == 'a' or character == 'A' then\n        num_alpha_inverse =\
    \ num_alpha_inverse + 1\n      end\n      if character = '%' then\n        num_digits\
    \ = num_digits + 1\n      end\n      table.insert(result, character)\n    end\n\
    \    if num_spaces > 0 then -- If the string has spaces then we should split on\
    \ commas\n      table.insert(result, ',')\n      num_commas = num_commas + 1\n\
    \    end\n    if num_commas > 0 then -- If the string has commas then we should\
    \ split on spaces\n      table.insert(result, ' ')\n      num_spaces = num_spaces\
    \ + 1\n    end\n    if num_digits > 0 then -- If the string has digits then we\
    \ should split on commas\n      table.insert(result, ',')\n      num_commas =\
    \ num_commas + 1\n    end\n    local alpha_inverse\n    if num_lowers > 0 then\
    \ -- If the string has lower-case letters then we should split on commas\n   \
    \   table.insert(result, '\"')\n      num_commas = num_commas + 1\n      alpha_inverse\
    \ = num_alpha_inverse + 1\n    end\n    local num_chars = #result\n    if num_uppers\
    \ > 0 then -- If the string has upper-case letters then we should split on commas\n\
    \      table.insert(result, '\"')\n      num_commas = num_commas + 1\n      alpha_inverse\
    \ = num_alpha_inverse + num_chars\n    end\n    if num_digits > 0 then\n     \
    \ table.insert(result, '\"')\n      num_commas = num_commas + 1\n      alpha_inverse\
    \ = ", "    local tbl = {}\n    local ws = txt:sub(1, 1):gsub('%S+', function(c)\
    \ tbl[#tbl+1] = c; return '' end)\n    local num_letters = txt:sub(2, 2) and tonumber(txt:sub(2,\
    \ 2):gsub('%S+', function(c) tbl[#tbl+1] = c; return '' end))\n    if ws then\n\
    \        local cs = ws:gsub('%S+', function(a) tbl[#tbl+1] = a return '' end)\n\
    \        return num_letters and cs or #tbl\n    else\n        return #tbl\n  \
    \  end\nend", "    local words = {}\n    for i = 1, #txt do\n        if txt:sub(i,\
    \ i) ~= ' ' then\n            table.insert(words, txt:sub(i, i))\n        else\n\
    \            local w = txt:sub(i, i + 1)\n            table.insert(words, w)\n\
    \        end\n    end\n    local length = 0\n    for _, v in pairs(words) do\n\
    \        length = length + #v\n    end\n    local n = 0\n    for _, v in pairs(words)\
    \ do\n        n = n + (#v > 0 and 1 or 0)\n    end\n    if length == 1 then\n\
    \        return words\n    end\n    if n == 1 then\n        local w = words[#words]\n\
    \        return {w}\n    end\n    local word = {}\n    for i = 1, #words do\n\
    \        table.insert(word, words[i])\n    end\n    table.sort(word)\n    return\
    \ word\nend", "    local words = {}\n    local count = 0\n    for w in str:gmatch('[^\
    \ ]+') do\n        count = count + 1\n        words[count] = w\n    end\n    return\
    \ count\nend\n</cell>\n<text>\nThe table function takes a list as input and outputs\
    \ the list of elements separated by a comma", "  if txt == nil or txt == '' or\
    \ txt == '0' then return nil end\n  local words = string.gsub(txt,' ','')\n  if\
    \ #words == 0 then return nil end\n  words = string.gsub(words,',','')\n  if #words\
    \ == 0 then return 1 end\n  local num_words = 0\n  for w in string.gmatch(words,'[^A-Za-z]+')\
    \ do\n    num_words = num_words + 1\n  end\n  return num_words\nend", "    local\
    \ words = {}\n    local words = split(txt,' ') -- split on whitespace\n    for\
    \ i = 1,#words do\n        words[i] = words[i]..','\n    end\n    return #words\n\
    end", "    local ret = {}\n    local words = txt:gsub(\"(%S+)\", function (x)\n\
    \        if x:find(\" \") then\n            local s = x:gsub(\"([\" .. string.char(string.byte('a'),\
    \ string.byte('z')) .. \"]+)\", \"\")\n            if s == \"\" then s = x end\n\
    \            table.insert(ret, s)\n        else\n            table.insert(ret,\
    \ x)\n        end\n    end)\n    if #words > 0 then\n        table.sort(ret)\n\
    \    end\n    return ret\nend", "    local split_str = {}\n    local word_num\
    \ = 0\n    local word = ''\n    local split_flag = false\n    local word_count\
    \ = 0\n    for w in string.gmatch(txt, '%w+') do\n        if w ~= nil and w ~=\
    \ '' then\n            split_str = split_str or {}\n            word = word ..\
    \ ' ' .. w\n            if word ~= nil then\n                if split_flag then\n\
    \                    split_str[#split_str + 1] = word\n                else\n\
    \                    split_str[word_num] = word\n                    word_count\
    \ = word_count + 1\n                end\n                word = ''\n         \
    \       word_num = word_num + 1\n            end\n        else\n            if\
    \ word ~= nil then\n                split_str[word_num] = word\n             \
    \   word_count = word_count + 1\n            end\n        end\n        split_flag\
    \ = split_flag or w ~= nil\n    end\n    return word_count, split_str\nend", " \
    \ local num_commas = 0\n  local num_whitespace_found = 0\n  for w in string.gmatch(txt,\
    \ \"([^,]+)\"..\"|([^ ]+)\")\n  do\n    if w ~= \"\" then\n      num_whitespace_found\
    \ = num_whitespace_found + 1\n    end\n    if w ~= nil then\n      num_commas\
    \ = num_commas + 1\n    end\n  end\n  if num_whitespace_found == 0 then\n    num_commas\
    \ = num_commas/2\n  end\n  num_commas = num_commas + 1\n  num_commas = num_commas\
    \ - 1\n  num_commas = num_commas - 1\n  return num_commas\nend", "\tlocal w =\
    \ {}\n\tfor w in string.gmatch(txt, '[^ ]+') do\n\t\tw[#w + 1] = tolower(w)\n\t\
    end\n\treturn w and #w or 0\nend", "    local whitespaces = {\n        [' '] =\
    \ true,\n        ['\\n'] = true,\n        ['\\r'] = true,\n        ['\\t'] = true,\n\
    \        ['!'] = true,\n        ['.'] = true,\n    }\n    local commas = string.gmatch(txt,\
    \ '%w+,?')\n    local no_whitespaces = string.gmatch(txt, '%w+')\n    local word_count\
    \ = {}\n    local word_count_total = 0\n    local all_lowercase = false\n    for\
    \ word in string.gmatch(no_whitespaces, \"%w+\") do\n        all_lowercase = all_lowercase\
    \ or #word == 1\n        word_count_total = word_count_total + 1\n        word_count[word]\
    \ = word_count[word] and word_count[word] + 1 or 1\n    end\n    \n    -- handle\
    \ 'em\n    if not all_lowercase then\n        word_count_total = word_count_total\
    \ + 1\n        word_count[string.char(ord('A') + #word_count)] = word_count[string.char(ord('A')\
    \ + #word_count)] and word_count[string.char(ord('A') + #word_count)] + 1 or 1\n\
    \    end", "   if txt:match('^%s*$') then\n      return #txt, {}\n   elseif txt:match(',')\
    \ then\n      return #txt, { txt:gsub(',','') }\n   else\n      local count =\
    \ 0\n      local txt2 = txt:gsub('([a-z])',\n         function (c)\n         \
    \   if string.sub(c, 1, 1):lower() == 'a' then\n               count = count +\
    \ 1\n            elseif string.sub(c, 2, 2):lower() == 'b' then\n            \
    \   count = count + 1\n            elseif string.sub(c, 3, 3):lower() == 'c' then\n\
    \               count = count + 1\n            elseif string.sub(c, 4, 4):lower()\
    \ == 'd' then\n               count = count + 1\n            elseif string.sub(c,\
    \ 5, 5):lower() == 'e' then\n               count = count + 1\n            elseif\
    \ string.sub(c, 6, 6):lower() == 'f' then\n               count = count + 1\n\
    \            elseif string.sub(c, 7, 7):lower() == 'g' then\n               count\
    \ = count + 1\n            elseif string.sub(c, 8, 8):lower() == 'h' then\n  \
    \             count = count + 1\n            elseif string.sub(c, 9, 9):lower()\
    \ == 'i' then\n               count = count + 1\n            elseif string.sub(c,\
    \ 10, 10):lower() == 'j' then\n               count = count + 1\n            elseif\
    \ string.sub(c, 11, 11):lower() == 'k' then\n               count = count + 1\n\
    \            elseif string.sub(c, 12, 12):lower() == 'l' then\n              \
    \ count = count + 1\n            elseif string.sub(c, 13, 13):lower() == 'm' then\n\
    \               count = count + 1\n            elseif string.sub(c, 14, 14):lower()\
    \ == 'n' then\n               count = count + 1\n            elseif string.sub(c,\
    \ 15, 15):lower() == 'o' then\n               count = count + 1\n            elseif\
    \ string.sub(c, 16, 16):lower() == 'p' then\n               count = count + 1\n\
    \            elseif string.sub(c, 17, 17):lower() == 'q' then\n              \
    \ count = count + 1\n            elseif string.sub(c, 18, 18):lower() == 'r' then\n\
    \               count = count + 1\n            elseif string.sub(c, 19, 19):lower()\
    \ == 's' then\n               count = count + 1\n            elseif string.sub(c,\
    \ 20, 20):lower() == 't' then\n               count = count + 1\n            elseif\
    \ string.sub(c, 21, 21):lower() == 'u' then\n               count = count + 1\n\
    \            elseif string.sub(c, 22, 22):lower() == 'v' then\n              \
    \ count = count + 1\n            elseif string.sub(c, 23, 23):lower() == 'w' then\n\
    \               count = count + 1\n            elseif string.sub(c, 24, 24):lower()\
    \ == 'x' then\n               ", "  if txt:find(' ') then\n    local w\n    if\
    \ txt:sub(1, 1):find(',') then\n      w = txt:sub(1, 1):gsub('(.)','%1 ')\n  \
    \  else\n      w = txt:sub(1, 1):upper():gsub('(.)','%1 ')\n    end\n    local\
    \ e = txt:find(w)\n    local n = #txt\n    local f = {}\n    for i=w,1,-1 do\n\
    \      f[#f+1] = txt:sub(i,i)\n    end\n    return n+1, f\n  end\n  return 0,\
    \ {txt}\nend", "    local w = {}\n    local num_lower = 0\n    for w in txt:gmatch('[^\
    \ ]+') do\n        num_lower = num_lower + 1\n    end\n    if num_lower % 2 ~=\
    \ 0 then\n        return nil\n    end\n    local num_words = num_lower / 2\n \
    \   for w in txt:gmatch('[^ ]+') do\n        num_words = num_words + 1\n    end\n\
    \    return w\nend", "\t-- Remove whitespaces from both ends of the string\n\t\
    txt = txt:gsub('%s+','')\n\ttxt = txt:gsub('-%s+','')", "  local letters = {}\n\
    \  for w in string.gmatch(txt, \" \") do\n    for i = string.len(w) - 1, 1, -1\
    \ do\n      table.insert(letters, string.sub(w,i,i))\n    end\n  end\n  return\
    \ letters\nend", "    local counts = {}\n    for w in txt:gmatch(\"%w+\") do\n\
    \        counts[#counts + 1] = w\n    end\n    return counts\nend", "  -- Remove\
    \ any whitespace\n  -- Split on commas if no whitespaces are present\n  -- Remove\
    \ all non-alphabetic characters from each word\n  -- Remove any whitespace\n \
    \ -- Return the number of letters in the alphabet with odd order\n  -- Example:\n\
    \  -- 'abc, def' -> {'abc', 'def'}\n  -- 'abc'    -> {'abc'}\n  -- 'abcd'   ->\
    \ {'abcd'}\n  -- 'abcde'  -> {'abcde'}\n  -- 'abcdef' -> 3\n  -- Note: This function\
    \ assumes the input consists of only alphanumeric characters (ASCII characters\
    \ plus 26 lowercase\n  -- and uppercase letters). The first letter of the alphabet\
    \ is not included in the count. If you want to count the\n  -- \"first\" letter\
    \ of the alphabet as 0, remove the `- 65` from the `math.abs` call.\n  local count\
    \ = 0\n  for w in string.gmatch(txt, '([^ \\n]+)')\n    do\n      local w = string.lower(w)\n\
    \      count = count + 1\n    end\n  -- Return only the alphabet\n  return count\n\
    end", "   if string.find(txt, ' ') then\n      local words = string.gsub(txt,\
    \ ' ', '\\n')\n      return table.concat(words..split(','))\n   elseif string.find(txt,\
    \ ',') then\n      return string.gsub(txt, ',', '\\n')\n   else\n      return\
    \ string.gsub(txt, '[a-z][A-Z]', '\\n')\n   end\nend", "   local words = {}\n\
    \   local whitespace = {}\n   local comma = {}\n   local num = 0\n   for char\
    \ in txt:gmatch(\"[%z%p]+\") do\n      if whitespace[char] then\n         table.insert(words,\
    \ table.concat(whitespace))\n         whitespace = {}\n      elseif comma[char]\
    \ then\n         table.insert(words, table.concat(comma))\n         comma = {}\n\
    \         table.insert(words, char:lower())\n         num = num + 1\n      else\n\
    \         table.insert(whitespace, char)\n      end\n   end\n   if whitespace[1]\
    \ then\n      table.insert(words, table.concat(whitespace))\n   end\n   if comma[1]\
    \ then\n      table.insert(words, table.concat(comma))\n   end\n   if #words ==\
    \ num then\n      return #words - 1\n   else\n      return #words\n   end\nend",
  "\tlocal words = {}\n\tlocal count = 1\n\tfor c in txt:gmatch(\"[^ ]+\") do\n\t\t\
    if #words > count then\n\t\t\treturn words\n\t\tend\n\t\twords[#words+1] = c\n\
    \t\tcount = count + 1\n\tend\n\treturn words\nend", "   local words = { }\n  \
    \ local alpha = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n   for w in\
    \ string.gmatch(txt, \"%w\") do\n      table.insert(words, w)\n   end\n   for\
    \ i, w in ipairs(words) do\n      words[i] = string.gsub(w, \" \", \"\")\n   end\n\
    \   for i, w in ipairs(words) do\n      if w ~= \"\" then\n         words[i] =\
    \ string.lower(w)\n      end\n   end\n   if #words % 2 == 0 then\n      table.insert(words,\
    \ words[#words])\n   end\n   local n = #words\n   for i = 2, n do\n      words[i]\
    \ = words[i]..(words[i-1] or \"\")\n   end\n   return n\nend", "  -- remove whitespace\n\
    \  local tbl = {}\n  for w in string.gmatch(txt, \"%S+\") do\n    tbl[w] = true\n\
    \  end\n  -- remove comma\n  if #tbl > 0 then\n    for i = 1, #tbl do\n      tbl[string.sub(txt,\
    \ i, i)] = true\n    end\n  end\n  -- remove letters\n  for i = 1, 26 do\n   \
    \ tbl[i] = false\n  end\n  -- find even number of letters\n  for i = 1, #tbl do\n\
    \    if tbl[i] and #tbl ~= 1 then\n      return i\n    end\n  end\n  -- no commas\
    \ found\n  return #tbl\nend", "   local spaces, commas = string.gsub(txt, ' ',\
    \ '|'), string.gsub(txt, ',', '|')\n   local count = {}\n   for _,v in ipairs(string.gmatch(commas,\
    \ '([^|]+)'..spaces)) do\n      count[v] = count[v] or 1\n      count[v] = count[v]\
    \ + 1\n   end\n   return count\nend", "   local words = txt:gsub(\"[\\s,]+\",\
    \ \"%d\"):gsub(\"[^a-zA-Z%d]\", ''):lower()\n   return words\nend", "\tlocal split_function\n\
    \tlocal count_function\n\t\n\t-- Split on whitespace by default\n\tsplit_function\
    \ = string.split\n\t\n\t-- Split on commas ',' if no commas exists in the text\n\
    \tif txt ~= nil and txt:sub(-1) == ',' then\n\t\tsplit_function = string.gsub\n\
    \tend\n\t\n\t-- Count how many lowercase letters with odd order in the alphabet\n\
    \tcount_function = function(str)\n\t\treturn #str:gsub(string.lower, '%l'):gsub('%d%d%d%d%d%d'):gsub('%d%d%d%d%d%d%d%d%d',\
    \ '%d'):gsub('%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d",
  "    local white = unpack(setmetatable({} , {__index = function(t, k) return (t[k])\
    \ end}))\n    local comma = unpack(setmetatable({} , {__index = function(t, k)\
    \ return (t[k]) end}))\n    local lower = unpack(setmetatable({} , {__index =\
    \ function(t, k) return (t[k]) end}))\n    for _, v in ipairs(txt) do\n      \
    \  if v ~= white and v ~= comma and v ~= lower then\n            comma[comma +\
    \ 1] = v\n        elseif v == white then\n            white[white] = true\n  \
    \      elseif v == comma then\n            comma[comma + 1] = true\n        elseif\
    \ v == lower then\n            lower[lower] = true\n        end\n    end\n   \
    \ local ans = #comma\n    if #lower % 2 > 0 then\n        ans = ans - 1\n    end\n\
    \    local a = {}\n    for i = 1, ans do\n        a[#a + 1] = comma[i]\n    end\n\
    \    return a\nend", "    local function split(i)\n        -- If current character\
    \ is not whitespace\n        if i ~= ' ' then\n            -- Insert current character\
    \ into table\n            table.insert(words, i)\n        end\n    end\n    local\
    \ splitter = {}\n    table.insert(splitter, 0)\n    -- Split the text into words\n\
    \    for i,c in ipairs(txt) do\n        split(i)\n        -- If current character\
    \ is whitespace\n        if i ~= ' ' then\n            -- Split on comma\n   \
    \         if c == ',' then\n                table.insert(splitter, 0)\n      \
    \      -- Split on whitespace\n            else\n                table.insert(splitter,\
    \ i)\n            end\n        end\n    end\n    return #words * 2 -- Multiply\
    \ by two to account for comma and whitespace in text\nend", "  local words = txt:gmatch('(.-)%s*(.)',\
    \ 's')\n  -- remove empty strings\n  words = words and words[1] or ''\n  -- remove\
    \ comma if exists\n  if words and (words[#words] and words[#words] == ',')\n \
    \   then\n    words = words:sub(1, #words - 1)\n  end\n  -- lower-case letters\n\
    \  local count = #words and #words\n  while count > 0 and words[count-1] ~= 'a'\n\
    \    and (words[count-1] ~= 'b' or words[count-1] ~= 'c')\n    and (words[count-1]\
    \ ~= 'd' or words[count-1] ~= 'e')\n    and (words[count-1] ~= 'f' or words[count-1]\
    \ ~= 'g')\n    and (words[count-1] ~= 'h' or words[count-1] ~= 'i')\n    and (words[count-1]\
    \ ~= 'j' or words[count-1] ~= 'k')\n    and (words[count-1] ~= 'l' or words[count-1]\
    \ ~= 'm')\n    and (words[count-1] ~= 'n' or words[count-1] ~= 'o')\n    and (words[count-1]\
    \ ~= 'p' or words[count-1] ~= 'q')\n    and (words[count-1] ~= 'r' or words[count-1]\
    \ ~= 's')\n    and (words[count-1] ~= 't' or words[count-1] ~= 'u')\n    and (words[count-1]\
    \ ~= 'v' or words[count-1] ~= 'w')\n    and (words[count-1] ~= 'x' or words[count-1]\
    \ ~= 'y')\n    and (words[count-1] ~= 'z')\n    then count = count - 1\n  end\n\
    \  return count\nend", "    local words = {}\n    local lens = {}\n    local counts\
    \ = {}\n    local uppers = {}\n    for w in txt:gmatch('([%a][%a]+)') do\n   \
    \     local wlen = #w\n        if wlen == 0 then\n            wlen = #txt\n  \
    \      end\n        table.insert(words, w)\n        table.insert(lens, wlen)\n\
    \        table.insert(counts, 1)\n        if w ~= w then\n            table.insert(counts,\
    \ -1)\n        end\n        table.insert(uppers, #w)\n    end\n    return { words\
    \ = words, lens = lens, counts = counts, uppers = uppers }\nend", "  if txt ==\
    \ '' then return {} end\n  local w = string.gsub(txt, \"[%p%w%+%-%]\", ' ');\n\
    \  local num_comma = #w - #w % 2\n  local num_lower = #w - 1\n  if num_comma >\
    \ 0 then\n    w = string.gsub(w, \",\", \" \")\n  end\n  if num_lower % 2 == 1\
    \ then\n    w = string.gsub(w, function(x) return string.char(x+string.byte(x))\
    \ end, '()')\n  end\n  if num_comma > 0 then\n    w = string.gsub(w, \",\" ..\
    \ \",\" .. \",\" .. \",\" .. \" \", \" \")\n  end\n  return { [num_comma+num_lower]\
    \ = w }\nend", "   local w = {}\n   for w in txt:gmatch(\"[^'\\\" ]*\") do return\
    \ w end\n   return #txt ~= 0 and #txt % 2 == 0 and #txt < 26 and #txt - 2 or #txt\
    \ * 2\nend", "   local words = {}\n   -- Split on spaces and commas, no more than\
    \ 2 spaces, no more than 2 commas\n   for word in str:gmatch('([^ ,]+)(%S+)?')do\n\
    \      if word ~= '' then\n         table.insert(words, word)\n      end\n   end\n\
    \   -- If there is only one word, insert one blank and add it to the list\n  \
    \ if #words == 1 then\n      table.insert(words, '')\n   end\n   return words\n\
    end", "    local words = \"\"\n    local alpha = {}\n    for letter, lettercode\
    \ do\n        alpha[lettercode] = letter\n    end\n    for w in txt:gmatch(\"\
    ([\" .. string.gsub(\",\", \"\", string.letters) .. \"]+)\") do\n        if w\
    \ ~= \"\" then\n            words = words & w .. \" \"\n        end\n    end\n\
    \    local res = {}\n    for i = 1, #words do\n        local word = words[i]\n\
    \        if word ~= \"\" then\n            res[#res + 1] = alpha[word:lower()]\n\
    \        end\n    end\n    return #res == 0 and words or res\nend", "\tlocal words\
    \ = {}\n\tlocal num_words = 0\n\tfor w in txt:gmatch(\"[%a]+\") do\n\t\ttable.insert(words,\
    \ w)\n\t\tnum_words = num_words + 1\n\tend\n\treturn num_words, words\nend", "\t\
    local tab = {}\n\tlocal counter = 0\n\tfor w in txt:gmatch(\"[%w-]+\") do\n\t\t\
    tab[#tab + 1] = w\n\tend\n\treturn tab\nend", "    local n = #txt\n    local words\
    \ = {}\n    while n do\n        words[#words + 1] = txt:sub(1, n)\n        txt\
    \ = txt:sub(n)\n        n = n - 1\n    end\n    return words\nend", "    if txt:match('[^\
    \ ]+$') then\n        txt = txt:sub(1, (txt:len() - 1))\n    end\n    return txt:gsub('\
    \ ', ',')\nend", "   local ret = {}\n   local num_commas = 0\n   local num_spaces\
    \ = 0\n   local num_words = 0\n   for _, _ in ipairs(txt:gmatch'([^%s]+)') do\n\
    \      local word_len = #_\n      num_words = num_words + 1\n      if word_len\
    \ > 0 then\n         if num_words > 1 then\n            if num_commas == 0 then\n\
    \               ret[#ret + 1] = num_words - 1\n               num_spaces = word_len\n\
    \               num_commas = 1\n            else\n               num_spaces =\
    \ num_spaces - word_len\n               num_commas = num_commas + 1\n        \
    \    end\n         else\n            num_spaces = word_len\n            num_commas\
    \ = 1\n         end\n      end\n   end\n   if num_commas > 0 then\n      ret[#ret\
    \ + 1] = num_words - 1\n   end\n   return ret\nend", "    local words = txt:gsub('\
    \ ', ' ')\n    local counts = {}\n    for _,word in ipairs(words) do\n       \
    \ local c = #word\n        local lowercase_count = 0\n        for _,c in ipairs(word)\
    \ do\n            if c >= 'a' and c <= 'z' then\n                lowercase_count\
    \ = lowercase_count + 1\n            end\n        end\n        table.insert(counts,\
    \ lowercase_count)\n    end\n    return table.concat(counts, ',')\nend", "  --\
    \ Split at any whitespace or comma\n  -- Split on commas if there are spaces\n\
    \  if txt:find('%w') ~= nil then\n    local words = txt:gsub('%w', ',')\n    --\
    \ Split at every whitespace and split on comma\n    -- If there are any spaces\
    \ after comma, remove them\n    words = words:gsub(',+', ',')\n    -- Split at\
    \ every whitespace\n    words = words:gsub('%s+', '%')\n    -- Split at every\
    \ single character\n    words = words:gsub('%S+', '[%a]')\n    -- Split at any\
    \ letter\n    words = words:gsub('%S+', '%a')\n    -- Remove any leading and trailing\
    \ whitespace\n    words = words:trim()\n    -- Remove any extra whitespace\n \
    \   words = words:trim()\n    -- Split at any whitespace\n    words = words:gsub('%s+',\
    \ '%')\n    -- Split at any letter\n    words = words:gsub('%s+', '%a')\n    --\
    \ Remove any leading and trailing whitespace\n    words = words:trim()\n    --\
    \ Remove any extra whitespace\n    words = words:trim()\n    -- Split at any whitespace\n\
    \    words = words:gsub('%w+', '%')\n    -- Split at any letter\n    words = words:gsub('%w+',\
    \ '%a')\n    -- Remove any leading and trailing whitespace\n    words = words:trim()\n\
    \    -- Remove any extra whitespace\n    words = words:trim()\n    -- Remove any\
    \ extra whitespace\n    words = words:trim()\n    -- Split at any whitespace\n\
    \    words = words:gsub('%w+', '%')\n    -- Split at any letter\n    words = words:gsub('%w+',\
    \ '%a')\n    -- Remove any leading and trailing whitespace\n    words = words:trim()\n\
    \    -- Remove any extra whitespace\n    words = words:trim()\n    -- Remove any\
    \ extra whitespace\n    words = words:trim()\n    -- Split at any whitespace\n\
    \    words = words:gsub('%w+', '%')\n    -- Split at any letter\n    words = words:gsub('%w+',\
    \ '%a')\n    -- Remove any leading and trailing whitespace\n    words = words:trim()\n\
    \    -- Remove any extra whitespace\n    words = words:trim()\n    -- Remove any\
    \ extra whitespace\n    words = words:trim()\n    -- Split at any whitespace\n\
    \    words = words:gsub('%w+', '%')\n    -- Split at any letter\n    words = words:gsub('%w+',\
    \ '%a')\n    -- Remove any leading and trailing whitespace\n    words = words:trim()\n\
    \    -- Remove any extra whitespace\n    words = words:trim()\n    -- Remove any\
    \ extra whitespace\n    words = words:trim()\n    -- Split at ", "  local words\
    \ = {}\n  local alphabet = string.gsub(txt, '[^'..string.char(string.upper, string.lower)..']',\
    \ '')\n  local words = string.gsub(txt, '[^'..alphabet..']', '', 'g')\n  return\
    \ table.concat(words, ' '):gsub(' ,', ' ').downcase()\nend", "   local ws = {}\n\
    \   for w in txt:gmatch'([^ ,]+)'do table.insert(ws,w) end\n   return table.sort(ws)\n\
    end", "  -- first count the number of words with spaces in the text\n  local num_words\
    \ = string.gsub(txt,' ','+').count('[^a-zA-Z]')\n  -- then split on commas\n \
    \ local words = string.gsub(txt,' ','+').split(',')\n  return table.copy(words),\
    \ num_words\nend", "  local words = { }\n  local i = 1\n  for c in txt:gmatch('%w+')\
    \ do table.insert(words, c) end\n  table.sort(words)\n  return table.concat(words)\n\
    end", "    local whitespace = string.char(9)\n    local comma = string.char(44)\n\
    \    local whitespace_count = string.len(whitespace)\n    local comma_count =\
    \ string.len(comma)\n    local split_chars = {}\n    local count = string.len(txt)\n\
    \    local i = 0\n    while i ~= count do\n        split_chars[#split_chars+1]\
    \ = string.sub(txt, i, i)\n        i = i + whitespace_count\n    end\n    if string.len(txt)\
    \ > comma_count then\n        for i = string.len(txt) - comma_count + 1, string.len(txt)\
    \ do\n            split_chars[#split_chars+1] = comma\n        end\n    end\n\
    \    return split_chars\nend", "    local words = {}\n    for w in txt:gmatch(\"\
    [%W%,%w]+\") do\n        table.insert(words, w)\n    end\n    return table.unpack(words)\n\
    end", "\tlocal words = txt:gsub('([^ ])+', function(word) return word:lower()\
    \ end)\n\treturn words:gsub(',+', function(word) return word:lower() end)\nend",
  "  if txt ~= nil then\n    txt = string.gsub(txt, ' ', '')\n    local num_words\
    \ = string.len(txt)\n    local words = { }\n    local count = 1\n    local letter_index\
    \ = 0\n    local word_index = 0\n    local num_letters = 0\n    local letter\n\
    \    local num_letters\n    local letter2\n    local num_letters\n    local letter3\n\
    \    local num_letters\n    local letter4\n    local num_letters\n    local letter5\n\
    \    local num_letters\n    local letter6\n    local num_letters\n    local letter7\n\
    \    local num_letters\n    local letter8\n    local num_letters\n    local letter9\n\
    \    local num_letters\n    local letter10\n    local num_letters\n    local letter11\n\
    \    local num_letters\n    local letter12\n    local num_letters\n    local letter13\n\
    \    local num_letters\n    local letter14\n    local num_letters\n    local letter15\n\
    \    local num_letters\n    local letter16\n    local num_letters\n    local letter17\n\
    \    local num_letters\n    local letter18\n    local num_letters\n    local letter19\n\
    \    local num_letters\n    local letter20\n    local num_letters\n    local letter21\n\
    \    local num_letters\n    local letter22\n    local num_letters\n    local letter23\n\
    \    local num_letters\n    local letter24\n    local num_letters", "    local\
    \ words = txt:gsub(\"[%l%p%w]+\", \" \"):gsub(\"^[%l%p%w]+\", \"\"):gsub(\"[%l%p%w]+$\"\
    , \"\")\n    return words == \"\" and 1 or words\nend\nreturn split_words\nend",
  "  local w = {}\n  for i=1,#txt do w[#w+i] = txt[i] end\n  return w\nend", "\t--\
    \ Remove whitespace and comma\n\ttxt = txt:gsub(' ', '')\n\ttxt = txt:gsub(',',\
    \ ' ')\n\t\n\t-- Remove spaces before and after the words\n\ttxt = txt:gsub('([%s])([%s])([%s])'\
    \ % (string.letters, string.letters, string.letters), '\\1 \\3')\n\t\n\t-- Lower\
    \ case and get words\n\tlocal words = txt:gmatch('([%s]+)'):gsub('([^%s]+)', '\\\
    1 \\2'):gsub(string.letters, '\\0').split(' ')\n\t\n\treturn words\nend", "  \
    \  local words = { }\n    for w in txt:gmatch(\"[%z+%.-]*\") do\n        words[#words\
    \ + 1] = w\n    end\n    return #words + 1 -- add one for the comma\nend", " \
    \   local letters = {}\n    local i = 0\n    while i < #txt do\n        local\
    \ c = string.sub(txt, i, i)\n        if c == \" \" then\n            i = i + 1\n\
    \        elseif c == \",\" then\n            i = i + 1\n        elseif string.find(string.lower(c),\
    \ string.lower(string.sub(\"abcdefghijklmnopqrstuvwxyz\", 0, -1))) then\n    \
    \        i = i + 1\n        elseif string.find(string.lower(c), string.lower(string.sub(\"\
    abcdefghijklmnopqrstuvwxyz\", 1, -1))) then\n            i = i + 2\n        elseif\
    \ string.find(string.lower(c), string.lower(string.sub(\"abcdefghijklmnopqrstuvwxyz\"\
    , 2, -1))) then\n            i = i + 3\n        elseif string.find(string.lower(c),\
    \ string.lower(string.sub(\"abcdefghijklmnopqrstuvwxyz\", 3, -1))) then\n    \
    \        i = i + 4\n        elseif string.find(string.lower(c), string.lower(string.sub(\"\
    abcdefghijklmnopqrstuvwxyz\", 4, -1))) then\n            i = i + 5\n        elseif\
    \ string.find(string.lower(c), string.lower(string.sub(\"abcdefghijklmnopqrstuvwxyz\"\
    , 5, -1))) then\n            i = i + 6\n        elseif string.find(string.lower(c),\
    \ string.lower(string.sub(\"abcdefghijklmnopqrstuvwxyz\", 6, -1))) then\n    \
    \        i = i + 7\n        elseif string.find(string.lower(c), string.lower(string.sub(\"\
    abcdefghijklmnopqrstuvwxyz\", 7, -1))) then\n            i = i + 8\n        elseif\
    \ string.find(string.lower(c), string.lower(string.sub(\"abcdefghijklmnopqrstuvwxyz\"\
    , 8, -1))) then\n            i = i + 9\n        elseif string.find(string.lower(c),\
    \ string.lower(string.sub(\"abcdefghijklmnopqrstuvwxyz\", 9, -1))) then\n    \
    \        i = i + 10\n        elseif string.find(string.lower(c), string.lower(string.sub(\"\
    abcdefghijklmnopqrstuvwxyz\", 10, -1))) then\n            i = i + 11\n       \
    \ elseif string.find(string.lower(c), string.lower(string.sub(\"abcdefghijklmnopqrstuvwxyz\"\
    , 11, -1))) then\n            i = i + 12\n        elseif string.find(string.lower(c),\
    \ string.lower(string.sub(\"abcdefghijklmnopqrstuvwxyz\", 12, -1))) then\n   \
    \         i = i + 13\n        elseif string.find(string.lower(c), string.lower(string.sub",
  "\tlocal words = { }\n\tlocal ws = string.gsub(txt, \"[^ ]+\", \" \")\n\tfor w in\
    \ string.gmatch(ws, \"[^ ]+\") do\n\t\ttable.insert(words, w)\n\tend\n\treturn\
    \ words\nend", "    if txt == nil then return end\n    local words = txt:gsub('([^%s]+)'\
    \ % {',', ' '}):gsub('(.-)/(.-)(.-)', '\\1\\2 \\3')\n    local w = {}\n    for\
    \ i = 1, #words do\n        local word = words[i]\n        words[i] = word:lower()\n\
    \        w[word] = w[word] + 1 or 1\n    end\n    return w\nend", "\tlocal w =\
    \ io.open(io.stdin,'r','UTF-8')\n\tlocal w1 = io.open(io.stdout,'w','UTF-8')\n\
    \tlocal txt = txt:gsub(\"%S+\",function(x) return x:lower() end)\n\tlocal len\
    \ = #txt\n\tlocal s = \"\"\n\tlocal n = 0\n\twhile true do\n\t\t-- get next word\n\
    \t\tn = string.find(txt,\" \")\n\t\tif n == nil then break end\n\t\ts = s .. txt:sub(0,n)\n\
    \t\ttxt = txt:sub(n)\n\tend\n\tif #s == 0 then return split_words(\",\") end --\
    \ no whitespaces\n\tif #s == 1 then return { s } end\n\tlocal table = {}\n\tfor\
    \ i = 1,#s do\n\t\tlocal n = #s:sub(i,i)\n\t\tif n % 2 == 0 then\n\t\t\ttable[i]\
    \ = s:sub(i,i)\n\t\telse\n\t\t\ttable[i] = string.sub(s,i,i+1)\n\t\tend\n\tend\n\
    \treturn table\nend", "\tlocal words = nil\n\tlocal counter = 0\n\tlocal last_letter\
    \ = ''\n\tlocal letter = 0\n\tif txt ~= nil then\n\t\t-- Splitting words\n\t\t\
    words = {}\n\t\twhile txt:len() > 0 do\n\t\t\tif txt:len() > 0 then\n\t\t\t\t\
    local letter = txt:sub(1, 1)\n\t\t\t\tif letter:len() > 0 then\n\t\t\t\t\t-- Counting\
    \ letters in odd order\n\t\t\t\t\tlocal odd = letter:sub(1, 1)\n\t\t\t\t\t-- If\
    \ odd order letter, store letter into table\n\t\t\t\t\tif odd:len() == 1 and odd:byte()\
    \ == 1 then\n\t\t\t\t\t\tcounter = counter + 1\n\t\t\t\t\t\tif last_letter:len()\
    \ > 0 then\n\t\t\t\t\t\t\t-- Store word into words table\n\t\t\t\t\t\t\ttable.insert(words,\
    \ last_letter)\n\t\t\t\t\t\tend\n\t\t\t\t\t\tlast_letter = letter\n\t\t\t\t\t\
    end\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn counter, words\nend", " \
    \   local words = {}\n    local num_lower = 0\n    for i, c in ipairs(txt) do\n\
    \        -- Check if we get an upper case letter\n        if string.byte(c) <\
    \ string.byte('A') and string.byte(c) > string.byte('Z') then\n            --\
    \ Add the character to the first word and increment the counter\n            words[#words\
    \ + 1] = string.sub(c, 2, 1)\n            num_lower = num_lower + 1\n        else\n\
    \            -- Check if we get an lower case letter\n            if string.byte(c)\
    \ < string.byte('a') then\n                -- Add the character to the first word\
    \ and increment the counter\n                words[#words + 1] = string.sub(c,\
    \ 2, 1)\n                num_lower = num_lower + 1\n            else\n       \
    \         -- Check if we get a number\n                if string.byte(c) < string.byte('1')\
    \ and string.byte(c) > string.byte('9') then\n                    -- Add the character\
    \ to the first word and increment the counter\n                    words[#words\
    \ + 1] = string.sub(c, 2, 1)\n                    num_lower = num_lower + 1\n\
    \                else\n                    -- Add the character to the last word\
    \ and increment the counter\n                    words[#words + 1] = string.sub(c,\
    \ 2, 1)\n                end\n            end\n        end\n    end\n    -- Make\
    \ sure we don't add an empty string\n    if num_lower == 0 then\n        return\
    \ words\n    end\n    -- Add the last word\n    words[#words + 1] = txt\n    return\
    \ words\nend", "\tlocal words = { }", "    if txt ~= nil and txt ~= '' then\n\
    \        -- split on whitespace\n        local words = text:gmatch(\"[\\s]+\"\
    )\n        -- split on commas\n        words = words and text:gmatch(\"[,]+\"\
    )\n        -- split on letters with odd order in the alphabet\n        words =\
    \ words and text:gmatch(\"[\" .. string.char(string.byte(\"a\"), string.byte(\"\
    z\")) .. \"]+\")\n        -- strip whitespace\n        words = words and text:gsub(\"\
    [\\s]+\", \" \")\n        return words\n    end\n    return {}\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
