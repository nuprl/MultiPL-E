name: HumanEval_57_monotonic
language: lua
prompt: "-- Return true is table elements are monotonically increasing or decreasing.\n\
  -- >>> monotonic({1, 2, 4, 20})\n-- true\n-- >>> monotonic({1, 20, 4, 10})\n-- false\n\
  -- >>> monotonic({4, 1, 0, -10})\n-- true\nlocal function monotonic(l)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = monotonic\n\
  \    lu.assertEquals(candidate({1, 2, 4, 10}), true)\n    lu.assertEquals(candidate({1,\
  \ 2, 4, 20}), true)\n    lu.assertEquals(candidate({1, 20, 4, 10}), false)\n   \
  \ lu.assertEquals(candidate({4, 1, 0, -10}), true)\n    lu.assertEquals(candidate({4,\
  \ 1, 1, 0}), true)\n    lu.assertEquals(candidate({1, 2, 3, 2, 5, 60}), false)\n\
  \    lu.assertEquals(candidate({1, 2, 3, 4, 5, 60}), true)\n    lu.assertEquals(candidate({9,\
  \ 9, 9, 9}), true)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local prev  = l[1]\n  local curr = l[1]\n  for i = 2, #l do\n   \
    \ if l[i-1] > prev then\n      return false\n    end\n    prev = curr\n    curr\
    \ = l[i]\n  end\n  return true\nend", "  local sorted = {}\n  table.sort(l)\n\
    \  for i = 1, table.getn(l) do\n    if sorted[i] then\n      if sorted[i] ~= l[i]\
    \ then\n        return false\n      end\n    elseif sorted[i] = l[i] then\n  \
    \    return true\n    else\n      sorted[i] = l[i]\n    end\n  end\n  return false\n\
    end", "  local low = nil\n  local high = nil\n  local length = #l", "    -- Determine\
    \ if the list is already monotonic.\n    if #l <= 1 then\n        return true\n\
    \    end\n    local first = l[1]\n    for i = 2, #l do\n        if l[i] > first\
    \ then\n            return false\n        end\n        first = l[i]\n    end\n\
    \    return true\nend", "   local i, j, m = {}, {}, 0\n   for i, v in ipairs(l)\
    \ do\n      if v < m[v] then\n         j = m[v]\n         m[v] = i\n      else\n\
    \         m[v] = i + 1\n      end\n   end\n   if #m == 1 then return true end\n\
    \   return false\nend", "  -- The list must not be empty, otherwise it would be\
    \ possible to\n  -- take `l[1]` which would be undefined\n  if not l then return\
    \ false end\n  local last_val = l[1] or 0\n  for i = 2, #l do\n    local val =\
    \ l[i]\n    if val ~= last_val then\n      return true\n    end\n    last_val\
    \ = val\n  end\n  return false\nend", "  if #l == 1 then return true end\n  local\
    \ prev = l[1]\n  for i = 2, #l do\n    if l[i] < prev then return false end\n\
    \    prev = l[i]\n  end\n  return true\nend", "  local monotonic_l\n  local prev_l\n\
    \  if #l == 0 then return false end\n  local min_v = l[1]\n  local max_v = l[1]\n\
    \  for i = 2, #l do\n    local v = l[i]\n    if v < min_v then\n      min_v =\
    \ v\n    end\n    if v > max_v then\n      max_v = v\n    end\n  end\n  if min_v\
    \ == max_v then\n    monotonic_l = \"unsorted\"\n  elseif min_v == prev_l then\n\
    \    monotonic_l = \"decreasing\"\n  elseif max_v == prev_l then\n    monotonic_l\
    \ = \"increasing\"\n  else\n    monotonic_l = \"increasing/decreasing\"\n  end\n\
    \  return prev_l, monotonic_l, max_v\nend", "    local max = #l\n    for i=1,\
    \ max do\n        if l[i] ~= l[i - 1] + 1 then\n            return false\n   \
    \     end\n    end\n    return true\nend", "  local ok, last_value, last_index\
    \ = true, {}, 0\n  for idx, value in ipairs(l) do\n    if idx > last_index then\n\
    \      ok = false\n      break\n    end", "    local function sort(a, b)\n   \
    \     if a < b then\n            return 1\n        elseif a > b then\n       \
    \     return -1\n        else\n            return 0\n        end\n    end\n  \
    \  table.sort(l, sort)\n    return #l == 0\nend", "  local first = table.remove(l,\
    \ 1)\n  local last = first\n  for i = 2, #l do\n    local value = table.remove(l,\
    \ nth(l, i))\n    if not first <= value then\n      return false\n    end\n  \
    \  first = value\n    last = value\n  end\n  return first <= last\nend", "\tlocal\
    \ keys = {}\n\tlocal max = 0\n\tfor k in pairs(l) do\n\t\tkeys[k] = true\n\t\t\
    max = math.max(max, k)\n\tend\n\tfor k in pairs(l) do\n\t\tif not keys[k] then\n\
    \t\t\treturn false\n\t\tend\n\tend\n\treturn max <= 0\nend", "  local lv = table.sort(l)\n\
    \  for i = 1, #l do\n    if lv[i] ~= lv[i-1] then return false end\n  end\n  return\
    \ true\nend", "    local max\n    for i, v in ipairs(l) do\n        if max then\n\
    \            if v > max then\n                return false\n            elseif\
    \ v == max and i > max then\n                return false\n            end\n \
    \       else\n            max = v\n        end\n    end\n    return true\nend",
  "  if #l == 1 then return false end\n  return l[1] < l[2] or l[2] < l[1]\nend",
  "  if #l == 1 then return true end\n  if #l == 2 then return l[1] < l[2] end\n \
    \ local v1 = l[1]\n  local v2 = l[2]\n  return v1 < v2 or\n    (v2 < v1 and monotonic(unpack(l,\
    \ 1, #l - 2)))\nend", "  local result = true\n  local prev = -1000000000\n  local\
    \ i = 1\n  for v in l:gmatch(\"%d*\") do\n    if v ~= prev then\n      result\
    \ = false\n      break\n    end\n    prev = v\n    i = i + 1\n  end\n  return\
    \ result\nend", "  local monotonic, decreasing = true, true\n  for i = 2, #l do\n\
    \    if l[i-1] > l[i] or l[i-1] == l[i] then\n      monotonic = false\n      decreasing\
    \ = false\n      break\n    end\n  end\n  if decreasing then\n    return true\n\
    \  end\n  return monotonic\nend", "  for i = #l - 1, 1, -1 do\n    local el =\
    \ l[i]\n    if el > l[i + 1] then\n      return false\n    end\n  end\n  return\
    \ true\nend", "  local i = 1\n  for i = 2, #l do\n    if l[i-1] < l[i] then\n\
    \      return false\n    end\n  end\n  return true\nend", "  local last_is_less\
    \ = {}\n  for i, v in ipairs(l) do\n    last_is_less[i] = v < last_is_less[i]\
    \ or last_is_less[i] == nil\n  end\n  return #last_is_less == 0\nend", "  local\
    \ result = true\n  for i = 2, #l do\n    local e = l[i]\n    if e < l[i - 1] then\n\
    \      result = false\n    end\n  end\n  return result\nend", "  return #l >=\
    \ 2 and l[1] < l[2] and l[2] < l[3]\nend", "  local last = l[1]\n  for i=2,#l\
    \ do\n    if l[i] > last then return false end\n    last = l[i]\n  end\n  return\
    \ true\nend", "  local function sub(v)\n    local i, j = unpack(v, 2, 2)\n   \
    \ return i - j\n  end", "  local i, j, k, x, y, z, c, count\n  count = 1 -- current\
    \ count\n  for i, x in ipairs(l) do\n    count = count + 1\n    i = i + 1\n  \
    \  if count == 1 then x = x+1 -- remember original order\n    else x = x + (x\
    \ > l[i]) and (x - l[i]) or l[i] end\n    if i == 1 then c = x end\n    if count\
    \ > 2 then\n      if l[j] ~= c then\n        x, y = c, l[j]\n      end\n     \
    \ if l[k] ~= y then\n        x, y = y, l[k]\n      end\n      if x ~= c then --\
    \ if x is different from c, then x is non-monotonic element\n        if x > y\
    \ then return false end\n      end\n      count = count - 1\n    end\n    j =\
    \ i + 1\n    k = j + 1\n  end\n  if count == 0 then return true end\n  return\
    \ false\nend", "\t-- Check table size is 1.\n\tif #l == 1 then\n\t\treturn l[0]\
    \ < l[1]\n\tend", "  local a = {}\n  for i = 1, #l do\n    if a.__index == nil\
    \ then\n      a.__index = i\n      local v = l[i]\n      if v < l[i-1] then\n\
    \        return false\n      elseif v > l[i-1] then\n        return true\n   \
    \   else\n        a.__index = i\n      end\n    else\n      if l[i] > l[a] then\n\
    \        return false\n      elseif l[i] < l[a] then\n        return true\n  \
    \    else\n        a[i] = i\n      end\n    end\n  end\n  return true\nend", " \
    \ if #l == 1 then\n    return true\n  end\n  local prev = l[1]\n  for _, v in\
    \ ipairs(l) do\n    if prev > v then\n      return false\n    end\n    prev =\
    \ v\n  end\n  return true\nend", "    local prev = -math.huge\n    local current\
    \ = 1\n    for _, v in ipairs(l) do\n        if prev > current then\n        \
    \    return false\n        end\n        prev = current\n        current = current\
    \ + v\n    end\n    return current <= prev\nend", "   local minimum = nil\n  \
    \ local maximum = nil", "  local sorted = table.sort(l)\n  for i = 1, #sorted\
    \ do\n    if sorted[i] ~= sorted[i - 1] + 1 then\n      return false\n    end\n\
    \  end\n  return true\nend", "  local lastVal = nil\n  local lastPos = nil\n \
    \ local incr = 0\n  local decr = 0\n  for i = 1, #l do\n    if l[i] < lastVal\
    \ then\n      incr = 1\n    elseif l[i] > lastVal then\n      decr = -1\n    else\n\
    \      incr = 0\n      decr = 0\n    end\n    lastVal = l[i]\n    lastPos = i\n\
    \  end\n  return decr == 0 and incr == 1 or (decr == -1 and incr == 0)\nend",
  "  if #l == 0 then return true end\n  local first, last = l[1], l[1]\n  for i =\
    \ 2, #l do\n    local x = l[i]\n    if x >= first then return false end\n    if\
    \ x <= last then return false end\n    first = last\n    last = x\n  end\n  return\
    \ true\nend", "  if #l == 0 then return false end\n  if #l == 1 then return true\
    \ end\n  local first = l[1]\n  local last = l[#l]\n  for i = 2, #l do\n    if\
    \ l[i] > first then return false end\n    if l[i] < last then return false end\n\
    \  end\n  return true\nend", "  local max = -l[1]\n  for _, v in pairs(l) do\n\
    \    if v < max then\n      return false\n    end\n    max = v\n  end\n  return\
    \ true\nend", "  local i = 1\n  local last = l[1]\n  for i = 2, #l do\n    local\
    \ current = l[i]\n    if current > last then\n      return true\n    end\n   \
    \ last = current\n  end\n  return false\nend", "  if #l == 0 then return true\
    \ end\n  if #l == 1 then return false\n  else if l[1] < l[2] then return true\n\
    \    else return false end\n  end\nend", "  if #l == 1 then return l[1] == 1 end\n\
    \  local i = #l\n  while i > 1 do\n    local j, k = l[1], #l\n    for i = i -\
    \ 1; i > 1; i = i - 1 do\n      if l[i] < l[j] then return false end\n      if\
    \ l[i] > l[k] then return false end\n    end\n    l = l[k]\n  end\n  return true\n\
    end", "    local result = true\n    for i, v in ipairs(l) do\n        if not i\
    \ then\n            if v ~= v then\n                result = false\n         \
    \   else\n                result = true\n            end\n        elseif v > l[i]\
    \ then\n            result = false\n        end\n    end\n    return result\n\
    end", "  local i = 1\n  for i = 1, #l do\n    if l[i] ~= l[i-1] then\n      return\
    \ false\n    end\n  end\n  return true\nend", "  for i=1,#l do\n    local t =\
    \ l[i]\n    local prev = l[i-1]\n    if prev < t then return false end\n  end\n\
    \  return true\nend", "  local ret\n  for _, x in ipairs(l) do\n    if x > ret\
    \ then\n      ret = x\n    end\n  end\n  return ret\nend", "    local sorted =\
    \ table.sort(l)\n    local prev = -math.inf - 1\n    local pos = 0\n    for idx\
    \ = 1, #l do\n        if prev > l[idx] then\n            pos = idx\n        end\n\
    \        prev = l[idx]\n    end\n    return pos == #sorted\nend", "  return l.NumFields\
    \ == 0 and l.NumElements == #l and #l <= #l and unpack(l.Fields, 1, #l.Fields)\
    \ == #l and unpack(l, 1, #l) <= unpack(l, 2, #l) and #l > 0 and #l.Fields == #l\n\
    end", "  local i = #l + 1\n  while i > 1 do\n    local j = i\n    while j < l\
    \ do\n      local x = l[j]\n      local y = l[j + 1]\n      if x > y then return\
    \ false end\n      if x < y then return true end\n      j = j + 1\n    end\n \
    \   i = i - 1\n  end\n  return l[1] <= l[#l]\nend", "  local function is_increasing(e)\n\
    \    local last = e[#e]\n    for i = #e - 1, 1, -1 do\n      if last < e[i] then\n\
    \        return true\n      end\n      last = e[i]\n    end\n    return false\n\
    \  end", "  if l == nil then return nil end\n  if #l == 1 then return l[1] ==\
    \ l[0] end\n  local last = l[1]\n  for i = 2, #l do\n    if l[i] ~= last then\
    \ return false end\n    last = l[i]\n  end\n  return true\nend", "  local sorted\
    \ = table.sort(l)\n  for i, v in ipairs(sorted) do\n    if v ~= sorted[i+1] then\n\
    \      return false\n    end\n  end\n  return true\nend", "    -- Check if all\
    \ elements are nonnegative\n    if l[1] == 0 then\n        return false\n    end\n\
    \    -- Store the max (minimum) value in an element and find its index\n    local\
    \ max = l[1]\n    local idx = 1\n    while idx < #l do\n        if l[idx] > max\
    \ then\n            max = l[idx]\n        end\n        idx = idx + 1\n    end\n\
    \    -- Check if all elements are nonnegative\n    if l[1] == 0 then\n       \
    \ return false\n    end\n    -- Store the max (minimum) value in an element and\
    \ find its index\n    local max = l[1]\n    local idx = 1\n    while idx < #l\
    \ do\n        if l[idx] > max then\n            max = l[idx]\n        end\n  \
    \      idx = idx + 1\n    end\n    -- Check if all elements are nonnegative\n\
    \    if l[1] == 0 then\n        return false\n    end\n    -- The table is monotonic\n\
    \    return true\nend", "  local prev = -1\n  for i, v in ipairs(l) do\n    if\
    \ prev > 0 then\n      if v < prev then\n        return false\n      elseif v\
    \ > prev then\n        return true\n      end\n    end\n    prev = v\n  end\n\
    \  return true\nend", "  local prev = nil\n  for _, v in ipairs(l) do\n    if\
    \ prev == nil then\n      prev = v\n    elseif prev < v then\n      return false\n\
    \    else\n      prev = v\n    end\n  end\n  return true\nend", "  if #l <= 1\
    \ then return true end\n  local max1 = l[1]\n  local max2 = l[1]\n  for i = 2,\
    \ #l do\n    local cur1 = l[i]\n    local cur2 = l[i-1]\n    if cur1 > cur2 then\n\
    \      return false\n    end\n    max2 = max1\n    max1 = cur1\n  end\n  return\
    \ max2 < max1\nend", "  if l==nil then return false end\n  local i=1, j=1\n  while\
    \ i <= #l do\n    local k = i\n    j = i+1\n    while j < #l and l[j] < l[k] do\n\
    \      j = j+1\n    end\n    if i == j then -- Degenerate\n      i = j\n    elseif\
    \ l[j] == l[i] then -- Equal\n      i = j\n    else\n      local d = l[j]-l[k]\n\
    \      if d > 0 then return false\n      elseif d < 0 then return true\n     \
    \ else return false\n      end\n    end\n  end\nend", "    if l[1] == nil then\n\
    \        return true\n    end\n    local l = { l }\n    local max = l[1]\n   \
    \ for i = 2, #l do\n        if l[i] < max then\n            return false\n   \
    \     elseif l[i] > max then\n            max = l[i]\n        end\n    end\n \
    \   return true\nend", "  local sorted = setmetatable({}, {__mode=\"v\"})\n  for\
    \ _, v in ipairs(l) do sorted[v] = true end\n  return table.keys(sorted) == 1\
    \ and table.next(sorted)\nend", "  local sorted = {}\n  for i, v in ipairs(l)\
    \ do sorted[v] = i end\n  for i = 2, #sorted do\n    if sorted[i] < sorted[i-1]\
    \ then\n      return true\n    end\n  end\n  return false\nend", "  local last\
    \ = l[1]\n  for i = 2, #l do\n    if l[i] <= last then\n      return false\n \
    \   end\n    last = l[i]\n  end\n  return true\nend", "  return l:apply(function(a)\n\
    \    return a < a[1] or (a[1] == a and a[2] <= a[3])\n  end)\nend", "  if #l ==\
    \ 0 then\n    return true\n  else\n    local last = l[1]\n    local i = 2\n  \
    \  while i < #l do\n      local curr = l[i]\n      if curr > last then\n     \
    \   return false\n      elseif curr == last then\n        i = i + 1\n      else\n\
    \        last = curr\n        i = i + 1\n      end\n    end\n    return true\n\
    \  end\nend", "  if l == nil then\n    return nil\n  end", "  for i = #l - 1,\
    \ 1, -1 do\n    if l[i] < l[i - 1] or l[i] > l[i + 1] then\n      return false\n\
    \    end\n  end\n  return true\nend", "    local monotonic = false\n    if #l\
    \ == 1 then\n        monotonic = l.[1] < l.[2]\n    else\n        local i = 2\n\
    \        while i < #l do\n            if l[i] < l[i-1] then\n                local\
    \ swap = l[i]\n                l[i] = l[i-1]\n                l[i-1] = swap\n\
    \                i = 2\n                monotonic = true\n            else\n \
    \               i = i + 1\n            end\n        end\n    end\n    return monotonic\n\
    end", "  local i = 1\n  while i < #l do\n    if not l[i] then\n      return false\n\
    \    end\n    if l[i] ~= l[i-1] then\n      return false\n    end\n    i = i +\
    \ 1\n  end\n  return true\nend", "  if l[1] == l[2] then\n    return true\n  end",
  "  local last_val = l[1]\n  local last_idx = 1\n  local first_idx = 1\n  for i =\
    \ 2, #l do\n    if l[i] > last_val then\n      last_val = l[i]\n      first_idx\
    \ = i - 1\n      last_idx = i - 1\n    elseif l[i] < last_val then\n      last_idx\
    \ = i - 1\n    end\n  end\n  return first_idx < last_idx\nend", "  if #l == 1\
    \ then return true end\n  local first = l[1]\n  for i = 2, #l do\n    if l[i]\
    \ < first then\n      return false\n    end\n  end\n  return true\nend", "   \
    \ if #l == 0 then return false end\n    if #l == 1 then return true end\n    return\
    \ l[1] < l[2] and l[2] <= l[3]\nend", "    -- Returns true if the list elements\
    \ are monotonically increasing or decreasing.\n    --\n    -- Parameters\n   \
    \ -- ----------\n    -- l   : (numeric) A list of numeric elements.\n    --\n\
    \    -- Returns\n    -- -------\n    -- boolean\n    --\n    -- Examples\n   \
    \ -- --------\n    -- >>> monotonic([1, 2, 4, 20])\n    -- true\n    -- >>> monotonic([1,\
    \ 20, 4, 10])\n    -- false\n    -- >>> monotonic([4, 1, 0, -10])\n    -- true",
  "  local min = math.min(unpack(l))\n  local max = math.max(unpack(l))\n  return\
    \ min < max and min == max\nend", "  for i = #l - 1, 1, -1 do\n    if l[i] > l[i\
    \ + 1] then\n      return false\n    end\n  end\n  return true\nend", "  local\
    \ prev = l[1]\n  for _, el in ipairs(l) do\n    if prev < el then\n      return\
    \ false\n    end\n    prev = el\n  end\n  return true\nend", '  local llen = #l',
  "\tlocal prev = l[1]\n\tlocal ok, max = true\n\tlocal count = #l\n\tfor i = 2, count\
    \ do\n\t\tlocal v = l[i]\n\t\tif v < prev then -- Monotonically increasing.\n\t\
    \t\tok = false\n\t\telseif v > prev then -- Monotonically decreasing.\n\t\t\t\
    ok = true\n\t\telse\n\t\t\tbreak\n\t\tend\n\t\tprev = v\n\tend\n\treturn ok and\
    \ max\nend", "  if #l < 2 then return false end\n  if l[1] == l[2] then return\
    \ false end\n  local i = 0\n  local last = l[1]\n  local j = #l\n  while i < j\
    \ do\n    local v = l[i]\n    i = i + 1\n    if last < v then return false end\n\
    \    last = v\n  end\n  return true\nend", "  local prev=nil\n  for _, v in ipairs(l)\
    \ do\n    if prev == nil or prev > v then\n      prev = v\n    end\n  end\n  return\
    \ prev == nil\nend", "  local i, j, n = 0, 1, #l\n  while i < n do\n    j = i\n\
    \    while j < n and l[j] < l[j+1] do\n      j = j + 1\n    end\n    if j < n\
    \ then\n      l[i], l[j] = l[j], l[i]\n      i = i + 1\n    end\n    n = j\n \
    \ end\n  return i == n\nend", "   local max = math.max(l)\n   local min = math.min(l)\n\
    \   return min == max\nend", "  if #l == 1 then\n    return l[1] < l[2]\n  end\n\
    \  local prev = l[1]\n  for i = 2, #l do\n    if l[i] > prev then\n      return\
    \ false\n    end\n    prev = l[i]\n  end\n  return true\nend", "  if #l == 1 then\
    \ return false end\n  for i = #l - 1, 1, -1 do\n    if l[i] > l[i-1] then return\
    \ false end\n  end\n  return true\nend", "  local prev = {l[1]}\n  for i=2,#l\
    \ do\n    if prev[i] ~= l[i] then\n      return false\n    end\n    prev[i] =\
    \ nil\n  end\n  return true\nend", "  local i = 1\n  while i < #l do\n    local\
    \ c = l[i]\n    if c < l[i-1] then\n      return false\n    end\n    if c > l[i-1]\
    \ then\n      l[i-1] = c\n      i = 1\n    else\n      i = i + 1\n    end\n  end\n\
    \  return true\nend", "  for i, v in ipairs(l) do\n    if v < l[i] then\n    \
    \  return false\n    end\n  end\n  return true\nend", "  return l[1] < l[2] and\
    \ l[1] > l[3] and l[2] > l[3]\nend", "  local last_elem = unpack(l[#l])\n  for\
    \ i = #l - 1, 0, -1 do\n    local elem = unpack(l[i])\n    if elem < last_elem\
    \ then return false end\n    if elem > last_elem then last_elem = elem end\n \
    \ end\n  return true\nend", "  if #l == 1 then\n    local i = l[1]\n    if i ==\
    \ i then\n      return true\n    end\n    return false\n  end", "\tlocal max,min\
    \ = l[1],l[1]\n\tfor i = 2,#l do\n\t\tmax,min = max,min or (l[i],l[i])\n\tend\n\
    \treturn max >= min\nend", "  local prev = {}\n  for i=1,#l do\n    local val\
    \ = l[i]\n    if not prev[val] then\n      prev[val] = true\n      return true\n\
    \    end\n  end\n  return false\nend", "  local last_idx = nil\n  for idx, v in\
    \ ipairs(l) do\n    if last_idx == nil or v < l[last_idx] then\n      last_idx\
    \ = idx\n    end\n  end\n  return last_idx ~= nil\nend", "   if l[1] == l[2] then\n\
    \      return false\n   end\n   if l[3] == l[4] then\n      return true\n   end\n\
    \   if l[3] > l[4] then\n      return monotonic(l) -- Return true is table elements\
    \ are monotonically increasing or decreasing.\n   else\n      return monotonic(l+1)\
    \ -- Return true is table elements are monotonically increasing or decreasing.\n\
    \   end\nend", "  local s = l[1]\n  for i = 2, #l do\n    if l[i] < s or s ==\
    \ 0 then\n      return false\n    end\n    s = l[i]\n  end\n  return true\nend",
  "  for i = 2, #l do\n    if l[i-1] < l[i] then return false end\n    if l[i-1] >\
    \ l[i] then return true end\n  end\n  return true\nend", "  for i = 1, #l do\n\
    \    local v = l[i]\n    if v ~= nil and v:isNumber() then\n      if v <= l[i\
    \ - 1] and v ~= nil then\n        return false\n      elseif v ~= l[i - 1] and\
    \ v <= l[i - 1] then\n        return true\n      else\n        return false\n\
    \      end\n    elseif v ~= nil and v:isString() then\n      local c = v:byte()\n\
    \      if c > l[i - 1] and c ~= nil then\n        return false\n      elseif c\
    \ ~= l[i - 1] and c > l[i - 1] then\n        return true\n      else\n       \
    \ return false\n      end\n    elseif v ~= nil and v:isBoolean() then\n      if\
    \ v and l[i - 1] == nil then\n        return false\n      elseif not v and l[i\
    \ - 1] != nil then\n        return true\n      else\n        return false\n  \
    \    end\n    elseif v ~= nil and v:isStruct() then\n      if monotonic(v) then\n\
    \        return true\n      else\n        return false\n      end\n    else\n\
    \      return false\n    end\n  end\n  return true\nend", "  local prevVal\n \
    \ local currentVal\n  for i = 1, #l do\n    currentVal = l[i]\n    prevVal = prevVal\
    \ or currentVal\n    if currentVal ~= prevVal then\n      return false\n    end\n\
    \  end\n  return true\nend", "  for i = 1, #l do\n    if l[i-1] >= l[i] then\n\
    \      return false\n    end\n  end\n  return true\nend", "  for i = 1, #l do\n\
    \    if l[i-1] < l[i] then\n      return false\n    end\n  end\n  return true\n\
    end", "  if #l == 1 then\n    local e = l[1]\n    return e ~= nil and e <= l[2]\
    \ and e >= l[1]\n  end\n  for i = #l - 1, 1, -1 do\n    local e = l[i]\n    if\
    \ e ~= nil and e > l[i - 1] and e <= l[i + 1] then\n      return false\n    end\n\
    \  end\n  return true\nend", "  if l[1] < l[2] then\n    return true\n  end\n\
    \  if l[1] > l[3] then\n    return false\n  end\n  if l[1] == l[2] then\n    return\
    \ true\n  end\n  return monotonic(\n    {l[3], l[1], l[3], l[2]}\n  )\nend", " \
    \ local i, m = 1, #l\n  while i <= m do\n    local k = i\n    i = i - 1\n    local\
    \ j = m\n    j = j - 1\n    while j > 0 and l[k] < l[j] do\n      k = k - 1\n\
    \      j = j - 1\n    end\n    if k > 0 and l[k] == l[k] then\n      return false\n\
    \    end\n    if j > 0 and l[k] > l[j] then\n      return true\n    end\n  end\n\
    \  return true\nend", "  if l == nil then return false end\n  local last_idx =\
    \ #l - 1\n  return all(l[last_idx]:map(function(elt)\n    local next_elt = l[last_idx+1]\n\
    \    return elt > next_elt\n  end))\nend", "\tlocal m = {}\n\tfor i, v in ipairs(l)\
    \ do\n\t\ttable.insert(m, v)\n\t\tif i ~= #l then\n\t\t\tif v < m[1] then m[1]\
    \ = v end\n\t\t\tif v > m[-1] then m[-1] = v end\n\t\tend\n\tend\n\treturn #m\
    \ == 1 and m[1] == m[-1]\nend", "  if #l == 1 then return l[1] < l[2] end\n  local\
    \ first = l[1]\n  for i = 2, #l do assert(l[i] <= first) end\n  return false\n\
    end", "  return l and #l == 1 and l[1] < l[2] and l[2] > l[3]\nend", "  local\
    \ isIncreasing, isDecreasing, index = 0, 0, 1\n  for _, v in ipairs(l) do\n  \
    \  if v == 0 then return false end\n    isIncreasing = not isIncreasing and v\
    \ <= l[index]\n    isDecreasing = not isDecreasing and v >= l[index]\n    index\
    \ = index + 1\n  end\n  return isIncreasing or isDecreasing\nend", "  local i\
    \ = 1\n  for i = #l + 1, -1, -1 do\n    if l[i] ~= l[i - 1] + 1 then return false\
    \ end\n  end\n  return true\nend", "  local l2 = {}\n  for i = 1, #l do\n    l2[i]\
    \ = l[i]\n  end\n  l2[#l2] = l[#l]\n  return l2 <= l2\nend", "  if l == nil then\n\
    \    return false\n  end\n  local n = #l\n  if n == 0 then\n    return false\n\
    \  end\n  local i, j, s\n  local min_value, max_value = nil, 0\n  for i = 1, n\
    \ do\n    s = l[i]\n    j = i\n    while j < n do\n      s = s > l[j] or s ==\
    \ l[j] and 1 or -1\n      if s ~= 0 then\n        break -- j stays in range\n\
    \      elseif j < n then -- j was deleted\n        j = j + 1\n      else -- j\
    \ was inserted\n        j = j + 1\n      end\n    end\n    if min_value == nil\
    \ then\n      min_value = s\n      max_value = s\n    else\n      if s == min_value\
    \ then\n        min_value = s\n      elseif s == max_value then\n        max_value\
    \ = s\n      else\n        return false\n      end\n    end\n  end\n  return max_value\
    \ == min_value and true or false\nend", "  -- If table is empty then return true.\n\
    \  -- If only one element then return true.\n  if #l == 0 then\n    return true\n\
    \  elseif #l == 1 then\n    return l[1] <= l[0]\n  end", "  local min, max = table.unpack(l)\n\
    \  if #min == 1 and #max == 1 then\n    if min >= max then\n      return true\n\
    \    else\n      return false\n    end\n  else\n    return not ((#min > #max)\
    \ or (min < max))\n  end\nend", "  local s = l.sort()\n  for i, x in pairs(s)\
    \ do\n    if x > s[i] then\n      return false\n    end\n  end\n  return true\n\
    end", "  local ok = false\n  local last", "  local i = 1\n  local n = #l\n  while\
    \ i < n do\n    if l[i] < l[i - 1] or l[i] > l[i - 1] then\n      return false\n\
    \    end\n    i = i + 1\n  end\n  return true\nend", "  local result = false\n\
    \  if #l == 0 then\n    return result\n  end\n  for i = 2, #l do\n    if l[i]\
    \ ~= l[i - 1] + 1 then\n      result = true\n      break\n    end\n  end\n  return\
    \ result\nend", "  local result = true\n  for i=1,#l do\n    if l[i] ~= l[i-1]\
    \ then result = false end\n  end\n  return result\nend", "\tlocal s = l[1]\n\t\
    for i = 2, #l do\n\t\tif l[i] ~= s then return false end\n\tend\n\treturn true\n\
    end", "  local sorted = terralib.newlist()\n  for i = 1, #l do sorted:insert(l[i])\
    \ end\n  sorted = sorted.sort()\n  local prev = {}\n  for i = 1, #l do\n    if\
    \ sorted[i] ~= prev[i] then\n      return true\n    end\n    prev[i] = sorted[i]\n\
    \  end\n  return false\nend", "  return l ~= nil and unpack(sort(l, function(a,\
    \ b) return a <= b end))\nend", "    local sorted = table.sort(l)\n    for i=1,\
    \ #sorted do\n        if sorted[i] < sorted[i-1] then\n            return false\n\
    \        end\n    end\n    return true\nend", "  for i, v in ipairs(l) do\n  \
    \  local min_v = v\n    for _, v2 in ipairs(l) do\n      if v < v2 and v ~= min_v\
    \ then\n        return false\n      end\n    end\n  end\n  return true\nend",
  "  local prevVal = nil\n  local curVal = nil\n  local hasNext = true\n  for _, v\
    \ in ipairs(l) do\n    if not prevVal then\n      prevVal = v\n      curVal =\
    \ v\n      continue\n    end\n    curVal = v\n    if prevVal < curVal then\n \
    \     hasNext = false\n    end\n    prevVal = curVal\n  end\n  return hasNext\n\
    end", "  if #l < 2 then return false end\n  local last, prev = l[1], l[1]\n  for\
    \ i = 2, #l do\n    if prev > l[i] then return false end\n    last = prev\n  \
    \  prev = l[i]\n  end\n  return last <= prev\nend", "  -- This isn't an exhaustive\
    \ search, just a simple and quick check.\n  local last_element = l[1]\n  local\
    \ increasing = 1\n  for _, v in pairs(l) do\n    if v > last_element then\n  \
    \    increasing = not increasing\n    end\n    last_element = v\n  end\n  return\
    \ increasing\nend", '    local sorted = {}', "  local max  = 0\n  local min  =\
    \ math.max(1, l[1])\n  local ok   = true\n  for i = 2, #l do\n    if l[i] < min\
    \ then\n      min  = l[i]\n    end\n    if l[i] > max then\n      ok = false\n\
    \      break\n    end\n  end\n  return ok\nend", "  local last = l[1]\n  for i\
    \ = 2, #l do\n    if l[i] > last then return false end\n    last = l[i]\n  end\n\
    \  return true\nend", "  for i, v in ipairs(l) do\n    if v < l[i - 1] then\n\
    \      return false\n    end\n  end\n  return true\nend", "\tlocal prev = l[1]\n\
    \tfor i = 2, #l do\n\t\tif prev < l[i] then return false end\n\t\tprev = l[i]\n\
    \tend\n\treturn true\nend", '  local sorted = table.sort(l)', "  return unpack(l:sort(function\
    \ (a, b)\n    local function less(x, y)\n      if x < y then return true else\
    \ return false end\n    end\n    local function greater(x, y)\n      if x > y\
    \ then return true else return false end\n    end\n    return less(less(b, a),\
    \ b)\n  end))\nend", "  if #l == 1 then return true end\n  local min_ = l[1]\n\
    \  local max_ = l[1]\n  for i = 2, #l do\n    if l[i] < min_ then\n      min_\
    \ = l[i]\n    elseif l[i] > max_ then\n      max_ = l[i]\n    end\n  end\n  if\
    \ min_ == max_ then return false end\n  return true\nend", "  local i = 1\n  local\
    \ last_value\n  while i ~= #l do\n    local value = l[i]\n    last_value = value\n\
    \    i = i + 1\n  end\n  local has_changed = last_value < l[1]\n  if has_changed\
    \ then\n    for i = 1, #l do\n      if not l[i] or l[i] > last_value then has_changed\
    \ = false end\n    end\n  end\n  return has_changed\nend", "  if #l == 0 then\n\
    \    return true\n  end\n  local last = l[1]\n  for i = 2, #l do\n    if l[i]\
    \ ~= last then\n      return false\n    end\n    last = l[i]\n  end\n  return\
    \ true\nend", "  local maxElement = unpack(l)\n  local minElement\n  if #l > 1\
    \ then\n    minElement = unpack(l[1 .. -1])\n  end\n  return #maxElement > #minElement\
    \ or\n    (#maxElement == #l and maxElement < minElement)\nend", "    local i\
    \ = 1\n    for _, v in ipairs(l) do\n        if v < l[i-1] then\n            return\
    \ false\n        end\n        i = i + 1\n    end\n    return true\nend", "  local\
    \ max = 1\n  for i, v in ipairs(l) do\n    if v > max then\n      max = v\n  \
    \  end\n  end\n  local prev = l[1]\n  for i, v in ipairs(l) do\n    if v < prev\
    \ then\n      return false\n    end\n    prev = v\n  end\n  return true\nend",
  "  local i = 1\n  local count = #l\n  for i = 1, count do\n    if l[i] > l[i-1]\
    \ then\n      return false\n    end\n  end\n  return true\nend", "  if #l == 0\
    \ then return true end\n  local first_elem = l[1]\n  if l[1] > l[#l] then return\
    \ false end\n  for i = 2, #l do\n    if l[i] < first_elem then return false end\n\
    \  end\n  return true\nend", "    local prev = -1\n    for _, v in ipairs(l) do\n\
    \      if prev >= 0 then\n        if v ~= prev + 1 then\n          return false\n\
    \        end\n      else\n        return true\n      end\n      prev = v\n   \
    \ end\n    return false\nend", "\tlocal decreasing = {}\n\tlocal increasing =\
    \ {}\n\tfor i = #l, 1, -1 do\n\t\tlocal el = l[i]\n\t\tif increasing[el] then\
    \ return false end\n\t\tif decreasing[el] then return false end\n\t\tif el <=\
    \ l[i - 1] or el <= l[i - 2] then increasing[el] = true else decreasing[el] =\
    \ true end\n\tend\n\treturn true\nend", "   if #l == 1 then return true end\n\
    \   if #l == 2 then\n      if l[1] > l[2] then return true end\n      return false\n\
    \   end\n   local maxi = l[1]\n   for i = 2, #l do\n      if l[i] > maxi then\
    \ maxi = l[i] end\n   end\n   return maxi < l[#l]\nend", "    local min = l[1]\n\
    \    local max = l[#l]\n    local increment = max - min + 1\n    for i = 2, #l\
    \ do\n        if l[i] < min then\n            l[i] = min + increment\n       \
    \ elseif l[i] > max then\n            l[i] = min + increment * 2\n        else\n\
    \            return true\n        end\n    end\n    return false\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis is also very fast and accurate. It works for\
    \ sorted tables, too. +1\n<|/ c |>\n<| c |>\nThis is nice solution, but unfortunately\
    \ it can be very slow on huge tables\n<|/ c |>\n<| c |>\nYes, this is fast but\
    \ inaccurate if the table has \"holes\" in the middle of it.\n<|/ c |>\n<| a |>\n\
    The other answers here are all wrong. Using a linear search is unnecessary and\
    \ slow. Here's what it does:\nLet's say we have the table {0,1,2,3,4,5,6,7}. Starting\
    \ with the first number we encounter, each number is either less than the previous\
    \ number or the next number greater, but never less than the number we're checking.\n\
    This can be described as the following matrix:\n<code>\n{\n    0    1   2   3\
    \   4   5   6   7\n0   0   1   1   1   1   1   1   1\n1   0   1   1   1   1  \
    \ 1   1   1\n2   0   1   1   1   1   1   1   1\n3   0   1   1   1   1   1   1\
    \   1\n4   0   1   1   1   1   1   1   1\n5   0   1   1   1   1   1   1   1\n\
    6   0   1   1   1   1   1   1   1\n7   0   1   1   1   1   1   1   1\n</code>\n\
    As we add numbers to each column until we get to the rightmost column, we're left\
    \ with the following matrix:\n<code>\n{\n    0    1   2   3   4   5   6   7\n\
    0   0   1   1   1   1   1   1   1\n1   0   1   1   1   1   1   1   1\n2   0  \
    \ 1   1   1   1   1   1   1\n3   0   1   1   1   1   1   1   1\n4   0   1   1\
    \   1   1   1   1   1\n5   0   1   1   1   1   1   1   1\n6   0   1   1   1  \
    \ 1   1   1   1\n7   0   1   1   1   1   1   1   1\n8   0   1   1   1   1   1\
    \   1   1\n9   0   1   1   1   1   1   1   1\n10  0   1   1   1   1   1   1  \
    \ 1\n11  0   1   1   1   ", "  local sorted = false\n  local monotonic = true\n\
    \  for i = 2, #l do\n    if l[i] ~= l[i-1] then\n      sorted = true\n    else\n\
    \      monotonic = monotonic and\n        (sorted)\n    end\n  end\n  return monotonic\n\
    end", "  if #l <= 1 then return false end\n  local i = 1\n  while i <= #l do\n\
    \    local k = i\n    while k <= #l and l[k] < l[k+1] do\n      k = k + 1\n  \
    \  end\n    if k <= #l then\n      l[i], l[i-1] = l[i-1], l[i]\n      i = i +\
    \ 1\n    end\n  end\n  return true\nend", "   if #l == 0 then return false end\n\
    \   local minv = l[1]\n   for i = 2, #l do\n      if l[i] > minv then return false\
    \ end\n      minv = l[i]\n   end\n   return true\nend", "  local i = #l\n  if\
    \ i == 0 then return false end\n  while i do\n    i = i - 1\n    if l[i] > l[i+1]\
    \ then return false end\n  end\n  return true\nend", "  if #l <= 1 then return\
    \ false end\n  local last = l[1]\n  for i = 2, #l do\n    if l[i] <= last then\
    \ return false end\n    last = l[i]\n  end\n  return true\nend", "\tlocal is_decrease",
  "    for i=1,#l do\n        if l[i-1] > l[i] then return false end\n    end\n  \
    \  return true\nend", "  if l[1] == nil then\n    return true\n  end\n  local\
    \ m = l[1]\n  for i = 2, #l do\n    if l[i] <= m then\n      return false\n  \
    \  end\n    m = l[i]\n  end\n  return true\nend", "   local i = 1, #l\n   while\
    \ i <= #l do\n      if l[i-1] < l[i] then\n         return false\n      end\n\
    \      i = i + 1\n   end\n   return true\nend", "  -- Find the minimum value in\
    \ the list using binary search.\n  -- This also gives us the index where the minimum\
    \ occurs.\n  local function comp(element, element, index)\n    if element > element\
    \ then\n      local high = index\n      local low = index - 1\n      while low\
    \ >= 0 do\n        local mid = (high + low) / 2\n        if element < list[mid]\
    \ then\n          high = mid\n        else\n          low = mid\n        end\n\
    \      end\n      return high\n    else\n      local high = index\n      local\
    \ low = index + 1\n      while low <= #list do\n        local mid = (high + low)\
    \ / 2\n        if element > list[mid] then\n          high = mid\n        else\n\
    \          low = mid\n        end\n      end\n      return low\n    end\n  end\n\
    \  local minimum = list[1]\n  local minimum_index = 1\n  for i = 2, #list do\n\
    \    local element = list[i]\n    if element < minimum then\n      minimum = element\n\
    \      minimum_index = comp(minimum, element, minimum_index)\n    end\n  end\n\
    \  return minimum_index == 1\nend", "    local i = 1\n    for i = 1, #l do\n \
    \       if l[i] ~= l[i-1] then\n            return false\n        end\n    end\n\
    \    return true\nend", "  local decreasing = false\n  local last_value = nil\n\
    \  for _, value in pairs(l) do\n    if not decreasing then\n      decreasing =\
    \ value < last_value\n    else\n      decreasing = value < last_value or not decreasing\n\
    \    end\n    last_value = value\n  end\n  return decreasing\nend", '  if #l ==
    0 then return true end', "  local max = 0\n  local min = nil", "  local monotonic\
    \ = nil\n  for i = 1, #l do\n    local x = l[i]\n    if monotonic ~= nil then\n\
    \      if x >= monotonic then\n        return false\n      elseif x < monotonic\
    \ then\n        monotonic = x\n      end\n    else\n      monotonic = x\n    end\n\
    \  end\n  return true\nend", "  if #l == 0 then\n    return true\n  end", "  local\
    \ max = {}\n  for i = 1, #l do\n    local v, m = l[i], 0\n    for _, v2 in pairs(l)\
    \ do\n      if v < v2 then\n        v, m = v2, m+1\n      end\n    end\n    max[i]\
    \ = m == 0\n  end\n  return max == nil\nend", "  local n = {}\n  local max = 0\n\
    \  for _, v in ipairs(l) do\n    n[v] = n[v] or 0\n    n = v > max and {v, n[v]\
    \ + 1} or n[v] and {v, 1} or n[v]\n  end\n  for _, v in pairs(n) do\n    if v\
    \ > max then\n      max = v\n    end\n  end\n  return n == 0\nend", "  if l ==\
    \ nil then return false end\n  local idx = #l\n  if idx == 1 then return true\
    \ end\n  if idx == 2 then return l[1] <= l[2] end\n  if idx == 3 then return l[1]\
    \ <= l[2] and l[3] <= l[2] end\n  return l[1] <= l[2] and l[3] <= l[2] and l[1]\
    \ <= l[3] and l[2] <= l[3]\nend", "  local sorted = sorttable(l)\n  local i =\
    \ 1\n  while i <= #sorted do\n    local current_element = sorted[i]\n    local\
    \ previous_element = sorted[i-1]\n    local result = false\n    -- Special case\
    \ if previous element monotonically\n    -- decreasing\n    if previous_element\
    \ and previous_element > current_element then\n      if i - 2 > 0 then\n     \
    \   local current_element2 = sorted[i-2]\n        local previous_element2 = sorted[i-1]\n\
    \        -- Special case if previous 2 elements are monotonically\n        --\
    \ decreasing\n        if previous_element2 and previous_element2 > current_element2\
    \ then\n          result = true\n        end\n      else\n        result = true\n\
    \      end\n    end\n    -- Special case if current element monotonically\n  \
    \  -- increasing\n    if current_element and current_element > previous_element\
    \ then\n      result = true\n    end\n    -- Only need to check up to two elements\
    \ since an element may\n    -- be monotonically decreasing or increasing\n   \
    \ if i > 2 and current_element and current_element > previous_element then\n \
    \     result = true\n    end\n    if result then\n      return true\n    end\n\
    \    i = i + 1\n  end\n  return false\nend", "  local isdecreasing = true\n  local\
    \ last = nil\n  for i, value in ipairs(l) do\n    last = value\n    if not isdecreasing\
    \ then\n      isdecreasing = value > last\n    end\n  end\n  return isdecreasing\n\
    end", "  if #l == 0 then\n    return false\n  elseif #l == 1 then\n    return\
    \ l[1] < l[0]\n  else\n    local tail = l[#l - 1]\n    for _, val in ipairs(l)\
    \ do\n      if val ~= tail and tail < val then\n        return false\n      end\n\
    \    end\n    return true\n  end\nend", "  -- Return true if all elements are\
    \ monotonically increasing or decreasing.\n  local function is_sorted(l)\n   \
    \ local i = 1\n    while i <= #l do\n      if not l[i-1] then\n        return\
    \ false\n      end\n      i = i + 1\n    end\n    return true\n  end\n  local\
    \ ok = true\n  for _, elem in ipairs(l) do\n    if not is_sorted(l) then\n   \
    \   ok = false\n      break\n    end\n  end\n  return ok\nend", '    local monotonic_flag
    = nil', "  local comp = function(a, b) return a < b end\n  if #l == 1 then return\
    \ comp(l[1], l[1]) end\n  if #l == 2 then return comp(l[1], l[2]) or comp(l[2],\
    \ l[1]) end\n  -- TODO: vectorize this algorithm\n  for i = 2, #l do\n    if l[i]\
    \ == l[i - 1] + 1 then return true end\n  end\n  return false\nend", "  local\
    \ function comp(a, b) return a < b end\n  local function compl(a, b) return comp(b,\
    \ a) end\n  local function pairs(l) return pairs(l) end\n  local function sort(a)\
    \ return sort(a) end\n  local function unique(a) return setmetatable({\n    __index\
    \ = function(self, i)\n      local seen = {}\n      for v in pairs(a) do\n   \
    \     if seen[v] == i then return v end\n        seen[v] = i\n      end\n    end\n\
    \  }, a) end\n  local function is_monotonic(a, e)\n    local function comp(a,\
    \ b) return b < a end\n    local function compl(a, b) return comp(b, a) end\n\
    \    local function pairs(l) return pairs(l) end\n    local function sort(a) return\
    \ sort(a) end\n    local function unique(a) return setmetatable({\n      __index\
    \ = function(self, i)\n        local seen = {}\n        for v in pairs(a) do\n\
    \          if seen[v] == i then return v end\n          seen[v] = i\n        end\n\
    \      end\n    }, a) end\n    local i, j = 1, length(a)\n    local last = { a\
    \ = last }\n    while i <= j do\n      local cmp, c = {}, last\n      while i\
    \ <= j do\n        if i == j then\n          cmp[i] = true\n          break\n\
    \        end\n        cmp[i] = a[i] > a[j]\n        if cmp[i] then\n         \
    \ c.a = a[i]\n          i = i + 1\n        else\n          c.a = a[j]\n      \
    \    j = j - 1\n        end\n      end\n      if cmp[i] then return false end\n\
    \      if cmp[i] and compl(last.a, a[i]) then\n        return false\n      end\n\
    \      last.a = a[i]\n    end\n    local n = length(a)\n    if n == 1 then return\
    \ true end\n    last = { a = a[n - 1] } if n > 1 and not is_monotonic(a, n) then\
    \ return false end\n    if cmp[n] then return false end\n    if compl(last.a,\
    \ a[n]) then\n      return false\n    end\n    return true\n  end\n  if type(l)\
    \ == \"table\" then\n    for i = 1, length(l) do\n      local m = monotonic(l[i])\n\
    \      if m == false then return false end\n    end\n    return true\n  end\n\
    \  local cmp = sort(l)\n  if is_monotonic(cmp) then\n    return true\n  end\n\
    \  local n = length(cmp)\n  if n == 1 then return true end\n  local k = n - 1\n\
    \  local e = cmp[k]\n  local j = k - 1\n  local i", "  if #l == 0 then\n    return\
    \ false\n  end\n  local prev = l[1]\n  for i = 2, #l do\n    if l[i] ~= prev then\n\
    \      return true\n    end\n    prev = l[i]\n  end\n  return false\nend", " \
    \ if #l == 0 then return false end\n  local i = #l - 1\n  local current = l[i]\n\
    \  for i = i - 1, -1, -1 do\n    if l[i] < current then return false end\n   \
    \ current = l[i]\n  end\n  return true\nend", "  local min, max = unpack(l) --\
    \ min & max values of l.\n  if min == max then -- Empty table.\n    return true\n\
    \  end\n  if min == min then -- If min and max are equal, table is strictly increasing\
    \ (or strictly decreasing).\n    return false\n  end\n  if min > max then -- If\
    \ min is greater than max, table is strictly decreasing.\n    return true\n  end\n\
    \  if min == max then -- If min and max are equal, table is strictly increasing\
    \ (or strictly decreasing).\n    return true\n  end\n  for i = #l + 1, 1 do\n\
    \    local v = l[i]\n    if v ~= min and v ~= max then -- If current value is\
    \ not equal to min or max, table is strictly increasing.\n      return false\n\
    \    end\n  end\n  return true\nend", "  -- If the list is empty, monotonicity\
    \ cannot be determined\n  if #l == 0 then\n    return false\n  end", "  local\
    \ min_val, max_val = l[1], l[#l]\n  for i = 2, #l do\n    if l[i] ~= l[i - 1]\
    \ + 1 then\n      if l[i] < min_val then\n        min_val = l[i]\n      elseif\
    \ l[i] > max_val then\n        max_val = l[i]\n      end\n    end\n  end\n  return\
    \ min_val <= max_val\nend", "   local function compare(x, y)\n      if x < y then\
    \ return -1 end\n      if x > y then return 1 end\n      return 0\n   end\n  \
    \ local curr = l[1]\n   for i = 2, #l do\n      if compare(curr, l[i]) < 0 then\n\
    \         return false\n      elseif compare(curr, l[i]) == 0 then\n         return\
    \ true\n      else\n         curr = l[i]\n      end\n   end\n   return true\n\
    end", "  local i = 1\n  local last = l[1]\n  while i < #l do\n    local x = l[i]\n\
    \    if x > last then\n      last = x\n    else\n      return false\n    end\n\
    \    i = i + 1\n  end\n  return true\nend", "  if #l <= 1 then return false end\n\
    \  if #l == 2 and (l[1] == l[2]) then return true end\n  if #l == 2 and (l[1]\
    \ < l[2]) then return false end\n  if #l == 2 and (l[1] > l[2]) then return true\
    \ end\n  if #l == 3 and (l[1] < l[2]) then return false end\n  if #l == 3 and\
    \ (l[1] > l[2]) then return true end\n  if #l == 3 and (l[2] < l[3]) then return\
    \ false end\n  if #l == 3 and (l[2] > l[3]) then return true end\n  if #l == 4\
    \ and (l[3] < l[2]) then return false end\n  if #l == 4 and (l[3] > l[2]) then\
    \ return true end\n  if #l == 4 and (l[2] < l[3]) then return false end\n  if\
    \ #l == 4 and (l[2] > l[3]) then return true end\n  return false\nend", "   local\
    \ sorted = table.sort(l)\n   for _, value in ipairs(sorted) do\n      if value\
    \ < sorted[#sorted] then\n         return false\n      end\n   end\n   return\
    \ true\nend", "    -- Return true if l is monotonically increasing or decreasing.\n\
    \    -- >>> monotonic([2, 3, 1, -1])\n    -- true\n    -- >>> monotonic([3, 2,\
    \ 1, 0])\n    -- false\n    -- >>> monotonic([2, 2, 2, 2])\n    -- true\n    local\
    \ min_, max_ = unpack(l)\n    if min_ > max_ then\n        return true\n    end\n\
    \    local min = min_\n    local max = max_\n    while min > 0 and min > max do\n\
    \        max = max + 1\n    end\n    return min > max\nend", "\tlocal prev = -math.huge\n\
    \tfor i, v in ipairs(l) do\n\t\tif prev < v then\n\t\t\treturn true\n\t\tend\n\
    \t\tprev = v\n\tend\n\treturn false\nend", "  local prev = {}\n  for i, v in ipairs(l)\
    \ do\n    prev[v] = true\n  end\n  for i, v in ipairs(l) do\n    if not prev[v]\
    \ then\n      return false\n    end\n    prev[v] = nil\n  end\n  return true\n\
    end", "  for i = 1, #l do\n    if l[i] ~= l[i - 1] + 1 then\n      return false\n\
    \    end\n  end\n  return true\nend", "  local sorted = table.remove(l, 1)\n \
    \ local i = #sorted\n  for i = #sorted - 1, 1, -1 do\n    if sorted[i] < sorted[i-1]\
    \ then\n      return false\n    end\n  end\n  return true\nend", "\tlocal maxIndex\
    \ = 1\n\tlocal minIndex = 1\n\tlocal elements = {l[1]}\n\tfor _, el in pairs(l)\
    \ do\n\t\tif el > elements[maxIndex] then\n\t\t\tmaxIndex = el\n\t\telseif el\
    \ < elements[minIndex] then\n\t\t\tminIndex = el\n\t\tend\n\t\ttable.insert(elements,\
    \ el)\n\tend\n\treturn minIndex == maxIndex\nend", "  local last_elem = l[1]\n\
    \  for i = 2, #l do\n    if last_elem < l[i] then\n      return false\n    end\n\
    \    last_elem = l[i]\n  end\n  return true\nend", "  local i = 1\n  local last\
    \ = l[1]\n  local j = 1\n  while i <= #l do\n    local current = l[i]\n    if\
    \ current > last then\n      return false\n    end\n    last = current\n    i\
    \ = i + 1\n  end\n  return true\nend", "  local prev = -1\n  local max = 0\n \
    \ for i = 1, #l do\n    if prev >= l[i] then\n      max = i\n    end\n    prev\
    \ = l[i]\n  end\n  if prev >= 0 and prev > l[max] then\n    return false\n  end\n\
    \  return true\nend", "   local keys = {}\n   local i = 1\n   for _,x in ipairs(l)\
    \ do keys[#keys + 1] = x end\n   for i = 2, #keys do keys[i] = keys[i-1] + keys[i]\
    \ end\n   return #keys > 0 and #keys == #l and keys[1] <= keys[#keys]\nend", "\t\
    local last_value = nil\n\tfor _, value in l:gmatch(\"%d+\") do\n\t\tif last_value\
    \ == nil or last_value < value then\n\t\t\tlast_value = value\n\t\t\treturn true\n\
    \t\telse\n\t\t\treturn false\n\t\tend\n\tend\nend", "   local i = 1\n   while\
    \ i <= #l do\n      if l[i] < l[i-1] then\n         return false\n      elseif\
    \ l[i] > l[i-1] then\n         i = i + 1\n      else\n         i = i + 2\n   \
    \   end\n   end\n   return true\nend", '  if #l <= 1 then return true end', " \
    \ local min, max = 0, #l\n  while min < max do\n    local mid = math.floor(min\
    \ + (max - min) / 2)\n    local cmp = l[mid]\n    if cmp < min then min = mid\
    \ else max = mid end\n  end\n  return min == 0 and false or true\nend", "  if\
    \ #l == 0 then return false end\n  local prev = l[1]\n  for i = 2, #l do\n   \
    \ if l[i] ~= prev then\n      return false\n    end\n    prev = l[i]\n  end\n\
    \  return true\nend", "  for i=1,#l do\n    if l[i] < l[i-1] then\n      return\
    \ false\n    end\n  end\n  return true\nend", "  if l == nil then\n    return\
    \ false\n  end\n  local i = 0\n  local j = #l + 1\n  while i <= j do\n    if l[i]\
    \ <= l[j] then\n      i = i + 1\n    else\n      j = j - 1\n    end\n  end\n \
    \ return i == #l\nend", "  local i, length = 1, #l\n  while i < length and l[i]\
    \ > l[i - 1]\n  do\n    i = i + 1\n  end\n  if i == length then\n    return true\n\
    \  end\n  local j = i\n  while j > 0 and l[j] < l[j - 1]\n  do\n    j = j - 1\n\
    \  end\n  return i <= j\nend", "  local ok, i, last_i = true, 1, 0\n  for i, v\
    \ in ipairs(l) do\n    local tmp\n    if last_i > i then\n      tmp = v\n    else\n\
    \      tmp = last_i - 1\n    end\n    last_i = i\n    if not ok then\n      ok\
    \ = tmp < v\n    end\n  end\n  return ok\nend", "   local last = l[1]\n   for\
    \ _, v in ipairs(l) do\n      if v < last then\n         return false\n      end\n\
    \      last = v\n   end\n   return true\nend", "  for i = 1, #l do\n    if l[i]\
    \ > l[i-1] then return false end\n    if l[i] < l[i-1] then return true end\n\
    \  end\n  return true\nend", "  local i = 1\n  local last_element = nil\n  while\
    \ i <= #l do\n    local element = l[i]\n    if last_element and element < last_element\
    \ then\n      return false\n    else\n      last_element = element\n    end\n\
    \    i = i + 1\n  end\n  return true\nend", '  if #l <= 1 then return true end']
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
