name: HumanEval_29_filter_by_prefix
language: lua
prompt: "-- Filter an input table of strings only for ones that start with a given\
  \ prefix.\n-- >>> filter_by_prefix({}, 'a')\n-- {}\n-- >>> filter_by_prefix({'abc',\
  \ 'bcd', 'cde', 'array'}, 'a')\n-- {'abc', 'array'}\nlocal function filter_by_prefix(strings,\
  \ prefix)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = filter_by_prefix\n\
  \    lu.assertEquals(candidate({}, 'john'), {})\n    lu.assertEquals(candidate({'xxx',\
  \ 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx'), {'xxx', 'xxxAAA', 'xxx'})\n\
  end\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local result = {}\n    for _, string in ipairs(strings) do\n  \
    \      if string.starts(prefix) then\n            result[#result + 1] = string\n\
    \        end\n    end\n    return result\nend", "  local result = {}\n  for key,\
    \ value in pairs(strings) do\n    if string.sub(key, 1, #prefix) == prefix then\n\
    \      table.insert(result, value)\n    end\n  end\n  return result\nend", " \
    \   local res = {}\n    for key, value in pairs(strings) do\n        if string.sub(key,\
    \ 1, string.len(prefix))~=prefix then\n            res[key] = value\n        end\n\
    \    end\n    return res\nend", "  if not prefix or prefix == '' then\n    return\
    \ strings\n  end\n  local new_strings = {}\n  for _, s in pairs(strings) do\n\
    \    local idx = string.find(s, prefix, 1, true) -- find the first character of\
    \ the prefix\n    if idx then\n      table.insert(new_strings, s)\n    end\n \
    \ end\n  return new_strings\nend", "    if not prefix then prefix = \"\" end\n\
    \    local result = {}\n    local prefix_len = #prefix\n    for _, item in ipairs(strings)\
    \ do\n        if item:len() <= prefix_len then\n            result[#result + 1]\
    \ = item\n        else\n            local prefix_len = prefix_len - 1\n      \
    \      for i = 1, item:len() - prefix_len do\n                if item:sub(i, i\
    \ + prefix_len) == prefix then\n                    result[#result + 1] = item\n\
    \                    prefix_len = 0\n                    break\n             \
    \   end\n            end\n        end\n    end\n    return result\nend", "  local\
    \ prefix = prefix or ''\n  local result = {}\n  for k, v in pairs(strings) do\n\
    \    if k:sub(1, #prefix) == prefix then\n      table.insert(result, v)\n    end\n\
    \  end\n  return result\nend", "    local new_strings = {}\n    for _, str in\
    \ ipairs(strings) do\n        if string.sub(str, 1, string.len(prefix)) == prefix\
    \ then\n            new_strings[#new_strings + 1] = {str}\n        end\n    end\n\
    \    return new_strings or {}\nend", "  local new_strings = setmetatable({}, {\n\
    \    __index = function(t, k)\n      -- The only way to filter out non-strings\
    \ is to filter out anything that isn't a string or a prefix of it.\n      return\
    \ k and t:sub(1, #prefix) == prefix and strings[k] or {}\n    end,\n    __newindex\
    \ = function()\n      error('trying to set __newindex')\n    end,\n  })\n  for\
    \ _, s in pairs(strings) do\n    new_strings[s:sub(1, #prefix)]\n  end\n  return\
    \ new_strings\nend", "  local function match(s)\n    return s:sub(1, #prefix)\
    \ == prefix\n  end\n  return filter_by_function(strings, match)\nend", "  local\
    \ result = {}\n  for _, s in ipairs(strings) do\n    if s:sub(1, #prefix) == prefix\
    \ then\n      table.insert(result, s)\n    end\n  end\n  return result\nend",
  "  local table = {}\n  for _, string in ipairs(strings) do\n    if string.sub(1,\
    \ prefix) == prefix then\n      table.insert(table, string)\n    end\n  end\n\
    \  return table\nend", "\tlocal r = {}\n\tfor _, s in ipairs(strings) do\n\t\t\
    if s:sub(1, #prefix) == prefix then\n\t\t\ttable.insert(r, s)\n\t\tend\n\tend\n\
    \treturn r\nend", "  for _, s in ipairs(strings) do\n    if string.sub(s, 1, #prefix)\
    \ == prefix then\n      table.insert(strings, s)\n    end\n  end\n  return strings\n\
    end", "  local result = {}\n  for _, v in ipairs(strings) do\n    if v:sub(1,\
    \ #prefix) == prefix then\n      table.insert(result, v)\n    end\n  end\n  return\
    \ result\nend", "  prefix = prefix or ''\n  local prefixed_strings = setmetatable({},\
    \ {__index = strings}) or {}\n  for key, value in pairs(strings) do\n    if key:sub(1,\
    \ #prefix) == prefix then\n      prefixed_strings[#prefixed_strings + 1] = value\n\
    \    end\n  end\n  return prefixed_strings\nend", "  local result = {}\n  for\
    \ k, v in pairs(strings) do\n    if k:sub(1, prefix:len()) == prefix then\n  \
    \    table.insert(result, v)\n    end\n  end\n  return result\nend", "    local\
    \ function f(input_value)\n        local is_prefix = prefix\n            .. (prefix\
    \ and prefix ~= '' and prefix or \"\")\n            .. (prefix and prefix ~= nil\
    \ and prefix or '')\n            .. (prefix and prefix ~= false and prefix or\
    \ nil)\n        return is_prefix and input_value ~= prefix and is_prefix or input_value:sub(1,\
    \ #prefix) == prefix\n    end\n    return table.filter(f, strings)\nend", "  local\
    \ result = {}\n  for k, v in pairs(strings) do\n    if k:sub(1, #prefix) == prefix\
    \ then\n      result[k] = v\n    end\n  end\n  return result\nend", "  local results\
    \ = {}\n  for _, string in ipairs(strings) do\n    if string.starts_with(prefix)\
    \ then\n      table.insert(results, string)\n    end\n  end\n  return results\n\
    end", "  assert(type(strings) == 'table')\n  assert(type(prefix) == 'string')\n\
    \  local result = {}\n  for _, item in pairs(strings) do\n    if string.sub(item,\
    \ 1, #prefix) == prefix then\n      result[#result + 1] = {item}\n    end\n  end\n\
    \  return result\nend", "  local result = {}\n  for key, value in pairs(strings)\
    \ do\n    if key:sub(1, #prefix) == prefix then\n      table.insert(result, value)\n\
    \    end\n  end\n  return result\nend", "  local result = {}\n  for i = 1, #strings\
    \ do\n    if strings[i] ~= prefix then break end\n    result[#result + 1] = strings[i]\n\
    \  end\n  return result\nend", "  local output = {}\n  for _, v in pairs(strings)\
    \ do\n    if v:sub(1, #prefix) == prefix then\n      table.insert(output, v)\n\
    \    end\n  end\n  return output\nend", "    local prefix = prefix or ''\n   \
    \ for _, value in pairs(strings) do\n        if string.sub(value, 1, prefix:len())\
    \ == prefix then\n            table.remove(strings, value)\n        end\n    end\n\
    \    return strings\nend", "  if not prefix then\n    return {}\n  else\n    prefix\
    \ = prefix or ''\n    local ret = {}\n    local i = 1\n    repeat\n      ret[#ret\
    \ + 1] = strings[i]\n      i = i + 1\n    until i > #strings or strings[i] ~=\
    \ prefix\n    return ret\n  end\nend", "  local result = {}\n  for k, v in pairs(strings)\
    \ do\n    if k:sub(1, #prefix) == prefix then\n      result[k] = v\n    end\n\
    \  end\n  return result\nend", "  local result = {}\n  for key, val in pairs(strings)\
    \ do\n    if val == prefix then\n      table.insert(result, key)\n    end\n  end\n\
    \  return result\nend", "    if prefix then\n        local filtered = {}\n   \
    \     for k, v in pairs(strings) do\n            if k:sub(1, prefix:len()) ==\
    \ prefix then\n                table.insert(filtered, k)\n            end\n  \
    \      end\n        return filtered\n    end\n    return {}\nend", "  local result\
    \ = {}\n  for k, v in pairs(strings) do\n    if k:sub(1, prefix:len()) == prefix\
    \ then\n      table.insert(result, v)\n    end\n  end\n  return result\nend",
  "  local result = {}\n  for _, string in ipairs(strings) do\n    if string.starts\
    \ with prefix then\n      table.insert(result, string)\n    end\n  end\n  return\
    \ result\nend", "  local result = {}\n  local i = 1\n  for k in pairs(strings)\
    \ do\n    local v = strings[k]\n    if not v:find(prefix) then\n      result[i]\
    \ = k\n      i = i + 1\n    end\n  end\n  return result\nend", "  if not prefix\
    \ then return strings end\n  local function filter1(string)\n    return string.startswith\
    \ and string.startswith(prefix) or prefix == string\n  end\n  return filter1(strings)\
    \ and\n         filter1(strings[1]) and\n         {[ filter1(strings[1]) ]}\n\
    end", "    local ret = {}\n    for k, v in pairs(strings) do\n        if string.sub(v,\
    \ 1, #prefix) == prefix then\n            ret[#ret + 1] = v\n        end\n   \
    \ end\n    return ret\nend", "  local prefix = prefix or ''\n  local filter =\
    \ {}\n  for k,v in pairs(strings) do\n    if string.sub(k, 1, #prefix) == prefix\
    \ then\n      table.insert(filter, v)\n    end\n  end\n  return filter\nend",
  "  if prefix and prefix ~= '' then\n    for k, v in pairs(strings) do\n      if\
    \ k:sub(1, #prefix) == prefix then\n        table.remove(strings, k)\n      end\n\
    \    end\n  end\n  return strings\nend", "  local prefix_len = #prefix\n  return\
    \ function()\n    local keys = table.getn(strings)\n    for i = 1, #strings do\n\
    \      local k = strings[i]\n      local n = #k\n      if n == prefix_len then\n\
    \        if k:sub(1, prefix_len) == prefix then\n          table.insert(keys,\
    \ k)\n        end\n      end\n    end\n    return keys\n  end\nend", "  local\
    \ result = {}\n  for _, str in pairs(strings) do\n    if string.sub(str, 1, prefix:len())\
    \ == prefix then\n      table.insert(result, str)\n    end\n  end\n  return result\n\
    end", "    if type(prefix) ~= 'string' then\n        return {}\n    end", "  assert(type(strings)\
    \ == 'table')\n  assert(type(prefix) == 'string')", "    local ret = {}\n    for\
    \ _, str in pairs(strings) do\n        if str:sub(1,prefix:len()) == prefix then\n\
    \            ret[#ret+1] = str\n        end\n    end\n    return ret\nend", " \
    \   local ret = {}\n    for _, str in pairs(strings) do\n        if str:sub(1,\
    \ #prefix) == prefix then\n            ret[str] = true\n        end\n    end\n\
    \    return ret\nend", "  if prefix and #prefix > 0 then\n    local pattern =\
    \ prefix\n    for i, v in ipairs(strings) do\n      if v:sub(1,#pattern) == pattern\
    \ then\n        table.insert(strings,v)\n      end\n    end\n  end\n  return strings\n\
    end", "   -- The returned object will hold all the values that start with 'prefix'\n\
    \   local result = {}\n   for key, val in pairs(strings) do\n      if key:sub(1,\
    \ #prefix) == prefix then\n         table.insert(result, val)\n      end\n   end\n\
    \   return result\nend", "\tlocal result = {}\n\tfor _, str in ipairs(strings)\
    \ do\n\t\tif str:sub(1, #prefix) == prefix then\n\t\t\tresult[#result + 1] = tostring(str)\n\
    \t\tend\n\tend\n\treturn result\nend", "  local output = {}\n  for _, string in\
    \ ipairs(strings) do\n    if string.starts_with(prefix) then\n      table.insert(output,\
    \ string)\n    end\n  end\n  return output\nend", "  if prefix ~= '' then\n  \
    \  local filtered = {}\n    for k, v in pairs(strings) do\n      if k:find(prefix)\
    \ == 0 then\n        table.insert(filtered, v)\n      end\n    end\n    return\
    \ filtered\n  else\n    return strings\n  end\nend", "  -- If there is no prefix,\
    \ the table is empty and there's nothing to filter.\n  if not prefix then\n  \
    \  return strings\n  end\n  -- If the prefix is too short, there's nothing to\
    \ filter.\n  if #prefix < 1 then\n    return strings\n  end\n  -- Create a table\
    \ of every possible prefix and check each of them to see if it starts with it.\n\
    \  local prefix_table = {}\n  for i, x in ipairs(prefix) do\n    prefix_table[x]\
    \ = true\n  end\n  -- For each string, if it starts with the prefix, add it to\
    \ the output table.\n  local output_strings = {}\n  for _, x in ipairs(strings)\
    \ do\n    local prefix = x\n    for _, prefix2 in ipairs(prefix) do\n      if\
    \ not prefix_table[prefix2] then\n        output_strings[#output_strings + 1]\
    \ = x\n      end\n    end\n  end\n  return output_strings\nend", "  if prefix\
    \ then\n    for k, v in pairs(strings) do\n      if k:sub(1, #prefix) == prefix\
    \ then\n        -- print(strings)\n        -- print(k)\n        -- print(v)\n\
    \        strings[k] = v\n      end\n    end\n  end\n  return strings\nend", " \
    \   local function match(s)\n        return s:sub(1, #prefix) == prefix\n    end",
  "    local filtered = {}\n    for key, value in pairs(strings) do\n        if string.sub(key,\
    \ 1, string.len(prefix))==prefix then\n            table.insert(filtered, value)\n\
    \        end\n    end\n    return filtered\nend\n</cell>\n<text>\nCombining Filtering\n\
    Filtering can also be combined with other operators to create a more complex filter.\
    \ Let's say we want to filter all of the values which don't start with the prefix\
    \ 'a':", "    if prefix then prefix = prefix .. '$' end", "  local result = {}\n\
    \  for k, v in pairs(strings) do\n    if k:sub(1, #prefix) == prefix then\n  \
    \    table.insert(result, v)\n    end\n  end\n  return result\nend", "  local\
    \ ret = {}\n  for _, str in ipairs(strings) do\n    if string.sub(str, 1, string.len(prefix))\
    \ = prefix then\n      table.insert(ret, str)\n    end\n  end\n  return ret\n\
    end", "  local result = {}\n  for k, v in pairs(strings) do\n    if v == prefix\
    \ then\n      table.insert(result, v)\n    end\n  end\n  return result\nend",
  "    if prefix then\n        local filtered = {}\n        for _, value in pairs(strings)\
    \ do\n            if value:sub(1, prefix:len()) == prefix then\n             \
    \   table.insert(filtered, value)\n            end\n        end\n        return\
    \ filtered\n    end\n    return strings\nend", "  local result = {}\n  for _,\
    \ str in pairs(strings) do\n    if str:sub(1, #prefix) == prefix then\n      table.insert(result,\
    \ str)\n    end\n  end\n  return result\nend", "  local result = {}\n  for k,\
    \ v in pairs(strings) do\n    if k:sub(1, prefix:len()) == prefix then\n     \
    \ table.insert(result, v)\n    end\n  end\n  return result\nend", "    local result\
    \ = {}\n    for key, value in pairs(strings) do\n        if string.sub(key, 1,\
    \ prefix) == prefix then\n            table.insert(result, value)\n        end\n\
    \    end\n    return result\nend", "   assert(type(strings) == 'table')\n   assert(type(prefix)\
    \ == 'string')\n   local filtered = {}\n   for k in pairs(strings) do\n      if\
    \ k:sub(1, #prefix) == prefix then\n         table.insert(filtered, k)\n     \
    \ end\n   end\n   return filtered\nend", "  local table = {}\n  for k, v in pairs(strings)\
    \ do\n    if k:sub(1, prefix:len()) == prefix then\n      table.insert(table,\
    \ v)\n    end\n  end\n  return table\nend", "    local filter = {}\n    for i,\
    \ v in ipairs(strings) do\n        if v:sub(1, prefix) == prefix then\n      \
    \      table.insert(filter, v)\n        end\n    end\n    return filter\nend",
  "   if prefix and prefix ~= '' and prefix ~= prefix .. '' then\n      return {\n\
    \         [prefix] = true,\n      }\n   else\n      return tables\n   end\nend",
  "    local result = {}\n    for _, s in ipairs(strings) do\n        if s:sub(1,\
    \ #prefix) == prefix then\n            result[#result + 1] = s\n        end\n\
    \    end\n    return result\nend", "   assert(type(strings) ~= 'table', 'Expected\
    \ a table')\n   assert(type(prefix) ~= 'string', 'Expected a string')\n   \n \
    \  local result = {}\n   for k, v in pairs(strings) do\n      if k:sub(1, #prefix)\
    \ == prefix then\n         table.insert(result, v)\n      end\n   end\n   \n \
    \  return result\nend", "  local result = {}\n  for _, s in ipairs(strings) do\n\
    \    if string.sub(s, 1, string.len(prefix)) ~= prefix then\n      result[#result\
    \ + 1] = s\n    end\n  end\n  return result\nend", "  local results = {}\n  for\
    \ _, s in ipairs(strings) do\n    if s:sub(1, #prefix) == prefix then\n      table.insert(results,\
    \ s)\n    end\n  end\n  return results\nend", "  local out = { }\n  for _, value\
    \ in ipairs(strings) do\n    if string.sub(value, 1, string.len(prefix)) == prefix\
    \ then\n      table.insert(out, value)\n    end\n  end\n  return out\nend", " \
    \  if prefix and prefix ~= '' then\n      return table.filter (\n         strings,\n\
    \         function (item)\n            return item:sub(1, #prefix):lower() ==\
    \ prefix\n         end\n      )\n   else\n      return strings\n   end\nend",
  "  local result = {}\n  for key, val in pairs(strings) do\n    if key:sub(1, #prefix)\
    \ == prefix then\n      table.insert(result, val)\n    end\n  end\n  return result\n\
    end", "  if not prefix or #prefix > 0 then return strings end\n  return setmetatable({[prefix]\
    \ = strings[prefix] or nil}, getmetatable(strings))\nend", "  local result = {}\n\
    \  for _, s in ipairs(strings) do\n    if string.sub(s, 1, prefix) == prefix then\n\
    \      table.insert(result, s)\n    end\n  end\n  return result\nend", "  local\
    \ prefix = prefix or ''\n  local new_strings = {}", "    local output = {}\n \
    \   for _, str in pairs(strings) do\n        if str:sub(1, prefix:len()) == prefix\
    \ then\n            output[#output + 1] = str\n        end\n    end\n    return\
    \ output\nend", "    local results = {}\n    for k in pairs(strings) do\n    \
    \    if k:sub(1, #prefix) == prefix then\n            results[k] = strings[k]\n\
    \        end\n    end\n    return results\nend", "  prefix = prefix or \"\"\n\
    \  local result = {}\n  for _, value in ipairs(strings) do\n    if type(value)\
    \ == 'string' and value:len() > prefix then\n      result[#result + 1] = value\n\
    \    end\n  end\n  return result\nend", "  local out = { }\n  for _, v in pairs(strings)\
    \ do\n    if v:sub(1, #prefix) == prefix then\n      table.insert(out, v)\n  \
    \  end\n  end\n  return out\nend", "  local result = {}\n  local i = 1\n  for\
    \ k in pairs(strings) do\n    if k:sub(1, prefix:len()) == prefix then\n     \
    \ table.insert(result, k)\n    end\n    i = i + 1\n  end\n  return result\nend",
  '    if not prefix then return strings end', "  for _, string in ipairs(strings)\
    \ do\n    if string.sub(1, #prefix) == prefix then\n      return string\n    end\n\
    \  end\n  local new_strings = setmetatable({strings[1]}, {}) or {}\n  new_strings[1]\
    \ = strings[1]\n  return new_strings\nend", "  local results = {}\n  for k, v\
    \ in pairs(strings) do\n    if k:find(prefix) == 0 then\n      table.insert(results,\
    \ v)\n    end\n  end\n  return results\nend", "  local result = {}\n  for k, v\
    \ in pairs(strings) do\n    if k:sub(1, #prefix) == prefix then\n      result[k]\
    \ = v\n    end\n  end\n  return result\nend", "  local result = {}\n  for _, _\
    \ in pairs(strings) do\n    if strings[_]:sub(1, #prefix) == prefix then\n   \
    \   table.insert(result, strings[_])\n    end\n  end\n  return result\nend", " \
    \   local result = {}\n    for k, v in pairs(strings) do\n        if k:find(prefix)\
    \ == 1 then\n            table.insert(result, v)\n        end\n    end\n    return\
    \ result\nend", "  local result = {}\n  local prefix_len = #prefix\n  for _, v\
    \ in pairs(strings) do\n    if v:sub(1, prefix_len) == prefix then\n      result[#result\
    \ + 1] = v\n    end\n  end\n  return result\nend", "  local output = {}\n  --\
    \ Copy all strings to preserve their original pointers.\n  for i, value in pairs(strings)\
    \ do\n    if string.sub(value, 1, #prefix) == prefix then\n      table.insert(output,\
    \ value)\n    end\n  end\n  return output\nend\n</cell>\n<text>\nLet's test it\
    \ out", "  if prefix == nil then\n    prefix = ''\n  end\n  local result = {}\n\
    \  for k in pairs(strings) do\n    if k:sub(1, #prefix) == prefix then\n     \
    \ result[k] = strings[k]\n    end\n  end\n  return result\nend", "  assert(type(prefix)\
    \ == 'string', 'prefix must be a string')\n  assert(type(strings) == 'table',\
    \ 'strings must be a table')\n  local result = {}\n  for k, v in pairs(strings)\
    \ do\n    if v:sub(1, #prefix) == prefix then\n      table.insert(result, k)\n\
    \    end\n  end\n  return result\nend", "  local output = {}\n  for k,v in pairs(strings)\
    \ do\n    if k:sub(1, prefix:len()) == prefix then\n      table.insert(output,\
    \ v)\n    end\n  end\n  return output\nend", "  local keys = {}\n  for _, value\
    \ in pairs(strings) do\n    if string.sub(value, 1, #prefix) == prefix then\n\
    \      table.insert(keys, value)\n    end\n  end\n  return keys\nend", "  local\
    \ prefix = prefix or ''\n  return function(value, key)\n    for _, string in pairs(strings)\
    \ do\n      local start_index = string and string:find(prefix)\n      if start_index\
    \ == 0 then\n        return false\n      end\n      if start_index > 0 then\n\
    \        return key == string\n      end\n    end\n    return true\n  end\nend",
  "    local filtered_strings = {}\n    for key, value in pairs(strings) do\n    \
    \    if string.sub(key, 1, string.len(prefix)) == prefix then\n            filtered_strings[#filtered_strings\
    \ + 1] = key\n        end\n    end\n    return filtered_strings\nend", "    local\
    \ result = {}\n    for k, v in pairs(strings) do\n        if k:sub(1, #prefix)\
    \ == prefix then\n            result[k] = v\n        end\n    end\n    return\
    \ result\nend", "    local function contains_prefix(string)\n        return string\
    \ and string.startswith(prefix)\n    end\n    local function add_keys(prefix,\
    \ table)\n        local new_table = {}\n        for k, val in pairs(table) do\n\
    \            if contains_prefix(val) then\n                new_table[k] = val\n\
    \            end\n        end\n        return prefix and {prefix, new_table} or\
    \ new_table\n    end\n    return add_keys(prefix, strings)\nend", "  local result\
    \ = {}\n  local function recurse(strings)\n    for i = 1, #strings do\n      if\
    \ string.sub(strings, 1, #prefix) == prefix then\n        result[#result + 1]\
    \ = strings[i]\n      end\n      if i == #strings then\n        return\n     \
    \ end\n      recurse(strings[i+1])\n    end\n  end\n  recurse(strings)\n  return\
    \ result\nend", "    local filtered = {}\n    for k in pairs(strings) do\n   \
    \     if k:sub(1, #prefix) == prefix then\n            table.insert(filtered,\
    \ k)\n        end\n    end\n    return filtered\nend", "    local prefixes = {\
    \ prefix }\n    local values = {}\n    for key, value in pairs(strings) do\n \
    \       if prefixes[1] == key then\n            values[#values + 1] = value\n\
    \        end\n    end\n    return values\nend", "    prefix = prefix or ''\n \
    \   local result = {}\n    for _, s in ipairs(strings) do\n        if s:sub(1,\
    \ #prefix) == prefix then\n            result[#result + 1] = cmsg(s, '<start>',\
    \ '</start>')\n        end\n    end\n    return result\nend", "    local result\
    \ = {}\n    for _, s in ipairs(strings) do\n        if s:sub(1, #prefix) == prefix\
    \ then\n            result[#result + 1] = s\n        end\n    end\n    return\
    \ result\nend", "  local ret = {}\n  for _, s in ipairs(strings) do\n    if s:sub(1,\
    \ #prefix) == prefix then\n      table.insert(ret, s)\n    end\n  end\n  return\
    \ ret\nend", "    if not prefix then\n        return strings\n    end\n    local\
    \ filtered = {}\n    for _, str in ipairs(strings) do\n        local prefix =\
    \ prefix\n        if type(prefix) == 'table' then\n            prefix = prefix[str]\n\
    \        end\n        if str:startswith(prefix) then\n            table.insert(filtered,\
    \ str)\n        end\n    end\n    return filtered\nend", "    if not prefix or\
    \ prefix:len() == 0 then return strings end\n    local prefix = prefix .. '_'\n\
    \    for _, str in ipairs(strings) do\n        if str:sub(1, prefix:len()) ==\
    \ prefix then\n            table.remove(strings, str)\n        end\n    end\n\
    \    return strings\nend", "    local t = {}\n    for key, value in pairs(strings)\
    \ do\n        if key:sub(1, #prefix) == prefix then\n            t[key] = value\n\
    \        end\n    end\n    return t\nend", "  if prefix then\n    local filtered\
    \ = {}\n    for key, value in pairs(strings) do\n      if string.sub(key, 1, string.len(prefix))\
    \ == prefix then\n        table.insert(filtered, value)\n      end\n    end\n\
    \    return filtered\n  else\n    return strings\n  end\nend", "  local result\
    \ = {}\n  for k, v in pairs(strings) do\n    if v and v:sub(1,prefix) == prefix\
    \ then\n      table.insert(result, v)\n    end\n  end\n  return result\nend",
  "    local result = {}\n    for key, value in pairs(strings) do\n        if key\
    \ ~= prefix then\n            result[key] = strings[key]\n        end\n    end\n\
    \    return result\nend", '  local prefix_length = #prefix', "    if not prefix\
    \ then\n        return strings\n    end\n    prefix = prefix:lower()\n    local\
    \ result = {}\n    for _, string in ipairs(strings) do\n        if string.find(prefix,\
    \ 1, true) then\n            result[#result + 1]= string\n        end\n    end\n\
    \    return result or nil\nend", "  local new = {}\n  for k in pairs(strings)\
    \ do\n    if k:sub(1, #prefix) == prefix then\n      new[#new + 1] = k\n    end\n\
    \  end\n  return new\nend", "    local output = {}\n    local found = false\n\
    \    for i = 1, #strings do\n        if strings[i] == prefix then\n          \
    \  found = true\n        else\n            if found then\n                output[#output\
    \ + 1] = '\"' .. strings[i] .. '\"'\n            else\n                output[#output]\
    \ = strings[i]\n            end\n        end\n    end\n    return output\nend",
  "  local filtered_strings = {}\n  for _, v in pairs(strings) do\n    if v:sub(1,\
    \ #prefix) == prefix then\n      table.insert(filtered_strings, v)\n    end\n\
    \  end\n  return filtered_strings\nend", "  local new_strings = {}\n  for _, str\
    \ in ipairs(strings) do\n    if str:sub(1, #prefix) == prefix then\n      table.insert(new_strings,\
    \ str)\n    end\n  end\n  return new_strings\nend", "  local filtered = {}\n \
    \ for _, s in ipairs(strings) do\n    if string.sub(s, 1, #prefix) == prefix then\n\
    \      table.insert(filtered, s)\n    end\n  end\n  return filtered\nend", " \
    \   if not prefix then return strings end\n    local filtered = {}\n    for k,\
    \ v in pairs(strings) do\n        if k:sub(1, #prefix) == prefix then\n      \
    \      table.insert(filtered, v)\n        end\n    end\n    return filtered\n\
    end", "    local result = {}\n    for k, v in pairs(strings) do\n        if k:sub(1,\
    \ #prefix) == prefix then\n            result[#result + 1] = v\n        end\n\
    \    end\n    return result\nend", "  local result = {}\n  for _, value in pairs(strings)\
    \ do\n    if string.sub(value, 1, string.len(prefix)) = prefix then\n      table.insert(result,\
    \ value)\n    end\n  end\n  return result\nend", "  for k in pairs(strings) do\n\
    \    if k:sub(1, #prefix) == prefix then\n      table.remove(strings, k)\n   \
    \ end\n  end\n  return strings\nend", "    local filtered_strings = {}\n    for\
    \ _, string in ipairs(strings) do\n        if string.sub(1, #prefix) == prefix\
    \ then\n            table.insert(filtered_strings, string)\n        end\n    end\n\
    \    return filtered_strings\nend", "  -- Return the input table if no prefix\
    \ has been given, otherwise\n  -- filter out all strings whose first element doesn't\
    \ start with the prefix.\n  if not prefix then\n    return strings\n  end", " \
    \   local ret = {}\n    for _, string in ipairs(strings) do\n        if string.startswith(prefix)\
    \ then\n            table.insert(ret, string)\n        end\n    end\n    return\
    \ ret\nend", "    if prefix ~= '' then\n        -- The first letter in the prefix\
    \ must be the same as the first letter in the string.\n        for k, v in pairs(strings)\
    \ do\n            if k ~= prefix then\n                strings[k] = nil\n    \
    \        end\n        end\n    end\n    return tables\n        :keys(strings)\n\
    \        :filter(\n            function (v)\n                -- Remember that\
    \ `nil` values should be treated like empty tables.\n                if v then\n\
    \                    -- `pairs` gives us the values as pairs of (key, value) pairs.\n\
    \                    for i = 1, #v do\n                        -- The first letter\
    \ in the string must be the same as the first letter of the key.\n           \
    \             local k = v[i]\n                        if k ~= prefix[1] then\n\
    \                            return false\n                        end\n     \
    \               end\n                    return true\n                end\n  \
    \          end\n        )\n        :values()\n        :flatten()\n        :filter(\n\
    \            function (v)\n                -- Remember that `nil` values should\
    \ be treated like empty tables.\n                if v then\n                 \
    \   -- `pairs` gives us the values as pairs of (key, value) pairs.\n         \
    \           for i = 1, #v do\n                        -- The first letter in the\
    \ key must be the same as the first letter in the prefix.\n                  \
    \      local k = v[i]\n                        if k ~= prefix[1] then\n      \
    \                      return false\n                        end\n           \
    \         end\n                    return true\n                end\n        \
    \    end\n        )\nend", "  local result = {}\n  for _, string in pairs(strings)\
    \ do\n    if string.startswith(prefix) then\n      result[#result + 1] = string\n\
    \    end\n  end\n  return result\nend", "    local result = {}\n    for _, string\
    \ in ipairs(strings) do\n        if string.starts(prefix) then\n            result[#result\
    \ + 1] = string\n        end\n    end\n    return result\nend", "  local result\
    \ = {}\n  for _, string in ipairs(strings) do\n    if string.starts(prefix) then\n\
    \      table.insert(result, string)\n    end\n  end\n  return result\nend", " \
    \   local prefix = prefix or ''\n    local result = {}\n    for k in pairs(strings)\
    \ do\n        if k:sub(1, #prefix) == prefix then\n            result[k] = strings[k]\n\
    \        end\n    end\n    return result\nend", "    local new = {}\n    for k,v\
    \ in pairs(strings) do\n        if k:sub(1,#prefix) == prefix then\n         \
    \   new[#new + 1] = v\n        end\n    end\n    return new\nend", "  if prefix\
    \ and prefix ~= '' then\n    local pattern = '^' .. prefix\n    local result =\
    \ {}\n    for _, value in pairs(strings) do\n      if string.match(pattern, value)\
    \ then\n        result[#result + 1] = value\n      end\n    end\n    return result\n\
    \  else\n    return {}\n  end\nend", "    local result = {}\n    for k in pairs(strings)\
    \ do\n        if k:sub(1, #prefix) == prefix then\n            result[k] = strings[k]\n\
    \        end\n    end\n    return result\nend", "  local result = {}\n  for _,\
    \ s in ipairs(strings) do\n    if string.sub(s, 1, #prefix) == prefix then\n \
    \     result[#result + 1] = s\n    end\n  end\n  return result\nend", "  local\
    \ result = {}\n  for _, value in ipairs(strings) do\n    if value:sub(1, #prefix)\
    \ == prefix then\n      result[#result + 1] = value\n    end\n  end\n  return\
    \ result\nend", "  local result = {}\n  for _, s in ipairs(strings) do\n    if\
    \ s:sub(1, #prefix) == prefix then\n      result[#result + 1] = s\n    end\n \
    \ end\n  return result\nend", "  local result = {}\n  for k, v in pairs(strings)\
    \ do\n    if k:sub(1, prefix:len()) == prefix then\n      table.insert(result,\
    \ v)\n    end\n  end\n  return result\nend", "  if prefix and not prefix ~= \"\
    \" then\n    local result = {}\n    for i = 1, #strings do\n      if strings[i]\
    \ and strings[i] ~= prefix then\n        result[#result + 1] = strings[i]\n  \
    \    end\n    end\n    return result\n  else\n    return strings\n  end\nend",
  "  local out = {}\n  for i = 1, #strings do\n    if strings[i] then\n      if string.sub(strings[i],\
    \ 1, #prefix) == prefix then\n        out[#out + 1] = strings[i]\n      end\n\
    \    end\n  end\n  return out\nend", "    local output = {}\n    for _, s in ipairs(strings)\
    \ do\n        if s:sub(1, #prefix) == prefix then\n            output[#output\
    \ + 1] = s\n        end\n    end\n    return output\nend", "  local filtered =\
    \ {}\n  for k, v in pairs(strings) do\n    if v:sub(1, #prefix) == prefix then\n\
    \      table.insert(filtered, v)\n    end\n  end\n  return filtered\nend", " \
    \   if type(prefix) ~= 'string' then\n        error('expected string for prefix')\n\
    \    end\n    local result = {}\n    local count = 0\n    for k,v in pairs(strings)\
    \ do\n        if v:sub(1,prefix:len()) == prefix then\n            result[#result\
    \ + 1] = v\n            count = count + 1\n        end\n    end\n    if count\
    \ == 0 then\n        result[#result+1] = {}\n    end\n    return result\nend",
  "  local result = {}\n  for key in pairs(strings) do\n    if key:sub(1, prefix:len())\
    \ == prefix then\n      table.insert(result, strings[key])\n    end\n  end\n \
    \ return result\nend", "   for k, v in pairs(strings) do\n      if string.sub(k,\
    \ 1, string.len(prefix)) == prefix then\n         return setmetatable(v, { __index\
    \ = setmetatable( v, { __ipairs = true } ) })\n      end\n   end\nend", "    local\
    \ result = {}\n    for k, v in pairs(strings) do\n        if k:sub(1, prefix:len())\
    \ == prefix then\n            result[k] = v\n        end\n    end\n    return\
    \ result\nend", "  local result = {}\n  for _, s in ipairs(strings) do\n    if\
    \ s:sub(1, #prefix) == prefix then\n      table.insert(result, s)\n    end\n \
    \ end\n  return result\nend", "  local result = {}\n  for _, value in ipairs(strings)\
    \ do\n    if string.sub(value, 1, string.len(prefix)) == prefix then\n      table.insert(result,\
    \ value)\n    end\n  end\n  return result\nend", "    if type(strings) ~= 'table'\
    \ then return strings end\n    if prefix ~= '' and prefix:len() <= 0 then return\
    \ strings end\n    local result = {}\n    for k, v in pairs(strings) do\n    \
    \    if type(v) ~= 'string' then continue end\n        if k:sub(1, prefix:len())\
    \ == prefix then\n            result[k] = v\n        end\n    end\n    return\
    \ result\nend", "  assert(type(strings) ~= 'table', 'string table expected')\n\
    \  assert(type(prefix) ~= 'string', 'prefix expected')\n  local result = {}\n\
    \  for key, value in pairs(strings) do\n    if string.sub(key, 1, string.len(prefix))\
    \ ~= prefix then\n      result[#result + 1] = value\n    end\n  end\n  return\
    \ result\nend", "  local result = {}\n  for _, s in ipairs(strings) do\n    if\
    \ s:sub(1, #prefix) == prefix then\n      result[#result +1] = s\n    end\n  end\n\
    \  return result\nend", "  -- If strings is an empty string, then prefix is empty.\n\
    \  if strings == '' or prefix == '' then return { } for return end", "    if type(prefix)\
    \ == 'string' then\n        prefix = prefix .. ''\n    end\n    local ret = {}\n\
    \    for key, value in pairs(strings) do\n        if key:sub(1, #prefix) == prefix\
    \ then\n            ret[key] = value\n        end\n    end\n    return ret\nend",
  "    if not prefix then\n        return strings\n    end\n    local result = {}\n\
    \    for k in pairs(strings) do\n        if k:sub(1, #prefix) == prefix then\n\
    \            table.insert(result, k)\n        end\n    end\n    return result\n\
    end", "  assert(type(strings) == 'table')\n  assert(type(prefix) == 'string')\n\
    \  local result = {}\n  for key, value in pairs(strings) do\n    if prefix ==\
    \ key:sub(1, #prefix) then\n      result[key] = value\n    end\n  end\n  return\
    \ result\nend", "  local ret = {}\n  local prefix_len = #prefix", "  local result\
    \ = {}\n  for i = 1, #strings do\n    if string.sub(prefix, 1, string.len(string.sub(string,\
    \ 1, #prefix))) == string.sub(string, 1, #prefix) then\n      result[#result +\
    \ 1] = strings[i]\n    end\n  end\n  return result\nend", "  local result = {}\n\
    \  for _, str in pairs(strings) do\n    if not str:sub(#prefix) == prefix then\
    \ break end\n    result[str] = true\n  end\n  return result\nend", "  local result\
    \ = {}\n  for k,v in pairs(strings) do\n    if v:sub(1, #prefix) == prefix then\n\
    \      table.insert(result, v)\n    end\n  end\n  return result\nend", "  assert(type(strings)\
    \ == 'table')\n  assert(type(prefix) == 'string')\n  local ret = {}\n  for i =\
    \ 1, #strings do\n    if strings[i] == prefix then\n      table.insert(ret, strings[i])\n\
    \    end\n  end\n  return ret\nend", "    local result = {}\n    for _, s in ipairs(strings)\
    \ do\n        if string.sub(s,1,prefix:len()) == prefix then\n            result[#result+1]\
    \ = s\n        end\n    end\n    return result\nend", "    local result = {}\n\
    \    for _, value in ipairs(strings) do\n        if string.sub(value, 1, prefix)\
    \ ~= prefix then\n            result[#result + 1] = value\n        end\n    end\n\
    \    return result\nend", "  -- If prefix is empty, reverse the order of the table\n\
    \  prefix = prefix and prefix or \"\"\n  \n  -- Get the length in characters of\
    \ the prefix\n  local prefix_len = #prefix\n  \n  -- Keep track of the indices\
    \ of strings starting with the prefix\n  local prefix_idxs = {} -- The indices\
    \ of the strings starting with the prefix\n  \n  -- Keep track of strings that\
    \ do not start with the prefix\n  local other_idxs = {} -- The indices of strings\
    \ NOT starting with the prefix\n  \n  -- For every string in the input table\n\
    \  for i = 1, #strings do\n    -- If the string does not start with the prefix\n\
    \    if strings[i] and strings[i][1] == prefix then\n      -- Keep track of the\
    \ index of the string starting with the prefix\n      prefix_idxs[i] = #prefix_idxs\n\
    \      \n      -- Append the string to the new set of strings\n      other_idxs[#other_idxs+1]\
    \ = i\n      \n      -- Remove the string from the input table\n      table.remove(strings,\
    \ i)\n      \n      -- If we removed the last string in the input table\n    \
    \  -- Reset the prefix index\n      if #strings == 1 then\n        prefix_idxs\
    \ = {}\n      end\n    else\n      -- If the string starts with the prefix\n \
    \     if prefix_idxs[#prefix_idxs+1] ~= 0 then\n        -- Remove the string from\
    \ the set of strings starting with the prefix\n        table.remove(strings, prefix_idxs[#prefix_idxs+1]-1)\n\
    \      end\n    end\n  end\n  \n  return other_idxs, prefix_idxs\nend", "    if\
    \ not prefix then return strings end\n    local result = {}\n    for _, string\
    \ in ipairs(strings) do\n        if string.startswith(prefix) then\n         \
    \   table.insert(result, string)\n        end\n    end\n    return result\nend",
  "  if prefix ~= '' then\n    strings = terralib.newlist()\n    local first_end =\
    \ 1\n    local last_end = 1\n    for i = 1, #strings do\n      if string.sub(strings[i],\
    \ 1, #prefix) == prefix then\n        if i == 1 then\n          first_end = 1\n\
    \        else\n          last_end = i - 1\n        end\n        strings:insert(strings[i])\n\
    \      end\n    end\n    return strings[first_end .. last_end]\n  else\n    return\
    \ strings\n  end\nend", "  local results = {}\n  for _, value in ipairs(strings)\
    \ do\n    if value:sub(1, #prefix) == prefix then\n      table.insert(results,\
    \ value)\n    end\n  end\n  return results\nend", "  prefix = prefix or ''\n \
    \ local filtered = {}\n  for _, string in ipairs(strings) do\n    string.start\
    \ = string.start or prefix\n    string.start = string.start:bytes()\n    string.start[string.start\
    \ ~= prefix] = nil\n    table.insert(filtered, string)\n  end\n  return filtered\n\
    end", "    local results = {}\n    for k, v in pairs(strings) do\n        if k:sub(1,\
    \ prefix:len()) == prefix then\n            results[k] = v\n        end\n    end\n\
    \    return results\nend", "  local filtered = {}\n  for ix, value in ipairs(strings)\
    \ do\n    if string.sub(value, 1, prefix) == prefix then\n      table.insert(filtered,\
    \ value)\n    end\n  end\n  return filtered\nend", "    if prefix == nil then\n\
    \        return strings\n    end", "  if prefix then prefix = prefix .. '.' end\n\
    \  local result = {}\n  for _, value in pairs(strings) do\n    if string.sub(value,\
    \ 1, string.len(prefix))==prefix then\n      table.insert(result, value)\n   \
    \ end\n  end\n  return result\nend", "  return table.filteri(function(x) return\
    \ string.sub(x, 1, string.len(prefix)) ~= prefix end, strings)\nend", "  if prefix\
    \ then\n    local result = {}\n    for _, string in ipairs(strings) do\n     \
    \ if string.sub(1, #prefix) == prefix then\n        table.insert(result, string)\n\
    \      end\n    end\n    return result -- A \"true\" empty table means that no\
    \ string in the original table started with prefix.\n  else\n    return strings\n\
    \  end\nend", "   assert(type(strings) == 'table')\n   assert(type(prefix) ==\
    \ 'string')\n   local filtered = {}\n   for i = 1, #strings do\n      if string.sub(strings,\
    \ i, i+#prefix) == prefix then\n         table.insert(filtered, strings[i])\n\
    \      end\n   end\n   return filtered\nend", "  local output = {}\n  for _, v\
    \ in pairs(strings) do\n    if v == prefix then\n      table.insert(output, v)\n\
    \    end\n  end\n  return output\nend", "    local new_strings = {}\n    for _,\
    \ str in pairs(strings) do\n        if str:sub(1, #prefix) == prefix then\n  \
    \          new_strings[#new_strings + 1] = str\n        end\n    end\n    return\
    \ new_strings\nend", "  local out = strings or {}\n  for k, v in pairs(strings)\
    \ do\n    if k:sub(1, prefix:len()) == prefix then\n      out[k] = v\n    end\n\
    \  end\n  return out\nend", "  local result = {}\n  for _, v in ipairs(strings)\
    \ do\n    if v:sub(1, #prefix) == prefix then\n      table.insert(result, v)\n\
    \    end\n  end\n  return result\nend", "  prefix = prefix or ''\n  local new_strings\
    \ = {}\n  for _, string in ipairs(strings) do\n    if string.startswith(prefix)\
    \ then\n      new_strings[#new_strings + 1]\n    end\n  end\n  if #new_strings\
    \ == 0 then\n    return {}\n  else\n    return new_strings\n  end\nend", "  local\
    \ prefix = prefix or ''\n  return setmetatable({[prefix .. '_']=1}, strings)\n\
    end", "  for k, v in pairs(strings) do\n    if k:sub(1, prefix:len()) == prefix\
    \ then\n      table.remove(strings, k)\n    end\n  end\n  return strings\nend",
  "  local table = {}\n  for _, str in pairs(strings) do\n    if str:sub(1, #prefix)\
    \ == prefix then\n      table.insert(table, str)\n    end\n  end\n  return table\n\
    end\n</code>\n<|/ a |>\n<| a tags=lua-table,lua,filter,string dscore=4 |>\nHere's\
    \ another function I wrote to do this which I thought I'd share.\n<code>", " \
    \   local result = {}\n    for i, v in pairs(strings) do\n        if v:sub(1,\
    \ #prefix) == prefix then\n            table.insert(result, v)\n        end\n\
    \    end\n    return result\nend", "  if prefix then\n    local prefix_lc = tostring(prefix):lower()\n\
    \    for _, string in pairs(strings) do\n      if string.starts and string.starts:lower():startswith(prefix_lc)\
    \ then\n        local key = tostring(strings[string])\n        table.insert(strings[key],\
    \ prefix)\n      end\n    end\n  end\n  return strings\nend", "    local new_strings\
    \ = {}\n    for _, string in ipairs(strings) do\n        if string.starts(prefix)\
    \ then\n            new_strings[#new_strings + 1] = string\n        end\n    end\n\
    \    return new_strings\nend", "\t-- This function is an implementation of Haskell's\
    \ \"filter\" for strings\n\tlocal filtered = {}\n\tfor _, string in ipairs(strings)\
    \ do\n\t\tif string.sub(1, prefix) == prefix then\n\t\t\ttable.insert(filtered,\
    \ string)\n\t\tend\n\tend\n\treturn filtered\nend", "   if prefix and prefix ~=\
    \ '' then\n      return setmetatable({}, {\n         __index = function(t, k)\n\
    \            local v = strings[k]\n            return v and (v:match('^' .. prefix\
    \ .. '(.+)') or nil)\n         end\n      })\n   end\n   return strings\nend",
  "  local result = {}\n  for key, value in pairs(strings) do\n    if string.sub(key,\
    \ 1, string.len(prefix)) = prefix then\n      table.insert(result, value)\n  \
    \  end\n  end\n  return result\nend", "    if prefix and prefix ~= '' then\n \
    \       local pattern = prefix .. '[^' .. prefix .. ']*'\n        local result\
    \ = {}\n        for _, string in ipairs(strings) do\n            table.insert(result,\
    \ string) -- Ignore non-matching strings\n            if string.match then\n \
    \               table.insert(result, string.match(pattern))\n            elseif\
    \ string.substr then\n                table.insert(result, string.sub(string,\
    \ 1, string.len(pattern)))\n            end\n        end\n        return result\n\
    \    else\n        return strings\n    end\nend", "    local result = {}\n   \
    \ for _, string in ipairs(strings) do\n        if string.find(prefix) then\n \
    \           result[#result + 1] = string\n        end\n    end\n    return result\n\
    end", "  local filtered = {}\n  for _, s in ipairs(strings) do\n    if s:sub(1,\
    \ #prefix) == prefix then\n      table.insert(filtered, s)\n    end\n  end\n \
    \ return filtered\nend", "    local filtered_strings = {}\n    for k, v in pairs(strings)\
    \ do\n        local kk = k\n        local i = 1\n        while kk ~= prefix ..\
    \ prefix .. tostring(k) do\n            i = i + 1\n            kk = prefix ..\
    \ prefix .. tostring(k)\n        end\n        if i == 1 then\n            filtered_strings[k]\
    \ = v\n        end\n    end\n    return filtered_strings\nend", "   local result\
    \ = {}\n   for key, value in pairs(strings) do\n      if key:sub(1, #prefix) ==\
    \ prefix then\n         table.insert(result, value)\n      end\n   end\n   return\
    \ result\nend", "  prefix = prefix:lower()\n  local result = {}\n  for i, str\
    \ in ipairs(strings) do\n    if str:sub(1, #prefix) == prefix then result[#result\
    \ + 1] = str end\n  end\n  return result\nend", "  local result = {}\n  for _,\
    \ string in pairs(strings) do\n    if string.startswith(prefix) then\n      result[#result\
    \ +1] = string\n    end\n  end\n  return result\nend", "  -- Create an empty output\
    \ table\n  local output_table = {}\n  for _, s in ipairs(strings) do\n    if string.sub(s,\
    \ 1, string.len(prefix)) == prefix then\n      table.insert(output_table, s)\n\
    \    end\n  end\n  return output_table\nend", "  if prefix then\n    local t =\
    \ {}\n    for _, s in ipairs(strings) do\n      if s:sub(1, #prefix) == prefix\
    \ then\n        t[#t + 1] = s\n      end\n    end\n    return t\n  end\n  return\
    \ strings\nend", "  local result = {}\n  for k, v in pairs(strings) do\n    if\
    \ k:sub(1, prefix:len()) == prefix then\n      table.insert(result, v)\n    end\n\
    \  end\n  return result\nend", "  local result = {}\n  for _, value in ipairs(strings)\
    \ do\n    if prefix == \"\" then\n      table.insert(result, value)\n    elseif\
    \ value and string.sub(value, 1, prefix) == prefix then\n      table.insert(result,\
    \ value)\n    end\n  end\n  return result\nend", "    local function match_prefix(item)\n\
    \        return item == prefix or item:sub(1, #prefix) == prefix and true or false\n\
    \    end\n    local function match_suffix(item)\n        return item == strings[#strings]\
    \ or item:sub(1, #strings) == strings[#strings] and true or false\n    end\n \
    \   return filter_by_predicate(strings, match_prefix, match_suffix)\nend", " \
    \   local prefix_len = #prefix\n    local res = {}\n    for _, str in pairs(strings)\
    \ do\n        if str:len() <= prefix_len then\n            res[str] = true\n \
    \       end\n    end\n    return res\nend", "  local result = {}\n  for _, value\
    \ in pairs(strings) do\n    if string.sub(value, 1, #prefix) == prefix then\n\
    \      table.insert(result, value)\n    end\n  end\n  return result\nend", " \
    \ local filtered_strings = {}\n  for i = 1, #strings do\n    if strings[i] ==\
    \ prefix then\n      filtered_strings[#filtered_strings + 1] = strings[i]\n  \
    \  end\n  end\n  return filtered_strings\nend", "  if prefix then return setmetatable({[prefix]\
    \ = true}, table) end\n  return strings\nend", "  local result = {}\n  for i =\
    \ 1, #strings do\n    if strings[i] == prefix then\n      table.insert(result,\
    \ strings[i])\n    end\n  end\n  return result\nend", "    if type(prefix) ~=\
    \ 'string' then\n        error('[filter_by_prefix] prefix must be a string')\n\
    \    end\n    local result = {}\n    local i = 0\n    for k, v in pairs(strings)\
    \ do\n        if k:sub(1, #prefix) == prefix then\n            result[i] = v\n\
    \            i = i + 1\n        end\n    end\n    if i == 0 then\n        return\
    \ result\n    end\n    for i = 1, i do\n        result[i] = nil\n    end\n   \
    \ return result\nend", "    local out = setmetatable({}, {\n        __index =\
    \ function(t, k) \n            if k ~= prefix then\n                return t[k]\n\
    \            end\n        end\n    })\n    for _, k in pairs(strings) do \n  \
    \      if k:sub(1, #prefix) == prefix then \n            out[k] = strings[k]\n\
    \        end\n    end\n    return out\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
