name: HumanEval_126_is_sorted
language: lua
prompt: "-- Given a table of numbers, return whether or not they are sorted\n-- in\
  \ ascending order. If table has more than 1 duplicate of the same\n-- number, return\
  \ false. Assume no negative numbers and only integers.\n-- Examples\n-- >>> is_sorted({5})\n\
  -- true\n-- >>> is_sorted({1, 2, 3, 4, 5})\n-- true\n-- >>> is_sorted({1, 3, 2,\
  \ 4, 5})\n-- false\n-- >>> is_sorted({1, 2, 3, 4, 5, 6})\n-- true\n-- >>> is_sorted({1,\
  \ 2, 3, 4, 5, 6, 7})\n-- true\n-- >>> is_sorted({1, 3, 2, 4, 5, 6, 7})\n-- false\n\
  -- >>> is_sorted({1, 2, 2, 3, 3, 4})\n-- true\n-- >>> is_sorted({1, 2, 2, 2, 3,\
  \ 4})\n-- false\nlocal function is_sorted(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_sorted\n\
  \    lu.assertEquals(candidate({5}), true)\n    lu.assertEquals(candidate({1, 2,\
  \ 3, 4, 5}), true)\n    lu.assertEquals(candidate({1, 3, 2, 4, 5}), false)\n   \
  \ lu.assertEquals(candidate({1, 2, 3, 4, 5, 6}), true)\n    lu.assertEquals(candidate({1,\
  \ 2, 3, 4, 5, 6, 7}), true)\n    lu.assertEquals(candidate({1, 3, 2, 4, 5, 6, 7}),\
  \ false)\n    lu.assertEquals(candidate({}), true)\n    lu.assertEquals(candidate({1}),\
  \ true)\n    lu.assertEquals(candidate({3, 2, 1}), false)\n    lu.assertEquals(candidate({1,\
  \ 2, 2, 2, 3, 4}), false)\n    lu.assertEquals(candidate({1, 2, 3, 3, 3, 4}), false)\n\
  \    lu.assertEquals(candidate({1, 2, 2, 3, 3, 4}), true)\n    lu.assertEquals(candidate({1,\
  \ 2, 3, 4}), true)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    -- Remove duplicates\n    local unique = {}\n    for i, v in ipairs(lst)\
    \ do\n        if v ~= unique[v] then\n            unique[v] = true\n        end\n\
    \    end\n    -- Check for ascending order\n    local is_sorted = true\n    for\
    \ i, v in ipairs(unique) do\n        if v ~= i + 1 then\n            is_sorted\
    \ = false\n            break\n        end\n    end\n    return is_sorted\nend",
  "  local num_unique = 1\n  local cur = lst[1]\n  for i = 2, #lst do\n    if lst[i]\
    \ ~= cur then\n      num_unique = num_unique + 1\n      if num_unique == 2 then\n\
    \        return false\n      else\n        cur = lst[i]\n      end\n    end\n\
    \  end\n  return true\nend", "  if #lst > 1 then\n    for i = 2, #lst do\n   \
    \   if lst[i] == lst[i - 1] + 1 then\n        return false\n      end\n    end\n\
    \  end\n  return true\nend", "  local last_value = lst[1]\n  local last_i = 2\n\
    \  local true = true\n  local false = false\n  for i = 2, #lst do\n    if lst[i]\
    \ ~= last_value then\n      if last_i == i then\n        return false\n      else\n\
    \        last_value = lst[i]\n        last_i = i\n        true = true\n      end\n\
    \    else\n      last_i = i + 1\n    end\n  end\n  return true\nend", "  local\
    \ size = #lst\n  if size == 1 then\n    local first = lst[1]\n    if first ~=\
    \ first then\n      return false\n    end\n  end\n  local last_val = lst[size\
    \ - 1]\n  for i = 2, size do\n    local current_val = lst[i]\n    if current_val\
    \ < last_val then\n      return false\n    end\n    last_val = current_val\n \
    \ end\n  return true\nend", "\tlocal table = getmetatable(lst)\n\tassert(table,\
    \ 'table must be passed as an argument to is_sorted')\n\tassert(type(table.__len__)\
    \ == 'function', 'table must be passed as an argument to is_sorted')\n\tlocal\
    \ sorted_count = 0\n\tfor k, v in pairs(lst) do\n\t\tif v ~= v or v == 0 then\n\
    \t\t\tsorted_count = sorted_count + 1\n\t\tend\n\tend\n\treturn sorted_count ==\
    \ table.__len__(lst)\nend", "   if #lst <= 1 then return true end\n   local last\
    \ = lst[1]\n   for _, v in pairs(lst) do\n      if v < last then return false\
    \ end\n      last = v\n   end\n   return true\nend", "  if #lst <= 1 then\n  \
    \  return true\n  end\n  local last, cnt = lst[1], 1\n  for i = 2, #lst do\n \
    \   local next = lst[i]\n    if next == last then\n      cnt = cnt + 1\n    else\n\
    \      if cnt > 1 then\n        return false\n      else\n        last = next\n\
    \        cnt = 1\n      end\n    end\n  end\n  return true\nend", "  local uniques\
    \ = {}\n  for i, v in ipairs(lst) do\n    if v in uniques then return false end\n\
    \    table.insert(uniques, v)\n  end\n  return true\nend", "  -- If list is empty,\
    \ then return true, since no elements are out of order.\n  -- This handles the\
    \ empty case.\n  if #lst == 0 then\n    return true\n  end", "  local sorted_flag\
    \ = nil\n  local uniques = {}\n  for i = 1, #lst do\n    local value = lst[i]\n\
    \    if value == sorted_flag then\n      return false\n    elseif value ~= sorted_flag\
    \ then\n      table.insert(uniques, value)\n      sorted_flag = value\n    end\n\
    \  end\n  for _, value in pairs(uniques) do\n    if value == sorted_flag then\n\
    \      return false\n    end\n  end\n  return true\nend", "  local function is_sorted(lst,\
    \ count)\n    if count == 0 then\n      return true\n    end\n    if count ==\
    \ 1 then\n      return list[count] == lst\n    end\n    local first = list[count\
    \ - 1]\n    for i = 1, count do\n      if list[i] ~= first then\n        return\
    \ false\n      end\n    end\n    return true\n  end", "  local count = {}\n  for\
    \ _, v in ipairs(lst) do\n    count = count[v] or 1\n  end\n  return #count ==\
    \ 1\nend", "    if lst:len() ~= 1 then\n        return false\n    end\n    local\
    \ value = lst[1]\n    for _, val in pairs(lst) do\n        if val == value then\n\
    \            return false\n        end\n    end\n    return true\nend", "  local\
    \ count = 1\n  for _, v in pairs(lst) do\n    if count > 1 then\n      return\
    \ false\n    end\n    if v == lst.first then\n      count = count + 1\n    end\n\
    \  end\n  return true\nend", "  -- Sort unique and remove duplicates.\n  local\
    \ num_list = lst:sorted()\n  local num_set = {}\n  num_list:foreach(\n    function(number)\n\
    \      num_set[number] = true\n    end)\n  -- Check for each number in the list\
    \ if it occurs more than once.\n  -- If so, they need to be in increasing order.\n\
    \  for i = 1, #num_list do\n    if num_set[i] then\n      -- Found duplicate,\
    \ check if next number is greater.\n      if i > 1 then\n        if num_list[i]\
    \ ~= num_list[i - 1] + 1 then\n          return false\n        else\n        \
    \  -- Found first duplicate, check if previous number is greater.\n          if\
    \ num_list[i] ~= num_list[i - 1] - 1 then\n            return false\n        \
    \  else\n            -- No duplicates, in increasing order.\n            return\
    \ true\n          end\n        end\n      else\n        -- No duplicates, in increasing\
    \ order.\n        return true\n      end\n    end\n  end\n  return false\nend",
  "  -- Check for empty list\n  if #lst == 0 then\n    return true\n  elseif #lst\
    \ == 1 then\n    return lst.head <= lst.head\n  end", "  local prev = {nil}\n\
    \  local curr = {}\n  for _, v in pairs(lst) do\n    if not prev[v] then\n   \
    \   table.insert(curr, v)\n      prev[v] = true\n    else\n      return false\n\
    \    end\n  end\n  local len = #curr\n  if len > 1 then\n    return false\n  end\n\
    \  for _, v in pairs(prev) do\n    if prev[v] == curr[len - 1] then\n      return\
    \ false\n    end\n  end\n  return true\nend", "  local tbl = {}\n  for _, v in\
    \ ipairs(lst) do\n    tbl[v] = true\n  end\n  -- Table is now sorted, so there\
    \ are no\n  -- duplicates. Otherwise, there are duplicates\n  -- that are sorted.\n\
    \  -- return #tbl < #lst\n  return not setmetatable(tbl, getmetatable(lst)).__len\n\
    end", "  if #lst < 2 then\n    return true\n  else\n    local last = lst[1]\n\
    \    for i=2,#lst do\n      if lst[i] ~= last then\n        return false\n   \
    \   end\n    end\n    return true\n  end\nend", "    for _, v in ipairs(lst) do\n\
    \        if v == lst[#lst] then\n            return false\n        end\n    end\n\
    \    return true\nend", "  assert(type(lst) == \"table\")\n  local t = {}\n  for\
    \ _, el in ipairs(lst) do\n    table.insert(t, el)\n  end\n  table.sort(t)\n \
    \ for i = 1, #t do\n    if t[i] ~= t[i - 1] then\n      return false\n    end\n\
    \  end\n  return true\nend", "  -- Check that the input is a table\n  if type(lst)\
    \ ~= 'table' then\n    return false\n  end\n  -- Check that there are unique numbers\
    \ in the list\n  local unique_numbers = {}\n  for i = 1, #lst do\n    local val\
    \ = lst[i]\n    if unique_numbers[val] == nil then\n      unique_numbers[val]\
    \ = true\n    end\n  end\n  -- Check that there are no duplicates\n  if #unique_numbers\
    \ > 1 then\n    return false\n  end\n  -- Check that there are no negative numbers\n\
    \  if type(lst[1]) ~= 'number' then\n    return false\n  end\n  -- Check if the\
    \ numbers are in ascending order\n  -- This should return false if all numbers\
    \ are equal.\n  local first_value = lst[1]\n  for i = 2, #lst do\n    if lst[i]\
    \ < first_value then\n      return false\n    end\n  end\n  return true\nend",
  "  -- We use table.sort here to handle duplicates as follows:\n  -- Given {1, 2,\
    \ 2, 2, 3} we get {1, 2, 2, 3} and we only want {1, 2, 3}\n  -- Thus, we first\
    \ sort the list and then compare it with itself as a set.\n  return table.issorted(lst)\
    \ == table.issorted(table.sort(lst))\nend", "  -- The first two entries must be\
    \ the same\n  if lst[1] and lst[2] then\n    if lst[1] == lst[2] then\n      --\
    \ If all entries are the same, all must be increasing\n      -- This would give\
    \ us an invalid array if all entries were equal\n      return true\n    end\n\
    \    -- If we got here, at least one entry is not increasing\n    return false\n\
    \  end", "  return lst.sorted and #lst <= 1 and lst[1] < lst[2] and #lst < 100000\
    \ -- ~200\u03BCs improvement for list of length < 10,000\nend", "  local last_value\
    \ = lst[1]\n  for _, val in pairs(lst) do\n    if val == last_value then\n   \
    \   return false\n    end\n    last_value = val\n  end\n  return true\nend", " \
    \   if #lst == 1 then\n        return lst[1] == lst[1]\n    end\n    local i =\
    \ 1\n    for i = 2, #lst do\n        if lst[i - 1] > lst[i] then\n           \
    \ return false\n        end\n    end\n    return true\nend", "  local num_entries\
    \ = #lst\n  if num_entries == 1 then\n    return lst[1] == lst[1]\n  else\n  \
    \  local first_value = lst[1]\n    local is_first_value_greater = false\n    for\
    \ i = 2, num_entries do\n      local current_value = lst[i]\n      if current_value\
    \ > first_value then\n        return false\n      elseif current_value == first_value\
    \ then\n        is_first_value_greater = true\n      else\n        return is_first_value_greater\n\
    \      end\n    end\n    return is_first_value_greater\n  end\nend", "  -- O(n)\
    \ time\n  -- O(1) space\n  if #lst < 1 then return true end\n  local first, last\
    \ = lst[1], lst[#lst]\n  for i = 2, #lst do\n    if lst[i] ~= first then return\
    \ false end\n  end\n  return true\nend", "  local size = #lst\n  if size <= 1\
    \ then return true end\n  for i = 1, size do\n    local j = size - 1\n    repeat\
    \ until j > i do\n      if lst[i] > lst[j] then\n        return false\n      end\n\
    \      if lst[i] == lst[j] then\n        j = j - 1\n      else\n        i = i\
    \ + 1\n      end\n    end\n  end\n  return true\nend", "  for _, val in ipairs(lst)\
    \ do\n    if val == lst[#lst] then return false end\n  end\n  return true\nend",
  "    local last_value = lst[1]\n    for _, value in ipairs(lst) do\n        if last_value\
    \ < value then return false end\n        last_value = value\n    end\n    return\
    \ true\nend", "  -- Return true if the list is already sorted.\n  if #lst ~= 1\
    \ then\n    local last = lst[1]\n    for _, elem in pairs(lst) do\n      if elem\
    \ ~= last then\n        return false\n      end\n    end\n    return true\n  end",
  "  -- TODO: Sort out duplicate numbers\n  for i = 1, #lst do\n    if lst[i] ~= lst[i\
    \ - 1] then return false end\n  end\n  return true\nend", "    local i = 1\n \
    \   while i <= #lst do\n        if lst[i] == lst[i-1] then\n            i = i\
    \ + 1\n        else\n            return false\n        end\n    end\n    return\
    \ true\nend", "    if lst.__len__() > 1 then\n        local first, last = unpack(lst)\n\
    \        for i = first+1, last do\n            if lst:find(i) == nil then\n  \
    \              return false\n            end\n        end\n        return true\n\
    \    end\n    return lst.__len__() ~= 1\nend", "  if #lst == 0 then return true\
    \ end\n  local i, last = 1, lst[1]\n  for i = 2, #lst do\n    if lst[i] ~= last\
    \ then\n      return false\n    end\n    last = lst[i]\n  end\n  return true\n\
    end", "  local cnt\n  if #lst == 1 then\n    return true\n  end\n  cnt = 1\n \
    \ -- Go through each unique element in the list\n  for i = 1, #lst do\n    local\
    \ found = false\n    -- Loop through the list again\n    for j=i, #lst do\n  \
    \    -- If the element is the same, continue\n      if lst[j] == lst[i] then\n\
    \        found = true\n      -- If the element is the same and count is greater,\
    \ break\n      elseif lst[j] == lst[i] and cnt > 1 then\n        cnt = cnt-1\n\
    \        found = true\n      end\n    end\n    -- If the element was not found,\
    \ break out of the loop and return false\n    if not found then break end\n  end\n\
    \  return cnt == 0\nend", "    local i, count = 1, 0\n    for i, v in ipairs(lst)\
    \ do\n        if v == lst[i] then\n            count = count + 1\n        else\n\
    \            return false\n        end\n    end\n    return count == 1\nend",
  "   local sorted = true\n   for _, num in ipairs(lst) do\n      if num > 1 then\
    \ sorted = false end\n   end\n   return sorted\nend", "  -- Return true if there\
    \ are duplicates and each one appears once or less\n  -- (by virtue of the fact\
    \ that dictionaries have no duplicates).\n  if #lst > 1 then\n    return false\n\
    \  elseif #lst == 1 then\n    -- If there are only 1 unique item, we can sort\
    \ it with no duplicates\n    -- and the item is guaranteed to be in the correct\
    \ order.\n    return true\n  else\n    -- Otherwise, return false if the set is\
    \ empty.\n    return #lst == 0\n  end\nend", "  return #lst <= 1 or not lst[1]\n\
    end", "  -- If table is empty, assume ascending order.\n  if not lst:len() then\
    \ return true end", "  if #lst == 0 then return true end\n  local last = lst[1]\n\
    \  for i = 2, #lst do\n    if lst[i] ~= last then\n      return false\n    end\n\
    \    last = lst[i]\n  end\n  return true\nend", "  if #lst <= 1 then\n    return\
    \ true\n  end\n  for idx = 1, #lst do\n    if lst[idx] == lst[idx - 1] then\n\
    \      if not idx == 1 then\n        return false\n      else\n        break --\
    \ return false if more than one duplicate\n      end\n    end\n  end\n  return\
    \ true\nend", "  local count = {}\n  for _, v in ipairs(lst) do count[v] = count[v]\
    \ + 1 end\n  for k, v in pairs(count) do\n    if v > 1 then return false end\n\
    \  end\n  return true\nend", "  -- Don't do anything if already sorted.\n  if\
    \ #lst > 1 and next(lst, 1) == lst[1] then\n    return false\n  end", "  local\
    \ result = true\n  for _, value in ipairs(lst) do\n    if value < lst[_ + 1] then\n\
    \      result = false\n      break\n    end\n  end\n  return result\nend", " \
    \  local unique = {}\n   local sorted = {}\n   for _, v in pairs(lst) do\n   \
    \   if unique[v] ~= nil then\n         return false\n      else\n         unique[v]\
    \ = true\n         sorted[v] = true\n      end\n   end\n   return true\nend",
  "    local last_val = lst[1]\n    for i = 2, #lst do\n        if last_val == lst[i]\
    \ then\n            return false\n        end\n        last_val = lst[i]\n   \
    \ end\n    return true\nend", "  -- Check only for integers\n  if type(lst) ==\
    \ 'number' then\n    return true\n  end\n  for i=1,#lst do\n    -- Check duplicate\
    \ number\n    if lst[i] == lst[i-1] then\n      return false\n    end\n  end\n\
    \  return true\nend", "  for i = 1, #lst do\n    if lst[i] ~= lst[i - 1] then\n\
    \      return false\n    end\n  end\n  return true\nend", "  -- Check for single\
    \ number\n  if #lst == 1 then\n    local value = lst[1]\n    return value == 1\
    \ or value < 0\n  end\n  -- Check for unique number\n  for i = 2, #lst do\n  \
    \  local value = lst[i]\n    if value == 1 then return false end\n    if value\
    \ == value and i ~= #lst then return false end\n  end\n  return true\nend", " \
    \ local is_sorted = true\n  for i, v in ipairs(lst) do\n    for _, v2 in ipairs(lst)\
    \ do\n      if v == v2 and i > 0 then\n        return false\n      end\n    end\n\
    \    if not is_sorted then break end\n  end\n  return is_sorted\nend", "  -- check\
    \ if all elements are the same (faster than a table lookup)\n  for _, v in ipairs(lst)\
    \ do\n    if v == lst[#lst] then return false end\n  end\n  -- check if the list\
    \ is sorted\n  return #lst == 1 and lst[1] == lst[#lst] and lst[1] >= 0\nend",
  "  local len = #lst\n  if len < 2 then\n    return true\n  end\n  -- Only check\
    \ up to the second to last element to avoid unnecessary sorting.\n  for i = 1,\
    \ len - 2 do\n    if lst[i] == lst[i+1] then\n      return false\n    end\n  end\n\
    \  return true\nend", "  return lst:nsort()\nend", "  local last = lst[1]\n  for\
    \ i=2,#lst do\n    if lst[i] ~= last then return false end\n    last = lst[i]\n\
    \  end\n  return true\nend", "  local last_elem = lst[1]\n  for i = 2, #lst do\n\
    \    if lst[i] ~= last_elem then\n      return false\n    end\n    last_elem =\
    \ lst[i]\n  end\n  return true\nend", "  if #lst == 0 then\n    return true\n\
    \  elseif #lst == 1 then\n    return lst[1] == lst[1]\n  else\n    local last\
    \ = lst[1]\n    for i = 2, #lst do\n      if lst[i] ~= last then\n        return\
    \ false\n      end\n      last = lst[i]\n    end\n    return true\n  end\nend",
  "  local sorted = {}\n  local i = 1\n  for _, v in ipairs(lst) do\n    if sorted[i]\
    \ == v then\n      return false\n    end\n    table.insert(sorted, v)\n    i =\
    \ i + 1\n  end\n  return true\nend", "  -- If table is empty or table has one\
    \ duplicate of itself, return true\n  if #lst == 0 then\n    return true\n  elseif\
    \ #lst == 1 then\n    return lst.data == lst[1]\n  else\n    -- If table has more\
    \ than one duplicate of itself, return false\n    for _, v in ipairs(lst) do\n\
    \      if v == lst[1] then\n        return false\n      end\n    end\n  end",
  "  -- Return true if all numbers in lst are unique\n  return lst:len() == (lst:distinct(true):len()\
    \ - 1)\nend", "    return #lst > 0 and #lst == 1 or not is_sorted(setmetatable(lst,\n\
    \        getmetatable(lst))[#lst])\nend", "  -- Find the first number in the list.\n\
    \  local value = nil\n  for i=1,#lst do\n    if value and value < lst[i] then\n\
    \      return false\n    end\n    value = lst[i]\n  end\n  return true\nend",
  "  if #lst == 1 then\n    return is_sorted({lst[1]})\n  end\n  local last = lst[1]\n\
    \  local sorted = {}\n  for i = 2, #lst do\n    if lst[i] ~= last then\n     \
    \ table.insert(sorted, last)\n    end\n    last = lst[i]\n  end\n  table.insert(sorted,\
    \ last)\n  for i = 2, #sorted do\n    if sorted[i] ~= sorted[i-1] then\n     \
    \ return false\n    end\n  end\n  return true\nend", "  -- Return false if there\
    \ are duplicates or if table has too many elements.\n  if #lst == 1 then return\
    \ true end", "  local last_value = lst[1]\n  for i = 2, #lst do\n    if lst[i]\
    \ ~= last_value then\n      return false\n    end\n    last_value = lst[i]\n \
    \ end\n  return true\nend", "  local unique_nums = {}\n  local num_dups = 0",
  "  for i, ele in pairs(lst) do\n    if ele ~= lst[i + (#lst - 1)] then\n      return\
    \ false\n    end\n  end\n  return true\nend", "  local last_seen = {}\n  for i\
    \ = 1, #lst do\n    last_seen[lst[i]] = true\n  end\n  for i = 1, #last_seen do\n\
    \    if #last_seen == i then return false end\n  end\n  return true\nend", " \
    \ assert(type(lst) == \"table\")\n  -- Check if the first number in the table\
    \ is unique and if it is not,\n  -- then return false to indicate that the list\
    \ is not in ascending order.\n  if #lst == 1 then\n    local first = lst[1]\n\
    \    if first ~= first then\n      return false\n    end\n  end\n  -- Sort the\
    \ list using merge sort\n  -- We start with the smallest number in the list\n\
    \  -- We then take each subsequent number and compare it to the smallest \n  --\
    \ in the list \n  local min_index = 1\n  local first_number = lst[min_index]\n\
    \  -- Compare each subsequent number to the smallest number in the list\n  for\
    \ i = min_index + 1, #lst, 1 do\n    -- If this number is greater than or equal\
    \ to the smallest number,\n    -- then we can swap the two numbers we are comparing\n\
    \    if lst[i] > first_number then\n      local tmp1 = first_number\n      first_number\
    \ = lst[i]\n      lst[i] = tmp1\n    end\n  end\n  return true\nend", "  -- The\
    \ set is sorted.\n  if #lst == 1 then\n    return true\n  end", "  local len =\
    \ #lst\n  if len == 0 then\n    return true\n  end\n  local sorted = {}\n  local\
    \ j = 1\n  local key\n  for i = 1, len do\n    key = lst[i]\n    j = j - 1\n \
    \   while j > 0 and not sorted[j] and (key == lst[j]) do\n      j = j - 1\n  \
    \  end\n    if j > 0 then\n      sorted[j] = true\n    end\n  end\n  local is_sorted\
    \ = true\n  for i = 1, len do\n    if sorted[i] then\n      is_sorted = false\n\
    \    end\n  end\n  return is_sorted\nend", "  local last_num = lst[1]\n  local\
    \ last_pos = 1\n  local sorted_ascending = 0\n  for _, num in ipairs(lst) do\n\
    \    if num == last_num then\n      last_pos = last_pos + 1\n    elseif num >\
    \ last_num then\n      return sorted_ascending\n    end\n    last_num = num\n\
    \  end\n  return sorted_ascending\nend", "    local last_val = next(lst)\n   \
    \ for v in lst:gmatch(\"%d*\") do\n        if last_val == v then\n           \
    \ return false\n        end\n        last_val = v\n    end\n    return true\n\
    end", "  local tbl = {}\n  for i, v in ipairs(lst) do tbl[v] = i end\n  local\
    \ nums = tbl.values()\n  table.sort(nums)\n  for _, v in ipairs(nums) do tbl[v]\
    \ = nil end\n  return #tbl == 0\nend", "  local i = 1\n  while i <= #lst do\n\
    \    local _, prev_value = unpack(lst:sub(1, i - 1))\n    local _, next_value\
    \ = unpack(lst:sub(i, #lst))\n    if prev_value == next_value then\n      return\
    \ false\n    end\n    i = i + 1\n  end\n  return true\nend", "    if #lst == 0\
    \ then\n        return true\n    end\n    local i = 1\n    while i <= #lst and\
    \ lst[i] == lst[#lst] do\n        i = i + 1\n    end\n    return i == #lst\nend",
  "    local last = -math.huge\n    for _, v in ipairs(lst) do\n        if last <\
    \ v then\n            return false\n        end\n        last = v\n    end\n \
    \   return true\nend", "  for _, value in ipairs(lst) do\n    if value == value\
    \ then\n      return false\n    end\n  end\n  return true\nend", "    local sorted\
    \ = true\n    local last_val = lst[1]\n    for i = 2, #lst do\n        if lst[i]\
    \ ~= last_val then\n            sorted = false\n        end\n        last_val\
    \ = lst[i]\n    end\n    return sorted\nend", "  local sorted_count = 1\n  local\
    \ next_key = nil\n  local last_key = nil\n  for _, key in ipairs(lst) do\n   \
    \ if sorted_count > 1 then\n      if key ~= last_key then\n        return false\n\
    \      end\n      sorted_count = sorted_count + 1\n    elseif key ~= next_key\
    \ then\n      sorted_count = sorted_count + 1\n      last_key = key\n      next_key\
    \ = key\n    else\n      return false\n    end\n  end\n  return true\nend", " \
    \   -- If table has no duplicates, it is sorted\n    if #lst ~= #unique(lst, function(a)\
    \ return a end) then\n        return true\n    end\n    -- If table has exactly\
    \ 1 duplicate, it is sorted\n    if #unique(lst, function(a) return a end) ==\
    \ 1 then\n        return true\n    end\n    -- If table is less than 2 elements,\
    \ it is not sorted\n    if #lst < 2 then\n        return false\n    end\n    --\
    \ Check each number for ascending\n    for _, number in ipairs(lst) do\n     \
    \   -- If all numbers are the same, return false\n        if number == lst[#lst]\
    \ then\n            return false\n        end\n    end\n    -- If we've made it\
    \ this far, return true\n    return true\nend", "\tlocal _, i = 1\n\twhile i <\
    \ #lst and lst[i] == lst[i - 1] + 1 do\n\t\ti = i + 1\n\tend\n\treturn i == #lst\n\
    end", "  assert(type(lst) == \"table\")\n  if #lst == 1 then\n    return true\n\
    \  end\n  for i = 2, #lst do\n    if lst[i] ~= lst[i-1] then\n      return false\n\
    \    end\n  end\n  return true\nend", "    local first = true\n    local count\
    \ = #lst\n    for _, v in ipairs(lst) do\n        if first then\n            first\
    \ = false\n        elseif v == lst[count] then\n            count = count - 1\n\
    \        else\n            return false\n        end\n    end\n    return true\n\
    end", "   local map = {}\n   for i, v in ipairs(lst) do map[v] = true end\n  \
    \ local l = #lst\n   if l == 0 then return true end\n   if l == 1 then return\
    \ map[lst[1]] end\n   -- More than 1 unique number, must be in wrong order\n \
    \  if l == 2 then\n      if map[lst[1]] then return false end\n      if map[lst[2]]\
    \ then return false end\n   end\n   -- At least 2 unique numbers, must be in right\
    \ order\n   if l > 2 then\n      local t = {}\n      for k, v in pairs(map) do\n\
    \         if v then t[k] = v end\n      end\n      if t[1] == t[2] then return\
    \ false end\n   end\n   return true\nend", "  for idx, num in ipairs(lst) do\n\
    \    if idx > 1 then\n      if lst[idx] == num then\n        return false\n  \
    \    else\n        local tmp = lst[idx]\n        lst[idx] = num\n        return\
    \ true\n      end\n    end\n  end\n  return true\nend", "    local last\n    for\
    \ i, v in ipairs(lst) do\n        if i > 0 then\n            if last < v then\n\
    \                return false\n            end\n        end\n        last = v\n\
    \    end\n    return true\nend", "  local size = #lst\n  local n = size - 1\n\
    \  local is_sorted = true\n  local keys = {}\n  for i = 1, n do\n    table.insert(keys,\
    \ lst[i])\n  end\n  for i = 2, n do\n    if keys[i] ~= keys[i - 1] and lst[i]\
    \ > lst[i - 1] then\n      is_sorted = false\n    end\n  end\n  return is_sorted\n\
    end", "   local map = {}\n   for _, v in pairs(lst) do\n      local c = map[v]\n\
    \      if c ~= nil then\n         return false\n      else\n         map[v] =\
    \ true\n      end\n   end\n   return true\nend", "  local sorted = true\n  local\
    \ last_value = nil\n  for i = 1, #lst do\n    if lst[i] ~= last_value then\n \
    \     sorted = false\n    end\n    last_value = lst[i]\n  end\n  return sorted\n\
    end", "  -- This solution takes O(n) time where n is the number of elements. If\n\
    \  -- you need a faster sort, you can use this method instead of the more general\n\
    \  -- is_sorted_iterative.\n  -- https://www.lua.org/pil/9.3.html\n  -- http://www.cs.helsinki.fi/group/goa/mallinnus/amoo.pdf\n\
    \  if #lst == 0 then return true end\n  if #lst == 1 then return false end\n \
    \ if lst[1] == lst[1] then return true end\n  if lst[1] ~= lst[2] then return\
    \ false end", "  if #lst == 0 then return true end\n  for i = 1, #lst do\n   \
    \ if lst[i - 1] == lst[i] then return false end\n  end\n  return true\nend", " \
    \ return #lst == 1 and lst[1] < lst[2] or #lst == 2 and lst[1] < lst[2] and lst[1]\
    \ < lst[3]\nend", "   if #lst == 0 then\n      return true\n   end\n   local last\
    \ = lst[#lst]\n   for i, v in ipairs(lst) do\n      if v == last then\n      \
    \   return false\n      end\n      last = v\n   end\n   return true\nend", " \
    \  if #lst == 1 then\n      return (lst[1] == lst[1]) or true\n   else\n     \
    \ local last = lst[1]\n      for i = 2, #lst do\n         if lst[i] ~= last then\n\
    \            return (last ~= last) or false\n         end\n         last = lst[i]\n\
    \      end\n      return true\n   end\nend", "    local num_unique = 0\n    local\
    \ i = 0\n    while i < #lst do\n        if lst[i] == lst[i - 1] then\n       \
    \     num_unique = num_unique + 1\n        elseif num_unique > 1 then\n      \
    \      return false\n        end\n        i = i + 1\n    end\n    return num_unique\
    \ <= 1\nend", "    local _, count = table.sort(lst)\n    return count == 1\nend",
  "\tlocal prev\n\tfor _, item in ipairs(lst) do\n\t\tif item ~= prev then\n\t\t\t\
    prev = item\n\t\t\treturn false\n\t\telse\n\t\t\treturn true\n\t\tend\n\tend\n\
    \treturn true\nend", "   -- Find the number of times a number appears in the list.\n\
    \   local function count_duplicates(lst)\n      local n = 0\n      for _, v in\
    \ ipairs(lst) do\n         n = n + 1\n      end\n      return n\n   end", "  --\
    \ First, check if there are any duplicates\n  for i, v in ipairs(lst) do\n   \
    \ -- If there are more than 1 duplicate, return false\n    if i ~= v and #lst[i\
    \ - 1] = #lst[v] then\n      return false\n    end\n  end\n  -- If we make it\
    \ all the way through without returning false, they are sorted\n  return true\n\
    end", "  -- First check if there is more than one number repeating in the list\n\
    \  -- If so, return false\n  local count_repeated_number = {}\n  for i=1,#lst\
    \ do\n    count_repeated_number[lst[i]] = count_repeated_number[lst[i]] + 1 or\
    \ 1\n  end\n  if #count_repeated_number > 1 then\n    return false\n  end", " \
    \  local i = 1\n   local n = #lst\n   while i <= n do\n      if lst[i] == lst[i-1]\
    \ then\n         return false\n      end\n      i = i + 1\n   end\n   return true\n\
    end", "  assert(#lst == 1)\n  local value = lst[1]\n  for i = 2, #lst do\n   \
    \ if lst[i] ~= value then return false end\n  end\n  return true\nend", "  --\
    \ if there are too many duplicates, we can't sort it\n  if #lst < 2 then\n   \
    \ return true\n  end\n  -- if we have 1 unique number, then it's sorted\n  if\
    \ #lst == 1 then\n    return true\n  end\n  -- find where the number would go\
    \ if we sorted it\n  local index = #lst\n  local last = lst[index] -- keep track\
    \ of last value\n  while true do\n    index = index - 1\n    if index < 0 then\
    \ return false end\n    if lst[index] == last then return true end\n    last =\
    \ lst[index]\n  end\nend", "    local i = 1\n    local last = lst[i]\n    for\
    \ i = 1, #lst do\n        if last == lst[i] then\n            return false\n \
    \       end\n        last = lst[i]\n    end\n    return true\nend", "\tlocal sorted\
    \ = true\n\tlocal last_key = nil\n\tlocal num_dups = 0\n\tlocal last_val = nil\n\
    \tfor _, v in pairs(lst) do\n\t\tif v == last_val then\n\t\t\tnum_dups = num_dups\
    \ + 1\n\t\telseif v == last_key then\n\t\t\tsorted = false\n\t\telse\n\t\t\tlast_val\
    \ = v\n\t\t\tlast_key = v\n\t\t\tnum_dups = 1\n\t\tend\n\tend\n\tif num_dups >\
    \ 1 then\n\t\treturn false\n\tend\n\treturn sorted\nend", "  return #lst == 1\
    \ then\n    lst[1] == lst[2]\n  else\n    -- count the number of duplicate items\n\
    \    local cnt = {}\n    local i = 1\n    while i <= #lst do\n      cnt.[lst[i]]\
    \ = cnt.[lst[i]] + 1 or 1\n      i = i + 1\n    end", "    local seen = {}\n \
    \   for i=1,#lst do\n        if seen[lst[i]] == true then\n            return\
    \ false\n        else\n            seen[lst[i]] = true\n        end\n    end\n\
    \    return true\nend", "    local sorted = {}\n    for _, num in ipairs(lst)\
    \ do\n        sorted[num] = true\n    end\n    return table.sort(sorted) == sorted\n\
    end", "  local sorted = {}\n  for _, v in pairs(lst) do\n    for i = 1, #sorted\
    \ do\n      if sorted[i] == v then\n        return false\n      end\n    end\n\
    \    table.insert(sorted, v)\n  end\n  return true\nend", "  -- This algorithm\
    \ is similar to bubble sort, except that it keeps track of\n  -- whether it has\
    \ sorted a duplicate or not.\n  local last_element = lst[1]\n  local first_element\
    \ = lst[1]\n  local sorted = true\n  for i = 2, #lst do\n    local element = lst[i]\n\
    \    if element ~= last_element then\n      sorted = false\n      break\n    end\n\
    \    last_element = element\n  end\n  return sorted and #lst > 1\nend", "  --\
    \ Check for one element only\n  if #lst == 1 then\n    return not is_sorted(lst:subarray(1))\n\
    \  end", "  local counts = {}\n  for _, value in ipairs(lst) do\n    counts[value]\
    \ = counts[value] or 0\n    counts[value] = counts[value] + 1\n  end\n  return\
    \ counts[first(lst)] > 1\nend", "  assert(type(lst) == 'table')\n  -- TODO: Remove\
    \ this once we switch to `setmetatable`\n  -- assert(type(tset) == 'table')",
  "  local i = 1\n  local last\n  while i <= #lst and last ~= lst.[i] do\n    last\
    \ = lst.[i]\n    i = i + 1\n  end\n  -- This should be impossible\n  assert(i\
    \ == #lst)\n  return last < lst.[1]\nend", "  for i = 2, #lst do\n    if lst[i]\
    \ ~= lst[i - 1] or not is_number(lst[i]) then return false end\n  end\n  return\
    \ true\nend", "\tlocal len = #lst\n\tlocal sorted = {}\n\tfor i = 1, len do\n\t\
    \tlocal value = lst[i]\n\t\tfor j = i + 1, len do\n\t\t\tif value < lst[j] then\n\
    \t\t\t\treturn false\n\t\t\tend\n\t\tend\n\t\tif table.contains(sorted, value)\
    \ then\n\t\t\treturn false\n\t\tend\n\t\ttable.insert(sorted, value)\n\tend\n\t\
    return true\nend", "    local last, sorted = {}, {}\n    for k in pairs(lst) do\n\
    \        if last[k] == k then\n            return false\n        end\n       \
    \ last[k] = k\n        sorted[k] = k\n    end\n    for k = 2, #lst do\n      \
    \  if sorted[k] == sorted[k - 1] then\n            return false\n        end\n\
    \    end\n    return true\nend", "  return type(lst) == \"table\" and #lst >=\
    \ 1 and #lst == sort(lst):len(lst)\nend", "  for k, v in ipairs(lst) do\n    if\
    \ v < k then return false end\n  end\n  return true\nend", "  return #lst == 1\
    \ and lst[1] < lst[#lst]\nend", "  for _, v in ipairs(lst) do\n    if v ~= math.floor(v)\
    \ then return false end\n  end\n  return true\nend", "  local nums = {}\n  local\
    \ i = 1\n  for v in lst do\n    local n = nums[v]\n    if n == nil then\n    \
    \  n = 1\n      nums[v] = n\n    else\n      n = n + 1\n    end\n  end\n  for\
    \ k, v in pairs(nums) do\n    if v == 1 or v == 2 then\n      return false\n \
    \   end\n  end\n  return true\nend", "  local i = 0\n  while i <= #lst do\n  \
    \  if lst[i] ~= lst[i - 1] + 1 then\n      return false\n    end\n    i = i +\
    \ 1\n  end\n  return true\nend", "  local last_num = 0\n  local sorted = true",
  "  -- If there are any duplicate numbers, return false\n  -- This should be optimized\
    \ if there are\n  -- too many duplicates.\n  return not table_length(lst) or table_length(lst)\
    \ == 1 and (\n    lst[1] == lst[#lst] or is_sorted(subset(lst, 1, #lst - 1)))\n\
    end", "    local last\n    for _, last in ipairs(lst) do\n        if last ~= last\
    \ then\n            return false\n        end\n    end\n    return true\nend",
  "  local last_num = lst[1]\n  for i=2,#lst do\n    if lst[i] ~= last_num then\n\
    \      return false\n    end\n    last_num = lst[i]\n  end\n  return true\nend",
  "    local len = #lst\n    if len == 0 then return true end\n    local i = 1\n \
    \   while i <= len do\n        local item = lst[i]\n        for j = i + 1, len\
    \ do\n            if item > lst[j] then return false end\n        end\n      \
    \  i = i + 1\n    end\n    return true\nend\nexports.is_sorted = is_sorted", " \
    \ for i, v in ipairs(lst) do\n    if v == i then\n      continue\n    end\n  \
    \  if v < i then\n      return false\n    end\n  end\n  return true\nend", " \
    \ local sorted_lst = table.sort(lst)\n  return sorted_lst == lst\nend", "  --\
    \ For each value, count the number of times it appears.\n  local counts = {}\n\
    \  for k, v in pairs(lst) do\n    counts[k] = counts[k] or 0\n    counts[k] =\
    \ counts[k] + 1\n  end\n  -- If every number appears once, it is sorted.\n  for\
    \ k, v in pairs(counts) do\n    if v == 1 then\n      return true\n    end\n \
    \ end\n  return false\nend", "  local n = #lst\n  assert(n > 0, 'list must have\
    \ at least 1 element')\n  for i = 1, n do\n    if lst[i] ~= lst[i - 1] or i ==\
    \ 1 then\n      return false\n    end\n  end\n  return true\nend", "   for _,\
    \ elem in ipairs(lst) do\n      if elem ~= lst[#lst] then\n         return false\n\
    \      end\n   end\n   return true\nend", "  -- TODO: add some tests here\n  return\
    \ true\nend", "  assert(#lst == 1)\n  local _, count = hs.first(lst)\n  return\
    \ count == 1\nend", "  local is_sorted = true\n  if #lst < 1 then\n    return\
    \ is_sorted\n  end\n  for i=1, #lst do\n    local num = lst[i]\n    if lst[i-1]\
    \ == num and i > 1 then\n      return false\n    end\n    is_sorted = is_sorted\
    \ and num < lst[i-1]\n  end\n  return is_sorted\nend", "  local n = #lst\n  if\
    \ n <= 1 then return true end\n  local prev\n  for i = 1, n do\n    local v =\
    \ lst[i]\n    local j = i\n    while j > 1 do\n      local x = lst[j - 1]\n  \
    \    if v < x then\n        lst[j] = prev\n        break\n      end\n      j =\
    \ j - 1\n    end\n    prev = v\n  end\n  return prev\nend", "  local sorted =\
    \ true\n  for i = 1,#lst do\n    if lst[i] ~= lst[i - 1] then\n      sorted =\
    \ false\n      break\n    end\n  end\n  return sorted\nend", "  local sorted,\
    \ count = {}, 0\n  local key, last_key, value", "  local last = lst[1]\n  for\
    \ i=2,#lst do\n    local v = lst[i]\n    if last < v then return false end\n \
    \   last = v\n  end\n  return true\nend", "  local num_dups = {}\n  local last_item\
    \ = lst[1]\n  for _, item in pairs(lst) do\n    if item ~= last_item then\n  \
    \    num_dups[item] = num_dups[item] or 0\n      num_dups[item] = num_dups[item]\
    \ + 1\n    end\n    last_item = item\n  end\n  for key, value in pairs(num_dups)\
    \ do\n    if value == 1 then\n      return false\n    end\n  end\n  return true\n\
    end", "    local n = #lst\n    if n == 0 then\n        return true\n    end\n\
    \    local prev\n    for i = 1, n do\n        prev = lst[i - 1]\n        if prev\
    \ == lst[i] then\n            return false\n        elseif prev > lst[i] then\n\
    \            return false\n        end\n    end\n    return true\nend", "  if\
    \ #lst == 1 then return true\n  end\n  for i = 1, #lst do\n    if lst[i] ~= lst[i\
    \ - 1] then\n      return false\n    end\n  end\n  return true\nend", "   local\
    \ last_index = #lst - 1\n   for i = 1, last_index do\n      if lst[i] ~= lst[i\
    \ - 1] or i > 1 then\n         return false\n      end\n   end\n   return true\n\
    end", "   for i = 1, #lst do\n      local j = i\n      while j > 0 and lst[j]\
    \ == lst[j-1] do\n         j = j - 1\n      end\n      if j == 1 then\n      \
    \   return true\n      else\n         return false\n      end\n   end\n   return\
    \ true\nend", "  -- If there are more than 1 duplicates, return false\n  if #lst\
    \ > 1 then\n    return false\n  end\n  -- If the first number doesn't have duplicates,\
    \ return true\n  if #lst == 1 then\n    return true\n  end\n  -- If there are\
    \ no duplicates, compare first and last\n  return lst.head <= lst[#lst]\nend",
  "    local count = 0\n    local max = 0\n    for v in lst:gmatch(\"%d*\") do\n \
    \       if v > max then\n            max = v\n        end\n        count = count\
    \ + 1\n    end\n    return count <= 1\nend", "  return #lst == 0 and nil or #lst\
    \ == 1 and not is_sorted(lst[0]) or #lst == 1 and\n    is_sorted(lst[0]) == #lst\
    \ and is_sorted(lst[0])\nend", "  local num_dupes, count = 1, 1\n  for _, value\
    \ in pairs(lst) do\n    if value == value then\n      count = count + 1\n    elseif\
    \ count > 1 then\n      num_dupes = num_dupes + 1\n    end\n  end\n  if num_dupes\
    \ > 1 then\n    return false\n  elseif num_dupes == 1 then\n    return true\n\
    \  end\n  for _, value in pairs(lst) do\n    if value < lst.min or value > lst.max\
    \ then\n      return false\n    end\n  end\n  return true\nend", "  -- The last\
    \ element in the list\n  local last = lst[#lst]", "  local i = 1\n  while i <=\
    \ #lst do\n    local elem = lst[i]\n    local j = i\n    while j <= #lst and lst[j]\
    \ == elem do\n      j = j + 1\n    end\n    if i == j then\n      return true\n\
    \    end\n    i = j\n  end\n  return false\nend", "    if #lst == 1 then\n   \
    \     return true\n    end\n    local last = 1\n    for _, val in ipairs(lst)\
    \ do\n        if val == last then\n            return false\n        end\n   \
    \     last = val\n    end\n    return true\nend", "   local seen = {}\n   for\
    \ _, v in ipairs(lst) do\n      if seen[v] then return false end\n      seen[v]\
    \ = true\n   end\n   return true\nend", "  if #lst == 0 then\n    return true\n\
    \  end\n  local last_value = lst[1]\n  for i = 2, #lst do\n    if lst[i] ~= last_value\
    \ then\n      return false\n    end\n  end\n  return true\nend", "  return #lst\
    \ == 1 and lst[1] or #lst > 1 or\n    lst:reduce(function(acc, val)\n      if\
    \ val > acc[1] then\n        return false\n      end\n      if val == acc[1] then\n\
    \        acc[2] = true\n      end\n      if val < acc[1] then\n        acc[1]\
    \ = val\n        acc[2] = true\n      end\n      return acc\n    end, {0, true,\
    \ false})[2]\nend", "  assert(type(lst) == \"table\")\n  assert(#lst > 0)\n  local\
    \ counts = {}\n  for i = 1, #lst do\n    local v = lst[i]\n    counts[v] = counts[v]\
    \ or 0\n    counts[v] = counts[v] + 1\n  end\n  for i = 1, #counts do\n    if\
    \ counts[i] > 1 then\n      return false\n    end\n  end\n  return true\nend",
  "  if #lst == 1 then\n    return true\n  end", "  for i = 1, #lst do\n    if lst[i]\
    \ ~= lst[(i - 1)] then\n      return false\n    end\n  end\n  return true\nend",
  "  return lst ~= nil and all(x == lst[1] or x > lst[1] for x in lst)\nend", "  for\
    \ i = 2, #lst do\n    if lst[i] ~= lst[i - 1] then return false end\n  end\n \
    \ return true\nend", "  return #lst == 0 and nil or #lst == 1 and\n          lst[1]\
    \ < lst[0] or #lst > 1 and #lst == 1 or\n          #lst > 1 and #lst == 1 and\
    \ lst[1] < lst[#lst - 1]\nend", "   if #lst == 1 then\n      return lst[1] ==\
    \ lst[1]\n   elseif #lst > 1 then\n      local cnt = 0\n      local dup = {}\n\
    \      for i = 1, #lst do\n         if lst[i] == lst[i-1] then\n            cnt\
    \ = cnt + 1\n         elseif cnt == 1 then\n            dup[#dup + 1] = lst[i]\n\
    \         end\n      end\n      if #dup > 1 then\n         return false\n    \
    \  else\n         return true\n      end\n   else\n      return true\n   end\n\
    end", "  local lastvalue = lst[1]\n  for i = 2, #lst do\n    if lst[i] ~= lastvalue\
    \ then\n      return false\n    end\n    lastvalue = lst[i]\n  end\n  return true\n\
    end", "   if #lst == 1 then return true else return false end\n   local last_elem\
    \ = lst[#lst]\n   for i, v in ipairs(lst) do\n      if v == last_elem then\n \
    \        return false\n      end\n   end\n   return true\nend", "  if #lst ==\
    \ 0 then\n    return true\n  elseif #lst == 1 then\n    return lst[1] == lst[1]\n\
    \  else\n    for i = 2, #lst do\n      if lst[i] > lst[i-1] then\n        return\
    \ false\n      end\n    end\n  end\n  return true\nend", "  -- Check for empty\
    \ list\n  if #lst == 0 then\n    return true\n  end", "  local ok, last_value,\
    \ last_key = false, lst[1], lst[1]\n  for i=2,#lst do\n    local value = lst[i]\n\
    \    if last_value < value then\n      ok = false\n    elseif last_value == value\
    \ then\n      if not last_key then\n        ok = false\n      elseif last_key\
    \ ~= key then\n        ok = false\n      end\n    else\n      ok = true\n    end\n\
    \    last_value, last_value = value, value\n    last_key = key\n  end\n  return\
    \ ok\nend", "  local sorted_lst, duplicate_lst = setmetatable({}, {__mode = 'k'})\n\
    \  for k, v in pairs(lst) do sorted_lst[k] = true end\n  -- The last pair is only\
    \ used to determine whether the table has\n  -- at least 1 duplicate, which indicates\
    \ that it is sorted.\n  for i = 2, #lst do\n    duplicate_lst[lst[i-1]] = true\n\
    \  end\n  -- Check if all elements are different.\n  if #sorted_lst ~= #lst then\n\
    \    return false\n  end\n  for k, v in pairs(sorted_lst) do\n    if v ~= true\
    \ then\n      return false\n    end\n  end\n  for k, v in pairs(duplicate_lst)\
    \ do\n    if v ~= true then\n      return false\n    end\n  end\n  return true\n\
    end", "    return #lst == 1 and lst[1] or #lst == 1 and false or math.fmod(#lst,\
    \ 1) == 0 and is_sorted(lst[math.fmod(#lst, 1) + 1])\nend", "  if #lst == 1 then\
    \ return true end\n  local last_value = lst[1]\n  for i = 2, #lst do\n    if last_value\
    \ == lst[i] then\n      return false\n    end\n    last_value = lst[i]\n  end\n\
    \  return true\nend", "  for i=1,#lst do\n    if lst[i] ~= lst[i-1] then\n   \
    \   return false\n    end\n  end\n  return true\nend", "  -- We sort the list\
    \ and then compare it to the input in reverse\n  -- order. If the list is sorted\
    \ in descending order, then there are\n  -- duplicates. But if there are duplicates,\
    \ they are the only way\n  -- to determine if there are duplicates in the list.\
    \ So therefore,\n  -- if the list is sorted in ascending order, then there are\
    \ no duplicates.\n  -- Thus if the list is sorted in ascending order, then the\
    \ duplicate\n  -- counts are the same, and the input must be sorted in ascending\
    \ order.\n  local function is_sorted(lst)\n    local sorted = table.sort(lst)\n\
    \    if sorted ~= lst then\n      return false\n    end\n    local prev_val =\
    \ sorted[1]\n    for _, val in ipairs(sorted) do\n      if val == prev_val then\n\
    \        return false\n      else\n        prev_val = val\n      end\n    end\n\
    \    return true\n  end\n  return is_sorted(lst)\nend", "   for _, val in ipairs(lst)\
    \ do\n      if val == lst[#lst] then return false end\n   end\n   return true\n\
    end", "  for _, value in ipairs(lst) do\n    if value ~= value then\n      return\
    \ false\n    end\n  end\n  return true\nend", "   -- Check one edge case: what\
    \ if the list is empty?\n   if #lst == 0 then\n      return true\n   end\n   if\
    \ lst[1] == lst[2] then\n      -- If two items are equal, make sure they are in\
    \ ascending order\n      if lst[1] ~= lst[3] then\n         return false\n   \
    \   end\n   else\n      -- If two items are different, make sure they are in ascending\
    \ order\n      if lst[1] ~= lst[3] then\n         if lst[1] <= lst[2] then\n \
    \           return true\n         else\n            return false\n         end\n\
    \      end\n   end\n   return false\nend", "  -- Find the number of repeated entries\n\
    \  local num_repeat = table.count(lst, function(x) return x == lst end) + 1 --\
    \ Don't allow empty tables.", "    local last\n    for i = 1, #lst - 1 do\n  \
    \      local current = lst[i]\n        local next = lst[i + 1]\n        if current\
    \ ~= last and current >= next then\n            return false\n        end\n  \
    \      last = current\n    end\n    return true\nend", "  local counts = {}\n\
    \  for _, v in ipairs(lst) do\n    if counts[v] then\n      counts[v] = counts[v]\
    \ + 1\n    else\n      counts[v] = 1\n    end\n  end\n  local dups = #counts\n\
    \  -- If there are more dups than values, then table is NOT sorted\n  return (dups\
    \ > 1)\nend", "  local len = #lst\n  if len == 1 then\n    return lst.head <=\
    \ lst.head\n  end", "  local i, j, count = 1, #lst\n  for i = 2, count do\n  \
    \  count = count - 1\n    if lst[i] == lst[j] then return false end\n    j = j\
    \ + 1\n  end\n  return true\nend", "  for i, v in ipairs(lst) do\n    if v ==\
    \ i then\n      return true\n    end\n  end\n  return false\nend", "  -- We don't\
    \ need to check for equal elements - the elements are unique\n  -- within a given\
    \ set, so just use set.\n  local set = setmetatable({}, {__mode = \"v\"})\n  for\
    \ i, x in ipairs(lst) do\n    local value = getmetatable(x).__index\n    set[value]\
    \ = true\n  end\n  return setmetatable(set, {}) == set\nend", "  -- Check for\
    \ more than 1 duplicate number.\n  for i = 1, #lst - 1 do\n    if lst[i] == lst[i-1]\
    \ then return false end\n  end\n  -- Check for negatives.\n  for i = 1, #lst -\
    \ 1 do\n    if lst[i] < 0 then return false end\n  end\n  return true\nend", " \
    \   for _, n in ipairs(lst) do\n        if table.contains(lst, n)\n        then\n\
    \            return false\n        end\n    end\n    return true\nend", "  local\
    \ uniques = {}\n  local n = #lst\n  for i = 1, n do\n    if lst[i] ~= lst[i -\
    \ 1] then\n      table.insert(uniques, lst[i])\n    end\n  end\n  if #uniques\
    \ > 1 then return false end\n  for i = 2, n do\n    if uniques[i - 2] < uniques[i]\
    \ then return false end\n  end\n  return true\nend", "   if #lst == 1 then\n \
    \     return true\n   else\n      local last_index = #lst\n      for i = 1, #lst\
    \ do\n         if lst[i - 1] = lst[i] then\n            last_index = i - 1\n \
    \        else\n            break\n         end\n      end\n      if last_index\
    \ == #lst then\n         return true\n      else\n         return false\n    \
    \  end\n   end\nend", "  if #lst > 1 then\n    -- If the list has duplicates,\
    \ we cannot sort it\n    return false\n  elseif #lst == 1 then\n    -- If the\
    \ list has one duplicate, it must be sorted\n    return true\n  elseif #lst ==\
    \ 0 then\n    -- If the list has no duplicates, then it is already sorted\n  \
    \  return true\n  end", "  -- Return true if lst is sorted.\n  if #lst == 0 then\
    \ return true end", "  if #lst == 0 then\n    return true\n  end\n  local last\n\
    \  for i = 1, #lst do\n    if lst[i] ~= last then\n      last = lst[i]\n     \
    \ break\n    end\n  end\n  return i == #lst\nend", "  -- This solution uses a\
    \ single sorted list to store each unique number in\n  -- lst. Since this list\
    \ is already sorted, the insertion complexity is\n  -- guaranteed to be O(n).\
    \ A binary search is then used to determine whether\n  -- lst contains every number\
    \ in the table.\n  local last_num = lst[1]\n  local count = 0\n  -- Binary search\
    \ is faster than linear search.\n  for i = 2, #lst do\n    if last_num == lst[i]\
    \ then\n      count = count + 1\n    elseif last_num > lst[i] then\n      count\
    \ = count + 1\n    elseif last_num < lst[i] then\n      if count ~= 0 then\n \
    \       return false\n      end\n      count = count\n    end\n    last_num =\
    \ lst[i]\n  end\n  if count ~= 0 then\n    return false\n  end\n  return true\n\
    end\n</cell>\n<text>\n6. Map", "  local last_value = nil\n  local last_index =\
    \ nil\n  for i=1,#lst do\n    if lst[i] ~= last_value then\n      last_value =\
    \ lst[i]\n      last_index = i\n    end\n  end\n  if #lst == last_index then\n\
    \    return true\n  else\n    return false\n  end\nend", "    local i, last =\
    \ 1, lst[1]\n    for i = 2, #lst do\n        if lst[i] ~= last then\n        \
    \    return false\n        end\n        last = lst[i]\n    end\n    return true\n\
    end", "  local sorted = {}\n  local dup = 0\n  for _, v in ipairs(lst) do\n  \
    \  if v == true then\n      table.insert(sorted, v)\n    elseif v > true then\n\
    \      table.insert(sorted, false)\n      dup = dup + 1\n      table.insert(sorted,\
    \ v)\n    elseif v < true then\n      return false\n    end\n  end\n  if dup >\
    \ 0 then\n    return false\n  end\n  if #sorted == #lst then\n    return true\n\
    \  end\n  if #sorted > 1 then\n    return false\n  end\n  return true\nend", " \
    \ if #lst <= 1 then return true end\n  local first, rest = unpack(lst)\n  if first\
    \ ~= first then return false end\n  if #rest == 1 then return true end\n  local\
    \ last, rest = unpack(rest)\n  if last ~= first then return false end\n  return\
    \ is_sorted(rest)\nend", "    local i, n = 1, #lst\n    while i <= n do\n    \
    \    if lst[i] == lst[i - 1] or i == n - 1 then\n            return false\n  \
    \      end\n        i = i + 1\n    end\n    return true\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
