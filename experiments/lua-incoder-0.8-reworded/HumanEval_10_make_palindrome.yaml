name: HumanEval_10_make_palindrome
language: lua
prompt: "-- Find the shortest palindrome that begins with a supplied string.\n-- Algorithm\
  \ idea is simple:\n-- - Find the longest postfix of supplied string that is a palindrome.\n\
  -- - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\n-- >>> make_palindrome('')\n-- ''\n-- >>> make_palindrome('cat')\n\
  -- 'catac'\n-- >>> make_palindrome('cata')\n-- 'catac'\nlocal function make_palindrome(string)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
  \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
  \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
  \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if string ~= string.reverse then string = string.reverse end\n  return\
    \ string:gsub('^(.*)$', function(substring)\n    -- Find the largest prefix in\
    \ supplied string that is a palindrome,\n    -- which is as long as the longest\
    \ postfix of the supplied string.\n    -- A palindrome is a string that reads\
    \ the same backwards as forwards.\n    local prefix = string.sub (string.reverse\
    \ (substring), 1, 1)\n    -- Concatenate the supplied string and reverse-prefixed\
    \ string to form the\n    -- palindrome suffix:\n    return string.sub (string.concat\
    \ ('', string.reverse (prefix), substring), 1)\n  end)\nend", "   if string ==\
    \ nil then return nil end\n   \n   local longest, longestLength, longestPrefix,\
    \ longestPrefixLength, longestPrefixPrefix, longestPostfix, longestPostfixLength,\
    \ longestPostfixPrefix, longestPostfixPostfix = string.gsub(string, \"([^\" ..\
    \ string.char(127) .. \"]+)\", \"\")\n   \n   if string.len(longest) == 0 or string.len(longestPrefix)\
    \ == 0 or string.len(longestPostfix) == 0 then return nil end\n   \n   local postfix\
    \ = string.gsub(longestPostfix, \"([^\" .. string.char(127) .. \"]+)\", \"\")\n\
    \   local palindrome = longestPrefix .. longestPostfix... postfix\n   \n   if\
    \ string.len(palindrome) < string.len(longest) then\n      return palindrome\n\
    \   else\n      return make_palindrome(longestPrefix) .. longestPostfix\n   end\n\
    end", "    if not string then return '' end", "  local longest, shortest = string.gsub(string.sub(string,\
    \ 1, string.len(string) -2), '[atc]$'), string.gsub(string.sub(string, string.len(string)\
    \ -1, string.len(string) -2), '[tc]$')\n  while true do\n    longest, shortest\
    \ = string.gsub(longest, '^$', ''), string.gsub(shortest, '^$', '')\n    if longest\
    \ ~= string.gsub(string.sub(longest, 1, string.len(longest) -2), '[atc]$') then\n\
    \      break\n    end\n  end\n  return string.sub(shortest, 1, string.len(shortest)\
    \ -1) + string.sub(longest, string.len(longest) -2)\nend", "\tlocal postfix, prefix,\
    \ suffix = string.match(string, '([^a-zA-Z]+)(.)(.*)$')\n\tlocal suffix_palindromic\
    \ = suffix:reverse():sub(1, #suffix)\n\treturn prefix .. suffix_palindromic\n\
    end", "    local postfix = string\n    local longest = 0\n    for i = 1, #string\
    \ do\n        if string:sub(i, i) == string[i]:reverse then\n            longest\
    \ = i\n        end\n    end\n    postfix = string[longest] .. string[#string -\
    \ longest:reverse():len()]\n    return postfix\nend", "    local length = 0\n\
    \    local palindrome = ''\n    local prefix = string.sub(string, 1, length)\n\
    \    local suffix = string.sub(string, 1, length)\n    local reverse = string.sub(string,\
    \ 1, length)\n    for i=1, #string do\n        local char = string.sub(string,\
    \ 1, i)\n        if char == reverse then\n            local remaining = string.sub(string,i,\
    \ #string)\n            palindrome = palindrome .. reverse .. remaining\n    \
    \    end\n    end\n    local postfix = string.sub(string, 1, length)\n    return\
    \ prefix .. palindrome .. postfix\nend", "\t-- Start with a blank string.\n\t\
    local result = string", "    local longest = string\n    for i = 1, (string.len()\
    \ - 1) do\n        longest = string.sub(string, i, i) + longest + string.sub(string,\
    \ string.len() - i, string.len() - i)\n    end\n    return longest\nend", "  --\
    \ TODO: use Lua tables to do this.\n  local max_len = 0\n  local max_len_palindromic_start\
    \ = 0\n  local palindromic_start = 0\n  for i = 1, #string do\n    -- We know\
    \ string[i] cannot be a palindrome, so let's check for that first.\n    if string[i]\
    \ ~= string[#string] then\n      -- We can't test for this palindromic starting\
    \ string because we'll\n      -- have to start searching at the next character.\n\
    \      palindromic_start = i\n      break\n    end\n    -- We've found the longest\
    \ palindromic prefix that comes before the current\n    -- character we're checking.\n\
    \    max_len = #string - i\n    -- Find the longest palindromic suffix that comes\
    \ after the current character\n    -- we're checking.\n    if #string > max_len\
    \ then\n      max_len_palindromic_start = i - 1\n    end\n  end\n  return string.sub(string,\
    \ 1, #string - #palindromic_start - max_len_palindromic_start - 1)\nend", "  \
    \  local prefix = string\n    local postfix = ''\n    local i = #string\n    while\
    \ i ~= 0 do\n        postfix = string.sub(string, i - 1, i) + postfix .. string.sub(string,\
    \ i - 1, i)\n        i = i - 1\n    end\n    local reversed = string.gsub(postfix,\
    \ \"[\" .. string.sub(postfix, 1, -1) .. \"]\", \"\")\n    return prefix .. reverse\
    \ .. postfix\nend", "    local start = string\n    local end = string.sub(string,\
    \ 1, string.len(string))\n    local post = string.sub(string, 1, string.len(end))\n\
    \    if string.len(post) > string.len(end) then\n        post = string.sub(string,\
    \ string.len(post), 1, string.len(end))\n    end\n    if string.len(post) == 0\
    \ then\n        return start\n    end\n    local palindrome = start .. post\n\
    \    local lenPost = string.len(post)\n    while string.len(palindrome) < lenPost\
    \ + 1 do\n        local new_palindrome = palindrome .. post\n        if new_palindrome\
    \ ~= palindrome then\n            palindrome = new_palindrome\n        end\n \
    \       post = string.sub(post, 1, string.len(post) - 1)\n    end\n    return\
    \ palindrome\nend", "    local prefix = ''\n    local suffix = ''\n    local palindrome\
    \ = ''", '    if not string then return string end', "   if string == '' then\
    \ return '' end\n   local postfix = string\n   while postfix:sub(1,#postfix) ==\
    \ postfix do\n      postfix = postfix .. string.rev(postfix:sub(1,#postfix))\n\
    \   end\n   return postfix .. string.rev(postfix:sub(1,#postfix))\nend", "   \
    \ local prefix = ''\n    local suffix = ''\n    for i = 1, #string do\n      \
    \  local value = string[i]\n        if value == value then\n            prefix\
    \ = prefix .. value\n        elseif value == 'c' then\n            prefix = prefix\
    \ .. 'c'\n        else\n            suffix = suffix .. value\n        end\n  \
    \  end\n    prefix = prefix .. string\n    suffix = suffix .. string\n    local\
    \ reversed_prefix = reversed(prefix)\n    local reversed_suffix = reversed(suffix)\n\
    \    if prefix == reversed_prefix then\n        return string\n    else\n    \
    \    return prefix .. reversed_suffix .. suffix\n    end\nend", "    local maxLength\
    \ = string.len(string) / 2\n    local palindrome = ''\n    local remainder = string\n\
    \    local length = 1\n    local suffix = ''\n    while length < maxLength do\n\
    \        suffix = '' -- Initialize to an empty string in order not to accidentally\
    \ append the reversed string of the empty string.\n        suffixLength = 0 --\
    \ Length of the suffix to append.\n        while string.len(remainder) > length\
    \ do\n            suffix = suffix .. string.sub(remainder, length, length + 1)\
    \ -- Append the suffix of the remaining string to the suffix.\n            suffixLength\
    \ = suffixLength + 1 -- Count the length of the suffix.\n            length =\
    \ length + 1 -- Increase the length of the string by 1 to exclude the current\
    \ character from the suffix.\n        end\n        suffixLength = suffixLength\
    \ + 1 -- Count 1 more character from the suffix to exclude it from the reversed\
    \ string.\n        palindrome = palindrome .. string.sub(remainder, length) ..\
    \ suffix .. string.sub(remainder, length - suffixLength, length - suffixLength\
    \ - 1) -- Add the reversed string of the suffix to the palindrome string.\n  \
    \      remainder = string.sub(remainder, length + suffixLength, string.len(remainder))\
    \ -- Skip 1 more character from the suffix to find the next palindrome suffix.\n\
    \        length = length + 1 -- Increase the length of the string by 1 to exclude\
    \ the current character from the suffix.\n    end\n    return palindrome\nend",
  "   -- If string is empty, return empty string\n   if string == nil or string ==\
    \ '' then\n      return ''\n   end", "  local longest = string.gsub(string, '^%s*',\
    \ '')\n  longest = string.gsub(longest, '%s*$', '') -- Remove any trailing spaces\n\
    \  longest = string.gsub(longest, '%s+$', '') -- Remove any trailing punct\n \
    \ longest = string.gsub(longest, '%s+%.?%s*$', '') -- Remove trailing punct and\
    \ any trailing space\n  longest = string.gsub(longest, '^%s+', '')", "    local\
    \ reversed_string = string.gsub(string, '(.-)%1', '\\\\2')\n    local reverse_length\
    \ = string.len(reversed_string)\n    local new_string = string .. reversed_string\n\
    \    local end_index = string.find(new_string, \"%1\", 1, reverse_length-1)\n\
    \    if end_index == nil then\n        return new_string\n    end\n    local first_index\
    \ = string.find(new_string, \"%\", 1, end_index)\n    if first_index == nil then\n\
    \        return new_string\n    end\n    local first_letter = string.sub(string.sub(new_string,\
    \ first_index, end_index-1), 1, 1)\n    if first_letter ~= string.sub(string.sub(new_string,\
    \ end_index+1, reverse_length-1), -1, -1) then\n        return new_string\n  \
    \  end\n    local first_letter_length = string.len(first_letter)\n    local start_index\
    \ = string.find(new_string, \"%\", first_index, first_index-1)\n    local end_index\
    \ = string.find(new_string, \"%\", start_index+1, reverse_length-1)\n    if end_index\
    \ == nil then\n        return new_string\n    end\n    local second_letter = string.sub(string.sub(new_string,\
    \ start_index+1, end_index-1), 1, 1)\n    if second_letter ~= string.sub(string.sub(new_string,\
    \ end_index+1, reverse_length-1), -1, -1) then\n        return new_string\n  \
    \  end\n    local second_letter_length = string.len(second_letter)\n    local\
    \ output_string = string.sub(new_string, first_index, end_index-1)\n    output_string\
    \ = \"%\" .. first_letter .. second_letter .. string.sub(output_string, start_index+1,\
    \ end_index-1)\n    return output_string\nend", "  local palindrome = ''\n  local\
    \ suffix = ''\n  local longest = 0\n  -- Scan the string and find the longest\
    \ postfix palindrome.\n  for i = 1, #string do\n    if string[i] == 'a' or string[i]\
    \ == 'e' or string[i] == 'i' or string[i] == 'o' then\n      longest = i\n   \
    \ end\n  end\n  -- Now we need to append to the end of the string reverse of longest\
    \ prefix.\n  for i = 1, longest do\n    suffix = string[i]:reverse()\n    local\
    \ reversed_suffix_length = #suffix - 1\n    for j = 1, reversed_suffix_length\
    \ do\n      palindrome = palindrome .. suffix[j + 1]\n    end\n  end\n  return\
    \ palindrome\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI do not understand how\
    \ this code works. Could you please explain more?\n<|/ c |>\n<| c |>\n- This code\
    \ just checks if the given string is a palindrome or not. It does not do any manipulation\
    \ of the string. How do you expect me to explain it in detail? If you need help\
    \ in understanding this code then I suggest you ask a separate question on Stack\
    \ Overflow explaining where you got stuck.\n<|/ c |>\n<| c |>\nThe OP said they\
    \ do not want a solution for any given string, but that they want to write a function\
    \ or use an existing function if they find one. I believe that the OP wants to\
    \ find if there is a palindrome in a string so that they can use it in an if statement\
    \ and perform an operation on that string if it is palindrome. Since you seem\
    \ to know more about this than I, I thought I would ask here. Sorry for the confusion.\n\
    <|/ c |>\n<| c |>\n- Okay fair enough. I hope that the OP will clarify the question\
    \ somehow because my explanation was based on a misunderstanding of what they\
    \ were asking for.\n<|/ c |>\n<| a |>\nA palindrome is a word that appears in\
    \ its reverse or mirror version. Here are a few examples of palindromes:\n\"racecar\"\
    , \"racecars\", \"racecar\", \"racecars\"\n\"racecar\", \"racecars\", \"racecar\"\
    , \"racecars\"\n\"racecar\", \"racecars\", \"racecar\", \"racecars\"\n\"racecar\"\
    , \"racecars\", \"racecar\", \"racecars\"\n\"racecar\", \"racecars\", \"racecar\"\
    , \"racecars\"\n\"racecar\", \"racecars\", \"racecar\", \"racecars\"\n\"", " \
    \ -- Sadly can't use an interator for this\n  -- So we're going to have to do\
    \ a bit more work\n  -- We'll do the suffix first and then reverse it\n  local\
    \ suffix_length = string.len()\n  local suffix_string = string\n  local suffix_reverse\
    \ = \"\"\n  for i = suffix_length, 1, -1 do\n    local c = string.sub(suffix_string,\
    \ i, i)\n    suffix_reverse = suffix_reverse .. c\n  end", "   local postfix =\
    \ string\n   local palindrome = string\n   local suffix_start = #string + 1\n\
    \   while suffix_start > 0 and string[suffix_start - 1] == string[suffix_start]\
    \ do\n      suffix_start = suffix_start - 1\n   end\n   if suffix_start == 0 then\n\
    \      return string\n   end\n   local suffix_end = #string - 1\n   while suffix_end\
    \ > 0 and string[suffix_end - 1] == string[suffix_end] do\n      suffix_end =\
    \ suffix_end - 1\n   end\n   if suffix_end == 0 then\n      return string\n  \
    \ end\n   palindrome = palindrome .. string[suffix_end - 1]\n   for i = suffix_start\
    \ - 1, #string + 1 do\n      local ch = string[i]\n      while #palindrome > 0\
    \ and palindrome[#palindrome - 1] == ch do\n         palindrome = palindrome ..\
    \ palindrome[#palindrome - 1]\n      end\n      palindrome = palindrome .. ch\n\
    \   end\n   palindrome = palindrome .. string[#string]\n   return palindrome\n\
    end", "   if string == '' or string == '*' then\n      return string\n   end\n\
    \   if #string == 1 then\n      return string\n   end\n   local start = '#'\n\
    \   local longest = string\n   for i = 1, #string do\n      local postfix = string:sub(i,\
    \ i)\n      local reverse = string\n      reverse = reverse:gsub('%s+$', '%s'):reverse()\n\
    \      if reverse == postfix then\n         return string\n      end\n      start\
    \ = postfix .. start .. postfix\n      longest = postfix .. longest .. postfix\n\
    \   end\n   return string\nend", "\t-- Find the longest postfix that is a palindrome.\n\
    \t-- A palindrome is of the form\n\t-- - The reverse of the shortest postfix of\
    \ that string that is a palindrome.\n\t-- >>> make_palindrome('cat')\n\t-- 'atcata'\n\
    \t-- >>> make_palindrome('cata')\n\t-- 'acatat'\n\tlocal postfix = string\n\t\
    local is_palindrome = true\n\tlocal reversed_postfix = string\n\tfor i = 1, #string\
    \ do\n\t\tlocal char = string[i]\n\t\treversed_postfix = reversed_postfix:reverse()\n\
    \t\tif char == reversed_postfix:sub(1,1) then\n\t\t\tpostfix = postfix:reverse()\n\
    \t\t\tbreak\n\t\tend\n\tend\n\tif #string > 1 then\n\t\tlocal reversed_prefix_before\
    \ = string\n\t\tfor i = #string+1, 1, -1 do\n\t\t\treversed_prefix_before = reversed_prefix_before:reverse()\n\
    \t\t\tif string[i] ~= reversed_prefix_before:sub(1,1) then\n\t\t\t\tis_palindrome\
    \ = false\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\t-- Append to the end of\
    \ the string reverse of the string prefix that comes before the palindromic suffix.\n\
    \treturn string .. postfix .. reversed_prefix_before\nend", "    local suffix\n\
    \    local longest_postfix, suffix_length = longest_palindrome_postfix(string,\
    \ true)\n    if suffix_length == 0 then\n        return string\n    end\n    suffix\
    \ = string\n    for index = 0, suffix_length - 1 do\n        suffix = suffix ..\
    \ string_reverse(longest_postfix, index)\n    end\n    return prefix .. suffix\
    \ .. longest_postfix\nend", "  local longest_palindrome_prefix_len = longest_palindrome_prefix(string,\
    \ true)\n  local longest_palindrome_suffix_len = longest_palindrome_suffix(string,\
    \ true)\n  local result = string\n  if string.len(string) > longest_palindrome_prefix_len\
    \ then\n    result = string .. make_palindrome(string.sub(string, 1, longest_palindrome_prefix_len))\
    \ .. string.reverse(string.sub(string, longest_palindrome_prefix_len + 1, string.len(string)))\n\
    \  elseif string.len(string) > longest_palindrome_suffix_len then\n    result\
    \ = string.sub(string, 1, longest_palindrome_suffix_len) .. string.reverse(string.sub(string,\
    \ longest_palindrome_prefix_len + 1, longest_palindrome_suffix_len))\n  end\n\
    \  return result\nend", "    local postfix, suffix = string_reverse(string), string\n\
    \    local palindrome = string_reverse(string_reverse(string))\n    for i = 2,\
    \ #string do\n        postfix = string_reverse(postfix, string[i])\n        suffix\
    \ = string_reverse(suffix)\n        palindrome = palindrome .. string[i]\n   \
    \ end\n    return postfix .. string_reverse(palindrome) .. suffix\nend", "  if\
    \ string == '' then\n    return string\n  end\n  local palindrome = ''\n  local\
    \ start_index = string.len()\n  for i = start_index, 1, -1 do\n    local substring\
    \ = string.sub(string, 0, i)\n    local reversed_substring = reverse(string:sub(i))\n\
    \    if substring == reversed_substring then\n      palindrome = palindrome ..\
    \ substring\n      break\n    end\n  end\n  return palindrome .. string\nend",
  "    local suffix = string\n    local prefix, suffix_len = string, \"a\"\n    local\
    \ suffix1, suffix_len1 = string, \"a\"", "    -- Find longest palindromic prefix\
    \ of string.\n    local postfix = find_longest_palindromic_postfix_string(string)",
  "    local suffix\n    local length", "   -- No reverse of empty string.\n   if\
    \ string == '' then\n      return string\n   end", "  if not string then return\
    \ '' end\n  local postfix = string.sub(string, 0, -1)\n  local reversed_prefix\
    \ = reverse(string:sub(1,-1))\n  local palindrome = string.sub(postfix:reverse()..reversed_prefix)\n\
    \  return string..palindrome\nend\n_G.make_palindrome = make_palindrome", "  \
    \  local result = string\n    for i = #string, 1, -1 do\n        local start =\
    \ i\n        local last = #result\n        while last > 0 do\n            local\
    \ char = string.sub(result,last-1,last)\n            if char == string.sub(result,last,last-1)\
    \ then\n                last = last - 1\n            else\n                last\
    \ = last - 1\n            end\n        end\n        result = result .. string.sub(string,\
    \ start, last)\n    end\n    return result\nend\n</code>\n<|/ a tags=palindrome,lua\
    \ |>\n<| a tags=palindrome,lua |>\n<code>", "    local string_reverse, postfix_palindrome\n\
    \    if string == '' then\n        return ''\n    end\n    -- Find the length\
    \ of the postfix palindrome\n    string_reverse = string\n    postfix_palindrome\
    \ = string.gsub(string_reverse, '(.)(.)', '$2$1')\n    if string.len(postfix_palindrome)\
    \ == 0 then\n        return ''\n    end\n    -- Append reverse of the postfix\
    \ palindrome to the end of the string.\n    string_reverse = string_reverse..postfix_palindrome\n\
    \    if string.len(string_reverse) <= 1 then\n        return string_reverse\n\
    \    end\n    -- Construct the palindrome from the reversed suffix.\n    return\
    \ string_reverse..string.gsub(string_reverse, '(.)', function(s)\n        return\
    \ string_reverse:sub(1,string.len(s)) .. s:sub(-string.len(s))\n    end)\nend",
  "    local suffix_len = string.len('a')\n    local suffix_start, suffix_end = string.find(string,\
    \ 'a'), string.find(string, 'a')\n    suffix_len = suffix_len - suffix_start\n\
    \    local prefix_len = 1\n    local prefix_start = suffix_end\n    local prefix_end\
    \ = suffix_end\n    local suffix_postfix_reverse = \"\"\n    while string.sub(string,suffix_end+1,string.len(string))\
    \ ~= suffix then\n        suffix_postfix_reverse = suffix_postfix_reverse .. string.sub(string,prefix_start,prefix_end)\n\
    \        suffix_end, suffix_start = suffix_start, suffix_end+1\n        prefix_end,\
    \ prefix_start = prefix_start, prefix_end+1\n    end\n    suffix_postfix_reverse\
    \ = suffix_postfix_reverse .. string.sub(string,prefix_start,prefix_end)\n   \
    \ suffix_len = suffix_len - suffix_start\n    prefix_len = prefix_len - prefix_start\n\
    \    local palindrome = string.sub(string,1,prefix_len-1) .. suffix .. string.sub(string,prefix_len+1,\
    \ string.len(string))\n    palindrome = suffix_postfix_reverse .. palindrome\n\
    \    return palindrome\nend", "  local lengthOfLongestPalindrome = 0\n  local\
    \ longestPalindrome = ''\n  for i = 1, #string do\n    local substring = string.sub(i,\
    \ i+1)\n    local substringReversed = string.sub(string.sub(string, 1, i), -1)\n\
    \    local isPalindrome = string.sub(string.sub(substring, 1, i), -1) == substringReversed\n\
    \    -- Check if it is possible to continue the longest palindrome in the next\
    \ iteration of the loop.\n    if i == 1 then\n      -- First iteration - check\
    \ if the current character is palindrome. If not, return it.\n      if not isPalindrome\
    \ then\n        return substring\n      end\n      -- Check if the current character\
    \ is a palindrome starting from the first character.\n    elseif not isPalindrome\
    \ and lengthOfLongestPalindrome > 0 then\n      -- Second iteration - check if\
    \ the current character is a palindrome starting from the current character.\n\
    \      if not isPalindrome then\n        return substring\n      end\n    elseif\
    \ isPalindrome then\n      -- Third iteration - check if the current character\
    \ is a palindrome starting from the current character.\n      local newLongestPalindrome\
    \ = string.sub(i, 1, i - 1..-1)\n      if not string.find(longestPalindrome, newLongestPalindrome)\
    \ then\n        longestPalindrome = newLongestPalindrome\n      end\n      lengthOfLongestPalindrome\
    \ = string.len(longestPalindrome)\n    end\n  end\n  if lengthOfLongestPalindrome\
    \ > 0 then\n    return longestPalindrome\n  end\n  return ''\nend", "  local postfix\
    \ = string\n  local reverse\n  local longest_palindrome = string\n  local prefix\
    \ = ''\n  local last_index = #string\n  for i = last_index - 1, 1, -1 do\n   \
    \ reverse = reverse..string[i]\n    if reverse == postfix then\n      longest_palindrome\
    \ = prefix..reverse\n      break\n    else\n      prefix = (prefix..string[i])\n\
    \    end\n  end\n  return longest_palindrome\nend", "    if string == nil then\n\
    \        return nil\n    end\n    local postfix_reversed = string.gsub(string,\
    \ '%a', function(match)\n        return string.sub(match, 2, -2)\n    end)\n \
    \   if postfix_reversed == nil then\n        return string\n    end\n    local\
    \ postfix_reversed_length = string.len(postfix_reversed)\n    local postfix_reversed_index\
    \ = 0\n    local palindrome_start = -1\n    for index=1, string.len(string) do\n\
    \        if postfix_reversed_index == postfix_reversed_length then\n         \
    \   palindrome_start = index\n            break\n        end\n        if string.sub(string,\
    \ (index - 1), index) == postfix_reversed then\n            palindrome_start =\
    \ index\n        end\n        postfix_reversed_index = postfix_reversed_index\
    \ + 1\n    end\n    if palindrome_start == -1 then\n        error(\"Failed to\
    \ determine palindrome start index.\")\n    end\n    if palindrome_start + 1 <=\
    \ string.len(string) then\n        return string\n    else\n        return string..string.sub(postfix_reversed,\
    \ palindrome_start, postfix_reversed_index)\n    end\nend", "  if string == ''\
    \ then\n    return string\n  end\n  local palindrome = string.gsub(string:reverse(),\
    \ '[%z]', '')\n  local prefix = string.sub(string, 1, string.len(string) - string.len(palindrome))\n\
    \  local postfix = string.sub(palindrome, string.len(string))\n  return prefix\
    \ .. postfix .. palindrome\nend", "    local max_len = 0\n    local max_postfix_len\
    \ = 0\n    local max_postfix_postfix_len = 0\n    for i = 1, #string do\n    \
    \    if string[i] ~= string[#string] then\n            if string[i] ~= ' ' then\n\
    \                max_len = max_len + 1\n            end\n            if string[#string]\
    \ == string[i] then\n                max_postfix_len = max_postfix_len + 1\n \
    \           elseif string[i] ~= string[#string] then\n                max_postfix_postfix_len\
    \ = max_postfix_postfix_len + 1\n            end\n        end\n    end\n    if\
    \ max_len == 0 or max_postfix_len == 0 or max_postfix_postfix_len == 0 then\n\
    \        return ''\n    end\n    -- If the longest postfix is a palindrome, append\
    \ the reverse of the prefix that comes before it.\n    local postfix_len = #string\n\
    \    local postfix_postfix_len = 0\n    local postfix_postfix_postfix_len = 0\n\
    \    while postfix_len > 0 and postfix_postfix_len < max_postfix_len do\n    \
    \    if string[postfix_len] == string[#string] then\n            postfix_postfix_len\
    \ = postfix_postfix_len + 1\n        elseif string[postfix_len] ~= string[#string]\
    \ then\n            postfix_postfix_postfix_len = postfix_postfix_postfix_len\
    \ + 1\n        end\n        postfix_len = postfix_len - 1\n    end\n    if postfix_len\
    \ > 0 then\n        local postfix_postfix_str = string\n        while postfix_postfix_len\
    \ > 0 do\n            if postfix_postfix_str[postfix_postfix_len] == string[#string]\
    \ then\n                postfix_postfix_postfix_len = postfix_postfix_postfix_len\
    \ + 1\n            elseif postfix_postfix_str[postfix_postfix_len] ~= string[#string]\
    \ then\n                postfix_postfix_postfix_postfix_len = postfix_postfix_postfix_len\
    \ + 1\n            end\n            postfix_postfix_len = postfix_postfix_len\
    \ - 1\n        end\n        return string..string.reverse(postfix_postfix_str)\n\
    \    end\n    return ''\nend", "  if string == nil then return '' end\n  local\
    \ postfix = string\n  local reverse = ''\n  for i = #string - 1, 1, -1 do\n  \
    \  local char\n    char = string.sub(string, i, i)\n    reverse = reverse .. char\n\
    \  end\n  if reverse == postfix then\n    return string\n  end\n  local palindrome\
    \ = postfix .. reverse .. postfix\n  return palindrome\nend", "   if string ==\
    \ nil then\n      return nil\n   end\n   local max_pos = #string\n   local reverse\
    \ = string.sub(string, 1, max_pos - 1)\n   reverse = reverse:reverse()\n   local\
    \ prefix = string\n   if reverse ~= '' then\n      prefix = reverse..string.sub(string,\
    \ max_pos)\n   end\n   return prefix\nend\nreturn make_palindrome", "   if string\
    \ == nil then\n      return string\n   end\n   local palindrome = string\n   local\
    \ length = #string\n   while length > 0 do\n      if string.sub(palindrome, length\
    \ -1, length) ~= string.reverse(string) then\n         length = length - 1\n \
    \     else\n         palindrome = palindrome .. string.sub(string, 0, length -\
    \ 1) .. string.reverse(string.sub(string, 0, length - 1))\n      end\n   end\n\
    \   return palindrome\nend", "  if string == nil then return '' end\n  local postfix\
    \ = string\n  while true do\n    local substring = string.sub(postfix, 1, string.len(postfix)\
    \ - 1)\n    local reversed_substring = string.sub(string.upper(substring), 1,\
    \ 1)\n    if postfix ~= reversed_substring then break\n    end\n    postfix =\
    \ string.sub(postfix, 1, string.len(postfix) - 1) + reversed_substring\n  end\n\
    \  local result = string.sub(postfix, 1, string.len(postfix) - 1) .. substring\n\
    \  if #result == 0 or #result == string.len(result) then\n    return string\n\
    \  end\n  return make_palindrome(string.sub(result, 1))\nend", "   -- If the string\
    \ is empty or just whitespace, just return the empty string.\n   if string ==\
    \ '' or\n      string:sub(1,1) == '\\n' or\n      string:sub(1,1) == '\\r' then\n\
    \      return ''\n   end\n   local result = {}\n   -- Find the longest postfix\
    \ of supplied string that is a palindrome.\n   -- Algorithm idea is simple:\n\
    \   -- - Find the longest postfix of supplied string that is a palindrome.\n \
    \  -- - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n   for i = 1, #string do\n      -- Construct\
    \ the postfix from the previous char.\n      result[i] = string[#string-1-i]\n\
    \   end\n   -- Reverse the string\n   local reversed = reverse(string)\n   --\
    \ Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n   -- Algorithm idea is simple:\n   -- - Find the longest\
    \ postfix of supplied string that is a palindrome.\n   -- - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \   for i = 1, #string do\n      result[i] = reversed[i]\n   end\n   -- Construct\
    \ the palindrome from the result.\n   for i = #result+1, #string do\n      result[i]\
    \ = string[i]\n   end\n   return table.concat(result, \"\")\nend", "  if string\
    \ == nil then return string end\n  local string = string.gsub(string, '[^' ..\
    \ string.char(127) .. ']', '')\n  local palindrome = string\n  while true do\n\
    \    local postfix = palindrome\n    palindrome = palindrome .. string.reverse(palindrome)\n\
    \    if string.len(palindrome) == string.len(postfix) then\n      return palindrome\n\
    \    end\n  end\nend", "  local palindrome = \"\"\n  local prefix\n  local suffix\n\
    \  local length\n  local i\n  \n  -- Find the longest postfix that is a palindrome.\n\
    \  for i = 1, #string do\n    -- Ignore whitespace.\n    if string[i] == \" \"\
    \ then\n      i = i + 1\n      -- Ignore newline characters at end of string.\n\
    \      if i == #string then\n        break\n      end\n      -- Ignore leading\
    \ space.\n      if string[i] ~= \" \" then\n        break\n      end\n    end\n\
    \    length = i\n    \n    -- Find the longest postfix that is a palindrome.\n\
    \    if length == 1 then\n      suffix = string\n    else\n      suffix = string[#string\
    \ - length]\n    end\n    \n    -- Reverse the suffix that comes before the palindromic\
    \ suffix.\n    prefix = string[#string - length - 1]\n    \n    -- Add the reverse\
    \ of the suffix.\n    palindrome = palindrome .. string[#string - length]\n  \
    \  \n    -- Add the reverse of the prefix.\n    palindrome = palindrome .. string[#string\
    \ - length + length]\n    \n    -- Add the prefix.\n    palindrome = palindrome\
    \ .. prefix\n    \n    -- Add the suffix.\n    palindrome = palindrome .. suffix\n\
    \  end\n  \n  -- Remove trailing newline character.\n  -- TODO: Not sure this\
    \ is necessary after testing this on Linux.\n  -- This seems to be the best way\
    \ to remove it.\n  -- Also see \"palindrome = string_reverse(string.gsub(string,\
    \ '\\n$', ''))\" below.\n  -- palindrome = string_reverse(palindrome)\n  \n  return\
    \ palindrome\nend", "    if not string then\n        string = 'cata'\n    end\n\
    \    local palindrome = ''\n    for i = 1, string.lenth, 1 do\n        palindrome\
    \ = string.sub(i, string.lenth) .. string.rev(palindrome)\n    end\n    return\
    \ palindrome\nend", "    local maxlen = 1\n    for i = 1, #string do\n       \
    \ if string.sub(i, i) ~= string.sub(string:sub(i, i), i, i) then\n           \
    \ maxlen = i\n            break\n        end\n    end\n    if maxlen == 0 or string.sub(string,\
    \ #string, #string) ~= string.sub(string:sub(maxlen - 1, maxlen), maxlen + 1,\
    \ maxlen) then\n        return string\n    end\n    local pal = string\n    local\
    \ start = 1\n    while #pal > 1 do\n        local substr = pal .. string.sub(string,\
    \ start, start + maxlen - 1)\n        pal = string.sub(substr, 1, #substr - 1)\n\
    \        start = start + maxlen - 1\n    end\n    return pal\nend", "    local\
    \ palindrome_prefix = string\n    for i = 1, math.floor(#string / 2) do\n    \
    \    local postfix = string.sub(string,i,i)\n        local postfix_reverse = postfix\
    \ .. string.sub(string,i,math.floor(#string / 2) - i + 1)\n        if postfix_reverse\
    \ == palindrome_prefix then\n            palindrome_prefix = postfix\n       \
    \ else\n            return palindrome_prefix\n        end\n    end\n    return\
    \ palindrome_prefix\nend", "    -- Find the longest postfix that is a palindrome\n\
    \    local longest_postfix = string\n    for i = 1, #string, 1 do\n        local\
    \ first_part = string\n        local second_part = string\n        local suffix\
    \ = 1\n        local i = i\n        while i <= #first_part do\n            local\
    \ new_first_part = first_part:sub(i, i)\n            local new_second_part = first_part:sub(i\
    \ + 1, i + 1)\n            -- Find the longest postfix that is palindromic\n \
    \           if new_second_part == new_first_part:reverse() then\n            \
    \    second_part = new_second_part\n                longest_postfix = first_part:sub(1,\
    \ i - 1)\n            end\n            i = i + 1\n        end\n        -- Reverse\
    \ the string\n        local reversed_second_part = second_part:reverse()\n   \
    \     second_part = reversed_second_part\n        -- Append to the end of the\
    \ string\n        local reversed_longest_postfix = longest_postfix:reverse() +\
    \ second_part\n        longest_postfix = reversed_longest_postfix\n    end\n \
    \   -- Return the full string\n    return longest_postfix\nend", "    local longest,\
    \ longestLength = 1, 0\n    for _,c in string.gmatch(\"(.-)%w+\") do\n       \
    \ local reversed = c:reverse()\n        if reversed == c then\n            longest\
    \ = 1 + longest\n        else\n            longestLength = longestLength or (longestLength\
    \ > #c) and #c or #reverse - 1\n        end\n    end\n    longest = longest or\
    \ 0\n    return string..string[longest:reverse()]\nend", "   local palindrome\
    \ = \"\"\n   local palindromePrefix = string.sub(string, 1, string.len(string))\n\
    \   for i = 1, string.len(string) do\n      local substring = string.sub(string,\
    \ 1, i - 1) -- The last character of the palindrome is the \"right\" end of the\
    \ string.\n      local reversed = string.reverse(substring) -- Reverse the substring\
    \ to get it palindrome.\n      palindrome = palindrome..reversed..substring\n\
    \   end\n   return palindromePrefix..palindrome\nend", "\t-- This code is modified\
    \ version of code from https://www.geeksforgeeks.org/longest-palindromic-substring-given-string/\n\
    \t-- The difference is this code works with long strings (for example 'cataaaacat')\
    \ while original code works only with small strings (for example 'cata')\n\t--\
    \ The original code was written in Russian, so I translated it to English.\n\t\
    -- And this code was written by Akinojim O. Osenov.\n\t-- The original code was\
    \ written by Ivo V. Karlovskiy and Ivo S. Osenov.", "    local longest, longestPos,\
    \ longestPrefix = {}, 0, 0\n    for i=1, #string, 1 do\n        local suffix =\
    \ string\n        if i > 1 then\n            suffix = string.sub(string, i - 1,\
    \ 1)\n        end\n        local reversed, reversedPos, reversedPrefix = {}, 0,\
    \ 0\n        for j=i-1, 1, -1 do\n            if j == i - 1 then\n           \
    \     reversedPos = i - 1\n            else\n                reversedPos = j\n\
    \            end\n            local reversed = string.sub(string, i, j)\n    \
    \        if reversed ~= suffix then\n                reversedPrefix = reversedPos\n\
    \            end\n        end\n        if longestPos ~= -1 and reversedPrefix\
    \ ~= longestPrefix then\n            break\n        end\n        longest = suffix\n\
    \        longestPos = longestPos\n        longestPrefix = reversedPrefix\n   \
    \ end\n    local palindrome = string.sub(string, longestPrefix + longest)\n  \
    \  return palindrome\nend", "    local palindrome = string.gsub(string, '(.)(.)',\
    \ '$2')\n    local reversed = string.gsub(string, '^.(.)', '$1')\n    return reverse\
    \ .. palindrome .. reversed\nend\n</code>\n<|/ a tags=lua,string-matching |>\n\
    <| c |>\nThis is probably the best answer out there. By the way, your second function\
    \ can be written: `function make_palindrome(s)  return s:gsub('(.)(.)', '$2')\
    \ + s:gsub('^.(.)', '$1')`\n<|/ c |>\n<| c |>\nI agree. Nice one. Thanks.\n<|/\
    \ c |>\n<| c |>\nThis works, but it is very inefficient for strings longer than\
    \ `10^6`, see my answer for an efficient solution.\n<|/ c |>\n<| c |>\n, thank\
    \ you for providing your solution, but I did try my own and it also works. I did\
    \ add some more explanation in my solution, but I do agree with the efficiency\
    \ of your solution. My solution is not \"simple\", but is also efficient.\n<|/\
    \ c |>\n<| a dscore=2 tags=lua,string-matching |>\nAn efficient implementation\
    \ would be:\n<code>", "  if string == '' then return string end", "\t-- If no\
    \ string is supplied, return empty string.\n\t-- >>> make_palindrome('')\n\t--\
    \ ''\n\t-- >>> make_palindrome('cat')\n\t-- 'catac'\n\t-- >>> make_palindrome('cata')\n\
    \t-- 'catac'\n\tif string == nil then\n\t\treturn ''\n\tend\n\t-- Reverse supplied\
    \ string, so we can compare with reverse of the reversed string.\n\tlocal reversed_string\
    \ = string.gsub(string, '%a', ''):reverse()\n\t-- If there is no palindrome, the\
    \ string is empty or contains only alphanumerics.\n\tif not string or string.len(string)\
    \ == 0 or string.match('%a^%s+', string) or not string.match('^[a-z0-9]*$', string)\
    \ then\n\t\treturn string\n\tend\n\t-- We know string is palindrome, so find the\
    \ longest postfix of string\n\t-- that is a palindrome.\n\tlocal max_length =\
    \ 0\n\tlocal max_length_palindrome = -1\n\tfor i = string.len(string) - 1, 1,\
    \ -1 do\n\t\tlocal substring = string.sub(i, 1, i)\n\t\tlocal suffix = string.reverse(substring)\n\
    \t\t-- If suffix is palindromic, it is the palindrome.\n\t\tif string.match(suffix\
    \ .. suffix .. '$', reversed_string) then\n\t\t\tif max_length == -1 or max_length\
    \ < string.len(suffix) then\n\t\t\t\tmax_length = string.len(suffix)\n\t\t\t\t\
    max_length_palindrome = i\n\t\t\tend\n\t\tend\n\tend\n\t-- Return the original\
    \ string if the longest postfix is 0.\n\t-- >>> make_palindrome('cat')\n\t-- 'cat'\n\
    \tif max_length == 0 then\n\t\treturn string\n\tend\n\t-- Append to the end of\
    \ the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \tlocal string_prefix = string.sub(string, 0, max_length_palindrome)\n\treturn\
    \ string_prefix .. string.reverse(string_prefix .. string.sub(string,max_length_palindrome\
    \ + 1, string.len(string)))\nend", "\t-- The palindrome starts after the end of\
    \ a string.\n\t-- For example, cata is reverse of catac, and catac is a palindrome.\n\
    \t-- Reverse of a string can be calculated using \"reverse\" function.\n\tlocal\
    \ reversed = string.gsub(string, \"..\", function(s)\n\t\treturn string.gsub(s,\
    \ \"(.)(.)\", function(c1, c2)\n\t\t\treturn string.format(\"%1s%2s\", string.char(c1),\
    \ string.char(c2):reverse())\n\t\tend)\n\tend)\n\t-- Find out where in the string\
    \ reversed string is located.\n\tlocal palindrome_idx = string.find(reversed,\
    \ string.reverse(string.sub(string, 1, string.len(string) - 1)), 1)\n\t-- Append\
    \ reverse of a string that comes before the palindromic suffix.\n\treturn string.sub(string,\
    \ 1, palindrome_idx-1..-1)..string.reverse(string.sub(reversed, palindrome_idx))\n\
    end", "  -- If the string is a palindrome.\n  if string == string.gsub(string,\
    \ \"^\" .. string, \"$\" .. string) then\n    return string\n  else\n    -- Find\
    \ the longest postfix of the supplied string that is a palindrome.\n    local\
    \ longest_postfix = ''\n    for i = 1, string.len(string) do\n      longest_postfix\
    \ = longest_postfix .. string[string.len(string) - i - 1] .. string[i]\n     \
    \ if longest_postfix == string.gsub(longest_postfix, \"^\" .. longest_postfix,\
    \ \"$\" .. longest_postfix) then\n        return string.gsub(longest_postfix,\
    \ \"^\" .. longest_postfix, \"$\" .. longest_postfix)\n      end\n    end\n  end\n\
    end", "    local longest, longestPrefix, longestSuffix = string_reverse(string_reverse(string)),\
    \ string, string\n    -- Find longest postfix\n    for i = #string + 1, 1, -1\
    \ do\n        local postfix = string_reverse(string_reverse(string:sub(i, i)))\n\
    \        if longest ~= postfix then\n            longest, longestPrefix, longestSuffix\
    \ = postfix, string, postfix\n        end\n    end\n    return longestPrefix ..\
    \ longestSuffix\nend", "  local palindrome = ''\n  local longest_prefix = 0\n\
    \  local longest_suffix_start = 0\n  local longest_suffix_end = 0\n  local postfix_length\
    \ = 0\n  for i = 1, #string do\n    local c = string.sub(string,i,i)\n    if c\
    \ == string.sub(string, i, i) then\n      postfix_length = postfix_length + 1\n\
    \      if postfix_length > longest_prefix then\n        longest_prefix = postfix_length\n\
    \        longest_suffix_start = i - postfix_length\n        longest_suffix_end\
    \ = i\n      else\n        postfix_length = 1\n      end\n    elseif c == 'a'\
    \ and (string.sub(string,i - 1,i) == string.sub(string,longest_suffix_start -\
    \ 1,longest_suffix_start - 1) or\n                   string.sub(string,i - 1,i)\
    \ == string.sub(string,longest_suffix_end - 1,longest_suffix_end - 1)) then\n\
    \      postfix_length = 0\n    end\n  end\n  if longest_prefix > 0 then\n    palindrome\
    \ = string.sub(string, longest_suffix_start - longest_suffix_end, longest_suffix_start\
    \ + longest_suffix_end + longest_prefix)\n  end\n  return palindrome\nend", " \
    \   local pal = string\n    local len = #string", "\t-- Initialize our result\
    \ to an empty string.\n\tlocal result = string\n\t-- If the string is empty, return\
    \ it unchanged.\n\tif string == '' then\n\t\treturn string\n\tend\n\t-- Find the\
    \ longest postfix that is a palindrome.\n\tlocal postfix, longest, longest_end\n\
    \tfor i = 1, #string do\n\t\t-- If the character at the current index is equal\
    \ to the character at the next index, we found a palindrome.\n\t\tif string[i]\
    \ == string[i + #string] then\n\t\t\t-- If we are at the end of the string, return\
    \ it unchanged.\n\t\t\tif i == #string then\n\t\t\t\treturn string\n\t\t\tend\n\
    \t\t\t-- If the length of the postfix is greater than the length of the longest,\
    \ replace it.\n\t\t\tif #postfix > #longest then\n\t\t\t\tlongest = #postfix\n\
    \t\t\t\tpostfix = string\n\t\t\t\tlongest_end = i\n\t\t\tend\n\t\t\t-- Otherwise,\
    \ just append the character at the current index.\n\t\telse\n\t\t\t-- Append the\
    \ character at the current index.\n\t\t\tpostfix = string..string[i]\n\t\t\t--\
    \ If we are at the end of the string, return it unchanged.\n\t\t\tif i == #string\
    \ then\n\t\t\t\treturn string\n\t\t\tend\n\t\tend\n\tend\n\t-- Append the reverse\
    \ of the postfix from the start of the string to the end of the longest postfix\
    \ found above.\n\treturn string..string.sub(postfix, 1, longest)..string.sub(postfix,\
    \ longest_end + 1)\nend", "    local palindrome = ''\n    local longest = ''\n\
    \    for i = 1, #string do\n        if string[i] ~= string[#string - 1 - i] then\n\
    \            longest = longest .. string[i]\n        end\n    end\n    for i =\
    \ 1, #string do\n        if string[#string - 1 - i] == string[i] then\n      \
    \      local t = string[#string - 1 - i]\n            string[#string - 1 - i]\
    \ = string[i]\n            string[i] = t\n        end\n    end\n    if longest\
    \ ~= '' then\n        longest = longest .. reverse(string:sub(1, longest:len()\
    \ - 1))\n    end\n    palindrome = string .. longest\nend", "  if string == ''\
    \ then\n    return string\n  elseif string[#string] ~= 'c' then\n    return string\n\
    \  else\n    -- Find longest postfix of string that is a palindrome.\n    -- Reverse\
    \ the postfix to find the shortest prefix that starts with it.\n    local prefix\
    \ = string\n    local postfix = string\n    repeat\n      postfix = postfix, string\n\
    \      postfix = postfix:reverse()\n    until postfix:sub(1, #prefix) == prefix\
    \ and #postfix > 0", "  -- Optimization to return early when there is only one\
    \ character.\n  local i = string.len()\n  if i == 1 then\n    return string\n\
    \  end", "    local longest = \"\"\n    local prefix_length = 0\n    local suffix_length\
    \ = 0\n    local suffix = string.sub(string, 1, string.len(string) - 2)\n    local\
    \ i = 0", "\tlocal longest, longestLen, longestPos = -1, -1, -1\n\tfor i = 1,\
    \ #string do\n\t\tlocal sub = string.sub(i, string.len() - i)\n\t\tlocal prefix\
    \ = string.sub(i, 1, string.len() - i)\n\t\tlocal suffix, suffixLen = sub, sub:len()\n\
    \t\tif suffix:reverse():sub(1, suffixLen) == prefix then\n\t\t\tlongest = sub\n\
    \t\t\tlongestLen = suffixLen\n\t\t\tlongestPos = i\n\t\tend\n\tend\n\tif longest\
    \ == \"\" then\n\t\treturn string\n\tend\n\treturn string..string.sub(longest,\
    \ 1, longestLen - longest)\nend", "\tlocal suffix_length = #string - #reverse(string)\n\
    \tlocal start_length = 0", "    local max_len = len(string)\n    local max_len_palindrome\
    \ = max_len - 1\n    local max_len_string = max_len - 1", "  if string == nil\
    \ then\n    return ''\n  end\n  local function helper(string, prefix, suffix)\n\
    \    prefix = prefix or ''\n    suffix = suffix or ''\n    local reversed = table.concat(string.gmatch('(['\
    \ .. string.gsub(string, '(%w+)', '%1,%1') .. ']+)'), '')\n    if reversed ==\
    \ suffix then\n      return prefix + suffix\n    end\n    if reversed:find('%,')\
    \ ~= nil then\n      local prefix = string.sub(string, 1, string.find(reversed,\
    \ '%,')-1)\n      local suffix = string.sub(string, string.find(reversed, '%,')+1)\n\
    \      return helper(prefix, prefix, suffix) or helper(prefix, suffix, prefix)\n\
    \    end\n    return helper(prefix, prefix, reversed)\n  end\n  return helper(string.gsub(string.gsub(string.gsub(string,\
    \ string.gsub('(%w+)', '%1,%1'), '(%w+)', '%1,%1'), '(%w+)', '%1,%1'), '(%w+)',\
    \ '%1,%1')\nend", "  if not string then return string end\n  local maxlen = -1\n\
    \  local palindrome = \"\"\n  for _, c in ipairs(string) do\n    local len = length(c)\n\
    \    if len > maxlen then maxlen = len end\n    if palindrome:sub(1, len) ~= c\
    \ then\n      palindrome = palindrome..c:reverse()..c\n    end\n  end\n  return\
    \ palindrome\nend", "  -- if there is no palindrome, then return original string\n\
    \  if string ~= '' and palindrome(string) then\n    return string\n  end", "\t\
    local postfix = string\n\tlocal reversed_postfix = ''\n\tfor i = #postfix, 1,\
    \ -1 do\n\t\tlocal letter = postfix:sub(i, i)\n\t\treversed_postfix = reversed_postfix\
    \ + letter\n\tend\n\tlocal palindrome = reversed_postfix + string\n\tif palindrome\
    \ == string then\n\t\treturn string\n\telse\n\t\treturn palindrome\n\tend\nend",
  "   -- If string is empty, return empty string\n   -- If string is already a palindrome,\
    \ return string\n   if not string then\n      return ''\n   end\n   -- Create\
    \ reverse string from string by removing letters and adding them back\n   -- while\
    \ removing letters from end of string\n   local reverse_string = ''\n   for i\
    \ = #string, 1, -1 do\n      local letter = string.sub(string, i, i)\n      reverse_string\
    \ = reverse_string .. letter\n   end\n   reverse_string = reverse_string.reverse()\n\
    \   -- If original string doesn't end with postfix of palindromic string,\n  \
    \ -- return original string since it is not palindrome\n   if not string.sub(string:reverse(),\
    \ 1, #string) == reverse_string then\n      return string\n   end\n   -- If string\
    \ begins with supplied string, return palindromic string\n   return reverse_string\
    \ .. string\nend", "  if string == '' then\n    return ''\n  end", "  if string\
    \ == '' then return string end\n  local reversed = string\n  local prefix = string\n\
    \  local suffix = string\n  local length = #string\n  for i = 2, length do\n \
    \   local postfix = prefix:sub(1, -i)\n    local palindrome = postfix .. reversed:sub(-i,\
    \ i)\n    if palindrome == reversed then return palindrome end\n    prefix = postfix\n\
    \    reversed = palindrome\n  end\n  error()\nend", "    local palindrome_string\
    \ = string\n    local max_len = #string\n    local min_len = max_len - 1 -- longest\
    \ postfix of string is also a palindrome\n    local index = 1\n    local found_first_palindrome\
    \ = false\n    while palindrome_string ~= '' do\n        if min_len > #palindrome_string\
    \ then break end\n        local letter = palindrome_string[index]\n        palindrome_string\
    \ = palindrome_string:gsub(string, '') -- Remove letter\n        if letter ==\
    \ letter:reverse then\n            index = index + 1\n            min_len = min_len\
    \ - 1 -- The letter is the longest palindrome in the string\n        else\n  \
    \          index = index + 1\n            min_len = min_len + 1\n        end\n\
    \    end\n    if palindrome_string ~= '' then\n        palindrome_string = palindrome_string:sub(1,\
    \ index) -- Remove first letter\n        palindrome_string = palindrome_string:reverse\
    \ -- Add reverse letter\n    end\n    return palindrome_string\nend\nreturn {\n\
    \    make_palindrome = make_palindrome\n}\n</code>\n<|/ a tags=lua,string,algorithm\
    \ |>\n<| a dscore=2 |>\nHere's my take on it.\n<code>", "    local length = #string\n\
    \    local string1 = string\n    local string2 = string\n    local prefix = ''\n\
    \    local suffix = ''\n    local reversedString\n    while length ~= 0 do\n \
    \       if string.sub(string1, length - 1, length) == string.sub(string1, length\
    \ - 1, length - 1) then\n            -- This string is a palindrome and we found\
    \ the longest postfix.\n            -- Append the longest postfix to the end and\
    \ continue searching for another palindrome\n            prefix = string1 .. prefix\n\
    \            string1 = string.sub(string1, 1, length - 1)\n            string2\
    \ = string1 .. string2\n            length = length - 1\n        else\n      \
    \      -- This string is not a palindrome, so continue searching for a palindrome\n\
    \            string1 = string.sub(string1, length - 1)\n            string2 =\
    \ string1 .. string2\n            length = length - 1\n        end\n    end",
  "  if string == '' then\n    return string\n  else\n    local start = string\n \
    \   local end = string\n    local reverse = ''\n    for i = #start do\n      local\
    \ char = start[#start - i]\n      if char == '~' then\n        -- Check if there\
    \ is a palindromic suffix.\n        if #end > 0 then\n          -- Start with\
    \ reversed suffix\n          reverse = reverse .. end\n          -- Remove prefix\
    \ from end\n          -- and reverse this prefix.\n          start = #start -\
    \ i - 1\n          local suffix = start\n          for j = #start do\n       \
    \     suffix = suffix .. start[j]\n          end\n          reverse = reverse\
    \ .. suffix\n          -- Move forward the length of the suffix.\n          start\
    \ = #end - 1\n        end\n      else\n        -- Append char\n        reverse\
    \ = reverse .. char\n      end\n    end\n    \n    return start..reverse\n  end\n\
    end", "  -- Find the longest palindromic suffix.\n  local longest = string\n \
    \ repeat\n    longest = longest .. string\n  until palindrome(longest)", "  --\
    \ Find the longest postfix of supplied string that is a palindrome.\n  -- Algorithm\
    \ idea is simple:\n  -- - Find the longest postfix of supplied string that is\
    \ a palindrome.\n  -- - Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n  local length = 0\n  local i = 0\n\
    \  while i <= (string:len()) do\n    length = length + 1\n    i = i + 1\n    local\
    \ postfix = string:sub(i, i)\n    local reverse = postfix:reverse()\n    if reverse\
    \ == postfix then\n      return string\n    elseif reverse ~= '' then\n      string\
    \ = string .. reverse\n      length = length - 1\n      i = i - 1\n    end\n \
    \ end\n  return string\nend", "    local longest, longest_palindrome, longest_suffix\
    \ = {}, {}, \"\"\n    for i = #string, 0, -1 do\n        local j = math.max(0,\
    \ #string - i)\n        local suffix, prefix = string:sub(i, j), string:sub(j,\
    \ i)\n        if suffix:reverse():sub(1, #suffix) = prefix then\n            longest[#longest+1]\
    \ = suffix\n            longest_palindrome[#longest_palindrome+1] = prefix\n \
    \           longest_suffix[#longest_suffix+1] = suffix\n        end\n    end\n\
    \    longest[#longest+1] = string:reverse()\n    longest_palindrome[#longest_palindrome+1]\
    \ = longest[#longest]\n    longest_suffix[#longest_suffix+1] = longest[#longest]\n\
    \    return string..longest[#longest]..longest_palindrome[#longest_palindrome]..longest_suffix[#longest_suffix]\n\
    end", "    local postfix = \"\"\n    local len = 0\n    for i = 1, #string do\n\
    \        postfix = string[#string]..postfix\n        len = len + 1\n    end\n\
    \    local reverse = \"\"\n    local palindrome = \"\"\n    for i = 1, len do\n\
    \        reverse = reverse..string[len-i-1]\n    end\n    while reverse ~= string[#string]\
    \ and #palindrome < #string do\n        reverse = reverse..string[#string]\n \
    \   end\n    for i = 1, #palindrome do\n        palindrome = palindrome..string[i]\n\
    \    end\n    return palindrome..postfix\nend", "  local suffix = ''\n  local\
    \ suffix_size = #string\n  while suffix_size do\n    suffix, suffix_size = string:sub(0,\
    \ suffix_size-1), suffix_size-1\n    if suffix:reverse() == suffix then return\
    \ string .. suffix end\n  end\n  return ''\nend", "  -- If the string is empty,\
    \ just return empty string.\n  if not string then\n    return ''\n  end\n  --\
    \ The longest postfix that is a palindrome.\n  local max_len = string.len()\n\
    \  -- The length of the shortest prefix that comes before the longest postfix.\n\
    \  local min_len = max_len - string.sub(string, (max_len - 1))\n  -- The shortest\
    \ prefix that comes before the longest postfix.\n  local prefix_len = min_len\
    \ - 1\n  -- The reverse of the shortest prefix.\n  local prefix_reverse = string.sub(string,\
    \ prefix_len)\n  -- The suffix of the longest postfix that is a palindrome.\n\
    \  local suffix_reverse = string.sub(string, 0, prefix_len)\n  -- The prefix of\
    \ the longest postfix that is a palindrome.\n  local prefix_reverse = string.sub(string,\
    \ 0, prefix_len)\n  -- The longest postfix that is a palindrome.\n  local max_len\
    \ = string.len()\n  -- The length of the shortest prefix that comes before the\
    \ longest postfix.\n  local min_len = max_len - string.sub(string, (max_len -\
    \ 1))\n  -- The shortest prefix that comes before the longest postfix.\n  local\
    \ prefix_len = min_len - 1\n  -- The reverse of the shortest prefix.\n  local\
    \ prefix_reverse = string.sub(string, prefix_len)\n  -- The suffix of the longest\
    \ postfix that is a palindrome.\n  local suffix_reverse = string.sub(string, 0,\
    \ prefix_len)\n  -- The prefix of the longest postfix that is a palindrome.\n\
    \  local prefix_reverse = string.sub(string, 0, prefix_len)\n  -- The longest\
    \ postfix that is a palindrome.\n  local max_len = string.len()\n  -- The length\
    \ of the shortest prefix that comes before the longest postfix.\n  local min_len\
    \ = max_len - string.sub(string, (max_len - 1))\n  -- The shortest prefix that\
    \ comes before the longest postfix.\n  local prefix_len = min_len - 1\n  -- The\
    \ reverse of the shortest prefix.\n  local prefix_reverse = string.sub(string,\
    \ prefix_len)\n  -- The suffix of the longest postfix that is a palindrome.\n\
    \  local suffix_reverse = string.sub(string, 0, prefix_len)\n  -- The prefix of\
    \ the longest postfix that is a palindrome.\n  local prefix_reverse = string.sub(string,\
    \ 0, prefix_len)\n  -- The longest postfix that is a palindrome.\n  local max_len\
    \ = string.len()\n  -- The length of the shortest prefix that comes ", "    local\
    \ string_reverse = string\n    local string_prefix = string\n    while true do\n\
    \        local start_index = string_reverse:find(string_prefix, 1, true)\n   \
    \     if start_index == nil then\n            break\n        end\n        string_reverse\
    \ = string_reverse:sub(start_index, string_reverse:len())\n        string_reverse\
    \ = string_reverse:reverse()\n        string_reverse = string_reverse:gsub(\"\
    %S\", \"\")\n        string_prefix = string_prefix:sub(1, string_prefix:len())\n\
    \    end\n    return string_reverse .. string_prefix\nend", "\tlocal postfix =\
    \ string.match(reverse(string), '..$') or '0'\n\treturn string..(reverse(string.match(reverse(string),\
    \ '.-..'))..postfix)\nend", "    local prefix_length, suffix_length = 0, 0\n \
    \   local max_prefix_length, max_suffix_length = 0, 0\n    local string = string\n\
    \    for i = 1, #string do\n        local prefix_start = string.len\n        local\
    \ prefix_end = string.len\n        local suffix_start = string.len\n        local\
    \ suffix_end = string.len\n        while prefix_end - prefix_start > suffix_end\
    \ - suffix_start do\n            prefix_length = prefix_end - prefix_start + 1\n\
    \            suffix_length = suffix_end - suffix_start + 1\n            if string[prefix_end\
    \ - prefix_start - 1] == string[suffix_end - suffix_start - 1] then\n        \
    \        max_prefix_length = prefix_length - 1\n                max_suffix_length\
    \ = suffix_length - 1\n            elseif prefix_length > suffix_length then\n\
    \                max_prefix_length = prefix_length\n                max_suffix_length\
    \ = suffix_length\n            else\n                max_prefix_length = suffix_length\n\
    \                max_suffix_length = prefix_length\n            end\n        \
    \    prefix_end = prefix_start + (prefix_end - prefix_start) / 2 - (prefix_end\
    \ - prefix_start) % 2\n            suffix_end = suffix_start + (suffix_end - suffix_start)\
    \ / 2 - (suffix_end - suffix_start) % 2\n        end\n        local reversed_string\
    \ = string\n        for j = prefix_start, string.len do\n            reversed_string[j]\
    \ = string[#reversed_string]\n        end\n        local postfix_start = string.len\
    \ - max_suffix_length\n        local postfix_end = string.len\n        while postfix_end\
    \ - postfix_start > reversed_string.len do\n            postfix_length = postfix_end\
    \ - postfix_start + 1\n            if postfix_length == reversed_string.len then\n\
    \                postfix_start = postfix_end - postfix_length\n            else\n\
    \                postfix_start = postfix_end - postfix_length + 1\n          \
    \  end\n            postfix_end = postfix_start + postfix_length\n        end\n\
    \        local new_string = ''\n        for j = 1, postfix_start do\n        \
    \    new_string = new_string .. reversed_string[j]\n        end\n        local\
    \ palindrome = string.sub(string, 1, string.len(new_string))\n        string =\
    \ string.sub(string, string.len(new_string) + 1, string.len)\n        string.str\
    \ = string\n        local suffix_str = string\n        for j = 1, #suffix_str\
    \ do\n            suffix_str = suffix_str .. string[j]\n        end\n        string.str\
    \ = string\n        string.str = suffix_str\n        string.str = new_string\n\
    \        string.str = palindrome\n        if #new_string > 0 then\n          \
    \  local palindrome = string.sub(string, 1, string.len(new_string))\n        \
    \    string.str = string\n            string.str = suffix_str\n            string.",
  "    local max_suffix_len = #string - (#string % 2)\n    local prefix_len = #string\n\
    \    local palindrome = \"\"\n    local max_suffix_end_index\n    for i = 1, max_suffix_len\
    \ do\n        local suffix_end_index = max_suffix_end_index\n        if suffix_end_index\
    \ <= prefix_len then\n            suffix_end_index = prefix_len\n        end\n\
    \        local suffix = string[suffix_end_index - 1, suffix_end_index]\n     \
    \   if suffix ~= suffix then\n            suffix_end_index = prefix_len\n    \
    \    else\n            suffix_end_index = prefix_len - 1\n        end\n      \
    \  local prefix = string[suffix_end_index, prefix_len - suffix_end_index + 1]\n\
    \        if prefix ~= prefix then\n            local index_offset = max_suffix_end_index\
    \ - suffix_end_index\n            if index_offset > 0 then\n                suffix_end_index\
    \ = prefix_len + index_offset\n            end\n        end\n        local suffix\
    \ = string[suffix_end_index, suffix_end_index + 1]\n        if suffix ~= suffix\
    \ then\n            suffix_end_index = prefix_len\n        else\n            suffix_end_index\
    \ = prefix_len + 1\n        end\n        local prefix = string[suffix_end_index,\
    \ prefix_len - suffix_end_index + 1]\n        if prefix ~= prefix then\n     \
    \       local index_offset = max_suffix_end_index - suffix_end_index\n       \
    \     if index_offset > 0 then\n                suffix_end_index = prefix_len\
    \ + index_offset\n            end\n        end\n        local suffix = string[suffix_end_index,\
    \ suffix_end_index + 1]\n        if suffix ~= suffix then\n            suffix_end_index\
    \ = prefix_len\n        else\n            suffix_end_index = prefix_len + 1\n\
    \        end\n        if suffix ~= suffix then\n            local index_offset\
    \ = max_suffix_end_index - suffix_end_index\n            if index_offset > 0 then\n\
    \                suffix_end_index = prefix_len + index_offset\n            end\n\
    \        end\n        palindrome = palindrome .. suffix .. prefix\n        max_suffix_end_index\
    \ = suffix_end_index\n    end\n    return palindrome\nend", "\t-- if there is\
    \ no string\n\t-- return empty string\n\tif not string then\n\t\treturn ''\n\t\
    end\n\tlocal postfix = {}\n\t-- if there is no palindrome\n\tif palindrome_reverse[string]\
    \ then\n\t\treturn string\n\tend\n\t-- split string into suffix parts\n\t-- loop\
    \ over all suffixes and add postfix parts to the string\n\tfor i = 1, string.lenth,\
    \ 1 do\n\t\ttable.insert(postfix, string.sub(i, i))\n\tend\n\t-- reverse the postfix\
    \ parts\n\tfor i = #postfix, 1, -1 do\n\t\ttable.insert(postfix, postfix.slice(i))\n\
    \tend\n\t-- append reverse of the suffix\n\t-- loop over all prefix parts and\
    \ add reverse of the prefix parts to the string\n\tfor i = 1, #postfix, 1 do\n\
    \t\ttable.insert(postfix, palindrome_reverse[string.sub(#postfix, i)])\n\tend\n\
    \t-- return string\n\treturn table.concat(postfix, '')\nend", "  if string ==\
    \ nil then string = '' end\n  local palindrome = string\n  local prefix = ''\n\
    \  for i = 1, #string do\n    local postfix = string.sub(string, i, i)\n    if\
    \ postfix ~= reverse then\n      palindrome = palindrome .. reverse .. postfix\n\
    \    end\n    prefix = prefix .. string\n  end\n  return prefix .. palindrome\n\
    end", "  -- Find longest palindrome prefix.\n  local function find_longest_palindrome_prefix(string,\
    \ start_pos)\n    local max_start = start_pos\n    local max_end = 0\n    local\
    \ max_len = string\n    while string[max_start] and string[max_start] == string[max_end\
    \ - 1] do\n      max_end, max_len = max_start, string[max_start]\n      max_start\
    \ = max_start + 1\n    end\n    return max_start, max_len\n  end\n  -- Find the\
    \ longest palindrome suffix.\n  local function find_longest_palindrome_suffix(string,\
    \ end_pos, max_len)\n    local max_start = end_pos\n    local max_end = end_pos\n\
    \    local max_len = max_len\n    while string[max_start] and string[max_start]\
    \ == string[max_end - 1] do\n      max_end, max_len = max_start, string[max_start]\n\
    \      max_start = max_end + 1\n    end\n    return max_start, max_end, max_len\n\
    \  end\n  -- Find the longest postfix that is a palindrome.\n  local function\
    \ find_longest_postfix_that_is_palindrome(string, end_pos)\n    local max_start,\
    \ max_end, max_len = find_longest_palindrome_suffix(string, end_pos)\n    while\
    \ string[max_start] and string[max_start] == string[max_end - 1] do\n      max_start,\
    \ max_end, max_len = find_longest_palindrome_suffix(string, max_end, max_len)\n\
    \    end\n    return max_start, max_end\n  end\n  -- Find the shortest palindrome\
    \ that begins with a supplied string.\n  -- Algorithm idea is simple:\n  -- -\
    \ Find the longest postfix of supplied string that is a palindrome.\n  -- - Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n  local function find_shortest_palindrome_begins_with_string(string,\
    \ start_pos, end_pos)\n    local max_start, max_end, max_len = find_longest_postfix_that_is_palindrome(string,\
    \ end_pos)\n    while string[max_start] and string[max_start] == string[max_end\
    \ - 1] do\n      max_start, max_end, max_len = find_longest_postfix_that_is_palindrome(string,\
    \ max_end, max_len)\n    end\n    return max_start, max_end\n  end\n  local start_pos,\
    \ end_pos, max_len = find_shortest_palindrome_begins_with_string(string, 1, #string)\n\
    \  if string.sub(string, 1, start_pos) ~= string.sub(string, start_pos, end_pos)\
    \ then\n    -- The palindrome is not the whole string.\n    return nil\n  end",
  "  if string == '' then\n    return ''\n  end", "    local palindrome = string\n\
    \    local palindrome_start = string.find(string, \"[^\" .. string.rep(\"^\",\
    \ string.len(string)) .. \"]\")\n    while palindrome_start > 0 do\n        local\
    \ palindrome_suffix = string[palindrome_start + 1]\n        local palindrome =\
    \ palindrome .. reverse_string(palindrome_suffix:sub(1, #palindrome_suffix))\n\
    \        palindrome_start = string.find(palindrome, string, \"[^\" .. string.rep(\"\
    ^\", string.len(palindrome) - 1) .. \"]\")\n    end\n    return palindrome\nend",
  "\t-- We use dictionary to check for palindromes.\n\t-- So dictionary can have O(n)\
    \ complexity.\n\tlocal palindromes = {}\n\tfor i = 1, #string do\n\t\tlocal palindrome\
    \ = string\n\t\tlocal reverse_suffix = string\n\t\treverse_suffix = reverse_suffix:reverse()\n\
    \t\t-- Find the longest postfix that is a palindrome.\n\t\t-- We can reverse string\
    \ from tail to head.\n\t\tlocal suffix = ''\n\t\twhile true do\n\t\t\tsuffix =\
    \ '' .. palindrome .. suffix\n\t\t\tif suffix == reverse_suffix then\n\t\t\t\t\
    break\n\t\t\tend\n\t\t\t-- Prepend longest postfix to the reversed suffix.\n\t\
    \t\tpalindrome = suffix:reverse()\n\t\tend\n\t\t-- Append the reverse of palindrome\
    \ to the original suffix.\n\t\tpalindrome = suffix:reverse()\n\t\ttable.insert(palindromes,\
    \ palindrome)\n\tend\n\t-- Find the shortest palindrome in the dictionary.\n\t\
    -- This palindrome is also the shortest one!\n\tlocal min_palindrome = string\n\
    \tfor _, palindrome in ipairs(palindromes) do\n\t\tif min_palindrome == palindrome\
    \ then\n\t\t\tbreak\n\t\tend\n\t\tmin_palindrome = palindrome\n\tend\n\treturn\
    \ min_palindrome\nend", "\tlocal palindrome = string\n\tlocal prefix_len = #string\n\
    \twhile string.find(string, \"[%a]\") do\n\t\tlocal idx = string.find(string,\
    \ \"[%a]\")\n\t\tif idx == 0 then return end\n\t\tlocal substring = string.sub(string,\
    \ 1, idx - 1)\n\t\tlocal reversed_substring = string.sub(string, idx + 1)\n\t\t\
    palindrome = palindrome .. reversed_substring\n\t\tprefix_len = prefix_len - 1\n\
    \tend\n\treturn palindrome .. reverse(palindrome:sub(1, prefix_len))\nend", " \
    \   local result = ''\n    local suffix = ''\n    for i = 1,len(string) do\n \
    \       local character = string[i]\n        local prefix_length = i - 1\n   \
    \     local suffix_length\n        if suffix == \"\" then\n            suffix_length\
    \ = i\n        else\n            suffix_length = i - 1\n        end\n        local\
    \ reversed_suffix = string.reverse(suffix)\n        if suffix == reversed_suffix\
    \ then\n            result = result .. character\n        else\n            suffix\
    \ = reversed_suffix\n            result = result .. suffix .. character\n    \
    \    end\n    end\n    return result\nend", "   local palindrome = ''\n   local\
    \ longest_postfix = 1\n   local longest_prefix_len = 1\n   local longest_prefix_end\
    \ = 1\n   for i = 1, string.len, '+' do\n      if string.sub(string,i,i) ~= string.sub(string,i,i):reverse()\
    \ then\n         longest_postfix = i\n      else\n         longest_prefix_len\
    \ = i\n      end\n   end\n   if longest_postfix then\n      longest_prefix_end\
    \ = longest_prefix_len + longest_postfix + 1\n   end\n   local postfix = string.sub(string,1,longest_prefix_end)\n\
    \   palindrome = string.sub(string,longest_prefix_len-1,longest_prefix_end)\n\
    \   palindrome = string.concat(string.reverse(palindrome),postfix)\n   return\
    \ palindrome\nend", "    if string == '' then\n        return string\n    end",
  "    local max_len = string.len(string) - 2\n    local palindrome = \"\"\n    for\
    \ i = 1, string.len(string) do\n        if string.sub(string, 1, i) == string.rev(string.sub(string,\
    \ 1, i)) then\n            palindrome = string.sub(string, 1, i) + palindrome\n\
    \        else\n            break\n        end\n    end\n    return max_len + palindrome\n\
    end", "   -- Scan for longest palindrome (starting from middle of string).\n \
    \  -- If it is not a palindrome, return it.\n   local function longest_palindrome(string,\
    \ palindrome)\n      if string == palindrome then\n         return string\n  \
    \    elseif string.find(palindrome, \"^\") then\n         -- The start of the\
    \ string is the palindrome\n         return palindrome\n      else\n         local\
    \ prefix_start = string.len(palindrome) -- Scan for longest palindrome prefix\
    \ before the palindromic suffix\n         for _, char in ipairs(string) do\n \
    \           local prefix_len = string.len(palindrome)\n            if string.find(palindrome,\
    \ \"%\" and char ~= '^') then\n               -- The start of the palindrome is\
    \ the palindrome\n               return palindrome\n            elseif string.find(palindrome,\
    \ char) then\n               -- The start of the palindrome is different from\
    \ the palindrome\n               -- suffix because it is not at the beginning\
    \ of the string.\n               -- This is different from longest_palindrome(string,\
    \ palindrome) because that\n               -- will include char in the result.\n\
    \               prefix_start = prefix_len\n               return string.sub(string,\
    \ prefix_start, prefix_len + prefix_start)\n            end\n         end\n  \
    \       return string.sub(string, prefix_start)\n      end\n   end\n   local postfix,\
    \ palindrome = string.find(string, \"^\"), \"/\"\n   if not (postfix and palindrome)\
    \ then\n      return string\n   end\n   -- The longest postfix palindrome is the\
    \ one that comes before the palindromic suffix.\n   local longest_postfix = longest_palindrome(string,\
    \ postfix)\n   -- Append the reverse of longest postfix palindrome to the end\
    \ of the string.\n   return longest_postfix .. longest_palindrome(string, palindrome)\n\
    end", "   if string ~= string.gsub(string.gsub(string, '%a'):reverse(), '%d'):reverse()\
    \ then\n      return string\n   end\n   return ''\nend", "    local prefix = string.sub(string,\
    \ 1, 1)\n    local suffix = string.sub(string, string.len(string) - 1, 1)\n  \
    \  local suffix_reversed = suffix:reverse()\n    return prefix .. suffix_reversed\
    \ .. suffix\nend", "\tlocal palindrome = string\n\tlocal index = string.len(string)\
    \ - 2\n\twhile index >= 0 do\n\t\tlocal postfix = string.sub(string, index, index\
    \ + 1)\n\t\tif postfix ~= make_palindrome(postfix) then\n\t\t\tlocal suffix\n\t\
    \t\tindex = string.len(string) - index\n\t\t\tif index > 0 then\n\t\t\t\tsuffix\
    \ = string.sub(string, index, string.len(string))\n\t\t\telse\n\t\t\t\tsuffix\
    \ = \"\"\n\t\t\tend\n\t\t\tpalindrome = palindrome .. string.rep(suffix, string.len(postfix))\n\
    \t\tend\n\tend\n\treturn palindrome\nend", "    local string_palindrome = ''\n\
    \    local string_prefix = string\n    local string_postfix = string\n    local\
    \ string_prefix_index = -1\n    local string_postfix_index = -1\n    for string_prefix_index,string_prefix\
    \ in ipairs(string_prefix:gsub('^%..(.*)$', '%1%2')) do\n        local string_postfix\
    \ = string_prefix:reverse():gsub('^..%..(.*)$', '%1%2')\n        if string_postfix\
    \ and string_postfix ~= string_prefix then\n            if string.sub(string_postfix,1,1)\
    \ and string.sub(string_postfix,-1,1) ~= string.sub(string_prefix,1,1) then\n\
    \                -- This is impossible, just abort\n                return 'Error:\
    \ impossible prefix and suffix combination.'\n            else\n             \
    \   string_palindrome = string_palindrome .. string_prefix:reverse() .. string_postfix\n\
    \            end\n        end\n    end\n    return string_palindrome\nend", " \
    \ local palindrome_string = ''\n  local last_char = string.sub(string, -1)\n \
    \ for i = 1, string.len(string) - 1 do\n    -- If our test string is a palindrome,\
    \ then we know that the\n    -- first character will match the last character\
    \ for our palindrome.\n    if string.sub(string, 1, i) == last_char then\n   \
    \   palindrome_string = palindrome_string..string.sub(string, i, string.len(string))\n\
    \    end\n  end\n  return string..palindrome_string\nend", "\t-- We already know\
    \ that the string has a length greater than 0.\n\t-- We also know that if there\
    \ are any characters, they will be letters.\n\t-- We also know that the string\
    \ will never end with a letter or punctuation.\n\t-- If there are no letters in\
    \ the string, the return value will be the empty string.\n\treturn string.match('^[a-zA-Z]+$')\
    \ and string.match('^[a-zA-Z]+$') and\n\t\tstring.match('^[a-zA-Z]*(%a+)$', string)\
    \ and\n\t\tstring.match('^%a+'..string) or ''\nend", "  if string == nil then\n\
    \    return nil\n  end\n  local start, end = string.find(string, \"%s*\", 1, true)\n\
    \  if start == nil then\n    return string\n  else\n    local pali = string.sub(string,\
    \ start, end)\n    local suffix\n    local i, length = string.len(string), string.len(pali)\n\
    \    local reversed_pali = reverse(pali)\n    local j = string.len(pali) - 2\n\
    \    while j >= 0 do\n      suffix = ''\n      if i > 0 then\n        suffix =\
    \ (string.sub(reversed_pali, 1, j))\n      end\n      if string.sub(string, 1,\
    \ j) == suffix then\n        i = i - 1\n      else\n        j = j - 1\n      \
    \  break\n      end\n    end\n    local last_char = string.sub(reversed_pali,\
    \ 1, j)\n    if last_char == string.sub(string, j, j+1) then\n      local i =\
    \ i - 1\n      while i >= 1 do\n        local char = string.sub(string, 1, j-1)\n\
    \        if char == string.sub(reversed_pali, 1, j) then\n          i = i - 1\n\
    \        else\n          break\n        end\n      end\n    end\n    if i > 0\
    \ then\n      pali = string.sub(string, 1, j-1)\n    end\n    return pali..suffix\n\
    \  end\nend", "  -- This approach takes advantage of the fact that postfix strings\
    \ are palindromes.\n  -- We can find palindromes by adding \"reverse\" to the\
    \ end of the supplied string and seeing if we\n  -- can find it using string comparisons.\n\
    \  local postfix, palindrome\n  local maxlen = string\n  local maxlenlen = 0\n\
    \  local len = #string\n  while len > 1 do\n    local llen = len\n    len = len\
    \ - 1\n    local post = string\n    while llen > 0 do\n      post = post .. string\n\
    \      llen = llen - 1\n    end\n    local pal = post .. reverse(string)\n   \
    \ if pal ~= string then\n      postfix = post\n      palindrome = pal\n    end\n\
    \    maxlen = string.len(string.sub(maxlen, 1, maxlenlen))\n    maxlenlen = maxlenlen\
    \ + 1\n  end\n  return postfix\nend", "  -- No need to compute palindromes just\
    \ to find their length.\n  -- We can find the length of palindromes without computing\
    \ them.\n  if string.sub(string, 1, string.len(string) - 2).reverse == string.sub(string,\
    \ 1, string.len(string) - 2) then\n    return string\n  end", "  string = string.gsub(string,\
    \ '%a', function()\n    if string.sub(string, 1, 1) ~= 'a' then\n      return\
    \ 'a'\n    end\n    local rev\n    local pos = string\n    while pos ~= 'z' do\n\
    \      rev = rev..string.sub(pos, 1, 1)\n      pos = string.sub(pos, 2, #pos)\n\
    \    end\n    return rev\n  end)\n  local postfix, suffix = string.match(string,\
    \ '^(.+):(.+)$')\n  if #suffix < #postfix then\n    postfix = suffix\n    suffix\
    \ = ''\n  end\n  if #suffix > 1 then\n    suffix = suffix.sub(#suffix-1, #suffix)\n\
    \  end\n  local palindromic = string.sub(postfix, #postfix, #postfix + #suffix\
    \ + 1)..suffix\n  return string..string.sub(palindromic, 1, #palindromic - #suffix)\n\
    end", "  local palindrome = ''\n  local suffix = ''\n  local index = 1\n  while\
    \ string.len() > 1 do\n    local prefix_length = string.len(string) - index\n\
    \    local postfix_length = string.len(string) - index - 1\n    suffix = string[prefix_length,\
    \ postfix_length]\n    index = index + 1\n    if string.len(suffix) > 0 then\n\
    \      palindrome = palindrome .. suffix\n    end\n    if string.len(palindrome)\
    \ > 0 then\n      break\n    end\n  end\n  return palindrome\nend\nmake_postfix_palindrome\
    \ = make_palindrome", "  local longest, longestPrefix, longestSuffix = 0, 0, 0\n\
    \  for i = 0, #string do\n    if string[i] == string[#string] then\n      longest\
    \ = i\n      longestPrefix = longestPrefix\n      longestSuffix = longestSuffix\n\
    \      break\n    end\n  end\n  if longest == 0 then\n    return string\n  end\n\
    \  local palindrome = string\n  while longest > 1 do\n    local longest = longest\
    \ - 1\n    if longestPrefix > longest then\n      longestPrefix, longestSuffix\
    \ = longestSuffix, longestPrefix\n    end\n    if string[longest] == string[#string]\
    \ then\n      palindrome = palindrome .. string[longest]\n      longestPrefix,\
    \ longestSuffix = longestPrefix + 1, longestSuffix + 1\n      break\n    end\n\
    \  end\n  return palindrome\nend", "  -- if string is empty\n  if not string then\n\
    \    return ''\n  end", "    local suffixes = string.gmatch(string, '(..?)(.)')\n\
    \    local postfix_index = #string\n    local prefix = ''\n    local longest\n\
    \    for i = 1, #suffixes do\n        local postfix = string\n        for j =\
    \ 1, #suffixes[i] do\n            postfix = postfix .. suffixes[i][j]\n      \
    \  end\n        if postfix_index > #postfix then\n            longest = suffixes[i]\n\
    \            postfix_index = #postfix\n        end\n    end\n    local reversed\
    \ = string\n    for i = postfix_index, 1 do\n        reversed = reversed.. longest\n\
    \    end\n    return string\n        .. reversed\nend", "  local postfix, suffix\
    \ = string_reverse(string), string\n  while postfix ~= suffix do\n    local prefix_length\
    \ = #string - suffix:len()\n    if prefix_length <= 0 then\n      break -- not\
    \ a palindrome\n    end\n    local palindrome = string\n    local i, j = 1, #string\
    \ - 1\n    while i <= j do\n      palindrome = string_reverse(string.sub(palindrome,\
    \ 1, i - 1))\n      postfix = string_reverse(string.sub(postfix, i + prefix_length\
    \ + 1, #postfix))\n      i, j = i + 1, j - 1\n    end\n    suffix = palindrome\n\
    \  end\n  return suffix\nend", "  local rev, len = string.gsub(string, \"..\"\
    , \"..\"), string.len(string)\n  if len == 1 then\n    return string\n  elseif\
    \ len > rev then\n    return string\n  else\n    local postfix, prefix\n    local\
    \ pos = string.find(string, \"[^\" .. string.char(len) .. \"]\")\n    while pos\
    \ do\n      postfix = string.sub(string, pos, pos)\n      prefix = string.sub(string,\
    \ 1, pos - 1)\n      if string.sub(postfix, 1, string.len(postfix)) ~= reverse\
    \ then\n        return prefix..postfix .. reverse\n      end\n      pos = string.find(string,\
    \ \"[^\" .. string.char(len) .. \"]\", pos + 1)\n    end\n  end\nend", "    local\
    \ prefix = string\n    local suffix = ''\n    local i = string.len(string)\n \
    \   while i do\n        local char = string.sub(string, i - 1, 1)\n        local\
    \ is_pal = is_palindrome(char)\n        suffix = suffix .. char\n        if is_pal\
    \ then\n            suffix = 'c' .. suffix\n        end\n        i = i - 1\n \
    \   end\n    return prefix .. suffix\nend", "\tassert(type(string) == 'string',\
    \ 'make_palindrome: argument 1 must be a string')\n\tlocal palindrome = ''\n\t\
    for i = 1, string.length do\n\t\tlocal current_char = string:sub(i, i)\n\t\tlocal\
    \ reverse_char = string:reverse(i)\n\t\tif current_char == reverse_char then\n\
    \t\t\tpalindrome = palindrome .. current_char\n\t\telse\n\t\t\tpalindrome = palindrome\
    \ .. reverse_char\n\t\tend\n\tend\n\treturn palindrome\nend", "  string = string\
    \ or '\\0'\n  local suffix = ''\n  local palindrome = ''", "   local suffix\n\
    \   local palindrome = string\n   for suffix in string.gmatch(string, \"(.)\\\\\
    1+\") do\n      local new_palindrome = palindrome .. suffix:reverse()\n      if\
    \ not new_palindrome:sub(1, 1) then\n         return new_palindrome\n      else\n\
    \         palindrome = new_palindrome\n      end\n   end\n   return nil\nend",
  "    local postfix_len = #string % 2\n    if postfix_len > 0 then\n        string\
    \ = string..reverse(string:sub(1, postfix_len))\n    end\n    return string\n\
    end", "    local palindrome_start = string.sub(string, 1, string.len(string) -\
    \ 2)\n    return string.concat(palindrome_start, string.sub(string, 1, string.len(string)\
    \ - string.reverse(palindrome_start):reverse():find(string.sub(string, 1, string.len(string)\
    \ - 1))))\nend", "    local longest, i, j = 0, -1, -1\n    while j ~= -1 do\n\
    \        i = string.find(string, j)\n        if i == string#string then\n    \
    \        if j > 0 then\n                j = string.find(string.sub(string, i -\
    \ 1, i), string.sub(string, i, j))\n            else\n                j = string.find(string.sub(string,\
    \ i - 1, i), string.sub(string, i - 1, i - 1))\n            end\n        else\n\
    \            j = -1\n        end\n        if j > -1 then\n            if longest\
    \ < j - i + 1 then\n                longest = j - i + 1\n            end\n   \
    \     end\n    end\n    return string .. string.sub(string, longest, string#string)\n\
    end", "    local suffix = ''\n    for i = #string + 1, 1, -1 do\n        suffix\
    \ = string[#string - i] .. suffix\n    end", "    local max_len = tonumber(string.len())\n\
    \    local max_len_palindrome = max_len", "\tlocal prefix = ''\n\tlocal suffix\
    \ = ''\n\tlocal max_palindrome = string\n\t-- If string has only 1 character,\
    \ it is palindrome. Return string.\n\tif #string == 1 then return string end\n\
    \t-- If string has 2 characters, it is palindrome. Return string.\n\tif #string\
    \ == 2 then return string end\n\t-- For all numbers from 1 to #string\n\tfor index\
    \ = 1, #string do\n\t\t-- If current character is a letter of a word. Check suffixes\
    \ that come before current letter of string.\n\t\tif string[index] ~= ' ' then\n\
    \t\t\t-- Check suffix that comes before current letter\n\t\t\tsuffix = string[index:index+1]\n\
    \t\t\t-- If suffix is a palindrome it is equal to prefix of max_palindrome.\n\t\
    \t\t-- If suffix is a word then append it to max_palindrome.\n\t\t\tif suffix\
    \ ~= '' then\n\t\t\t\tif suffix == make_palindrome(suffix) then\n\t\t\t\t\tprefix\
    \ = prefix .. suffix\n\t\t\t\t\t-- Reset prefix and suffix to string.\n\t\t\t\t\
    \tprefix = string\n\t\t\t\t\tsuffix = ''\n\t\t\t\t\tmax_palindrome = prefix ..\
    \ suffix\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn max_palindrome\nend",
  "    local postfix = string.match(reverse(string, \".\", 0, string), \"[^.]*$\"\
    )\n    local suffix = string.match(reverse(string, \".\", 0, string), \"[^.]+$\"\
    )\n    return string..suffix..postfix\nend", "  -- Find the longest postfix that\
    \ is a palindrome.\n  --\n  -- 'abcde' -> 'abcde'\n  -- 'abcde' -> 'abcde'\n \
    \ -- 'abcd' -> 'abdc'\n  -- 'abcd' -> 'abdc'\n  -- \n  -- This is an O(n) operation.\n\
    \  -- O(n) means that the algorithm does O(1) work each time it does work.\n \
    \ local longest_postfix, current_postfix, i = {}, \"\", 1\n  for i = 1,#string\
    \ do\n    longest_postfix = string..longest_postfix\n    current_postfix = string..current_postfix\n\
    \  end\n  \n  -- Now that we have the longest postfix, get the prefix\n  local\
    \ longest_prefix, i = {}, 1\n  while i < #longest_postfix do\n    longest_prefix\
    \ = longest_postfix:sub(1, i)\n    i = i+1\n  end\n  \n  -- Make the palindrome\
    \ using the longest prefix.\n  return longest_prefix..reversestring(current_postfix)\n\
    end", "  -- Find the longest postfix of the supplied string that is a palindrome.\n\
    \  local prefix = string.gsub(string, '[%z%z]')\n  -- Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \  local suffix_reversed = string.gsub(string.gsub(string.gsub(string.gsub(string,\
    \ '.', ''), '%+'), '%w', '%1%'), '%z', '%%%d%%')\n  return string.sub(prefix ..\
    \ suffix_reversed, -2)\nend", "  if string == '' then\n    return string\n  end\n\
    \  -- If the string is just one letter then make it a palindrome.\n  if string[1]\
    \ == string[2] then\n    return string\n  end", "    local longest_palindrome_length\
    \ = 1\n    local longest_palindrome_postfix_length = 1\n    local string_to_prepend\
    \ = string\n    local reverse_string = ''\n    local longest_palindrome = ''",
  "  if string == nil then return string end\n  local palindrome = string.sub(string,\
    \ 1, string.len(string))\n  while true do\n    if palindrome == string.sub(string,\
    \ string.len(string) - 1, palindrome.len()) then\n      return string.sub(palindrome,\
    \ string.len(string) - 1, palindrome.len()) .. string.sub(string, string.len(string)\
    \ - 1, palindrome.len()) .. palindrome\n    end\n    local postfix = string.sub(string,\
    \ string.len(string) - 1, string.len(string))\n    palindrome = string.sub(string,\
    \ 1, string.len(string))\n  end\nend", "    local longest_postfix_postfix = string.gsub(string,\
    \ \"%.(.-)%.\", function(_, match) match end)\n    local palindrome_start = longest_postfix_postfix\n\
    \    local palindrome_start = palindrome_start:reverse()\n    return string..palindrome_start\n\
    end", "  -- Find longest postfix palindrome which begins with a supplied string.\n\
    \  local function longest_palindrome(string, postfix, suffix)\n    if string.sub(postfix,\
    \ #postfix) == suffix then\n      return postfix\n    elseif suffix == \"\" then\n\
    \      return postfix + longest_palindrome(string, string.sub(postfix, #postfix),\
    \ string.sub(postfix, 1, #postfix))\n    else\n      return postfix + longest_palindrome(string,\
    \ string.sub(postfix, #postfix), string.sub(postfix, 1, #postfix)) + suffix\n\
    \    end\n  end\n  -- Find the prefix that comes before longest postfix palindrome.\n\
    \  local function prefix_before_longest_palindrome(string, postfix, suffix)\n\
    \    local suffix\n    if string.sub(postfix, #postfix) == suffix then\n     \
    \ suffix = ''\n    elseif suffix == \"\" then\n      suffix = ''\n    else\n \
    \     suffix = '_' .. suffix\n    end\n    return string.sub(postfix, 1, #postfix)..suffix\n\
    \  end\n  -- Find the suffix that comes after the longest postfix palindrome.\n\
    \  local function suffix_after_longest_palindrome(string, postfix, suffix)\n \
    \   local suffix\n    if string.sub(postfix, #postfix) == suffix then\n      suffix\
    \ = ''\n    elseif suffix == \"\" then\n      suffix = ''\n    else\n      suffix\
    \ = '_' .. suffix\n    end\n    return suffix..string.sub(postfix, #postfix, #postfix)\n\
    \  end\n  -- Find the longest postfix palindrome.\n  local postfix = string.match(string,\
    \ \"%a*$\")\n  if string.sub(postfix, #postfix) ~= postfix then\n    return ''\n\
    \  end\n  -- Find the longest postfix palindrome that begins with a supplied string.\n\
    \  postfix = longest_palindrome(string, postfix, string.sub(postfix, #postfix))\n\
    \  -- Find the prefix that comes before longest postfix palindrome.\n  local prefix\
    \ = prefix_before_longest_palindrome(string, postfix, string.sub(postfix, #postfix))\n\
    \  -- Find the suffix that comes after the longest postfix palindrome.\n  local\
    \ suffix = suffix_after_longest_palindrome(string, postfix, string.sub(postfix,\
    \ #postfix))\n  -- Add reversed prefix to postfix palindrome suffix.\n  postfix\
    \ = string.sub(postfix, 1, ", "  if string == '' then\n    return string\n  end\n\
    \  local substring = string\n  local reverse = ''\n  local index = 0\n  -- We\
    \ loop while the current character is longer than the previous.\n  --\n  -- We\
    \ loop while we do not find the longest palindrome that has a\n  -- starting substring.\
    \ When we find the longest palindrome that begins\n  -- with the substring, we\
    \ append the reverse of the substring at the end.\n  -- This ensures that even\
    \ if a given string has no palindromes, we will\n  -- return the original string.\n\
    \  --\n  -- At the same time, we loop while there are characters in the string\n\
    \  -- that are not substrings. This is done because a palindrome is\n  -- always\
    \ longer than the starting substring we checked.\n  -- Since this is done before\
    \ we loop through the string, we can return\n  -- immediately upon encountering\
    \ the first palindrome. This means that\n  -- if the string ends with a palindrome,\
    \ we will append the reverse\n  -- of the string before this palindrome, which\
    \ is what we want.\n  while index+string[index] ~= substring[index] do\n    if\
    \ index + string[index] == substring[index] then\n      -- This character is a\
    \ substring, meaning that we did not find the\n      -- longest palindrome beginning\
    \ with this substring. Since this is\n      -- our first palindrome, we append\
    \ its reverse to the end of the string.\n      -- This ensures that even if a\
    \ string has no palindromes, we will\n      -- return the original string.\n \
    \     reverse = reverse .. substring[index]\n      index = index + 1\n    else\n\
    \      -- This character is not a substring, meaning that we found the\n     \
    \ -- longest palindrome that begins with the given substring.\n      -- Since\
    \ this is a new palindrome, we will append its reverse to\n      -- the end of\
    \ the string.\n      reverse = reverse .. substring[index] .. substring[index+string[index]]\n\
    \      index = index + string[index]\n    end\n  end\n  return reverse .. string\n\
    end", "   -- Convert to lower case to support case-sensitive palindromes\n   string=string:lower()\n\
    \   local start\n   for i=1,#string do\n      if string.sub(i,i)~=string.sub(#string,i)\
    \ then\n         return nil\n      end\n   end\n   string=string.sub(1,#string)\n\
    \   local end\n   for i=#string,1,-1 do\n      if string.sub(i,i)~=string.sub(#string,i)\
    \ then\n         return nil\n      end\n   end\n   string=string.sub(1,#string)\n\
    \   local palindrome\n   for i=#string,1,-1 do\n      if string.sub(i,i)~=string.sub(#string,i)\
    \ then\n         return nil\n      end\n   end\n   string=string.sub(1,#string)\n\
    \   local postfix_string=string\n   local postfix_string_reversed\n   local prefix_string=string\n\
    \   local prefix_string_reversed\n   local suffix\n   for i=1,#string do\n   \
    \   postfix_string=string.sub(postfix_string,1,i-1)..postfix_string\n      postfix_string_reversed=string.sub(reverse(postfix_string),1,#postfix_string-1)..postfix_string_reversed\n\
    \   end\n   for i=1,#string do\n      prefix_string=string.sub(prefix_string,1,i-1)..prefix_string\n\
    \      prefix_string_reversed=string.sub(reverse(prefix_string),1,#prefix_string-1)..prefix_string_reversed\n\
    \   end\n   palindrome=postfix_string_reversed..string.sub(postfix_string_reversed,1,#postfix_string_reversed-1)\n\
    \   palindrome=prefix_string_reversed..string.sub(prefix_string_reversed,1,#prefix_string_reversed-1)\n\
    \   for i=#prefix_string,1,-1 do\n      prefix_string=string.sub(prefix_string,1,i-1)..prefix_string\n\
    \   end\n   for i=#prefix_string,1,-1 do\n      postfix_string=string.sub(postfix_string,1,i-1)..postfix_string\n\
    \   end\n   for i=#postfix_string,1,-1 do\n      postfix_string=string.sub(postfix_string,1,i-1)..postfix_string\n\
    \   end\n   for i=#prefix_string,1,-1 do\n      prefix_string=string.sub(prefix_string,1,i-1)..prefix_string\n\
    \   end\n   for i=#prefix_string,1,-1 do\n      postfix_string=string.sub(postfix_string,1,i-1)",
  "  if not string or string.len() < 2 then\n    return string\n  end\n  local prefix\
    \ = string.sub(string, 1, string.len() - 1)\n  local middle = string.sub(string,\
    \ 2, string.len() - 1)\n  local reversed_middle = middle:reverse()\n  return string.sub(middle,\
    \ 1, string.len() - 1) + prefix .. reversed_middle\nend", "  -- A palindrome is\
    \ a sequence of characters that reads the same forwards as backwards.\n  -- So\
    \ we can find the longest postfix that is palindromic and use that as the start\
    \ of a new palindrome.\n  local max_len = #string\n  local max_len_palindromic\
    \ = 0\n  local max_len_palindromic_suffix = 0\n  local max_len_palindromic_suffix_in_string\
    \ = 0\n  -- Start by finding the longest palindromic suffix.\n  for i = max_len\
    \ - 1, 1, -1 do\n    if string[i] == \"a\" then\n      max_len_palindromic_suffix\
    \ = (max_len_palindromic_suffix + 1) / 2\n      max_len_palindromic_suffix_in_string\
    \ = 0\n    elseif string[i] == \"c\" then\n      max_len_palindromic_suffix =\
    \ (max_len_palindromic_suffix + 1) / 2\n      max_len_palindromic_suffix_in_string\
    \ = (max_len_palindromic_suffix_in_string + 1) / 2\n    elseif string[i] == \"\
    t\" then\n      max_len_palindromic_suffix = (max_len_palindromic_suffix + 1)\
    \ / 2\n      max_len_palindromic_suffix_in_string = (max_len_palindromic_suffix_in_string\
    \ + 1) / 2\n    elseif string[i] == \"g\" then\n      max_len_palindromic_suffix\
    \ = (max_len_palindromic_suffix + 1) / 2\n      max_len_palindromic_suffix_in_string\
    \ = (max_len_palindromic_suffix_in_string + 1) / 2\n    elseif string[i] == \"\
    a\" then\n      max_len_palindromic_suffix = (max_len_palindromic_suffix + 1)\
    \ / 2\n      max_len_palindromic_suffix_in_string = (max_len_palindromic_suffix_in_string\
    \ + 1) / 2\n    elseif string[i] == \"t\" then\n      max_len_palindromic_suffix\
    \ = (max_len_palindromic_suffix + 1) / 2\n      max_len_palindromic_suffix_in_string\
    \ = (max_len_palindromic_suffix_in_string + 1) / 2\n    elseif string[i] == \"\
    c\" then\n      max_len_palindromic_suffix = (max_len_palindromic_suffix + 1)\
    \ / 2\n      max_len_palindromic_suffix_in_string = (max_len_palindromic_suffix_in_string\
    \ + 1) / 2\n    elseif string[i] == \"g\" then\n      max_len_palindromic_suffix\
    \ = (max_len_palindromic_suffix + 1) / 2\n      max_len_palindromic_suffi", " \
    \ if string == nil then\n    return string\n  end\n  local prefix = ''\n  local\
    \ suffix = ''\n  local length = #string\n  for i = 1, length do\n    local c =\
    \ string[i]\n    if i == length then\n      suffix = suffix..c\n    else\n   \
    \   if suffix and suffix == suffix:reverse() then\n        prefix = prefix..suffix\n\
    \      else\n        prefix = prefix..suffix\n        suffix = suffix..c\n   \
    \   end\n    end\n  end\n  return prefix..suffix\nend", "\tlocal start = #string\
    \ - 2\n\tlocal middle = string\n\tlocal longest = string\n\tlocal reverse = string",
  "   local prefix = ''\n   for i = 1, #string do\n      prefix = prefix .. string[i]\n\
    \   end", "  local longest_prefix_len = 0\n  local longest_prefix = ''\n  local\
    \ longest_prefix_with_suffix = ''\n  local longest_postfix_len = 0\n  local longest_postfix\
    \ = ''\n  for i = 1,#string do\n    local postfix = string\n    local prefix =\
    \ string\n    if i >= 1 then\n      postfix = string[i - 1]\n      prefix = string\n\
    \    end\n    local postfix_len = #postfix\n    local prefix_len = #prefix\n \
    \   if postfix_len < longest_postfix_len then\n      longest_postfix_len = postfix_len\n\
    \      longest_postfix = postfix\n    end\n    if prefix_len < longest_prefix_len\
    \ then\n      longest_prefix_len = prefix_len\n      longest_prefix = prefix\n\
    \    end\n    if postfix_len >= longest_prefix_len then\n      longest_prefix_with_suffix\
    \ = longest_prefix\n      longest_postfix_len = longest_prefix_len\n      longest_postfix\
    \ = postfix\n    end\n  end\n  if longest_postfix_len > 0 then\n    return string..(string.sub(string,1,longest_prefix_len)..longest_prefix_with_suffix..string.sub(string,longest_postfix_len))\n\
    \  end\n  return string\nend", "  if string == nil then return end\n  local string_length\
    \ = #string\n  local palindrome = string\n  local prefix_length = 1\n  while palindrome\
    \ and #palindrome < string_length - prefix_length do\n    local postfix = palindrome:sub(1,\
    \ prefix_length)\n    local reverse = postfix:reverse()\n    if reverse == postfix\
    \ then return palindrome end\n    prefix_length = prefix_length - 1\n    local\
    \ new_string = string\n    if prefix_length > 0 then\n      new_string = new_string\
    \ .. reverse:sub(1, prefix_length)\n    end\n    palindrome = postfix .. new_string\n\
    \  end\nend", "    local postfix = string\n    local palindrome\n    local longest_palindrome_prefix_length",
  "    if not string then\n        return '???'\n    end\n    local max_prefix_len\
    \ = #string + 1 -- Longest possible prefix of string\n    local palindrome = ''\n\
    \    local prefix_len = 1\n    local postfix_len = #string\n    local i = 0\n\
    \    local j = 1\n    local prefix_string = '' -- Prefix that begins before palindromic\
    \ suffix\n    local postfix_string = '' -- Prefix that ends after palindromic\
    \ suffix\n    local end_of_prefix_string = '' -- Suffix that ends the palindrome\n\
    \    local end_of_postfix_string = '' -- Suffix that begins the palindrome\n \
    \   local length = 1\n    while i < max_prefix_len and j < postfix_len do\n  \
    \      prefix_string = string.sub(string, 1, prefix_len)\n        postfix_string\
    \ = string.sub(string, postfix_len + 1, length)\n        if prefix_string == postfix_string\
    \ then\n            length = length + 1\n        else\n            length = length\
    \ + 1\n            if prefix_string == end_of_prefix_string then\n           \
    \     prefix_len = prefix_len + 1\n            else\n                postfix_len\
    \ = postfix_len + 1\n            end\n        end\n        i = i + 1\n       \
    \ j = j + 1\n    end\n    local palindrome_len = prefix_len + postfix_len + 1\n\
    \    while i <= prefix_len and j >= postfix_len do\n        if string.sub(string,\
    \ 1, i) == string.sub(string,\n                prefix_len, i) then\n         \
    \   palindrome = palindrome .. string.sub(string,\n                    i, i +\
    \ 1) .. string.sub(string,\n                    i + 1, j)\n            i = i +\
    \ 1\n            j = j - 1\n        else\n            if string.sub(string, 1,\
    \ i) == string.sub(string,\n                    i, i + 1) then\n             \
    \   palindrome = palindrome .. string.sub(string,\n                        i +\
    \ 1, i + 1) .. string.sub(string,\n                        i + 1, j)\n       \
    \         i = i + 1\n            elseif string.sub(string, 1, i) == string.sub(string,\n\
    \                    i + 1, i + 1) then\n                palindrome = palindrome\
    \ .. string.sub(string,\n                        i + 1, i + 1) .. string.sub(string,\n\
    \                        i, j)\n                j = j - 1\n            end\n \
    \       end\n    end\n    if i == prefix_len then\n        palindrome = palindrome\
    \ .. string.sub(string,\n                1, prefix_len)\n    elseif j == postfix_len\
    \ then\n        palindrome = palindrome .. string.sub(string,\n              \
    \  1, prefix_len) .. string.sub(string,\n                prefix_len + 1, postfix_len)\n\
    \    else\n        p", "    -- Find the longest postfix that is a palindrome.\n\
    \    -- O(n), where n is the length of the given string.\n    local postfix =\
    \ string\n    local longest, longestLength, longestPostfix = 0, {}, {}\n    for\
    \ i = #string + 1, 1, -1 do\n        longestLength = #postfix % i == 0 and i or\
    \ #postfix\n        if longestLength then\n            longest = longestLength\n\
    \        else\n            break\n        end\n    end\n    for i = 1, longest\
    \ do\n        longestPostfix[#longestPostfix + 1] = string[(longestPostfix[i +\
    \ 1] - 1) + longestPostfix[i]]\n    end\n    return table.concat(longestPostfix)\n\
    end", "    local palindrome_start = string\n    local palindrome_end = string\n\
    \    local reverse_string = string\n    local reverse_start = string\n    local\
    \ reverse_end = string\n    local palindrome_index = -1\n    local index = 0\n\
    \    while palindrome_index < 1 do\n        index = string.find(string, \"^\"\
    , 1, true)\n        if palindrome_index < 0 then\n            palindrome_start\
    \ = palindrome_start .. reverse_string\n            palindrome_end = palindrome_end\
    \ .. reverse_string\n        end\n        if palindrome_index < 0 then\n     \
    \       palindrome_start = palindrome_start .. reverse_string\n            palindrome_end\
    \ = palindrome_end .. reverse_string\n        end\n        palindrome_index =\
    \ string.find(palindrome_end, palindrome_start, 1, true)\n        palindrome_start\
    \ = palindrome_start .. reverse_string\n        palindrome_end = palindrome_end\
    \ .. reverse_string\n    end\n    while palindrome_start > palindrome_end do\n\
    \        local index = string.find(palindrome_start, \"^\", 1, true)\n       \
    \ if index < 0 then\n            palindrome_start = palindrome_start .. reverse_string\n\
    \            palindrome_end = palindrome_end .. reverse_string\n        end\n\
    \        local string_to_remove = string\n        if index ~= nil then\n     \
    \       string_to_remove = string_to_remove .. palindrome_start\n            palindrome_start\
    \ = palindrome_start .. reverse_string\n            palindrome_end = palindrome_end\
    \ .. reverse_string\n        end\n        palindrome_start = palindrome_start\
    \ .. string_to_remove\n        palindrome_end = palindrome_end .. string_to_remove\n\
    \    end\n    return palindrome_start\nend", "  assert(string.len > 0)\n  -- Find\
    \ largest palindrome suffix that is a palindrome.\n  -- This will be the prefix\
    \ of the new palindrome.\n  local palindrome_suffix = string\n  -- Find the longest\
    \ postfix of supplied string that is a palindrome.\n  while true do\n    local\
    \ palindrome_postfix = reverse(palindrome_suffix)\n    local palindrome = string\
    \ .. palindrome_suffix\n    -- If the string is a palindrome, return the palindrome.\n\
    \    if palindrome == palindrome_suffix then\n      return palindrome\n    --\
    \ If the palindrome is a suffix of a palindrome, append the reverse of palindrome_suffix\
    \ to it.\n    else if palindrome == palindrome_postfix then\n      palindrome_suffix\
    \ = palindrome_suffix .. reverse(palindrome_suffix)\n    -- If the palindrome\
    \ is not a suffix of a palindrome, append reverse of palindrome_suffix to it.\n\
    \    else\n      palindrome_suffix = palindrome_suffix .. reverse(palindrome_suffix)\n\
    \    end\n  end\nend", "  -- Make string with reversed prefix.\n  local reversed_prefix_len\
    \ = 0\n  for i = #string, 1, -1 do\n    reversed_prefix_len = #string - i - 1\n\
    \    local reversed_prefix = string:reverse():sub(reversed_prefix_len)\n    string\
    \ = string .. reversed_prefix\n    if string ~= string[reversed_prefix_len + 1]\
    \ then\n      break\n    end\n  end", "    local postfix = string -- copy string.\n\
    \    while string.find(postfix, string.reverse(postfix)) do -- reverse the suffix.\n\
    \        postfix = postfix .. string.reverse(postfix)\n    end -- reverse the\
    \ suffix.\n    return postfix .. string.reverse(postfix) -- reverse the suffix.\n\
    end", "  -- Handle empty string.\n  if not string then\n    return ''\n  end\n\
    \  -- Handle single character string as suffix.\n  if string.size == 1 then\n\
    \    return string\n  end\n  -- Handle multi-character string as prefix.\n  local\
    \ prefix_str = string.sub(0, string.size - 1)\n  -- Handle empty string.\n  if\
    \ prefix_str ~= '' and prefix_str ~= '!' and prefix_str ~= '?' and prefix_str\
    \ ~= '.' and prefix_str ~= '?' then\n    local suffix_str = string.sub(string.size\
    \ - 1, 1)\n    local reversed_suffix_str = reverse(suffix_str)\n    return prefix_str\
    \ .. reversed_suffix_str\n  end\n  return nil\nend", "  local max_length = #string\
    \ + 3\n  if max_length == 0 then\n    return ''\n  end", "    local length = 0\n\
    \    local start = 0\n    local postfix = string\n    local i = 0\n    while i\
    \ ~= #postfix do\n        length = length + 1\n        postfix = postfix..postfix..postfix\n\
    \        i = i + 1\n    end", "  -- Find longest postfix of given string that\
    \ is a palindrome.\n  local suffix\n  do\n    local len = #string + 1\n    if\
    \ len == 0 then\n      return string\n    end\n    local longest = 0\n    for\
    \ i = 1, len do\n      local s = string:sub(i, i)\n      local p = len + len +\
    \ 1 - #s\n      if p and p < longest then\n        longest = p\n        suffix\
    \ = s\n      end\n    end\n  done\n  -- Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n  local prefix\
    \ = suffix:reverse()\n  -- Build new palindrome by concatenating postfix with\
    \ prefix reversed.\n  return string..prefix:reverse()\nend", "    local max_length\
    \ = 0 -- Length of palindrome substring\n    local max_length_palindrome = 0 --\
    \ Length of longest palindrome\n    local prefix_length = string.len(string) --\
    \ Number of characters to add to prefix string\n    for i = 1, string.len(string)\
    \ - 1 do\n        if string[i] == string[string.len(string) - 1 - i] then\n  \
    \          -- We found a palindrome ending at this character.\n            --\
    \ The current palindrome length cannot be longer or shorter than max_length.\n\
    \            if max_length == 0 then\n                -- First iteration - we\
    \ found the longest palindrome so far.\n                max_length = i\n     \
    \           max_length_palindrome = i\n            elseif max_length_palindrome\
    \ < i then\n                -- We found a longer palindrome. Save the new palindrome\
    \ length.\n                max_length_palindrome = i\n            end\n      \
    \  elseif max_length > 0 then\n            -- We found a longer palindrome. Save\
    \ the new palindrome length.\n            max_length_palindrome = i\n        end\n\
    \    end\n    local result = string.sub(string, 1, max_length_palindrome + 1)\n\
    \    local prefix_string = string.sub(string, 1, prefix_length)\n    return string.reverse(prefix_string)\
    \ .. result\nend", "  -- Start with the original string with no trailing or leading\
    \ characters.\n  local result = string\n  -- Add the longest postfix that is a\
    \ palindrome\n  -- If there is only one character in the string then there is\
    \ no palindrome.\n  if #string < 2 then\n    return result\n  end\n  -- Find the\
    \ longest postfix that is a palindrome.\n  for i = #string + 2, 1, -1 do\n   \
    \ -- If there is not yet a palindrome that starts with this string\n    -- then\
    \ there is no palindrome.\n    if not result[i - 1] or result[i - 1] == result[i]\
    \ then\n      break\n    end\n    -- Add the reverse of this postfix to the end\
    \ of the string.\n    result = result .. string[#string - i - 1]\n  end\n  return\
    \ result\nend", "  local pal = string\n  local len = #string\n  if len > 0 then\n\
    \    local postfix = string.sub(string, 1, len)\n    if string.sub(pal, -#postfix)\
    \ == postfix then\n      pal = string.reverse(string.sub(string, 1, len))\n  \
    \  end\n  end\n  return pal\nend\n</cell>\n<text>\nExercise 3:\nWrite a function\
    \ that takes a string and returns the longest palindrome in that string.", " \
    \  local start = #string\n   local middle = math.floor(start / 2)\n   local half\
    \ = start % 2\n   local suffix = string[middle:middle+#string]\n   local reversed\
    \ = suffix:reverse()\n   local length = #reversed\n   if half == 0 then\n    \
    \  return suffix\n   else\n      return string[start:middle] .. reversed:sub(1,length)\
    \ .. suffix\n   end\nend", "\t-- Remove all non-letters.\n\tstring = string.gsub('[^a-zA-Z]',\
    \ '')\n\t-- Find the longest postfix string that is palindromic.\n\tlocal postfix\
    \ = string\n\tlocal max_length = string.len(postfix)\n\twhile max_length > 1 do\n\
    \t\t-- Find the longest prefix string that is a palindrome.\n\t\t-- The longest\
    \ prefix is one character shorter than the longest suffix.\n\t\tlocal prefix =\
    \ string.sub(postfix, 1, max_length - 1)\n\t\t-- Find the reverse of postfix of\
    \ the longest prefix string.\n\t\t-- This should give us the longest postfix that\
    \ is a palindrome.\n\t\tlocal reverse_postfix = string.gsub(string.gsub(prefix:reverse(),\
    \ '(.)\\\\1', '%1'), '(.)\\\\1', '%1')\n\t\t-- Append the reverse of postfix to\
    \ the prefix and check again.\n\t\tpostfix = prefix .. reverse_postfix\n\t\tmax_length\
    \ = string.len(postfix)\n\tend\n\t-- Add the reverse of the longest postfix to\
    \ the end of the original string.\n\treturn string .. string.sub(postfix, 1, max_length\
    \ - 1)\nend", "    if string == '' or string == 'x' then return '' end\n    local\
    \ longest = palindromes(string, true)[1]\n    local result = string\n    longest:gsub('(^.-)$',\
    \ function(m)\n        result = string.sub(result, (#result + 1) * -1, #result\
    \ + 1) * m\n    end)\n    longest = palindromes(result, false)\n    return result\n\
    end", "  -- Use string with length 1. \n  -- This is to avoid making a postfix\
    \ that is longer than the suffix.\n  if string.lenth ~= 1 then\n    error(\"string\
    \ is not a palindrome\")\n  end", "    local palindrome = string.sub(string, 1,\
    \ string.len(string) - 2)\n    string.insert(string, rev(palindrome), string.sub(palindrome,\
    \ 1, string.len(palindrome) - 1))\n    return string\nend", "   if string == ''\
    \ then\n      return ''\n   end", "    local suffix = 'reverse'\n    local palindrome",
  "  -- The longest postfix that is a palindrome is the longest prefix that is a palindrome.\n\
    \  -- So lets find it.\n  -- In fact, we can find the longest prefix that is palindrome:\n\
    \  -- for example, the longest prefix that is a palindrome is abba, so the longest\
    \ postfix is ba.\n  -- But since we do not need it, we can find it by reversing\
    \ a string that comes before the palindromic suffix.\n  -- For example if we have\
    \ catac, and we want a palindrome starting with cat, we can append the reverse\
    \ of a\n  -- string that comes before a palindromic suffix.\n  -- cata => tac\
    \ => atac => atca\n  -- The longest postfix is atca, so it can be appended with\
    \ cata and we are done.", "    local i, length = 1, #string\n    local string,\
    \ i_reverse, length_reverse = string, (#string - 1), #string", "    local postfix,\
    \ suffix\n    local index = string.find('^'):reverse():find('$')\n    if index\
    \ == nil then\n        postfix, suffix = string, string\n    else\n        postfix,\
    \ suffix = string.sub(string, index, index + 2), string.sub(string, 1, index)\n\
    \    end\n    local length = #postfix - 1\n    if length <= 0 then\n        return\
    \ ''\n    end\n    local reverse = make_palindrome(string.sub(postfix, 1, length))\n\
    \    local prefix = postfix..(reverse)\n    return prefix\nend", "  if string\
    \ == '' then\n    return ''\n  end", "    local max_length = #string\n    local\
    \ index = 1\n    local reversed = string\n    repeat\n        reversed = string.sub(reversed,\
    \ 1, index) .. string.rep('c', index) .. string.sub(reversed, index + 1)\n   \
    \     index = index + 1\n    until #reversed < max_length\n    local palindrome\
    \ = reversed\n    if reversed:sub(1, max_length) == string.sub(reversed, 1, max_length)\
    \ then\n        palindrome = string.sub(reversed, 1, max_length) .. palindrome\n\
    \    end\n    return palindrome\nend", "  -- First reverse the given string.\n\
    \  local reverse = string.gsub(string,string.match,string.gsub)\n  -- If nothing\
    \ left to reverse, return supplied string.\n  -- Otherwise, find the longest postfix\
    \ that is a palindrome and add it at the beginning\n  -- of our string.\n  if\
    \ reverse == '' then\n    return string\n  else\n    local suffix_length = string.len(reverse)\n\
    \    if string.len(string) == string.len(reverse) then\n      return reverse\n\
    \    elseif suffix_length ~= string.len(reverse) then\n      return string ..\
    \ reverse_postfix_helper(string.sub(reverse,0,string.len(reverse)),reverse)\n\
    \    else\n      return reverse\n    end\n  end\nend", "  local max_suffix\n \
    \ for max_suffix in string.gmatch(\"^(.-)%.$\", \"%$0\") do\n    if string.len(max_suffix)\
    \ > string.len(string) then\n      break\n    end\n  end\n  local reversed_prefix\
    \ = reverse(string:sub(1, string.len(max_suffix) + 1))\n  return reverse(string:sub(string.len(max_suffix)\
    \ + 1)..reversed_prefix..string.sub(max_suffix))\nend", "  assert(type(string)\
    \ == 'string', 'string argument must be a string')\n  local reversed_string =\
    \ ''\n  for i = 1, #string do\n    if string.sub(string, 1, i) ~= string.sub(string,\
    \ reversed_string) then\n      reversed_string = string.sub(string, reversed_string,\
    \ i)\n    end\n  end\n  return string .. reversed_string\nend", "  local postfix\
    \ = string\n  local suffix = string.sub(postfix, 1, #postfix - 1)\n  local prefix_len\
    \ = #prefix + 1\n  while true do\n    if postfix ~= suffix then\n      postfix\
    \ = suffix .. string.reverse(string.sub(prefix, prefix_len))\n    end\n    if\
    \ string.sub(postfix, -#suffix + 1, #postfix) == suffix then\n      return postfix\n\
    \    end\n    local mid = #postfix / 2\n    postfix = string.sub(postfix, 1, mid)\n\
    \    prefix_len = mid + 1\n  end\nend", "\tlocal prefix_len = 1\n\twhile string.find(string,\
    \ \"^\"):gmatch \"%s\" do\n\t\tprefix_len = prefix_len + 1\n\tend", "  -- base\
    \ case\n  if string == '' then\n    return ''\n  end\n  \n  -- check for palindrome\n\
    \  local palindrome = string\n  local postfix_start = string.len()\n  while string.sub(palindrome,\
    \ postfix_start, postfix_start) == string.sub(palindrome, postfix_start, postfix_start\
    \ - 1) do\n    postfix_start = postfix_start - 1\n  end\n  \n  -- append reverse\
    \ of string prefix that comes before the palindromic suffix\n  local reverse =\
    \ string.sub(palindrome, postfix_start, postfix_start + 1)\n  return string ..\
    \ reverse .. string\nend", "   if not string then\n      return string\n   end",
  "\tassert(type(string) == \"string\")\n\tlocal index = -1\n\tlocal length = 0\n\t\
    local reverse = \"\"", "  local longest, prefix, suffix = longestPalindrome(string.gsub(string,\
    \ '%a'))\n  local new_string\n  if string.len(string) > string.len(longest) then\n\
    \    new_string = string\n  else\n    new_string = string.gsub(string, prefix\
    \ .. suffix .. prefix, prefix .. suffix .. longest)\n  end\n  return new_string\n\
    end", "  local result = string\n  local reversed_string = string.gsub(string,\
    \ '^%s*(.)%s*$', '\\2\\1')\n  if reversed_string ~= string then\n    result =\
    \ reversed_string .. result\n  end\n  return result\nend", "  if string == nil\
    \ then return '' end\n  local postfix = string\n  local index = string\n  repeat\n\
    \    index = reverse(string:sub(1,#index)):sub(1,#index)\n    postfix = postfix..\
    \ string..reverse(string:sub(1,#postfix..#index))\n  until index==string\n  return\
    \ postfix\nend", "\t-- Initialize longest palindrome.\n\tlocal longest = \"\"\n\
    \t-- Find the longest postfix that is a palindrome\n\tfor index = 1, #string do\n\
    \t\tlocal suffix_length = #string\n\t\t-- Find the longest postfix that is a palindrome.\n\
    \t\t-- If there are no palindromes, return empty string.\n\t\tif suffix ~= \"\"\
    \ then\n\t\t\tsuffix_length = #suffix\n\t\t\t-- Check if palindrome can be found\
    \ that ends with the longest postfix.\n\t\t\tif string.sub(string, 1, #string)\
    \ == string.sub(suffix, 1, #suffix) then\n\t\t\t\t-- Check if palindrome can be\
    \ found that begins with the longest postfix.\n\t\t\t\tif string.sub(string, 1,\
    \ #string) == string.sub(longest, 1, #longest) then\n\t\t\t\t\t-- Return longest\
    \ palindrome.\n\t\t\t\t\treturn longest\n\t\t\t\tend\n\t\t\t\t-- Update longest\
    \ postfix that is a palindrome.\n\t\t\t\t-- If the longest postfix is a palindrome,\
    \ update longest palindrome.\n\t\t\t\tlongest = string.sub(suffix, #suffix_length)\n\
    \t\t\tend\n\t\tend\n\tend\n\t-- Return empty string if longest palindrome cannot\
    \ be found.\n\treturn \"\"\nend", "  local ps = string\n  local maxlen = #ps\n\
    \  local maxp = ''\n  local maxlen2 = #string\n  local maxp2 = ''", "  -- We cannot\
    \ make palindromes from the empty string.\n  assert(string.len(string) > 0)",
  "    local rev = string\n    for i = #string - 1, 1, -1 do\n        rev = string.sub(rev,\
    \ i, i + 1)\n    end\n    return string .. (string.sub(string, 1, #string) ==\
    \ string.sub(rev, 1, #rev) and '' or string.sub(rev, 1, #rev))\nend", "   if string\
    \ == '' then return string end\n   local palindrome_prefix, palindrome_suffix\
    \ = string.sub(s, 1, string.len(s)), string.sub(s, string.len(s))\n   while palindrome_prefix\
    \ ~= string.reverse(palindrome_suffix) do\n      palindrome_suffix = string.reverse(palindrome_suffix)\n\
    \   end\n   return string.reverse(palindrome_prefix) .. palindrome_suffix\nend",
  "    -- Find a palindrome in a substring.\n    local longest_postfix = string\n\
    \    local longest_postfix_index = -1\n    local longest_prefix_length = -1\n\
    \    local longest_prefix_index = -1\n    for i = 1, #string do\n        local\
    \ postfix = string:sub(i,i)\n        local prefix_length = #string\n        local\
    \ prefix_index = i\n        if string.len(postfix) == 0 then\n            longest_prefix_index\
    \ = prefix_index\n            longest_prefix_length = prefix_length\n        elseif\
    \ string.len(postfix) == 1 then\n            longest_prefix_length = prefix_length\n\
    \            longest_postfix = postfix\n        elseif string.len(postfix) > longest_prefix_length\
    \ then\n            longest_prefix_length = string.len(postfix)\n            longest_prefix_index\
    \ = prefix_index\n            longest_postfix = postfix\n        end\n    end\n\
    \    if string.len(longest_postfix) == 0 then\n        return string\n    end",
  "  if string == nil then string = '' end", "    local reverse, prefix\n    repeat\n\
    \        local last = reverse[#reverse]\n        reverse = reverse:reverse()\n\
    \        prefix = string\n        string = last .. string\n    until not (last\
    \ == prefix)\n    return string\nend", "  local reverse = string\n  local i =\
    \ #string - 1\n  repeat\n    string = string .. string[i]\n    i = i - 1\n  until\
    \ string.char:sub(1, 1) == 'c'\n  reverse = reverse .. string\n  return string\n\
    end", "    local palindrome = string\n    local index = 0\n    while string[index]\
    \ == string[index + 1] do\n        index = index + 1\n    end\n    local palindrome_prefix,\
    \ palindrome_suffix, reverse = string.sub(palindrome, index, index), string.sub(palindrome,\
    \ index, index - 1), string.char(tonumber(reverse))\n    while palindrome_prefix:sub(1,1)\
    \ == reverse do\n        palindrome_prefix = palindrome_prefix:sub(2)\n    end\n\
    \    string = string .. reverse .. palindrome_suffix\n    return string\nend",
  "   if string == nil then string = '' end\n   local reverse = ''\n   local longest\
    \ = #string\n   for i = 1, longest do reverse = reverse .. string[i] end\n   local\
    \ suffix = ''\n   for i = 1, longest do\n      if i == (longest - 1) then suffix\
    \ = '' end\n      if string[i + (longest - 1)] == string[i] then\n         suffix\
    \ = suffix .. string[i] .. reverse\n      else\n         suffix = suffix .. string[i]\n\
    \      end\n   end\n   return string .. reverse .. suffix\nend", "    local prefix\
    \ = string\n    local suffix_reverse = string\n    local suffix_length = 0\n \
    \   local suffix_length_set = false\n    local suffix_length_reverse = 0\n   \
    \ while true do\n        local suffix_length = suffix_length + 1 -- Update suffix_length\
    \ because we're counting characters each time\n        -- if suffix is already\
    \ palindrome\n        -- if suffix is longer than longest palindrome\n       \
    \ -- if suffix is a palindrome\n        if suffix_length_reverse == suffix_length\
    \ then\n            if suffix_length < suffix_length_reverse then\n          \
    \      -- The longest palindrome that begins with a supplied string is suffix_length\
    \ characters.\n                -- If this palindrome is shorter than suffix_length,\
    \ that is the answer we're looking for.\n                return prefix\n     \
    \       end\n            break\n        end\n        local suffix_reversed_substring\
    \ = reverse(suffix_reverse)\n        local suffix_reversed_substring_reverse =\
    \ reverse(suffix_reversed_substring)\n        local suffix_substring = suffix_reverse\
    \ .. suffix_reversed_substring\n        local suffix_substring_reverse = suffix_reverse\
    \ .. suffix_reversed_substring_reverse\n        if suffix_substring_reverse ==\
    \ suffix_substring then\n            suffix_length_set = true\n            suffix_length\
    \ = suffix_length + 1\n            suffix_length_reverse = suffix_length_reverse\
    \ + 1\n            -- The string suffix that we've just counted is palindrome\n\
    \            -- We will just append the reverse of this string prefix.\n     \
    \       -- We know that the first character of the string we're appending will\
    \ always be the\n            -- longest palindromic suffix that we've seen, since\
    \ it ends with the longest palindrome\n            -- we've seen so far.\n   \
    \         if suffix == suffix then\n                -- This suffix is a palindrome\n\
    \                return (prefix .. suffix_reverse)\n            end\n        else\n\
    \            suffix_length_set = false\n            suffix_length = suffix_length\
    \ + 1\n            suffix_length_reverse = suffix_length_reverse + 1\n       \
    \ end\n    end\n    return ''\nend", "   assert(string)\n   local maxlen = string.len(string)\n\
    \   local prefix\n   local suffix\n   for suffix = 1, maxlen do\n      -- Find\
    \ longest postfix that is a palindrome.\n      if string.sub(string, maxlen-suffix)\
    \ == string.sub(string, reverse(string:sub(1, maxlen-suffix))) then\n        \
    \ maxlen = suffix\n         -- Append the reverse of the string prefix that comes\
    \ before this suffix.\n         -- This ensures that we only pick palindromes\
    \ of the same length, as we\n         -- do not want to pick palindromes of different\
    \ lengths.\n         prefix = string.sub(string, 1, maxlen)\n      end\n   end\n\
    \   return prefix..string..reverse(string:sub(1, maxlen))\nend", "\tlocal max_len\
    \ = #string + 1\n\twhile max_len > 1 do\n\t\tlocal pos = max_len - 2\n\t\tif string.sub(string,pos,pos)\
    \ == string.sub(string,pos,pos) then\n\t\t\t-- If the string is a palindrome,\
    \ return it.\n\t\t\t-- The returned string is guaranteed to be of length one.\n\
    \t\t\treturn string\n\t\tend\n\t\t-- If the string is not a palindrome, find its\
    \ longest postfix.\n\t\tlocal max_len = max_len - 1\n\tend\n\t-- If the string\
    \ is not a palindrome, return it as-is.\n\treturn string\nend", "    local suffix\n\
    \    local max_post_palindrome\n    local prefix_to_use\n    local found_palindrome\n\
    \    local prefix\n    local string_to_reverse"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
