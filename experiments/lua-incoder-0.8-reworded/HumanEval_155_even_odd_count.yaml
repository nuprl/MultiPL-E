name: HumanEval_155_even_odd_count
language: lua
prompt: "-- Given an integer. return a table that has the number of even and odd digits\
  \ respectively.\n-- Example:\n-- >>> even_odd_count(-12)\n-- {1, 1}\n-- >>> even_odd_count(123)\n\
  -- {1, 2}\nlocal function even_odd_count(num)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = even_odd_count\n\
  \    lu.assertEquals(candidate(7), {0, 1})\n    lu.assertEquals(candidate(-78),\
  \ {1, 1})\n    lu.assertEquals(candidate(3452), {2, 2})\n    lu.assertEquals(candidate(346211),\
  \ {3, 3})\n    lu.assertEquals(candidate(-345821), {3, 3})\n    lu.assertEquals(candidate(-2),\
  \ {1, 0})\n    lu.assertEquals(candidate(-45347), {2, 3})\n    lu.assertEquals(candidate(0),\
  \ {1, 0})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\t-- If the number is negative, return an empty table\n\tif num < 0\
    \ then\n\t\treturn {}\n\tend", "  if num == 0 then\n    return {1, 0}\n  end",
  "    local table = {}\n    local i = 1\n    while num > 0 do\n        table.insert(table,\
    \ num % 2)\n        num = math.floor(num / 10)\n        i = i + 1\n    end\n \
    \   return table\nend", "  local count = { }\n  for i = 0, 100 do\n    if num\
    \ % i == 0 then\n      table.insert(count, i)\n    end\n  end\n  return count\n\
    end", "  local even = {}\n  local odd = {}\n  for i = 1, 10 do\n    if num % 2\
    \ == 0 then\n      table.insert(even, i)\n    else\n      table.insert(odd, i)\n\
    \    end\n    num = math.floor(num / 2)\n  end\n  return even, odd\nend", "\t\
    -- Initialise the result table to contain two empty elements.\n\tlocal ret = {}\n\
    \t\n\t-- While a loop condition is valid, execute the body of the loop.\n\twhile\
    \ num > 0 do\n\t\t-- Add num/2 to ret[1] and num/2 to ret[2].\n\t\tret[1] = ret[1]\
    \ + 1\n\t\tret[2] = ret[2] + 1 \n\t\t\n\t\t-- Reduce num by two.\n\t\tnum = num\
    \ / 2\n\tend\n\t\n\treturn ret\nend", "  local ret = {}\n  local count = 0", " \
    \ if num < 0 then\n    return {}\n  end\n  local count = {}\n  local i = 1\n \
    \ while i <= math.floor(math.log(num) / math.log(2)) do\n    table.insert(count,\
    \ math.modf(math.pow(num, 2)) * (not i % 2))\n    i = i + 1\n  end\n  return count\n\
    end", "  -- We will count from 2 to avoid duplicates. We need this if we have\
    \ negative numbers.\n  local digits = math.floor(math.log(math.abs(num), 10))\n\
    \  local table = {}\n  for i = 2, digits do\n    table.insert(table, num % 10)\n\
    \    num = num / 10\n  end\n  table.insert(table, num % 10)\n  return table\n\
    end", "   local odds, evens = 0, 1\n   if num < 0 then\n      odds = num\n   else\n\
    \      for i = 1, num do\n         local t = i\n         if i % 2 == 0 then\n\
    \            t = t / 2\n         else\n            evens = evens * 2 + 1\n   \
    \      end\n         odds = odds + t\n      end\n   end\n   return { evens, odds\
    \ }\nend", "  local even = 0\n  local odd = 0", "  local even = nil\n  local odd\
    \ = nil\n  -- If the number is positive, then all even digits will be 0 and the\
    \ even count will be even\n  if num > 0 then\n    even = {}\n    for i = 1, math.floor(math.log10(num)+1)\
    \ do\n      if math.mod(num, 10) == 0 then\n        even = even + 1\n      end\n\
    \      num = num / 10\n    end\n  end\n  -- If the number is negative, then all\
    \ odd digits will be 0 and all odd count will be odd\n  if num < 0 then\n    odd\
    \ = {}\n    for i = 1, math.floor(math.log10(num)+1) do\n      if math.mod(num,\
    \ 10) == 0 then\n        odd = odd + 2\n      end\n      num = num / 10\n    end\n\
    \  end\n  return even, odd\nend", "\tlocal even_count = 1\n\tlocal odd_count =\
    \ 1\n\twhile num >= 1 do\n\t\tif num % 2 == 0 then\n\t\t\teven_count = even_count\
    \ + 1\n\t\telseif num % 2 ~= 0 then\n\t\t\todd_count = odd_count + 1\n\t\tend\n\
    \t\tnum = num / 2\n\tend\n\treturn { even_count, odd_count }\nend", "    local\
    \ t = {}\n    -- If it's negative, no need to check.\n    if num < 0 then return\
    \ t end\n    -- If the number is a multiple of 100, then it must be an even number.\n\
    \    if num % 100 == 0 then\n        t[1] = true\n        return\n    end\n  \
    \  -- If the number is divisible by 10, then it's an even number.\n    if num\
    \ % 10 == 0 then\n        t[1] = true\n        return\n    end\n    -- If the\
    \ number is divisible by 5, then it's an even number.\n    if num % 5 == 0 then\n\
    \        t[1] = true\n        return\n    end", '  num = math.floor(num)', " \
    \   local even = 1\n    local odd = 1\n    while num > 0 do\n        if num &\
    \ 1 then\n            even = even + 1\n        else\n            odd = odd + 1\n\
    \        end\n        num = num >> 1\n    end\n    return even, odd\nend", " \
    \ local even, odd = 1, 0\n  local t = {0, 1}\n  while num > 0 do\n    local tmp\
    \ = num % 10\n    if tmp > 0 and t[tmp] == nil then\n      even = even + 1\n \
    \     t[tmp] = even\n    elseif tmp == 0 and t[tmp] == nil then\n      odd = odd\
    \ + 2\n      t[tmp] = odd\n    end\n    num = math.floor(num / 10)\n  end\n  return\
    \ t\nend", "  if num < 0 then return end\n  local even = 0\n  local odd = 0\n\
    \  for i = 1, math.floor(math.log(num, 2)) do\n    local tmp = num / math.pow(10,\
    \ i * 2)\n    if tmp % 2 == 1 then\n      even = even+1\n    else\n      odd =\
    \ odd+1\n    end\n  end\n  return even, odd\nend", "  local even = tonumber(math.remainder(num,\
    \ 2))\n  local odd = tonumber(math.remainder(num, 2))\n  return even, odd\nend",
  "  local ret = {}\n  if num < 0 then\n    return ret\n  end\n  local count = 1\n\
    \  repeat\n    local tmp = math.floor(num / 2)\n    num = tmp\n    if tmp % 2\
    \ == 1 then\n      table.insert(ret, count)\n    end\n    count = count + 1\n\
    \  until num == 0\n  return ret\nend", "    local odd_count = 0\n    local even_count\
    \ = 0\n    for _ in num:gmatch(\"%d+\") do\n        if num % 2 == 0 then\n   \
    \         even_count = even_count + 1\n        else\n            odd_count = odd_count\
    \ + 1\n        end\n        num = math.floor(num / 10)\n    end\n    return {\
    \ even = even_count, odd = odd_count }\nend", "  local even, odd = {}, {}\n  \n\
    \  for i = 1,math.floor(math.log(num,2)) do\n    table.insert(even, num % 2 ~=\
    \ 0 and 1 or -1)\n    table.insert(odd, num % 2 ~= 0 and -1 or 1)\n    num = math.floor(num\
    \ / 10)\n  end\n  \n  return table.unpack(table.concat(even, ' '), 1, table.unpack(table.concat(odd,\
    \ ' '), 1, 2))\nend", "   if num < 0 then\n      return {}\n   end\n   local even,\
    \ odd = 0, 1\n   while num > 0 do\n      num = math.floor(num / 10)\n      if\
    \ num % 2 ~= 0 then\n         even = even + 1\n      else\n         odd = odd\
    \ + 1 \n      end\n   end\n   return { even, odd }\nend", "  if num < 0 then return\
    \ nil end\n  local num_str = tostring(num)", "   local oddTable = {}\n   local\
    \ evenTable = {}\n   for n = 1, num:bit_length() do\n      if num % 2 == 0 then\n\
    \         table.insert(evenTable, num:byte(n, 1))\n      else\n         table.insert(oddTable,\
    \ num:byte(n, 1))\n      end\n   end\n   return { even = table.concat(evenTable,\
    \ \"\"), odd = table.concat(oddTable, \"\") }\nend", "    local ret = {}\n   \
    \ local count = 0\n    for _, v in ipairs(num) do\n        count = count+1\n \
    \       if v == 0 and count%2 == 0 then\n            table.insert(ret, 2)\n  \
    \      elseif v == 0 and count%2 == 1 then\n            table.insert(ret, 1)\n\
    \        elseif v == 1 then\n            table.insert(ret, 2)\n        end\n \
    \   end\n    return ret\nend", "\tnum = tonumber(num)", "    local num_digits\
    \ = math.floor(math.log(num) / math.log(10))\n    local even, odd = {}, {}\n \
    \   for i = 1, num_digits do\n        local digit = math.trunc(num / 10)\n   \
    \     if i % 2 == 1 then\n            even[digit] = even[digit] or {}\n      \
    \      even[digit][true] = true\n        else\n            odd[digit] = odd[digit]\
    \ or {}\n            odd[digit][false] = true\n        end\n        num = num\
    \ - 10 * digit\n    end\n    return even, odd\nend", "  local even = {}\n  local\
    \ odd = {}\n  for i = 1, math.floor(math.log(math.abs(num), 1)) do\n    local\
    \ remainder = math.mod(num, i)\n    if remainder == 0 then\n      table.insert(even,\
    \ i)\n    else\n      table.insert(odd, i)\n    end\n    num = math.floor(num\
    \ / i)\n  end\n  return { even, odd }\nend", "    local even, odd = 0, 1\n   \
    \ for i = 1, 10 do\n        if ((num mod i) == 0) then\n            even = even+1\n\
    \        else\n            odd = odd+1\n        end\n    end\n    return {even,\
    \ odd}\nend", "    local evens, odds = { 0 }, { 0 }\n    for i = 1, 10 do\n  \
    \      if num % i == 0 then\n            evens[#evens + 1] = i\n        end\n\
    \        if num % i != 0 then\n            odds[#odds + 1] = i\n        end\n\
    \    end\n    return evens, odds\nend", "  local odd_digits = {}\n  local even_digits\
    \ = {}\n  for i = 1, 10 do\n    local remainder = num % i\n    -- Check if the\
    \ number if even\n    if remainder ~= 0 then\n      table.insert(even_digits,\
    \ i)\n    else\n      table.insert(odd_digits, i)\n    end\n    num = num / i\n\
    \  end\n  return {table.unpack(even_digits), table.unpack(odd_digits)}\nend",
  "  local even, odd = {}, {}\n  for i = 1, #num do\n    if num % i == 0 then\n  \
    \    even[#even+1] = i\n    elseif num % i ~= 0 then\n      odd[#odd+1] = i\n\
    \    end\n  end\n  return even, odd\nend", "    if num < 0 then\n        return\
    \ {}\n    end\n    local count_even = {} -- Initialize to empty table\n    local\
    \ count_odd = {} -- Initialize to empty table\n    local count = 1\n    while\
    \ num > 0 do\n        if num % 2 == 0 then\n            count_even[count] = count_even[count]\
    \ or {}\n            count_even[count][2] = count_even[count][2] or num\n    \
    \        count_odd[count] = count_odd[count] or {}\n            count_odd[count][1]\
    \ = 1\n        else\n            count_even[count] = count_even[count] or {}\n\
    \            count_even[count][1] = count_even[count][1] or num\n            count_odd[count]\
    \ = count_odd[count] or {}\n            count_odd[count][2] = count_odd[count][2]\
    \ or 1\n        end\n        num = math.floor(num / 2)\n        count = count\
    \ + 1\n    end\n    count_even[count] = count_even[count] or {}\n    count_odd[count]\
    \ = count_odd[count] or {}\n    count_even[count][2] = count_even[count][2] or\
    \ num\n    count_odd[count][2] = count_odd[count][2] or num\n    return count_even,\
    \ count_odd\nend", "  local odd = {}\n  local even = {}\n  for n in string.gmatch(string.rep(num,\
    \ 2, '%d'), '%d') do\n    if n ~= 0 then\n      even[n - 1] = even[n - 1] + 1\n\
    \    else\n      odd[#odd + 1] = #odd\n    end\n  end\n  return {even, odd}\n\
    end", "  local even = 0\n  local odd = 0\n  -- count the number of even and odd\
    \ digits\n  for i = 1, math.floor(math.log(num)/math.log(2)) do\n    -- add 1\
    \ to the number of even digits\n    if math.mod(i, 2) == 0 then\n      even =\
    \ even+1\n      -- subtract 1 from the number of odd digits\n    elseif math.mod(i,\
    \ 2) == 1 then\n      odd = odd+1\n    end\n  end\n  return { even, odd }\nend",
  "    local odd_count = {}\n    local num_str = tostring(num)\n    -- Count odd and\
    \ even\n    for idx = 1,#num_str do\n        local digit = tonumber(num_str:subidx(idx))\n\
    \        if digit == 0 then\n            odd_count[1] = odd_count[1] + 1 -- Count\
    \ odd digit\n        else\n            odd_count[2] = odd_count[2] + 1 -- Count\
    \ even digit\n        end\n    end\n    return odd_count\nend\n</cell>\n<cell>",
  "  local odd = 1\n  local even = 1\n  while true do\n    local remainder = math.mod(num,\
    \ 10)\n    if remainder == 0 then\n      table.insert(even, even)\n      table.insert(odd,\
    \ odd)\n      break\n    end\n    num = math.floor(num / 10)\n    table.insert(even,\
    \ even)\n    table.insert(odd, odd)\n  end\n  return even, odd\nend", "   local\
    \ odd_count = 0\n   local even_count = 0\n   local i = 0\n   while i < num do\n\
    \      if ((num % 10) % 2 == 1) then\n         odd_count = odd_count + 1\n   \
    \   else\n         even_count = even_count + 1\n      end\n      i = i + 1\n \
    \  end\n   return { even_count, odd_count }\nend", "  local even, odd = 0, 1\n\
    \  for _ = 1, math.floor(math.log(num, 2)) do\n    local digit = math.floor(math.fmod(num,\
    \ 2)) -- Get the last digit\n    if digit == 0 then -- If the last digit is 0,\
    \ it is even\n      even = even + 1\n    else\n      odd = 1 + odd\n    end\n\
    \    num = math.floor(num / 2) -- Remove the last digit\n  end\n  return { even,\
    \ odd }\nend", "  local even, odd = 0, 1\n  for _, i in pairs(string.gmatch(tostring(num),\
    \ '%d*[%d%d]+')) do\n    even = even + (i ~= 0)\n    odd = odd * (i % 2)\n  end\n\
    \  return { even = even, odd = odd }\nend", "  if num < 0 then return {}\n  local\
    \ even = {}\n  local odd = {}\n  -- Find the number of digits in the given number\n\
    \  -- We are assuming that the given number is positive.\n  for i = 1, num:len()\
    \ do\n    local digit = num:sub(i, i)\n    if digit % 2 = 0 then even[#even +\
    \ 1] = digit end\n    if digit % 2 ~= 0 then odd[#odd + 1] = digit end\n  end\n\
    \  return even, odd\nend", "  -- If number is even, count the even, otherwise\
    \ count the odd\n  local even = num % 2 == 0 and 1 or 0\n  -- Return table\n \
    \ local result = {}\n  for i = 1, 10, 2 do\n    local number = num / i\n    local\
    \ odd = number % 2 == 1 and 1 or 0\n    result[even] = result[even] or odd and\
    \ even\n  end\n  -- Return table\n  return result\nend", "  -- Initialize count\n\
    \  local count = {}\n  -- Iterate from left to right\n  for i = 1, 10 do\n   \
    \ -- Store the number modulo 10, i.e. the digit\n    local digit = num %10\n \
    \   -- If the number is even, add one to the count of even digits\n    count[digit]\
    \ = count[digit] or 1\n    -- If the number is odd, subtract one from the count\
    \ of odd digits\n    if digit == 0 then\n      count[digit] = count[digit] - 1\n\
    \    end\n    -- Get the next number\n    num = num / 10\n  end\n  return count\n\
    end", "  local result\n  if num > 0 then\n    local even = 1\n    local odd =\
    \ 0\n    for i=1,math.floor(math.log(num,2)) do\n      local tmp = math.pow(num,2)/even\n\
    \      if num >= tmp then\n        even = even+1\n      else\n        odd = odd+1\n\
    \      end\n    end\n    \n    if even > odd then\n      result = even\n    else\n\
    \      result = odd\n    end\n  else\n    result = 1\n  end\n  \n  return result\n\
    end\n</cell>\n<code language=julia-1.4>\neven_odd_count(1)\n</cell>\n<code language=julia-1.4>\n\
    even_odd_count(10)\n</cell>\n<code language=julia-1.4>\neven_odd_count(1000)\n\
    </cell>\n<code language=julia-1.4>\neven_odd_count(-4)\n</cell>\n<code language=julia-1.4>\n\
    even_odd_count(-100)\n</cell>\n<code language=julia-1.4>\neven_odd_count(0)\n\
    </cell>\n<code language=julia-1.4>\neven_odd_count(-2)\n</cell>\n<code language=julia-1.4>\n\
    even_odd_count(-1)\n</cell>\n<code language=julia-1.4>\neven_odd_count(1)\n</cell>\n\
    <code language=julia-1.4>\neven_odd_count(10)\n</cell>\n<code language=julia-1.4>\n\
    even_odd_count(1000)\n</cell>\n<code language=julia-1.4>\neven_odd_count(-4)\n\
    </cell>\n<code language=julia-1.4>\neven_odd_count(-100)\n</cell>\n<code language=julia-1.4>\n\
    even_odd_count(0)\n</cell>\n<code language=julia-1.4>\neven_odd_count(-2)\n</cell>\n\
    <code language=julia-1.4>\neven_odd_count(-1)\n</cell>\n<code language=julia-1.4>\n\
    even_odd_count(1)\n</cell>\n<code language=julia-1.4>\neven_odd_count(10)\n</cell>\n\
    <code language=julia-1.4>\neven_odd_count(1000)\n</cell>\n<code language=julia-1.4>\n\
    even_odd_count(-4)\n</cell>\n<code language=julia-1.4>\neven_odd_count(-100)\n\
    </cell>\n<code language=julia-1.4>\neven_odd_count(0)\n</cell>\n<code language=julia-1.4>\n\
    even_odd_count(-2)\n</cell>\n<code language=julia-1.4>", "  num = tonumber(num)\n\
    \  if num == 0 then\n    return {0, 0}\n  else\n    local even, odd = 1, 0\n \
    \   while true do\n      even = even * 10 + num % 10\n      odd = odd + 1\n  \
    \    num = math.floor(num / 10)\n      if not num then\n        break\n      end\n\
    \    end\n    return {even, odd}\n  end\nend", "  num = num + 0\n  local even,\
    \ odd = {}, {}\n  local num_digits = math.floor(math.log(abs(num), 10)) + 1\n\
    \  for i = 1, num_digits do\n    if num % 2 == 0 then\n      table.insert(even,\
    \ i)\n    else\n      table.insert(odd, i)\n    end\n    num = math.floor(num\
    \ / 2)\n  end\n  return even, odd\nend", "  -- Write your code here.\nend", " \
    \ if num == 0 then\n    return {0, 0}\n  end\n  local even, odd = 0, 0\n  for\
    \ i = 1, 9 do\n    local remainder = num % i\n    if remainder == 0 then\n   \
    \   even = even + 1\n    else\n      odd = odd + 1\n    end\n    num = num / i\n\
    \  end\n  table.insert(table, 0, even)\n  table.insert(table, 0, odd)\n  return\
    \ table\nend", "  local even = math.floor((num - math.floor(num)) % 2)\n  local\
    \ odd = math.floor((num - math.floor(num)) / 2)\n  if even > 0 then\n    return\
    \ {even, odd}\n  else\n    return {odd, even}\n  end\nend", "  if num == 0 then\n\
    \    return {}\n  end", "    local even = num % 2\n    local odd = num / 2", " \
    \ if num < 0 then\n    return {}\n  end\n  local count = { }\n  for i = math.floor(math.log(math.abs(num),\
    \ 1)) + 1, 1, -1 do\n    local n = math.floor((num / i) * 2)\n    if n % 2 ==\
    \ 1 then table.insert(count, n) end\n  end\n  return count\nend", "\t-- If the\
    \ number is negative, return an empty table.\n\tif num < 0 then\n\t\treturn {}\n\
    \tend", "  local table = {{}, {}}\n  local digit = string.len(tostring(num))",
  "  if num == 0 then\n    return {}\n  end\n  local t = {0, 0}\n  while num >= 10\
    \ do\n    t[1] = t[1] + 1\n    num = math.floor(num / 10)\n  end\n  if num ~=\
    \ 0 then\n    t[1] = t[1] + 1\n  end\n  return t\nend", "  if num < 0 then\n \
    \   error(\"cannot find even and odd digits for negative number\")\n  end", "\t\
    num = tonumber(num)\n\tlocal t = {}\n\t\n\tif num < 0 then return nil end\n\t\n\
    \tif num >= 0 then\n\t\tif num == 0 then\n\t\t\tt.even.count = 0\n\t\t\tt.odd.count\
    \ = 0\n\t\telse\n\t\t\tlocal even, odd = divmod(num, 10)\n\t\t\tt.even.count =\
    \ t.even.count or even\n\t\t\tt.odd.count = t.odd.count or odd\n\t\tend\n\tend\n\
    \treturn t\nend\n</cell>\n<text>\nProblem 3: Convert binary to decimal - Problem\
    \ Set 5", "  local tx = {}\n  local n = math.floor(num)\n  for i = 1, math.floor(num\
    \ / 2) do\n    tx[i] = 1\n  end\n  for i = 1, n do\n    if num % 2 == 0 then\n\
    \      tx[i + 1] = tx[i] + 1\n    elseif num % 2 ~= 0 then\n      tx[i + 1] =\
    \ tx[i]\n    end\n  end\n  return tx\nend", "  local even_count, odd_count = 0,\
    \ 1\n  if num == 0 then\n    return {even_count, odd_count}\n  end\n  local div,\
    \ mod = div(num, 10)\n  local digit = mod\n  while div > 0 do\n    if num % div\
    \ == 0 then\n      even_count = even_count+1\n    end\n    if digit == 0 then\n\
    \      break\n    end\n    digit = digit/10\n    odd_count = odd_count+1\n  end\n\
    \  table.insert(even_odd_count, even_count)\n  table.insert(even_odd_count, odd_count)\n\
    \  return even_odd_count\nend", "\tlocal evens, odds = { 0 }, { 0 }\n\t\n\tfor\
    \ i = 1, 10 do\n\t\tif math.fmod(num, i) == 0 then\n\t\t\tevens[#evens+1] = i\n\
    \t\telse\n\t\t\todds[#odds+1] = i\n\t\tend\n\tend\n\t\n\treturn { evens, odds\
    \ }\nend", "  local odd = {}\n  local even = {}\n  local count = num\n  while\
    \ (not count or count > 0) do\n    count = math.floor(count / 10)\n    if count\
    \ % 2 == 0 then\n      table.insert(even, count)\n    else\n      table.insert(odd,\
    \ count)\n    end\n  end\n  return table.concat(even, '/') .. '/' .. table.concat(odd,\
    \ '/')\nend", "  local count = {}\n  if num == 0 then\n    return count\n  end",
  "  local tbl = {}\n  for i = 1, #num do\n    tbl[i] = (string.sub(num, i, i) ==\
    \ 0)\n  end\n  return tbl\nend", "  if num <= 0 then\n    return {}\n  else\n\
    \    local result = {}\n    local i = 0\n    repeat\n      i = i + 1\n      if\
    \ not num then break end\n      if num % 2 == 0 then result.even[#result.even\
    \ + 1] = i end\n      if num % 2 == 1 then result.odd[#result.odd + 1] = i end\n\
    \      num = num >> 1\n    until num == 0\n    return result\n  end\nend", " \
    \ if num == 0 then return {0,0}\n  elseif num <= 0 then return {1,0}\n  else\n\
    \    local num = math.floor(num)\n    local even, odd = 1, 1\n    while num >\
    \ 0 do\n      if num % 2 ~= 0 then\n        even = even * 10 + num % 2\n     \
    \ else\n        odd = odd * 10 + num % 2\n      end\n      num = math.floor(num\
    \ / 10)\n    end\n    return {even, odd}\n  end\nend", "  local evens, odds =\
    \ 0, 1\n  local max_num = tonumber(tostring(num))\n  while true do\n    evens\
    \ = evens + (max_num % 2 ~= 0 and 1 or 0)\n    odds = odds + (max_num % 2 ~= 1\
    \ and 1 or 0)\n    max_num = max_num / 10\n    if max_num == 0 then break end\n\
    \  end\n  return evens, odds\nend", "   if num < 0 then\n      return {1, 0}\n\
    \   end\n   local t = {}\n   if num < 10 then\n      t[1] = t[1] + 1\n      return\
    \ t\n   end\n   if num >= 10 and num % 10 == 2 then\n      t[1] = t[1] + 1\n \
    \  elseif num >= 10 and num % 10 == 1 then\n      t[2] = t[2] + 1\n   else\n \
    \     t[1] = t[1] + 1\n   end\n   return t\nend", "  local even = {}\n  local\
    \ odd = {}\n  local n = 0\n  local sum = 0\n  while num ~= 0 do\n    sum = sum\
    \ + num % 10\n    n = n + 1\n    num = num / 10\n    if num == 0 then\n      odd[n]\
    \ = sum\n      sum = 0\n      n = n - 1\n    end\n    if num > 0 then\n      even[n]\
    \ = sum\n      sum = 0\n      n = n - 1\n    end\n  end\n  return even, odd\n\
    end", "  local even_count = even_count(num)\n  local odd_count = odd_count(num)\n\
    \  return {even_count, odd_count}\nend", "  local table = {}\n  if num then\n\
    \    local n = math.floor(math.log(num) / math.log(2)) -- Get number of even,\
    \ odd digits.\n    local i, cnt\n    for i = 1,n do\n      cnt = 0\n      while\
    \ num ~= 0 do\n        if num % 2 ~= 0 then\n          num = math.floor(num /\
    \ 2)\n          cnt = cnt + 1\n        else\n          num = math.floor(num /\
    \ 2)\n        end\n      end\n      table.insert(table, cnt)\n    end\n  else\n\
    \    table.insert(table, 0)\n  end\n  return table\nend", "    local even, odd\
    \ = 1, 1\n    for i = 1, num do\n        if i mod 2 == 0 then\n            even\
    \ = even + 1\n        else\n            odd = odd + 0\n        end\n    end\n\
    \    return {even, odd}\nend", "    local even = {}\n    local odd = {}\n    local\
    \ count = 2\n    while count < 10 do\n        local mod = math.modf(math.floor(num\
    \ / 10))\n        if mod ~= nil then\n            if mod[1] == 2 then\n      \
    \          even[count] = true\n            elseif mod[1] == 1 then\n         \
    \       odd[count] = true\n            end\n        end\n        count = count\
    \ + 1\n    end\n    local result = {}\n    table.insert(result, #even)\n    table.insert(result,\
    \ #odd)\n    return result\nend", "  local evens = {}\n  local odds = {}", " \
    \   local even = {}\n    local odd = {}\n    for digit = 1, 10 do\n        if\
    \ num % 2 == 0 then\n            even[digit] = 1 + even[digit]\n        else\n\
    \            odd[digit] = 1 + odd[digit]\n        end\n        num = math.floor(num\
    \ / 10)\n    end\n    return even, odd\nend", "  if num == 0 then\n    return\
    \ {}\n  end", "    local even = even_odd();\n    local odd = even_odd();\n   \
    \ if num >= 0 then\n        local count_even = even[#even];\n        local count_odd\
    \ = odd[#odd];\n        if num - count_even - count_odd > 0 then\n           \
    \ even[#even] = num - count_even - count_odd;\n            odd[#odd] = count_even;\n\
    \        else\n            even[#even] = 0;\n            odd[#odd] = count_odd;\n\
    \        end\n        return even, odd;\n    else\n        local count_even =\
    \ even[#even];\n        local count_odd = odd[#odd];\n        if count_even +\
    \ count_odd <= num and count_even ~= count_odd then\n            even[#even] =\
    \ count_even + count_odd;\n            odd[#odd] = count_even;\n        end\n\
    \        return even, odd;\n    end\nend", "    local even, odd = 0, 1\n    \n\
    \    while num > 0 do\n        if num & 1 == 1 then\n            even = even +\
    \ 1\n        end\n        \n        num = num >> 1\n    end\n    \n    return\
    \ even, odd\nend\n</cell>\n<text>\nNext, write a function that, given a number\
    \ as a string, returns a new string where all the odd digits of the string are\
    \ moved to the left and the even digits moved to the right. Let's call this function\
    \ even_odd_rearrange. We will do this for several examples.", "   if num < 0 then\n\
    \      return nil\n   end\n   local ts = {}\n   if num < 2 then\n      return\
    \ ts\n   end\n   local i = 0\n   while i < num do\n      ts[i] = 1\n      i =\
    \ i + 1\n   end\n   local j = 1\n   while j < num do\n      ts[j] = ts[j] + ts[i]\n\
    \      j = j + 1\n      i = i + 1\n   end\n   return ts\nend", "   if num == 0\
    \ then\n      return {}\n   end\n   local even = {}\n   local odd = {}\n   for\
    \ i = 1, (math.floor(math.log(num + 1, 2))) do\n      if num % i == 0 then\n \
    \        table.insert(even, i)\n      else\n         table.insert(odd, i)\n  \
    \    end\n   end\n   return {table.concat(even), table.concat(odd)}\nend", " \
    \ local ret = {}\n  local reminder = math.floor(num)\n  if reminder == 0 then\n\
    \    ret[1] = true\n    ret[2] = true\n    return\n  end\n  if num / 2 ~= math.floor(reminder\
    \ / 2) then\n    ret[1] = true\n    ret[2] = true\n    return\n  end\n  ret[1]\
    \ = false\n  ret[2] = true\n  while reminder ~= 0 do\n    reminder, rem = divmod(reminder,\
    \ 2)\n    ret[rem] = true\n  end\n  return ret\nend", "  local even = {}\n  local\
    \ odd = {}\n  local i, n = num, 1\n  while n ~= 0 do\n    table.insert(even, i)\n\
    \    i = i << 1\n    table.insert(odd, i)\n    i = i << 1\n    n = n >> 1\n  end\n\
    \  return { even = even, odd = odd }\nend", "\t-- We need to find the number of\
    \ digits, not the number of digits.\n\t-- We use digits to find the number of\
    \ even digits.\n\tlocal num_digits = math.floor(math.log(math.abs(num), 10)) +\
    \ 1", "    local even, odd = 0, 1\n    while true do\n        local current_number\
    \ = math.abs(num)\n        if current_number % 2 == 0 then\n            even =\
    \ even + 1\n        else\n            odd = odd + current_number % 2\n       \
    \ end\n        num = math.floor(num / 2)\n    end\n    local table = {even, odd}\n\
    \    return table\nend", "    if num < 0 then return {} end\n    local even, odd\
    \ = 0, 1\n    while num > 0 do\n        num = math.floor(num / 10)\n        even\
    \ = even + num%2\n        odd = odd*10 + num%2\n    end\n    local ans = {}\n\
    \    for i = 1, math.floor(math.log(abs(num), 2)) do\n        if even < num then\n\
    \            table.insert(ans, even)\n        elseif even == num then\n      \
    \      table.insert(ans, even)\n        elseif odd < num then\n            table.insert(ans,\
    \ odd)\n        elseif odd == num then\n            table.insert(ans, odd)\n \
    \       end\n    end\n    return ans\nend", "  if num < 0 then return nil end\n\
    \  if num == 0 then return { 0, 0 }\n  local td = {}\n  local i = 1\n  while i\
    \ <= math.floor(math.log(math.abs(num),10)) do\n    table.insert(td, math.mod(num,math.pow(10,i)))\n\
    \    num = math.trunc(num/math.pow(10,i))\n    i = i + 1\n  end\n  table.insert(td,\
    \ num)\n  return td\nend", "  local even = 1\n  local odd = 0\n  while num > 0\
    \ do\n    -- add one to count odd numbers, if there are an even number of digits\n\
    \    -- subtract one from the even number. Repeat the process until there are\
    \ only odd numbers\n    if num % 2 == 0 then\n      even = even + 1\n    else\n\
    \      odd = even - 1\n    end\n    num = math.floor(num / 2)\n  end\n  return\
    \ { even, odd }\nend", "    local even = {}\n    local odd = {}\n    local i =\
    \ 1\n    while i <= num do\n        if ((num % i) == 0) then\n            table.insert(even,\
    \ i)\n        else\n            table.insert(odd, i)\n        end\n        i =\
    \ i + 1\n    end\n    return table.concat(even, \"-\"), table.concat(odd, \"-\"\
    )\nend", "\tlocal even = 0\n\tlocal odd = 0\n\tlocal count = { even, odd }\n\t\
    while num > 0 do\n\t\tif num % 2 ~= 0 then\n\t\t\tcount = { even = even + 1, odd\
    \ = odd + 1 }\n\t\telse\n\t\t\tcount = { even = even, odd = odd + 1 }\n\t\tend\n\
    \t\tnum = math.floor(num / 2)\n\tend\n\treturn count\nend", "  local odd = 1\n\
    \  local even = 1\n  for i = 2, #num + 1 do\n    if (num % i == 0) then\n    \
    \  even = even * 2\n    else\n      odd = odd + 1\n    end\n  end\n  return {even,\
    \ odd}\nend", "  if num < 0 then\n    return {0, 0}\n  end\n  local odd = 0\n\
    \  local even = 0\n  for i = 1, math.floor(math.log(num, 2)) do\n    if math.fmod(num,\
    \ 2) == 1 then\n      even = even + 1\n    elseif math.fmod(num, 2) ~= 1 then\n\
    \      odd = odd + 2\n    end\n    num = math.fmod(num, 2)\n  end\n  local odd_digits\
    \ = math.floor(math.log10(odd + 1))\n  local even_digits = math.floor(math.log10(even))\n\
    \  return {odd_digits, even_digits}\nend", "  local t = {}\n  local i = 1\n  while\
    \ i <= math.sqrt(num) do\n    if num % i == 0 then\n      table.insert(t, i)\n\
    \      table.insert(t, num / i)\n    end\n    i = i + 1\n  end\n  if #t > 1 then\n\
    \    if #t > 2 then\n      table.insert(t, math.floor(math.sqrt(num)))\n    end\n\
    \  end\n  return t\nend", "  local table={}\n  local i=-1\n  while num>0 do\n\
    \    table[i+1]=math.floor((num-1)/10)\n    num=num-((table[i+1]-1)*10)\n    i=i+1\n\
    \  end\n  return table\nend", "    local even = 0\n    local odd = 0", "    if\
    \ num < 0 then\n        return nil\n    end\n    local result = {}\n    for i\
    \ = 1, 10 do\n        if ((num % 10) == 0) then\n            result[#result +\
    \ 1] = (i % 2)\n        end\n        num = math.floor(num / 10)\n    end\n   \
    \ return result\nend", "    if num < 0 then\n        return {1, 1}\n    end\n\
    \    local even = 1\n    local odd = 0\n    while num > 0 do\n        local remainder\
    \ = num % 10\n        if remainder == 0 then\n            even = even+1\n    \
    \    elseif remainder == 1 then\n            odd = odd+1\n        end\n      \
    \  num = num / 10\n    end\n    if even > odd then\n        return {even, odd}\n\
    \    else\n        return {odd, even}\n    end\nend", "  local num_str = tostring(num)\n\
    \  local num_len  = string.len(num_str)\n  local num_odd  = 0\n  local num_even\
    \ = 0\n  for i = 1, num_len do\n    if (string.sub(num_str, i, i) ~= '-') then\n\
    \      if ((num_str[i] == '2') and (num_str[i + 1] == '0')) then\n        num_even\
    \ = num_even + 1\n      elseif (num_str[i] == '0') then\n        num_odd = num_odd\
    \ + 1\n      end\n    end\n  end\n  return { num_even, num_odd }\nend\n</cell>\n\
    <cell>", "  local even = 0\n  local odd = 0\n  for i = 1, math.floor(math.log(num,\
    \ 10)) + 1 do\n    local digit = math.floor(num / math.pow(10, i))\n    if digit\
    \ % 2 == 0 then\n      even = even + 1\n    else\n      odd = odd + 0\n    end\n\
    \  end\n  local ret = {}\n  if even > 0 then\n    table.insert(ret, 1, even)\n\
    \  end\n  if odd > 0 then\n    table.insert(ret, 1, odd)\n  end\n  return ret\n\
    end", "  -- check if its an odd or even number\n  if num % 2 ~= 0 then\n    return\
    \ num > 0 and {1, num} or {1, -num}\n  else\n    -- find the number that has at\
    \ least two even digits and one odd digit\n    local digits = {1, num}\n    while\
    \ #digits > 2 do\n      local num = math.floor((#digits - 1) / 2)\n      if #digits[num]\
    \ ~= 0 then\n        digits[num] = digits[num] % 10\n      end\n    end\n    return\
    \ digits\n  end\nend", "  local odds = {}\n  local evens = {}\n  -- Start with\
    \ even digits\n  -- We start with -1 because 0 counts as odd.\n  -- When we encounter\
    \ a negative number we count up from 0 to the absolute number.\n  -- This ensures\
    \ that -1 counts as even even when the number is negative.\n  -- We use the second\
    \ table as our counter since our numbers are even and odd.\n  --\n  -- When we\
    \ encounter a positive number, we add it to the even table and subtract it from\
    \ the odd table.\n  -- This ensures that a positive number counts as even even\
    \ when the number is positive.\n  -- We use the second table as our counter since\
    \ our numbers are even and odd.\n  --\n  -- When we encounter a zero we simply\
    \ add it to the even table\n  --\n  -- When we encounter a non-digit, simply add\
    \ it to the odd table.\n  -- This ensures that non-digit numbers are counted as\
    \ odd when the number is non-digit.\n  -- We use the second table as our counter\
    \ since our numbers are even and odd.\n  -- The reason we use two different tables\
    \ is because we want to preserve the order of the digits in our output.\n  --\
    \ This also ensures that we account for leading zeros in the number when counting\
    \ the digits\n  --\n  -- The reason we need two counters is to account for leading\
    \ zeros.\n  for i = 1, math.ceil(math.log10(abs(num))) do\n    local digit = math.floor(math.pow(10,\
    \ (i)))\n    local numDigits = math.floor(num / digit)\n    if numDigits > 0 then\n\
    \      table.insert(evens, digit)\n    end\n    local numDigits2 = num % digit\n\
    \    if numDigits2 > 0 then\n      table.insert(odds, numDigits2)\n    end\n \
    \ end\n  return evens, odds\nend", "  local evens, odds = 1, 0\n  for i = 1, math.ceil(math.log(num,\
    \ 2)) do\n    if num % 2 == 0 then\n      evens = evens + 1\n    else\n      odds\
    \ = odds + 1\n    end\n    num = num / 2\n  end\n  return evens, odds\nend", " \
    \ local even = 0\n  local odd = 0\n  while num > 0 do\n    -- if num is odd and\
    \ even, then subtract them\n    -- if num is odd, then add 1 to the odd count\n\
    \    -- if num is even, then add 1 to the even count\n    if num % 2 == 0 then\n\
    \      even = even + 1\n    else\n      odd = odd + 1 -- odd count increases every\
    \ time even is subtracted\n    end\n    num = num / 2\n  end\n  return { even\
    \ = even, odd = odd }\nend\n</cell>\n<code language=ocaml-jupyter>\neven_odd_count(-20)\n\
    </cell>\n<text>\nProblem 2b\nWrite a function that takes a number and returns\
    \ its integer part.", "  local even = 0\n  local odd = 0\n  local tmp = num\n\
    \  while tmp ~= 0 do\n    -- get the last digit.\n    local last_digit = math.floor(tmp\
    \ % 10)\n    -- if the last digit is even.\n    if last_digit % 2 == 0 then\n\
    \      even = even + 1\n    end\n    -- if the last digit is odd.\n    if last_digit\
    \ % 2 ~= 0 then\n      odd = 1 + odd\n    end\n    -- get the last two digits.\n\
    \    tmp = tmp / 10\n  end\n  return { even, odd }\nend", "\tnum = tonumber(num)\n\
    \tlocal odd_count = 1, 0\n\tlocal even_count  = 1, 0\n\tlocal results = {{}, {}}\n\
    \tlocal m = math.floor(math.log(num, 2))\n\tlocal count = 0", "    local even,\
    \ odd = 1, 1\n    while num > 0 do\n        even = even + 1 -- count evens\n \
    \       if num % 2 ~= 0 then break end\n        odd = odd + 1 -- count odds\n\
    \        num = num div 2\n    end\n    return even, odd\nend", "    local even\
    \ = {}\n    local odd = {}\n    for i = 1, 10 do\n        table.insert(even, ((num\
    \ % i) == 0 and i or 0))\n        table.insert(odd, ((num % i) and i or 0))\n\
    \    end\n    return { even = even, odd = odd }\nend", "  if num == 0 then\n \
    \   return {0, 0}\n  else\n    local n = math.floor(math.log(math.abs(num), 2))\n\
    \    local even, odd = 0, 1\n    if n ~= 0 then\n      repeat\n        n = math.floor((n\
    \ + 1) / 2) - 1\n        local d = num / math.pow(10, n)\n        even = even\
    \ + d\n        odd = (odd - d) / 2\n      until n <= 0\n    end\n    return {even,\
    \ odd}\n  end\nend", "    if num <= 0 then\n        return {0,0}\n    end\n  \
    \  -- Count the number of even and odd digits\n    local even = math.floor(num\
    \ / 2)\n    local odd = num - even\n    if even % 2 ~= 0 then\n        return\
    \ {even, odd}\n    else\n        return {even-1, odd}\n    end\nend", "    local\
    \ num_str = tostring(num)\n    local even = 0\n    local odd = 0\n    for i=1,num_str:len()\
    \ do\n        if num_str:sub(i,i) ~= \"0\" then\n            even = even+1\n \
    \       end\n        if num_str:sub(i,i) ~= \"1\" then\n            odd = odd+1\n\
    \        end\n    end\n    \n    return { even = even, odd = odd }\nend", "  \
    \  local odd, even = 1, 0\n    for i = 1, #num, 2 do\n        if num[i] % 2 ~=\
    \ 0 then\n            even = even + 1\n        else\n            odd = odd + 1\
    \ \n        end\n    end\n    return { even, odd }\nend", "  local odd = math.floor(math.log2(num))\n\
    \  local even = num - math.pow(2, odd)\n  return { even = even, odd = odd }\n\
    end", "  local even = {}\n  local odd = {}\n  local n = 1\n  while n > 0 do\n\
    \    local digit = num % 10\n    num = num / 10\n    if digit == 0 then\n    \
    \  -- found even number\n      table.insert(even, digit)\n      n = n + 1\n  \
    \  else\n      -- found odd number\n      table.insert(odd, digit)\n      n =\
    \ n + 1\n    end\n  end\n  return table.setn(even, #even), table.setn(odd, #odd)\n\
    end", "    local even = {}\n    local odd = {}\n    while num > 0 do\n       \
    \ if num%2 == 0 then\n            table.insert(even, num)\n        else\n    \
    \        table.insert(odd, num)\n        end\n        num = math.floor(num / 2)\n\
    \    end\n    return even, odd\nend\n</cell>\n<text>\nThe last one we didn't touch\
    \ on at all and is a straightforward function to write:", "  local even = 1\n\
    \  local odd = 1\n  local tmp", "  local even_count, odd_count = 0,1\n  while\
    \ num > 0 do\n    if num mod 2 == 0 then\n      even_count = even_count+1\n  \
    \  else\n      odd_count = odd_count+1\n    end\n    num = math.floor(num/10)\n\
    \  end\n  return {even_count, odd_count}\nend", "    local odd_count = 0\n   \
    \ local even_count = 0\n    for i = 2, #num-1 do\n        if num % i ~= 0 then\n\
    \            odd_count = odd_count + 1\n        else\n            even_count =\
    \ even_count + 1\n        end\n    end\n    return odd_count, even_count\nend",
  "    local even, odd = {}, {}\n    while num ~= 0 do\n        table.insert(even,\
    \ num % 2)\n        table.insert(odd, num % 2 ~= 1)\n        num = math.floor(num\
    \ / 2)\n    end\n    return {even, odd}\nend", "  if num < 0 then\n    return\
    \ {}\n  else\n    local even, odd = 1, 1\n    for i = 1, math.floor(math.log(num))\
    \ do\n      if num >= (math.pow(10,i)) then\n        even = even * 2 + 1\n   \
    \   else\n        odd = odd * 2 + 1\n      end\n    end\n    return {even = even,\
    \ odd = odd}\n  end\nend\n</cell>\n<text>\nProblem 4\nThe Fibonacci numbers, commonly\
    \ denoted F(n) form a sequence such that every number after the first two is equal\
    \ to the sum of the two preceding ones, starting with F(1) = 1 and F(2) = 1. If\
    \ n is greater than 1, then F(n) = F(n-1) + F(n-2).\nF(10)\nF(20)\nF(30)\nF(40)\
    \ \nF(50) \nF(60) \nF(70)\nF(80)\nF(90)\nF(100) \nF(200) \nF(300)", "  -- num\
    \ has to be an int\n  local even, odd = 1, 1\n  local sign = num > 0 and 1 or\
    \ -1\n  -- if num is 0, then even_odd_count(0) returns 0\n  if num ~= 0 then\n\
    \    -- num is odd, then 1 digit is odd\n    if num % 2 == 1 then\n      odd \
    \ = odd  + 1\n    end\n    -- num is even, then 1 digit is even\n    even = even\
    \  + 1\n    -- num is odd, then 2 digits is odd\n    while num % 2 == 1 do\n \
    \     even = even  + 1\n      num = num / 2\n    end\n    -- num is even, then\
    \ 2 digits is even\n    while num % 2 == 0 do\n      odd = odd  + 1\n      num\
    \ = num / 2\n    end\n    -- if num is odd, then 1 digit is odd\n    if num %\
    \ 2 == 1 then\n      odd  = odd  + 1\n    end\n  end\n  return { even, odd }\n\
    end", "  if num < 0 then\n    error(\"negative integers aren't allowed\")\n  end\n\
    \  local result = {}\n  local num_even = 0\n  local num_odd = 0\n  repeat\n  \
    \  local num_dec = math.floor((num - 1) / 2)\n    table.insert(result, num_dec)\n\
    \    local num_even = num_even + num_dec\n    if num_dec % 2 == 0 then\n     \
    \ num_odd = num_odd + 1\n    end\n    num = num_dec\n  until num == 0 or num_odd\
    \ > num_even\n  table.insert(result, num_even)\n  table.insert(result, num_odd)\n\
    \  return result\nend", "  local even = {}\n  local odd = {}\n  local n = math.floor(math.log(math.abs(num),\
    \ 2))\n  for i = 1, n do\n    if (math.mod(num, 2)) == 0 then\n      table.insert(even,\
    \ i)\n    else\n      table.insert(odd, i)\n    end\n    num = math.floor(num\
    \ / 2)\n  end\n  return { even = even, odd = odd }\nend", "    local even = {}\n\
    \    local odd = {}\n    for i = 0, #num - 1 do\n        if num[i] == 0 then table.insert(even,\
    \ 0) end\n        if num[i] == 1 then table.insert(odd, 0) end\n    end\n    table.insert(even,\
    \ #num)\n    table.insert(odd, #num)\n    return even, odd\nend", "  local even\
    \ = 0 -- number of even digit\n  local odd = 0 -- number of odd digit\n  local\
    \ t = {}\n  while num > 0 do\n    -- get the last digit\n    local digit = num\
    \ % 10\n    -- calculate the number of even and odd digits\n    if digit == 0\
    \ then\n      even = even + 1\n    else\n      odd = odd + 1 -- add 1 to the odd\
    \ digit\n    end\n    -- remove the digit from number\n    num = num / 10\n  end\n\
    \  table.insert(t, even)\n  table.insert(t, odd)\n  return t\nend", "  if num\
    \ == 0 then\n    return {}\n  elseif num < 0 then\n    return even_odd_count(-num)\n\
    \  else\n    local digits = {}\n    local total = 0\n    local pos = 1\n    while\
    \ pos < #num and (total + num[pos] % 2 == 0) do\n      total = total + num[pos]\
    \ % 2\n      pos = pos + 1\n    end\n    if pos == #num then\n      digits[1]\
    \ = digits[2] = digits[3] = 1\n    else\n      digits[1] = total / 2\n      digits[2]\
    \ = total - digits[1] * 2\n      digits[3] = total - digits[1] * 2 - digits[2]\n\
    \    end\n    return digits\n  end\nend", "    local numstr = string.format(\"\
    %g\", num)\n    local even = {}\n    local odd = {}\n    for i = 1, #numstr, 2\
    \ do\n        local str = numstr:sub(i, i)\n        if str:sub(1, 1) == \"0\"\
    \ then\n            even[#even+1] = #even\n        else\n            odd[#odd+1]\
    \ = #odd\n        end\n    end\n    return { even = even, odd = odd }\nend", " \
    \   local even, odd = {}, {}\n    for i = 2, #num do\n        if num % i ~= 0\
    \ then\n            even[#even+1] = i\n        else\n            odd[#odd+1] =\
    \ i\n        end\n    end\n    return {even, odd}\nend", "  if num < 0 then\n\
    \    error(\"invalid argument\")\n  end\n  local even, odd = 0, 0\n  for i = 1,\
    \ math.ceil(math.log(num, 2)) do\n    if num % 2 == 0 then\n      even = even\
    \ + 1\n    else\n      odd = odd + 1  -- odd number has 1 more digit\n    end\n\
    \    num = math.floor(num / 2)\n  end\n  -- odd number has 1 more digit\n  if\
    \ odd > 0 then\n    odd = odd + 1  -- odd number has 1 more digit\n  end\n  return\
    \ even, odd\nend", "    if num then\n        local count = {}\n        for i=1,num:len()\
    \ do\n            local digit = num:sub(i,i)\n            -- If the digit is even,\
    \ add it to the odd count table\n            if digit == math.floor(digit) then\n\
    \                table.insert(count, digit)\n            end\n        end\n  \
    \      return count\n    end\n    return nil\nend", "  local even = 0\n  local\
    \ odd = 0\n  local count = 0\n  while num > 0 do\n    if num % 2 == 0 then\n \
    \     even = even + 1\n    else\n      odd = odd + 1 \n    end\n    num = num\
    \ / 2\n    count = count + 1\n  end\n  return {even, odd}\nend", "    local even\
    \ = {}\n    local odd = {}\n    local digits = math.floor(math.log(math.abs(num),\
    \ 10)) + 1\n    for i = 1, digits do\n        local div = math.modf(math.pow(10,\
    \ i) * num)[1]\n        if div == 0 then even[#even+1] = i else odd[#odd+1] =\
    \ i end\n    end\n    return { even = even, odd = odd }\nend", "    if num >=\
    \ 0 then\n        return { even_count(num), odd_count(num) }\n    end\n    return\
    \ { 0, 0 }\nend", "\tnum = tonumber(num)\n\tif not num then\n\t\treturn\n\tend",
  "    local table = {} -- A table that holds even-odd counts of num\n    if num ==\
    \ 0 then\n        table.even = 1\n        table.odd = 1\n        return\n    end\n\
    \    local num_str = tostring(num)\n    local index = 1\n    while true do\n \
    \       if num_str:sub(1, index) == \"0\" then\n            table.even = table.even\
    \ + 1\n        end\n        if num_str:sub(1, index) ~= \"0\" then\n         \
    \   table.odd = table.odd + 1\n        end\n        index = index + 1\n      \
    \  if index > num_str then break end\n    end\n    return table\nend", "  -- initialize\
    \ two counters to 0 and 1\n  local odd_cnt, even_cnt = 1, 1\n  -- loop over digits\n\
    \  for n in str:gmatch(\"(%d+)\") do\n    -- if n is odd, then add one to even_cnt\n\
    \    if tonumber(n) mod 2 ~= 0 then\n      even_cnt = even_cnt + 1\n    -- else\
    \ add one to odd_cnt\n    else\n      odd_cnt = odd_cnt + 1\n    end\n  end\n\
    \  -- return {even_cnt, odd_cnt}\n  return even_cnt, odd_cnt\nend", "    local\
    \ even = 0\n    local odd = 0\n    for i = 1, #num, 2 do\n        local digit\
    \ = tonumber(string.sub(num, i, i + 1))\n        if digit == 0 then\n        \
    \    break\n        end", "  local even, odd = 1, 0\n  for i = 1, 10 do\n    if\
    \ num % i == 0 then\n      even = even + 1\n    else\n      odd = odd + 1\n  \
    \  end\n  end\n  return even, odd\nend", "  -- Initialize table with numbers of\
    \ even and odd digits.\n  local digit = {}\n  local count = 0\n  -- Iterate through\
    \ digits.\n  for i = 1, 10 do\n    -- Check whether the number is even or odd.\n\
    \    if math.mod(num, i) == 0 then\n      -- If the number is even, increment\
    \ the count by 1.\n      if digit[i - 1] == nil then\n        digit[i - 1] = 1\n\
    \      else\n        digit[i - 1] = 1\n      end\n    else\n      -- If the number\
    \ is odd, increment the count by 1.\n      if digit[i - 1] == nil then\n     \
    \   digit[i - 1] = count + 1\n      else\n        digit[i - 1] = count + 1\n \
    \     end\n    end\n    -- Increment the number.\n    count = count + 1\n  end\n\
    \  return digit\nend", "  local oddCount = 0\n  local evenCount = 0\n  for i =\
    \ 1, num do\n    if num % 2 == 1 then\n      evenCount = evenCount + 1\n    elseif\
    \ num % 2 == 0 then\n      oddCount = oddCount + 1\n    end\n  end\n  return {oddCount,\
    \ evenCount}\nend", "  if num < 0 then return nil end\n  local num_str   = tostring(num)\n\
    \  local num_length = len(num_str)\n  local even  = 0\n  local odd   = 0", " \
    \   if num == 0 then\n        return {0, 0}\n    end\n    local even_count = 0\n\
    \    local odd_count = 0\n    local i = 1\n    while i <= math.floor(math.log(num)\
    \ / math.log(2)) do\n        if ((math.pow(2,i) % num) == 0) then\n          \
    \  even_count = even_count + 1\n        else\n            odd_count = odd_count\
    \ + 1\n        end\n        i = i + 1\n    end\n    return even_count, odd_count\n\
    end", "  local nums = {}\n  local count = num / 2\n  while not (num mod 2) do\n\
    \    count = count + 1\n    num = num / 2\n  end\n  nums[1] = count\n  count =\
    \ num / 2\n  while not (num mod 2) do\n    count = count + 1\n    num = num /\
    \ 2\n  end\n  nums[2] = count\n  return table.concat(nums, \":\")\nend", "  if\
    \ num < 0 then\n    return nil\n  end\n  local result = {}\n  local i = 2\n  while\
    \ i <= math.floor(math.log(num, 2)) do\n    if num % i == 0 then\n      if i %\
    \ 2 == 0 then\n        result[#result + 1] = 2\n      else\n        result[#result\
    \ + 1] = 1\n      end\n    end\n    i = i + 1\n  end\n  return result\nend", " \
    \   local odd_count = 0\n    local even_count = 0\n    for i = 1, num do\n   \
    \     if num % i == 0 then\n            even_count = even_count + 1\n        else\n\
    \            odd_count = odd_count + 1\n        end\n    end", "  -- Initialize\
    \ variables\n  local even = { }\n  local odd = { }\n  -- Iterate over the num\n\
    \  while num > 0 do\n    local i = 1\n    -- If the current digit is even, increment\
    \ the count\n    while num % 2 == 0 do\n      num = num / 2\n      i = i + 1\n\
    \    end\n    -- If the current digit is odd, decrement the count\n    while num\
    \ % 2 == 1 do\n      num = num / 2\n      i = i + 1\n    end\n    even[i] = even[i]\
    \ + 1 -- Increment the count\n    odd[i] = odd[i] - 1 -- Decrement the count\n\
    \    -- If the number is now empty, break the loop\n    if num == 0 then\n   \
    \   break\n    end\n  end\n  return { even, odd }\nend", "  if num < 0 then\n\
    \    return nil\n  else\n    local odd, even, count = 0, 2, 1\n    while true\
    \ do\n      local t = math.floor(math.abs(num) / 2)\n      odd = odd + (t % 2\
    \ == 0)\n      even = even + (t % 2 == 1)\n      if num > 0 then\n        count\
    \ = count + 2\n      else\n        count = count + 1\n        break\n      end\n\
    \      num = num - t\n    end\n    return odd, even, count\n  end\nend", "  local\
    \ even = {}\n  local odd = {}", "  if num == 0 then\n    return {}\n  end\n  local\
    \ even = even_odd_count(num/10)\n  local odd = even_odd_count(num - (even[1]*10))\n\
    \  return {even[1], odd[1]}\nend", "\tlocal count = {0,0}\n\tlocal r = math.floor(math.log10(num))\
    \ + 1\n\t\n\twhile r > 0 do\n\t\tif num % 10 == 0 then\n\t\t\tcount[1] = count[1]\
    \ + 1\n\t\telseif num % 10 == 1 then\n\t\t\tcount[2] = count[2] + 1\n\t\telse\n\
    \t\t\tbreak\n\t\tend\n\t\t\n\t\tnum = num / 10\n\t\tr = r - 1\n\tend\n\t\n\treturn\
    \ count\nend\n</cell>\n<code language=xeus-cling-cpp14>", "  if num < 0 then\n\
    \    return nil\n  elseif num == 0 then\n    return {{1, 1}, {1, 1}}\n  end",
  "  if num == 0 then return {0,0} end\n  local count1 = math.floor(math.log10(num))\n\
    \  local count2 = math.floor(num / 10)\n  local odd = count2 - 1\n  return {{\n\
    \    even = count1 - 1,\n    odd = odd\n  }}\nend", "  local even, odd = 0, 1\n\
    \  if num == 0 then\n    return {even, odd}\n  end\n  while num >= 1 do\n    even\
    \ = even * 10 + num % 10\n    odd = odd * 10 + num / 10 % 10\n    num = num /\
    \ 10\n  end\n  return {even, odd}\nend", "  if num == 0 then return {} end\n \
    \ local ret = {}\n  local n = num\n  while n > 0 do\n    local digit = n % 10\n\
    \    if digit % 2 == 0 then\n      table.insert(ret, digit)\n    end\n    n =\
    \ math.floor(n/10)\n  end\n  return ret\nend", "  local even, odd = {}, {}\n \
    \ for i=1,math.floor(math.log(abs(num),10)+1) do\n    -- Even digits\n    if num\
    \ >= 0 and num % 2 == 0 then\n      table.insert(even, i)\n    end\n    -- Odd\
    \ digits\n    if num >= 0 and num % 2 ~= 0 then\n      table.insert(odd, i)\n\
    \    end\n  end\n  return even, odd\nend", "   local even = 0 \n   local odd =\
    \ 0 \n   local n1 = math.floor(num / 10^1) \n   num = num - (10^n1) * 10^(n1 +\
    \ 1) \n   if num > 0 then \n      even = even+1 \n   end\n   if num < 0 then\n\
    \      odd = odd+1\n   end\n   return \nend", "    local even = {}\n    local\
    \ odd = {}\n    for i = 1, 10 do\n        if math.mod(num, i) == 0 then\n    \
    \        table.insert(even, i)\n        else\n            table.insert(odd, i)\n\
    \        end\n    end\n    return {even, odd}\nend", "    local odd = 1\n    local\
    \ even = 0\n    while num > 0 do\n        odd = odd + math.floor((num % 10)/2)\n\
    \        even = even + math.floor((num % 10)%2)\n        num = math.floor((num\
    \ / 10))\n    end\n    return {odd, even}\nend", "    local num_string = (string.format(\"\
    %g\"):format(num))\n    local even_string, odd_string = \"{}\", \"{}\"\n    local\
    \ i\n    for i = 1, #num_string do\n        if num_string:sub(i,i) == \".\" then\n\
    \            if num_string:sub(i,i) == \".\" then\n                even_string\
    \ = even_string..\"1\"\n            elseif num_string:sub(i,i) == \"-\" then\n\
    \                even_string = even_string..\"0\"\n            else\n        \
    \        even_string = even_string..\"0\"\n                odd_string = odd_string..\"\
    1\"\n            end\n        elseif num_string:sub(i,i) == \"-\" then\n     \
    \       odd_string = odd_string..\"0\"\n        else\n            even_string\
    \ = even_string..\"0\"\n            odd_string = odd_string..\"0\"\n        end\n\
    \    end\n    return even_string, odd_string\nend", "  local even, odd = 0, 0\n\
    \  while true do\n    even = even + num % 2\n    odd = 1 + odd\n    num = math.floor(num\
    \ / 2)\n    if even == 0 and odd ~= 0 then\n      break\n    end\n  end\n  --\
    \ We need the last element in the table since the last iteration will leave the\
    \ value in even.\n  return {even, odd}\nend", "  local count = {0, 0}\n  while\
    \ num ~= 0 do\n    local last_digit = num % 10\n    num = math.floor(num / 10)\n\
    \    if last_digit % 2 == 0 then\n      count[1] = count[1] + 1 -- +1 because\
    \ we count even digits\n    else\n      count[2] = count[2] + 1\n    end\n  end\n\
    \  return count\nend", "  local even = {}\n  local odd = {}\n  local count = {}",
  "  local result = {}\n  for i = 1, math.floor(math.log10(num)) do\n    if math.mod(num,\
    \ 2^i) == 0 then\n      table.insert(result, 1)\n    else\n      table.insert(result,\
    \ 2)\n    end\n  end\n  return result\nend", "    local table = {}\n    local\
    \ digit_sum = 0\n    while num ~= 0 do\n        digit_sum = digit_sum + math.floor(math.log(abs(num),\
    \ 2))\n        table.insert(table, digit_sum)\n        num = math.floor(num /\
    \ 10)\n    end\n    return table\nend", "\tlocal even_odd = 0\n\twhile num > 0\
    \ do\n\t\tlocal remainder = math.floor(num / 10)\n\t\teven_odd = even_odd + math.abs(remainder\
    \ - remainder % 2)\n\t\tnum = num - remainder * 10\n\tend\n\treturn even_odd\n\
    end", "    if num <= 0 then\n        return { 0, 0 }\n    end\n    local counts\
    \ = {0, 0}\n    while num > 0 do\n        if num % 2 ~= 0 then\n            counts[1]\
    \ = counts[1] + 1\n        end\n        if num % 2 ~= 1 then\n            counts[2]\
    \ = counts[2] + 1\n        end\n        num = math.floor(num / 2)\n    end\n \
    \   return counts\nend", "  local count = 0\n  while num > 0 do\n    count = count\
    \ + math.abs(math.floor((num % 10)))\n    num = math.floor(num / 10)\n  end\n\
    \  return count\nend", "  if num < 0 then\n    return {0, 0}\n  end\n  local even\
    \ = math.floor(math.log(num) / math.log(2))\n  local odd = math.ceil(math.log(num)\
    \ / math.log(2))\n  if even > odd then\n    even = even\n  else\n    odd = odd\n\
    \  end\n  return {even, odd}\nend", "    local table = {}\n    local i = 2\n \
    \   while i <= num do\n        table[i] = (i & 1)\n        i = i >> 1\n    end\n\
    \    return table\nend", "    local counts = setmetatable({}, {__mode=\"k\"});\n\
    \    for i=1, 10 do\n        if num % i == 0 then\n            table.insert(counts,\
    \ i);\n        end;\n    end\n    return counts;\nend", "  local even = 1, odd\
    \ = 0\n  while num > 0 do\n    even = even + num %  2\n    odd = odd + num / 2\n\
    \    num = math.floor(num / 10)\n  end\n  return {even, odd}\nend", "    local\
    \ even = 0\n    local odd = 0", "    local odd_count = 0\n    local even_count\
    \ = 0\n    while num ~= 0 do\n        if num % 2 == 0 then\n            even_count\
    \ = even_count + 1\n        else\n            odd_count = odd_count + 1\n    \
    \    end\n        num = math.floor(num / 10)\n    end\n    return even_count,\
    \ odd_count\nend", "  if num < 0 then\n    return nil, nil\n  end", "  local even,\
    \ odd = {}, {}\n  -- First we count the number of digits\n  local count = 0\n\
    \  while num > 0 do\n    num = math.floor(num / 10)\n    count = count + 1\n \
    \ end\n  -- Now we create an array with only the number of digits. If the number\
    \ is negative, we'll have to flip all the digits\n  if num < 0 then\n    count\
    \ = -count\n  end\n  for i=1,count do\n    table.insert(even, i)\n  end\n  for\
    \ i=count,-1,-1 do\n    table.insert(odd, i)\n  end\n  return even, odd\nend",
  "    local even = 0,\n    local odd = 0\n    for i = 1, num:len() do\n        if\
    \ num:sub(i, i) ~= '0' then return { even, odd }\n        even = even + 1\n  \
    \  end\n    return { even, odd }\nend", "    local even, odd\n    if num <= 0\
    \ then\n        return {}, {}\n    end\n    even = math.floor((num / 2) * 2) -\
    \ 1\n    odd = math.ceil((num / 2) * 2) - 1\n    return {even, odd}\nend", " \
    \   local even = 0, odd = 0\n    for i = 1, (num / 10) do\n        local digit\
    \ = num % 10\n        if digit == 0 then\n            even = even + 1\n      \
    \  else\n            odd = odd + 1 -- Odd numbers don't have a zero\n        end\n\
    \        num = num / 10\n    end\n    return even, odd\nend", "  if num < 0 then\
    \ return end\n  local even = math.floor((num - num % 2) / 2)\n  if even > 0 then\n\
    \    return {even, even + 1}\n  else\n    return {math.ceil(num / 2), 0}\n  end\n\
    end", "  local even = {}\n  local odd = {}\n  local x = 1\n  local total = 0\n\
    \  while x > 0 do\n    if num % x == 0 then\n      if even[x] == nil then\n  \
    \      even[x] = 1\n      else\n        even[x] = even[x] + 1\n      end\n   \
    \   total = total + 1\n    end\n    if x % 2 ~= 0 then\n      if odd[x] == nil\
    \ then\n        odd[x] = 1\n      else\n        odd[x] = odd[x] + 1\n      end\n\
    \    end\n    x = x + 1\n  end\n  return { even = even, odd = odd }\nend", " \
    \ if num == 0 then\n    return {}\n  elseif num >= 0 then\n    local odd = 1\n\
    \    local even = 1\n    for i = 1, floor(log10(num)) + 1 do\n      if num / 10^(i)\
    \ > 0 then\n        even = even + 1\n      else\n        odd = odd + 1 \n    \
    \  end\n    end\n    return { odd = odd, even = even }\n  else\n    error(\"input\
    \ should be positive\")\n  end\nend", "\t-- Initialize a table to hold results.\n\
    \t-- The first field holds the number of even digits, the second odd digits\n\t\
    local even_count_table = {}\n\t-- For every integer from 0 to the number passed\
    \ to the function.\n\tfor i = 1, num do\n\t\t-- Divide the number by 10 until\
    \ there are no digits left.\n\t\tlocal remainder = num % 10\n\t\tnum = num / 10\n\
    \t\t-- If the remainder of the division is 0, add 1 to the even count table.\n\
    \t\tif remainder == 0 then\n\t\t\ttable.insert(even_count_table, 1)\n\t\t-- Otherwise,\
    \ the remainder is a 1 so add 2 to the odd count table.\n\t\telse\n\t\t\ttable.insert(even_count_table,\
    \ 2)\n\t\tend\n\tend\n\t-- Return the count table.\n\treturn even_count_table\n\
    end", "  if num == 0 then\n    return { 1, 1 }\n  else\n    local evens, odds\
    \ = 1, 1\n    while num > 0 do\n      local quotient = num / 2\n      evens, odds\
    \ = evens + quotient * 2, odds + quotient * 2\n      num = num % 2\n    end\n\
    \    return { evens, odds }\n  end\nend", "  if num == 0 then\n    return {0,\
    \ 1}\n  elseif num < 0 then\n    error(\"invalid argument: \" .. num)\n  end",
  "\tlocal even, odd = {}, {}\n\tlocal n = 0\n\t\n\t-- For odd numbers, start from\
    \ 1 since we only have odd numbers in our table\n\tfor i = 1, num do\n\t\tif num\
    \ % 2 == 0 then\n\t\t\tn = n + 1\n\t\t\teven[n - 1] = i\n\t\telse\n\t\t\tn = n\
    \ + 1\n\t\t\todd[n - 1] = i\n\t\tend\n\tend", "  local odd = {}\n  local even\
    \ = {}\n  for x = 1, math.floor(math.log(num, 2)) do\n    if num % x == 0 then\n\
    \      odd[x] = odd[x] or 1\n    else\n      even[x] = even[x] or 1\n    end\n\
    \  end\n  return { even = even, odd = odd }\nend", "  local even = {}\n  local\
    \ odd = {}\n  local t = 1\n  while t <= num do\n    if (t % 2) == 0 then\n   \
    \   table.insert(even, t)\n    else\n      table.insert(odd, t)\n    end\n   \
    \ table.insert(odd, t ^ 1)\n    t = t + 1\n  end\n  return { even = even, odd\
    \ = odd }\nend", "\tlocal even = 0, odd = 0\n\t-- We want to make sure we start\
    \ at one, and not zero, to account for the possibility of negative numbers\n\t\
    -- Also we only want to count a number once (unless it is a repeating pattern)\n\
    \t-- A possible pattern would be 12321, but we won't worry about that here\n\t\
    local repeating = 1\n\tfor i = 1, math.floor(math.log(num) / math.log(2)) do\n\
    \t\t-- If the number we are checking is even or odd and it has a repeating pattern\
    \ then\n\t\t-- we won't count that number again\n\t\t-- 12321 is a good example\n\
    \t\tif ((num % (math.pow(2, i) - 1)) == 0 and repeating) or (num % (math.pow(2,\
    \ i)))  == 0 then\n\t\t\tif num % math.pow(2, i) == 0 then\n\t\t\t\teven = even\
    \ + 1\n\t\t\telse\n\t\t\t\todd = odd + 1\t\n\t\t\tend\n\t\tend\n\t\t-- If the\
    \ number we are checking is odd and it doesn't have a repeating pattern,\n\t\t\
    -- then we count it as an even number\n\t\tif num % math.pow(2, i) == 1 then\n\
    \t\t\teven = even + 1\n\t\tend\n\t\t-- If the number we are checking is even and\
    \ it doesn't have a repeating pattern,\n\t\t-- then we count it as an odd number\n\
    \t\tif num % math.pow(2, i) == 0 then\n\t\t\todd = odd + 1\t\n\t\tend\n\t\t--\
    \ We know that the number we checked is a repeating number, but we want to double\
    \ check\n\t\t-- so that we don't count it again\n\t\trepeating = repeating * 2\n\
    \tend", "    local even_count = even_count(num)\n    local odd_count = odd_count(num)\n\
    \    local table = {}\n    table.insert(table, {even_count, odd_count})\n    return\
    \ table\nend", "  if num < 0 then\n    return nil\n  end\n  local even, odd =\
    \ 0, 1\n  while num > 0 do\n    num = math.floor(num / 10)\n    even = even +\
    \ 1\n    if num % 2 == 1 then\n      odd = odd + 1\n    end\n  end\n  local pairs\
    \ = {}\n  pairs[even] = odd and pairs[even] + 1 or 1\n  return pairs\nend", " \
    \ if num < 0 then\n    return {0, 0}\n  end\n  local result = {}\n  local remainder\
    \ = math.floor((num / 2) % 2)\n  if remainder == 0 then\n    result[1] = num %\
    \ 2\n  else\n    result[1] = remainder\n  end\n  num = num - (result[1] * 2)\n\
    \  repeat\n    remainder = math.floor((num / 2) % 2)\n    if remainder == 0 then\n\
    \      result[2] = num % 2\n    else\n      result[2] = remainder\n    end\n \
    \   num = num - (result[2] * 2)\n  until num == 0\n  return result\nend", "  \
    \  local table = {}\n    local num1 = math.abs(num)\n    local i = 0\n    while\
    \ num1 ~= 0 do\n        local num2 = math.floor(num1 / 10)\n        table.insert(table,\
    \ num2)\n        num = num % 10\n        i = i + 1\n    end\n    return table\n\
    end", "    local even = {}\n    local odd = {}\n    for i = 1, num do\n      \
    \  if math.floor(num / pow(2, i)) == 0 then\n            table.insert(even, i)\n\
    \        else\n            table.insert(odd, i)\n        end\n    end\n    return\
    \ table.concat(even, \"-\"), table.concat(odd, \"-\")\nend", "  local result =\
    \ {}\n  for i = 1, 10 do\n    local odd = (num % i) % 2\n    local even = ((num\
    \ - odd) * (num - odd)) % 2\n    result[i] = {even, odd}\n  end\n  return result\n\
    end", "    if num == 0 then\n        return {0, 1}\n    end\n    -- Use an auxiliary\
    \ table to store counts\n    local odd_even = {}\n    for i = 2, #num + 1, 2 do\n\
    \        if num % i == 0 then\n            if odd_even[i] ~= nil then\n      \
    \          odd_even[i] = odd_even[i] + 1\n            else\n                odd_even[i]\
    \ = 1\n            end\n        else\n            if odd_even[i] ~= nil then\n\
    \                odd_even[i] = odd_even[i] - 1\n            else\n           \
    \     odd_even[i] = -1\n            end\n        end\n    end\n    -- Construct\
    \ return table\n    local table = {}\n    for i = 1, #odd_even, 2 do\n       \
    \ table.insert(table, odd_even[i])\n    end\n    return table\nend", "  local\
    \ table = {}\n  if num == 0 then\n    return table\n  elseif num < 0 then\n  \
    \  table.even, table.odd = 1, 2\n    return table\n  end", "   local even = {0}\n\
    \   local odd = {1}\n   if num < 0 then\n      table.insert(even, num % 2)\n \
    \     table.insert(odd, num - num % 2)\n   else\n      local n = math.floor(num\
    \ / 2)\n      while n >= 1 do\n         table.insert(even, n % 2)\n         n\
    \ = n - n % 2\n         table.insert(odd, n / 2)\n      end\n      table.insert(odd,\
    \ num - math.floor(n))\n   end\n   return table.concat(even, \"|\") + table.concat(odd,\
    \ '|')\nend", "  local even = {}\n  local odd = {}", "  local even = 0\n  local\
    \ odd = 0\n  while true do\n    local remainder = math.mod(num, 2)\n    if remainder\
    \ == 0 then\n      even = even + 1\n    else\n      odd = odd + 1 -- The key is\
    \ the odd number or the number divided by 2.\n      num = remainder\n    end\n\
    \    if num == 0 then\n      break\n    end\n  end\n  return { even, odd }\nend",
  "  local count_even = {}\n  count_even[1] = 1\n  count_even[2] = 2\n  count_even[3]\
    \ = 2\n  count_even[4] = 1", "  num = num or 0\n  local evens, odds = {}, {}\n\
    \  local count = math.ceil(math.sqrt(num))\n  for i = 1, count do\n    local mod\
    \ = math.fmod(num, 2)\n    evens[#evens + 1] = i if mod == 0 then\n  end\n  for\
    \ i = 1, count do\n    local mod = math.fmod(num, 2)\n    odds[#odds + 1] = i\
    \ if mod == 1 then\n  end\n  return {evens, odds}\nend", "   if num < 0 then\n\
    \      return nil, \"Must be a positive integer\"\n   end\n   local t = {{}, {}}\n\
    \   local carry = false\n   for i=1, num do\n      local digit = math.floor((num\
    \ - i) / 2)\n      if digit > 0 then\n         table.insert(t, digit)\n      else\n\
    \         carry = true\n         table.insert(t, 0)\n      end\n   end\n   if\
    \ carry then\n      table.insert(t, 1)\n   end\n   return t\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
