name: HumanEval_93_encode
language: lua
prompt: "-- Write a function that takes a message, and encodes in such a \n-- way\
  \ that it swaps case of all letters, replaces all vowels in \n-- the message with\
  \ the letter that appears 2 places ahead of that \n-- vowel in the english alphabet.\
  \ \n-- Assume only letters. \n-- Examples:\n-- >>> encode('test')\n-- 'TGST'\n--\
  \ >>> encode('This is a message')\n-- 'tHKS KS C MGSSCGG'\nlocal function encode(message)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = encode\n\
  \    lu.assertEquals(candidate('TEST'), 'tgst')\n    lu.assertEquals(candidate('Mudasir'),\
  \ 'mWDCSKR')\n    lu.assertEquals(candidate('YES'), 'ygs')\n    lu.assertEquals(candidate('This\
  \ is a message'), 'tHKS KS C MGSSCGG')\n    lu.assertEquals(candidate('I DoNt KnOw\
  \ WhAt tO WrItE'), 'k dQnT kNqW wHcT Tq wRkTg')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local words = {}\n    local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    for index, letter in string.gmatch(message, \"%[A-z]\") do\n        -- if\
    \ letter == 'i' or letter == 'o' or letter == 'u' then\n        --     table.insert(words,\
    \ letter)\n        -- else\n        -- table.insert(words, letter)\n        --\
    \ end\n        table.insert(words, alphabet[alphabet.find(letter) + 1])\n    \
    \    -- table.insert(words, alphabet[alphabet.find(letter) + 2])\n        -- table.insert(words,\
    \ alphabet[alphabet.find(letter) + 3])\n        -- table.insert(words, alphabet[alphabet.find(letter)\
    \ + 4])\n        -- table.insert(words, alphabet[alphabet.find(letter) + 5])\n\
    \        -- table.insert(words, alphabet[alphabet.find(letter) + 6])\n       \
    \ -- table.insert(words, alphabet[alphabet.find(letter) + 7])\n        -- table.insert(words,\
    \ alphabet[alphabet.find(letter) + 8])\n        -- table.insert(words, alphabet[alphabet.find(letter)\
    \ + 9])\n        -- table.insert(words, alphabet[alphabet.find(letter) + 10])\n\
    \        -- table.insert(words, alphabet[alphabet.find(letter) + 11])\n      \
    \  -- table.insert(words, alphabet[alphabet.find(letter) + 12])\n        -- table.insert(words,\
    \ alphabet[alphabet.find(letter) + 13])\n        -- table.insert(words, alphabet[alphabet.find(letter)\
    \ + 14])\n        -- table.insert(words, alphabet[alphabet.find(letter) + 15])\n\
    \        -- table.insert(words, alphabet[alphabet.find(letter) + 16])\n      \
    \  -- table.insert(words, alphabet[alphabet.find(letter) + 17])\n        -- table.insert(words,\
    \ alphabet[alphabet.find(letter) + 18])\n        -- table.insert(words, alphabet[alphabet.find(letter)\
    \ + 19])\n        -- table.insert(words, alphabet[alphabet.find(letter) + 20])\n\
    \        -- table.insert(words, alphabet[alphabet.find(letter) + 21])\n      \
    \  -- table.insert(words, alphabet[alphabet.find(letter) + 22])\n        -- table.insert(words,\
    \ alphabet[alphabet.find(letter) + 23])\n        -- table.insert(words, alphabet[alphabet.find(letter)\
    \ + 24])\n        -- table.insert(words, alphabet[alphabet.find(letter) + 25])\n\
    \        -- table.insert(words, alphabet[alphabet.find(letter) + 26])\n      \
    \  -- table.insert(words, alphabet[alphabet.find(letter) + 27])\n        -- table.insert(words,\
    \ alphabet[alphabet.find(letter) + 28])\n        -- table.insert(words, alphabet[alphabet.find(letter)\
    \ + 29])\n        -- table.insert(words, alphabet", "    local alphabet =  {a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}\n\
    \    local function swapcase(x)\n        return x:gsub(a..b,\n            function(x)\n\
    \                return alphabet[x:byte(1, true)]\n            end)\n    end\n\
    \    return message:gsub(a..b,\n        function(x)\n            local letter\
    \ = alphabet[x:byte(1, true)]\n            return letter:gsub(v,\n           \
    \     function(x)\n                    return alphabet[alphabet:byte(2, true)\
    \ + x]\n                end)\n        end):gsub(vowels,\n            function(x)\n\
    \                local letter = alphabet[x:byte(1, true)]\n                local\
    \ index = alphabet:byte(2, true)\n                return letter:gsub(v,\n    \
    \                function(x)\n                        return alphabet[index +\
    \ x]\n                    end)\n            end)\nend", "\tlocal alphabet = string.gsub(message,\
    \ \"[^A-Za-z]\", \"\")\n\treturn alphabet\nend", "    local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    local vowels = \"aeiou\"", "    local alphabet = {}\n    for i = 1,26 do\n\
    \        alphabet[i] = string.char(i + 65)\n    end\n    local vowels = {'a','e','i','o','u'}\n\
    \    local vowelCounts = {\n        ['a'] = 1, ['e'] = 1, ['i'] = 1, ['o'] = 1,\
    \ ['u'] = 1\n    }", "  -- write your code\nend", "  local vowels = { 'a', 'e',\
    \ 'i', 'o', 'u', 'y' } -- Set of all vowels\n  local replacements = { 'b', 'c',\
    \ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w',\
    \ 'x', 'y', 'z' }\n  local message_copy = message\n  local vowel_count = 0 --\
    \ Keep track of how many vowels are in the message", "  message = string.lower(message)\n\
    \  local vowels = string.chars(string.sub('aeiou', 'a', 'i'))\n  local res = {}\n\
    \  for i = 1, string.len(message) do\n    local char = string.sub(message, i,\
    \ i)\n    local index = string.find(vowels, char)\n    if ~index then\n      table.insert(res,\
    \ char)\n    else\n      table.insert(res, string.sub(char, 1, index + 1))\n \
    \     table.insert(res, string.sub(char, index + 1, index + 2))\n    end\n  end\n\
    \  return table.concat(res, '') \nend", "    message = message:gsub(\"[aA]\",\
    \ \"[%1]\")\n    message = message:gsub(\"[bB]\", \"[%1]\")\n    message = message:gsub(\"\
    [cC]\", \"[%1]\")\n    message = message:gsub(\"[dD]\", \"[%1]\")\n    message\
    \ = message:gsub(\"[eE]\", \"[%1]\")\n    message = message:gsub(\"[fF]\", \"\
    [%1]\")\n    message = message:gsub(\"[gG]\", \"[%1]\")\n    message = message:gsub(\"\
    [hH]\", \"[%1]\")\n    message = message:gsub(\"[iI]\", \"[%1]\")\n    message\
    \ = message:gsub(\"[jJ]\", \"[%1]\")\n    message = message:gsub(\"[kK]\", \"\
    [%1]\")\n    message = message:gsub(\"[lL]\", \"[%1]\")\n    message = message:gsub(\"\
    [mM]\", \"[%1]\")\n    message = message:gsub(\"[nN]\", \"[%1]\")\n    message\
    \ = message:gsub(\"[oO]\", \"[%1]\")\n    message = message:gsub(\"[pP]\", \"\
    [%1]\")\n    message = message:gsub(\"[qQ]\", \"[%1]\")\n    message = message:gsub(\"\
    [rR]\", \"[%1]\")\n    message = message:gsub(\"[sS]\", \"[%1]\")\n    message\
    \ = message:gsub(\"[tT]\", \"[%1]\")\n    message = message:gsub(\"[uU]\", \"\
    [%1]\")\n    message = message:gsub(\"[vV]\", \"[%1]\")\n    message = message:gsub(\"\
    [wW]\", \"[%1]\")\n    message = message:gsub(\"[xX]\", \"[%1]\")\n    message\
    \ = message:gsub(\"[yY]\", \"[%1]\")\n    message = message:gsub(\"[zZ]\", \"\
    [%1]\")\n    message = message:gsub(\"[Aa]\", \"[%1]\")\n    message = message:gsub(\"\
    [Bb]\", \"[%1]\")\n    message = message:gsub(\"[Cc]\", \"[%1]\")\n    message\
    \ = message:gsub(\"[Dd]\", \"[%1]\")\n    message = message:gsub(\"[Ee]\", \"\
    [%1]\")\n    message = message:gsub(\"[Ff]\", \"[%1]\")\n    message = message:gsub(\"\
    [Gg]\", \"[%1]\")\n    message = message:gsub(\"", "  -- Your code here\nend",
  "  if #message < 2 then\n    return message\n  elseif message[1] ~= ' ' then\n \
    \   message = message:sub(1, 1) .. ' ' .. message:sub(2)\n  else\n    message\
    \ = message:sub(1, 1)\n  end", "    local result = \"\";\n    local vowels = \"\
    aeiou\";\n    for i = 1, #message, 1 do\n        local char = message[i];\n  \
    \      if #vowels == 0 then\n            result = \"tH\"..result;\n        else\n\
    \            local idx2 = vowels:lower():find(char:lower())+1;\n            if\
    \ idx2 == #vowels then\n                result = \"tH\"..result;\n           \
    \ else\n                local idx1 = vowels:lower():find(char:lower())-1;\n  \
    \              result = \"tH\"..result\n                    .. string.sub(vowels:lower(),idx1,idx2)\n\
    \                    .. string.sub(vowels:lower(),idx2+1,#vowels)\n          \
    \      end;\n            end;\n        end;\n    end;\n    return result;\nend;",
  "\tlocal function rewrite()\n\t\tlocal function next(i)\n\t\t\tlocal letter = string.sub(message,\
    \ i, i)\n\t\t\tif letter == \" \" then\n\t\t\t\treturn i\n\t\t\telse\n\t\t\t\t\
    local vowels = string.gsub(letter, \"[aeiou]\", \"@\")\n\t\t\t\treturn string.gsub(vowels,\
    \ \"@\", \"[%1s%2]\", 2)\n\t\t\tend\n\t\tend\n\t\treturn function(i)\n\t\t\treturn\
    \ next(i) + rewrite()\n\t\tend\n\tend\n\treturn message\nend", "    local alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    local vowels = \"AEIOU\"\n    local s\
    \ = \"\"\n    for i = 1, #message do\n        local letter = message:sub(i, i)\n\
    \        if string.sub(alphabet, letter:lower()) = letter:lower() then\n     \
    \       -- letter occurs once, swap case\n            letter = string.sub(alphabet,\
    \ letter:lower() + 1, letter:lower() + 2)\n        end\n        if string.sub(vowels,\
    \ letter:lower()) = letter:lower() then\n            -- letter occurs in vowel\
    \ sequence two positions ahead, swap letters\n            letter = string.sub(alphabet,\
    \ letter:lower() + 2, letter:lower() + 3)\n        end\n        s = s .. letter\n\
    \    end\n    return s\nend", "  local alphabet = {'a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', \n    'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', \n    'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7',\
    \ '8', '9'}\n  -- encode a message by swapping each letter and then finding its\
    \ 2\n  -- place vowel \n  local result = {}\n  for i = 1, #message do \n    local\
    \ letter = alphabet[message[i]]\n    table.insert(result, letter)\n    table.insert(result,\
    \ alphabet[alphabet[letter] + 1])\n  end\n  \n  return table.concat(result, \"\
    \")\nend", "    local result = \"\"\n    for _, char in ipairs(message) do\n \
    \       if char == \"a\" or char == \"e\" or char == \"i\" then\n            char\
    \ = string.upper(string.sub(char, 2)) \n        elseif char == \"o\" or char ==\
    \ \"u\" or char == \"y\" then\n            char = string.upper(string.sub(char,\
    \ 2))\n        elseif char == \"A\" or char == \"E\" or char == \"I\" then\n \
    \           char = string.upper(string.sub(char, 2))\n        elseif char == \"\
    O\" or char == \"U\" or char == \"Y\" then\n            char = string.upper(string.sub(char,\
    \ 2))\n        end\n        result = result .. char\n    end\n    return result\n\
    end", "  local alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \  local vowels = 'aouiuy'\n  local mapping = {}\n  \n  -- Build a dictionary\
    \ with key value pairs\n  for i, letter in ipairs(alphabet) do\n    mapping[letter]\
    \ = {}\n    for j = 1, #vowels do\n      mapping[letter][vowels[j - 1]] = alphabet\
    \ .. i\n    end\n  end\n  \n  -- Iterate over each letter in the message\n  for\
    \ i, letter in ipairs(message) do\n    -- Iterate over each vowel in the letter\n\
    \    for j, vowel in ipairs(vowels) do\n      -- If the letter and vowel are the\
    \ same at the current index, \n      -- then update the letter with the value\
    \ from the dictionary\n      if letter == vowel then\n        message[i] = mapping[letter][vowel]\n\
    \      end\n    end\n  end\n  \n  return message\nend", "\t-- Write your solution\
    \ here\nend", "  if #message < 1 then return '' end", "    return string.gsub(message,\
    \ \"[A-Za-z]\", function(letter)\n        -- First find the vowel position. \n\
    \        local vowel, position = string.find(letter, \"AEIOUaeiou\")\n       \
    \ -- Then swap the case of all letters \n        return string.upper(letter)..string.lower(letter)\n\
    \        -- Replace vowels with letters two places ahead. \n        -- Note the\
    \ use of string.sub to limit the string to the first vowel position. \n      \
    \  -- If you use string.substring it would include the vowel and a space character.\
    \ \n        ..string.sub(letter, position+1, position+2)\n    end) \nend\n</cell>\n\
    <cell>", "    local vowels = {'a','e','i','o','u','y'}\n    return message:gsub('.',\
    \ function(letter)\n        if vowels[letter] then\n            local a = letter:lower():sub(1,\
    \ 1)\n            local b = letter:lower():sub(2, 2)\n            return b:sub(1,\
    \ 1)..a:upper()\n        else\n            return letter\n        end\n    end)\n\
    end", "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    local vowels = 'aeiouAEIOU'\n\
    \    local output = ''\n    for i = 1, #message do\n        local letter = string.sub(message,\
    \ i, i)\n        if letter == ' ' then\n            letter = '#'\n        end\n\
    \        -- TODO: Handle non-letters more gracefully\n        local outputLetter\
    \ = ''\n        local vowelPosition = nil\n        for letterIndex = 1, #alphabet\
    \ do\n            if string.find(alphabet, letter, letterIndex, 1, true) then\n\
    \                if vowelPosition ~= nil then\n                    outputLetter\
    \ = outputLetter .. vowels[vowelPosition]\n                end\n             \
    \   outputLetter = outputLetter .. alphabet[letterIndex]\n                vowelPosition\
    \ = letterIndex + 1\n            end\n        end\n        output = output ..\
    \ letter .. outputLetter\n    end\n    return output\nend", "    local alphabet\
    \ = {\n        -- Alphabet of the english language. \n        -- http://www.asciitable.com/\n\
    \        ['a'] = 65,\n        ['b'] = 66,\n        ['c'] = 67,\n        ['d']\
    \ = 68,\n        ['e'] = 69,\n        ['f'] = 70,\n        ['g'] = 71,\n     \
    \   ['h'] = 72,\n        ['i'] = 73,\n        ['j'] = 74,\n        ['k'] = 75,\n\
    \        ['l'] = 76,\n        ['m'] = 77,\n        ['n'] = 78,\n        ['o']\
    \ = 79,\n        ['p'] = 80,\n        ['q'] = 81,\n        ['r'] = 82,\n     \
    \   ['s'] = 83,\n        ['t'] = 84,\n        ['u'] = 85,\n        ['v'] = 86,\n\
    \        ['w'] = 87,\n        ['x'] = 88,\n        ['y'] = 89,\n        ['z']\
    \ = 90,", "\tmessage = tostring(message)\n\tlocal messageLen = #message\n\tlocal\
    \ vowels = {'a', 'e', 'i', 'o', 'u'}\n\tlocal vowelsLen = #vowels\n\tlocal alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n\tlocal alphabetLen = #alphabet\n\tlocal encoded\
    \ = ''\n\t\n\tfor i = 1, messageLen do\n\t\tlocal char = message[i]\n\t\tif char\
    \ in vowels then\n\t\t\tlocal pos = vowels.index(char)\n\t\t\tlocal vowelChar\
    \ = alphabet[pos + 1]\n\t\t\tlocal vowelChar2 = alphabet[pos + 2]\n\t\t\tlocal\
    \ newChar = vowelChar .. vowelChar2\n\t\t\tencoded = encoded .. newChar\n\t\t\
    else\n\t\t\tencoded = encoded .. char\n\t\tend\n\tend\n\t\n\treturn encoded\n\
    end", "  local messageLower=string.lower(message)\n  local message=string.gsub(messageLower,'[aeiou]','')\n\
    \  local messageCap=string.upper(message)\n  local alphabet={'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \  local newMessage=\"\"\n  for index, letter in pairs(message) do\n    local\
    \ indexPlusTwo=alphabet[string.find(alphabet, letter)+1]\n    local indexMinusTwo=alphabet[string.find(alphabet,\
    \ letter)-1]\n    local indexPlusThree=alphabet[string.find(alphabet, letter)+2]\n\
    \    local indexMinusThree=alphabet[string.find(alphabet, letter)-2]\n    local\
    \ indexPlusFour=alphabet[string.find(alphabet, letter)+3]\n    local indexMinusFour=alphabet[string.find(alphabet,\
    \ letter)-3]\n    local letterCap=letter\n    local letterCapCap=string.upper(letterCap)\n\
    \    if indexPlusTwo~=nil then\n      letterCap=string.lower(letterCap)\n    end\n\
    \    if indexPlusThree~=nil then\n      letterCapCap=string.upper(letterCapCap)\n\
    \    end\n    if indexPlusFour~=nil then\n      letterCapCapCap=string.upper(letterCapCapCap)\n\
    \    end\n    local letterCapCapCapCap=string.upper(letterCapCapCapCap)\n    if\
    \ indexMinusTwo~=nil then\n      letterCapCap=string.lower(letterCapCap)\n   \
    \ end\n    if indexMinusThree~=nil then\n      letterCapCapCap=string.upper(letterCapCapCap)\n\
    \    end\n    if indexMinusFour~=nil then\n      letterCapCapCapCap=string.upper(letterCapCapCapCap)\n\
    \    end\n    if letterCapCap~=letterCapCapCap then\n      newMessage=newMessage..letterCapCapCap\n\
    \    elseif letterCapCapCap~=letterCapCap then\n      newMessage=newMessage..letterCapCap\n\
    \    elseif letterCapCapCapCap~=letterCapCap then\n      newMessage=newMessage..letterCapCapCap\n\
    \    elseif letterCap~=letterCap then\n      newMessage=newMessage..letterCap\n\
    \    elseif letterCap~=letter then\n      new", "    local output = ''\n    for\
    \ i, v in pairs(message) do\n        if v:lower() == 'a' then\n            v =\
    \ 97 -- ASCII 'A' -- 97 = 'a'\n        elseif v:lower() == 'e' then\n        \
    \    v = 65 -- ASCII 'E' -- 65 = 'e'\n        elseif v:lower() == 'i' then\n \
    \           v = 90 -- ASCII 'I'\n        elseif v:lower() == 'o' then\n      \
    \      v = 122 -- ASCII 'O' -- 122 = 'o'\n        elseif v:lower() == 'u' then\n\
    \            v = 164 -- ASCII 'U' -- 164 = 'u'\n        elseif v:lower() == 'y'\
    \ then\n            v = 169 -- ASCII 'Y' -- 169 = 'y'\n        end\n        local\
    \ letter = string.char(v)\n        output = output .. letter\n    end -- end i\n\
    \    return output\nend -- end encode", "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local vowels = 'aeiou'\n    local firstVowel = alphabet[1]\n    local secondVowel\
    \ = alphabet[2]\n    local firstVowelIndex = alphabet == firstVowel \n       \
    \                     and #alphabet or #alphabet/2\n    local secondVowelIndex\
    \ = alphabet == secondVowel \n                            and #alphabet or #alphabet/2\n\
    \    local vowelIndex = #alphabet/2", "   local alphabet = string.char(\"a\",\"\
    e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\")\n   local vowels = {'a','e','i','o','u','A','E','I','O','U'}\n\
    \   local message = \"\"\n   for i = 1,#message do -- Replace every vowel with\
    \ letter 2 places ahead\n      local place = alphabet:sub(i,i)\n      if vowels:sub(i+1)\
    \ then\n         message = message .. place -- Replace vowel with 2 letter after\
    \ vowel\n      else\n         message = message .. place .. alphabet:sub(i+2,i+2)\n\
    \      end\n   end\n   return message\nend", "  -- Split message into list of\
    \ vowels and non-vowels\n  local vowels = {}\n  local nonVowels = {}\n  for letter\
    \ in message:gmatch(\"[aeiouAEIOU]\") do\n    vowels[#vowels + 1] = letter\n \
    \ end\n  for letter in message:gmatch(\"[^aeiouAEIOU]\") do\n    nonVowels[#nonVowels\
    \ + 1] = letter\n  end\n  -- Swap the case of non-vowels\n  local nonVowelsCaps\
    \ = {}\n  for i = 1, #nonVowels do\n    nonVowelsCaps[i] = toupper(nonVowels[i])\n\
    \  end\n  -- Put all non-vowels in reverse order\n  local nonVowelsCapsRev = {}\n\
    \  for i = #nonVowels - 1, 1, -1 do\n    nonVowelsCapsRev[#nonVowelsCapsRev +\
    \ 1] = nonVowelsCaps[i]\n  end\n  -- Replace all vowels with two vowels ahead\n\
    \  local vowelsCaps = {}\n  for i = 1, #vowels do\n    vowelsCaps[i] = vowels[i]\n\
    \  end\n  for i = 1, #vowels do\n    local pos = #nonVowelsCaps + i\n    local\
    \ next = #nonVowelsCaps + i + 1\n    local currentVowel = nonVowelsCaps[pos]\n\
    \    local nextVowel = nonVowelsCaps[next]\n    local newVowel = vowelsCaps[currentVowel]\n\
    \    local newNextVowel = vowelsCaps[nextVowel]\n    nonVowelsCaps[pos] = newVowel\n\
    \    nonVowelsCaps[next] = newNextVowel\n  end\n  return table.concat(nonVowelsCapsRev,\
    \ \"\") .. table.concat(vowelsCaps, \"\")\nend", "    local msg = {}\n    for\
    \ i=1,#message do\n        local letter = string.sub(message,i,i)\n        if\
    \ string.find(letter, 'a','e','i','o','u') ~= nil then\n            table.insert(msg,\
    \ letter)\n        elseif string.find(letter, 'a','e','i','o','u') ~= nil then\n\
    \            table.insert(msg, letter)\n        elseif letter == 'y' then\n  \
    \          table.insert(msg,'a')\n        elseif letter == 'e' then\n        \
    \    table.insert(msg,'e')\n        elseif letter == 'i' then\n            table.insert(msg,'o')\n\
    \        elseif letter == 'o' then\n            table.insert(msg,'i')\n      \
    \  elseif letter == 'u' then\n            table.insert(msg,'u')\n        elseif\
    \ letter == 'A' then\n            table.insert(msg,'a')\n        elseif letter\
    \ == 'E' then\n            table.insert(msg,'e')\n        elseif letter == 'I'\
    \ then\n            table.insert(msg,'o')\n        elseif letter == 'O' then\n\
    \            table.insert(msg,'i')\n        elseif letter == 'U' then\n      \
    \      table.insert(msg,'u')\n        elseif letter == 'Y' then\n            table.insert(msg,'a')\n\
    \        elseif letter == 'Y' then\n            table.insert(msg,'e')\n      \
    \  elseif letter == 'Y' then\n            table.insert(msg,'i')\n        elseif\
    \ letter == 'Y' then\n            table.insert(msg,'u')\n        elseif letter\
    \ == 'Y' then\n            table.insert(msg,'a')\n        elseif letter == 'Y'\
    \ then\n            table.insert(msg,'e')\n        elseif letter == 'Y' then\n\
    \            table.insert(msg,'i')\n        elseif letter == 'Y' then\n      \
    \      table.insert(msg,'o')\n        elseif letter == 'Y' then\n            table.insert(msg,'u')\n\
    \        elseif letter == 'Y' then\n            table.insert(msg,'a')\n      \
    \  elseif letter == 'Y' then\n            table.insert(msg,'e')\n        elseif\
    \ letter == 'Y' then\n            table.insert(msg,'i')\n        elseif letter\
    \ == 'Y' then\n            table.insert(msg,'o')\n        elseif letter == 'Y'\
    \ then\n            table.insert(msg,'u')\n        elseif letter == 'Y' then\n\
    \            table.insert(msg,'a')\n        elseif letter == 'Y' then\n      \
    \      table.insert(msg,'e')\n        elseif letter == 'Y' then\n            table.insert(msg,'i')\n\
    \        elseif letter == 'Y' then", "    local newMessage = \"\"\n    for i =\
    \ 1, #message do\n        local firstLetter = string.sub(message, i, i)\n    \
    \    local secondLetter = string.sub(message, i + 1, i + 1)\n        local firstPlace\
    \ = string.find(string.gsub(firstLetter, \"[AEIOUYaeiou]\", \"A\"), string.gsub(firstLetter,\
    \ \"[AEIOUYaeiou]\", \"A\") + string.lower(string.sub(message, i, i + 1)))\n \
    \       local secondPlace = string.find(string.gsub(secondLetter, \"[AEIOUYaeiou]\"\
    , \"A\"), string.gsub(secondLetter, \"[AEIOUYaeiou]\", \"A\") + string.lower(string.sub(message,\
    \ i + 1, i + 1)))\n        if firstPlace == nil then\n            firstPlace =\
    \ 1\n        end\n        if secondPlace == nil then\n            secondPlace\
    \ = 1\n        end\n        newMessage = newMessage .. string.sub(string.gsub(firstLetter,\
    \ \"[AEIOUYaeiou]\", \"A\") + string.lower(string.sub(message, i, i + 1)), firstPlace,\
    \ firstPlace + 1) ..\n                string.sub(string.gsub(secondLetter, \"\
    [AEIOUYaeiou]\", \"A\") + string.lower(string.sub(message, i + 1, i + 1)), secondPlace\
    \ - 1, secondPlace + 1)\n    end\n    return newMessage\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nPlease add further details to expand on your answer, such as working\
    \ code or documentation citations.\n<|/ c |>\n<| c |>\nPlease add further details\
    \ to expand on your answer, such as working code or documentation citations.\n\
    <|/ c |>\n<| a dscore=0 tags=lua-table,lua,arrays |>\nThe Lua table in Lua is\
    \ really just a hash table.\nA hash table has one key per element.  So when you\
    \ do this\n<code>\ntable1 = {\n    key1 = val1,\n    key2 = val2,\n    key3 =\
    \ val3\n}\n</code>\nYou are saying there is one key for each element.  It might\
    \ be one key for each element, or it might be more keys.  Lua will use whatever\
    \ number of keys you tell it to have.\nBut when you do this\n<code>\ntable1 =\
    \ {\n    key1 = val1,\n    key2 = val2,\n    key3 = val3\n}\ntable1[1] = 'a'\n\
    table1[2] = 'b'\ntable1[3] = 'c'\n</code>\nYou are saying there is one key for\
    \ each element, but also that each key has 3 values.  Since Lua is a little smarter\
    \ than that, it will use whatever number of keys you have for the table as well.\n\
    A table ", "    local alphabet = {'a','b','c','d','e','f','g','h','i','j','k','l','m',\n\
    \                      'n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \    local vowels = {'a','e','i','o','u'}\n    local newMessage = {}\n    for\
    \ i = 1, #message do\n        newMessage[i] = message[i]\n        for j = 1, #alphabet\
    \ do\n            newMessage[i] = alphabet[alphabet[i]] == alphabet[j] and alphabet[i]\
    \ or alphabet[j]\n        end\n        for j = 1, #vowels do\n            newMessage[i]\
    \ = vowels[vowels[i]] ~= vowels[j] and vowels[i]:sub(vowels[i]-1, vowels[i]) or\
    \ vowels[j]\n        end\n        newMessage[i] = alphabet[alphabet[i]] == alphabet[#alphabet]\
    \ and alphabet[i] or alphabet[#alphabet]\n    end\n    return table.concat(newMessage)\n\
    end", "    local alphabet = 'aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ'\n\
    \    local vowels = 'aeiou'", "    local newMessage = ''\n    for i = 1, #message\
    \ do\n        if message:sub(i,i) ~= 'a' and message:sub(i,i) ~= 'e' and message:sub(i,i)\
    \ ~= 'i' and message:sub(i,i) ~= 'o' and message:sub(i,i) ~= 'u' then\n      \
    \      local newLetter = ''\n            local position = 0\n            for j\
    \ = 1, #message do\n                if message:sub(i,i) == message:sub(j,j) then\n\
    \                    position = j\n                    break\n               \
    \ else\n                    if j == #message then\n                        newLetter\
    \ = message:sub(position,position)\n                        break\n          \
    \          end\n                end\n            end\n            newLetter =\
    \ alphabet:sub((alphabet:find(newLetter) + 1):byte(), (alphabet:find(newLetter)\
    \ + 1):byte()+2)\n            newMessage = newMessage .. newLetter\n        end\n\
    \    end\n    return newMessage\nend", "  local result = message\n  for i = 1,\
    \ #message do \n    local index = string.find(message:sub(i,i),'A') + 1\n    local\
    \ letter = message:sub(i,index)\n    local position = string.find(message:sub(i,i),'a')\n\
    \    local nextLetter = message:sub(i+1,index-1)\n    local nextPosition = string.find(message:sub(i+1,i),'a')\n\
    \    local letterToReplace = nextLetter\n    if position > 0 and position < nextPosition\
    \ then \n      letterToReplace = message:sub(i+1,position)\n    end \n    result\
    \ = result:gsub('a',letterToReplace)\n  end \n  return result\nend", "\tlocal\
    \ vowels = \"AEIOUaeiou\"\n\tlocal alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \tlocal newMessage = \"\"\n\tfor i = 1, #message do\n\t\tlocal vowel = string.sub(message,i,i)\n\
    \t\tlocal newVowel = string.sub(vowels,string.find(vowel,vowels+string.sub(vowel,2,1))\
    \ or 1)\n\t\tlocal newLetter = string.sub(alphabet,string.find(vowel,vowel+string.sub(vowel,2,1))\
    \ or 1,string.find(vowel,vowel+string.sub(vowel,3,1)) or string.len(alphabet))\n\
    \t\tnewMessage = newMessage .. newVowel .. newLetter\n\tend\n\treturn newMessage\n\
    end", "  -- Initialize the letters.\n  local t = {}\n  for k, v in string.gmatch(message,\
    \ '%a') do\n    t[v] = true\n  end\n  -- Initialize vowels.\n  local v = {}\n\
    \  for k, v in string.gmatch('aeiouAEIOU') do\n    v[v] = true\n  end\n  -- Initialize\
    \ substitutions.\n  local substitutions = {}\n  -- Initialize indexes.\n  local\
    \ indexes = {}\n  -- Loop over the message. \n  for i = 1, #message do\n    --\
    \ If the letter is already in the substitutions, skip it.\n    if substitutions[message[i]]\
    \ then\n      -- If it's an index, increment the index.\n      if indexes[message[i]]\
    \ == nil then\n        indexes[message[i]] = true\n      end\n      -- If the\
    \ letter before it is in the substitutions, swap it \n      -- with the letter\
    \ after it. \n      elseif substitutions[message[i - 1]] then\n        t[message[i\
    \ - 1]], t[message[i]] = t[message[i]], t[message[i - 1]]\n      -- Otherwise,\
    \ just add the letter to the substitutions.\n      else\n        substitutions[message[i]]\
    \ = true\n      end\n    -- Otherwise, add it to the substitutions.\n    else\n\
    \      substitutions[message[i]] = true\n    end\n  end\n  -- Loop again over\
    \ the message. \n  for i = 1, #message do\n    -- If the letter is in the substitutions,\
    \ swap it with the \n    -- letter after it.\n    if substitutions[message[i]]\
    \ then\n      t[message[i - 1]], t[message[i]] = t[message[i]], t[message[i -\
    \ 1]]\n    -- If the letter is in the vowels, add it to the vowels. \n    elseif\
    \ v[message[i]] then\n      table.insert(indexes, message[i])\n    end\n  end\n\
    \  return table.concat(t, ' ')\nend", "    local vowels = string.gsub(message,\
    \ '[aeiou]', '')\n    local replaced = ''\n    for i = 1, string.len(vowels) do\n\
    \        local index = string.find(vowels, string.sub(vowels, i, i + 1)) - 1\n\
    \        if index >= 0 then\n            replaced = replaced .. string.sub(vowels,\
    \ i, index) .. string.sub(vowels, index + 1, i + 1)\n        else\n          \
    \  replaced = replaced .. string.sub(vowels, i, i)\n        end\n    end\n   \
    \ return string.gsub(replaced, '([aeiou])([aeiou])', '\\1\\2\\3')\nend", "   \
    \ local vowels = \"AEIOU\"\n    local alpha = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \    local message = string.gsub(message, '[aeiou]', vowels)\n    message = string.gsub(message,\
    \ '[AEIOU]', alpha)\n    local counts = {}\n    for letter in string.gmatch(message,\
    \ \"%a\") do\n        local index = string.find(alpha, letter)\n        count\
    \ = string.sub(letter, 1, index-1)\n        counts[letter] = count\n    end\n\
    \    local result = ''\n    for letter in string.gmatch(message, \"%a\") do\n\
    \        local count = counts[letter]\n        if count ~= nil then\n        \
    \    result = result .. string.sub(letter, 1, index-1)\n        end\n    end\n\
    \    return result\nend", "    if message == nil then\n        message = ''\n\
    \    end\n    if #message < 1 then\n        return message\n    end\n    local\
    \ new_message = ''\n    local new_vowel = ''\n    local new_letter = ''\n    local\
    \ vowels = { 'a','e','i','o','u' } \n    for i = 1, #message do\n        if string.sub(\
    \ message, i, i + 1 ) ~= ' ' then\n            new_message = new_message .. string.sub(\
    \ message, i, i + 1 )\n        else\n            new_message = new_message ..\
    \ string.sub( message, i )\n        end\n    end\n    \n    for i = 1, #message\
    \ do\n        new_letter = string.sub( message, i, i )\n        if string.find(\
    \ new_letter, vowels ) == 1 then\n            new_letter = string.sub( new_letter,\
    \ string.find( new_letter, vowels ), 1 )\n            new_letter = string.char(\
    \ string.find( new_letter, 'aeiou' )+1 )\n        elseif string.find( new_letter,\
    \ vowels ) then\n            new_letter = string.sub( new_letter, string.find(\
    \ new_letter, vowels ) )\n            new_letter = string.char( string.find( new_letter,\
    \ 'aeiou' )+1 )\n        end\n        \n        new_message = new_message .. new_letter\n\
    \    end\n    return new_message\nend", "  message = message:lower()\n  for i=1,#message\
    \ do -- For each letter, convert it to the next\n    local letter = message:sub(i,i)\
    \ -- Get the current letter\n    local nextLetter = message:sub(i+1,i+1) -- Get\
    \ the next letter\n    if nextLetter == 'a' then -- If the next letter is 'a',\
    \ swap it\n      letter = letter == 'a' and 'b' or 'a'\n    end\n    for j=1,#alphabet\
    \ do -- For each vowel found in the message, replace it with the one that comes\
    \ 2 letters ahead of the vowel.\n      if alphabet[j] == letter then -- If the\
    \ letter found is the same as the vowel, swap it with the one that comes 2 letters\
    \ ahead.\n        letter = alphabet[j + 2]\n        break\n      end\n    end\n\
    \    message = message:sub(1,i-1) -- Remove the current letter and add it back\n\
    \    message = message .. letter -- Add the letter\n  end\n  return message\n\
    end", "\t-- write your solution here\n\t-- Don't forget to return the message\
    \ at the end\n\t-- Also remember to include a check to see if message contains\
    \ \n\t-- at least 1 letter.\n\t-- Hint: use the string.gsub function\n\t\n\t--\
    \ BEGIN SOLUTION\n\t-- END SOLUTION\nend", "    local vowels = {'a', 'e', 'i',\
    \ 'o', 'u'}\n    return message:gsub(\"[aeiou]\", function(letter)\n        return\
    \ letter:lower() .. vowels[vowels:find(letter) + 2]\n    end)\nend", "    local\
    \ alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    local vowels = \"AEIOUYAEIOUY\"\
    \n    local vowelcount = 0\n    local messagelength = #message", "  local newMessage\
    \ = message\n  -- first we need to get the letters right case\n  -- letters are\
    \ easy\n  local function swapCase(letter)\n    local convertedLetter = string.upper(letter)\n\
    \    return string.lower(convertedLetter)\n  end\n  -- next we need to swap case\
    \ of the vowels\n  for index = 1, #newMessage do\n    -- get the current letter\n\
    \    local letter = newMessage[index]\n    -- get the letter in front of it so\
    \ we can swap case of the \n    -- current letter\n    local letterBefore = string.sub(newMessage,\
    \ index-1, index)\n    -- swap case of the letter\n    newMessage[index] = swapCase(letterBefore)\n\
    \    -- get the letter in front of that vowel\n    local letterBeforeVowel = string.sub(newMessage,\
    \ index-1, index-1)\n    -- swap case of the vowel\n    newMessage[index-1] =\
    \ swapCase(letterBeforeVowel)\n  end\n  -- now that all the letters and vowels\
    \ are right case, we can do \n  -- all this in one go\n  local newMessageLetters\
    \ = string.gsub(newMessage, \"[aeiouAEIOU]\", \"$1\")\n  -- convert all the letters\
    \ to a letter in the english alphabet\n  -- using the alphabet array\n  local\
    \ alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n  local\
    \ letterCount = 1\n  for letter in newMessageLetters do\n    -- get the position\
    \ that we are looking for in the alphabet array\n    local position = alphabet:find(letter)\n\
    \    -- swap the case of the letter\n    newMessage[letterCount] = alphabet:sub(position,\
    \ position+1)\n    -- increment the position in the alphabet array by 1\n    position\
    \ = position + 1\n    letterCount = letterCount + 1\n  end\n  -- return the new\
    \ message\n  return newMessage\nend", "    local function replaceVowels(letter)\n\
    \        local vowels = {'a', 'e', 'i', 'o', 'u'}\n        for i = 1, #vowels\
    \ do\n            if string.match(letter, vowels[i]) then\n                return\
    \ string.sub(letter, 1, i)..string.sub(letter, i+1, #letter)\n            end\n\
    \        end\n        return letter\n    end\n    local function replaceLetters(letter)\n\
    \        local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n        for i = 1, #alphabet\
    \ do\n            if string.match(letter, alphabet[i]) then\n                return\
    \ string.sub(letter, 1, i)..string.sub(letter, i+1, #letter)\n            end\n\
    \        end\n        return letter\n    end\n    local function replaceLettersVowels(letter)\n\
    \        return string.sub(letter, 1, 1)..replaceLetters(string.sub(letter, 1,\
    \ 2))..replaceLetters(string.sub(letter, 1, 3))..string.sub(letter, #letter, #letter)\n\
    \    end\n    message = string.gsub(message, '(.)', replaceLettersVowels)\n  \
    \  message = string.gsub(message, '([aeiou])', replaceVowels)\n    return message\n\
    end", "    local alphabet = {\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\
    \ 'i', 'j', 'k', 'l', 'm',\n        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z'\n    }\n    local vowels = { 'a', 'e', 'i', 'o', 'u' }",
  "   for i = 1, #message do\n      local char = string.sub( message, i, i )\n   \
    \   local index = math.abs( string.find( char, 'aeiou' ) )\n      local letter\
    \ = string.sub( char, index, index+1 )\n      local rev = string.sub( char, index+1,\
    \ index+2 )\n      local newChar = string.upper( letter )\n      \n      \n  \
    \    if( rev == 'u' ) then\n        newChar = string.lower( letter )\n      end\n\
    \      \n      if( rev == 'a' ) then\n        newChar = string.upper( letter )\n\
    \      end\n      \n      message[i] = newChar\n   end\n   return message\nend",
  "    local vowels = 'AEIOU'\n    local alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \ \n    local mapping = {}\n    \n    for letter in string.gsub(message, \"[^\"\
    \ .. vowels .. \"]\", \"\")\n    do\n        mapping[string.sub(alphabet, string.find(alphabet,\
    \ letter) + 1, 1)] = letter\n    end\n    \n    return string.gsub(message, \"\
    [\" .. vowels .. \"]\", function(letter)\n        return mapping[letter]\n   \
    \ end)\nend", "    local newMessage = message\n    for i = 1,#message do\n   \
    \     local letter = string.sub(message, i, i)\n        -- replace all vowels\
    \ with letter 2 places ahead of them\n        if string.find(letter, '[aeiou]')\
    \ then\n            letter = string.sub(letter, 1, string.find(letter, '[aeiou]')\
    \ - 1)\n        end\n        newMessage = newMessage:gsub('.', letter)\n    end\n\
    \    return newMessage\nend", "    -- Replace vowels with letter after vowel.\n\
    \    local function replace(char, index)\n        if string.sub(char, 1, index)\
    \ ~= 'aeiou' then\n            return char\n        end\n        local index =\
    \ index + 1\n        if string.sub(char, index, index) ~= 'aeiou' then\n     \
    \       return char\n        end\n        local index = index + 1\n        if\
    \ string.sub(char, index, index) ~= 'aeiou' then\n            return char\n  \
    \      end\n        local index = index + 1\n        if string.sub(char, index,\
    \ index) ~= 'aeiou' then\n            return char\n        end\n        local\
    \ index = index + 1\n        if string.sub(char, index, index) ~= 'aeiou' then\n\
    \            return char\n        end\n        local index = index + 1\n     \
    \   if string.sub(char, index, index) ~= 'aeiou' then\n            return char\n\
    \        end\n        return string.char(string.sub(string.char(char), index,\
    \ index + 1))\n    end\n    return table.concat(map(string.gmatch, message:gsub('[aeiouAEIOU]'\
    \ .. string.rep('?', 2) .. '[aeiouAEIOU]', replace)), \"\")\nend", "    local\
    \ out = {}\n    for c in string.gmatch(message, '%a') do\n        local pos =\
    \ string.find(message, c, 'a')\n        if pos ~= nil then\n            out[#out+1]\
    \ = string.sub(message, pos, pos)\n            out[#out+1] = string.lower(string.sub(message,\
    \ pos+1, pos+1))\n            out[#out+1] = string.upper(string.sub(message, pos+2))\n\
    \        end\n    end\n    return table.concat(out, '')\nend", "  -- Initialize\
    \ with empty string.\n  local result = \"\"\n  -- Loop through the string.\n \
    \ for i = 1, #message do\n    -- If the character is alpha, we swap case.\n  \
    \  if string.sub(message, i, i) ~= 'a' and string.sub(message, i, i) ~= 'A' then\n\
    \      result = string.gsub(string.gsub(string.gsub(string.sub(message, i, i),\
    \ \"a\", \"A\"), \"e\", \"E\"), \"i\", \"I\")\n      -- If the character is consonant,\
    \ we replace vowels.\n    elseif string.sub(message, i, i) ~= 'a' and string.sub(message,\
    \ i, i) ~= 'A' then\n      -- If the character is vowel, we replace it with it's\
    \ two places ahead.\n      if string.sub(message, i, i) ~= 'a' and string.sub(message,\
    \ i, i) ~= 'A' then\n        result = result .. string.sub(message, i, i + 1)\n\
    \      end\n      -- Otherwise, just add it to the result string.\n      else\n\
    \        result = result .. string.sub(message, i, i)\n      end\n    end\n  end\n\
    \  return result\nend", "  local alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    \n  local vowels = alphabet:match(\"[aeiou]\") -- Finds all the vowels\n  -- Replaces\
    \ all vowels with their 2 places ahead in the alphabet\n  local newMessage = message:gsub(vowels,\
    \ function(match)\n      local i = alphabet.indexOf(match) -- Gets the index of\
    \ that vowel\n      -- Gets what 2 places ahead of that vowel\n      local nextVowel\
    \ = alphabet:sub(i + 1, i + 1)\n      -- Replace that vowel\n      return alphabet:sub(i,\
    \ i) + nextVowel\n  end)\n  return newMessage\nend", "  local result = \"\"\n\
    \  for letter in message:gmatch(\"%a\") do\n    local letterIndex = letter:byte()\
    \ - \"a\"\n    letterIndex = math.floor(letterIndex / 2) \n    result = result\
    \ .. letter:sub(1, letterIndex) .. letter:sub(letterIndex + 1) \n  end\n  return\
    \ result\nend", "   local output = ''\n   for i = 1, #message do\n      local\
    \ char = string.lower(message[i])\n      if char in string.letters then\n    \
    \     local vowels = {}\n         for j = 1, #char:sub(1,1) do\n            table.insert(vowels,\
    \ string.sub(char, 1, j))\n         end\n         local vowelsLen = #vowels\n\
    \         for j = 1, #char:sub(1,1) do\n            local newVowel = string.sub(char,\
    \ 1, j) \n            local previousVowel = string.sub(vowels, j+1, j-1)\n   \
    \         local newVowelIndex = math.abs(#vowels - j - 1)\n            if vowelsLen\
    \ > newVowelIndex then\n               newVowel = previousVowel\n            end\n\
    \            table.insert(output, newVowel)\n         end\n         table.insert(output,\
    \ string.sub(vowels, #vowels))\n      end\n   end\n   return output\nend", " \
    \ -- Your code here\n  local letters = {}\n  for i = 1, #message do\n    table.insert(letters,\
    \ string.sub(message, i, i) + string.sub(message, i - 1, i - 1))\n  end\n  for\
    \ i, letter in pairs(letters) do\n    if string.find(letter, 'aeiou') ~= nil then\n\
    \      letters[i] = string.sub(letter, 2, 2)\n    end\n  end\n  -- Your code here\n\
    \  local message = ''\n  for i = 1, #message do\n    message = message .. letters[i]\n\
    \  end\n  return message\nend", "\t-- Add your code here\n\tlocal alphabet = \"\
    abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\tfor i = 0, #message\
    \ do\n\t\tlocal alphabetIndex = alphabet :sub(i,i)\n\t\tlocal letterIndex = message[i]\n\
    \t\tlocal newLetterIndex = alphabetIndex + letterIndex\n\t\tif newLetterIndex\
    \ > #alphabet then\n\t\t\tnewLetterIndex = newLetterIndex - #alphabet\n\t\tend\n\
    \t\tmessage[i] = alphabet[newLetterIndex]\n\tend\n\treturn message\nend", "  --\
    \ TODO: Implement me!\nend", "    local letter = {}\n    for i = 1, #message do\n\
    \        letter[i] = message[i]\n    end\n    local vowels = \"aeiou\"\n    for\
    \ i = 1, #vowels do\n        local l = vowels[i]\n        if letter[l] == nil\
    \ then\n            letter[l] = letter[l+2]\n        end\n    end\n    local letters\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    for i = 1, #letters do\n        local\
    \ l = letters[i]\n        if letter[l] ~= nil then\n            letter[l] = letter[l+2]\n\
    \        end\n    end\n    for i = 1, #letter do\n        letter[i] = letter[i]:lower()\n\
    \    end\n    return table.concat(letter, 1)\nend", "    local message = '' ..\
    \ message\n    local vowels = \"aeiouAEIOU\"\n    local letters = \"bcdfghjklmnpqrstvwxyz\"\
    \n    local replace = {}\n    for i = 0, #message, 1 do\n        local found =\
    \ false\n        for j = 1, #vowels, 1 do\n            if string.sub( vowels,\
    \ i, i+1 ) then\n                found = true \n                replace[j] = letters[i]\n\
    \                break\n            end\n        end\n        if not found then\n\
    \            -- Not a vowel, so just replace it.\n            replace[i] = letters[i]\n\
    \        end\n    end\n    local result = \"\"\n    for i = 0, #message, 1 do\n\
    \        -- Replace all vowels in message with the \n        -- letter that appears\
    \ 2 places ahead of that vowel.\n        if string.sub( message, i, i+1 ) then\n\
    \            result = result .. replace[ string.sub( message, i, i+1 ) ]\n   \
    \     end\n    end\n    return result\nend\n</cell>\n<cell>", "    local newMessage\
    \ = \"\"\n    for letter in message:gmatch \"[%a][aeiou]\" do\n        newMessage\
    \ = newMessage .. string.sub (letter, 2)\n    end\n    return newMessage\nend\n\
    </code>\n<|/ a dscore=0 tags=lua |>\n<| c |>\nI did say I did not know where to\
    \ start. Also, I do not understand your code. Could you explain?\n<|/ c |>\n<|\
    \ c |>\nI modified the answer to include a description of what each part of your\
    \ function does\n<|/ c |>\n<| a dscore=0 tags=lua |>\n<code>", "\tlocal alphabet\
    \ = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \tlocal vowels = {'a','e','i','o','u'}", "    local alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    local vowels = \"AEIOUY\"\n    local result = \"\"\n    for symbol in message:gmatch(\"\
    %a\") do\n        local count = 1\n        for letter in alphabet:gmatch(\"[\"\
    \ .. symbol .. \"]\") do\n            if symbol:sub(1,1) == letter then\n    \
    \            count = count + 1\n            else\n                count = count\
    \ - 1\n            end\n        end\n        if count > 1 then\n            local\
    \ letter_index = alphabet:find(symbol, alphabet:len()) \n            local vowel_index\
    \ = vowels:find(symbol)\n            local letter_position = alphabet:sub(vowel_index,\
    \ letter_index)\n            local vowel_position = alphabet:sub(letter_index,\
    \ letter_index)\n            result = result .. alphabet:sub(vowel_index, vowel_index)\
    \ .. letter:sub(1, 1)\n            if count == 2 then\n                result\
    \ = result .. alphabet:sub(vowel_position, letter_index)\n            end\n  \
    \      else\n            result = result .. symbol\n        end\n    end\n   \
    \ return result\nend", "    local alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\
    \    local vowels = \"aeiou\"\n    local new_message = \"\"\n    for letter in\
    \ message:gmatch(\"%a\") do\n        new_message = new_message .. alphabet:sub(1,\
    \ alphabet:find(letter, alphabet:sub(1) + 1)) .. alphabet:find(letter, alphabet:sub(1)\
    \ + 1)\n    end \n    return new_message\nend", "    local result = \"\"\n   \
    \ for i = 1, #message do\n        local char = string.sub(message, i, i)\n   \
    \     if char == \"a\" then char = \"e\" end\n        if char == \"e\" then char\
    \ = \"a\" end\n        if char == \"i\" then char = \"o\" end\n        if char\
    \ == \"o\" then char = \"i\" end\n        if char == \"u\" then char = \"k\" end\n\
    \        if char == \"k\" then char = \"u\" end\n        if char == \"y\" then\
    \ char = \"o\" end\n        if char == \"i\" then char = \"e\" end\n        if\
    \ char == \"o\" then char = \"i\" end\n        if char == \"u\" then char = \"\
    k\" end\n        if char == \"k\" then char = \"u\" end\n        if char == \"\
    y\" then char = \"o\" end\n        if char == \"a\" then char = \"e\" end\n  \
    \      if char == \"e\" then char = \"a\" end\n        if char == \"i\" then char\
    \ = \"o\" end\n        if char == \"o\" then char = \"i\" end\n        if char\
    \ == \"u\" then char = \"k\" end\n        if char == \"k\" then char = \"u\" end\n\
    \        if char == \"y\" then char = \"o\" end\n        if char == \"a\" then\
    \ char = \"e\" end\n        if char == \"e\" then char = \"a\" end\n        if\
    \ char == \"i\" then char = \"o\" end\n        if char == \"o\" then char = \"\
    i\" end\n        if char == \"u\" then char = \"k\" end\n        if char == \"\
    k\" then char = \"u\" end\n        if char == \"y\" then char = \"o\" end\n  \
    \      result = result .. char .. string.sub(message, i+1, i+1)\n    end\n   \
    \ return result\nend", "\t-- Initialize an empty string\n\tlocal msg = ''\n\t\
    -- Iterate through each letter in the message\n\tfor i = 1, #message do\n\t\t\
    -- Swap the case of the letter\n\t\tmsg = string.sub(message, i, i) + string.sub(message,\
    \ i) + msg\n\t\t-- Replace each vowel in the message with the letter that appears\
    \ 2 places ahead of the vowel\n\t\tmsg = string.gsub(msg, '[aeiouAEIOU]', function(vowel,\
    \ index, string)\n\t\t\treturn string.sub(string, (index - 1), index - 1) + string.sub(string,\
    \ (index + 1), index + 1) \n\t\tend)\n\tend\n\t-- Return the message\n\treturn\
    \ msg\nend", "\tlocal message2 = \"\"\n\t\n\tfor i=1,#message do\n\t\tlocal letter\
    \ = string.sub(message, i, i)\n\t\tif letter == \"a\" then\n\t\t\tletter = \"\
    b\"\n\t\telseif letter == \"e\" then\n\t\t\tletter = \"f\"\n\t\telseif letter\
    \ == \"i\" then\n\t\t\tletter = \"j\"\n\t\telseif letter == \"o\" then\n\t\t\t\
    letter = \"k\"\n\t\telseif letter == \"u\" then\n\t\t\tletter = \"l\"\n\t\telseif\
    \ letter == \"y\" then\n\t\t\tletter = \"m\"\n\t\tend\n\t\t\n\t\tlocal vowel =\
    \ string.sub(message, i, i) + string.sub(message, i+1, 1)\n\t\t\n\t\tif vowel\
    \ ~= letter then\n\t\t\tmessage2 = message2 + letter .. vowel\n\t\telse\n\t\t\t\
    message2 = message2 + letter\n\t\tend\n\tend\n\t\n\treturn message2\nend", " \
    \  -- We first need to know what letters are in the message, \n   -- which we\
    \ get from counting the letters.\n   -- Then we iterate through the letters in\
    \ message and replace\n   -- the appropriate letters.\n   -- Finally, we return\
    \ the encoded message.\n   local letterCount = {}\n   for letter, index in pairs(alphabet)\
    \ do\n      letterCount[letter] = countLetters(message, index)\n   end", "   \
    \ local message2 = message\n    local positions = {}\n    local count = 0\n  \
    \  for i,v in pairs(alphabet) do\n        positions[v] = count\n        count\
    \ = count + 1\n    end\n    for i,v in pairs(message2) do\n        if letters_map[v]\
    \ == nil then\n            --print(i)\n            positions[v] = count\n    \
    \        count = count + 1\n        else\n            positions[letters_map[v]]\
    \ = count\n            count = count + 1\n        end\n    end\n    local encoded\
    \ = ''\n    local letter = ''\n    local i = 1\n    while i < #message do\n  \
    \      local char = message[i]\n        letter = message[i]\n        if letters_map[letter]\
    \ == nil then\n            letter = alphabet[alphabet.lenght]\n        end\n \
    \       encoded = encoded .. letters[letter] .. positions[letter]\n        i =\
    \ i + 1\n    end\n    return encoded\nend", "    local vowels = 'aeiou'\n    local\
    \ mapping = {}\n    \n    for i, v in ipairs(vowels) do\n        mapping[v] =\
    \ string.sub(i + 1, 2)\n    end\n    \n    return message\n        :gsub('.',\
    \ function(c) \n            local s = string.sub(c, 2, 1)\n            if mapping[s]\
    \ ~= nil then\n                return mapping[s]\n            else\n         \
    \       return c\n            end\n        end)\n        :gsub('[^'..vowels..']',\
    \ function(c) \n            return string.upper(c)\n        end)\n        :gsub('[AEIOUaeiou]',\
    \ function(c) \n            return string.upper(c)\n        end)\nend", "  --\
    \ TODO: write this function\n  return message\nend", "  local messageUpper = message:upper()\n\
    \  local messageUpper2 = message:gsub(\"A\", \"E\"):gsub(\"O\", \"I\"):gsub(\"\
    U\", \"Y\")\n  local messageUpper3 = messageUpper2:gsub(\"a\", \"e\"):gsub(\"\
    o\", \"i\"):gsub(\"u\", \"y\")\n  local messageUpper4 = messageUpper3:gsub(\"\
    A\", \"E\"):gsub(\"O\", \"I\"):gsub(\"U\", \"Y\")\n  local messageUpper5 = messageUpper4:gsub(\"\
    a\", \"e\"):gsub(\"o\", \"i\"):gsub(\"u\", \"y\")\n  local messageUpper6 = messageUpper5:gsub(\"\
    A\", \"E\"):gsub(\"O\", \"I\"):gsub(\"U\", \"Y\")\n  \n  local messageLower =\
    \ message:lower()\n  local messageLower2 = messageLower:gsub(\"a\", \"e\"):gsub(\"\
    o\", \"i\"):gsub(\"u\", \"y\")\n  local messageLower3 = messageLower2:gsub(\"\
    A\", \"E\"):gsub(\"O\", \"I\"):gsub(\"U\", \"Y\")\n  local messageLower4 = messageLower3:gsub(\"\
    a\", \"e\"):gsub(\"o\", \"i\"):gsub(\"u\", \"y\")\n  local messageLower5 = messageLower4:gsub(\"\
    A\", \"E\"):gsub(\"O\", \"I\"):gsub(\"U\", \"Y\")\n  local messageLower6 = messageLower5:gsub(\"\
    A\", \"E\"):gsub(\"O\", \"I\"):gsub(\"U\", \"Y\")\n  \n  local outputLower = messageLower:gsub(\"\
    a\", \"e\"):gsub(\"A\", \"E\"):gsub(\"o\", \"i\"):gsub(\"O\", \"I\"):gsub(\"u\"\
    , \"Y\"):gsub(\"U\", \"y\")\n  \n  return outputLower\nend", "    local alphabet\
    \ = \"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ\"\n    local alphabetMap\
    \ = {}\n    for i,letter in ipairs(alphabet) do\n        alphabetMap[i] = letter\n\
    \    end\n    local letterMap = {}\n    for i,letter in ipairs(alphabet) do\n\
    \        letterMap[letter] = i\n    end\n    \n    local message = message:gsub(\"\
    .\", function(character)\n        return alphabetMap[character]\n    end)\n  \
    \  \n    local messageMap = {}\n    for i,letter in ipairs(message) do\n     \
    \   if letterMap:find(letter) ~= nil then\n            local index = letterMap[letter]\n\
    \            table.insert(messageMap, index)\n        end\n    end\n    \n   \
    \ local result = ''\n    for i,v in ipairs(messageMap) do\n        local pos =\
    \ i\n        if v > 1 then\n            local index = (v - 2) * 2 + pos\n    \
    \        if index > 26 then\n                index = 1\n            end\n    \
    \        pos = index + 1\n        end\n        \n        local next = alphabetMap[v]\n\
    \        local lastCharacter = alphabetMap[v + 1]\n        \n        if next ~=\
    \ lastCharacter then\n            result = result .. next\n        end\n    end\n\
    \    \n    return result\nend", "\tlocal out = ''\n\tfor letter, vowel in pairs(string.gmatch(message,\
    \ '%a') or 'a') do\n\t\tlocal index = string.find(letter, vowel)\n\t\tif index\
    \ > 0 then\n\t\t\tlocal nextVowel = string.sub(letter, 1, index - 1)\n\t\t\tlocal\
    \ nextLetter = string.sub(letter, index + 1, (index + 3))\n\t\t\tout = out ..\
    \ nextLetter\n\t\t\tlocal vowelCount = string.count(vowel, letter)\n\t\t\tif vowelCount\
    \ % 2 > 0 then\n\t\t\t\tout = out .. nextVowel\n\t\t\tend\n\t\telse\n\t\t\tout\
    \ = out .. letter\n\t\tend\n\tend\n\treturn out\nend", "  -- Write your code here!\n\
    \  return \nend", "  message = message:lower()\n  local decoded = message\n  for\
    \ letter, index in pairs(string.gmatch('([a-z])\\\\1', '%a')) do\n    decoded\
    \ = decoded:gsub('\\\\' .. letter, letter:lower())\n    decoded = decoded:gsub('%a'\
    \ .. index, '%' .. letter)\n  end\n  return decoded\nend", "    local vowels =\
    \ { 'a', 'e', 'i', 'o', 'u' }\n    local alphabet = { 'a', 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z' }\n    local message = message\n    -- Iterate through\
    \ all letters\n    for i=1,#message do\n        -- Iterate through all vowels\n\
    \        for v=1,#vowels do\n            -- If the letter is the same as the vowel\
    \ 2 letters ahead\n            -- Then swap the letters\n            if message[i]\
    \ == vowels[v] and message[i+v] == vowels[v] and message[i+2*v] == vowels[v] then\n\
    \                message = message:sub(1,i-1) .. alphabet[vowels[v]] .. message:sub(i+v)\n\
    \            end\n        end\n    end\n    return message\nend", "    local vowels\
    \ = { 'a', 'e', 'i', 'o', 'u' }\n    local alphabet = { 'b', 'c', 'd', 'f', 'g',\
    \ 'h', 'j', 'k', 'l', \n        'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x',\
    \ 'y', 'z' }\n    \n    local encoded = message\n    \n    for i = 1, #message\
    \ do\n        if string.sub( message, i, i ) then\n            local j = 1\n \
    \           local vowel = string.sub( message, i, i + 1 )\n            while j\
    \ <= #vowels and vowel ~= vowels[j] do\n                local alpha = alphabet[\
    \ #alphabet - 1 ]\n                j = j + 1\n                \n             \
    \   -- swap letters\n                encoded = string.sub( encoded, 1, i ) ..\
    \ \n                    string.sub( encoded, i + 1, i + j ) .. \n            \
    \        string.sub( encoded, i + j ) .. \n                    string.sub( encoded,\
    \ i + 1, i + 1 )\n                \n                -- swap vowels\n         \
    \       encoded = string.sub( encoded, 1, i ) .. \n                    string.sub(\
    \ encoded, i + 1, i + j ) .. \n                    string.sub( encoded, i + j\
    \ ) .. \n                    string.sub( encoded, i + 1, i + 1 )\n           \
    \     \n                -- swap alpha\n                encoded = string.sub( encoded,\
    \ 1, i ) .. \n                    alpha .. \n                    string.sub( encoded,\
    \ i + 1, i + j ) .. \n                    string.sub( encoded, i + j ) .. \n \
    \                   string.sub( encoded, i + 1, i + 1 )\n                \n  \
    \              -- swap vowel again\n                encoded = string.sub( encoded,\
    \ 1, i ) .. \n                    string.sub( encoded, i + 1, i + j ) .. \n  \
    \                  string.sub( encoded, i + j ) .. \n                    string.sub(\
    \ encoded, i + 1, i + 1 )\n            end\n        end\n    end\n    \n    return\
    \ encoded\nend", "    local vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I',\
    \ 'O', 'U'}\n    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    local new_message\
    \ = ''", "  -- Write your encoding function here.\nend", "    local alphabet =\
    \ {}\n    local upper, lower = string.upper, string.lower\n    for i=1,string.len(message)\
    \ do alphabet[lower(message[i])] = 1 end -- add uppercase letters\n    for i=2,string.len(message)\
    \ do alphabet[lower(lower(message[i-1]))] = 1 -- add lower case letters\n    local\
    \ index = 1\n    local result = ''\n    for i=1,string.len(message) do\n     \
    \   if alphabet[lower(message[i])] then\n            result = result .. lower(lower(message[i]))\
    \ .. lower(lower(message[index]))\n            index = index + 1\n        elseif\
    \ alphabet[lower(lower(message[i]))] then\n            result = result .. lower(message[i])\n\
    \            index = index + 1\n        else\n            result = result .. lower(lower(message[i]))\n\
    \            index = index + 1\n        end\n    end\n    return string.reverse(result)\n\
    end", "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    local alphabetLower\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n    local alphabetUpper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \    local vowels = 'aeiou'\n    local messageLower = ''\n    local messageUpper\
    \ = ''\n    local newMessage = ''", "    message = message:gsub('.', function(c)\
    \ return string.upper(c) end)\n    message = message:gsub('a', 'z')\n    message\
    \ = message:gsub('ey', 'f') \n    message = message:gsub('iu', 'x') \n    message\
    \ = message:gsub('o', '0') \n    message = message:gsub('u', '2') \n    message\
    \ = message:gsub('u', '2')\n    message = message:gsub('y', '2') \n    message\
    \ = message:gsub('a', '0') \n    message = message:gsub('y', '1')\n    message\
    \ = message:gsub('y', '1') \n    message = message:gsub('o', '0')\n    return\
    \ message\nend", "    local words = split(message)\n    local alphabet = {\n \
    \       'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', \n       \
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', \n        'y', 'z'\n\
    \    }\n    local vowels = {\n        'a', 'e', 'i', 'o', 'u'\n    }\n    \n \
    \   for i, word in pairs(words) do\n        local decoded = {}\n        for j,\
    \ letter in pairs(word) do\n            decoded[alphabet[j]] = letter\n      \
    \  end\n        \n        for i, letter in pairs(alphabet) do\n            decoded[letter]\
    \ = decoded[letter] .. decoded[vowels[i+1]]\n        end\n        \n        decoded\
    \ = table.concat(decoded)\n        \n        table.insert(words, decoded)\n  \
    \  end\n    \n    local messages = {}\n    \n    for _, word in ipairs(words)\
    \ do\n        table.insert(messages, word)\n    end\n    \n    return table.concat(messages)\n\
    end", "  -- Create a variable that stores the count of vowels \n  -- from the\
    \ message. \n  -- Create a variable that stores the length of the message \n \
    \ -- string. \n  -- Create a variable that stores the index of the current vowel\
    \ \n  -- in the message. \n  -- Create a variable that stores the index of a vowel\
    \ that \n  -- appears 2 places ahead of the current vowel in the \n  -- english\
    \ alphabet. \n  -- Create a variable that stores the index of the current \n \
    \ -- letter in the english alphabet. \n  -- Create a variable that stores the\
    \ letter that appears \n  -- 2 places ahead of the current letter in the english\
    \ \n  -- alphabet. \n  -- Create a variable that stores the string of the encrypted\
    \ \n  -- message. \n  -- Create a variable that stores the current vowel before\
    \ \n  -- encrypting the message. \n  -- Create a variable that stores the current\
    \ letter before \n  -- encrypting the message. \n  -- Set the variable that stores\
    \ the encrypted message equal to \n  -- the empty string. \n  -- Iterate over\
    \ the length of the message string. \n  for i = 0, #message do\n    \n    \n \
    \   -- Increment a variable that stores the count of vowels \n    -- from the\
    \ message. \n    count = #message:sub(1, i) + #message:sub(i, i+1) \n    \n  \
    \  -- Increment a variable that stores the length of the message \n    -- string.\
    \ \n    length = #message\n    \n    -- Iterate over all the characters in the\
    \ message string. \n    for j = 1, length do\n      \n      -- Increment a variable\
    \ that stores the index of a vowel \n      -- that appears 2 places ahead of the\
    \ current vowel in the \n      -- english alphabet. \n      vowelIndex = #alphabet:sub(1,\
    \ i) + #alphabet:sub(i, i+1)\n      \n      -- Check if the vowel index and the\
    \ current letter index \n      -- are equal, if the vowel index and the current\
    \ letter \n      -- index are not equal, then increment a variable that \n   \
    \   -- stores the index of the current letter in the english \n      -- alphabet.\
    \ \n      if vowelIndex == j then\n        alphabetIndex = #alphabet:sub(1, i)\
    \ + #alphabet:sub(i, i+1)\n      else\n        alphabetIndex = #alphabet:sub(i,\
    \ i)\n      end\n      \n      -- Increment a variable that stores the current\
    \ vowel before \n      -- encrypting the message. \n      alphabet = alphabet:sub(i,\
    \ i)\n      \n      -- Set the variable that stores the encrypted message equal\
    \ to \n      -- the empty string. \n      encryptedMessage = \"\"\n      \n  \
    \    -- Iterate over the length of the alphabet. \n      for k = 1, #alphabet ",
  "    -- Write your answer here\n    -- \n    -- Write some code here\n    -- \n\
    \    -- Don't forget to return your answer as a string\n    -- \n    -- Explanation:\
    \ \n    -- The message is converted to lower case. Then we loop through \n   \
    \ -- each letter and if the letter is a vowel, we find the letter \n    -- that\
    \ is 2 places ahead of the vowel (i.e. the second letter in the alphabet). \n\
    \    -- Then we replace the letter in the message with that letter. \n    -- \n\
    \    -- Finally, we return the message\n    \n    -- Write your code here\n  \
    \  \n    return message\nend", "    local alphabet = {}\n    for i=1,26 do alphabet[i]\
    \ = i end\n    local vowels = \"aeiou\"\n    local consonants = \"bcdfghjklmnpqrstvwxyz\"\
    \n    local firstLetters = {}\n    for i=1,#message do\n        local letter =\
    \ string.sub(message,i,i)\n        if firstLetters[letter] == nil then\n     \
    \       firstLetters[letter] = letter\n        else\n            firstLetters[letter]\
    \ = string.sub(firstLetters[letter],1,1)\n        end\n    end\n    local codes\
    \ = {}\n    local consonantCount = 0\n    local vowelCount = 0\n    for i=1,#message\
    \ do\n        local letter = string.sub(message,i,i)\n        if firstLetters[letter]\
    \ ~= nil then\n            codes[#codes+1] = string.sub(firstLetters[letter],1,1)\n\
    \            if alphabet[letter] == letters[letter] then\n                consonantCount\
    \ = consonantCount + 1\n            else\n                vowelCount = vowelCount\
    \ + 1\n            end\n        end\n    end\n    for i=1,#message do\n      \
    \  local letter = string.sub(message,i,i)\n        if alphabet[letter] == letters[letter]\
    \ then\n            codes[#codes+1] = alphabet[letter]\n            if firstLetters[letter]\
    \ == vowels[vowelCount] then\n                codes[#codes+1] = alphabet[letters[letter]]\n\
    \                vowelCount = vowelCount + 1\n            end\n        end\n \
    \   end\n    for i=1,#codes do\n        alphabet[codes[i]] = codes[i]\n    end\n\
    \    \n    return table.concat(alphabet)\nend", "  -- We assume that the message\
    \ is all letters. \n  -- The code below swaps all letters and then replaces vowels\
    \ with \n  -- letters that appear in two places ahead of the vowel. \n  local\
    \ messageAsString = tostring(message)", "\t-- We use \"letters\" as a synonym\
    \ for \"characters\" here because \n\t-- it makes the code below easier to understand.\
    \ \n\tlocal letters = {}\n\tfor letter, character in pairs(message) do\n\t\tif\
    \ character == \"a\" then letters.[letter] = letter .. letter \n\t\telse letters.[letter]\
    \ = character \n\t\tend \n\tend \n\t-- We use the following dict to translate\
    \ vowels into other \n\t-- letters. \n\tlocal vowels = {}\n\tvowels.a = \"t\"\n\
    \tvowels.e = \"h\"\n\tvowels.i = \"k\"\n\tvowels.o = \"g\"\n\tvowels.u = \"c\"\
    \n\t-- We use a list to save the result of the substitution in. \n\tlocal result\
    \ = {}\n\tfor letter, character in pairs(letters) do\n\t\t-- We use the following\
    \ logic to determine if a character \n\t\t-- should be replaced with another character.\
    \ \n\t\tif vowels[letter] ~= nil then \n\t\t\t-- In order for the vowel to be\
    \ replaced with a letter, it \n\t\t\t-- must appear 2 places ahead of the vowel.\
    \ \n\t\t\tif letter == vowels[letter] then \n\t\t\t\t-- If the letter is followed\
    \ by a vowel, it is followed \n\t\t\t\t-- by the letter that appears 2 places\
    \ ahead of the vowel. \n\t\t\t\tif letter ~= vowels[letter + 1] then \n\t\t\t\t\
    \tresult[letter] = vowels[letter + 1] \n\t\t\t\telse \n\t\t\t\t\tresult[letter]\
    \ = letter \n\t\t\t\tend \n\t\t\telse \n\t\t\t\t-- If the letter isn't followed\
    \ by a vowel, it is \n\t\t\t\t-- replaced with the letter that appears 2 places\
    \ ahead \n\t\t\t\t-- of the vowel. \n\t\t\t\tresult[letter] = letter \n\t\t\t\
    end \n\t\telse \n\t\t\t-- If the character isn't a vowel, it is simply replaced\
    \ with \n\t\t\t-- a letter. \n\t\t\tresult[letter] = letter \n\t\tend \n\tend\
    \ \n\treturn table.concat(result, \"\") \nend ", "    local table = {\n      \
    \  [\"a\"] = \"e\",\n        [\"b\"] = \"i\",\n        [\"c\"] = \"l\",\n    \
    \    [\"d\"] = \"n\",\n        [\"e\"] = \"o\",\n        [\"f\"] = \"u\",\n  \
    \      [\"g\"] = \"h\",\n        [\"h\"] = \"k\",\n        [\"i\"] = \"l\",\n\
    \        [\"j\"] = \"k\",\n        [\"k\"] = \"j\",\n        [\"l\"] = \"i\",\n\
    \        [\"m\"] = \"a\",\n        [\"n\"] = \"m\",\n        [\"o\"] = \"n\",\n\
    \        [\"p\"] = \"h\",\n        [\"q\"] = \"i\",\n        [\"r\"] = \"a\",\n\
    \        [\"s\"] = \"c\",\n        [\"t\"] = \"e\",\n        [\"u\"] = \"o\",\n\
    \        [\"v\"] = \"a\",\n        [\"w\"] = \"t\",\n        [\"x\"] = \"g\",\n\
    \        [\"y\"] = \"m\",\n        [\"z\"] = \"a\",\n    }\n    local function\
    \ remap(m)\n        local words = string.split(message, \" \")\n        local\
    \ s = \"\"\n        for _, word in ipairs(words) do\n            local result\
    \ = \"\"\n            for letter in string.gsub(word, \"[A-Z]\", function(c)\n\
    \                return table[c]\n            end) do\n                local pos\
    \ = string.find(m, letter)\n                if pos > 0 then\n                \
    \    result = result .. letter\n                    result = result .. table[letter]\n\
    \                    result = result .. string.sub(m, pos)\n                end\n\
    \            end\n            s = s .. result\n        end\n        return s\n\
    \    end\n    return remap(message)\nend", "    local vowels = {'a', 'e', 'i',\
    \ 'o', 'u'}\n    local alphabet = {\n        'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h',\n        'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',\n        'q', 'r', 's',\
    \ 't', 'u', 'v', 'w', 'x', \n        'y', 'z', 'a', 'b', 'c', 'd', 'e', 'f', \n\
    \        'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', \n        'o', 'p', 'q', 'r',\
    \ 's', 't', 'u', 'v', \n        'w', 'x', 'y', 'z'\n    }\n    local counts =\
    \ {}\n    for letter in alphabet:gmatch('([a-z])') do \n        counts[letter]\
    \ = counts[letter] or 1\n    end \n    for letter in message:gmatch('([a-z])')\
    \ do \n        counts[letter] = counts[letter] + 1 \n    end \n    local result\
    \ = {}\n    for letter in alphabet:gmatch('([a-z])') do \n        local count\
    \ = counts[letter] or 0\n        local replacement = alphabet[(count - 2) % 26\
    \ + 1]\n        result[#result + 1] = letter .. replacement\n        counts[letter]\
    \ = count \n    end \n    return table.concat(result)\nend ", "    local alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n    local vowels = { 'a', 'e', 'i', 'o', 'u'\
    \ }", "  local vowels = {\n    ['A'] = 'A', \n    ['E'] = 'E', \n    ['I'] = 'I',\
    \ \n    ['O'] = 'O', \n    ['U'] = 'U', \n    ['Y'] = 'Y', \n  }\n  local newmessage\
    \ = ''\n  for i = 1, #message do\n    local letter = string.sub(message, i, i)\n\
    \    local newletter = string.sub(letter, 1, 1)\n    if letter == 'A' then\n \
    \     newletter = vowels.A\n    elseif letter == 'E' then\n      newletter = vowels.E\n\
    \    elseif letter == 'I' then\n      newletter = vowels.I\n    elseif letter\
    \ == 'O' then\n      newletter = vowels.O\n    elseif letter == 'U' then\n   \
    \   newletter = vowels.U\n    elseif letter == 'Y' then\n      newletter = vowels.Y\n\
    \    end\n    newmessage = newmessage .. newletter\n  end\n  return newmessage\n\
    end", "\t-- We need a way to access all the letters of the alphabet\n\tlocal letters\
    \ = string.gsub(string.gsub(\"abcdefghijklmnopqrstuvwxyz\", \"aeiouAEIOU\", \"\
    ..\"), \"aeiouAEIOU\", \"a..\")\n\t-- We need a way to access a letter of the\
    \ alphabet\n\tlocal letter = string.gsub(\"abcdefghijklmnopqrstuvwxyz\", \"aeiouAEIOU\"\
    , \"..\")\n\t-- This is an invariant: it must be true\n\tassert(string.find(letters,\
    \ \"a..\") ~= nil)\n\t-- We need a function that swaps two letters\n\tlocal function\
    \ swap(l, r)\n\t\tlocal t = letter\n\t\tletter = letter\n\t\tletter = string.gsub(letter,\
    \ \"..\", l)\n\t\tletter = string.gsub(letter, \"..\", r)\n\t\tletter = letter\n\
    \t\tletter = string.gsub(letter, \"a..\", t)\n\tend\n\t-- The letter\n\tlocal\
    \ letter\n\t-- This is the message\n\tlocal message\n\t-- The position of the\
    \ first vowel found\n\tlocal i\n\t-- The position of the second vowel found\n\t\
    local j\n\t-- The letter that will appear in the first position\n\tlocal l\n\t\
    -- The letter that will appear in the second position\n\tlocal r\n\t-- The new\
    \ message\n\tlocal message\n\t-- The letters before the first vowel\n\tlocal before\n\
    \t-- The letters after the first vowel\n\tlocal after\n\t-- The letter that appears\
    \ 2 places ahead of the first vowel\n\tlocal a\n\t-- The letter that appears 2\
    \ places ahead of the second vowel\n\tlocal b\n\t-- Iterate over the message\n\
    \tfor i = 1,#message do\n\t\t-- Check if we find an actual letter\n\t\tif string.find(letters,\
    \ string.sub(message, i, i)) ~= nil then\n\t\t\t-- The letter found\n\t\t\tletter\
    \ = string.sub(message, i, i)\n\t\t\t-- Check if we have found the first vowel\n\
    \t\t\tif letter == \"a\" then\n\t\t\t\t-- This is the first vowel\n\t\t\t\tbefore\
    \ = string.sub(letters, 1, i)\n\t\t\t\t-- We have found the first vowel\n\t\t\t\
    \t-- Iterate over the letters before the first vowel\n\t\t\t\tfor j = 1,#before\
    \ do\n\t\t\t\t\t-- Check if we have found a second vowel\n\t\t\t\t\tif letters[j\
    \ + 1] == \"a\" then\n\t\t\t\t\t\t-- This is the second vowel\n\t\t\t\t\t\tafter\
    \ = string.sub(letters, j + 1, j + i + 1)\n\t\t\t\t\t\t-- We have found a second\
    \ vowel\n\t\t\t\t\t\t-- Swap the letters\n\t\t\t\t\t\tswap(before, after)\n\t\t\
    \t\t\t\t-- We have swapped the letters", "\tlocal alpha = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\tlocal vowels = \"aeiou\"\n\t-- Convert all letters to lowercase\n\tmessage\
    \ = message:gsub(\"%c\", string.lower(%c))\n\t-- Replace all vowels with their\
    \ next letter\n\tmessage = message:gsub(\"[\" .. vowels .. \"]\", function(v)\n\
    \t\t-- Find the index of vowel v in alpha\n\t\tlocal idx = (alpha:find(v) + 1):byte()\n\
    \t\t-- If the letter is in the alphabet, return the alphabet letter\n\t\tif idx\
    \ > #alpha then\n\t\t\treturn alpha:sub((idx - 1):byte() + 1, idx)\n\t\telse\n\
    \t\t\treturn alpha:sub(idx, idx)\n\t\tend\n\tend)\n\t-- Convert to uppercase and\
    \ replace all spaces with 'z'\n\tmessage = message:gsub(\"%S\", function(v)\n\t\
    \tv = string.upper(v)\n\t\treturn string.gsub(v, \" \", \"z\")\n\tend)\n\treturn\
    \ message\nend", "    return message\nend", "    -- Your code here\n    \n   \
    \ -- return the encoded message\n    return message\nend", "  -- Start with the\
    \ first letter.\n  local first_letter = message[1]\n  -- Now we swap letters.\n\
    \  -- For example, if first letter is 'A', then return 'T'\n  -- Otherwise, if\
    \ first letter is 'e', then return 'h'\n  -- Otherwise, if first letter is 'i',\
    \ then return 'k'\n  -- Otherwise, if first letter is 'o', then return 'k'\n \
    \ -- Otherwise, if first letter is 'u', then return 'g'\n  -- Otherwise, if first\
    \ letter is 'a', then return 't'\n  -- Otherwise, if first letter is 'm', then\
    \ return 's'\n  -- Otherwise, if first letter is 'y', then return 'c'\n  -- Otherwise,\
    \ if first letter is 'g', then return 'g'\n  -- Otherwise, if first letter is\
    \ 'f', then return 'f'\n  -- Otherwise, if first letter is 'c', then return 'h'\n\
    \  -- Otherwise, if first letter is 's', then return 's'\n  -- Otherwise, if first\
    \ letter is 's', then return 's'\n  -- Otherwise, if first letter is 'g', then\
    \ return 'g'\n  -- Otherwise, if first letter is 'e', then return 'k'\n  -- Otherwise,\
    \ if first letter is 'l', then return 'l'\n  -- Otherwise, if first letter is\
    \ 'd', then return 'd'\n  -- Otherwise, if first letter is 'a', then return 't'\n\
    \  -- Otherwise, if first letter is 'm', then return 's'\n  -- Otherwise, if first\
    \ letter is 'u', then return 'g'\n  -- Otherwise, if first letter is 'n', then\
    \ return 'n'\n  -- Otherwise, if first letter is 'y', then return 'c'\n  -- Otherwise,\
    \ if first letter is 'y', then return 'c' \n  -- Otherwise, if first letter is\
    \ 's', then return 's'\n  -- Otherwise, if first letter is 'n', then return 'n'\n\
    \  -- Otherwise, if first letter is 'p', then return 'p'\n  -- Otherwise, if first\
    \ letter is 'o', then return 'o'\n  -- Otherwise, if first letter is 'h', then\
    \ return 'h'\n  -- Otherwise, if first letter is 'y', then return 'c'\n  -- Otherwise,\
    \ if first letter is 'g', then return 'g'\n  -- Otherwise, if first letter is\
    \ 'e', then return 'k'\n  -- Otherwise, if first letter is 't', then return 't'\n\
    \  -- Otherwise, if first ", "  local messages = {}\n  local lastLetters = {}\n\
    \  local counts = {}\n  local currentLetter = ''\n  local count = 0\n  for letter\
    \ in message:gmatch(\"([A-Za-z])\")do\n    if currentLetter ~= \"\" then\n   \
    \   table.insert(messages, currentLetter)\n      table.insert(lastLetters, currentLetter)\n\
    \      table.insert(counts, count)\n      count = 0\n    end\n    currentLetter\
    \ = letter\n    count = count + 1\n  end\n  table.insert(messages, currentLetter)\n\
    \  table.insert(lastLetters, currentLetter)\n  table.insert(counts, count)\n \
    \ local message = ''\n  for index, letter in ipairs(messages)do\n    local count\
    \ = 0\n    for index = 1, #lastLetters do\n      if letter == lastLetters[index]\
    \ then\n        count = count + 1\n      end\n    end\n    local newLetter = letter\n\
    \    for index = 1, count - 1 do\n      newLetter = string.char(string.byte(newLetter)+1)\n\
    \    end\n    message = message .. newLetter\n  end\n  return message\nend", " \
    \ local new_message = message\n  local vowels = {'a', 'e', 'i', 'o', 'u'}\n  for\
    \ index, letter in pairs(message) do\n    if letter ~= nil then\n      new_message\
    \ = new_message:gsub('([' .. vowels .. '])(.)' .. letter .. '(.)', '\\1\\3\\2')\n\
    \      new_message = new_message:gsub('(.)(.)(.)' .. letter .. '(.)(.)(.)', '\\\
    4\\1\\2\\3')\n    end\n  end\n  return new_message\nend", "    local vowels =\
    \ { 'a', 'e', 'i', 'o', 'u', 'y' }\n    local alphabet = 'bcdfghjklmnpqrstvwxyz'\n\
    \    local alphabet2 = 'klmnopqrstuvwxyz'\n    local newMessage = ''\n    local\
    \ letters = {}\n    for i = 0, #message do\n        local character = message[i]\n\
    \        -- Find first vowel position\n        local vowelIdx = (#vowels - 1)\
    \ - (#vowels + #alphabet) - 1\n        for j = 0, #vowels do\n            if alphabet:sub(vowelIdx\
    \ + j, 1) ~= character then\n                vowelIdx = j\n            end\n \
    \       end\n        -- Find second vowel position\n        for j = 1, #vowels\
    \ do\n            if alphabet2:sub(vowelIdx + j, 1) ~= character then\n      \
    \          vowelIdx = j\n            end\n        end\n        -- Replace the\
    \ vowel with its letter\n        local letter = alphabet:sub(vowelIdx + #alphabet,\
    \ #alphabet)\n        newMessage = newMessage .. letter\n        -- Find second\
    \ vowel position\n        for j = 0, #vowels do\n            if alphabet:sub(vowelIdx\
    \ + j, 1) ~= character then\n                vowelIdx = j\n            end\n \
    \       end\n        -- Replace the vowel with its letter\n        local letter\
    \ = alphabet2:sub(vowelIdx + #alphabet, #alphabet)\n        newMessage = newMessage\
    \ .. letter\n        -- Find next vowel position\n        for j = #vowels, #vowels\
    \ do\n            if alphabet:sub(vowelIdx + j, 1) ~= character then\n       \
    \         vowelIdx = j\n            end\n        end\n        -- Replace the vowel\
    \ with its letter\n        local letter = alphabet:sub(vowelIdx + #alphabet, #alphabet)\n\
    \        newMessage = newMessage .. letter\n        -- Find next vowel position\n\
    \        for j = #vowels, #vowels do\n            if alphabet2:sub(vowelIdx +\
    \ j, 1) ~= character then\n                vowelIdx = j\n            end\n   \
    \     end\n        -- Replace the vowel with its letter\n        local letter\
    \ = alphabet2:sub(vowelIdx + #alphabet, #alphabet)\n        newMessage = newMessage\
    \ .. letter\n        -- Find next vowel position\n        for j = #vowels, #vowels\
    \ do\n            if alphabet:sub(vowelIdx + j, 1) ~= character then\n       \
    \         vowelIdx = j\n            end\n        end\n        -- Replace the vowel\
    \ with its letter\n        local letter = alphabet:sub(vowelIdx + #alphabet, #alphabet)\n\
    \        newMessage = newMessage .. letter\n    end\n    return newMessage\nend",
  "    local message = '' .. message\n    -- convert all letters to lowercase\n  \
    \  message = message:lower()\n    -- Replace all vowels in the message with the\
    \ letter that appears 2 places ahead of that vowel in the english alphabet\n \
    \   message = message:gsub('[a\xE1]', '[ae]')\n    message = message:gsub('[\xC1\
    ]', '[Ae]')\n    message = message:gsub('[\xC9]', '[Ee]')\n    message = message:gsub('[\xCD\
    ]', '[Ie]')\n    message = message:gsub('[\xD3]', '[Oe]')\n    message = message:gsub('[\xDA\
    ]', '[Ue]')\n    message = message:gsub('[\xD1]', '[N]')\n    message = message:gsub('[\xF1\
    ]', '[n]')\n    message = message:gsub('[\xE9]', '[e]')\n    message = message:gsub('[\xF3\
    ]', '[o]')\n    message = message:gsub('[\xFA]', '[u]')\n    message = message:gsub('[\xED\
    ]', '[i]')\n    message = message:gsub('[\xFA]', '[u]')\n    message = message:gsub('[\xF1\
    ]', '[n]')\n    message = message:gsub('[\xF1]', '[n]')\n    -- Now swap case\
    \ for all letters \n    message = message:gsub('[A-Za-z]', function(letter)\n\
    \        return toupper(letter):sub(1, 2)\n    end)\n    -- Finally add the space\
    \ between letters\n    message = message:gsub('([A-Za-z])', function(letter)\n\
    \        return letter:sub(2, 2) .. ' '\n    end)\n    return message\nend", " \
    \ -- Your code here\n  local alphabet = {}\n  for letter in string.gmatch(message,\
    \ '%a') do\n    alphabet[letter] = letter\n  end\n  local vowels = string.gmatch(message,\
    \ '[aeiou]')\n  for i = 1, #vowels do\n    local v = vowels[i]\n    local letter\
    \ = alphabet[v]\n    local n = 1\n    for j = 1, #message do\n      if message[j]\
    \ == v then\n        letter = alphabet[letter:sub(1, letter:len() - 1)] + alphabet[j\
    \ + 1]\n        n = 2\n      end\n    end\n    message = string.gsub(message,\
    \ '^%s*', letter)\n    message = string.gsub(message, '%s*$', letter)\n  end\n\
    \  return message\nend", "    message = message:gsub('(.)', function(letter)\n\
    \        letter = string.upper(letter)\n        local vowels = {'a', 'e', 'i',\
    \ 'o', 'u'}\n        return vowels[string.find(letter, vowels) + 1]\n    end)\n\
    \    local vowels = {'a', 'e', 'i', 'o', 'u'}\n    local alphabet = {string.char(97\
    \ + 1), string.char(65 + 1), string.char(97 + 2), string.char(65 + 2), string.char(97\
    \ + 3), string.char(65 + 3)}\n    local output = ''\n    for i = 1, #message do\n\
    \        local index = string.find(message, alphabet[i])\n        local firstLetter\
    \ = alphabet[i]\n        local secondLetter = alphabet[(index + 1) % #alphabet]\n\
    \        local letter = string.sub(message, i, i)\n        local isVowel = string.find(letter,\
    \ vowels) ~= nil\n        if index == nil then\n            output = output ..\
    \ firstLetter .. letter .. secondLetter\n        elseif isVowel then\n       \
    \     output = output .. firstLetter .. secondLetter\n        else\n         \
    \   output = output .. firstLetter .. letter .. secondLetter\n        end\n  \
    \  end\n    return output\nend", "    local newString = ''\n    for i = 1, #message\
    \ do\n        local letter = string.lower(message[i])\n        local vowels =\
    \ letter:match('[aeiou]') or 'a'\n        local vowel = string.sub(letter, 1,\
    \ 1) .. string.sub(letter, 2)\n        newString = newString .. string.sub(vowels,\
    \ #vowels-1, #vowels-1) .. vowel\n    end\n    return newString\nend", "  local\
    \ newMessage = string.gsub(message, \"([a-z])\", function(l) \n    local match\
    \  = string.lower(l)\n    local vowels = match..'a' .. match..'e' .. match..'i'..match..'o'..match..'u'\n\
    \    local index1 = string.find(vowels, match)\n    local index2 = index1 + 2\n\
    \    return string.sub(vowels, index2, index1)\n  end) \n  return newMessage\n\
    end", "    local output = ''\n    for i=1,#message do\n        local letter =\
    \ string.lower(message[i])\n        if letter ~= 'a' and letter ~= 'e' and letter\
    \ ~= 'i' and letter ~= 'o' and letter ~= 'u' then\n            local index = math.floor(letter\
    \ - 'a') + 1\n            local letterIndex = math.floor((letter - 'a') - index/2)\n\
    \            local vowel = string.sub(letterIndex, 1, 2)\n            local nextVowel\
    \ = string.sub(letterIndex, 2)\n            local replacement = string.sub(index,\
    \ 1, index + 1)\n            output = output .. string.char(letter, replacement,\
    \ vowel, nextVowel)\n        end\n    end\n    return output\nend", "  local vowels\
    \ = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n  local alphabet = {'a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n  local alphabetVowels = {}\n\
    \  for i=1,#vowels do\n    alphabetVowels[alphabet[vowels[i]]] = alphabet[vowels[i]]\n\
    \  end\n  local function encode(message)\n    local index = 1\n    local messageUpper\
    \ = message:upper()\n    local messageUpper = string.gsub(messageUpper, '[aeiou]',\
    \ function(letter)\n      local index = alphabetVowels[letter]\n      return alphabet[index]\n\
    \    end)\n    return messageUpper\n  end\n  local function decode(message)\n\
    \    local index = 1\n    local messageUpper = message:upper()\n    local messageUpper\
    \ = string.gsub(messageUpper, '[aeiou]', function(letter)\n      local index =\
    \ alphabetVowels[letter]\n      return alphabet[index]\n    end)\n    return messageUpper\n\
    \  end\n  return decode(encode(message))\nend", "    local alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    local vowels = \"aeiouAEIOU\"\n    local message = message:gsub(\"[\" ..\
    \ vowels .. \"]\", function(letter)\n        local offset = alphabet.find(letter)\n\
    \        return alphabet:sub(offset, offset + 1)\n    end)\n    message = message:gsub(\"\
    [\" .. vowels .. alphabet:sub(-1) + \"]\", function(letter)\n        local offset\
    \ = alphabet.find(letter)\n        return alphabet:sub(offset, offset + 2)\n \
    \   end)\n    return message\nend", "\tlocal alphabet = \n\t\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n\t\t\"abcdefghijklmnopqrstuvwxyz\"\n\t\t\"!@#$%^&*()[]{};:,./<>?\"\n\tlocal\
    \ swap = \"\"\n\tfor i, v in pairs(alphabet) do\n\t\tswap = swap .. v\n\tend\n\
    \tlocal vowel = alphabet:sub(1, 1)\n\tlocal consonant = alphabet:sub(2, 1)\n\t\
    local count = \n\t\tstring.sub(message, vowel, 1, 1) .. \n\t\tstring.sub(message,\
    \ consonant, 1, 1) .. \n\t\tstring.sub(message, consonant, 2, 1)\n\tlocal encodedMessage\
    \ = \"\"\n\tfor i = 1, message:len() - 1, 1 do\n\t\tlocal encoded = alphabet:sub(count,\
    \ i)\n\t\tcount = count + 1\n\t\tencoded = swap .. encoded\n\t\tencodedMessage\
    \ = encodedMessage .. encoded\n\tend\n\treturn encodedMessage\nend", "    local\
    \ words = string.gsub(message, \"[^ ]+\", \"%w\") -- Split message by spaces \n\
    \    local buffer = {}\n    for i=1, #words do\n        local letter = string.sub(words,\
    \ i, i)\n        local vowel = string.sub(words, i - 1, 1)\n        local newLetter\
    \ = letter\n        local newVowel = vowel\n        if letter == \"A\" and vowel\
    \ == \"E\" then newLetter = \"a\" end\n        if letter == \"A\" and vowel ==\
    \ \"I\" then newLetter = \"i\" end\n        if letter == \"A\" and vowel == \"\
    O\" then newLetter = \"o\" end\n        if letter == \"A\" and vowel == \"U\"\
    \ then newLetter = \"u\" end\n        if letter == \"E\" and vowel == \"I\" then\
    \ newLetter = \"e\" end\n        if letter == \"E\" and vowel == \"O\" then newLetter\
    \ = \"o\" end\n        if letter == \"E\" and vowel == \"U\" then newLetter =\
    \ \"u\" end\n        if letter == \"I\" and vowel == \"U\" then newLetter = \"\
    i\" end\n        if letter == \"O\" and vowel == \"U\" then newLetter = \"o\"\
    \ end\n        if letter == \"U\" and vowel == \"I\" then newLetter = \"u\" end\n\
    \        if letter == \"Y\" and vowel == \"I\" then newLetter = \"y\" end\n  \
    \      table.insert(buffer, newLetter)\n    end\n    return table.concat(buffer,\
    \ '') -- Reassemble word for string concat \nend", "    local messageList = string.gmatch(message,\
    \ \"[^a-zA-Z]\") -- Strip out all non-letters.\n    local decoded = \"\" -- Start\
    \ out with an empty string.\n    local letterCount = {} -- Start off with an empty\
    \ table of letter counts.\n    -- Go through every letter in our message and see\
    \ how many times it occurs in the message.\n    for i = 1, #messageList do\n \
    \       local letter = string.sub(messageList, i, i) -- Get the current letter.\n\
    \        -- Increment the count of letters that occur the current letter.\n  \
    \      letterCount[letter] = letterCount[letter] + 1 or 1\n        -- Go through\
    \ every letter in the english alphabet and count how often it occurs.\n      \
    \  for j = 0, 26 do\n            local letter2 = string.sub(alphabet, j, j) --\
    \ Get the current letter 2 places ahead.\n            if letter == letter2 then\n\
    \                -- If the letters are the same as the current letter, add one\
    \ to the letter count.\n                letterCount[letter] = letterCount[letter]\
    \ + 1\n            else\n                -- Otherwise check to see if we are past\
    \ a vowel (a, e, i, o, u).\n                if letter2 == \"a\" or letter2 ==\
    \ \"e\" or letter2 == \"i\" or letter2 == \"o\" or letter2 == \"u\" then\n   \
    \                 -- If the letter we're checking is after a vowel in the english\
    \ alphabet, add a \"u\" to the letter count.\n                    letterCount[letter]\
    \ = letterCount[letter] + 2\n                end\n            end\n        end\n\
    \    end\n    -- Now that we have all of the letter counts, go through each letter\
    \ count in our table of letter counts,\n    -- adding letters to the decoded string\
    \ according to the letter count in our table.\n    for letter, count in pairs(letterCount)\
    \ do\n        -- If the count is bigger than 1, then add that letter to our decoded\
    \ string.\n        if count > 1 then\n            decoded = decoded .. letter\n\
    \        end\n    end\n    -- Return the decoded string.\n    return decoded\n\
    end", "  -- Only letters.\n  assert(type(message) == 'string')\n  assert(string.sub(message,\
    \ 1, 1) == 'a')\n  assert(string.sub(message, 2, 1) == 'A')", "  -- Write your\
    \ code here\nend", "    local new_message = message\n    for i, letter in ipairs(message:gsub(\"\
    (.)\", function(c) \n        return string.upper(c:sub(1,1)) + c:sub(2)\n    end))\
    \ do\n        -- Check if the current letter being looked at is a vowel. \n  \
    \      if letter:sub(1,1) ~= 'A' and letter:sub(1,1) ~= 'E' and letter:sub(1,1)\
    \ ~= 'I'\n            and letter:sub(1,1) ~= 'O' and letter:sub(1,1) ~= 'U' then\n\
    \            -- Swap case of the letter, except for E in MUSICAL LETTERS. \n \
    \           if letter:sub(1,1) == 'E' then\n                new_message = new_message:gsub(\"\
    [\"..i..\"]\", function(c) \n                    return string.lower(c:sub(1,1))\
    \ + c:sub(2)\n                end)\n            -- Swap letters if current letter\
    \ is in MUSICAL LETTERS. \n            else new_message = new_message:gsub(\"\
    [\"..i..\"]\", function(c) \n                return string.upper(c:sub(1,1)) +\
    \ c:sub(2)\n            end)\n        end\n    end\n    -- Remove any trailing\
    \ vowels. \n    new_message = new_message:gsub(\"[^AEIOU]$\", \"\")\n    return\
    \ new_message\nend", "   local messageArray = string.gsub(message, '[^A-Za-z]',\
    \ '')\n   local chars = {}\n   for i = 0, #messageArray-1 do \n      local char\
    \ = string.sub(messageArray,i,i)\n      if string.find(string.chars(char), vowels)\
    \ then\n         local place = string.find(string.chars(char), vowels)\n     \
    \    if place > 1 then\n            place = place - 1\n         end\n        \
    \ if place > 0 then\n            table.insert(chars, string.chars(string.sub(string.chars(char),\
    \ 1, place)))\n            table.insert(chars, string.chars(string.sub(string.chars(char),\
    \ place)))\n         else\n            table.insert(chars, string.chars(char))\n\
    \         end\n      end\n   end\n   return table.concat(chars, ' ')\nend", " \
    \   local alphabet = {\n        [string.lower(string.lower(string.lower(message)))]\
    \ = \n            string.upper(string.upper(string.upper(message)))\n    }", " \
    \ local messageChars = string.gsub(message, \"[^A-Za-z]\", \"\")\n  local output\n\
    \  local i = 0\n  \n  for i = 1, #messageChars do\n    local outputChar = string.sub(\"\
    a\", i, i)\n    \n    -- swap the case of all letters except a\n    if messageChars[i]\
    \ ~= 'a' then\n      outputChar = string.upper(outputChar)\n    end\n    \n  \
    \  -- replace all vowels in message\n    -- with the letter that appears 2 places\
    \ ahead of that vowel in the english alphabet\n    -- i've taken the letter to\
    \ the left of the vowel\n    -- and added it to the letter to the right of the\
    \ vowel to get the letter to place ahead of the vowel\n    -- i've used the %\
    \ operator on strings to get the letter that appears 2 places ahead of a\n   \
    \ -- and % on strings to get the letter that appears 2 places ahead of another\
    \ letter\n    \n    -- i've also used the string.sub function on the english alphabet\
    \ to get a letter at a certain index\n    -- and string.upper to uppercase the\
    \ letter\n    \n    -- string.sub\n    -- string.upper\n    \n    local aLetter\
    \ = string.sub(string.lower(string.letters), i, i + 1)\n    local bLetter = string.sub(string.letters,\
    \ i + 1, 1)\n    \n    -- i've used the string.sub function on the english alphabet\
    \ to get a letter at a certain index\n    -- and string.upper to uppercase the\
    \ letter\n    \n    -- string.sub\n    -- string.upper\n    \n    local vowels\
    \ = \"aeiouAEIOU\"\n    \n    if vowels:find(aLetter) then\n      outputChar =\
    \ string.sub(vowels, string.find(vowels, aLetter) + 2, string.find(vowels, bLetter)\
    \ + 2)\n    end\n    \n    -- i've used the string.sub function on the english\
    \ alphabet to get a letter at a certain index\n    -- and string.upper to uppercase\
    \ the letter\n    \n    -- string.sub\n    -- string.upper\n    \n    output =\
    \ output .. outputChar\n    \n    -- i've used the string.sub function on the\
    \ english alphabet to get a letter at a certain index\n    -- and string.upper\
    \ to uppercase the letter\n    \n    -- string.sub\n    -- string.upper\n  end\n\
    \  \n  return output\nend", "  -- Create a string with all letters in lowercase.\n\
    \  local alphabet = string.gsub(string.gsub(\"abcdefghijklmnopqrstuvwxyz\", \"\
    a\", \"A\"), \"b\", \"B\")\n  -- Replace all vowels in the message with the letter\n\
    \  -- 2 places ahead of the vowel.\n  -- \n  -- The function string.find returns\
    \ the index of the letter\n  -- in the alphabet (1 indexed).\n  -- \n  -- The\
    \ function string.sub removes 2 letters from the \n  -- string with the index\
    \ of the letter found by the function \n  -- 'string.find'.\n  -- \n  -- The function\
    \ string.gsub replaces all vowels in the message \n  -- with the letter 2 places\
    \ ahead of the vowel.\n  -- \n  -- string.gsub replaces vowels with the letter\
    \ 2 places ahead\n  -- of the vowel with the substitution 'alphabet'.\n  return\
    \ string.gsub(message, \"([aeiou])\", alphabet, string.sub(message, string.find(message,\
    \ \"([aeiou])\", 1) + 1, string.find(message, \"([aeiou])\", string.find(message,\
    \ \"([aeiou])\", 1) + 1) + 2)\nend", "  local vowels = {'a', 'e', 'i', 'o', 'u'}\n\
    \  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local vowel_index = alphabet:sub(1,\
    \ 1):upper() .. alphabet:sub(2, 2):upper() .. alphabet:sub(3, 3):upper()\n  local\
    \ new_message = {}\n  for i = 1, #message do\n    local letter_found = false\n\
    \    local letter = message[i]\n    for j = 1, #vowels do\n      local current_letter\
    \ = vowels[j]\n      if letter ~= current_letter then\n        letter_found =\
    \ true\n        -- Find index of vowel in alphabet\n        local index = alphabet:find(current_letter,\
    \ i - 1, true)\n        -- Swap the letter if the index is more than 2\n     \
    \   if index ~= nil then\n          new_message[i] = alphabet:sub(i, i + 1, alphabet:sub(index\
    \ - 1, index + 1, alphabet:sub(i - 1, i, alphabet:sub(i + 1))))\n        end\n\
    \      end\n    end\n    -- If no vowels match then add letter to new message\n\
    \    if not letter_found then\n      new_message[i] = letter\n    end\n  end\n\
    \  return table.concat(new_message, \"\")\nend", "    local msg = {}\n    for\
    \ i=1, #message do\n        local char = message[i]\n        if char ~= nil then\n\
    \            local letter = string.lower(char)\n            for j=1, #VOWELS do\n\
    \                if VOWELS[j] == letter then\n                    local index\
    \ = j - 1\n                    table.insert(msg, VOWELS[index])\n            \
    \        table.insert(msg, letter)\n                    table.insert(msg, VOWELS[index+1])\n\
    \                    table.insert(msg, VOWELS[index+2])\n                end\n\
    \            end\n        end\n    end\n    return table.concat(msg)\nend", " \
    \ -- TODO: Replace this function with your own.\n  local function replace_vowel(vowel)\n\
    \    -- TODO: Replace this function with your own.\n    local position = 2\n \
    \   while position do\n      if message:sub(1, position) ~= vowel then\n     \
    \   message = message:sub(1, position-1)\n      else\n        local new_vowel\
    \ = message:sub(1, position-1)\n        local new_letter = english_alphabet:sub(1,\
    \ position-1)\n        message = message:sub(1, position-1)\n        message =\
    \ message:gsub(new_vowel, new_letter)\n        break\n      end\n      position\
    \ = position + 2\n    end\n    return message\n  end\n  local message = message:gsub('a',\
    \ 'A')\n  message = message:gsub('e', 'E')\n  message = message:gsub('i', 'I')\n\
    \  message = message:gsub('o', 'O')\n  message = message:gsub('u', 'U')\n  message\
    \ = message:gsub('y', 'Y')\n  message = message:gsub('\xE6', 'ae')\n  message\
    \ = message:gsub('\xF8', 'o')\n  message = message:gsub('\xE5', 'a')\n  message\
    \ = message:gsub('\xC6', 'AE')\n  message = message:gsub('\xD8', 'O')\n  message\
    \ = message:gsub('\xC5', 'A')\n  message = message:gsub('\xC5', 'A')\n  message\
    \ = message:gsub('\xE4', 'ae')\n  message = message:gsub('\xF6', 'o')\n  message\
    \ = message:gsub('\xE5', 'a')\n  message = message:gsub('\xC5', 'A')\n  message\
    \ = message:gsub('\xC5', 'A')\n  message = message:gsub('\xC4', 'A')\n  message\
    \ = message:gsub('\xC5', 'A')\n  message = message:gsub('\xC4', 'A')\n  message\
    \ = message:gsub('\xC4', 'A')\n  message = message:gsub('\xE4', 'ae')\n  message\
    \ = message:gsub('\xF6', 'o')\n  message = message:gsub('\xE5', 'a')\n  message\
    \ = message:gsub('\xC5', 'A')\n  message = message:gsub('\xC5', 'A')\n  message\
    \ = message:gsub('\xC4', 'A')\n  message = message:gsub('\xC4', 'A')\n  message\
    \ = message:gsub('\xC4', 'A')\n  message = message:gsub('\xC4', 'A')\n  message\
    \ = message:gsub('\xE4', 'ae')\n  message = message:gsub('\xF6', 'o')\n  message\
    \ = message:gsub('\xE5', 'a')\n  message = message:gsub('\xC5', 'A')\n  message\
    \ = message:gsub('\uFFFD", "  -- Initialize result to empty string\n  local result\
    \ = \"\"\n  -- Initialize vowel count as 0\n  local vowelCount = 0\n  -- Iterate\
    \ through all letters in message\n  for letter in message:gmatch(\"%a\") do\n\
    \    -- Determine if a letter is a vowel\n    if vowelToSwap[letter] then\n  \
    \    -- Determine if vowel appears two places ahead\n      if message:sub(1, vowelCount)\
    \ == vowelToSwap[letter] then\n        -- Swap case for letter\n        letter\
    \ = letter:lower()\n      else\n        -- Swap case for vowel\n        letter\
    \ = vowelToSwap[letter]\n      end\n    end\n    -- Append letter to result\n\
    \    table.insert(result, letter)\n    -- Increment vowel count\n    vowelCount\
    \ = vowelCount + 1\n  end\n  return result\nend", "    local result = ''", " \
    \   local new_message = message\n    local vowels = { 'a', 'e', 'i', 'o', 'u',\
    \ 'y' } \n    local new_message = message:gsub('a', 'z'):gsub('e', 'w'):gsub('i',\
    \ 'x'):gsub('o', 'v'):gsub('u', 's'):gsub('y', 'x')\n    local vowel_map = {}\n\
    \    local new_message = \"\"\n    for i, letter in pairs(new_message) do\n  \
    \      vowel_map[letter] = vowels[i+1]\n    end\n    for i, letter in pairs(message)\
    \ do\n        if letter in vowels then\n            new_message = new_message\
    \ .. vowel_map[letter]\n        elseif letter in vowel_map then\n            new_message\
    \ = new_message .. letter\n        end\n    end\n    return new_message\nend",
  "    local encoded = message\n    local vowels = \"aeiouy\"\n    for i, v in ipairs(vowels)\
    \ do\n        encoded = string.gsub(encoded, v, tostring(i + 2))\n    end\n  \
    \  return encoded\nend", "    local alphabet = {'a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', \n    'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', \n    'y', 'z'}\n    local function swapCase(message)\n\
    \        for i = 1, #message do\n            local character = message[i]\n  \
    \          if character ~= nil then\n                local index = alphabet.index(character)\n\
    \                message[i] = alphabet[(index + 1) % #alphabet]\n            end\n\
    \        end\n        return message\n    end\n    local function vowelIndex(character)\n\
    \        local index = alphabet.index(character)\n        if character == 'a'\
    \ or character == 'e' or character == 'i' or character == 'o' or character ==\
    \ 'u' then\n            return alphabet[(index - 1) % #alphabet]\n        elseif\
    \ character == 'e' or character == 'i' or character == 'o' or character == 'u'\
    \ then\n            return (index - 1) % #alphabet\n        elseif character ==\
    \ 'y' then\n            return index\n        else\n            return nil\n \
    \       end\n    end\n    local function replaceVowels(message)\n        for i\
    \ = 1, #message do\n            local character = message[i]\n            if character\
    \ ~= nil then\n                local index = vowelIndex(character)\n         \
    \       if index == nil then\n                    index = #alphabet\n        \
    \        end\n                local nextIndex = index + 1\n                local\
    \ newCharacter = alphabet[(nextIndex - 1) % #alphabet]\n                message[i]\
    \ = newCharacter\n            end\n        end\n        return message\n    end\n\
    \    return replaceVowels(swapCase(message))\nend", "  local newMessage = \"\"\
    \ \n  for letter in message:gmatch(\"%a+\") do\n    local letterIndex = englishAlphabet:find(letter)\
    \ \n    newMessage = newMessage .. englishAlphabet[letterIndex + 1] \n  end\n\
    \  return newMessage\nend", "  -- Write your code here\n  -- return message\n\
    \  return \nend", "    local vowels = 'AEIOUYaeiouy'\n    local t = {}\n    for\
    \ i=1,#message do\n        local letter = message:sub(i,i)\n        local nextLetter\
    \ = message:sub(i+1,i+1)\n        -- swap case\n        for j=1,#vowels do\n \
    \           local c = letter:sub(1,1)\n            letter = letter:sub(2,2)\n\
    \            letter = letter:sub(1,1)\n            letter = vowels:sub(1,1)\n\
    \            letter = letter:sub(2,2)\n            letter = letter:sub(1,1)\n\
    \            letter = vowels:sub(1,1)\n            letter = letter:sub(2,2)\n\
    \            letter = letter:sub(1,1)\n            letter = vowels:sub(1,1)\n\
    \            letter = letter:sub(2,2)\n            letter = letter:sub(1,1)\n\
    \            letter = vowels:sub(1,1)\n            letter = letter:sub(2,2)\n\
    \            letter = letter:sub(1,1)\n            letter = vowels:sub(1,1)\n\
    \            letter = letter:sub(2,2)\n            letter = letter:sub(1,1)\n\
    \            letter = vowels:sub(1,1)\n            letter = letter:sub(2,2)\n\
    \            letter = letter:sub(1,1)\n            letter = vowels:sub(1,1)\n\
    \            letter = letter:sub(2,2)\n            letter = letter:sub(1,1)\n\
    \        end\n        -- swap next letter\n        letter = letter:sub(2,2)\n\
    \        letter = letter:sub(1,1)\n        letter = vowels:sub(1,1)\n        letter\
    \ = letter:sub(2,2)\n        letter = letter:sub(1,1)\n        letter = vowels:sub(1,1)\n\
    \        letter = letter:sub(2,2)\n        letter = letter:sub(1,1)\n        letter\
    \ = vowels:sub(1,1)\n        letter = letter:sub(2,2)\n        letter = letter:sub(1,1)\n\
    \        letter = vowels:sub(1,1)\n        letter = letter:sub(2,2)\n        letter\
    \ = letter:sub(1,1)\n        letter = vowels:sub(1,1)\n        letter = letter:sub(2,2)\n\
    \        letter = letter:sub(1,1)\n        letter = vowels:sub(1,1)\n        letter\
    \ = letter:sub(2,2)\n        letter = letter:sub(1,1)\n        letter = vowels:sub(1,1)\n\
    \        letter = letter:sub(2,2)\n        letter = letter:sub(1,1)\n        letter\
    \ = vowels:sub(1,1)\n        letter = letter:sub(2,2)\n        letter = letter",
  "    local vowels = { \"a\", \"e\", \"i\", \"o\", \"u\" }\n    local alphabet =\
    \ { \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\" }\n   \
    \ local result = \"\"\n    \n    for i = 1, #message do\n        local current\
    \ = message[i]\n        local next\n        \n        if current:lower() == current:lower()\
    \ then\n            next = alphabet[#alphabet]\n        else\n            next\
    \ = alphabet[#alphabet+1]\n        end\n        \n        for _, v in ipairs(vowels)\
    \ do\n            if current:find(v) then\n                current = current:sub(v:len()\
    \ -1 , v:len() - 1)\n                next = next:sub(v:len() -1 , v:len() - 1)\n\
    \            end\n        end\n        \n        result = result .. next\n   \
    \ end\n    \n    return result\nend", "  local messageWords = split(message, \"\
    \ \")\n  local lastLetter = nil\n  local newMessage = \"\"\n  for i = 1, #messageWords\
    \ do\n    if messageWords[i] ~= \"\" then\n      local currentLetter = messageWords[i]\n\
    \      if lastLetter ~= nil then\n        if currentLetter == \"a\" or currentLetter\
    \ == \"e\" or currentLetter == \"i\" or currentLetter == \"o\" or currentLetter\
    \ == \"u\" then\n          newMessage = newMessage .. lastLetter\n          newMessage\
    \ = newMessage .. currentLetter\n        elseif currentLetter == \"e\" then\n\
    \          newMessage = newMessage .. lastLetter\n          newMessage = newMessage\
    \ .. \"b\"\n        elseif currentLetter == \"i\" then\n          newMessage =\
    \ newMessage .. lastLetter\n          newMessage = newMessage .. \"g\"\n     \
    \   elseif currentLetter == \"o\" then\n          newMessage = newMessage .. lastLetter\n\
    \          newMessage = newMessage .. \"h\"\n        elseif currentLetter == \"\
    u\" then\n          newMessage = newMessage .. lastLetter\n          newMessage\
    \ = newMessage .. \"k\"\n        elseif currentLetter == \"a\" then\n        \
    \  newMessage = newMessage .. lastLetter\n          newMessage = newMessage ..\
    \ \"b\"\n        elseif currentLetter == \"e\" then\n          newMessage = newMessage\
    \ .. lastLetter\n          newMessage = newMessage .. \"g\"\n        elseif currentLetter\
    \ == \"i\" then\n          newMessage = newMessage .. lastLetter\n          newMessage\
    \ = newMessage .. \"h\"\n        elseif currentLetter == \"o\" then\n        \
    \  newMessage = newMessage .. lastLetter\n          newMessage = newMessage ..\
    \ \"k\"\n        elseif currentLetter == \"u\" then\n          newMessage = newMessage\
    \ .. lastLetter\n          newMessage = newMessage .. \"j\"\n        elseif currentLetter\
    \ == \"a\" then\n          newMessage = newMessage .. lastLetter\n          newMessage\
    \ = newMessage .. \"b\"\n        elseif currentLetter == \"e\" then\n        \
    \  newMessage = newMessage .. lastLetter\n          newMessage = newMessage ..\
    \ \"g\"\n        elseif currentLetter == \"i\" then\n          newMessage = newMessage\
    \ .. lastLetter\n          newMessage = newMessage .. \"h\"\n        elseif currentLetter\
    \ == \"o\" then\n          newMessage = newMessage .. lastLetter\n          newMessage\
    \ = newMessage .. \"k\"\n        elseif currentLetter == \"u\" then\n        \
    \  newMessage = newMessage .. lastLetter\n          newMessage = newMessage ..\
    \ \"j\"\n        else\n          newMessage = newMessage .. lastLetter\n     \
    \     newMessage = newMessage .. currentLetter\n        end\n      else", "  \
    \  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    local vowels = 'aeiou'\n\
    \    local capitals = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    local vowelCounts = {}\n\
    \    for letter in string.gmatch(message, '%a') do\n        if letter:sub(1, 1)\
    \ in vowels then\n            local firstLetter = letter:sub(1, 1)\n         \
    \   if firstLetter:sub(2, 2) in vowelCounts then\n                vowelCounts[firstLetter:sub(2,\
    \ 2)] = vowelCounts[firstLetter:sub(2, 2)] + 1\n            else\n           \
    \     vowelCounts[firstLetter] = 1\n            end\n        end\n    end\n  \
    \  local capitalCounts = {}\n    for letter in string.gmatch(message, '%A') do\n\
    \        if letter:sub(1, 1) in capitals then\n            local firstLetter =\
    \ letter:sub(1, 1)\n            if firstLetter:sub(2, 2) in capitalCounts then\n\
    \                capitalCounts[firstLetter:sub(2, 2)] = capitalCounts[firstLetter:sub(2,\
    \ 2)] + 1\n            else\n                capitalCounts[firstLetter] = 1\n\
    \            end\n        end\n    end\n    local output = ''\n    for letter\
    \ in string.gmatch(message, '%a') do\n        local firstLetter = letter:sub(1,\
    \ 1)\n        local letterCount = vowelCounts[firstLetter]\n        if letterCount\
    \ ~= nil then\n            local secondLetter = alphabet[string.byte(firstLetter,2)+1]\n\
    \            local letterCount = letterCount\n            for i = 1, letterCount\
    \ do\n                secondLetter = alphabet[string.byte(secondLetter,2)+1]\n\
    \            end\n            letter = secondLetter\n        end\n        if letter:sub(2,\
    \ 2) in vowelCounts then\n            local secondLetter = alphabet[string.byte(letter:sub(2,\
    \ 2),2)+1]\n            local letterCount = vowelCounts[letter:sub(2, 2)]\n  \
    \          for i = 1, letterCount do\n                secondLetter = alphabet[string.byte(secondLetter,2)+1]\n\
    \            end\n            letter = secondLetter\n        end\n        if letter:sub(1,\
    \ 1) in capitalCounts then\n            local secondLetter = alphabet[string.byte(letter:sub(1,\
    \ 1),2)+1]\n            local letterCount = capitalCounts[letter:sub(1, 1)]\n\
    \            for i = 1, letterCount do\n                secondLetter = alphabet[string.byte(secondLetter,2)+1]\n\
    \            end\n            letter = secondLetter\n        end\n        output\
    \ = output .. letter\n    end\n    return output\nend", "\t-- Write your solution\
    \ here\n\treturn message\nend", "  -- encode function takes in a message and swaps\
    \ case of letters, \n  -- replaces vowels with their letter 2 places ahead of\
    \ it. \n  -- Assume letters and only letters. \n  -- Return the encoded message.\n\
    \  -- TODO: Write your code here\n  local vowels = \"AEIOU\"\n  -- Find index\
    \ of vowel\n  local vowel_index = string.rep(\"AEIOU\", 1, #vowels)\n  -- Find\
    \ the letter that appears 2 places ahead of vowel\n  local vowel_letter = string.rep(vowels,\
    \ 1, #vowels + 1)[vowel_index + 1]\n  -- Swap the case\n  local encoded_message\
    \ = string.reverse(message)\n  -- Replace vowels\n  encoded_message = string.rep(encoded_message,\
    \ 1, #encoded_message) \n  -- Replace the letter\n  for i = 1, #encoded_message\
    \ do\n    encoded_message[i] = string.char(string.sub(encoded_message, i, i) \n\
    \                                   == vowel_letter \n                       \
    \            and vowel_letter \n                                   or string.sub(encoded_message,\
    \ i, i)\n                                   )\n  end\n  return encoded_message\n\
    end", "  -- your code goes here --\n  return result \nend", "  -- Write your code\
    \ here\n  -- You can use the alphabet and swapcase\n  -- You can replace vowels\
    \ with letters 2 places ahead of them\n  -- You can use the string functions to\
    \ replace vowels with letters\n  -- Hint: You need to use a recursive function\n\
    \  -- You will need to use the string functions \n  -- and string concatenation",
  "    local message_length = #message\n    local message_encoded = \"\"\n    local\
    \ index = 1\n    local alphabet = \"aBCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    while index\
    \ <= message_length do\n        local char = message[index]\n        if #alphabet\
    \ <= #char then\n            local current_char = alphabet:sub(1, #alphabet)\n\
    \            local next_char\n            if #alphabet > #char + 1 then\n    \
    \            next_char = alphabet:sub((#alphabet) + 1, 1)\n            else\n\
    \                next_char = \"\"\n            end\n            local vowel_index\
    \ = current_char:index(char)\n            local vowel_position = vowel_index +1\n\
    \            local new_vowel = alphabet:sub(vowel_position, vowel_index + 1)\n\
    \            local new_vowel_position = alphabet:index(new_vowel)\n          \
    \  local new_char = alphabet:sub(new_vowel_position, new_vowel_position + 2)\n\
    \            local new_char = new_char + new_vowel\n            message_encoded\
    \ = message_encoded .. new_char\n        else\n            message_encoded = message_encoded\
    \ .. char\n        end\n        index = index + 1\n    end\n    return message_encoded\n\
    end\n</cell>\n<text>\nNext, let's write a function that takes a message and converts\
    \ the message to binary in order for the message to be able to travel through\
    \ our network of computers. A good example of a function that does this for you\
    \ is encode, shown below:", "    local vowels = { 'a', 'e', 'i', 'o', 'u' }\n\
    \    local alphabet = { 'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n',\
    \ 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z' }\n    local messageUpper =\
    \ message:upper()\n    local newMessage = \"\"\n    local alphaIndex", "  local\
    \ words = {}\n  for word in string.gmatch(message, '[^ ]+') do\n    table.insert(words,\
    \ word:gsub('a', 'b'):gsub('e', 'b'):gsub('i', 'e'):gsub('o', 'e'):gsub('u', 'e'):gsub('y',\
    \ 'e'):gsub('a', 'z'):gsub('a', 'z'):gsub('e', 'z'):gsub('e', 'z'):gsub('i', 'z'):gsub('o',\
    \ 'z'):gsub('u', 'z'):gsub('y', 'z'))\n  end\n  return table.concat(words, ' ')\n\
    end", "    local vowels = { 'A', 'a', 'E', 'e', 'I', 'i', 'O', 'o', 'U', 'u' }\n\
    \    local alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'", "    local messageEnc = \"\
    \"\n    local vowels = \"a\",\"e\",\"i\",\"o\",\"u\"\n    local letters = \"a\"\
    ,\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\"\
    ,\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"\n   \
    \ local count = 0\n    local newCount = 0\n    local swap = 1\n    for i=1,#message\
    \ do\n        newCount = count\n        for j=1,#vowels do\n            if message[i]\
    \ == vowels[j] then\n                count = newCount + 1\n                if\
    \ count > newCount then\n                    messageEnc = messageEnc .. letters[newCount]\n\
    \                    newCount = count\n                else\n                \
    \    messageEnc = messageEnc .. letters[count]\n                end\n        \
    \    end\n        end\n        messageEnc = messageEnc .. letters[count]\n   \
    \     count = newCount\n    end\n    return messageEnc\nend", "    return string:gsub('([a-z])',\
    \ function(c) return string.gsub(string.upper(c), '[aeiou]', string.lower(string.sub(c,\
    \ 1, 2)) .. string.sub(c, 2)) end)\nend", "  -- start out with the empty string,\
    \ as no letters are left \n  -- out and no swaps are performed.\n  local encodedMessage\
    \ = ''\n  -- iterate through each letter in the message\n  for letter in string.gsub(message,\
    \ \"%c\", function (letter)\n    -- swap the letter case and swap the vowels\n\
    \    local decodedLetter = letter:lower()\n    local vowels = {'a','e','i','o','u'}\n\
    \    for i = 1, #vowels do\n      -- if the letter matches the vowel, swap the\
    \ two letters\n      if decodedLetter == vowels[i] then\n        local firstLetter\
    \ = decodedLetter:sub(1, 1)\n        local secondLetter = decodedLetter:sub(2,\
    \ 1)\n        decodedLetter = firstLetter:upper() .. secondLetter:upper()\n  \
    \    -- otherwise, leave it alone\n      else\n        decodedLetter = decodedLetter\n\
    \      end\n    end\n    encodedMessage = encodedMessage .. decodedLetter\n  end)\n\
    \  return encodedMessage\nend", "    local output = ''\n    for i = 1, #message\
    \ do\n        if string.find(message, string.sub(message,i,i+1)..'a'..string.sub(message,i+1,i+2))\
    \ then\n            local first = string.find(message, string.sub(message,i,i+1)..'a'..string.sub(message,i+1,i+2))\n\
    \            local second = string.find(message, string.sub(message,i+1,i+2)..'a'..string.sub(message,i,i+3))\n\
    \            if first ~= nil and second ~= nil then\n                output =\
    \ output .. string.sub(message,i,first)\n                output = output .. string.sub(message,first,second)\n\
    \            else\n                output = output .. string.sub(message,i,i+2)\n\
    \            end\n        else\n            output = output .. string.sub(message,i,i+1)\n\
    \        end\n    end\n    return output\nend", "    local alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    local vowels = \"AEIOUY\"\n    local result = \"\"\n    for i = 1, #message,\
    \ 1 do\n        local char = message[i]\n        local current = alphabet.index(char)\n\
    \        if vowels.includes(char) then\n            local next_char = alphabet.index(message[i\
    \ + 1])\n            current = current - next_char\n            if current <=\
    \ 0 then\n                current = 26\n            end\n            local temp\
    \ = alphabet.sub(alphabet, current + 1, current + 2)\n            result = result\
    \ .. temp\n        end\n    end\n    return result\nend", "  local alphabet =\
    \ \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  local vowels = \"AEIOUaeiou\"\n  local new_message\
    \ = \"\"\n  for i = 1, #message do\n    local current_letter = message[i]\n  \
    \  local new_letter\n    if current_letter then\n      new_letter = alphabet:sub(i,i)\
    \ + alphabet:sub(i+1,i+1)\n    else\n      new_letter = current_letter\n    end\n\
    \    if vowels:sub(i,1) then\n      new_letter = alphabet:sub(i,i) + new_letter\n\
    \    end\n    new_message = new_message .. new_letter\n  end\n  return new_message\n\
    end", "\tlocal message_encoded = message\n\tlocal alphabet = {'A', 'B', 'C', 'D',\
    \ 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\
    \ 'U', 'V', 'W', 'X', 'Y', 'Z'}\n\tfor i = 1, #alphabet do -- First we check that\
    \ we have a valid letter for the alphabet\n\t\tif alphabet[i] == message[i] then\n\
    \t\t\t-- First we check that we have a valid letter for the alphabet\n\t\t\tlocal\
    \ first_letter_of_alphabet = alphabet[i]\n\t\t\tlocal second_letter_of_alphabet\
    \ = alphabet[i+1]\n\t\t\t-- We check that we are not looking at the last letter,\
    \ and that there is no letter to look ahead onto\n\t\t\tif i > #message then break\
    \ end\n\t\t\tif message[#message] == first_letter_of_alphabet or message[#message]\
    \ == second_letter_of_alphabet then\n\t\t\t\t-- We now check that we have a second\
    \ letter on either side of the letter to look ahead onto\n\t\t\t\tlocal second_letter_of_alphabet_to_look_ahead_onto\
    \ = alphabet[i+1]\n\t\t\t\tlocal second_letter_of_alphabet_to_look_ahead_onto_length\
    \ = #alphabet[i+1]\n\t\t\t\t-- We check that we have the second letter in the\
    \ alphabet\n\t\t\t\tif message[#message] == second_letter_of_alphabet and message[#message+1]\
    \ == second_letter_of_alphabet then\n\t\t\t\t\t-- We now check that we have the\
    \ second letter in the alphabet\n\t\t\t\t\tif second_letter_of_alphabet_to_look_ahead_onto\
    \ == second_letter_of_alphabet and second_letter_of_alphabet_to_look_ahead_onto_length\
    \ > 1 then\n\t\t\t\t\t\t-- We check that we have the second letter in the alphabet\
    \ and it is longer than 1\n\t\t\t\t\t\tmessage_encoded = message_encoded .. alphabet[i]\n\
    \t\t\t\t\t\t-- We now start looking ahead\n\t\t\t\t\t\tfor j = #message + 2, 1\
    \ do\n\t\t\t\t\t\t\t-- We check that we have a second letter on either side of\
    \ the letter to look ahead onto\n\t\t\t\t\t\t\tlocal second_letter_of_alphabet_to_look_ahead_onto_to_look_ahead_onto\
    \ = alphabet[i+1]\n\t\t\t\t\t\t\tlocal second_letter_of_alphabet_to_look_ahead_onto_to_look_ahead_onto_length\
    \ = #alphabet[i+1]\n\t\t\t\t\t\t\t-- We check that we have the second letter in\
    \ the alphabet\n\t\t\t\t\t\t\tif message[#message] == second_letter_of_alphabet\
    \ and message[#message+1] == second_letter_of_alphabet then\n\t\t\t\t\t\t\t\t\
    -- We now check that we have the second letter in the alphabet\n\t\t\t\t\t\t\t\
    \tif second_letter_of_alphabet_to_look_ahead_onto_to_look_ahead_onto == second_letter_of_alphabet\
    \ and second_letter_of_alphabet_to_look_ahead_onto_to_look_ahead_on", "    local\
    \ alphabet = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', \n        'J', 'K',\
    \ 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', \n        'U', 'V', 'W', 'X', 'Y',\
    \ 'Z'}\n    local vowels = {'a', 'e', 'i', 'o', 'u'}\n    local result = \"\"\n\
    \    for letter in message:gmatch(\"[%a]+\") do\n        local first = letter:sub(1,\
    \ 1)\n        if first in vowels then\n            local second_index = alphabet\
    \ \n                           [letter:sub(2, 2):lower():byte()]\n           \
    \ local second = alphabet[second_index]\n            letter = second\n       \
    \ elseif letter ~= first then\n            letter = letter:sub(1, 1)\n       \
    \ end\n        result = result .. letter\n    end\n    return result\nend", " \
    \ local alphabet = {\n    'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p',\n\
    \    'q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G',\n  \
    \  'H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W',\n    'X','Y','Z'\n\
    \  }", "  -- your code goes here\nend", "  local vowels = \"aeiou\"\n  local result\
    \ = \"\"\n  local i = 0\n  while i <= #message do\n    local c = message[i]\n\
    \    if i == #message then\n      if c == \"a\" then\n        c = \"g\"\n    \
    \  elseif c == \"e\" then\n        c = \"g\"\n      elseif c == \"i\" then\n \
    \       c = \"h\"\n      elseif c == \"o\" then\n        c = \"h\"\n      elseif\
    \ c == \"u\" then\n        c = \"h\"\n      else\n        c = nil\n      end\n\
    \    end\n    local count = 1\n    for j = i+1; j<=#message-1 do\n      if c ==\
    \ message[j] then\n        count = count+1\n      end\n    end\n    if count ==\
    \ 2 then\n      for j = i+1; j<=#message-1 do\n        if vowels:find(message[j])\
    \ then\n          result = result .. string.rep(message[j], count)\n         \
    \ i = j\n          break\n        end\n      end\n    end\n    i = i+1\n  end\n\
    \  return result\nend", "    local alphabet = string.letters .. string.digits\n\
    \    local vowels = string.letters\n    local output = '' -- The output to be\
    \ returned\n    local count = 0 -- The number of times a character appears in\
    \ the \n                       -- message\n    local vowel = ''  -- The character\
    \ that is 2 places ahead of the \n                        -- current vowel\n \
    \   -- Loop through the string from the first character to the \n    -- last\n\
    \    for i = 1, #message do \n        -- If the character is in the alphabet,\
    \ increase count by \n        -- 1, otherwise set count to 0\n        if alphabet:sub(i,i)\
    \ == message then\n            count = count + 1\n        else\n            count\
    \ = 0\n        end\n        -- Determine what letter should appear 2 places ahead\n\
    \        if count > 2 then\n            -- Determine the index of the next character\
    \ that has \n            -- the same letter\n            local letter = alphabet:sub(i,i)\n\
    \            -- Set the vowel to the letter that is 2 places ahead \n        \
    \    -- of the current vowel\n            vowel = vowel:sub(1,1) .. letter\n \
    \       else\n            -- If the count is less than 2, set the vowel to the\
    \ \n            -- the letter that appears 2 places ahead of the current \n  \
    \          -- vowel\n            vowel = vowel:sub(1,1) .. alphabet:sub(i,i) \n\
    \        end\n        -- Add the current vowel to the output string\n        output\
    \ = output .. vowel\n    end\n    -- Return string with vowels replaced by letters\n\
    \    return output\nend", "  -- Write your code here\nend", "\t-- Get the index\
    \ of the 2nd vowel (we assume that \n\t-- we only have one vowel, and that its\
    \ index is \n\t-- 2 places ahead)\n\tlocal vowel_idx = string.find('a', message)\
    \ + 2\n\t-- Find the letter that comes after it (for the 1st vowel)\n\tlocal letter_after\
    \ = string.sub(message, vowel_idx, 1)\n\t-- Get the letter that comes before the\
    \ 2nd vowel (for the \n\t-- 2nd vowel)\n\tlocal letter_before = string.sub(message,\
    \ 1, vowel_idx - 1)\n\t-- If the 2nd letter is 'w', swap it with the 1st letter\n\
    \tif letter_after == 'w' then\n\t\treturn string.sub(message,1,1)..string.sub(message,vowel_idx,1)..string.sub(message,vowel_idx\
    \ + 1,1)\n\telse\n\t\treturn letter_after..letter_before\n\tend\nend", "    return\
    \ message\n    \nend", "   -- Write your code here\n   message\n   local vowels\
    \ = \"aeiouAEIOU\"\n   local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   local\
    \ output\n   for i=1,#message do\n      local char = message[i]\n      local position\
    \ = alphabet .. vowels:find(char)\n      position = position + 2\n      if position\
    \ <= #alphabet\n         then\n           char = alphabet[position]\n      else\n\
    \         position = #alphabet\n         char = alphabet[position-1]\n      end\n\
    \      output = output .. char\n   end\n   return output\nend", "   -- your solution\
    \ here\nend", "  local alphabet = string.gsub(message, \"[^A-Za-z]\", \"\")\n\
    \  local vowels = {'a', 'e', 'i', 'o', 'u'}\n  local alphabetLetters = string.gsub(alphabet,\
    \ \"[AEIOU]\", \n                                      function(letter)\n    \
    \                                    local index = alphabet == letter \n     \
    \                                                   and 1 or alphabet == \n  \
    \                                                        (letter + \n        \
    \                                                   string.sub(alphabet, \n  \
    \                                                                     \n     \
    \                                                                      string.find(alphabet,\
    \ letter) - 1))\n                                                        end\n\
    \                                        return alphabet[index + 1]\n        \
    \                              end)\n  return string.gsub(message, \"[AEIOU]\"\
    , function(letter)\n    return alphabetLetters[string.find(alphabet, letter) +\
    \ 1]\n  end)\nend", "    local msg = {}\n    local vowels = \"aeiouAEIOU\"\n \
    \   for i=1,#message do -- convert string to an array of characters\n        msg[i]\
    \ = tostring(message[i])\n    end\n    local out = ''\n    for i=1,#msg do\n \
    \       local char = string.sub(msg,i,i)\n        local newChar = string.upper(char)\n\
    \        local position = string.find(vowels,char)\n        if position ~= nil\
    \ then -- swap case\n            local nextVowel = string.sub(msg,position+1,position+1)\n\
    \            newChar = string.lower(nextVowel)\n        end\n        out = out\
    \ .. newChar\n    end\n    return string.gsub(out,'[aeiouAEIOU]','[aeiouAEIOU]')\n\
    end", "\tlocal letters = {\n\t\t['A'] = string.char(97),\n\t\t['B'] = string.char(98),\n\
    \t\t['C'] = string.char(99),\n\t\t['D'] = string.char(100),\n\t\t['E'] = string.char(101),\n\
    \t\t['F'] = string.char(102),\n\t\t['G'] = string.char(103),\n\t\t['H'] = string.char(104),\n\
    \t\t['I'] = string.char(105),\n\t\t['J'] = string.char(106),\n\t\t['K'] = string.char(107),\n\
    \t\t['L'] = string.char(108),\n\t\t['M'] = string.char(109),\n\t\t['N'] = string.char(110),\n\
    \t\t['O'] = string.char(111),\n\t\t['P'] = string.char(112),\n\t\t['Q'] = string.char(113),\n\
    \t\t['R'] = string.char(114),\n\t\t['S'] = string.char(115),\n\t\t['T'] = string.char(116),\n\
    \t\t['U'] = string.char(117),\n\t\t['V'] = string.char(118),\n\t\t['W'] = string.char(119),\n\
    \t\t['X'] = string.char(120),\n\t\t['Y'] = string.char(121),\n\t\t['Z'] = string.char(122),\n\
    \t\t['a'] = string.char(123),\n\t\t['b'] = string.char(124),\n\t\t['c'] = string.char(125),\n\
    \t\t['d'] = string.char(126),\n\t\t['e'] = string.char(127),\n\t\t['f'] = string.char(128),\n\
    \t\t['g'] = string.char(129),\n\t\t['h'] = string.char(130),\n\t\t['i'] = string.char(131),\n\
    \t\t['j'] = string.char(132),\n\t\t['k'] = string.char(133),\n\t\t['l'] = string.char(134),\n\
    \t\t['m'] = string.char(135),\n\t\t['n'] = string.char(136),\n\t\t['o'] = string.char(137),\n\
    \t\t['p'] = string.char(138),\n\t\t['q'] = string.char(139),\n\t\t['r'] = string.char(140),\n\
    \t\t['s'] = string.char(141),\n\t\t['t'] = string.char(142),\n\t\t['u'] = string.char(143),\n\
    \t\t['v'] = string.char(144),\n\t\t['w'] = string.char(145),\n\t\t['x'] = string.char(146),\n\
    \t\t['y'] = string.char(147),\n\t\t['z'] = string.char(148),\n\t\t['0'] = string.char(149),\n\
    \t\t['1'] = string.char(150),\n\t\t['2'] = string.char(151),\n\t\t['3'] = string.char(152),\n\
    \t\t['4'] = string.char(153),\n\t\t['5'] = string.char(154),\n\t\t['6'] = string.char(155),\n\
    \t\t['7'] = string.char(156),\n\t\t['8'] = string.char(157),\n\t\t['9'] = string.char(158),\n\
    \t\t['*'] = string.char(159),\n\t\t[']'] = ", "  local vowels = 'AEIOU'\n  local\
    \ map = {}\n  \n  -- Use map to store index of where each letter is in the alphabet\n\
    \  for i, letter in pairs(string.gmatch(message, '%a') ) do\n    map[ letter ]\
    \ = i\n  end\n  \n  -- Iterate through message and swap case of letters\n  for\
    \ letter, index in pairs(map) do\n    local messageWithIndex = string.sub(message,\
    \ 1, index-1)\n    local messageWithLetter = string.sub(message, index+1, index)\n\
    \    \n    local upperCaseLetter = string.upper(letter)\n    local lowerCaseLetter\
    \ = string.lower(letter)\n    \n    local newLetter = string.sub(vowels, string.find(vowels,\
    \ upperCaseLetter))\n    newLetter = string.sub(newLetter, 1, string.find(newLetter,\
    \ lowerCaseLetter))\n    \n    message = string.sub(messageWithIndex, index-1)\n\
    \    message = string.sub(message, index+1, index-1)\n    message = message ..\
    \ newLetter .. messageWithLetter\n  end\n  \n  return message\nend", "   -- your\
    \ code goes here\n   \n   \n   local alphabet = {'A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', \n        'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\
    \ 'U', \n        'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', \n   \
    \     'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', \n        's',\
    \ 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n    \n   for i,v in pairs(message) do\n\
    \      \n      if alphabet:find(v) == nil then\n          \n         for i,v in\
    \ pairs(alphabet) do\n            \n            if v == v then\n             \
    \  return v \n            end\n         end\n         \n      else\n         \n\
    \         return alphabet[alphabet.find(v)+1] \n      end\n   end\n   \nend\n\
    </cell>\n<text>\nProblem 5\nThe \"H\" letter is used twice in the message. Create\
    \ a dictionary that contains the english letters as keys, and each time they appear\
    \ as a value.", "   if message == nil then\n      return nil\n   end", "  -- TODO:\
    \ implement this\nend", "  local alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    \n  local vowels = \"aeiouAEIOU\"\n  local decoded = message\n  for i = 1, #message,\
    \ 1 do\n    local letter = message:sub(i, i)\n    if letter:sub(1, 1) ~= letter:sub(2,\
    \ 1) then \n      local position = alphabet .. vowels .. alphabet:sub(#alphabet,\
    \ #alphabet)\n      decoded:sub(i, i) = position\n    end\n  end\n  return decoded\n\
    end", "    local messageLower=message:lower()\n    local vowelsCount={}\n    for\
    \ i,v in ipairs({'a','e','i','o','u'}) do\n        vowelsCount[v]=nil\n    end\n\
    \    for i,c in ipairs(messageLower) do\n        if c=='a' or c=='e' or c=='i'\
    \ or c=='o' or c=='u' then\n            vowelsCount[c]=nil\n        elseif c=='w'\
    \ then\n            vowelsCount[c]=nil\n            vowelsCount[c+1]=vowelsCount[c]\n\
    \        else\n            local p=i\n            while p < #messageLower-1 and\
    \ messageLower[p]=c do\n                p = p + 1\n            end\n         \
    \   vowelsCount[c]=vowelsCount[c]+2\n            vowelsCount[c+1]=vowelsCount[c]\n\
    \        end\n    end\n    local result=''\n    for i,v in ipairs(vowelsCount)\
    \ do\n        if i then\n            result=result .. string.format('%c',i)\n\
    \        else\n            result=result .. string.format('%c',v)\n        end\n\
    \    end\n    return result\nend", "  -- Write your solution here\nend", "\t--\
    \ Write code here\n\tlocal alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\tlocal vowels\
    \ = 'aeiouAEIOU'\n\tlocal output = ''\n\tfor i, c in ipairs(message) do\n\t\t\
    local index = alphabet.find(c)\n\t\tif index == nil then\n\t\t\toutput = '?'\n\
    \t\telseif index > 26 then\n\t\t\toutput = alphabet[index - 26]\n\t\telseif index\
    \ > 25 then\n\t\t\toutput = alphabet[index - 25] .. alphabet[index]\n\t\telse\n\
    \t\t\tlocal char = alphabet[index]\n\t\t\toutput = '?'\n\t\t\tfor i = 1, 2 do\n\
    \t\t\t\tlocal l = string.len(vowels)\n\t\t\t\tif index == l then\n\t\t\t\t\tlocal\
    \ letter = alphabet[index + 1]\n\t\t\t\t\toutput = '' .. letter\n\t\t\t\telse\n\
    \t\t\t\t\toutput = '' .. alphabet[string.sub(vowels, index, index + 1)] .. letter\n\
    \t\t\t\tend\n\t\t\t\tindex = index + 2\n\t\t\tend\n\t\tend\n\tend\n\treturn output\n\
    end", "    local vowels = {}\n    for i = 1, #message do \n        table.insert(vowels,\
    \ string.sub((message), i, i+1))\n    end\n    local map = {}\n    for i = 1,\
    \ #message do\n        if string.sub((message), i, i+1) ~= \"\" then\n       \
    \     if string.sub((message), i, i+1) ~= string.sub((message), i, i+2) and \n\
    \               string.sub((message), i, i+1) ~= string.sub((message), i+2, i+3)\
    \ then\n                table.insert(map, string.sub((message), i, i+1))\n   \
    \         end\n        end\n    end\n    for i = 1, #map do\n        local j =\
    \ 1\n        while j <= #vowels do\n            local k = j + 1\n            local\
    \ n = string.sub(map, i, i)\n            while k <= #map and string.sub((map[k]),\
    \ 1, 1) ~= n do\n                k = k + 1\n            end\n            local\
    \ l = string.sub(map, i, k)\n            if l ~= \"\" then\n                table.insert(vowels,\
    \ l)\n            else\n                j = j + 1\n            end\n        end\n\
    \    end\n    local code = \"\"\n    for i = 1, #message do\n        local c =\
    \ string.sub(message, i, i+1)\n        for j = 1, #vowels do\n            local\
    \ u = string.sub(vowels, j, j)\n            if string.sub(c, i, i) ~= u then\n\
    \                local j = j - 1\n                if j == 0 then\n           \
    \         local v = string.sub(c, i, i)\n                    local f = true\n\
    \                    for k = 1, #map do\n                        if string.sub((map[k]),\
    \ i, i) ~= v then\n                            f = false\n                   \
    \         break\n                        end\n                    end\n      \
    \              if f then\n                        code = code .. (string.sub(c,\
    \ i, i) + string.sub((map[1]), i, i))\n                    end\n             \
    \   else\n                    code = code .. (string.sub(c, i, i) + string.sub((vowels[j]),\
    \ i, j))\n                end\n            end\n        end\n    end\n    return\
    \ code\nend", "  local decoded = {}\n  for i = 1, #message do\n    if string.sub(message,i,i)\
    \ == string.upper(string.sub(message,i,i)) then\n      decoded = string.gsub(message,\
    \ '%a', string.upper(string.sub(message,i+2,i+1)))\n    else\n      decoded =\
    \ string.gsub(message, '%a', string.lower(string.sub(message,i+2,i+1)))\n    end\n\
    \  end\n  return decoded\nend", "   if message == nil then return nil end\n  \
    \ local decoded = message\n   for i = 1, #message do \n      if message[i] ==\
    \ 'a' then decoded = decoded:gsub('a',\"A\"):gsub('e','E'):gsub('i','I'):gsub('o','O'):gsub('u','U')\
    \ end\n      if message[i] == 'e' then decoded = decoded:gsub('a',\"A\"):gsub('e','E'):gsub('i','I'):gsub('o','O'):gsub('u','U')\
    \ end\n      if message[i] == 'i' then decoded = decoded:gsub('a',\"A\"):gsub('e','E'):gsub('i','I'):gsub('o','O'):gsub('u','U')\
    \ end\n      if message[i] == 'o' then decoded = decoded:gsub('a',\"A\"):gsub('e','E'):gsub('i','I'):gsub('o','O'):gsub('u','U')\
    \ end\n      if message[i] == 'u' then decoded = decoded:gsub('a',\"A\"):gsub('e','E'):gsub('i','I'):gsub('o','O'):gsub('u','U')\
    \ end\n      if message[i] == 'A' then decoded = decoded:gsub('a',\"a\"):gsub('e','e'):gsub('i','i'):gsub('o','o'):gsub('u','u')\
    \ end\n      if message[i] == 'E' then decoded = decoded:gsub('a',\"a\"):gsub('e','e'):gsub('i','i'):gsub('o','o'):gsub('u','u')\
    \ end\n      if message[i] == 'I' then decoded = decoded:gsub('a',\"a\"):gsub('e','e'):gsub('i','i'):gsub('o','o'):gsub('u','u')\
    \ end\n      if message[i] == 'O' then decoded = decoded:gsub('a',\"a\"):gsub('e','e'):gsub('i','i'):gsub('o','o'):gsub('u','u')\
    \ end\n      if message[i] == 'U' then decoded = decoded:gsub('a',\"a\"):gsub('e','e'):gsub('i','i'):gsub('o','o'):gsub('u','u')\
    \ end\n   end\n   return decoded\nend", "  -- Write your code here\n  local encoded\
    \ = {}\n  for i = 1, #message do\n    local char = string.sub(message, i, i)\n\
    \    if i == 1 then\n      table.insert(encoded, string.upper(char))\n    else\n\
    \      local index = string.find(char, \"aeiou\")\n      if index and string.find(char,\
    \ \"AEIOU\") then\n        -- do nothing\n      else\n        local prevChar =\
    \ string.sub(message, i-1, i-1)\n        local prevCharIndex = string.find(prevChar,\
    \ \"aeiou\")\n        table.insert(encoded, string.upper(string.sub(message, i-1,\
    \ index)))\n        if prevCharIndex and prevCharIndex <= index then\n       \
    \   table.insert(encoded, string.lower(string.sub(message, index-1, prevCharIndex)))\n\
    \        end\n      end\n    end\n  end\n  local final = ''\n  for i = 1, #encoded\
    \ do\n    local char = string.sub(encoded, i, i)\n    if i == 1 then\n      table.insert(final,\
    \ string.upper(char))\n    else\n      local index = string.find(char, \"aeiou\"\
    )\n      if index and string.find(char, \"AEIOU\") then\n        -- do nothing\n\
    \      else\n        local prevChar = string.sub(encoded, i-1, i-1)\n        local\
    \ prevCharIndex = string.find(prevChar, \"aeiou\")\n        table.insert(final,\
    \ string.upper(string.sub(encoded, i-1, index)))\n        if prevCharIndex and\
    \ prevCharIndex <= index then\n          table.insert(final, string.lower(string.sub(encoded,\
    \ index-1, prevCharIndex)))\n        end\n      end\n    end\n  end\n  return\
    \ final\nend", "  local encodedMessage = message\n  local alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  local vowels = \"AEIOU\"", "    local encoded = ''\n    for i = 1, #message\
    \ do\n        local char = message[i]\n        local vowels = {}\n        for\
    \ j = 0, #alphabet-1 do\n            if char == alphabet[j] then\n           \
    \     table.insert(vowels, j)\n            end\n        end\n        for j = #vowels-1,1,-1\
    \ do\n            local v1 = alphabet[vowels[j]]\n            local v2 = alphabet[vowels[j+1]]\n\
    \            local replacement = alphabet[v1+v2]\n            encoded = encoded\
    \ .. replacement\n        end\n    end\n    return encoded\nend", "  -- This can\
    \ be done by looping through each letter and swapping the \n  -- case if needed,\
    \ and replacing the vowel with a letter 2 letters \n  -- ahead of the vowel. \n\
    \  -- However, it would be better to use a lookup table with 26 letters\n  --\
    \ rather than a switch statement. \n  -- This can be done by making two arrays,\
    \ one for lower case letters, \n  -- one for upper case letters. \n  -- Then use\
    \ that array to find the letter 3 letters ahead of the \n  -- vowel.\n  local\
    \ lower = {}\n  local upper = {}\n  for i = 1, #message do \n    lower[string.lower(message[i])]\
    \ = string.lower(message[i])\n    upper[string.upper(message[i])] = string.upper(message[i])\n\
    \  end", "  -- Split up the message into individual letters \n  local words =\
    \ string.gmatch(message, '%w+')\n  -- Make an empty string to hold the result\n\
    \  local result = \"\"\n  -- Loop over each letter in the message \n  for letter\
    \ in words do\n    -- If the letter is uppercase, swap the case \n    -- of every\
    \ letter in the message except the one \n    -- we're currently looking at, i.e.\
    \ swap every lowercase \n    -- letter in the message with its uppercase counterpart\n\
    \    if string.upper(letter) == letter then\n      -- Make sure we're working\
    \ on the correct letter\n      local upperLetter = letter:upper()\n      -- Loop\
    \ over every letter in the message\n      for innerLetter in string.gmatch(message,\
    \ '%w') do\n        -- If the letter in the message is the same as the \n    \
    \    -- uppercase letter, we'll just append the letter to \n        -- this result\
    \ \n        if innerLetter == upperLetter then\n          result = result .. letter\n\
    \        else\n          -- If the letter in the message is different \n     \
    \     -- to the uppercase, then we check whether the\n          -- letter in the\
    \ english alphabet appears 2 \n          -- letters ahead of the letter in the\
    \ message \n          -- and append the english alphabet letter \n          --\
    \ to the result \n          local englishLetter = string.sub(\n            string.sub(string.upper(letter),\
    \ 1, 1), 1, 1)\n          local nextLetter = string.sub(letter, 2)\n         \
    \ -- If the letter in the english alphabet appears \n          -- two letters\
    \ ahead of the current letter, we'll\n          -- append that letter to the result,\
    \ otherwise \n          -- we'll just append the current letter \n          --\
    \ to the result \n          if nextLetter == englishLetter then\n            result\
    \ = result .. nextLetter\n          else\n            result = result .. letter\n\
    \          end\n        end\n      end\n    else\n      -- If the letter is lowercase\n\
    \      -- just append the letter to the result\n      result = result .. letter\n\
    \    end\n  end\n  -- Return the result \n  return result\nend", "   local output\
    \ = ''\n   for i=1, #message, 1 do\n      local currentChar = message[i]\n   \
    \   local vowels = 'AEIOU'\n      local index = 0\n      for j = 1, #vowels do\n\
    \         index = index + 1 if currentChar == vowels[j] end\n      end\n     \
    \ output = output .. string.sub(vowels, index) .. currentChar\n   end\n   return\
    \ output\nend", "\t-- Write your solution here\n\treturn message\nend", "    message\
    \ = string.lower(message)\n    local vowels = {'a', 'e', 'i', 'o', 'u'}\n    local\
    \ result = \"\"\n    for i = 1, #message do\n        local char = message[i]\n\
    \        if char then\n            if #vowels <= #char then\n                --\
    \ If the letter is a vowel, then find what letter 2 \n                -- places\
    \ ahead of that vowel.\n                local index = string.find(vowels, char)\n\
    \                char = string.sub(vowels, index, index+2)\n            end\n\
    \            local index = string.find(vowels, char)\n            local nextIndex\
    \ = string.find(vowels, string.sub(message, i+1, i+2))\n            result = (string.sub(message,\
    \ i, i+1)) .. string.sub(message, index, nextIndex) .. char\n        end\n   \
    \ end\n    return result\nend", "  local function replace_vowel(vowel)\n    return\
    \ string.sub(vowel, 1, string.len(vowel)-2) + \n          string.sub(vowel, string.len(vowel)-1,\
    \ string.len(vowel))\n  end\n  \n  local function swap_case(letter)\n    return\
    \ string.upper(letter) .. string.lower(letter)\n  end\n  \n  local function replace_consonants(letter)\n\
    \    return string.sub(letter, 1, string.len(letter)-1)\n  end\n  \n  local message_letters\
    \ = string.gsub(message, \"[^a-zA-Z]\", \"\")\n  local message = string.gsub(message,\
    \ \"([aeiou])\", replace_vowel)\n  local message = string.gsub(message, \"[^aeiou]\"\
    , swap_case)\n  \n  local result_letters = \"\"\n  for letter in message_letters\n\
    \    do\n      result_letters = result_letters ..\n                       string.sub(message,\
    \ string.len(letter), string.len(letter)-1)\n    end\n  \n  return result_letters\n\
    end", "    local function rec(string)\n        -- Base case: if the message is\
    \ empty return an empty string\n        if message == '' then return '' end",
  "    local result = \"\"\n    for i, v in ipairs(message) do\n        local v2 =\
    \ message:sub(i,i+1)\n        if v:lower()==\"a\" or v:lower()==\"e\" or v:lower()==\"\
    i\" or v:lower()==\"o\" or v:lower()==\"u\" then\n            v2 = v:lower()\n\
    \        end\n        if v:lower() then\n            result = result .. v:lower()\
    \ .. v2\n        end\n    end\n    return result\nend", "  -- Initialize a table\
    \ that holds the message in their \n  -- original case, with each letter in the\
    \ alphabet \n  -- swapped and each vowel replaced by its letter \n  -- in the\
    \ alphabet 2 places ahead of it. \n  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  local messageInUpperCase = message\n  local messageInLowerCase = message:lower()\n\
    \  -- Iterate over each character in the message. \n  for i = 1, #message do\n\
    \    local char = message:sub(i,i)\n    -- If the character is a letter, swap\
    \ case and \n    -- replace each vowel with the letter that \n    -- appears 2\
    \ places ahead of that vowel. \n    if char in alphabet:gmatch(\"%a\") then\n\
    \      -- Swap the case of the letter. \n      char = char:upper()\n      char\
    \ = char:gsub(\"a\", \"A\")\n      char = char:gsub(\"e\", \"E\")\n      char\
    \ = char:gsub(\"i\", \"I\")\n      char = char:gsub(\"o\", \"O\")\n      char\
    \ = char:gsub(\"u\", \"U\")\n      char = char:gsub(\"A\", \"a\")\n      char\
    \ = char:gsub(\"E\", \"e\")\n      char = char:gsub(\"I\", \"i\")\n      char\
    \ = char:gsub(\"O\", \"o\")\n      char = char:gsub(\"U\", \"u\")\n    end\n \
    \   local swappedChar = char\n    -- Iterate over the alphabet and compare each\
    \ \n    -- letter to the letter that appears 2 places \n    -- ahead of it. \n\
    \    for j = #alphabet, 1, -1 do\n      local letter = alphabet:sub(j,j)\n   \
    \   swappedChar = swappedChar:gsub(letter, alphabet:sub(j-2, j-2))\n    end\n\
    \    -- Write the new case version of the character \n    -- back to the original\
    \ message. \n    messageInUpperCase = messageInUpperCase:gsub(messageInLowerCase,\
    \ swappedChar)\n  end\n  return messageInUpperCase\nend", "  -- First we find\
    \ each vowel.\n  local vowels = {'a', 'e', 'i', 'o', 'u'}\n  local vowelsPositions\
    \ = {\n    [0] = {1, 2},\n    [1] = {1, 3},\n    [2] = {1, 4},\n    [3] = {1,\
    \ 5},\n    [4] = {1, 6},\n    [5] = {1, 7},\n    [6] = {1, 8},\n    [7] = {1,\
    \ 9},\n    [8] = {1, 10},\n    [9] = {1, 11},\n    [10] = {2, 12},\n    [11] =\
    \ {2, 13},\n    [12] = {2, 14},\n    [13] = {2, 15},\n    [14] = {2, 16},\n  \
    \  [15] = {2, 17},\n    [16] = {2, 18},\n    [17] = {2, 19},\n    [18] = {2, 20},\n\
    \    [19] = {2, 21},\n    [20] = {2, 22},\n    [21] = {2, 23},\n    [22] = {2,\
    \ 24},\n    [23] = {2, 25},\n    [24] = {2, 26},\n    [25] = {2, 27},\n    [26]\
    \ = {2, 28},\n    [27] = {2, 29},\n    [28] = {2, 30},\n    [29] = {2, 31},\n\
    \    [30] = {2, 32},\n    [31] = {2, 33},\n    [32] = {2, 34},\n    [33] = {2,\
    \ 35},\n    [34] = {2, 36},\n    [35] = {2, 37},\n    [36] = {2, 38},\n    [37]\
    \ = {2, 39},\n    [38] = {2, 40},\n    [39] = {2, 41},\n    [40] = {2, 42},\n\
    \    [41] = {2, 43},\n    [42] = {2, 44},\n    [43] = {2, 45},\n    [44] = {2,\
    \ 46},\n    [45] = {2, 47},\n    [46] = {2, 48},\n    [47] = {2, 49},\n    [48]\
    \ = {2, 50},\n    [49] = {2, 51},\n    [50] = {2, 52},\n    [51] = {2, 53},\n\
    \    [52] = {2, 54},\n    [53] = {2, 55},\n    [54] = {2, 56},\n    [55] = {2,\
    \ 57},\n    [56] = {2, 58},\n    [57] = {2, 59},\n    [58] = {2, 60},\n    [59]\
    \ = {2, 61},\n    [60] = {2, 62},\n    [61] = {2, 63},\n    [62] = {2, 64},\n\
    \    [63] = {2, 65},\n    [64] = {2, 66},\n    [65] = {2, 67},\n    [66] = {2,\
    \ 68},\n    [67] = {2, 69},", "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local vowels = 'aeiouAEIOU'\n    local result = ''\n    for i = 1, #message\
    \ do\n        local index = alphabet:find(message[i])\n        if index == nil\
    \ then\n            -- Character not found, just append the character\n      \
    \      result = result .. message[i]\n        else\n            -- Find two places\
    \ ahead of the character\n            local places = alphabet.sub(index, index+1,\
    \ index + 2)\n            -- Swap case of all letters that come after the vowel\n\
    \            local replacement = alphabet:sub((vowels:find(places)+1):lower(),\n\
    \                (vowels:find(places)+1):upper(), (vowels:find(places)+1):lower())\n\
    \            result = result .. alphabet:sub((vowels:find(message[i])+1):lower(),\
    \ \n                (vowels:find(message[i])+1):upper(), replacement)\n      \
    \  end\n    end\n    return result\nend", "   -- Write your solution here\n  \
    \ return message\nend", "    if message == nil then return end\n    local vowels\
    \ = \"a\",\"e\",\"i\",\"o\",\"u\",\"y\",\"\xE1\",\"\xE9\",\"\xED\",\"\xF3\",\"\
    \xFA\"\n    local new_str = \"\"\n    for i = 1, #message do\n        if message[i]\
    \ ~= nil then\n            local new_char = message[i]\n            local vowel_index\
    \ = math.floor((i - 1) % 5)\n            local next_vowel_index = math.floor((i\
    \ - 2) % 5)\n            if vowel_index == next_vowel_index then\n           \
    \     new_char = string.upper(message[i])\n            end\n            if string.find(vowels,message[i])\
    \ == 1 then\n                local next_vowel = vowels[next_vowel_index]\n   \
    \             new_char = string.upper(next_vowel) + new_char\n            end\n\
    \            new_str = new_str..new_char\n        end\n    end\n    return new_str\n\
    end", "  -- Find all vowels (lower case only)\n  local vowels = setmetatable({},\
    \ {__mode=\"k\"})\n  for letter, index in pairs(string.gmatch(\"[aeiouy]+\", \"\
    %s\", \"i\")) do\n    vowels[letter] = index\n  end", "    local alphabet = string.gsub(string.gsub(string.gsub(\"\
    abcdefghijklmnopqrstuvwxyz\", 'aeiouAEIOU'), ''), 'aeiou', 'AEIOU')\n    local\
    \ t = {}\n    for i = 1, #message do\n        local index = alphabet and string.find(alphabet,\
    \ message[i]) or 0\n        if index and index > 0 and index + 1 <= #alphabet\
    \ then\n            t[#t + 1] = (alphabet[index + 1] .. message[i])\n        else\n\
    \            t[#t + 1] = message[i]\n        end\n    end\n    return table.concat(t)\n\
    end", "  if message == nil then return '' end\n  local alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \  local vowels = 'aeiouAEIOU'\n  local encoded = message\n  local index = 1\n\
    \  while index <= #message do\n    local letter = string.sub(message, index, index)\n\
    \    if letter ~= nil then\n      local index2 = index + 1 \n      while index2\
    \ < #message do\n        local letter2 = string.sub(message, index2, index2)\n\
    \        if letter2 ~= nil then\n          local firstLetter = string.sub(letter,\
    \ 1, 1)\n          local secondLetter = string.sub(letter2, 1, 1)\n          local\
    \ firstIndex2 = index2 + 1\n          while firstIndex2 < #message do\n      \
    \      local firstLetter2 = string.sub(message, firstIndex2, firstIndex2)\n  \
    \          if firstLetter2 ~= nil then\n              local firstLetter2Letter\
    \ = string.sub(firstLetter2, 1, 1)\n              if firstLetter2Letter ~= nil\
    \ and firstLetter2Letter ~= firstLetter and firstLetter2Letter ~= secondLetter\
    \ then\n                local secondIndex2 = index2 + 1 \n                while\
    \ secondIndex2 < #message do\n                  local secondLetter2 = string.sub(message,\
    \ secondIndex2, secondIndex2)\n                  if secondLetter2 ~= nil then\n\
    \                    local secondLetter2Letter = string.sub(secondLetter2, 1,\
    \ 1)\n                    if secondLetter2Letter ~= nil and secondLetter2Letter\
    \ ~= firstLetter2Letter then\n                      secondIndex2 = secondIndex2\
    \ + 1\n                    end\n                  end\n                  secondIndex2\
    \ = secondIndex2 + 1\n                end\n              end\n            end\n\
    \            firstIndex2 = firstIndex2 + 1\n          end\n        end\n     \
    \   index2 = index2 + 1\n      end\n    end\n    index = index + 1\n  end\n  return\
    \ encoded\nend", "  message = message:gsub(\".\", function(letter)\n    local\
    \ vowels = { 'a', 'e', 'i', 'o', 'u' }\n    local index = 0\n    local replaced\
    \ = letter\n    local vowel = ''\n    while true do\n      index = vowel:find(letter)\n\
    \      if index == -1 then\n        return replaced\n      end\n      vowel =\
    \ vowel:sub(0, index) + vowel:sub(index + 1)\n      replaced = replaced:sub(1,\
    \ index - 1) .. vowel:sub(1, index) .. replaced:sub(index + 1)\n    end\n  end)\n\
    \  return message:gsub(\"a\", \"t\")\nend", "  local output = \"\"\n  for letter\
    \ in string.gsub(message, \"[^A-Za-z]\", function(c) \n    local firstVowel =\
    \ string.sub(tolower(c), 1, 1)\n    local secondVowel = string.sub(tolower(c),\
    \ 1, 1)\n    local firstVowelIndex = string.find(letters, firstVowel)\n    local\
    \ secondVowelIndex = string.find(letters, secondVowel)\n    return letters[firstVowelIndex+1]\
    \ .. letters[secondVowelIndex+2]\n  end)\n  return output\nend", "  -- We need\
    \ to map letters to their position in english alphabet\n  local alphabet = { \n\
    \    ['A']=1, ['A']=1, ['A']=1, ['A']=1, ['B']=2, ['B']=2, ['C']=3, \n    ['C']=3,\
    \ ['D']=4, ['E']=5, ['F']=6, ['G']=7, ['H']=8, ['I']=9, \n    ['J']=10, ['K']=11,\
    \ ['L']=12, ['M']=13, ['N']=14, ['O']=15, \n    ['P']=16, ['Q']=17, ['R']=18,\
    \ ['S']=19, ['T']=20, ['U']=21, \n    ['V']=22, ['W']=23, ['X']=24, ['Y']=25,\
    \ ['Z']=26, \n    ['a']=27, ['a']=27, ['a']=27, ['a']=27, ['b']=28, ['b']=28,\
    \ \n    ['c']=29, ['c']=29, ['c']=29, ['c']=29, ['c']=29, ['c']=29, \n    ['d']=30,\
    \ ['e']=31, ['e']=31, ['e']=31, ['e']=31, ['e']=31, \n    ['e']=31, ['e']=31,\
    \ ['e']=31, ['e']=31, ['e']=31, ['e']=31, \n    ['e']=31, ['f']=32, ['g']=33,\
    \ ['h']=34, ['i']=35, ['j']=36, \n    ['k']=37, ['l']=38, ['m']=39, ['n']=40,\
    \ ['o']=41, ['p']=42, \n    ['q']=43, ['r']=44, ['s']=45, ['t']=46, ['u']=47,\
    \ ['v']=48, \n    ['w']=49, ['x']=50, ['y']=51, ['z']=52, ['a']=53, ['a']=53,\
    \ \n    ['a']=53, ['a']=53, ['b']=54, ['b']=54, ['c']=55, ['c']=55, \n    ['c']=55,\
    \ ['c']=55, ['c']=55, ['c']=55, ['c']=55, ['c']=55, \n    ['d']=56, ['e']=57,\
    \ ['e']=57, ['e']=57, ['e']=57, ['e']=57, \n    ['e']=57, ['e']=57, ['e']=57,\
    \ ['e']=57, ['e']=57, ['e']=57, \n    ['e']=57, ['f']=58, ['g']=59, ['h']=60,\
    \ ['i']=61, ['j']=62, \n    ['k']=63, ['l']=64, ['m']=65, ['n']=66, ['o']=67,\
    \ ['p']=68, \n    ['q']=69, ['r']=70, ['s']=71, ['t']=", "\t-- Initialize result\
    \ string to empty string\n\tlocal result = \"\"\n\t-- Iterate over the length\
    \ of the message \n\tfor i = 0, #message do \n\t\t-- Get character at position\
    \ i in message\n\t\tlocal char = message[i]:lower()\n\t\t-- Replace vowels in\
    \ string with letters that appear 2 places ahead of \n\t\t-- the vowel in the\
    \ alphabet \n\t\tif char == \"a\" or char == \"e\" or char == \"i\" or char ==\
    \ \"o\" or char == \"u\" then\n\t\t\tresult = result .. letters[#letters-1] \n\
    \t\tend\n\tend\n\t-- Return result string\n\treturn result\nend", "  local alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n  local vowels = \"aeiou\"\n  local messageArray\
    \ = string.gsub(message, \"[\" .. vowels .. \"]\", function (v)\n    return alphabet:sub((string.find(alphabet,\
    \ v) + 1), 1)\n  end)\n  return messageArray\nend", "  local encoded = message\n\
    \  local vowels = { 'a', 'e', 'i', 'o', 'u' }\n  for i = 1,#message do\n    local\
    \ letter = message[i]\n    for vowel = 1,#vowels do\n      if letter == vowels[vowel]\
    \ then\n        local next = letters[#letters] + vowel\n        letters[#letters]\
    \ = next\n      end\n    end\n    encoded = string.rep('TCGA', #encoded)\n   \
    \ local index = #encoded - 1\n    local previousLetter = encoded:sub(index-1,\
    \ index) \n    local previousVowel = previousLetter:sub(1, 1) \n    local nextLetter\
    \ = encoded:sub(index+1, index+2) \n    local nextVowel = nextLetter:sub(1, 1)\
    \ \n    local previousLetterIndex = string.find(previousVowel, 'a')\n    local\
    \ previousLetter = letters[previousLetterIndex]\n    local nextLetterIndex = string.find(nextVowel,\
    \ 'a')\n    local nextLetter = letters[nextLetterIndex]\n    if previousLetterIndex\
    \ == 0 and nextLetterIndex == 1 then\n      encoded:sub(index+3, index+4) = previousLetter..nextLetter\n\
    \    elseif previousLetterIndex == 0 and nextLetterIndex == 0 then\n      encoded:sub(index+1,\
    \ index+2) = previousLetter..nextLetter\n    elseif previousLetterIndex == 0 and\
    \ nextLetterIndex == 1 then\n      encoded:sub(index+1, index+3) = previousLetter..nextLetter\n\
    \    elseif previousLetterIndex == 1 and nextLetterIndex == 1 then\n      encoded:sub(index+3,\
    \ index+2) = previousLetter..nextLetter\n    elseif previousLetterIndex == 1 and\
    \ nextLetterIndex == 0 then\n      encoded:sub(index+1, index+2) = previousLetter..nextLetter\n\
    \    else\n      encoded:sub(index+1, index+2) = previousLetter..nextLetter\n\
    \      encoded:sub(index+3, index+4) = previousLetter..nextLetter\n    end\n \
    \ end\n  return encoded\nend", "    local result = \"\"\n    for i = 1,#message\
    \ do \n        local letter = string.sub(message,i,i)\n        if letter ~= letter\
    \ then\n            local vowel = string.sub(letter,1,1) \n            local letter2\
    \ = string.sub(letter,2,2)\n            letter = letter2 .. string.sub(vowel,1,1)\
    \ \n        end\n        result = result .. letter\n    end\n    return result\n\
    end", "    message = string.lower(message)\n    -- convert all letters to lowercase\n\
    \    for i = 1, #message do\n        local c = string.sub(message, i, i)\n   \
    \     -- convert to lowercase\n        local lower_c = string.lower(c)\n     \
    \   if lower_c ~= c then\n            -- replace all vowels\n            if string.find(lower_c,\
    \ \"aeiou\") then\n                -- replace vowels\n                message\
    \ = string.gsub(message, \"[aeiou]\", lower_c) \n            else\n          \
    \      -- swap case\n                message = string.upper(lower_c) + string.upper(c)\n\
    \            end\n        end\n    end\n    return message\nend\n</cell>\n<text>\n\
    Exercise 5\nWrite a function that takes a message, and encodes in such a way that\
    \ it swaps case of all letters, replaces all vowels in the message with the letter\
    \ that appears 2 places ahead of the vowel in the english alphabet. Assume only\
    \ letters. \nExamples:\n>>> encode('test')\n'TGST'\n>>> encode('This is a message')\n\
    'tHKS KS C MGSSCGG'"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
