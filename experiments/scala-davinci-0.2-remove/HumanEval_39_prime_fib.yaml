name: HumanEval_39_prime_fib
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n\
  \    def primeFib(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(primeFib((1l)) ==\
  \ (2l));\n    assert(primeFib((2l)) == (3l));\n    assert(primeFib((3l)) == (5l));\n\
  \    assert(primeFib((4l)) == (13l));\n    assert(primeFib((5l)) == (89l));\n  \
  \  assert(primeFib((6l)) == (233l));\n    assert(primeFib((7l)) == (1597l));\n \
  \   assert(primeFib((8l)) == (28657l));\n    assert(primeFib((9l)) == (514229l));\n\
  \    assert(primeFib((10l)) == (433494437l));\n    }\n\n}\n"
completions: ["        var i = 1\n        var j = 1\n        var k = 1\n        while\
    \ (k < n) {\n            val t = i + j\n            if (isPrime(t)) k += 1\n \
    \           i = j\n            j = t\n        }\n        j", "        var i =\
    \ 0;\n        var j = 1;\n        var k = 0;\n        var count = 0;\n       \
    \ while (count < n) {\n            k = i + j;\n            i = j;\n          \
    \  j = k;\n            if (isPrime(k)) count += 1;\n        }\n        return\
    \ k;", "        var a = 2L; var b = 3L; var c = 5L; var i = 3L\n        while\
    \ (i < n) {\n            a = b; b = c; c = a + b\n            if (isPrime(c))\
    \ i += 1\n        }\n        return c", "        var fib = new Array[Long](n.toInt\
    \ + 1)\n        fib(0) = 0\n        fib(1) = 1\n        for (i <- 2 to n.toInt)\
    \ {\n            fib(i) = fib(i - 1) + fib(i - 2)\n        }\n        var primes\
    \ = new Array[Boolean](fib(n.toInt).toInt + 1)\n        for (i <- 2 to fib(n.toInt).toInt)\
    \ {\n            primes(i) = true\n        }\n        for (i <- 2 to sqrt(fib(n.toInt).toDouble).toInt)\
    \ {\n            if (primes(i)) {\n                var j = i * i\n           \
    \     while (j <= fib(n.toInt).toInt) {\n                    primes(j) = false\n\
    \                    j += i\n                }\n            }\n        }\n   \
    \     var count = 0\n        for (i <- 2 to fib(n.toInt).toInt) {\n          \
    \  if (primes(i)) {\n                count += 1\n                if (count ==\
    \ n) return i\n            }\n        }\n        return 0", "        var fib =\
    \ new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1) = 1\n     \
    \   for (i <- 2 to n.toInt) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n\
    \        }\n        var primes = new Array[Boolean](fib(n.toInt).toInt + 1)\n\
    \        for (i <- 2 to fib(n.toInt).toInt) {\n            primes(i) = true\n\
    \        }\n        for (i <- 2 to sqrt(fib(n.toInt).toDouble).toInt) {\n    \
    \        if (primes(i)) {\n                var j = i * i\n                while\
    \ (j <= fib(n.toInt).toInt) {\n                    primes(j) = false\n       \
    \             j += i\n                }\n            }\n        }\n        var\
    \ count = 0\n        for (i <- 2 to fib(n.toInt).toInt) {\n            if (primes(i))\
    \ {\n                count += 1\n                if (count == n) return i\n  \
    \          }\n        }\n        return -1", "        var i = 1\n        var j\
    \ = 1\n        var count = 0\n        while (count < n) {\n            val k =\
    \ i + j\n            if (isPrime(k)) count += 1\n            i = j\n         \
    \   j = k\n        }\n        return j", "        val fibs = new ArrayBuffer[Long]()\n\
    \        fibs += 1\n        fibs += 2\n        var i = 2\n        while (fibs.size\
    \ < n) {\n            fibs += fibs(i - 1) + fibs(i - 2)\n            i += 1\n\
    \        }\n        fibs(i - 1)", "        var i = 0\n        var j = 1\n    \
    \    var k = 1\n        var count = 0\n        while (count < n) {\n         \
    \   if (isPrime(k)) {\n                count += 1\n            }\n           \
    \ val t = i + j\n            i = j\n            j = k\n            k = t\n   \
    \     }\n        k", "        var fib = new Array[Long](n.toInt + 1)\n       \
    \ fib(0) = 0\n        fib(1) = 1\n        for (i <- 2 to n.toInt) {\n        \
    \    fib(i) = fib(i - 1) + fib(i - 2)\n        }\n        var primes = new Array[Boolean](fib(n.toInt).toInt\
    \ + 1)\n        for (i <- 2 to fib(n.toInt).toInt) {\n            primes(i) =\
    \ true\n        }\n        for (i <- 2 to sqrt(fib(n.toInt).toDouble).toInt) {\n\
    \            if (primes(i)) {\n                var j = i * i\n               \
    \ while (j <= fib(n.toInt).toInt) {\n                    primes(j) = false\n \
    \                   j += i\n                }\n            }\n        }\n    \
    \    var count = 0\n        for (i <- 2 to fib(n.toInt).toInt) {\n           \
    \ if (primes(i)) {\n                count += 1\n                if (count == n)\
    \ return i\n            }\n        }\n        return -1", "        var i = 0\n\
    \        var j = 1\n        var k = 0\n        var count = 0\n        while (count\
    \ < n) {\n            k = i + j\n            if (isPrime(k)) count += 1\n    \
    \        i = j\n            j = k\n        }\n        return k", "        var\
    \ fib = new Array[Long](n.toInt)\n        fib(0) = 1\n        fib(1) = 2\n   \
    \     var i = 2\n        while (i < n) {\n            fib(i) = fib(i - 1) + fib(i\
    \ - 2)\n            i += 1\n        }\n        fib(n.toInt - 1)", "        var\
    \ i = 1\n        var j = 1\n        var k = 1\n        while (k < n) {\n     \
    \       val t = i + j\n            if (isPrime(t)) k += 1\n            i = j\n\
    \            j = t\n        }\n        j", "        var fib = new Fibonacci()\n\
    \        var i = 0\n        var p = 0L\n        while (i < n) {\n            p\
    \ = fib.next\n            if (isPrime(p)) i += 1\n        }\n        return p",
  "        val fib = new Fibonacci()\n        var i = 0\n        var p = 0L\n    \
    \    while (i < n) {\n            p = fib.next\n            if (p.isPrime) i +=\
    \ 1\n        }\n        p", "        var f = new Array[Long](n.toInt)\n      \
    \  f(0) = 2\n        f(1) = 3\n        var i = 2\n        while (i < n) {\n  \
    \          f(i) = f(i - 1) + f(i - 2)\n            i += 1\n        }\n       \
    \ f(n.toInt - 1)", "        var i = 0\n        var j = 1\n        var k = 0\n\
    \        var count = 0\n        while (count < n) {\n            k = i + j\n \
    \           i = j\n            j = k\n            if (isPrime(k)) count += 1\n\
    \        }\n        return k", "        var i = 0\n        var j = 1\n       \
    \ var k = 0\n        var count = 0\n        while (count < n) {\n            k\
    \ = i + j\n            if (isPrime(k)) count += 1\n            i = j\n       \
    \     j = k\n        }\n        return k", "        var count = 0\n        var\
    \ i = 1\n        while (count < n) {\n            i += 1\n            if (isPrime(i)\
    \ && isFib(i)) count += 1\n        }\n        return i", "        var i = 2L;\n\
    \        var fib = 1L;\n        var fib_prev = 1L;\n        var count = 0L;\n\
    \        while (count < n) {\n            if (i.isPrime) {\n                val\
    \ temp = fib;\n                fib += fib_prev;\n                fib_prev = temp;\n\
    \                count += 1;\n            }\n            i += 1;\n        }\n\
    \        return fib;", "        var i = 1\n        var j = 1\n        var k =\
    \ 1\n        while (k < n) {\n            val t = i + j\n            if (t.isPrime)\
    \ k += 1\n            i = j\n            j = t\n        }\n        j", "     \
    \   var fibs = new ArrayBuffer[Long]();\n        fibs += 1; fibs += 2;\n     \
    \   var i = 2;\n        while (i <= n) {\n            fibs += fibs(i - 1) + fibs(i\
    \ - 2);\n            if (fibs(i) % 2 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 3 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 5 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 7 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 11 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 13 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 17 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 19 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 23 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 29 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 31 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 37 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 41 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 43 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 47 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 53 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 59 == 0) {\n                fib", "        var\
    \ fibs = new ArrayBuffer[Long]()\n        fibs += 1\n        fibs += 2\n     \
    \   var i = 2\n        while (i <= n) {\n            fibs += fibs(i - 1) + fibs(i\
    \ - 2)\n            i += 1\n        }\n        fibs(n.toInt - 1)", "        var\
    \ i = 0\n        var j = 1\n        var k = 0\n        var count = 0\n       \
    \ while (count < n) {\n            k = i + j\n            if (isPrime(k)) {\n\
    \                count += 1\n            }\n            i = j\n            j =\
    \ k\n        }\n        return k", "        var count = 0\n        var i = 1\n\
    \        while (count < n) {\n            if (isPrime(fib(i))) count += 1\n  \
    \          i += 1\n        }\n        fib(i - 1)", "        var fibs = new ArrayBuffer[Long]()\n\
    \        fibs += 1\n        fibs += 2\n        var i = 2\n        while (i <=\
    \ n) {\n            fibs += fibs(i - 1) + fibs(i - 2)\n            i += 1\n  \
    \      }\n        return fibs(n.toInt - 1)", "        var fibs = new ArrayBuffer[Long]()\n\
    \        fibs += 1\n        fibs += 2\n        var i = 2\n        while (i <=\
    \ n) {\n            fibs += fibs(i - 1) + fibs(i - 2)\n            i += 1\n  \
    \      }\n        fibs(n.toInt - 1)", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 1; fibs += 2;\n        var i = 2;\n        while (fibs.length\
    \ < n) {\n            fibs += fibs(i - 1) + fibs(i - 2);\n            i += 1;\n\
    \        }\n        fibs(n.toInt - 1)", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 1; fibs += 2;\n        var i = 2;\n        while (fibs.length\
    \ < n) {\n            fibs += fibs(i - 1) + fibs(i - 2);\n            i += 1;\n\
    \        }\n        fibs(n.toInt - 1)", "        var i = 1\n        var j = 1\n\
    \        var k = 1\n        while (k < n) {\n            val t = i + j\n     \
    \       if (isPrime(t)) k += 1\n            i = j\n            j = t\n       \
    \ }\n        j", "        val primes = new Primes(1000000)\n        val fibs =\
    \ new Fibonacci(1000000)\n        var i = 0\n        var j = 0\n        while\
    \ (i < n) {\n            j += 1\n            if (primes.isPrime(fibs(j))) i +=\
    \ 1\n        }\n        fibs(j)", "        var fib = new Array[Long](n.toInt +\
    \ 1)\n        fib(0) = 0\n        fib(1) = 1\n        var i = 2\n        while\
    \ (i <= n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n\
    \        }\n        return fib(n.toInt)", "        var count = 0\n        var\
    \ i = 0\n        while (count < n) {\n            i += 1\n            if (isPrime(i)\
    \ && isFib(i)) count += 1\n        }\n        return i", "        var fib = new\
    \ Array[Long](n.toInt + 1)\n        fib(0) = 1\n        fib(1) = 1\n        var\
    \ i = 2\n        while (i <= n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n\
    \            i += 1\n        }\n        fib(n.toInt)", "        var i = 1\n  \
    \      var count = 0\n        var fib = 1\n        while (count < n) {\n     \
    \       fib = fibonacci(i)\n            if (isPrime(fib)) count += 1\n       \
    \     i += 1\n        }\n        fib", "        var fib = new Array[Long](n.toInt)\n\
    \        fib(0) = 1\n        fib(1) = 2\n        var i = 2\n        while (i <\
    \ n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n   \
    \     }\n        fib(n.toInt - 1)", "        var a = 0L\n        var b = 1L\n\
    \        var c = 0L\n        var count = 0L\n        while (count < n) {\n   \
    \         c = a + b\n            if (isPrime(c)) count += 1\n            a = b\n\
    \            b = c\n        }\n        return c", "        var fib = ArrayBuffer[Long](2,\
    \ 3)\n        var i = 2\n        while (i < n) {\n            fib += fib(i - 1)\
    \ + fib(i - 2)\n            i += 1\n        }\n        fib(n.toInt - 1)", "  \
    \      var count = 0\n        var i = 2\n        while (count < n) {\n       \
    \     if (isPrime(i) && isFib(i)) {\n                count += 1\n            }\n\
    \            i += 1\n        }\n        return i - 1", "        var i = 1\n  \
    \      var j = 1\n        var k = 1\n        while (k < n) {\n            val\
    \ t = i + j\n            if (t.isPrime) {\n                k += 1\n          \
    \  }\n            i = j\n            j = t\n        }\n        j", "        var\
    \ i = 1\n        var count = 0\n        var result = 0L\n        while (count\
    \ < n) {\n            i += 1\n            if (isPrime(fib(i))) {\n           \
    \     count += 1\n                result = fib(i)\n            }\n        }\n\
    \        result", "        val fibs = ArrayBuffer[Long](2, 3)\n        var i =\
    \ 2\n        while (i <= n) {\n            fibs += fibs(i - 1) + fibs(i - 2)\n\
    \            i += 1\n        }\n        fibs(n.toInt - 1)", "        var count\
    \ = 0\n        var i = 0\n        var fib = 0\n        while (count < n) {\n \
    \           fib = fibonacci(i)\n            if (isPrime(fib)) count += 1\n   \
    \         i += 1\n        }\n        fib", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 1; fibs += 2;\n        var i = 2;\n        while (i <= n) {\n\
    \            fibs += fibs(i - 1) + fibs(i - 2);\n            i += 1;\n       \
    \ }\n        return fibs(n.toInt - 1);", "        var fibs = ArrayBuffer[Long](1,\
    \ 2)\n        var i = 2\n        while (fibs.size < n) {\n            fibs +=\
    \ fibs(i - 1) + fibs(i - 2)\n            i += 1\n        }\n        fibs(n.toInt\
    \ - 1)", "        var fibs = new ArrayBuffer[Long]()\n        fibs += 1\n    \
    \    fibs += 2\n        var i = 2\n        while (fibs.length < n) {\n       \
    \     fibs += fibs(i - 1) + fibs(i - 2)\n            i += 1\n        }\n     \
    \   fibs(i - 1)", "        var i = 0\n        var j = 1\n        var k = 0\n \
    \       var count = 0\n        while (count < n) {\n            k = i + j\n  \
    \          if (isPrime(k)) count += 1\n            i = j\n            j = k\n\
    \        }\n        return k", "        var a = 1L; var b = 1L; var c = 0L; var\
    \ i = 1L\n        while (i < n) {\n            c = a + b; a = b; b = c\n     \
    \       if (isPrime(c)) i += 1\n        }\n        return c", "        var fibs\
    \ = new ArrayBuffer[Long]();\n        fibs += 1; fibs += 2;\n        var i = 2;\n\
    \        while (i <= n) {\n            var next = fibs(i - 1) + fibs(i - 2);\n\
    \            if (isPrime(next)) {\n                fibs += next;\n           \
    \     i += 1;\n            }\n        }\n        return fibs(n.toInt - 1);", " \
    \       var i = 1\n        var j = 1\n        var k = 0\n        var count = 0\n\
    \        while (count < n) {\n            k = i + j\n            if (isPrime(k))\
    \ count += 1\n            i = j\n            j = k\n        }\n        return\
    \ k", "        var i = 1\n        var j = 1\n        var k = 0\n        var count\
    \ = 0\n        while (count < n) {\n            k = i + j\n            if (BigInt(k).isProbablePrime(10))\
    \ {\n                count += 1\n            }\n            i = j\n          \
    \  j = k\n        }\n        return k", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 1; fibs += 2;\n        var i = 2;\n        while (i <= n) {\n\
    \            fibs += fibs(i - 1) + fibs(i - 2);\n            if (fibs(i) % 2 ==\
    \ 0) {\n                fibs.remove(i);\n            } else if (fibs(i) % 3 ==\
    \ 0) {\n                fibs.remove(i);\n            } else if (fibs(i) % 5 ==\
    \ 0) {\n                fibs.remove(i);\n            } else if (fibs(i) % 7 ==\
    \ 0) {\n                fibs.remove(i);\n            } else if (fibs(i) % 11 ==\
    \ 0) {\n                fibs.remove(i);\n            } else if (fibs(i) % 13 ==\
    \ 0) {\n                fibs.remove(i);\n            } else if (fibs(i) % 17 ==\
    \ 0) {\n                fibs.remove(i);\n            } else if (fibs(i) % 19 ==\
    \ 0) {\n                fibs.remove(i);\n            } else if (fibs(i) % 23 ==\
    \ 0) {\n                fibs.remove(i);\n            } else if (fibs(i) % 29 ==\
    \ 0) {\n                fibs.remove(i);\n            } else if (fibs(i) % 31 ==\
    \ 0) {\n                fibs.remove(i);\n            } else if (fibs(i) % 37 ==\
    \ 0) {\n                fibs.remove(i);\n            } else if (fibs(i) % 41 ==\
    \ 0) {\n                fibs.remove(i);\n            } else if (fibs(i) % 43 ==\
    \ 0) {\n                fibs.remove(i);\n            } else if (fibs(i) % 47 ==\
    \ 0) {\n                fibs.remove(i);\n            } else if (fibs(i) % 53 ==\
    \ 0) {\n                fibs.remove(i);\n            } else if (fibs(i) % 59 ==\
    \ 0) {\n                fib", "        val primes = new PrimeSet(1000000)\n  \
    \      var i = 0\n        var j = 1\n        var k = 0\n        while (k < n)\
    \ {\n            val f = i + j\n            if (primes.contains(f)) k += 1\n \
    \           i = j\n            j = f\n        }\n        i + j", "        var\
    \ fibs = new ArrayBuffer[Long]()\n        fibs += 1\n        fibs += 2\n     \
    \   var i = 2\n        while (i <= n) {\n            fibs += fibs(i - 1) + fibs(i\
    \ - 2)\n            i += 1\n        }\n        return fibs(n.toInt - 1)", "  \
    \      var i = 1\n        var j = 1\n        var k = 1\n        while (k < n)\
    \ {\n            val t = i + j\n            if (t.isPrime) k += 1\n          \
    \  i = j\n            j = t\n        }\n        j", "        val fib = new Array[Long](n.toInt\
    \ + 1)\n        fib(0) = 1\n        fib(1) = 1\n        for (i <- 2 to n.toInt)\
    \ {\n            fib(i) = fib(i - 1) + fib(i - 2)\n        }\n        var i =\
    \ 0\n        while (i < n.toInt) {\n            if (isPrime(fib(i))) return fib(i)\n\
    \            i += 1\n        }\n        return -1", "        var i = 0\n     \
    \   var j = 1\n        var k = 0\n        var count = 0\n        while (count\
    \ < n) {\n            k = i + j\n            if (isPrime(k)) {\n             \
    \   count += 1\n            }\n            i = j\n            j = k\n        }\n\
    \        return k", "        var i = 1\n        var count = 0\n        while (count\
    \ < n) {\n            i += 1\n            if (isPrime(i) && isFib(i)) count +=\
    \ 1\n        }\n        return i", "        var fib = new Array[Long](n.toInt\
    \ + 1)\n        fib(0) = 1\n        fib(1) = 1\n        for (i <- 2 to n.toInt)\
    \ {\n            fib(i) = fib(i - 1) + fib(i - 2)\n        }\n        fib(n.toInt)",
  "        var fib = new Array[Long](n.toInt + 1)\n        fib(0) = 1\n        fib(1)\
    \ = 1\n        for (i <- 2 to n.toInt) {\n            fib(i) = fib(i - 1) + fib(i\
    \ - 2)\n        }\n        var primes = new Array[Boolean](fib(n.toInt).toInt\
    \ + 1)\n        for (i <- 2 to fib(n.toInt).toInt) {\n            primes(i) =\
    \ true\n        }\n        for (i <- 2 to sqrt(fib(n.toInt).toDouble).toInt) {\n\
    \            if (primes(i)) {\n                var k = i * i\n               \
    \ while (k <= fib(n.toInt).toInt) {\n                    primes(k) = false\n \
    \                   k += i\n                }\n            }\n        }\n    \
    \    var count = 0\n        for (i <- 2 to fib(n.toInt).toInt) {\n           \
    \ if (primes(i)) {\n                count += 1\n                if (count == n)\
    \ return i\n            }\n        }\n        return 0", "        val primes =\
    \ new PrimeSet(1000000)\n        var a = 1L\n        var b = 1L\n        var c\
    \ = a + b\n        var i = 3L\n        while (i <= n) {\n            c = a + b\n\
    \            a = b\n            b = c\n            i += 1\n        }\n       \
    \ while (!primes.contains(c)) {\n            c = a + b\n            a = b\n  \
    \          b = c\n            i += 1\n        }\n        c", "        var fibs\
    \ = new ArrayBuffer[Long]()\n        fibs += 1\n        fibs += 2\n        var\
    \ i = 2\n        while (i <= n) {\n            fibs += fibs(i - 1) + fibs(i -\
    \ 2)\n            i += 1\n        }\n        fibs(n.toInt - 1)", "        val\
    \ fib = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1) = 1\n\
    \        for (i <- 2 to n.toInt) fib(i) = fib(i - 1) + fib(i - 2)\n        var\
    \ i = 0\n        while (i < n.toInt) {\n            if (isPrime(fib(i))) return\
    \ fib(i)\n            i += 1\n        }\n        0", "        var i = 1\n    \
    \    var j = 1\n        var count = 1\n        while (count < n) {\n         \
    \   val k = i + j\n            if (isPrime(k)) count += 1\n            i = j\n\
    \            j = k\n        }\n        j", "        var a = 1L; var b = 1L; var\
    \ c = 0L; var i = 2L;\n        while (i <= n) {\n            c = a + b;\n    \
    \        if (isPrime(c)) {\n                i += 1;\n            }\n         \
    \   a = b;\n            b = c;\n        }\n        return c;", "        var a\
    \ = 0L\n        var b = 1L\n        var c = 0L\n        var i = 0L\n        while\
    \ (i < n) {\n            c = a + b\n            a = b\n            b = c\n   \
    \         if (isPrime(c)) i += 1\n        }\n        return c", "        var fib\
    \ = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1) = 1\n   \
    \     for (i <- 2 to n.toInt) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n\
    \        }\n        var primes = new Array[Boolean](fib(n.toInt).toInt + 1)\n\
    \        for (i <- 2 to fib(n.toInt).toInt) {\n            primes(i) = true\n\
    \        }\n        for (i <- 2 to sqrt(fib(n.toInt).toDouble).toInt) {\n    \
    \        if (primes(i)) {\n                var k = i * i\n                while\
    \ (k <= fib(n.toInt).toInt) {\n                    primes(k) = false\n       \
    \             k += i\n                }\n            }\n        }\n        var\
    \ count = 0\n        for (i <- 2 to fib(n.toInt).toInt) {\n            if (primes(i))\
    \ {\n                count += 1\n                if (count == n) return i\n  \
    \          }\n        }\n        return -1", "        var fib = new Array[Long](n.toInt\
    \ + 1)\n        fib(0) = 0\n        fib(1) = 1\n        for (i <- 2 to n.toInt)\
    \ {\n            fib(i) = fib(i - 1) + fib(i - 2)\n        }\n        var primes\
    \ = new Array[Boolean](fib(n.toInt).toInt + 1)\n        for (i <- 2 to fib(n.toInt).toInt)\
    \ {\n            primes(i) = true\n        }\n        for (i <- 2 to sqrt(fib(n.toInt).toDouble).toInt)\
    \ {\n            if (primes(i)) {\n                var j = i * i\n           \
    \     while (j <= fib(n.toInt).toInt) {\n                    primes(j) = false\n\
    \                    j += i\n                }\n            }\n        }\n   \
    \     var result = 0\n        for (i <- 2 to n.toInt) {\n            if (primes(fib(i).toInt))\
    \ result = fib(i).toInt\n        }\n        return result", "        var fibs\
    \ = new ArrayBuffer[Long]();\n        fibs += 1; fibs += 2;\n        var i = 2;\n\
    \        while (i <= n) {\n            fibs += fibs(i - 1) + fibs(i - 2);\n  \
    \          if (fibs(i) % 2 == 0) fibs(i) += 1;\n            while (!isPrime(fibs(i)))\
    \ fibs(i) += 2;\n            i += 1;\n        }\n        return fibs(n.toInt -\
    \ 1);", "        val fibs = new ArrayBuffer[Long]\n        fibs += 1\n       \
    \ fibs += 2\n        var i = 2\n        while (i <= n) {\n            fibs +=\
    \ fibs(i - 1) + fibs(i - 2)\n            i += 1\n        }\n        fibs(n.toInt\
    \ - 1)", "        var fib = ArrayBuffer(1L, 1L)\n        var i = 2\n        while\
    \ (i < n) {\n            fib += fib(i - 1) + fib(i - 2)\n            i += 1\n\
    \        }\n        return fib(n - 1)", "        var fib = new Array[Long](n.toInt\
    \ + 1)\n        fib(0) = 0\n        fib(1) = 1\n        for (i <- 2 to n.toInt)\
    \ {\n            fib(i) = fib(i - 1) + fib(i - 2)\n        }\n        var primes\
    \ = new Array[Boolean](fib(n.toInt).toInt + 1)\n        for (i <- 2 to fib(n.toInt).toInt)\
    \ {\n            primes(i) = true\n        }\n        for (i <- 2 to sqrt(fib(n.toInt).toDouble).toInt)\
    \ {\n            if (primes(i)) {\n                var j = i * i\n           \
    \     while (j <= fib(n.toInt).toInt) {\n                    primes(j) = false\n\
    \                    j += i\n                }\n            }\n        }\n   \
    \     var count = 0\n        for (i <- 2 to fib(n.toInt).toInt) {\n          \
    \  if (primes(i)) {\n                count += 1\n                if (count ==\
    \ n) return i\n            }\n        }\n        return 0", "        val fib =\
    \ new Array[Long](n.toInt + 1)\n        fib(0) = 1\n        fib(1) = 1\n     \
    \   for (i <- 2 to n.toInt) fib(i) = fib(i - 1) + fib(i - 2)\n        var i =\
    \ n.toInt\n        while (true) {\n            if (isPrime(fib(i))) return fib(i)\n\
    \            i -= 1\n        }\n        return -1", "        val primes = new\
    \ PrimeSet(1000000)\n        var i = 0\n        var a = 0L\n        var b = 1L\n\
    \        var c = 1L\n        while (i < n) {\n            c = a + b\n        \
    \    a = b\n            b = c\n            if (primes.isPrime(c)) i += 1\n   \
    \     }\n        return c", "        var i = 1\n        var j = 1\n        var\
    \ k = 1\n        while (k < n) {\n            val t = i + j\n            i = j\n\
    \            j = t\n            if (j.isPrime) k += 1\n        }\n        j",
  "        var i = 0;\n        var j = 1;\n        var k = 0;\n        var count =\
    \ 0;\n        while (count < n) {\n            k = i + j;\n            i = j;\n\
    \            j = k;\n            if (isPrime(k)) count += 1;\n        }\n    \
    \    return k;", "        var a = 1L; var b = 1L; var c = 2L; var i = 2L;\n  \
    \      while (i < n) {\n            c = a + b; a = b; b = c;\n            if (c.isPrime)\
    \ i += 1;\n        }\n        return c;", "        val primes = new PrimeSet(1000000)\n\
    \        var i = 0\n        var j = 1\n        var k = 0\n        while (k < n)\
    \ {\n            val f = i + j\n            if (primes.isPrime(f)) k += 1\n  \
    \          i = j\n            j = f\n        }\n        i + j", "        var count\
    \ = 0\n        var i = 0\n        while (count < n) {\n            if (isPrime(fib(i)))\
    \ count += 1\n            i += 1\n        }\n        return fib(i - 1)", "   \
    \     val fibs = new ArrayBuffer[Long]\n        fibs += 1\n        fibs += 2\n\
    \        var i = 2\n        while (i <= n) {\n            fibs += fibs(i - 1)\
    \ + fibs(i - 2)\n            i += 1\n        }\n        fibs(n.toInt - 1)", " \
    \       var fib = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1)\
    \ = 1\n        for (i <- 2 to n.toInt) {\n            fib(i) = fib(i - 1) + fib(i\
    \ - 2)\n        }\n        var primes = new Array[Boolean](fib(n.toInt).toInt\
    \ + 1)\n        for (i <- 2 to fib(n.toInt).toInt) {\n            primes(i) =\
    \ true\n        }\n        for (i <- 2 to sqrt(fib(n.toInt).toDouble).toInt) {\n\
    \            if (primes(i)) {\n                var j = i * i\n               \
    \ while (j <= fib(n.toInt).toInt) {\n                    primes(j) = false\n \
    \                   j += i\n                }\n            }\n        }\n    \
    \    var count = 0\n        for (i <- 2 to fib(n.toInt).toInt) {\n           \
    \ if (primes(i)) {\n                count += 1\n                if (count == n)\
    \ return i\n            }\n        }\n        return -1", "        var fibs =\
    \ new ArrayBuffer[Long]()\n        fibs += 1\n        fibs += 2\n        var i\
    \ = 2\n        while (fibs.size < n) {\n            fibs += fibs(i - 1) + fibs(i\
    \ - 2)\n            i += 1\n        }\n        fibs(n.toInt - 1)", "        val\
    \ fibs = new ArrayBuffer[Long]\n        fibs += 1\n        fibs += 2\n       \
    \ var i = 2\n        while (fibs.size < n) {\n            fibs += fibs(i - 1)\
    \ + fibs(i - 2)\n            i += 1\n        }\n        fibs(n.toInt - 1)", " \
    \       var i = 1\n        var count = 0\n        while (count < n) {\n      \
    \      i += 1\n            if (isPrime(fib(i))) count += 1\n        }\n      \
    \  fib(i)", "        var fibs = new ArrayBuffer[Long]()\n        fibs += 1\n \
    \       fibs += 2\n        var i = 2\n        while (fibs.length < n) {\n    \
    \        fibs += fibs(i - 1) + fibs(i - 2)\n            i += 1\n        }\n  \
    \      fibs(n.toInt - 1)", "        val fibs = new ArrayBuffer[Long]()\n     \
    \   fibs += 1\n        fibs += 2\n        var i = 2\n        while (i <= n) {\n\
    \            fibs += fibs(i - 1) + fibs(i - 2)\n            i += 1\n        }\n\
    \        fibs(n.toInt - 1)", "        var fib = ArrayBuffer[Long](1, 2)\n    \
    \    var i = 2\n        while (i < n) {\n            fib += fib(i - 1) + fib(i\
    \ - 2)\n            i += 1\n        }\n        fib(n.toInt - 1)", "        var\
    \ fibs = new ArrayBuffer[Long]()\n        fibs += 1\n        fibs += 2\n     \
    \   var i = 2\n        while (i <= n) {\n            fibs += fibs(i - 1) + fibs(i\
    \ - 2)\n            i += 1\n        }\n        return fibs(n.toInt - 1)", "  \
    \      var fib = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1)\
    \ = 1\n        for (i <- 2 to n.toInt) {\n            fib(i) = fib(i - 1) + fib(i\
    \ - 2)\n        }\n        var primes = new Array[Boolean](fib(n.toInt).toInt\
    \ + 1)\n        for (i <- 2 to fib(n.toInt).toInt) {\n            primes(i) =\
    \ true\n        }\n        for (i <- 2 to sqrt(fib(n.toInt).toDouble).toInt) {\n\
    \            if (primes(i)) {\n                var j = i * i\n               \
    \ while (j <= fib(n.toInt).toInt) {\n                    primes(j) = false\n \
    \                   j += i\n                }\n            }\n        }\n    \
    \    var count = 0\n        for (i <- 2 to fib(n.toInt).toInt) {\n           \
    \ if (primes(i)) {\n                count += 1\n                if (count == n)\
    \ return i\n            }\n        }\n        return 0", "        var fib : Long\
    \ = 1\n        var count : Long = 0\n        var i : Long = 1\n        while (count\
    \ < n) {\n            if (isPrime(fib)) count += 1\n            val temp = fib\n\
    \            fib += i\n            i = temp\n        }\n        fib", "      \
    \  var i = 1\n        var j = 1\n        var k = 1\n        while (k < n) {\n\
    \            val t = i + j\n            if (isPrime(t)) k += 1\n            i\
    \ = j\n            j = t\n        }\n        j", "        var i = 1\n        var\
    \ j = 1\n        var k = 2\n        var count = 0\n        while (count < n) {\n\
    \            if (isPrime(k)) {\n                count += 1\n            }\n  \
    \          i = j\n            j = k\n            k = i + j\n        }\n      \
    \  return k", "        var fib = new Array[Long](n.toInt)\n        fib(0) = 1\n\
    \        fib(1) = 2\n        var i = 2\n        while (i < n) {\n            fib(i)\
    \ = fib(i - 1) + fib(i - 2)\n            i += 1\n        }\n        fib(n.toInt\
    \ - 1)", "        val fibs = new ArrayBuffer[Long]()\n        fibs += 1\n    \
    \    fibs += 2\n        var i = 2\n        while (fibs.size < n) {\n         \
    \   fibs += fibs(i - 1) + fibs(i - 2)\n            i += 1\n        }\n       \
    \ fibs(n.toInt - 1)", "        var pf = new ArrayBuffer[Long]\n        pf += 1\n\
    \        pf += 2\n        var i = 2\n        var j = 3\n        while (i <= n)\
    \ {\n            if (j.isPrime) {\n                pf += j\n                i\
    \ += 1\n            }\n            j += 1\n        }\n        return pf(n.toInt\
    \ - 1)", "        var i = 0;\n        var j = 1;\n        var k = 0;\n       \
    \ var count = 0;\n        while (count < n) {\n            k = i + j;\n      \
    \      i = j;\n            j = k;\n            if (isPrime(k)) count += 1;\n \
    \       }\n        return k;", "        var a = 1L; var b = 1L; var c = 2L; var\
    \ i = 3L;\n        while (i <= n) {\n            c = a + b;\n            if (isPrime(c))\
    \ {\n                i += 1;\n            }\n            a = b;\n            b\
    \ = c;\n        }\n        return c;", "        var pf = new ArrayBuffer[Long]()\n\
    \        var fib = new ArrayBuffer[Long]()\n        var i = 0\n        var j =\
    \ 0\n        while (pf.length < n) {\n            if (i == fib.length) {\n   \
    \             fib += fib(j) + fib(j + 1)\n                i += 1\n           \
    \ }\n            if (j == fib.length - 1) {\n                j = 0\n         \
    \   } else {\n                j += 1\n            }\n            if (isPrime(fib(i)))\
    \ {\n                pf += fib(i)\n            }\n        }\n        pf(n.toInt\
    \ - 1)", "        var fibs = new ArrayBuffer[Long]();\n        fibs += 1; fibs\
    \ += 2;\n        var i = 2;\n        while (i <= n) {\n            fibs += fibs(i\
    \ - 1) + fibs(i - 2);\n            if (fibs(i) % 2 == 0) {\n                fibs(i)\
    \ = fibs(i) / 2;\n                i += 1;\n            }\n        }\n        fibs(n.toInt\
    \ - 1)", "        var i = 0\n        var j = 1\n        var k = 0\n        var\
    \ count = 0\n        while (count < n) {\n            k = i + j\n            if\
    \ (isPrime(k)) count += 1\n            i = j\n            j = k\n        }\n \
    \       return k", "        var i = 0\n        var j = 1\n        var k = 0\n\
    \        var count = 0\n        while (count < n) {\n            k = i + j\n \
    \           i = j\n            j = k\n            if (isPrime(k)) count += 1\n\
    \        }\n        return k", "        var count = 0\n        var i = 1\n   \
    \     while (count < n) {\n            if (isPrime(fib(i))) {\n              \
    \  count += 1\n            }\n            i += 1\n        }\n        fib(i - 1)",
  "        var i = 1\n        var j = 1\n        var k = 1\n        while (k < n)\
    \ {\n            val t = i + j\n            if (t.isPrime) {\n               \
    \ k += 1\n            }\n            i = j\n            j = t\n        }\n   \
    \     j", "        var i = 1\n        var j = 1\n        var k = 1\n        var\
    \ count = 0\n        while (count < n) {\n            k = i + j\n            if\
    \ (isPrime(k)) {\n                count += 1\n            }\n            i = j\n\
    \            j = k\n        }\n        return k", "        var a = 1L; var b =\
    \ 1L; var c = 0L; var i = 0L\n        while (i < n) {\n            c = a + b;\
    \ a = b; b = c\n            if (isPrime(c)) i += 1\n        }\n        return\
    \ c", "        var fib = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n  \
    \      fib(1) = 1\n        for (i <- 2 to n.toInt) {\n            fib(i) = fib(i\
    \ - 1) + fib(i - 2)\n        }\n        var primes = new Array[Boolean](fib(n.toInt).toInt\
    \ + 1)\n        for (i <- 2 to fib(n.toInt).toInt) {\n            primes(i) =\
    \ true\n        }\n        for (i <- 2 to sqrt(fib(n.toInt).toDouble).toInt) {\n\
    \            if (primes(i)) {\n                var k = i * i\n               \
    \ while (k <= fib(n.toInt).toInt) {\n                    primes(k) = false\n \
    \                   k += i\n                }\n            }\n        }\n    \
    \    var count = 0\n        for (i <- 2 to fib(n.toInt).toInt) {\n           \
    \ if (primes(i)) {\n                count += 1\n                if (count == n)\
    \ return i\n            }\n        }\n        return -1", "        var fibs =\
    \ new ArrayBuffer[Long]()\n        fibs += 1\n        fibs += 2\n        var i\
    \ = 2\n        while (i < n) {\n            fibs += fibs(i - 1) + fibs(i - 2)\n\
    \            i += 1\n        }\n        return fibs(n.toInt - 1)", "        var\
    \ fibs = new ArrayBuffer[Long]()\n        fibs += 0\n        fibs += 1\n     \
    \   var i = 2\n        while (fibs.length < n) {\n            fibs += fibs(i -\
    \ 1) + fibs(i - 2)\n            i += 1\n        }\n        fibs(n.toInt - 1)",
  "        var i = 1\n        var j = 1\n        var k = 1\n        while (k < n)\
    \ {\n            val t = i + j\n            if (BigInt(t).isProbablePrime(10))\
    \ k += 1\n            i = j\n            j = t\n        }\n        i", "     \
    \   var fib = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1)\
    \ = 1\n        for (i <- 2 to n.toInt) {\n            fib(i) = fib(i - 1) + fib(i\
    \ - 2)\n        }\n        var primes = new Array[Boolean](fib(n.toInt).toInt\
    \ + 1)\n        for (i <- 2 to fib(n.toInt).toInt) {\n            primes(i) =\
    \ true\n        }\n        for (i <- 2 to sqrt(fib(n.toInt).toDouble).toInt) {\n\
    \            if (primes(i)) {\n                var j = i * i\n               \
    \ while (j <= fib(n.toInt).toInt) {\n                    primes(j) = false\n \
    \                   j += i\n                }\n            }\n        }\n    \
    \    var count = 0\n        for (i <- 2 to fib(n.toInt).toInt) {\n           \
    \ if (primes(i)) {\n                count += 1\n                if (count == n)\
    \ return i\n            }\n        }\n        return -1", "        var fibs =\
    \ new ArrayBuffer[Long]();\n        fibs += 1; fibs += 2;\n        var i = 2;\n\
    \        while (fibs.length < n) {\n            fibs += fibs(i - 1) + fibs(i -\
    \ 2);\n            i += 1;\n        }\n        fibs(n.toInt - 1)", "        var\
    \ a = 1L; var b = 1L; var c = 1L; var i = 2L;\n        while (i <= n) {\n    \
    \        c = a + b;\n            if (isPrime(c)) {\n                i += 1;\n\
    \            }\n            a = b;\n            b = c;\n        }\n        return\
    \ c;", "        var i = 1\n        var j = 1\n        var count = 0\n        while\
    \ (count < n) {\n            val k = i + j\n            if (isPrime(k)) count\
    \ += 1\n            i = j\n            j = k\n        }\n        return j", " \
    \       var i = 1\n        var count = 0\n        var result = 0L\n        while\
    \ (count < n) {\n            if (isPrime(i) && isFib(i)) {\n                count\
    \ += 1\n                result = i\n            }\n            i += 1\n      \
    \  }\n        result", "        var count = 0\n        var i = 1\n        var\
    \ fib = 1\n        while (count < n) {\n            fib = fibonacci(i)\n     \
    \       if (isPrime(fib)) count += 1\n            i += 1\n        }\n        fib",
  "        var fibs = new ArrayBuffer[Long]();\n        fibs += 1; fibs += 2;\n  \
    \      var i = 2;\n        while (i < n) {\n            fibs += fibs(i - 1) +\
    \ fibs(i - 2);\n            i += 1;\n        }\n        return fibs(n.toInt -\
    \ 1);", "        var fibs = new ArrayBuffer[Long]();\n        fibs += 1; fibs\
    \ += 2;\n        var i = 2;\n        while (fibs.length < n) {\n            fibs\
    \ += fibs(i - 1) + fibs(i - 2);\n            i += 1;\n        }\n        fibs(n.toInt\
    \ - 1)", "        val fib = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n\
    \        fib(1) = 1\n        for (i <- 2 to n.toInt) {\n            fib(i) = fib(i\
    \ - 1) + fib(i - 2)\n        }\n        var i = 0\n        while (i < n.toInt)\
    \ {\n            if (isPrime(fib(i))) return fib(i)\n            i += 1\n    \
    \    }\n        0", "        var count = 0\n        var i = 0\n        var fib\
    \ = 0\n        while (count < n) {\n            fib = fibonacci(i)\n         \
    \   if (isPrime(fib)) count += 1\n            i += 1\n        }\n        fib",
  "        var fib = new Array[Long](n.toInt)\n        fib(0) = 1\n        fib(1)\
    \ = 2\n        var i = 2\n        while (i < n) {\n            fib(i) = fib(i\
    \ - 1) + fib(i - 2)\n            i += 1\n        }\n        fib(n.toInt - 1)",
  "        var i = 1\n        var count = 0\n        while (count < n) {\n       \
    \     i += 1\n            if (isPrime(i)) {\n                if (isFib(i)) {\n\
    \                    count += 1\n                }\n            }\n        }\n\
    \        return i", "        val fibs = new ArrayBuffer[Long]\n        fibs +=\
    \ 1\n        fibs += 2\n        var i = 2\n        while (i <= n) {\n        \
    \    fibs += fibs(i - 1) + fibs(i - 2)\n            i += 1\n        }\n      \
    \  fibs(n.toInt - 1)", "        var i = 0\n        var j = 1\n        var k =\
    \ 0\n        var count = 0\n        while (count < n) {\n            k = i + j\n\
    \            if (k.isPrime) count += 1\n            i = j\n            j = k\n\
    \        }\n        return k", "        var i = 1\n        var j = 1\n       \
    \ var k = 1\n        while (k < n) {\n            val t = i + j\n            if\
    \ (t.isPrime) k += 1\n            i = j\n            j = t\n        }\n      \
    \  j", "        var i = 0\n        var j = 1\n        var k = 0\n        var count\
    \ = 1\n        while (count < n) {\n            k = i + j\n            i = j\n\
    \            j = k\n            if (isPrime(k)) count += 1\n        }\n      \
    \  k", "        var fibs = new ArrayBuffer[Long]();\n        fibs += 1; fibs +=\
    \ 2;\n        var i = 2;\n        while (i <= n) {\n            fibs += fibs(i\
    \ - 1) + fibs(i - 2);\n            i += 1;\n        }\n        return fibs(n.toInt\
    \ - 1);", "        var i = 1\n        var j = 1\n        var k = 1\n        while\
    \ (k < n) {\n            val t = i + j\n            if (t.isPrime) {\n       \
    \         k += 1\n            }\n            i = j\n            j = t\n      \
    \  }\n        j", "        var fib = new Array[Long](n.toInt + 1)\n        fib(0)\
    \ = 0\n        fib(1) = 1\n        for (i <- 2 to n.toInt) fib(i) = fib(i - 1)\
    \ + fib(i - 2)\n        var primes = new Array[Boolean](fib(n.toInt).toInt + 1)\n\
    \        for (i <- 2 to fib(n.toInt).toInt) primes(i) = true\n        for (i <-\
    \ 2 to sqrt(fib(n.toInt).toDouble).toInt) {\n            if (primes(i)) {\n  \
    \              var k = i * i\n                while (k <= fib(n.toInt)) {\n  \
    \                  primes(k) = false\n                    k += i\n           \
    \     }\n            }\n        }\n        var result = 0\n        for (i <- 0\
    \ to n.toInt) {\n            if (primes(fib(i).toInt)) result = fib(i).toInt\n\
    \        }\n        return result", "        var i = 0\n        var j = 1\n  \
    \      var k = 0\n        var count = 0\n        while (count < n) {\n       \
    \     k = i + j\n            if (isPrime(k)) count += 1\n            i = j\n \
    \           j = k\n        }\n        return k", "        val fib = new Array[Long](n.toInt)\n\
    \        fib(0) = 1\n        fib(1) = 2\n        for (i <- 2 to n.toInt - 1) fib(i)\
    \ = fib(i - 1) + fib(i - 2)\n        var i = 0\n        while (i < n.toInt) {\n\
    \            if (isPrime(fib(i))) return fib(i)\n            i += 1\n        }\n\
    \        return 0", "        var i = 0\n        var j = 1\n        var k = 1\n\
    \        var count = 0\n        while (count < n) {\n            k = i + j\n \
    \           i = j\n            j = k\n            if (isPrime(k)) count += 1\n\
    \        }\n        return k", "        var count = 0\n        var i = 1\n   \
    \     var fib = 1\n        while (count != n) {\n            if (isPrime(fib))\
    \ {\n                count += 1\n            }\n            i += 1\n         \
    \   fib = fibonacci(i)\n        }\n        fib", "        var count = 0\n    \
    \    var i = 0\n        var fib = 0\n        while (count < n) {\n           \
    \ fib = fibonacci(i)\n            if (isPrime(fib)) count += 1\n            i\
    \ += 1\n        }\n        fib", "        var fib = new Array[Long](n.toInt +\
    \ 1)\n        fib(0) = 0\n        fib(1) = 1\n        var i = 2\n        while\
    \ (i <= n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n\
    \        }\n        fib(n.toInt)", "        var a = 1L; var b = 1L; var c = 2L;\
    \ var i = 2L;\n        while (i < n) {\n            c = a + b; a = b; b = c;\n\
    \            if (isPrime(c)) i += 1;\n        }\n        return c;", "       \
    \ var fib = new Fibonacci()\n        var i = 0\n        var p = 0L\n        while\
    \ (i < n) {\n            p = fib.next\n            if (isPrime(p)) i += 1\n  \
    \      }\n        return p", "        var fibs = new ArrayBuffer[Long]()\n   \
    \     fibs += 1\n        fibs += 2\n        var i = 2\n        while (fibs.length\
    \ < n) {\n            fibs += fibs(i - 1) + fibs(i - 2)\n            i += 1\n\
    \        }\n        fibs(n.toInt - 1)", "        var count = 0\n        var i\
    \ = 1\n        while (count < n) {\n            if (isPrime(fib(i))) count +=\
    \ 1\n            i += 1\n        }\n        fib(i - 1)", "        var fib = new\
    \ Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1) = 1\n        for\
    \ (i <- 2 to n.toInt) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n      \
    \  }\n        return fib(n.toInt)", "        var i = 1\n        var j = 1\n  \
    \      var k = 2\n        var count = 1\n        while (count < n) {\n       \
    \     if (isPrime(k)) count += 1\n            i = j\n            j = k\n     \
    \       k = i + j\n        }\n        return k", "        var fib = new Array[Long](n.toInt\
    \ + 1)\n        fib(0) = 0\n        fib(1) = 1\n        for (i <- 2 to n.toInt)\
    \ {\n            fib(i) = fib(i - 1) + fib(i - 2)\n        }\n        var primes\
    \ = new Array[Boolean](fib(n.toInt).toInt + 1)\n        for (i <- 2 to fib(n.toInt).toInt)\
    \ {\n            primes(i) = true\n        }\n        for (i <- 2 to sqrt(fib(n.toInt).toDouble).toInt)\
    \ {\n            if (primes(i)) {\n                var j = i * i\n           \
    \     while (j <= fib(n.toInt).toInt) {\n                    primes(j) = false\n\
    \                    j += i\n                }\n            }\n        }\n   \
    \     var count = 0\n        for (i <- 2 to fib(n.toInt).toInt) {\n          \
    \  if (primes(i)) {\n                count += 1\n                if (count ==\
    \ n) return i\n            }\n        }\n        return 0", "        var fib =\
    \ new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1) = 1\n     \
    \   fib(2) = 2\n        var i = 3\n        while (i <= n) {\n            fib(i)\
    \ = fib(i - 1) + fib(i - 2)\n            i += 1\n        }\n        fib(n.toInt)",
  "        var fibs = new ArrayBuffer[Long]();\n        fibs += 1; fibs += 2;\n  \
    \      var i = 2;\n        while (i <= n) {\n            fibs += fibs(i - 1) +\
    \ fibs(i - 2);\n            if (fibs(i) % 2 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 3 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 5 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 7 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 11 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 13 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 17 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 19 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 23 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 29 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 31 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 37 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 41 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 43 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 47 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 53 == 0) {\n                fibs.remove(i);\n\
    \            } else if (fibs(i) % 59 == 0) {\n                fib", "        var\
    \ count = 0\n        var i = 0\n        while (count < n) {\n            i +=\
    \ 1\n            if (isPrime(i)) {\n                val fib = fibonacci(i)\n \
    \               if (isPrime(fib)) count += 1\n            }\n        }\n     \
    \   fibonacci(i)", "        var fibs = new ArrayBuffer[Long]();\n        fibs\
    \ += 1; fibs += 2;\n        var i = 2;\n        while (i <= n) {\n           \
    \ fibs += fibs(i - 1) + fibs(i - 2);\n            i += 1;\n        }\n       \
    \ return fibs(n.toInt - 1);", "        var fib = new Array[Long](n.toInt + 1)\n\
    \        fib(0) = 0\n        fib(1) = 1\n        for (i <- 2 to n.toInt) {\n \
    \           fib(i) = fib(i - 1) + fib(i - 2)\n        }\n        var primes =\
    \ new Array[Boolean](fib(n.toInt).toInt + 1)\n        for (i <- 2 to fib(n.toInt).toInt)\
    \ {\n            primes(i) = true\n        }\n        for (i <- 2 to sqrt(fib(n.toInt).toDouble).toInt)\
    \ {\n            if (primes(i)) {\n                var k = i * i\n           \
    \     while (k <= fib(n.toInt).toInt) {\n                    primes(k) = false\n\
    \                    k += i\n                }\n            }\n        }\n   \
    \     var count = 0\n        for (i <- 2 to fib(n.toInt).toInt) {\n          \
    \  if (primes(i)) {\n                count += 1\n                if (count ==\
    \ n) return i\n            }\n        }\n        return -1", "        var fib\
    \ = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1) = 1\n   \
    \     var i = 2\n        while (i <= n) {\n            fib(i) = fib(i - 1) + fib(i\
    \ - 2)\n            i += 1\n        }\n        fib(n.toInt)", "        var i =\
    \ 1\n        var count = 0\n        var fib = 1\n        while (count < n) {\n\
    \            fib = fibonacci(i)\n            if (isPrime(fib)) count += 1\n  \
    \          i += 1\n        }\n        fib", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 1; fibs += 2;\n        var i = 2;\n        while (fibs.length\
    \ < n) {\n            fibs += fibs(i - 1) + fibs(i - 2);\n            i += 1;\n\
    \        }\n        return fibs(n - 1);", "        val fib = new Array[Long](n.toInt\
    \ + 1)\n        fib(0) = 1\n        fib(1) = 1\n        for (i <- 2 to n.toInt)\
    \ {\n            fib(i) = fib(i - 1) + fib(i - 2)\n        }\n        var i =\
    \ n.toInt\n        while (!isPrime(fib(i))) {\n            i -= 1\n        }\n\
    \        fib(i)", "        var i = 1\n        var j = 1\n        var k = 0\n \
    \       var count = 0\n        while (count < n) {\n            k = i + j\n  \
    \          if (k.isPrime) count += 1\n            i = j\n            j = k\n \
    \       }\n        k", "        var fibs = new HashMap[Long, Long]()\n       \
    \ fibs(0) = 0\n        fibs(1) = 1\n        var i = 2\n        var result = 0L\n\
    \        while (true) {\n            fibs(i) = fibs(i - 1) + fibs(i - 2)\n   \
    \         if (fibs(i) > 10000000000L) {\n                break\n            }\n\
    \            if (isPrime(fibs(i))) {\n                result += 1\n          \
    \      if (result == n) {\n                    return fibs(i)\n              \
    \  }\n            }\n            i += 1\n        }\n        return -1", "    \
    \    var fib = new Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1)\
    \ = 1\n        var i = 2\n        while (i <= n) {\n            fib(i) = fib(i\
    \ - 1) + fib(i - 2)\n            i += 1\n        }\n        fib(n.toInt)", " \
    \       var a = 0L\n        var b = 1L\n        var c = 0L\n        var i = 0L\n\
    \        while (i < n) {\n            c = a + b\n            a = b\n         \
    \   b = c\n            if (isPrime(c)) i += 1\n        }\n        return c", " \
    \       var fibs = new ArrayBuffer[Long]();\n        fibs += 1; fibs += 2;\n \
    \       var i = 2;\n        while (i <= n) {\n            fibs += fibs(i - 1)\
    \ + fibs(i - 2);\n            i += 1;\n        }\n        return fibs(n.toInt\
    \ - 1);", "        var i = 0\n        var j = 1\n        var k = 0\n        var\
    \ count = 0\n        while (count < n) {\n            k = i + j\n            if\
    \ (isPrime(k)) count += 1\n            i = j\n            j = k\n        }\n \
    \       k", "        var fib = new Array[Long](n.toInt + 1)\n        fib(0) =\
    \ 0\n        fib(1) = 1\n        for (i <- 2 to n.toInt) {\n            fib(i)\
    \ = fib(i - 1) + fib(i - 2)\n        }\n        var primes = new Array[Boolean](fib(n.toInt).toInt\
    \ + 1)\n        for (i <- 2 to fib(n.toInt).toInt) {\n            primes(i) =\
    \ true\n        }\n        for (i <- 2 to sqrt(fib(n.toInt).toDouble).toInt) {\n\
    \            if (primes(i)) {\n                var k = i * i\n               \
    \ while (k <= fib(n.toInt).toInt) {\n                    primes(k) = false\n \
    \                   k += i\n                }\n            }\n        }\n    \
    \    var count = 0\n        for (i <- 2 to fib(n.toInt).toInt) {\n           \
    \ if (primes(i)) {\n                count += 1\n                if (count == n)\
    \ return i\n            }\n        }\n        return -1", "        var count =\
    \ 0\n        var i = 1\n        var fib = 1\n        while (count < n) {\n   \
    \         if (isPrime(fib)) {\n                count += 1\n            }\n   \
    \         i += 1\n            fib = fibonacci(i)\n        }\n        fib", " \
    \       var i = 1\n        var j = 1\n        var k = 1\n        while (k < n)\
    \ {\n            val t = i + j\n            if (isPrime(t)) k += 1\n         \
    \   i = j\n            j = t\n        }\n        j", "        val fibs = new ArrayBuffer[Long]\n\
    \        fibs += 1\n        fibs += 2\n        var i = 2\n        while (i <=\
    \ n) {\n            fibs += fibs(i - 1) + fibs(i - 2)\n            i += 1\n  \
    \      }\n        fibs(n.toInt - 1)", "        var fibs = new ArrayBuffer[Long]()\n\
    \        fibs += 1\n        fibs += 2\n        var i = 2\n        while (fibs.size\
    \ < n) {\n            fibs += fibs(i - 1) + fibs(i - 2)\n            i += 1\n\
    \        }\n        var j = fibs.size - 1\n        while (!isPrime(fibs(j))) {\n\
    \            j -= 1\n        }\n        fibs(j)", "        var fibs = new ArrayBuffer[Long]()\n\
    \        fibs += 1\n        fibs += 2\n        var i = 2\n        while (fibs.length\
    \ < n) {\n            fibs += fibs(i - 1) + fibs(i - 2)\n            i += 1\n\
    \        }\n        return fibs(n - 1)", "        var i = 1\n        var j = 1\n\
    \        var k = 1\n        var count = 0\n        while (count < n) {\n     \
    \       k = i + j\n            if (isPrime(k)) count += 1\n            i = j\n\
    \            j = k\n        }\n        return k", "        var a = 1L; var b =\
    \ 1L; var c = 2L; var i = 2L;\n        while (i <= n) {\n            c = a + b;\
    \ a = b; b = c;\n            if (isPrime(c)) i += 1;\n        }\n        return\
    \ c;", "        var count = 0\n        var i = 0\n        while (count < n) {\n\
    \            i += 1\n            if (isPrime(fib(i))) count += 1\n        }\n\
    \        fib(i)", "        var i = 0;\n        var fib = 0;\n        var fib_prev\
    \ = 0;\n        while (i < n) {\n            fib = if (i == 0) 1 else if (i ==\
    \ 1) 2 else fib + fib_prev;\n            fib_prev = if (i == 0) 0 else fib - fib_prev;\n\
    \            if (fib.isPrime) i += 1;\n        }\n        fib", "        var i\
    \ = 1\n        var j = 1\n        var k = 0\n        var count = 0\n        while\
    \ (count < n) {\n            k = i + j\n            i = j\n            j = k\n\
    \            if (isPrime(k)) count += 1\n        }\n        return k", "     \
    \   var i = 0\n        var j = 1\n        var k = 0\n        var count = 0\n \
    \       while (count < n) {\n            k = i + j\n            if (isPrime(k))\
    \ {\n                count += 1\n            }\n            i = j\n          \
    \  j = k\n        }\n        return k", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 1; fibs += 2;\n        var i = 2;\n        while (i < n) {\n\
    \            fibs += fibs(i - 1) + fibs(i - 2);\n            i += 1;\n       \
    \ }\n        return fibs(n.toInt - 1);", "        var i = 0\n        var j = 0\n\
    \        var f = 0L\n        var p = 0L\n        var c = 0L\n        while (c\
    \ < n) {\n            f = fib(i)\n            if (isPrime(f)) {\n            \
    \    c += 1\n                p = f\n            }\n            i += 1\n      \
    \  }\n        return p", "        var fibs = new ArrayBuffer[Long]()\n       \
    \ fibs += 1\n        fibs += 2\n        var i = 2\n        while (i < n) {\n \
    \           fibs += fibs(i - 1) + fibs(i - 2)\n            i += 1\n        }\n\
    \        return fibs(n.toInt - 1)", "        var fib = new Array[Long](n.toInt)\n\
    \        fib(0) = 1\n        fib(1) = 2\n        var i = 2\n        while (i <\
    \ n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n   \
    \     }\n        fib(n.toInt - 1)", "        val primes = new PrimeSet(1000000)\n\
    \        var i = 0\n        var j = 1\n        var k = 0\n        while (i < n)\
    \ {\n            k = j\n            j = j + k\n            if (primes.isPrime(j))\
    \ i += 1\n        }\n        j", "        val fib = new Array[Long](n.toInt)\n\
    \        fib(0) = 1\n        fib(1) = 2\n        for (i <- 2 to n.toInt - 1) {\n\
    \            fib(i) = fib(i - 1) + fib(i - 2)\n        }\n        var count =\
    \ 0\n        for (i <- 0 to n.toInt - 1) {\n            if (isPrime(fib(i))) {\n\
    \                count += 1\n                if (count == n) return fib(i)\n \
    \           }\n        }\n        return -1", "        var i = 0\n        var\
    \ j = 1\n        var count = 0\n        while (count < n) {\n            val k\
    \ = i + j\n            if (isPrime(k)) count += 1\n            i = j\n       \
    \     j = k\n        }\n        return j", "        var fib = new Array[Long](n.toInt)\n\
    \        fib(0) = 1\n        fib(1) = 2\n        var i = 2\n        while (i <\
    \ n) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n            i += 1\n   \
    \     }\n        return fib(n.toInt - 1)", "        var count = 0L\n        var\
    \ i = 1L\n        while (count < n) {\n            if (isPrime(fib(i))) count\
    \ += 1\n            i += 1\n        }\n        fib(i - 1)", "        var fibs\
    \ = new ArrayBuffer[Long]()\n        fibs += 1\n        fibs += 2\n        var\
    \ i = 2\n        while (i <= n) {\n            fibs += fibs(i - 1) + fibs(i -\
    \ 2)\n            i += 1\n        }\n        fibs(n.toInt - 1)", "        var\
    \ i = 1; var j = 1; var k = 0; var count = 0\n        while (count < n) {\n  \
    \          k = i + j; i = j; j = k\n            if (isPrime(k)) count += 1\n \
    \       }\n        k", "        var fib = new Array[Long](n.toInt + 1)\n     \
    \   fib(0) = 0\n        fib(1) = 1\n        for (i <- 2 to n.toInt) {\n      \
    \      fib(i) = fib(i - 1) + fib(i - 2)\n        }\n        var primes = new Array[Boolean](fib(n.toInt).toInt\
    \ + 1)\n        for (i <- 2 to fib(n.toInt).toInt) {\n            primes(i) =\
    \ true\n        }\n        for (i <- 2 to sqrt(fib(n.toInt).toDouble).toInt) {\n\
    \            if (primes(i)) {\n                var k = i * i\n               \
    \ while (k <= fib(n.toInt).toInt) {\n                    primes(k) = false\n \
    \                   k += i\n                }\n            }\n        }\n    \
    \    var count = 0\n        for (i <- 2 to fib(n.toInt).toInt) {\n           \
    \ if (primes(i)) {\n                count += 1\n                if (count == n)\
    \ return i\n            }\n        }\n        return 0", "        var p = new\
    \ Prime(n * log(n).toLong)\n        var i = 0\n        var f = 1\n        var\
    \ f1 = 1\n        var f2 = 1\n        while (i < n) {\n            f = f1 + f2\n\
    \            if (p.isPrime(f)) i += 1\n            f2 = f1\n            f1 = f\n\
    \        }\n        return f", "        var i = 0\n        var j = 1\n       \
    \ var k = 1\n        var count = 0\n        while (count < n) {\n            if\
    \ (isPrime(k)) {\n                count += 1\n            }\n            val temp\
    \ = j\n            j = i + j\n            i = temp\n            k += 1\n     \
    \   }\n        k - 1", "        var count = 0\n        var i = 1\n        while\
    \ (count < n) {\n            if (isPrime(fib(i))) {\n                count +=\
    \ 1\n            }\n            i += 1\n        }\n        return fib(i - 1)",
  "        var i = 0\n        var j = 0\n        var fib = 0\n        var prime =\
    \ 0\n        while (i < n) {\n            fib = fibonacci(j)\n            if (isPrime(fib))\
    \ {\n                i += 1\n                prime = fib\n            }\n    \
    \        j += 1\n        }\n        prime", "        val fib = new Array[Long](n.toInt)\n\
    \        fib(0) = 1\n        fib(1) = 2\n        for (i <- 2 to n.toInt - 1) {\n\
    \            fib(i) = fib(i - 1) + fib(i - 2)\n        }\n        def isPrime(n\
    \ : Long) : Boolean = {\n            if (n == 1) return false\n            if\
    \ (n == 2) return true\n            if (n % 2 == 0) return false\n           \
    \ for (i <- 3 to sqrt(n).toInt by 2) {\n                if (n % i == 0) return\
    \ false\n            }\n            return true\n        }\n        for (i <-\
    \ 0 to n.toInt - 1) {\n            if (isPrime(fib(i))) return fib(i)\n      \
    \  }\n        return 0", "        var i = 0;\n        var j = 1;\n        var\
    \ k = 0;\n        var count = 0;\n        while (count < n) {\n            k =\
    \ i + j;\n            i = j;\n            j = k;\n            if (isPrime(k))\
    \ count += 1;\n        }\n        return k;", "        var i = 0\n        var\
    \ j = 1\n        var k = 0\n        var count = 0\n        while (count < n) {\n\
    \            k = i + j\n            if (isPrime(k)) count += 1\n            i\
    \ = j\n            j = k\n        }\n        return k", "        var fib = new\
    \ Array[Long](n.toInt + 1)\n        fib(0) = 0\n        fib(1) = 1\n        for\
    \ (i <- 2 to n.toInt) {\n            fib(i) = fib(i - 1) + fib(i - 2)\n      \
    \  }\n        var primes = new Array[Boolean](fib(n.toInt).toInt + 1)\n      \
    \  for (i <- 2 to fib(n.toInt).toInt) {\n            primes(i) = true\n      \
    \  }\n        for (i <- 2 to sqrt(fib(n.toInt).toDouble).toInt) {\n          \
    \  if (primes(i)) {\n                var j = i * i\n                while (j <=\
    \ fib(n.toInt).toInt) {\n                    primes(j) = false\n             \
    \       j += i\n                }\n            }\n        }\n        var count\
    \ = 0\n        for (i <- 2 to fib(n.toInt).toInt) {\n            if (primes(i))\
    \ {\n                count += 1\n                if (count == n) return i\n  \
    \          }\n        }\n        return -1", "        var count = 0\n        var\
    \ i = 1\n        while (count < n) {\n            if (isPrime(fib(i))) {\n   \
    \             count += 1\n            }\n            i += 1\n        }\n     \
    \   fib(i - 1)", "        var i = 0\n        var j = 1\n        var k = 1\n  \
    \      var count = 0\n        while (count < n) {\n            k = i + j\n   \
    \         i = j\n            j = k\n            if (isPrime(k)) count += 1\n \
    \       }\n        return k", "        var count = 0\n        var i = 0\n    \
    \    while (count < n) {\n            i += 1\n            if (isPrime(fib(i)))\
    \ count += 1\n        }\n        fib(i)", "        var count = 0\n        var\
    \ i = 2\n        while (count < n) {\n            if (isPrime(i) && isFib(i))\
    \ {\n                count += 1\n            }\n            i += 1\n        }\n\
    \        return i - 1", "        val fib = new Array[Long](n.toInt + 1)\n    \
    \    fib(0) = 1\n        fib(1) = 1\n        for (i <- 2 to n.toInt) {\n     \
    \       fib(i) = fib(i - 1) + fib(i - 2)\n        }\n        var i = n.toInt\n\
    \        while (true) {\n            if (isPrime(fib(i))) return fib(i)\n    \
    \        i -= 1\n        }\n        return -1", "        var fibs = new ArrayBuffer[Long]();\n\
    \        fibs += 1; fibs += 2;\n        var i = 2;\n        while (i <= n) {\n\
    \            fibs += fibs(i - 1) + fibs(i - 2);\n            i += 1;\n       \
    \ }\n        return fibs(n.toInt - 1);", "        var i = 1\n        var j = 1\n\
    \        var k = 0\n        var count = 0\n        while (count < n) {\n     \
    \       k = i + j\n            if (isPrime(k)) count += 1\n            i = j\n\
    \            j = k\n        }\n        return k", "        val fibs = new ArrayBuffer[Long]()\n\
    \        fibs += 1\n        fibs += 2\n        var i = 2\n        while (i < n)\
    \ {\n            fibs += fibs(i - 1) + fibs(i - 2)\n            i += 1\n     \
    \   }\n        fibs(i - 1)", "        var fibs = new ArrayBuffer[Long]();\n  \
    \      fibs += 1; fibs += 2;\n        var i = 2;\n        while (fibs.length <\
    \ n) {\n            fibs += fibs(i - 1) + fibs(i - 2);\n            i += 1;\n\
    \        }\n        return fibs(n - 1);", "        val fib = new Array[Long](n.toInt\
    \ + 1)\n        fib(0) = 0\n        fib(1) = 1\n        for (i <- 2 to n.toInt)\
    \ fib(i) = fib(i - 1) + fib(i - 2)\n        var i = 0\n        while (i < n.toInt)\
    \ {\n            if (isPrime(fib(i))) return fib(i)\n            i += 1\n    \
    \    }\n        -1", "        var i = 1\n        var j = 1\n        var k = 1\n\
    \        var count = 0\n        while (count < n) {\n            k = i + j\n \
    \           if (isPrime(k)) {\n                count += 1\n            }\n   \
    \         i = j\n            j = k\n        }\n        return k", "        var\
    \ i = 1\n        var j = 1\n        var count = 1\n        while (count < n) {\n\
    \            val k = i + j\n            if (isPrime(k)) {\n                count\
    \ += 1\n            }\n            i = j\n            j = k\n        }\n     \
    \   j", "        var i = 0\n        var j = 1\n        var k = 1\n        while\
    \ (i < n) {\n            val t = j + k\n            j = k\n            k = t\n\
    \            if (isPrime(k)) i += 1\n        }\n        k"]
stop_tokens:
- "\n    }\n"
