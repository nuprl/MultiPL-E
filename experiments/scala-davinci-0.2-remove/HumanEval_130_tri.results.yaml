language: scala
name: HumanEval_130_tri
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new HashMap[Long, Long]\n        cache(1) = 3\n        def tri(n\
    \ : Long) : Long = {\n            if (cache.contains(n)) cache(n)\n          \
    \  else {\n                val result = if (n % 2 == 0) 1 + n / 2 else tri(n -\
    \ 1) + tri(n - 2) + tri(n + 1)\n                cache(n) = result\n          \
    \      result\n            }\n        }\n        (1 to n.toInt).map(tri).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppz7yl3o6.scala:29:27\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m        (\e[31m1\e[0m to n.toInt).map(tri).toList\n\
    \e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\e[31m   |\e[0m    \
    \                       Found:    \e[1m\e[31mLong\e[0m => Long\n\e[31m   |\e[0m\
    \                           Required: \e[1m\e[32mInt\e[0m => Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new HashMap[Long, Long]\n        def tri(n : Long) : Long = {\n\
    \            if (cache.contains(n)) cache(n)\n            else {\n           \
    \     val result = if (n == 1) 3\n                else if (n % 2 == 0) 1 + n /\
    \ 2\n                else tri(n - 1) + tri(n - 2) + tri(n + 1)\n             \
    \   cache += (n -> result)\n                result\n            }\n        }\n\
    \        (1 to n + 1).map(tri(_)).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpumukowq3.scala:30:14\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        (\e[31m1\e[0m to n +\
    \ \e[31m1\e[0m).map(tri(_)).toList\n\e[31m\e[31m   |\e[0m              ^^^^^\e\
    [0m\n\e[31m   |\e[0m              Found:    Long\n\e[31m   |\e[0m            \
    \  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var a = 0L\n        var b = 3L\n \
    \       var c = 2L\n        var d = 0L\n        var result = List(a, b, c)\n \
    \       for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) d = 1 + i / 2\n\
    \            else d = a + b + c\n            result = result :+ d\n          \
    \  a = b\n            b = c\n            c = d\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5rvisfjh.scala:38)\n\tat Problem.main(tmp5rvisfjh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 1L\n        var d = 0L\n  \
    \      var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    if (i == 1) result = result :+ a\n            else if (i == 2) result = result\
    \ :+ b\n            else if (i == 3) result = result :+ c\n            else {\n\
    \                d = a + b + c\n                a = b\n                b = c\n\
    \                c = d\n                result = result :+ d\n            }\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpymxjpjec.scala:39)\n\tat Problem.main(tmpymxjpjec.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 8L\n        var d = 0L\n  \
    \      var l = List(3L, 2L, 8L)\n        for (i <- 4 to n.toInt) {\n         \
    \   d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            l = l :+ d\n   \
    \         a = b\n            b = c\n            c = d\n        }\n        return\
    \ l\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgyejk9b4.scala:34)\n\tat Problem.main(tmpgyejk9b4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var result = ListBuffer[Long]()\n        result += 3\n        for (i <- 1 to\
    \ n.toInt) {\n            if (i % 2 == 0) result += (1 + i / 2)\n            else\
    \ result += (result(i - 1) + result(i - 2) + result(i + 1))\n        }\n     \
    \   result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmp6blhig1g.scala:23)\n\tat Problem$.tri$$anonfun$adapted$1(tmp6blhig1g.scala:24)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp6blhig1g.scala:24)\n\
    \tat Problem$.main(tmp6blhig1g.scala:28)\n\tat Problem.main(tmp6blhig1g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Ma"
  stdout: ''
  timestamp: 1659979461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var result = List(0, 3)\n        var i = 2\n        while (i <= n) {\n     \
    \       if (i % 2 == 0) result = result :+ (1 + i / 2)\n            else result\
    \ = result :+ (result(i - 1) + result(i - 2) + result(i + 1))\n            i +=\
    \ 1\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe0t85phd.scala:28:15\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979460
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val result = new ListBuffer[Long]\n        result += 3\n        for (i <- 1\
    \ to n.toInt) {\n            if (i % 2 == 0) result += (1 + i / 2)\n         \
    \   else result += (result(i - 1) + result(i - 2) + result(i + 1))\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmp7_i4vbd6.scala:23)\n\tat Problem$.tri$$anonfun$adapted$1(tmp7_i4vbd6.scala:24)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp7_i4vbd6.scala:24)\n\
    \tat Problem$.main(tmp7_i4vbd6.scala:28)\n\tat Problem.main(tmp7_i4vbd6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Ma"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var result = ListBuffer[Long]()\n        result += 3\n        for (i <- 1 to\
    \ n.toInt) {\n            if (i % 2 == 0) result += (1 + i / 2)\n            else\
    \ result += (result(i - 1) + result(i - 2) + result(i + 1))\n        }\n     \
    \   result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmp6blhig1g.scala:23)\n\tat Problem$.tri$$anonfun$adapted$1(tmp6blhig1g.scala:24)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp6blhig1g.scala:24)\n\
    \tat Problem$.main(tmp6blhig1g.scala:28)\n\tat Problem.main(tmp6blhig1g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Ma"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 1L\n        var d = 0L\n  \
    \      var result = List[Long]()\n        result = result :+ a\n        for (i\
    \ <- 1 to n.toInt) {\n            if (i % 2 == 0) {\n                d = 1 + i\
    \ / 2\n                result = result :+ d\n            }\n            else {\n\
    \                d = a + b + c\n                result = result :+ d\n       \
    \         a = b\n                b = c\n                c = d\n            }\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6usvnjr2.scala:41)\n\tat Problem.main(tmp6usvnjr2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  def triRec(n : Long, l : List[Long]) : List[Long] = {\n            if (n ==\
    \ 0) l\n            else if (n == 1) triRec(n - 1, 3 :: l)\n            else if\
    \ (n % 2 == 0) triRec(n - 1, (1 + n / 2) :: l)\n            else triRec(n - 1,\
    \ (l(0) + l(1) + l(2)) :: l)\n        }\n        triRec(n, List()).reverse\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.triRec$1(tmpk3pc5_zq.scala:23)\n\tat Problem$.tri(tmpk3pc5_zq.scala:25)\n\
    \tat Problem$.main(tmpk3pc5_zq.scala:28)\n\tat Problem.main(tmpk3pc5_zq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var list = List(0, 3, 2)\n       \
    \ var i = 3\n        while (i <= n) {\n            if (i % 2 == 0) list = list\
    \ :+ (1 + i / 2)\n            else list = list :+ (list(i - 1) + list(i - 2) +\
    \ list(i + 1))\n            i += 1\n        }\n        return list\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp91iqeij2.scala:29:15\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mreturn\e[0m list\n\
    \e[31m\e[31m   |\e[0m               ^^^^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (list : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new HashMap[Long, Long]\n        def tri(n : Long) : Long = {\n\
    \            if (cache.contains(n)) cache(n)\n            else {\n           \
    \     val result = if (n == 1) 3\n                else if (n % 2 == 0) 1 + n /\
    \ 2\n                else tri(n - 1) + tri(n - 2) + tri(n + 1)\n             \
    \   cache(n) = result\n                result\n            }\n        }\n    \
    \    (1 to n.toInt).map(tri(_)).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2a6vfa67.scala:33)\n\tat Problem.main(tmp2a6vfa67.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List[Long]()\n        result :+= a\n        result :+= b\n\
    \        result :+= c\n        for (i <- 3 to n.toInt) {\n            d = if (i\
    \ % 2 == 0) 1 + i / 2 else a + b + c\n            a = b\n            b = c\n \
    \           c = d\n            result :+= d\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmvtxbpij.scala:39)\n\tat Problem.main(tmpmvtxbpij.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 1L\n        var d = 0L\n  \
    \      var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    if (i == 1) result = result :+ a\n            else if (i == 2) result = result\
    \ :+ b\n            else if (i == 3) result = result :+ c\n            else {\n\
    \                if (i % 2 == 0) {\n                    d = 1 + i / 2\n      \
    \              result = result :+ d\n                }\n                else {\n\
    \                    d = a + b + c\n                    result = result :+ d\n\
    \                    a = b\n                    b = c\n                    c =\
    \ d\n                }\n            }\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbi5d47tn.scala:45)\n\tat Problem.main(tmpbi5d47tn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var result = List(0, 3, 2)\n     \
    \   for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) result = result :+\
    \ (1 + i / 2)\n            else result = result :+ (result(i - 1) + result(i -\
    \ 2) + result(i + 1))\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3yy18gh5.scala:27:15\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var result = List(0, 3)\n        var i = 2\n        while (i <= n) {\n     \
    \       if (i % 2 == 0) result = result :+ (1 + i / 2)\n            else result\
    \ = result :+ (result(i - 1) + result(i - 2) + result(i + 1))\n            i +=\
    \ 1\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe0t85phd.scala:28:15\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979460
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var list = List(0, 3, 2)\n        for (i <- 3 to n.toInt) {\n            if\
    \ (i % 2 == 0) list = list :+ (1 + i / 2)\n            else list = list :+ (list(i\
    \ - 1) + list(i - 2) + list(i + 1))\n        }\n        return list\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmqezlcci.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m list\n\
    \e[31m\e[31m   |\e[0m               ^^^^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (list : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var result = List(a,\
    \ b, c)\n        for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) {\n  \
    \              a = b\n                b = c\n                c = 1 + i / 2\n \
    \           } else {\n                a = b\n                b = c\n         \
    \       c = a + b + c\n            }\n            result = result :+ c\n     \
    \   }\n        return result\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6i5adbvl.scala:40)\n\tat Problem.main(tmp6i5adbvl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  def tri(n : Long, a : Long, b : Long, c : Long) : List[Long] = {\n        \
    \    if (n == 0) List(a)\n            else if (n == 1) List(a, b)\n          \
    \  else if (n == 2) List(a, b, c)\n            else if (n % 2 == 0) a :: tri(n\
    \ - 1, b, c, a + b + c)\n            else a :: tri(n - 1, b, c, 1 + n / 2)\n \
    \       }\n        tri(n, 3, 1, 2)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfopemki3.scala:29)\n\tat Problem.main(tmpfopemki3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(3)\n        if\
    \ (n == 2) return List(3, 2)\n        var list = List(3, 2, 8)\n        for (i\
    \ <- 4 to n.toInt) {\n            if (i % 2 == 0) list = list :+ (1 + i / 2)\n\
    \            else list = list :+ (list(i - 1) + list(i - 2) + list(i - 3))\n \
    \       }\n        return list\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiyyrvezw.scala:27:15\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mreturn\e[0m list\n\
    \e[31m\e[31m   |\e[0m               ^^^^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (list : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979460
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new HashMap[Long, Long]\n        def tri(n : Long) : Long = {\n\
    \            if (cache.contains(n)) cache(n)\n            else {\n           \
    \     val result = if (n == 1) 3\n                else if (n % 2 == 0) 1 + n /\
    \ 2\n                else tri(n - 1) + tri(n - 2) + tri(n + 1)\n             \
    \   cache(n) = result\n                result\n            }\n        }\n    \
    \    (1 to n.toInt).map(tri(_)).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2a6vfa67.scala:33)\n\tat Problem.main(tmp2a6vfa67.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 1L\n        var d = 0L\n  \
    \      var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    if (i == 1) {\n                result = result :+ 3\n            } else if\
    \ (i == 2) {\n                result = result :+ 2\n            } else if (i ==\
    \ 3) {\n                result = result :+ 1\n            } else {\n         \
    \       d = a + b + c\n                result = result :+ d\n                a\
    \ = b\n                b = c\n                c = d\n            }\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptvwpf55e.scala:42)\n\tat Problem.main(tmptvwpf55e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var list = List(0, 3, 2)\n        for (i <- 3 to n.toInt) {\n            if\
    \ (i % 2 == 0) list = list :+ (1 + i / 2)\n            else list = list :+ (list(i\
    \ - 1) + list(i - 2) + list(i + 1))\n        }\n        return list\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmqezlcci.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m list\n\
    \e[31m\e[31m   |\e[0m               ^^^^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (list : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new HashMap[Long, Long]\n        def tri(n : Long) : Long = {\n\
    \            if (cache.contains(n)) cache(n)\n            else {\n           \
    \     val result = if (n == 1) 3\n                else if (n % 2 == 0) 1 + n /\
    \ 2\n                else tri(n - 1) + tri(n - 2) + tri(n + 1)\n             \
    \   cache(n) = result\n                result\n            }\n        }\n    \
    \    (0 to n.toInt).map(tri(_)).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new HashMap[Long, Long]\n        def tri(n : Long) : Long = {\n\
    \            if (cache.contains(n)) cache(n)\n            else {\n           \
    \     val result = if (n == 1) 3\n                else if (n % 2 == 0) 1 + n /\
    \ 2\n                else tri(n - 1) + tri(n - 2) + tri(n + 1)\n             \
    \   cache += (n -> result)\n                result\n            }\n        }\n\
    \        (1 to n.toInt).map(tri(_)).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx54fs9d_.scala:33)\n\tat Problem.main(tmpx54fs9d_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new HashMap[Long, Long]\n        def tri(n : Long) : Long = {\n\
    \            if (cache.contains(n)) cache(n)\n            else {\n           \
    \     val result = if (n == 1) 3 else if (n % 2 == 0) 1 + n / 2 else tri(n - 1)\
    \ + tri(n - 2) + tri(n + 1)\n                cache(n) = result\n             \
    \   result\n            }\n        }\n        (1 to n.toInt).map(tri).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9hzgggth.scala:28:27\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        (\e[31m1\e[0m to n.toInt).map(tri).toList\n\
    \e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\e[31m   |\e[0m    \
    \                       Found:    \e[1m\e[31mLong\e[0m => Long\n\e[31m   |\e[0m\
    \                           Required: \e[1m\e[32mInt\e[0m => Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979470
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var l = List(0, 3, 2)\n        for (i <- 3 to n.toInt) {\n            if (i\
    \ % 2 == 0) l = l :+ (1 + i / 2)\n            else l = l :+ (l(i - 1) + l(i -\
    \ 2) + l(i + 1))\n        }\n        return l\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvcyczun1.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m l\n\
    \e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (l : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979470
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var a = 0L\n        var b = 3L\n \
    \       var c = 2L\n        var d = 0L\n        var result = List(a, b, c)\n \
    \       for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) d = 1 + i / 2\n\
    \            else d = a + b + c\n            result = result :+ d\n          \
    \  a = b\n            b = c\n            c = d\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5rvisfjh.scala:38)\n\tat Problem.main(tmp5rvisfjh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) List(0)\n        else if (n == 1) List(0, 3)\n        else if (n\
    \ == 2) List(0, 3, 8)\n        else {\n            val l = tri(n - 1)\n      \
    \      val last = l.last\n            val last2 = l(l.length - 2)\n          \
    \  val last3 = l(l.length - 3)\n            if (n % 2 == 0) l :+ (1 + n / 2)\n\
    \            else l :+ (last + last2 + last3)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq3dfyqs5.scala:32)\n\tat Problem.main(tmpq3dfyqs5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979471
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var list = List(0, 3, 2)\n        for (i <- 3 to n.toInt) {\n            if\
    \ (i % 2 == 0) list = list :+ (1 + i / 2)\n            else list = list :+ (list(i\
    \ - 1) + list(i - 2) + list(i + 1))\n        }\n        return list\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmqezlcci.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m list\n\
    \e[31m\e[31m   |\e[0m               ^^^^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (list : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        else if (n == 1) return List(0, 3)\n  \
    \      else if (n == 2) return List(0, 3, 2)\n        else {\n            var\
    \ result = List(0, 3, 2)\n            for (i <- 3 to n.toInt) {\n            \
    \    if (i % 2 == 0) result = result :+ (1 + i / 2)\n                else result\
    \ = result :+ (result(i - 1) + result(i - 2) + result(i + 1))\n            }\n\
    \            return result\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpthpv1ij_.scala:28:19\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mreturn\e[0m\
    \ result\n\e[31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                   Found:    (result : List[Int])\n\e[31m   |\e[0m          \
    \         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979470
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 1L\n        var d = 0L\n  \
    \      var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    result = result :+ a\n            d = a\n            a = b + c + d\n    \
    \        b = c\n            c = d\n        }\n        return result\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4xhjl_4n.scala:34)\n\tat Problem.main(tmp4xhjl_4n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979472
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  def triHelper(n : Long, a : Long, b : Long, c : Long) : List[Long] = {\n  \
    \          if (n == 0) return List(a)\n            if (n % 2 == 0) return a ::\
    \ triHelper(n - 1, b, c, 1 + n / 2)\n            else return a :: triHelper(n\
    \ - 1, b, c, b + c + tri(n + 1))\n        }\n        triHelper(n, 3, 0, 0)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpyv0u2wu9.scala:22:58 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33melse\e[0m \e[33mreturn\e[0m a :: triHelper(n\
    \ - \e[31m1\e[0m, b, c, b + c + tri(n + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m\
    \                                                    ^^^^^^^\e[0m\n\e[31m   |\e\
    [0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m+\e[0m in \e\
    [33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\
    \e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e\
    [0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short):\
    \ Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0m (x: String): String\n\
    \e[31m   |\e[0mmatch arguments (List[Long])\n1 error found\n"
  stdout: ''
  timestamp: 1659979468
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var a = List(0, 3, 2)\n        for\
    \ (i <- 3 to n.toInt) {\n            if (i % 2 == 0) a = a :+ (1 + i / 2)\n  \
    \          else a = a :+ (a(i - 1) + a(i - 2) + a(i + 1))\n        }\n       \
    \ return a\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8e3awmj5.scala:27:15\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mreturn\e[0m a\n\
    \e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (a : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979471
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var result = List(0, 3)\n        var i = 2\n        while (i <= n) {\n     \
    \       if (i % 2 == 0) result = result :+ (1 + i / 2)\n            else result\
    \ = result :+ (result(i - 1) + result(i - 2) + result(i + 1))\n            i +=\
    \ 1\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe0t85phd.scala:28:15\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979460
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var list = List(0, 3, 2)\n        for (i <- 3 to n.toInt) {\n            if\
    \ (i % 2 == 0) list = list :+ (1 + i / 2)\n            else list = list :+ (list(i\
    \ - 1) + list(i - 2) + list(i + 1))\n        }\n        return list\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmqezlcci.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m list\n\
    \e[31m\e[31m   |\e[0m               ^^^^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (list : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var result = ListBuffer[Long]()\n        result += 3\n        for (i <- 1 to\
    \ n.toInt) {\n            if (i % 2 == 0) result += 1 + i / 2\n            else\
    \ result += result(i - 1) + result(i - 2) + result(i + 1)\n        }\n       \
    \ result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmpq2wni18x.scala:23)\n\tat Problem$.tri$$anonfun$adapted$1(tmpq2wni18x.scala:24)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpq2wni18x.scala:24)\n\
    \tat Problem$.main(tmpq2wni18x.scala:28)\n\tat Problem.main(tmpq2wni18x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Ma"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var list = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n          \
    \  if (i % 2 == 0) d = 1 + (i / 2)\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            list = list :+ d\n\
    \        }\n        return list\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd4p7koye.scala:37)\n\tat Problem.main(tmpd4p7koye.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979472
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) (i + 1) / 2 else a + b + c\n            a = b\n     \
    \       b = c\n            c = d\n            result = result :+ d\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd_wjfy3f.scala:36)\n\tat Problem.main(tmpd_wjfy3f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var a = 0L\n        var b = 3L\n \
    \       var c = 2L\n        var d = 0L\n        var result = List(a, b, c)\n \
    \       for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) d = 1 + i / 2\n\
    \            else d = a + b + c\n            result = result :+ d\n          \
    \  a = b\n            b = c\n            c = d\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5rvisfjh.scala:38)\n\tat Problem.main(tmp5rvisfjh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var result = List(0, 3, 2)\n     \
    \   for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) result = result :+\
    \ (1 + i / 2)\n            else result = result :+ (result(i - 1) + result(i -\
    \ 2) + result(i + 1))\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3yy18gh5.scala:27:15\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var result = List(0, 3)\n        var i = 2\n        while (i <= n) {\n     \
    \       if (i % 2 == 0) result = result :+ (1 + i / 2)\n            else result\
    \ = result :+ (result(i - 1) + result(i - 2) + result(i + 1))\n            i +=\
    \ 1\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe0t85phd.scala:28:15\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979460
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var list = List[Long]()\n        for (i <- 0 to n.toInt) {\n            if\
    \ (i == 0) list = list :+ 0\n            else if (i == 1) list = list :+ 3\n \
    \           else if (i == 2) list = list :+ 8\n            else if (i % 2 == 0)\
    \ list = list :+ (1 + i / 2)\n            else list = list :+ (list(i - 1) + list(i\
    \ - 2) + list(i + 1))\n        }\n        return list\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri$$anonfun$1(tmp5w5p7rpm.scala:25)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp5w5p7rpm.scala:26)\n\
    \tat Problem$.main(tmp5w5p7rpm.scala:30)\n\tat Problem.main(tmp5w5p7rpm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 1L\n        var d = 0L\n  \
    \      var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpen0dvgdd.scala:34)\n\tat Problem.main(tmpen0dvgdd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new HashMap[Long, Long]\n        cache += (1L -> 3L)\n        def\
    \ tri(n : Long) : Long = {\n            if (cache.contains(n)) cache(n)\n    \
    \        else {\n                val result = if (n % 2 == 0) 1 + n / 2 else tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1)\n                cache += (n -> result)\n   \
    \             result\n            }\n        }\n        (1L to n).map(tri(_)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiho_uk_m.scala:32)\n\tat Problem.main(tmpiho_uk_m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new Array[Long](n.toInt + 1)\n        def tri(n : Long) : Long\
    \ = {\n            if (n == 1) 3\n            else if (n == 2) 2\n           \
    \ else if (n == 3) 8\n            else if (cache(n.toInt) != 0) cache(n.toInt)\n\
    \            else {\n                val result = if (n % 2 == 0) 1 + n / 2 else\
    \ tri(n - 1) + tri(n - 2) + tri(n + 1)\n                cache(n.toInt) = result\n\
    \                result\n            }\n        }\n        (1 to n.toInt).map(tri).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyxbnsc5i.scala:31:27\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        (\e[31m1\e[0m to n.toInt).map(tri).toList\n\
    \e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\e[31m   |\e[0m    \
    \                       Found:    \e[1m\e[31mLong\e[0m => Long\n\e[31m   |\e[0m\
    \                           Required: \e[1m\e[32mInt\e[0m => Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979472
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  def tri(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0)\
    \ l\n            else if (n == 1) tri(n - 1, 3 :: l)\n            else if (n %\
    \ 2 == 0) tri(n - 1, (1 + n / 2) :: l)\n            else tri(n - 1, (l(0) + l(1)\
    \ + l(2)) :: l)\n        }\n        tri(n, List())\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri$1(tmp9qqezvdc.scala:23)\n\tat Problem$.tri(tmp9qqezvdc.scala:25)\n\
    \tat Problem$.main(tmp9qqezvdc.scala:28)\n\tat Problem.main(tmp9qqezvdc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ val list = new ListBuffer[Long]\n        list += 0\n        list += 3\n    \
    \    var i = 2\n        while (i <= n) {\n            if (i % 2 == 0) list +=\
    \ (1 + i / 2)\n            else list += (list(i - 1) + list(i - 2) + list(i +\
    \ 1))\n            i += 1\n        }\n        list.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri(tmpn9_18p5r.scala:27)\n\tat Problem$.main(tmpn9_18p5r.scala:33)\n\
    \tat Problem.main(tmpn9_18p5r.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) i / 2 else b + c + d\n            result = result :+\
    \ d\n            a = b\n            b = c\n            c = d\n        }\n    \
    \    return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoacpximi.scala:36)\n\tat Problem.main(tmpoacpximi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979472
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var a = 0L\n        var b = 3L\n \
    \       var c = 2L\n        var d = 0L\n        var result = List(a, b, c)\n \
    \       for (i <- 3 to n.toInt) {\n            d = if (i % 2 == 0) 1 + i / 2 else\
    \ a + b + c\n            result = result :+ d\n            a = b\n           \
    \ b = c\n            c = d\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ajts1d9.scala:37)\n\tat Problem.main(tmp5ajts1d9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var result = List(0, 3)\n        for (i <- 2 to n.toInt) {\n            if (i\
    \ % 2 == 0) result = result :+ (1 + i / 2)\n            else result = result :+\
    \ (result(i - 1) + result(i - 2) + result(i + 1))\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplyeqdmhv.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979472
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        var result = List[Long](3)\n        var\
    \ i = 1\n        while (i < n) {\n            if (i % 2 == 0) result = result\
    \ :+ (1 + i / 2)\n            else result = result :+ (result(i - 1) + result(i\
    \ - 2) + result(i + 1))\n            i += 1\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri(tmpcywhecuz.scala:24)\n\tat Problem$.main(tmpcywhecuz.scala:30)\n\
    \tat Problem.main(tmpcywhecuz.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979474
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var list = List[Long]()\n        for (i <- 0 to n.toInt) {\n            if\
    \ (i == 0) list = list :+ 0\n            else if (i == 1) list = list :+ 3\n \
    \           else if (i == 2) list = list :+ 8\n            else if (i % 2 == 0)\
    \ list = list :+ (1 + i / 2)\n            else list = list :+ (list(i - 1) + list(i\
    \ - 2) + list(i + 1))\n        }\n        return list\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri$$anonfun$1(tmp5w5p7rpm.scala:25)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp5w5p7rpm.scala:26)\n\
    \tat Problem$.main(tmp5w5p7rpm.scala:30)\n\tat Problem.main(tmp5w5p7rpm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw4sspsb.scala:36)\n\tat Problem.main(tmpxw4sspsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val m = n + 1\n        val a = new Array[Long](m.toInt)\n        a(0) = 3\n\
    \        a(1) = 2\n        a(2) = 8\n        for (i <- 3 until m.toInt) {\n  \
    \          if (i % 2 == 0) a(i) = 1 + i / 2\n            else a(i) = a(i - 1)\
    \ + a(i - 2) + a(i + 1)\n        }\n        a.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmp60g0n3yj.scala:26)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp60g0n3yj.scala:27)\n\
    \tat Problem$.main(tmp60g0n3yj.scala:31)\n\tat Problem.main(tmp60g0n3yj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw4sspsb.scala:36)\n\tat Problem.main(tmpxw4sspsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  def tri(n : Long, a : Long, b : Long, c : Long) : List[Long] = {\n        \
    \    if (n == 0) List(a)\n            else if (n == 1) List(a, b)\n          \
    \  else if (n == 2) List(a, b, c)\n            else if (n % 2 == 0) a :: tri(n\
    \ - 1, b, c, 1 + n / 2)\n            else a :: tri(n - 1, b, c, b + c + a)\n \
    \       }\n        tri(n, 3, 1, 2)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp76xcbpm3.scala:29)\n\tat Problem.main(tmp76xcbpm3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var result = List(0, 3, 2)\n     \
    \   for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) result = result :+\
    \ (1 + i / 2)\n            else result = result :+ (result(i - 1) + result(i -\
    \ 2) + result(i + 1))\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3yy18gh5.scala:27:15\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw4sspsb.scala:36)\n\tat Problem.main(tmpxw4sspsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 1L\n        var d = 0L\n  \
    \      var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    if (i == 1) {\n                result = result :+ a\n            } else if\
    \ (i == 2) {\n                result = result :+ b\n            } else if (i ==\
    \ 3) {\n                result = result :+ c\n            } else {\n         \
    \       d = a + b + c\n                result = result :+ d\n                a\
    \ = b\n                b = c\n                c = d\n            }\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc1qeha34.scala:42)\n\tat Problem.main(tmpc1qeha34.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979480
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new HashMap[Long, Long]\n        def triRec(n : Long) : Long =\
    \ {\n            if (cache.contains(n)) cache(n)\n            else {\n       \
    \         val result = if (n == 1) 3\n                else if (n % 2 == 0) 1 +\
    \ n / 2\n                else triRec(n - 1) + triRec(n - 2) + triRec(n + 1)\n\
    \                cache(n) = result\n                result\n            }\n  \
    \      }\n        (0 to n.toInt).map(triRec(_)).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979483
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new HashMap[Long, Long]\n        def tri(n : Long) : Long = {\n\
    \            if (cache.contains(n)) cache(n)\n            else {\n           \
    \     val result = if (n == 1) 3\n                else if (n % 2 == 0) 1 + n /\
    \ 2\n                else tri(n - 1) + tri(n - 2) + tri(n + 1)\n             \
    \   cache += (n -> result)\n                result\n            }\n        }\n\
    \        (0 to n.toInt).map(tri(_)).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979482
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  def triRec(n : Long, l : List[Long]) : List[Long] = {\n            if (n ==\
    \ 0) l\n            else if (n == 1) triRec(n - 1, 3 :: l)\n            else if\
    \ (n % 2 == 0) triRec(n - 1, (1 + n / 2) :: l)\n            else triRec(n - 1,\
    \ l.head + l.tail.head + l.tail.tail.head :: l)\n        }\n        triRec(n,\
    \ List()).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.triRec$1(tmpufsam7f9.scala:23)\n\
    \tat Problem$.tri(tmpufsam7f9.scala:25)\n\tat Problem$.main(tmpufsam7f9.scala:28)\n\
    \tat Problem.main(tmpufsam7f9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979482
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw4sspsb.scala:36)\n\tat Problem.main(tmpxw4sspsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  def tri(n : Long, a : Long, b : Long, c : Long) : List[Long] = {\n        \
    \    if (n == 0) List(a)\n            else if (n == 1) List(a, b)\n          \
    \  else if (n == 2) List(a, b, c)\n            else if (n % 2 == 0) a :: tri(n\
    \ - 1, b, c, a + b + c)\n            else a :: tri(n - 1, b, c, a + b + c)\n \
    \       }\n        tri(n, 3, 1, 2)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl3feoe8t.scala:29)\n\tat Problem.main(tmpl3feoe8t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979482
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new HashMap[Long, Long]\n        def tri(n : Long) : Long = {\n\
    \            if (cache.contains(n)) cache(n)\n            else {\n           \
    \     val result = if (n == 1) 3\n                else if (n % 2 == 0) 1 + n /\
    \ 2\n                else tri(n - 1) + tri(n - 2) + tri(n + 1)\n             \
    \   cache(n) = result\n                result\n            }\n        }\n    \
    \    (1 to n.toInt).map(tri).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsqfvzl38.scala:30:27\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        (\e[31m1\e[0m to n.toInt).map(tri).toList\n\
    \e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\e[31m   |\e[0m    \
    \                       Found:    \e[1m\e[31mLong\e[0m => Long\n\e[31m   |\e[0m\
    \                           Required: \e[1m\e[32mInt\e[0m => Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979482
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var result = List(0, 3, 2)\n     \
    \   for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) result = result :+\
    \ (i / 2)\n            else result = result :+ (result(i - 1) + result(i - 2)\
    \ + result(i + 1))\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplfix3xn5.scala:27:15\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979482
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 1L\n        var d = 0L\n  \
    \      var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    if (i == 1) {\n                result = result :+ a\n            } else if\
    \ (i == 2) {\n                result = result :+ b\n            } else if (i ==\
    \ 3) {\n                result = result :+ c\n            } else {\n         \
    \       d = a + b + c\n                a = b\n                b = c\n        \
    \        c = d\n                result = result :+ d\n            }\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2eo6kfcr.scala:42)\n\tat Problem.main(tmp2eo6kfcr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979484
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var l = List(0, 3, 2)\n        for (i <- 3 to n.toInt) {\n            if (i\
    \ % 2 == 0) l = l :+ (1 + i / 2)\n            else l = l :+ (l(i - 1) + l(i -\
    \ 2) + l(i + 1))\n        }\n        return l\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvcyczun1.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m l\n\
    \e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (l : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979470
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw4sspsb.scala:36)\n\tat Problem.main(tmpxw4sspsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 1L\n        var d = 0L\n  \
    \      var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    if (i == 1) result = result :+ a\n            else if (i == 2) result = result\
    \ :+ b\n            else if (i == 3) result = result :+ c\n            else {\n\
    \                d = a + b + c\n                result = result :+ d\n       \
    \         a = b\n                b = c\n                c = d\n            }\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkbzh52f0.scala:39)\n\tat Problem.main(tmpkbzh52f0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979483
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var a = 0L\n        var b = 3L\n \
    \       var c = 2L\n        var d = 0L\n        var result = List(a, b, c)\n \
    \       for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) d = 1 + i / 2\n\
    \            else d = a + b + c\n            result = result :+ d\n          \
    \  a = b\n            b = c\n            c = d\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5rvisfjh.scala:38)\n\tat Problem.main(tmp5rvisfjh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw4sspsb.scala:36)\n\tat Problem.main(tmpxw4sspsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var l = List(0, 3, 2)\n        for (i <- 3 to n.toInt) {\n            if (i\
    \ % 2 == 0) l = l :+ (1 + i / 2)\n            else l = l :+ (l(i - 1) + l(i -\
    \ 2) + l(i + 1))\n        }\n        return l\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvcyczun1.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m l\n\
    \e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (l : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979470
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw4sspsb.scala:36)\n\tat Problem.main(tmpxw4sspsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 1L\n        var d = 0L\n  \
    \      var result = List(a, b, c)\n        for (i <- 4 to n.toInt) {\n       \
    \     d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result :+= d\n\
    \            a = b\n            b = c\n            c = d\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfy7mw7z0.scala:34)\n\tat Problem.main(tmpfy7mw7z0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979484
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(1)\n        if (n == 1) return List(1, 3)\n       \
    \ var a = 1L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(1, 3, 2)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) {\n                d = 1 + i / 2\n            } else {\n\
    \                d = a + b + c\n            }\n            a = b\n           \
    \ b = c\n            c = d\n            result = result :+ d\n        }\n    \
    \    return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp152fn223.scala:35:31\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m            result = result :+\
    \ d\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e\
    [0m                               Found:    (d : Long)\n\e[31m   |\e[0m      \
    \                         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp152fn223.scala:37:15 --------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m        \e[33mreturn\e[0m result\n\e[31m\e[31m   |\e[0m  \
    \             ^^^^^^\e[0m\n\e[31m   |\e[0m               Found:    (result : List[Int])\n\
    \e[31m   |\e[0m               Required: List[Long]\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979483
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var result = new ListBuffer[Long]\n        result += 3\n        for (i <- 1\
    \ to n.toInt) {\n            if (i % 2 == 0) result += (1 + i / 2)\n         \
    \   else result += (result(i - 1) + result(i - 2) + result(i + 1))\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmppse32tm8.scala:23)\n\tat Problem$.tri$$anonfun$adapted$1(tmppse32tm8.scala:24)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmppse32tm8.scala:24)\n\
    \tat Problem$.main(tmppse32tm8.scala:28)\n\tat Problem.main(tmppse32tm8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Ma"
  stdout: ''
  timestamp: 1659979484
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 1L\n        var d = 0L\n  \
    \      var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    if (i == 1) result = result :+ a\n            else if (i == 2) result = result\
    \ :+ b\n            else if (i == 3) result = result :+ c\n            else {\n\
    \                d = a + b + c\n                a = b\n                b = c\n\
    \                c = d\n                result = result :+ d\n            }\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpymxjpjec.scala:39)\n\tat Problem.main(tmpymxjpjec.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val a = new Array[Long](n.toInt + 1)\n        a(0) = 0\n        a(1) = 3\n\
    \        a(2) = 2\n        for (i <- 3 to n.toInt) {\n            if (i % 2 ==\
    \ 0) a(i) = 1 + i / 2\n            else a(i) = a(i - 1) + a(i - 2) + a(i + 1)\n\
    \        }\n        a.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmpj9l6jtt8.scala:25)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpj9l6jtt8.scala:26)\n\
    \tat Problem$.main(tmpj9l6jtt8.scala:30)\n\tat Problem.main(tmpj9l6jtt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979484
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val result = new ListBuffer[Long]\n        result += 3\n        for (i <- 1\
    \ to n.toInt) {\n            if (i % 2 == 0) result += (1 + i / 2)\n         \
    \   else result += (result(i - 1) + result(i - 2) + result(i + 1))\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmp7_i4vbd6.scala:23)\n\tat Problem$.tri$$anonfun$adapted$1(tmp7_i4vbd6.scala:24)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp7_i4vbd6.scala:24)\n\
    \tat Problem$.main(tmp7_i4vbd6.scala:28)\n\tat Problem.main(tmp7_i4vbd6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Ma"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var result = ListBuffer[Long]()\n        result += 3\n        for (i <- 1 to\
    \ n.toInt) {\n            if (i % 2 == 0) result += 1 + i / 2\n            else\
    \ result += result(i - 1) + result(i - 2) + result(i + 1)\n        }\n       \
    \ result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmpq2wni18x.scala:23)\n\tat Problem$.tri$$anonfun$adapted$1(tmpq2wni18x.scala:24)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpq2wni18x.scala:24)\n\
    \tat Problem$.main(tmpq2wni18x.scala:28)\n\tat Problem.main(tmpq2wni18x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Ma"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var a = 0L\n        var b = 3L\n \
    \       var c = 2L\n        var d = 0L\n        var result = List(a, b, c)\n \
    \       for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) d = 1 + i / 2\n\
    \            else d = a + b + c\n            result = result :+ d\n          \
    \  a = b\n            b = c\n            c = d\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5rvisfjh.scala:38)\n\tat Problem.main(tmp5rvisfjh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var result = List[Long]()\n        var a = 3L\n        var b = 2L\n       \
    \ var c = 1L\n        for (i <- 1 to n.toInt) {\n            result = result :+\
    \ a\n            if (i % 2 == 0) {\n                a = 1 + i / 2\n          \
    \  } else {\n                a = b + c + a\n                b = c\n          \
    \      c = a\n            }\n        }\n        return result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp30l9cdd9.scala:36)\n\tat Problem.main(tmp30l9cdd9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979485
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val result = new ArrayBuffer[Long]()\n        result += 3\n        for (i <-\
    \ 1 to n.toInt) {\n            if (i % 2 == 0) result += 1 + i / 2\n         \
    \   else result += result(i - 1) + result(i - 2) + result(i + 1)\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1 is out of bounds (min 0, max 0)\n\
    \tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:98)\n\tat scala.collection.mutable.ArrayBuffer.apply(ArrayBuffer.scala:43)\n\
    \tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\
    \tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\tat Problem$.tri$$anonfun$1(tmpjyg_q7di.scala:23)\n\
    \tat Problem$.tri$$anonfun$adapted$1(tmpjyg_q7di.scala:24)\n\tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\
    \tat Problem$.tri(tmpjyg_q7di.scala:24)\n\tat Problem$.main(tmpjyg_q7di.scala:28)\n\
    \tat Problem.main(tmpjyg_q7di.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979485
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new HashMap[Long, Long]\n        def tri(n : Long) : Long = {\n\
    \            if (cache.contains(n)) cache(n)\n            else {\n           \
    \     val result = if (n == 1) 3\n                else if (n % 2 == 0) 1 + n /\
    \ 2\n                else tri(n - 1) + tri(n - 2) + tri(n + 1)\n             \
    \   cache(n) = result\n                result\n            }\n        }\n    \
    \    (1 to n + 1).map(tri(_)).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkn4o5_wj.scala:30:14\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        (\e[31m1\e[0m to n +\
    \ \e[31m1\e[0m).map(tri(_)).toList\n\e[31m\e[31m   |\e[0m              ^^^^^\e\
    [0m\n\e[31m   |\e[0m              Found:    Long\n\e[31m   |\e[0m            \
    \  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979483
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var a = 0L\n        var b = 3L\n \
    \       var c = 2L\n        var d = 0L\n        var result = List(a, b, c)\n \
    \       for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) d = 1 + i / 2\n\
    \            else d = a + b + c\n            result = result :+ d\n          \
    \  a = b\n            b = c\n            c = d\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5rvisfjh.scala:38)\n\tat Problem.main(tmp5rvisfjh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var lst = List(0, 3, 2)\n        for (i <- 3 to n.toInt) {\n            if (i\
    \ % 2 == 0) lst = lst :+ (1 + i / 2)\n            else lst = lst :+ (lst(i - 1)\
    \ + lst(i - 2) + lst(i + 1))\n        }\n        return lst\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaadnwmet.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m lst\n\
    \e[31m\e[31m   |\e[0m               ^^^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (lst : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979483
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var result = List(0, 3, 2)\n     \
    \   for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) result = result :+\
    \ (1 + i / 2)\n            else result = result :+ (result(i - 1) + result(i -\
    \ 2) + result(i + 1))\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3yy18gh5.scala:27:15\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new HashMap[Long, Long]\n        cache(1) = 3\n        def tri(n\
    \ : Long) : Long = {\n            if (cache.contains(n)) cache(n)\n          \
    \  else {\n                val result = if (n % 2 == 0) 1 + n / 2 else tri(n -\
    \ 1) + tri(n - 2) + tri(n + 1)\n                cache(n) = result\n          \
    \      result\n            }\n        }\n        (1 to n + 1).map(tri(_)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpasc47ugi.scala:29:14\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m        (\e[31m1\e[0m to n +\
    \ \e[31m1\e[0m).map(tri(_)).toList\n\e[31m\e[31m   |\e[0m              ^^^^^\e\
    [0m\n\e[31m   |\e[0m              Found:    Long\n\e[31m   |\e[0m            \
    \  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979484
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) (i / 2) + 1 else a + b + c\n            a = b\n     \
    \       b = c\n            c = d\n            result = result :+ d\n        }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwkhx6may.scala:36)\n\tat Problem.main(tmpwkhx6may.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979485
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var l = List(0, 3, 2)\n        for (i <- 3 to n.toInt) {\n            if (i\
    \ % 2 == 0) l = l :+ (1 + i / 2)\n            else l = l :+ (l(i - 1) + l(i -\
    \ 2) + l(i + 1))\n        }\n        return l\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvcyczun1.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m l\n\
    \e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (l : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979470
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var result = List(0, 3)\n        var i = 2\n        while (i <= n) {\n     \
    \       if (i % 2 == 0) result = result :+ (1 + i / 2)\n            else result\
    \ = result :+ (result(i - 1) + result(i - 2) + result(i + 1))\n            i +=\
    \ 1\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe0t85phd.scala:28:15\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979460
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  def tri(n : Long, list : List[Long]) : List[Long] = {\n            if (n ==\
    \ 0) list.reverse\n            else if (n % 2 == 0) tri(n - 1, n / 2 + 1 :: list)\n\
    \            else tri(n - 1, list(0) + list(1) + list(2) :: list)\n        }\n\
    \        tri(n, List(3, 2, 1))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpevdwjnrr.scala:27)\n\tat Problem.main(tmpevdwjnrr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979484
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var result = List(a,\
    \ b, c)\n        for (i <- 3 to n.toInt) {\n            val d = if (i % 2 == 0)\
    \ 1 + i / 2 else a + b + c\n            result = result :+ d\n            a =\
    \ b\n            b = c\n            c = d\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3fqc87am.scala:27:31\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            result = result :+\
    \ d\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e\
    [0m                               Found:    (d : AnyVal)\n\e[31m   |\e[0m    \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp3fqc87am.scala:30:16 --------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m            c = d\n\e[31m\e[31m   |\e[0m                ^\e\
    [0m\n\e[31m   |\e[0m                Found:    (d : AnyVal)\n\e[31m   |\e[0m  \
    \              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979484
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var result = List(0, 3)\n        var i = 2\n        while (i <= n) {\n     \
    \       if (i % 2 == 0) result = result :+ (1 + i / 2)\n            else result\
    \ = result :+ (result(i - 1) + result(i - 2) + result(i + 1))\n            i +=\
    \ 1\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe0t85phd.scala:28:15\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979460
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var l = List(0, 3, 2)\n        for (i <- 3 to n.toInt) {\n            if (i\
    \ % 2 == 0) l = l :+ (1 + i / 2)\n            else l = l :+ (l(i - 1) + l(i -\
    \ 2) + l(i + 1))\n        }\n        return l\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvcyczun1.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m l\n\
    \e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (l : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979470
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new HashMap[Long, Long]\n        def tri(n : Long) : Long = {\n\
    \            if (cache.contains(n)) cache(n)\n            else {\n           \
    \     val result = if (n == 1) 3 else if (n % 2 == 0) 1 + n / 2 else tri(n - 1)\
    \ + tri(n - 2) + tri(n + 1)\n                cache(n) = result\n             \
    \   result\n            }\n        }\n        (0 to n.toInt).map(tri(_)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979485
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = (i / 2) + 1\n            else d = a + b + c\n       \
    \     a = b\n            b = c\n            c = d\n            result = result\
    \ :+ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0ffzlujk.scala:37)\n\tat Problem.main(tmp0ffzlujk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979485
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var result = List(0, 3, 2)\n     \
    \   for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) result = result :+\
    \ (1 + i / 2)\n            else result = result :+ (result(i - 1) + result(i -\
    \ 2) + result(i + 1))\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3yy18gh5.scala:27:15\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var result = ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n      \
    \      if (i == 1) result += 3\n            else if (i == 2) result += 2\n   \
    \         else if (i == 3) result += 8\n            else if (i % 2 == 0) result\
    \ += (1 + i / 2)\n            else result += (result(i - 2) + result(i - 3) +\
    \ result(i - 1))\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpye755dnl.scala:30)\n\tat Problem.main(tmpye755dnl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979493
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var l = List(0, 3, 2)\n        for (i <- 3 to n.toInt) {\n            if (i\
    \ % 2 == 0) l = l :+ (1 + i / 2)\n            else l = l :+ (l(i - 1) + l(i -\
    \ 2) + l(i + 1))\n        }\n        return l\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvcyczun1.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m l\n\
    \e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (l : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979470
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw4sspsb.scala:36)\n\tat Problem.main(tmpxw4sspsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(3)\n        if\
    \ (n == 2) return List(3, 2)\n        var result = List(3, 2, 8)\n        for\
    \ (i <- 3 to n.toInt) {\n            if (i % 2 == 0) result = result :+ (1 + i\
    \ / 2)\n            else result = result :+ (result(i - 1) + result(i - 2) + result(i\
    \ + 1))\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcf0bfldb.scala:27:15\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979491
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw4sspsb.scala:36)\n\tat Problem.main(tmpxw4sspsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new Array[Long](n.toInt + 1)\n        def tri(n : Long) : Long\
    \ = {\n            if (n == 1) 3\n            else if (n == 2) 2\n           \
    \ else if (n == 3) 8\n            else if (cache(n.toInt) != 0) cache(n.toInt)\n\
    \            else {\n                val result = if (n % 2 == 0) 1 + n / 2 else\
    \ tri(n - 1) + tri(n - 2) + tri(n + 1)\n                cache(n.toInt) = result\n\
    \                result\n            }\n        }\n        (1 to n.toInt).map(tri).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyxbnsc5i.scala:31:27\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        (\e[31m1\e[0m to n.toInt).map(tri).toList\n\
    \e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\e[31m   |\e[0m    \
    \                       Found:    \e[1m\e[31mLong\e[0m => Long\n\e[31m   |\e[0m\
    \                           Required: \e[1m\e[32mInt\e[0m => Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979472
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 1L\n        var d = 0L\n  \
    \      var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    if (i == 1) result = result :+ a\n            else if (i == 2) result = result\
    \ :+ b\n            else if (i == 3) result = result :+ c\n            else {\n\
    \                if (i % 2 == 0) {\n                    d = 1 + i / 2\n      \
    \              result = result :+ d\n                }\n                else {\n\
    \                    d = a + b + c\n                    result = result :+ d\n\
    \                    a = b\n                    b = c\n                    c =\
    \ d\n                }\n            }\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbi5d47tn.scala:45)\n\tat Problem.main(tmpbi5d47tn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var map = Map[Long, Long]()\n        def tri(n : Long) : Long = {\n       \
    \     if (n == 1) return 3\n            if (n == 2) return 2\n            if (n\
    \ == 3) return 8\n            if (map.contains(n)) return map(n)\n           \
    \ var result = 0L\n            if (n % 2 == 0) result = 1 + n / 2\n          \
    \  else result = tri(n - 1) + tri(n - 2) + tri(n + 1)\n            map(n) = result\n\
    \            return result\n        }\n        var result = List[Long]()\n   \
    \     for (i <- 1 to n.toInt) result = result :+ tri(i)\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_88tk6pu.scala:36)\n\tat Problem.main(tmp_88tk6pu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979494
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 8L\n        var d = 0L\n  \
    \      var list = List(3L, 2L, 8L)\n        for (i <- 4 to n.toInt) {\n      \
    \      d = a + b + c\n            list = list :+ d\n            a = b\n      \
    \      b = c\n            c = d\n        }\n        return list\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv855275l.scala:34)\n\tat Problem.main(tmpv855275l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979494
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val dp = Array.fill(n.toInt + 1)(0L)\n        dp(1) = 3\n        for (i <-\
    \ 2 to n.toInt) {\n            if (i % 2 == 0) dp(i) = 1 + i / 2\n           \
    \ else dp(i) = dp(i - 1) + dp(i - 2) + dp(i + 1)\n        }\n        dp.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmphb6kh0i4.scala:23)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmphb6kh0i4.scala:24)\n\
    \tat Problem$.main(tmphb6kh0i4.scala:28)\n\tat Problem.main(tmphb6kh0i4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979494
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  def tri(n : Long, l : List[Long]) : List[Long] = {\n            if (n == 0)\
    \ l\n            else if (n == 1) tri(n - 1, 3 :: l)\n            else if (n %\
    \ 2 == 0) tri(n - 1, (1 + n / 2) :: l)\n            else tri(n - 1, (l(0) + l(1)\
    \ + l(2)) :: l)\n        }\n        tri(n, List()).reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri$1(tmp6na_p9dk.scala:23)\n\tat Problem$.tri(tmp6na_p9dk.scala:25)\n\
    \tat Problem$.main(tmp6na_p9dk.scala:28)\n\tat Problem.main(tmp6na_p9dk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979494
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val a = ArrayBuffer[Long]()\n        a += 3\n        for (i <- 1 to n) {\n\
    \            if (i % 2 == 0) a += (1 + i / 2)\n            else a += (a(i - 1)\
    \ + a(i - 2) + a(i + 1))\n        }\n        a.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnd9z1g07.scala:21:23\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m1\e[0m to n) {\n\e[31m\e[31m   |\e[0m                       ^\e[0m\n\e\
    [31m   |\e[0m                       Found:    (n : Long)\n\e[31m   |\e[0m    \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979492
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var result = List(0, 3)\n        var i = 2\n        while (i <= n) {\n     \
    \       if (i % 2 == 0) result = result :+ (1 + i / 2)\n            else result\
    \ = result :+ (result(i - 1) + result(i - 2) + result(i + 1))\n            i +=\
    \ 1\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe0t85phd.scala:28:15\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979460
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var result = new ListBuffer[Long]\n        result += 3\n        for (i <- 1\
    \ to n.toInt) {\n            if (i % 2 == 0) result += (1 + i / 2)\n         \
    \   else result += (result(i - 1) + result(i - 2) + result(i + 1))\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmppse32tm8.scala:23)\n\tat Problem$.tri$$anonfun$adapted$1(tmppse32tm8.scala:24)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmppse32tm8.scala:24)\n\
    \tat Problem$.main(tmppse32tm8.scala:28)\n\tat Problem.main(tmppse32tm8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Ma"
  stdout: ''
  timestamp: 1659979484
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var result = List(0, 3)\n        var i = 2\n        while (i <= n) {\n     \
    \       if (i % 2 == 0) result = result :+ (1 + i / 2)\n            else result\
    \ = result :+ (result(i - 1) + result(i - 2) + result(i + 1))\n            i +=\
    \ 1\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe0t85phd.scala:28:15\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979460
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var result = new ListBuffer[Long]\n        result += 3\n        for (i <- 1\
    \ to n.toInt) {\n            if (i % 2 == 0) result += (1 + i / 2)\n         \
    \   else result += (result(i - 1) + result(i - 2) + result(i + 1))\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmppse32tm8.scala:23)\n\tat Problem$.tri$$anonfun$adapted$1(tmppse32tm8.scala:24)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmppse32tm8.scala:24)\n\
    \tat Problem$.main(tmppse32tm8.scala:28)\n\tat Problem.main(tmppse32tm8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Ma"
  stdout: ''
  timestamp: 1659979484
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 1L\n        var d = 0L\n  \
    \      var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    if (i == 1) result = result :+ a\n            else if (i == 2) result = result\
    \ :+ b\n            else if (i == 3) result = result :+ c\n            else {\n\
    \                d = a + b + c\n                result = result :+ d\n       \
    \         a = b\n                b = c\n                c = d\n            }\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkbzh52f0.scala:39)\n\tat Problem.main(tmpkbzh52f0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979483
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var result = ListBuffer[Long]()\n        result += 0\n        result += 3\n\
    \        var i = 2\n        while (i <= n) {\n            if (i % 2 == 0) result\
    \ += 1 + i / 2\n            else result += result(i - 1) + result(i - 2) + result(i\
    \ + 1)\n            i += 1\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri(tmp1aco7vhy.scala:27)\n\tat Problem$.main(tmp1aco7vhy.scala:33)\n\
    \tat Problem.main(tmp1aco7vhy.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979494
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var list = List(0, 3, 8)\n        var i = 2\n        while (i < n) {\n     \
    \       if (i % 2 == 0) list = list :+ (1 + i / 2)\n            else list = list\
    \ :+ (list(i - 1) + list(i - 2) + list(i + 1))\n            i += 1\n        }\n\
    \        return list\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmq9khixx.scala:28:15\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mreturn\e[0m list\n\
    \e[31m\e[31m   |\e[0m               ^^^^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (list : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979493
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new HashMap[Long, Long]\n        def tri(n : Long) : Long = {\n\
    \            if (cache.contains(n)) cache(n)\n            else {\n           \
    \     val result = if (n == 1) 3\n                else if (n % 2 == 0) 1 + n /\
    \ 2\n                else tri(n - 1) + tri(n - 2) + tri(n + 1)\n             \
    \   cache(n) = result\n                result\n            }\n        }\n    \
    \    (1 to n + 1).map(tri(_)).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkn4o5_wj.scala:30:14\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        (\e[31m1\e[0m to n +\
    \ \e[31m1\e[0m).map(tri(_)).toList\n\e[31m\e[31m   |\e[0m              ^^^^^\e\
    [0m\n\e[31m   |\e[0m              Found:    Long\n\e[31m   |\e[0m            \
    \  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979483
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw4sspsb.scala:36)\n\tat Problem.main(tmpxw4sspsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw4sspsb.scala:36)\n\tat Problem.main(tmpxw4sspsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var list = List(0, 3, 2)\n        for (i <- 3 to n.toInt) {\n            if\
    \ (i % 2 == 0) list = list :+ (1 + i / 2)\n            else list = list :+ (list(i\
    \ - 1) + list(i - 2) + list(i + 1))\n        }\n        return list\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmqezlcci.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m list\n\
    \e[31m\e[31m   |\e[0m               ^^^^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (list : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) i / 2 else a + b + c\n            result = result :+\
    \ d\n            a = b\n            b = c\n            c = d\n        }\n    \
    \    return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplzyl2fqu.scala:36)\n\tat Problem.main(tmplzyl2fqu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979495
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 1L\n        var d = 0L\n  \
    \      var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    if (i == 1) result = result :+ a\n            else if (i == 2) result = result\
    \ :+ b\n            else if (i == 3) result = result :+ c\n            else {\n\
    \                d = a + b + c\n                a = b\n                b = c\n\
    \                c = d\n                result = result :+ d\n            }\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpymxjpjec.scala:39)\n\tat Problem.main(tmpymxjpjec.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new HashMap[Long, Long]\n        cache(1) = 3\n        def tri(n\
    \ : Long) : Long = {\n            if (cache.contains(n)) cache(n)\n          \
    \  else {\n                val result = if (n % 2 == 0) 1 + n / 2 else tri(n -\
    \ 1) + tri(n - 2) + tri(n + 1)\n                cache(n) = result\n          \
    \      result\n            }\n        }\n        (1 to n + 1).map(tri(_)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpasc47ugi.scala:29:14\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m        (\e[31m1\e[0m to n +\
    \ \e[31m1\e[0m).map(tri(_)).toList\n\e[31m\e[31m   |\e[0m              ^^^^^\e\
    [0m\n\e[31m   |\e[0m              Found:    Long\n\e[31m   |\e[0m            \
    \  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979484
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var a = 0L\n        var b = 3L\n \
    \       var c = 2L\n        var d = 0L\n        var result = List(a, b, c)\n \
    \       for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) d = 1 + i / 2\n\
    \            else d = a + b + c\n            result = result :+ d\n          \
    \  a = b\n            b = c\n            c = d\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5rvisfjh.scala:38)\n\tat Problem.main(tmp5rvisfjh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 8L\n        var d = 0L\n  \
    \      var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    if (i == 1) result = result :+ a\n            else if (i == 2) result = result\
    \ :+ b\n            else if (i == 3) result = result :+ c\n            else {\n\
    \                d = a + b + c\n                a = b\n                b = c\n\
    \                c = d\n                result = result :+ d\n            }\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1hfa3xuk.scala:39)\n\tat Problem.main(tmp1hfa3xuk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979495
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var list = ListBuffer[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    if (i == 1) list += 3\n            else if (i == 2) list += 2\n         \
    \   else if (i == 3) list += 8\n            else {\n                val last =\
    \ list(list.length - 1)\n                val secondLast = list(list.length - 2)\n\
    \                val thirdLast = list(list.length - 3)\n                if (i\
    \ % 2 == 0) list += (1 + i / 2)\n                else list += (last + secondLast\
    \ + thirdLast)\n            }\n        }\n        list.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6aut_e2y.scala:35)\n\tat Problem.main(tmp6aut_e2y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979495
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw4sspsb.scala:36)\n\tat Problem.main(tmpxw4sspsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var list = List[Long]()\n        for (i <- 0 to n.toInt) {\n            if\
    \ (i == 0) list = list :+ 0\n            else if (i == 1) list = list :+ 3\n \
    \           else if (i == 2) list = list :+ 2\n            else if (i % 2 == 0)\
    \ list = list :+ (1 + i / 2)\n            else list = list :+ (list(i - 1) + list(i\
    \ - 2) + list(i + 1))\n        }\n        return list\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri$$anonfun$1(tmpo12et4v5.scala:25)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpo12et4v5.scala:26)\n\
    \tat Problem$.main(tmpo12et4v5.scala:30)\n\tat Problem.main(tmpo12et4v5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979495
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new HashMap[Long, Long]\n        def tri(n : Long) : Long = {\n\
    \            if (cache.contains(n)) cache(n)\n            else {\n           \
    \     val result = if (n == 1) 3\n                else if (n % 2 == 0) 1 + n /\
    \ 2\n                else tri(n - 1) + tri(n - 2) + tri(n + 1)\n             \
    \   cache(n) = result\n                result\n            }\n        }\n    \
    \    (1 to n.toInt).map(tri).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsqfvzl38.scala:30:27\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        (\e[31m1\e[0m to n.toInt).map(tri).toList\n\
    \e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\e[31m   |\e[0m    \
    \                       Found:    \e[1m\e[31mLong\e[0m => Long\n\e[31m   |\e[0m\
    \                           Required: \e[1m\e[32mInt\e[0m => Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979482
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  def tri(n : Long, a : Long, b : Long, c : Long) : List[Long] = {\n        \
    \    if (n == 0) List(a)\n            else if (n == 1) List(a, b)\n          \
    \  else if (n == 2) List(a, b, c)\n            else if (n % 2 == 0) a :: tri(n\
    \ - 1, b, c, a + b + c)\n            else a :: tri(n - 1, b, c, a + b + c)\n \
    \       }\n        tri(n, 3, 1, 2)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl3feoe8t.scala:29)\n\tat Problem.main(tmpl3feoe8t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979482
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw4sspsb.scala:36)\n\tat Problem.main(tmpxw4sspsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var l = List(0, 3, 2)\n        var\
    \ i = 3\n        while (i <= n) {\n            if (i % 2 == 0) l = l :+ (1 + i\
    \ / 2)\n            else l = l :+ (l(i - 1) + l(i - 2) + l(i + 1))\n         \
    \   i += 1\n        }\n        return l\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpag4ggzoo.scala:29:15\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mreturn\e[0m l\n\
    \e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (l : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979494
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var list = List[Long]()\n        for (i <- 0 to n.toInt) {\n            if\
    \ (i == 0) list = list :+ 0\n            else if (i == 1) list = list :+ 3\n \
    \           else if (i == 2) list = list :+ 8\n            else if (i % 2 == 0)\
    \ list = list :+ (1 + i / 2)\n            else list = list :+ (list(i - 1) + list(i\
    \ - 2) + list(i + 1))\n        }\n        return list\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri$$anonfun$1(tmp5w5p7rpm.scala:25)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp5w5p7rpm.scala:26)\n\
    \tat Problem$.main(tmp5w5p7rpm.scala:30)\n\tat Problem.main(tmp5w5p7rpm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var l = List[Long]()\n        for (i <- 0 to n.toInt) {\n            if (i\
    \ == 0) l = l :+ 0\n            else if (i == 1) l = l :+ 3\n            else\
    \ if (i == 2) l = l :+ 8\n            else if (i % 2 == 0) l = l :+ (1 + i / 2)\n\
    \            else l = l :+ (l(i - 1) + l(i - 2) + l(i + 1))\n        }\n     \
    \   return l\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri$$anonfun$1(tmpqlvg037n.scala:25)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpqlvg037n.scala:26)\n\
    \tat Problem$.main(tmpqlvg037n.scala:30)\n\tat Problem.main(tmpqlvg037n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979495
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var list = List[Long]()\n        var a = 3L\n        var b = 2L\n        var\
    \ c = 1L\n        for (i <- 1 to n.toInt) {\n            list = list :+ a\n  \
    \          val temp = a\n            a = b\n            b = c\n            c =\
    \ temp + b + c\n        }\n        return list\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmputaferze.scala:33)\n\tat Problem.main(tmputaferze.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979495
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var list = List(0, 3, 2)\n        for (i <- 3 to n.toInt) {\n            if\
    \ (i % 2 == 0) list = list :+ (1 + i / 2)\n            else list = list :+ (list(i\
    \ - 1) + list(i - 2) + list(i + 1))\n        }\n        return list\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmqezlcci.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m list\n\
    \e[31m\e[31m   |\e[0m               ^^^^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (list : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var result = new ListBuffer[Long]\n        result += 3\n        for (i <- 2\
    \ to n.toInt) {\n            if (i % 2 == 0) result += (1 + i / 2)\n         \
    \   else result += (result(i - 2) + result(i - 1) + result(i + 1))\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 2\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmpi20em_lx.scala:23)\n\tat Problem$.tri$$anonfun$adapted$1(tmpi20em_lx.scala:24)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpi20em_lx.scala:24)\n\
    \tat Problem$.main(tmpi20em_lx.scala:28)\n\tat Problem.main(tmpi20em_lx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Mai"
  stdout: ''
  timestamp: 1659979496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var i = 2L\n        var result = List(a, b, c)\n        while (i <= n) {\n\
    \            if (i % 2 == 0) {\n                d = 1 + i / 2\n            } else\
    \ {\n                d = a + b + c\n            }\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n            i\
    \ += 1\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphu55zvyj.scala:42)\n\tat Problem.main(tmphu55zvyj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979495
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        var a = 1L\n        var b = 2L\n      \
    \  var c = 3L\n        var result = List(a, b, c)\n        for (i <- 3 to n.toInt)\
    \ {\n            val d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n          \
    \  result = result :+ d\n            a = b\n            b = c\n            c =\
    \ d\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpra1gofiu.scala:26:31\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            result = result :+\
    \ d\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e\
    [0m                               Found:    (d : AnyVal)\n\e[31m   |\e[0m    \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpra1gofiu.scala:29:16 --------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m            c = d\n\e[31m\e[31m   |\e[0m                ^\e\
    [0m\n\e[31m   |\e[0m                Found:    (d : AnyVal)\n\e[31m   |\e[0m  \
    \              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979495
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var result = ListBuffer[Long]()\n        result += 3\n        for (i <- 2 to\
    \ n.toInt) {\n            if (i % 2 == 0) result += 1 + i / 2\n            else\
    \ result += result(i - 2) + result(i - 1) + result(i + 1)\n        }\n       \
    \ result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 2\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:60)\n\
    \tat scala.collection.mutable.ListBuffer.apply(ListBuffer.scala:39)\n\tat scala.Function1.apply$mcJI$sp(Function1.scala:69)\n\
    \tat scala.Function1.apply$mcJI$sp$(Function1.scala:69)\n\tat scala.collection.AbstractSeq.apply$mcJI$sp(Seq.scala:1161)\n\
    \tat Problem$.tri$$anonfun$1(tmppkhlqw7f.scala:23)\n\tat Problem$.tri$$anonfun$adapted$1(tmppkhlqw7f.scala:24)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmppkhlqw7f.scala:24)\n\
    \tat Problem$.main(tmppkhlqw7f.scala:28)\n\tat Problem.main(tmppkhlqw7f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.Mai"
  stdout: ''
  timestamp: 1659979496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new Array[Long](n.toInt + 1)\n        def tri(n : Long) : Long\
    \ = {\n            if (n == 1) 3\n            else if (n == 2) 2\n           \
    \ else if (n == 3) 8\n            else if (cache(n.toInt) != 0) cache(n.toInt)\n\
    \            else {\n                val result = if (n % 2 == 0) 1 + n / 2 else\
    \ tri(n - 1) + tri(n - 2) + tri(n + 1)\n                cache(n.toInt) = result\n\
    \                result\n            }\n        }\n        (1 to n.toInt).map(tri).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyxbnsc5i.scala:31:27\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        (\e[31m1\e[0m to n.toInt).map(tri).toList\n\
    \e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\e[31m   |\e[0m    \
    \                       Found:    \e[1m\e[31mLong\e[0m => Long\n\e[31m   |\e[0m\
    \                           Required: \e[1m\e[32mInt\e[0m => Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979472
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 1L\n        var d = 0L\n  \
    \      var result = List(a, b, c)\n        for (i <- 4 to n.toInt) {\n       \
    \     d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9977oeob.scala:34)\n\tat Problem.main(tmp9977oeob.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var a = 0L\n        var b = 3L\n \
    \       var c = 2L\n        var d = 0L\n        var result = List(a, b, c)\n \
    \       for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) d = 1 + i / 2\n\
    \            else d = a + b + c\n            result = result :+ d\n          \
    \  a = b\n            b = c\n            c = d\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5rvisfjh.scala:38)\n\tat Problem.main(tmp5rvisfjh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw4sspsb.scala:36)\n\tat Problem.main(tmpxw4sspsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new Array[Long](n.toInt + 1)\n        cache(0) = 1\n        cache(1)\
    \ = 3\n        for (i <- 2 to n.toInt) {\n            if (i % 2 == 0) cache(i)\
    \ = 1 + i / 2\n            else cache(i) = cache(i - 1) + cache(i - 2) + cache(i\
    \ + 1)\n        }\n        cache.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.tri$$anonfun$1(tmpzfun77gq.scala:24)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmpzfun77gq.scala:25)\n\
    \tat Problem$.main(tmpzfun77gq.scala:29)\n\tat Problem.main(tmpzfun77gq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw4sspsb.scala:36)\n\tat Problem.main(tmpxw4sspsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 1L\n        var d = 0L\n  \
    \      var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    if (i == 1) result = result :+ a\n            else if (i == 2) result = result\
    \ :+ b\n            else if (i == 3) result = result :+ c\n            else {\n\
    \                d = a + b + c\n                a = b\n                b = c\n\
    \                c = d\n                result = result :+ d\n            }\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpymxjpjec.scala:39)\n\tat Problem.main(tmpymxjpjec.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw4sspsb.scala:36)\n\tat Problem.main(tmpxw4sspsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        var a = 3L\n        var b = 2L\n      \
    \  var c = 1L\n        var d = 0L\n        var result = List(a, b, c)\n      \
    \  for (i <- 3 to n.toInt) {\n            d = if (i % 2 == 0) 1 + i / 2 else a\
    \ + b + c\n            result = result :+ d\n            a = b\n            b\
    \ = c\n            c = d\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp519egjjg.scala:35)\n\tat Problem.main(tmp519egjjg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979497
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  val cache = new HashMap[Long, Long]\n        def tri(n : Long) : Long = {\n\
    \            if (cache.contains(n)) cache(n)\n            else {\n           \
    \     val result = if (n == 1) 3\n                else if (n % 2 == 0) 1 + n /\
    \ 2\n                else tri(n - 1) + tri(n - 2) + tri(n + 1)\n             \
    \   cache(n) = result\n                result\n            }\n        }\n    \
    \    (1 to n + 1).map(tri(_)).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkn4o5_wj.scala:30:14\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        (\e[31m1\e[0m to n +\
    \ \e[31m1\e[0m).map(tri(_)).toList\n\e[31m\e[31m   |\e[0m              ^^^^^\e\
    [0m\n\e[31m   |\e[0m              Found:    Long\n\e[31m   |\e[0m            \
    \  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979483
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var result = List(0, 3)\n        for (i <- 2 to n.toInt) {\n            if (i\
    \ % 2 == 0) result = result :+ (1 + i / 2)\n            else result = result :+\
    \ (result(i - 1) + result(i - 2) + result(i + 1))\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplyeqdmhv.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979472
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 1L\n        var d = 0L\n  \
    \      var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    if (i == 1) result = result :+ a\n            else if (i == 2) result = result\
    \ :+ b\n            else if (i == 3) result = result :+ c\n            else {\n\
    \                d = a + b + c\n                result = result :+ d\n       \
    \         a = b\n                b = c\n                c = d\n            }\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkbzh52f0.scala:39)\n\tat Problem.main(tmpkbzh52f0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979483
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       return result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxw4sspsb.scala:36)\n\tat Problem.main(tmpxw4sspsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var list = List[Long]()\n        for (i <- 0 to n.toInt) {\n            if\
    \ (i == 0) list = list :+ 0\n            else if (i == 1) list = list :+ 3\n \
    \           else if (i == 2) list = list :+ 8\n            else if (i % 2 == 0)\
    \ list = list :+ (1 + i / 2)\n            else list = list :+ (list(i - 1) + list(i\
    \ - 2) + list(i + 1))\n        }\n        return list\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 4\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri$$anonfun$1(tmp5w5p7rpm.scala:25)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.tri(tmp5w5p7rpm.scala:26)\n\
    \tat Problem$.main(tmp5w5p7rpm.scala:30)\n\tat Problem.main(tmp5w5p7rpm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var l = List(0, 3, 2)\n        for\
    \ (i <- 3 to n.toInt) {\n            if (i % 2 == 0) l = l :+ (1 + i / 2)\n  \
    \          else l = l :+ (l(i - 1) + l(i - 2) + l(i + 1))\n        }\n       \
    \ return l\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfefn4ajd.scala:27:15\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mreturn\e[0m l\n\
    \e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (l : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var result = List(0, 3)\n        var i = 2\n        while (i <= n) {\n     \
    \       if (i % 2 == 0) result = result :+ (1 + i / 2)\n            else result\
    \ = result :+ (result(i - 1) + result(i - 2) + result(i + 1))\n            i +=\
    \ 1\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe0t85phd.scala:28:15\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979460
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List()\n        if (n == 1) return List(3)\n        if (n\
    \ == 2) return List(3, 2)\n        var a = 3L\n        var b = 2L\n        var\
    \ c = 3L\n        var result = List(3, 2, 3)\n        for (i <- 3 to n.toInt)\
    \ {\n            if (i % 2 == 0) {\n                result = result :+ (1 + i\
    \ / 2)\n            } else {\n                result = result :+ (a + b + c)\n\
    \                a = b\n                b = c\n                c = result.last\n\
    \            }\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4d770kwd.scala:30:36\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m                result = result\
    \ :+ (a + b + c)\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    Found:    Long\n\e[31m\
    \   |\e[0m                                    Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4d770kwd.scala:36:15 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mreturn\e[0m result\n\e[31m\e[31m   |\e\
    [0m               ^^^^^^\e[0m\n\e[31m   |\e[0m               Found:    (result\
    \ : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979498
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        val l = tri(n - 1)\n        if (n\
    \ % 2 == 0) return l :+ (1 + n / 2)\n        else return l :+ (l(l.length - 1)\
    \ + l(l.length - 2) + l(l.length - 3))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkg71qvd_.scala:27)\n\tat Problem.main(tmpkg71qvd_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var l = List(0, 3, 2)\n        for (i <- 3 to n.toInt) {\n            if (i\
    \ % 2 == 0) l = l :+ (1 + i / 2)\n            else l = l :+ (l(i - 1) + l(i -\
    \ 2) + l(i + 1))\n        }\n        return l\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvcyczun1.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m l\n\
    \e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (l : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979470
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var result = List(0, 3, 2)\n     \
    \   var i = 3\n        while (i <= n) {\n            if (i % 2 == 0) result =\
    \ result :+ (1 + i / 2)\n            else result = result :+ (result(i - 1) +\
    \ result(i - 2) + result(i + 1))\n            i += 1\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpc035i5wb.scala:29:15\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        var result = List(0, 3, 2)\n     \
    \   for (i <- 3 to n.toInt) {\n            if (i % 2 == 0) result = result :+\
    \ (1 + i / 2)\n            else result = result :+ (result(i - 1) + result(i -\
    \ 2) + result(i + 1))\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3yy18gh5.scala:27:15\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var d = 0L\n   \
    \     var result = List(a, b, c)\n        for (i <- 3 to n.toInt) {\n        \
    \    if (i % 2 == 0) d = 1 + i / 2\n            else d = a + b + c\n         \
    \   a = b\n            b = c\n            c = d\n            result = result :+\
    \ d\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkqrb0mpg.scala:37)\n\tat Problem.main(tmpkqrb0mpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 3L\n        var d = 0L\n  \
    \      var result = List[Long]()\n        for (i <- 1L to n) {\n            if\
    \ (i == 1) result = result :+ a\n            else if (i == 2) result = result\
    \ :+ b\n            else if (i == 3) result = result :+ c\n            else {\n\
    \                if (i % 2 == 0) {\n                    d = 1 + i / 2\n      \
    \              result = result :+ d\n                }\n                else {\n\
    \                    d = a + b + c\n                    result = result :+ d\n\
    \                    a = b\n                    b = c\n                    c =\
    \ d\n                }\n            }\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsjl5kb1m.scala:45)\n\tat Problem.main(tmpsjl5kb1m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979500
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var a = 0L\n        var b = 3L\n        var c = 2L\n        var result = List(a,\
    \ b, c)\n        for (i <- 3 to n.toInt) {\n            var d = if (i % 2 == 0)\
    \ (i / 2) + 1 else a + b + c\n            result = result :+ d\n            a\
    \ = b\n            b = c\n            c = d\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7j8sfefp.scala:27:31\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            result = result :+\
    \ d\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e\
    [0m                               Found:    (d : AnyVal)\n\e[31m   |\e[0m    \
    \                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp7j8sfefp.scala:30:16 --------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m            c = d\n\e[31m\e[31m   |\e[0m                ^\e\
    [0m\n\e[31m   |\e[0m                Found:    (d : AnyVal)\n\e[31m   |\e[0m  \
    \              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979499
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  var a = 3L\n        var b = 2L\n        var c = 1L\n        var d = 0L\n  \
    \      var result = List[Long]()\n        for (i <- 1 to n.toInt) {\n        \
    \    d = if (i % 2 == 0) 1 + i / 2 else a + b + c\n            result = result\
    \ :+ d\n            a = b\n            b = c\n            c = d\n        }\n \
    \       result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpen0dvgdd.scala:34)\n\tat Problem.main(tmpen0dvgdd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979473
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ if (n == 2) return List(0, 3, 2)\n        if (n == 3) return List(0, 3, 2, 8)\n\
    \        var lst = List(0, 3, 2, 8)\n        for (i <- 4 to n.toInt) {\n     \
    \       if (i % 2 == 0) lst = lst :+ (1 + i / 2)\n            else lst = lst :+\
    \ (lst(i - 1) + lst(i - 2) + lst(i + 1))\n        }\n        return lst\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf_xb1tm1.scala:28:15\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mreturn\e[0m lst\n\
    \e[31m\e[31m   |\e[0m               ^^^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (lst : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    def tri(n : Long) : List[Long] = {\n      \
    \  if (n == 0) return List(0)\n        if (n == 1) return List(0, 3)\n       \
    \ var lst = List(0, 3, 2)\n        for (i <- 3 to n.toInt) {\n            if (i\
    \ % 2 == 0) lst = lst :+ (1 + i / 2)\n            else lst = lst :+ (lst(i - 1)\
    \ + lst(i - 2) + lst(i + 1))\n        }\n        return lst\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaadnwmet.scala:26:15\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m lst\n\
    \e[31m\e[31m   |\e[0m               ^^^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (lst : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979483
