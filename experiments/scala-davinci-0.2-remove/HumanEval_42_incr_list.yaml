name: HumanEval_42_incr_list
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return list with elements incremented by 1.\n    def incrList(l : List[Long])\
  \ : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n\
  \    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong,\
  \ 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong,\
  \ 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong,\
  \ 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong,\
  \ 124l.toLong))));\n    }\n\n}\n"
completions: ['        l.map(x => x + 1)', "        var result = List[Long]()\n  \
    \      for (i <- l) {\n            result = (i + 1) :: result\n        }\n   \
    \     result.reverse", "        var newList = List[Long]()\n        for (i <-\
    \ l) {\n            newList = newList :+ (i + 1)\n        }\n        return newList",
  "        var result = new ListBuffer[Long]()\n        for (i <- l) result += (i\
    \ + 1)\n        return result.toList", "        var result = List[Long]()\n  \
    \      for (i <- l) {\n            result = result :+ (i + 1)\n        }\n   \
    \     return result", '        l.map(x => x + 1)', "        if (l.isEmpty) {\n\
    \            List()\n        } else {\n            l.head + 1 :: incrList(l.tail)\n\
    \        }", '        l.map(x => x + 1)', '        l.map(x => x + 1)', '        l.map(x
    => x + 1)', '        l.map(x => x + 1)', '        l.map(x => x + 1)', '        l.map(x
    => x + 1)', "        var newList = new ListBuffer[Long]()\n        for (i <- l)\
    \ {\n            newList += (i + 1)\n        }\n        return newList.toList",
  '        l.map(x => x + 1)', "        var result = List[Long]()\n        for (i\
    \ <- l) {\n            result = result :+ (i + 1)\n        }\n        return result",
  '        l.map(x => x + 1)', '        l.map(x => x + 1)', "        var result =\
    \ List[Long]()\n        for (i <- l) result = result :+ (i + 1)\n        return\
    \ result", "        var result = List[Long]()\n        for (i <- l) result = (i\
    \ + 1) :: result\n        result.reverse", '        l.map(x => x + 1)', "    \
    \    if (l.isEmpty) Nil\n        else (l.head + 1) :: incrList(l.tail)", "   \
    \     var result = List[Long]()\n        for (i <- l) result = (i + 1) :: result\n\
    \        result.reverse", '        l.map(x => x + 1)', '        l.map(x => x +
    1)', '        l.map(x => x + 1)', '        l.map(x => x + 1)', '        l.map(x
    => x + 1)', "        var result = List[Long]()\n        for (i <- l) result =\
    \ (i + 1) :: result\n        result.reverse", '        l.map(x => x + 1)', '        l.map(x
    => x + 1)', "        var result = List[Long]()\n        for (i <- l) {\n     \
    \       result = (i + 1) :: result\n        }\n        result.reverse", '        l.map(x
    => x + 1)', "        var ret = List[Long]()\n        for (i <- l) {\n        \
    \    ret = ret :+ (i + 1)\n        }\n        return ret", '        l.map(x =>
    x + 1)', "        var result = List[Long]()\n        for (i <- l) {\n        \
    \    result = result :+ (i + 1)\n        }\n        return result", '        l.map(x
    => x + 1)', '        l.map(x => x + 1)', '        l.map(x => x + 1)', '        l.map(x
    => x + 1)', '        l.map(x => x + 1)', "        var result = new ListBuffer[Long]\n\
    \        for (i <- l) result += (i + 1)\n        return result.toList", '        l.map(x
    => x + 1)', "        var result = List[Long]()\n        for (i <- l) {\n     \
    \       result = (i + 1) :: result\n        }\n        result.reverse", "    \
    \    var result = List[Long]()\n        for (i <- l) {\n            result = result\
    \ :+ (i + 1)\n        }\n        return result", "        var result = new ListBuffer[Long]()\n\
    \        for (i <- l) result += (i + 1)\n        return result.toList", "    \
    \    if (l.isEmpty) {\n            List()\n        } else {\n            l.head\
    \ + 1 :: incrList(l.tail)\n        }", '        l.map(x => x + 1)', '        l.map(x
    => x + 1)', "        var result = List[Long]()\n        for (i <- l) result =\
    \ result :+ (i + 1)\n        return result", '        l.map(x => x + 1)', '        l.map(x
    => x + 1)', '        l.map(x => x + 1)', "        var result = List[Long]()\n\
    \        for (i <- l) {\n            result = result :+ (i + 1)\n        }\n \
    \       return result", '        l.map(x => x + 1)', "        var result = List[Long]()\n\
    \        for (x <- l) result = result :+ (x + 1)\n        return result", "  \
    \      var ret = List[Long]()\n        for (i <- l) {\n            ret = ret :+\
    \ (i + 1)\n        }\n        return ret", "        var result = List[Long]()\n\
    \        for (i <- l) {\n            result = (i + 1) :: result\n        }\n \
    \       result.reverse", '        l.map(x => x + 1)', '        l.map(x => x +
    1)', '        l.map(x => x + 1)', "        var result = List[Long]()\n       \
    \ for (i <- l) {\n            result = result :+ (i + 1)\n        }\n        return\
    \ result", '        l.map(x => x + 1)', '        l.map(x => x + 1)', '        l.map(x
    => x + 1)', '        l.map(x => x + 1)', "        var result = new ListBuffer[Long]\n\
    \        for (i <- l) result += (i + 1)\n        return result.toList", "    \
    \    var result = List[Long]()\n        for (i <- l) {\n            result = result\
    \ :+ (i + 1)\n        }\n        return result", "        var ret = List[Long]()\n\
    \        for (e <- l) {\n            ret = ret :+ (e + 1)\n        }\n       \
    \ return ret", "        var result = new ListBuffer[Long]\n        for (i <- l)\
    \ {\n            result += (i + 1)\n        }\n        return result.toList",
  '        l.map(x => x + 1)', "        var r = new ListBuffer[Long]()\n        for\
    \ (i <- l) r += (i + 1)\n        return r.toList", "        var result = List[Long]()\n\
    \        for (i <- l) {\n            result = (i + 1) :: result\n        }\n \
    \       result.reverse", '        l.map(x => x + 1)', "        var result = List[Long]()\n\
    \        for (i <- l) {\n            result = (i + 1) :: result\n        }\n \
    \       result.reverse", "        var result = List[Long]()\n        for (i <-\
    \ l) {\n            result = (i + 1) :: result\n        }\n        result.reverse",
  '        l.map(x => x + 1)', "        var result = List[Long]()\n        for (i\
    \ <- l) {\n            result = result :+ (i + 1)\n        }\n        return result",
  '        l.map(x => x + 1)', '        l.map(x => x + 1)', '        l.map(x => x
    + 1)', '        l.map(x => x + 1)', '        l.map(x => x + 1)', "        var\
    \ result = List[Long]()\n        for (i <- l) result = result :+ (i + 1)\n   \
    \     return result", "        var ret = List[Long]()\n        for (i <- l) {\n\
    \            ret = ret :+ (i + 1)\n        }\n        return ret", "        var\
    \ result = List[Long]()\n        for (i <- l) {\n            result = (i + 1)\
    \ :: result\n        }\n        result.reverse", '        l.map(x => x + 1)',
  '        l.map(x => x + 1)', '        l.map(x => x + 1)', "        var res = new\
    \ ListBuffer[Long]\n        for (i <- l) res += (i + 1)\n        res.toList",
  '        l.map(x => x + 1)', "        var result = List[Long]()\n        for (i\
    \ <- l) result = result :+ (i + 1)\n        return result", "        var result\
    \ = List[Long]()\n        for (i <- l) {\n            result = result :+ (i +\
    \ 1)\n        }\n        return result", '        l.map(x => x + 1)', "      \
    \  var result = List[Long]()\n        for (i <- l) {\n            result = result\
    \ :+ (i + 1)\n        }\n        return result", '        l.map(x => x + 1)',
  "        var result = List[Long]()\n        for (i <- l) result = result :+ (i +\
    \ 1)\n        return result", '        l.map(x => x + 1)', '        l.map(x =>
    x + 1)', "        var result = new ListBuffer[Long]\n        for (i <- l) result\
    \ += (i + 1)\n        return result.toList", "        var result = new ListBuffer[Long]\n\
    \        for (i <- l) result += (i + 1)\n        return result.toList", '        l.map(x
    => x + 1)', '        return l.map(x => x + 1)', "        var result = List[Long]()\n\
    \        for (i <- l) {\n            result = (i + 1) :: result\n        }\n \
    \       result.reverse", "        var result = List[Long]()\n        for (i <-\
    \ l) {\n            result = result :+ (i + 1)\n        }\n        return result",
  '        return l.map(x => x + 1)', "        var result = List[Long]()\n       \
    \ for (i <- l) {\n            result = result :+ (i + 1)\n        }\n        return\
    \ result", '        l.map(x => x + 1)', '        l.map(x => x + 1)', "       \
    \ var result = List[Long]()\n        for (i <- l) {\n            result = (i +\
    \ 1) :: result\n        }\n        result.reverse", "        var result = List[Long]()\n\
    \        for (i <- l) result = result :+ (i + 1)\n        return result", '        l.map(x
    => x + 1)', "        var r = List[Long]()\n        for (i <- l) {\n          \
    \  r = r :+ (i + 1)\n        }\n        return r", '        l.map(x => x + 1)',
  '        l.map(x => x + 1)', '        l.map(x => x + 1)', '        l.map(x => x
    + 1)', "        if (l.isEmpty) l\n        else l.head + 1 :: incrList(l.tail)",
  "        var result = List[Long]()\n        for (i <- l) {\n            result =\
    \ (i + 1) :: result\n        }\n        result.reverse", '        l.map(x => x
    + 1)', "        if (l.isEmpty) List()\n        else l.head + 1 :: incrList(l.tail)",
  '        l.map(x => x + 1)', "        var result = List[Long]()\n        for (i\
    \ <- l) {\n            result = (i + 1) :: result\n        }\n        result.reverse",
  '        l.map(x => x + 1)', '        l.map(x => x + 1)', "        var result =\
    \ List[Long]()\n        for (i <- l) result = result :+ (i + 1)\n        return\
    \ result", '        l.map(x => x + 1)', '        l.map(x => x + 1)', '        l.map(x
    => x + 1)', '        l.map(x => x + 1)', '        l.map(x => x + 1)', "      \
    \  if (l.isEmpty) {\n            List[Long]()\n        } else {\n            l.head\
    \ + 1 :: incrList(l.tail)\n        }", '        l.map(x => x + 1)', '        l.map(x
    => x + 1)', '        l.map(x => x + 1)', '        l.map(x => x + 1)', '        l.map(x
    => x + 1)', "        var result = List[Long]()\n        for (i <- l) {\n     \
    \       result = result :+ (i + 1)\n        }\n        return result", '        l.map(x
    => x + 1)', '        l.map(x => x + 1)', '        l.map(x => x + 1)', '        l.map(x
    => x + 1)', '        l.map(x => x + 1)', "        var result = List[Long]()\n\
    \        for (i <- l) result = result :+ (i + 1)\n        return result", '        l.map(x
    => x + 1)', '        l.map(x => x + 1)', '        l.map(x => x + 1)', "      \
    \  var result = List[Long]()\n        for (i <- l) result = result :+ (i + 1)\n\
    \        return result", "        var result = List[Long]()\n        for (i <-\
    \ l) {\n            result = (i + 1) :: result\n        }\n        result.reverse",
  "        var result = List[Long]()\n        for (i <- l) {\n            result =\
    \ result :+ (i + 1)\n        }\n        return result", '        l.map(x => x
    + 1)', "        var newList = new ListBuffer[Long]\n        for (i <- l) {\n \
    \           newList += (i + 1)\n        }\n        return newList.toList", '        l.map(x
    => x + 1)', '        l.map(x => x + 1)', "        var result = List[Long]()\n\
    \        for (i <- l) {\n            result = result :+ (i + 1)\n        }\n \
    \       return result", '        l.map(x => x + 1)', '        l.map(x => x + 1)',
  '        l.map(x => x + 1)', '        l.map(x => x + 1)', '        l.map(x => x
    + 1)', "        var result = new ListBuffer[Long]\n        for (i <- l) {\n  \
    \          result += (i + 1)\n        }\n        return result.toList", "    \
    \    var result = new ListBuffer[Long]\n        for (i <- l) result += (i + 1)\n\
    \        return result.toList", '        l.map(x => x + 1)', '        l.map(x
    => x + 1)', "        var result = new ListBuffer[Long]\n        for (i <- l) result\
    \ += (i + 1)\n        return result.toList", '        l.map(x => x + 1)', "  \
    \      var result = List[Long]()\n        for (i <- l) {\n            result =\
    \ (i + 1) :: result\n        }\n        result.reverse", "        var result =\
    \ List[Long]()\n        for (i <- l) {\n            result = (i + 1) :: result\n\
    \        }\n        result.reverse", "        var result = new ListBuffer[Long]\n\
    \        for (i <- l) result += (i + 1)\n        return result.toList", '        l.map(x
    => x + 1)', '        l.map(x => x + 1)', '        l.map(x => x + 1)', '        l.map(x
    => x + 1)', '        l.map(x => x + 1)', '        l.map(x => x + 1)', "      \
    \  var result = new ListBuffer[Long]\n        for (i <- l) result += (i + 1)\n\
    \        return result.toList", '        l.map(x => x + 1)', '        l.map(x
    => x + 1)', "        var result = List[Long]()\n        for (i <- l) result =\
    \ result :+ (i + 1)\n        return result", '        l.map(x => x + 1)', "  \
    \      var ret = new ListBuffer[Long]\n        for (i <- l) ret += (i + 1)\n \
    \       return ret.toList", '        l.map(x => x + 1)', '        l.map(x => x
    + 1)', '        l.map(x => x + 1)', "        var res = List[Long]()\n        for\
    \ (i <- l) res = res :+ (i + 1)\n        res", '        l.map(x => x + 1)', '        l.map(x
    => x + 1)', '        l.map(x => x + 1)', '        return l.map(x => x + 1)', '        l.map(x
    => x + 1)', '        l.map(x => x + 1)', "        var ret = List[Long]()\n   \
    \     for (i <- l) {\n            ret = ret :+ (i + 1)\n        }\n        return\
    \ ret", '        l.map(x => x + 1)', '        l.map(x => x + 1)', '        l.map(x
    => x + 1)', "        if (l.isEmpty) l\n        else l.head + 1 :: incrList(l.tail)",
  '        l.map(x => x + 1)', "        var res = List[Long]()\n        for (i <-\
    \ l) res = (i + 1) :: res\n        res.reverse", "        var result = List[Long]()\n\
    \        for (i <- l) result = result :+ (i + 1)\n        return result", '        l.map(x
    => x + 1)']
stop_tokens:
- "\n    }\n"
