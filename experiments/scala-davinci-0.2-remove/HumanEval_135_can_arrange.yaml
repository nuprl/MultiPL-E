name: HumanEval_135_can_arrange
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function which returns the largest index of an element which\n\
  \    // is not greater than or equal to the element immediately preceding it. If\n\
  \    // no such element exists then return -1. The given array will not contain\n\
  \    // duplicate values.\n    // Examples:\n    def canArrange(arr : List[Long])\
  \ : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(canArrange((List[Long](1l.toLong,\
  \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))) == (3l));\n    assert(canArrange((List[Long](1l.toLong,\
  \ 2l.toLong, 4l.toLong, 5l.toLong))) == (-1l));\n    assert(canArrange((List[Long](1l.toLong,\
  \ 4l.toLong, 2l.toLong, 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong)))\
  \ == (2l));\n    assert(canArrange((List[Long](4l.toLong, 8l.toLong, 5l.toLong,\
  \ 7l.toLong, 3l.toLong))) == (4l));\n    assert(canArrange((List[Long]())) == (-1l));\n\
  \    }\n\n}\n"
completions: ["        val n = arr.length\n        val sorted = arr.sorted\n     \
    \   val min = sorted.head\n        val max = sorted.last\n        if (max - min\
    \ > 1) return -1\n        if (min == max) {\n            if (min == 0) return\
    \ (n * (n - 1)) / 2\n            return -1\n        }\n        val zeros = sorted.count(_\
    \ == 0)\n        val ones = sorted.count(_ == 1)\n        return zeros * ones\
    \ + (zeros * (zeros - 1)) / 2", "        val s = arr.sorted\n        var i = 0\n\
    \        var j = s.length - 1\n        var count = 0\n        while (i < j) {\n\
    \            if (s(i) + s(j) == 0) {\n                count += 1\n           \
    \     i += 1\n                j -= 1\n            } else if (s(i) + s(j) < 0)\
    \ {\n                i += 1\n            } else {\n                j -= 1\n  \
    \          }\n        }\n        count", "        val n = arr.length\n       \
    \ val sorted = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val sum = sorted.sum\n        if (sum % 2 == 1) return 0\n        val\
    \ target = sum / 2\n        if (target < min || target > max) return 0\n     \
    \   val dp = Array.fill(n + 1, target.toInt + 1)(0L)\n        dp(0)(0) = 1\n \
    \       for (i <- 1 to n) {\n            for (j <- 0 to target.toInt) {\n    \
    \            dp(i)(j) = dp(i - 1)(j)\n                if (j >= sorted(i - 1))\
    \ dp(i)(j) += dp(i - 1)(j - sorted(i - 1).toInt)\n            }\n        }\n \
    \       dp(n)(target.toInt)", "        val sorted = arr.sorted\n        val n\
    \ = sorted.length\n        val max = sorted(n - 1)\n        val min = sorted(0)\n\
    \        if (max - min > 1) return -1\n        if (max - min == 1) {\n       \
    \     if (n % 2 == 1) return -1\n            val mid = n / 2\n            for\
    \ (i <- 0 until mid) {\n                if (sorted(i) != sorted(i + mid)) return\
    \ -1\n            }\n            return mid - 1\n        }\n        if (max ==\
    \ min) {\n            if (n % 2 == 1) return -1\n            val mid = n / 2\n\
    \            for (i <- 0 until mid) {\n                if (sorted(i) != sorted(i\
    \ + mid)) return -1\n            }\n            return mid - 1\n        }\n  \
    \      return -1", "        val sorted = arr.sorted\n        val n = sorted.length\n\
    \        var i = 0\n        var j = n - 1\n        while (i < j) {\n         \
    \   if (sorted(i) + sorted(j) == 0) {\n                i += 1\n              \
    \  j -= 1\n            } else if (sorted(i) + sorted(j) > 0) {\n             \
    \   j -= 1\n            } else {\n                i += 1\n            }\n    \
    \    }\n        if (i == j) {\n            if (sorted(i) == 0) 1 else 0\n    \
    \    } else {\n            1\n        }", "        val n = arr.length\n      \
    \  val sorted = arr.sorted\n        val max = sorted.last\n        val min = sorted.head\n\
    \        val maxIndex = sorted.indexOf(max)\n        val minIndex = sorted.indexOf(min)\n\
    \        val maxIndex2 = sorted.indexOf(max, maxIndex + 1)\n        val minIndex2\
    \ = sorted.indexOf(min, minIndex + 1)\n        val maxIndex3 = sorted.indexOf(max,\
    \ maxIndex2 + 1)\n        val minIndex3 = sorted.indexOf(min, minIndex2 + 1)\n\
    \        val maxIndex4 = sorted.indexOf(max, maxIndex3 + 1)\n        val minIndex4\
    \ = sorted.indexOf(min, minIndex3 + 1)\n        val maxIndex5 = sorted.indexOf(max,\
    \ maxIndex4 + 1)\n        val minIndex5 = sorted.indexOf(min, minIndex4 + 1)\n\
    \        val maxIndex6 = sorted.indexOf(max, maxIndex5 + 1)\n        val minIndex6\
    \ = sorted.indexOf(min, minIndex5 + 1)\n        val maxIndex7 = sorted.indexOf(max,\
    \ maxIndex6 + 1)\n        val minIndex7 = sorted.indexOf(min, minIndex6 + 1)\n\
    \        val maxIndex8 = sorted.indexOf(max, maxIndex7 + 1)\n        val minIndex8\
    \ = sorted.indexOf(min, minIndex7 + 1)\n        val maxIndex9 = sorted.indexOf(max,\
    \ maxIndex8 + 1)\n        val minIndex9 = sorted.indexOf(min, minIndex8 + 1)\n\
    \        val maxIndex10 = sorted.indexOf(max, maxIndex9 + 1)\n        val minIndex10\
    \ = sorted.indexOf(min, minIndex9 + 1)\n        val maxIndex11 = sorted.indexOf(max,\
    \ maxIndex10 + 1)\n        val minIndex11 = sorted.indexOf(min, minIndex10 + 1)\n\
    \        val maxIndex12 = sorted.indexOf(max, maxIndex11 + 1)\n        val minIndex12\
    \ = sorted.indexOf(min, minIndex11 + 1)\n        val maxIndex13 = sorted.indexOf(max,\
    \ max", "        val n = arr.length\n        val dp = Array.fill(n)(0L)\n    \
    \    for (i <- 0 until n) {\n            val x = arr(i)\n            var j = i\
    \ - 1\n            while (j >= 0 && arr(j) >= x) {\n                j -= 1\n \
    \           }\n            if (j < 0) {\n                dp(i) = x\n         \
    \   } else {\n                dp(i) = dp(j) + x\n            }\n        }\n  \
    \      dp(n - 1)", "        val sorted = arr.sorted\n        val max = sorted.max\n\
    \        val min = sorted.min\n        val range = max - min\n        if (range\
    \ == 0) return 0\n        val count = Array.fill(range.toInt + 1)(0)\n       \
    \ for (i <- 0 until sorted.length) {\n            count(sorted(i).toInt - min.toInt)\
    \ += 1\n        }\n        var total = 0L\n        for (i <- 0 until count.length)\
    \ {\n            if (count(i) > 0) {\n                val j = i + min.toInt\n\
    \                if (j + j == max + min) {\n                    total += count(i)\
    \ * (count(i) - 1) / 2\n                } else if (j + j < max + min) {\n    \
    \                total += count(i) * count(max.toInt - min.toInt - j)\n      \
    \          }\n            }\n        }\n        total", "        val n = arr.length\n\
    \        val sorted = arr.sorted\n        val max = sorted.max\n        val min\
    \ = sorted.min\n        val diff = max - min\n        if (diff % 2 == 1) return\
    \ -1\n        val mid = min + diff / 2\n        val count = Array.fill(n)(0)\n\
    \        for (i <- 0 until n) {\n            val x = sorted(i)\n            if\
    \ (x <= mid) count(i) = 1\n            else count(i) = -1\n        }\n       \
    \ val prefix = Array.fill(n)(0)\n        prefix(0) = count(0)\n        for (i\
    \ <- 1 until n) prefix(i) = prefix(i - 1) + count(i)\n        var result = 0L\n\
    \        for (i <- 0 until n) {\n            if (count(i) == 1) {\n          \
    \      val index = prefix.indexWhere(_ == prefix(i) - 1)\n                if (index\
    \ != -1) result += 1\n            }\n        }\n        result", "        val\
    \ n = arr.length\n        val sorted = arr.sorted\n        var sum = 0L\n    \
    \    for (i <- 0 until n) {\n            sum += sorted(i)\n        }\n       \
    \ if (sum % 2 == 1) return 0\n        val target = sum / 2\n        val dp = Array.fill(n\
    \ + 1)(0L)\n        for (i <- 1 to n) {\n            dp(i) = dp(i - 1) + sorted(i\
    \ - 1)\n        }\n        val count = Array.fill(n + 1)(0L)\n        for (i <-\
    \ 1 to n) {\n            count(i) = count(i - 1) + 1\n        }\n        var result\
    \ = 0L\n        for (i <- 1 to n) {\n            val j = dp.indexWhere(dp(i) -\
    \ _ == target)\n            if (j != -1) {\n                result += count(j)\n\
    \            }\n        }\n        result", "        val n = arr.length\n    \
    \    val max = arr.max\n        val sum = arr.sum\n        if (sum % 2 == 1) return\
    \ 0\n        val half = sum / 2\n        val dp = Array.fill(n + 1, half + 1)(0L)\n\
    \        dp(0)(0) = 1\n        for (i <- 1 to n) {\n            val a = arr(i\
    \ - 1)\n            for (j <- 0 to half) {\n                dp(i)(j) = dp(i -\
    \ 1)(j)\n                if (j >= a) dp(i)(j) += dp(i - 1)(j - a)\n          \
    \  }\n        }\n        dp(n)(half)", "        val n = arr.length\n        val\
    \ sorted = arr.sorted\n        var i = 0\n        var j = n - 1\n        var count\
    \ = 0\n        while (i < j) {\n            if (sorted(i) + sorted(j) == 0) {\n\
    \                count += 1\n                i += 1\n                j -= 1\n\
    \            } else if (sorted(i) + sorted(j) < 0) {\n                i += 1\n\
    \            } else {\n                j -= 1\n            }\n        }\n    \
    \    count", "        val sorted = arr.sorted\n        val n = sorted.length\n\
    \        val max = sorted(n - 1)\n        val min = sorted(0)\n        if (max\
    \ - min >= n) return -1\n        var i = 0\n        var j = 1\n        while (i\
    \ < n && j < n) {\n            if (sorted(i) + 1 == sorted(j)) {\n           \
    \     i += 1\n                j += 1\n            } else {\n                j\
    \ += 1\n            }\n        }\n        i.toLong", '        arr.sortWith(_ >
    _).foldLeft(0L)((acc, x) => acc + x)', "        val sorted = arr.sorted\n    \
    \    val n = sorted.length\n        val sum = sorted.sum\n        if (sum % 2\
    \ == 1) return 0\n        val half = sum / 2\n        val dp = Array.fill(n +\
    \ 1, half + 1)(0L)\n        dp(0)(0) = 1\n        for (i <- 1 to n) {\n      \
    \      for (j <- 0 to half) {\n                dp(i)(j) = dp(i - 1)(j)\n     \
    \           if (j >= sorted(i - 1)) dp(i)(j) += dp(i - 1)(j - sorted(i - 1))\n\
    \            }\n        }\n        dp(n)(half)", "        val n = arr.length\n\
    \        val sum = arr.sum\n        if (sum % 2 == 1) return 0\n        val half\
    \ = sum / 2\n        val dp = Array.fill(n + 1, half + 1)(0L)\n        dp(0)(0)\
    \ = 1\n        for (i <- 1 to n) {\n            for (j <- 0 to half) {\n     \
    \           dp(i)(j) = dp(i - 1)(j)\n                if (j >= arr(i - 1)) dp(i)(j)\
    \ += dp(i - 1)(j - arr(i - 1))\n            }\n        }\n        dp(n)(half)",
  "        val sorted = arr.sorted\n        val n = sorted.length\n        val min\
    \ = sorted(0)\n        val max = sorted(n - 1)\n        val sum = sorted.sum\n\
    \        if (sum % 2 == 1) return 0\n        val target = sum / 2\n        if\
    \ (min == max) {\n            if (min == target) return 1\n            else return\
    \ 0\n        }\n        val counts = new HashMap[Long, Long]\n        for (i <-\
    \ 0 until n) {\n            val x = sorted(i)\n            if (counts.contains(x))\
    \ counts(x) += 1\n            else counts(x) = 1\n        }\n        val dp =\
    \ new Array[Long](target.toInt + 1)\n        dp(0) = 1\n        for (i <- min.toInt\
    \ to target.toInt) {\n            for (j <- min.toInt to max.toInt) {\n      \
    \          if (i - j >= 0 && counts.contains(j)) {\n                    dp(i)\
    \ += dp(i - j) * counts(j)\n                }\n            }\n        }\n    \
    \    return dp(target.toInt)", "        val n = arr.length\n        val dp = Array.fill(n)(0L)\n\
    \        for (i <- 0 until n) {\n            val x = arr(i)\n            for (j\
    \ <- i - 1 to 0 by -1) {\n                if (arr(j) <= x) {\n               \
    \     dp(i) = max(dp(i), dp(j) + 1)\n                }\n            }\n      \
    \  }\n        dp.max", "        val n = arr.length\n        val m = arr.max\n\
    \        val dp = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n        \
    \    val x = arr(i)\n            for (j <- 0 until n) {\n                if (j\
    \ != i) {\n                    val y = arr(j)\n                    if (x + y <=\
    \ m) dp(x.toInt) = max(dp(x.toInt), dp(y.toInt) + 1)\n                }\n    \
    \        }\n        }\n        dp.max", "        val n = arr.length\n        val\
    \ sorted = arr.sorted\n        var i = 0\n        var j = n - 1\n        var count\
    \ = 0\n        while (i < j) {\n            if (sorted(i) + sorted(j) == 0) {\n\
    \                count += 1\n                i += 1\n                j -= 1\n\
    \            } else if (sorted(i) + sorted(j) < 0) {\n                i += 1\n\
    \            } else {\n                j -= 1\n            }\n        }\n    \
    \    count", "        val n = arr.length\n        val sorted = arr.sorted\n  \
    \      val sum = sorted.sum\n        if (sum % 2 == 1) return 0\n        val half\
    \ = sum / 2\n        val dp = Array.fill(n + 1, half + 1)(0L)\n        dp(0)(0)\
    \ = 1\n        for (i <- 1 to n) {\n            for (j <- 0 to half) {\n     \
    \           dp(i)(j) = dp(i - 1)(j)\n                if (j >= sorted(i - 1)) dp(i)(j)\
    \ += dp(i - 1)(j - sorted(i - 1))\n            }\n        }\n        dp(n)(half)",
  "        val n = arr.length\n        val dp = Array.fill(n)(0L)\n        for (i\
    \ <- 0 until n) {\n            val x = arr(i)\n            var j = i - 1\n   \
    \         while (j >= 0 && arr(j) >= x) j -= 1\n            if (j == -1) dp(i)\
    \ = x\n            else dp(i) = dp(j) + x\n        }\n        dp.max", "     \
    \   val n = arr.length\n        val sorted = arr.sorted\n        val sum = sorted.sum\n\
    \        if (sum % 2 == 1) return 0\n        val half = sum / 2\n        val dp\
    \ = Array.fill(n + 1, half + 1)(0L)\n        dp(0)(0) = 1\n        for (i <- 1\
    \ to n) {\n            for (j <- 0 to half) {\n                dp(i)(j) = dp(i\
    \ - 1)(j)\n                if (j >= sorted(i - 1)) dp(i)(j) += dp(i - 1)(j - sorted(i\
    \ - 1))\n            }\n        }\n        dp(n)(half)", "        val sorted =\
    \ arr.sorted\n        val n = sorted.length\n        val max = sorted(n - 1)\n\
    \        val min = sorted(0)\n        val diff = max - min\n        if (diff %\
    \ 2 == 0) {\n            val target = diff / 2\n            val map = new HashMap[Long,\
    \ Int]\n            for (i <- 0 until n) {\n                val x = sorted(i)\n\
    \                if (map.contains(x)) map(x) += 1\n                else map(x)\
    \ = 1\n            }\n            for (i <- 0 until n) {\n                val\
    \ x = sorted(i)\n                if (map(x) > 0) {\n                    val y\
    \ = x + target\n                    if (map.contains(y) && map(y) > 0) {\n   \
    \                     map(x) -= 1\n                        map(y) -= 1\n     \
    \               }\n                }\n            }\n            var count = 0\n\
    \            for (i <- 0 until n) {\n                val x = sorted(i)\n     \
    \           if (map(x) > 0) count += 1\n            }\n            if (count %\
    \ 2 == 0) count / 2 else -1\n        } else -1", "        val sorted = arr.sorted\n\
    \        val min = sorted.head\n        val max = sorted.last\n        if (min\
    \ == max) return 0\n        val diff = max - min\n        val sum = sorted.sum\n\
    \        if (sum % 2 == 1) return -1\n        val target = sum / 2\n        if\
    \ (target < min || target > max) return -1\n        val dp = Array.fill(target.toInt\
    \ + 1)(-1)\n        dp(0) = 0\n        for (i <- 0 until sorted.length) {\n  \
    \          val x = sorted(i)\n            for (j <- target.toInt to x.toInt by\
    \ -1) {\n                if (dp(j - x.toInt) != -1) {\n                    if\
    \ (dp(j) == -1) dp(j) = dp(j - x.toInt) + 1\n                    else dp(j) =\
    \ min(dp(j), dp(j - x.toInt) + 1)\n                }\n            }\n        }\n\
    \        if (dp(target.toInt) == -1) return -1\n        return dp(target.toInt).toLong",
  "        val n = arr.length\n        val dp = Array.fill(n)(0L)\n        for (i\
    \ <- 0 until n) {\n            val x = arr(i)\n            for (j <- 0 until n)\
    \ {\n                if (x % arr(j) == 0) {\n                    dp(i) += 1\n\
    \                }\n            }\n        }\n        var result = 0L\n      \
    \  for (i <- 0 until n) {\n            val x = arr(i)\n            for (j <- 0\
    \ until n) {\n                if (arr(j) % x == 0) {\n                    result\
    \ += dp(j)\n                }\n            }\n            result -= dp(i)\n  \
    \      }\n        result / 2", "        val n = arr.length\n        val sum =\
    \ arr.sum\n        if (sum % 2 == 1) return 0\n        val half = sum / 2\n  \
    \      val dp = Array.fill(n + 1, half + 1)(0L)\n        dp(0)(0) = 1\n      \
    \  for (i <- 1 to n) {\n            for (j <- 0 to half) {\n                dp(i)(j)\
    \ = dp(i - 1)(j)\n                if (j >= arr(i - 1)) dp(i)(j) += dp(i - 1)(j\
    \ - arr(i - 1))\n            }\n        }\n        dp(n)(half)", "        val\
    \ n = arr.length\n        val sorted = arr.sorted\n        var i = 0\n       \
    \ var j = n - 1\n        var count = 0\n        while (i < j) {\n            if\
    \ (sorted(i) + sorted(j) == 0) {\n                count += 1\n               \
    \ i += 1\n                j -= 1\n            } else if (sorted(i) + sorted(j)\
    \ < 0) {\n                i += 1\n            } else {\n                j -= 1\n\
    \            }\n        }\n        count", "        val n = arr.length\n     \
    \   val sorted = arr.sorted\n        val min = sorted.head\n        val max =\
    \ sorted.last\n        if (max - min > n) return -1\n        var count = new Array[Long](n)\n\
    \        for (i <- 0 until n) count(i) = 0\n        for (i <- 0 until n) count(arr(i).toInt\
    \ - min.toInt) += 1\n        var d = 0\n        for (i <- 0 until n) {\n     \
    \       if (count(i) > 0) {\n                var j = i\n                while\
    \ (j < n && count(j) > 0) {\n                    count(j) -= 1\n             \
    \       j += 1\n                }\n                d = max(d, j - i)\n       \
    \     }\n        }\n        return d", "        val n = arr.length\n        val\
    \ sum = arr.sum\n        if (sum % 2 == 1) return 0\n        val half = sum /\
    \ 2\n        val dp = Array.fill(n + 1, half + 1)(0L)\n        dp(0)(0) = 1\n\
    \        for (i <- 1 to n) {\n            for (j <- 0 to half) {\n           \
    \     dp(i)(j) = dp(i - 1)(j)\n                if (j >= arr(i - 1)) dp(i)(j) +=\
    \ dp(i - 1)(j - arr(i - 1))\n            }\n        }\n        dp(n)(half)", " \
    \       val n = arr.length\n        val arr2 = arr.sorted\n        val arr3 =\
    \ arr2.reverse\n        val arr4 = arr3.map(x => x * x)\n        val arr5 = arr4.sorted\n\
    \        val arr6 = arr5.reverse\n        val arr7 = arr6.map(x => sqrt(x).toLong)\n\
    \        val arr8 = arr7.sorted\n        val arr9 = arr8.reverse\n        val\
    \ arr10 = arr9.map(x => x * x)\n        val arr11 = arr10.sorted\n        val\
    \ arr12 = arr11.reverse\n        val arr13 = arr12.map(x => sqrt(x).toLong)\n\
    \        val arr14 = arr13.sorted\n        val arr15 = arr14.reverse\n       \
    \ val arr16 = arr15.map(x => x * x)\n        val arr17 = arr16.sorted\n      \
    \  val arr18 = arr17.reverse\n        val arr19 = arr18.map(x => sqrt(x).toLong)\n\
    \        val arr20 = arr19.sorted\n        val arr21 = arr20.reverse\n       \
    \ val arr22 = arr21.map(x => x * x)\n        val arr23 = arr22.sorted\n      \
    \  val arr24 = arr23.reverse\n        val arr25 = arr24.map(x => sqrt(x).toLong)\n\
    \        val arr26 = arr25.sorted\n        val arr27 = arr26.reverse\n       \
    \ val arr28 = arr27.map(x => x * x)\n        val arr29 = arr28.sorted\n      \
    \  val arr30 = arr29.reverse\n        val arr31 = arr30.map(x => sqrt(x).toLong)\n\
    \        val arr32 = arr31.sorted\n        val arr33 = arr32.reverse\n       \
    \ val arr34 = arr33.map(x => x * x)\n        val arr35 = arr34.sorted\n      \
    \  val arr36 = arr35.reverse\n        val arr37 = arr36.map(x => sqrt(x).toLong)\n\
    \        val arr38 = arr37.sorted\n        val arr39 = arr38.reverse\n       \
    \ val arr", "        val n = arr.length\n        val max = arr.max\n        val\
    \ min = arr.min\n        val sum = arr.sum\n        if (sum % 2 == 1) return 0\n\
    \        val half = sum / 2\n        if (half < min) return 0\n        if (max\
    \ > half) return 0\n        val dp = Array.fill(n + 1, half + 1)(0L)\n       \
    \ dp(0)(0) = 1\n        for (i <- 1 to n) {\n            for (j <- 0 to half)\
    \ {\n                dp(i)(j) = dp(i - 1)(j)\n                if (j >= arr(i -\
    \ 1)) dp(i)(j) += dp(i - 1)(j - arr(i - 1))\n            }\n        }\n      \
    \  dp(n)(half) / 2", "        val sorted = arr.sorted\n        val n = sorted.length\n\
    \        val sum = sorted.sum\n        if (sum % 2 == 1) return 0\n        val\
    \ target = sum / 2\n        val dp = Array.fill(n + 1, target.toInt + 1)(0L)\n\
    \        dp(0)(0) = 1\n        for (i <- 1 to n) {\n            for (j <- 0 to\
    \ target.toInt) {\n                dp(i)(j) = dp(i - 1)(j)\n                if\
    \ (j >= sorted(i - 1).toInt) dp(i)(j) += dp(i - 1)(j - sorted(i - 1).toInt)\n\
    \            }\n        }\n        dp(n)(target.toInt)", "        val n = arr.length\n\
    \        val dp = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n        \
    \    dp(i) = arr(i)\n            for (j <- 0 until i) {\n                if (arr(j)\
    \ < arr(i)) dp(i) = max(dp(i), dp(j) + arr(i))\n            }\n        }\n   \
    \     dp.max", "        val n = arr.length\n        val sorted = arr.sorted\n\
    \        val m = sorted.max\n        val sum = sorted.sum\n        if (sum % 2\
    \ == 1) return 0\n        val target = sum / 2\n        val dp = Array.fill(n\
    \ + 1, target + 1)(0L)\n        dp(0)(0) = 1\n        for (i <- 1 to n) {\n  \
    \          for (j <- 0 to target) {\n                dp(i)(j) = dp(i - 1)(j)\n\
    \                if (j >= sorted(i - 1)) dp(i)(j) += dp(i - 1)(j - sorted(i -\
    \ 1))\n            }\n        }\n        dp(n)(target)", "        val n = arr.length\n\
    \        val sorted = arr.sorted\n        val sum = arr.sum\n        if (sum %\
    \ 2 == 1) return 0\n        val half = sum / 2\n        val dp = Array.fill(n\
    \ + 1, half + 1)(0L)\n        dp(0)(0) = 1\n        for (i <- 1 to n) {\n    \
    \        for (j <- 0 to half) {\n                dp(i)(j) = dp(i - 1)(j)\n   \
    \             if (j >= sorted(i - 1)) dp(i)(j) += dp(i - 1)(j - sorted(i - 1))\n\
    \            }\n        }\n        dp(n)(half)", "        val sorted = arr.sorted\n\
    \        var max = 0L\n        for (i <- 0 until sorted.length) {\n          \
    \  val x = sorted(i)\n            if (i == 0) max = x\n            else {\n  \
    \              if (x > max) max = x\n                else return -1\n        \
    \    }\n        }\n        return max", "        val sorted = arr.sorted\n   \
    \     val n = sorted.length\n        val a = sorted.head\n        val b = sorted.last\n\
    \        if (a == b) return 0\n        if (a + 1 == b) return 1\n        val x\
    \ = (b - a) / (n - 1)\n        val y = (b - a) % (n - 1)\n        if (y == 0)\
    \ return x\n        if (y == 1) return x + 1\n        return x + 2", "       \
    \ val n = arr.length\n        val sorted = arr.sorted\n        val max = sorted.max\n\
    \        val min = sorted.min\n        val diff = max - min\n        if (diff\
    \ % 2 == 1) return -1\n        val half = diff / 2\n        val count = new Array[Long](n)\n\
    \        for (i <- 0 until n) {\n            val x = sorted(i)\n            val\
    \ j = sorted.indexOf(x + half)\n            if (j != -1) count(j) += 1\n     \
    \   }\n        var result = 0L\n        for (i <- 0 until n) {\n            val\
    \ x = sorted(i)\n            val j = sorted.indexOf(x + half)\n            if\
    \ (j != -1) {\n                val c = count(j)\n                if (c > 0) {\n\
    \                    result += c\n                    count(j) = 0\n         \
    \       }\n            }\n        }\n        result", "        val n = arr.length\n\
    \        val sorted = arr.sorted\n        var i = 0\n        while (i < n) {\n\
    \            if (sorted(i) % 2 == 0) {\n                if (i == 0 || sorted(i)\
    \ != sorted(i - 1)) return 0\n            }\n            else {\n            \
    \    if (i == n - 1 || sorted(i) != sorted(i + 1)) return 0\n            }\n \
    \           i += 1\n        }\n        return 1", "        val n = arr.length\n\
    \        val arr2 = arr.sorted\n        val arr3 = arr2.reverse\n        val arr4\
    \ = arr3.zipWithIndex\n        val arr5 = arr4.map(x => (x._1, x._2 + 1))\n  \
    \      val arr6 = arr5.map(x => (x._1, x._2.toLong))\n        val arr7 = arr6.map(x\
    \ => (x._1, x._2 * x._2))\n        val arr8 = arr7.map(x => (x._1, x._2 * x._2))\n\
    \        val arr9 = arr8.map(x => (x._1, x._2 * x._2))\n        val arr10 = arr9.map(x\
    \ => (x._1, x._2 * x._2))\n        val arr11 = arr10.map(x => (x._1, x._2 * x._2))\n\
    \        val arr12 = arr11.map(x => (x._1, x._2 * x._2))\n        val arr13 =\
    \ arr12.map(x => (x._1, x._2 * x._2))\n        val arr14 = arr13.map(x => (x._1,\
    \ x._2 * x._2))\n        val arr15 = arr14.map(x => (x._1, x._2 * x._2))\n   \
    \     val arr16 = arr15.map(x => (x._1, x._2 * x._2))\n        val arr17 = arr16.map(x\
    \ => (x._1, x._2 * x._2))\n        val arr18 = arr17.map(x => (x._1, x._2 * x._2))\n\
    \        val arr19 = arr18.map(x => (x._1, x._2 * x._2))\n        val arr20 =\
    \ arr19.map(x => (x._1, x._2 * x._2))\n        val arr21 = arr20.map(x => (x._1,\
    \ x._2 * x._2))\n        val arr22 = arr21.map(x => (x._1, x._2 * x._2))\n   \
    \     val arr23 = arr", "        val n = arr.length\n        val sum = arr.sum\n\
    \        if (sum % 2 == 1) return 0\n        val half = sum / 2\n        val dp\
    \ = Array.fill(half + 1)(0L)\n        dp(0) = 1\n        for (i <- 0 until n)\
    \ {\n            val x = arr(i)\n            for (j <- half to x by -1) {\n  \
    \              dp(j) += dp(j - x)\n            }\n        }\n        dp(half)",
  "        val n = arr.length\n        val dp = Array.fill(n)(0L)\n        for (i\
    \ <- 1 until n) {\n            val j = i - 1\n            val x = arr(i)\n   \
    \         val y = arr(j)\n            if (x >= y) dp(i) = dp(j) + 1\n        \
    \    else dp(i) = dp(j)\n        }\n        dp(n - 1)", "        val n = arr.length\n\
    \        val m = arr.max\n        val freq = Array.fill(m.toInt + 1)(0)\n    \
    \    for (i <- 0 until n) {\n            freq(arr(i).toInt) += 1\n        }\n\
    \        var ans = 0L\n        for (i <- 0 until n) {\n            var j = arr(i).toInt\n\
    \            while (j <= m) {\n                if (freq(j) > 0) {\n          \
    \          freq(j) -= 1\n                    ans += 1\n                    break\n\
    \                }\n                j += 1\n            }\n        }\n       \
    \ ans", "        val sorted = arr.sorted\n        val n = sorted.length\n    \
    \    val min = sorted(0)\n        val max = sorted(n - 1)\n        val sum = sorted.sum\n\
    \        if (sum % 2 == 1) return 0\n        val target = sum / 2\n        if\
    \ (min > target || max < target) return 0\n        val dp = Array.fill(target.toInt\
    \ + 1)(0L)\n        dp(0) = 1\n        for (i <- 0 until n) {\n            val\
    \ x = sorted(i)\n            for (j <- target.toInt to x.toInt by -1) {\n    \
    \            dp(j) += dp(j - x.toInt)\n            }\n        }\n        dp(target.toInt)",
  "        val sorted = arr.sorted\n        val max = sorted.last\n        val min\
    \ = sorted.head\n        if (max - min > 1) return -1\n        if (max == min)\
    \ return 0\n        val maxCount = sorted.count(_ == max)\n        val minCount\
    \ = sorted.count(_ == min)\n        if (maxCount == minCount) return 0\n     \
    \   if (maxCount > minCount) {\n            val diff = maxCount - minCount\n \
    \           if (diff % 2 == 0) return 0\n            else return 1\n        }\n\
    \        else {\n            val diff = minCount - maxCount\n            if (diff\
    \ % 2 == 0) return 0\n            else return 1\n        }", "        val sorted\
    \ = arr.sorted\n        val max = sorted.last\n        val min = sorted.head\n\
    \        val diff = max - min\n        val n = arr.length\n        val sum = arr.sum\n\
    \        if (sum % n != 0) return -1\n        val avg = sum / n\n        if (avg\
    \ < min || avg > max) return -1\n        val count = new Array[Long](n)\n    \
    \    for (i <- 0 until n) count(i) = 0\n        for (i <- 0 until n) count(arr(i).toInt\
    \ - min.toInt) += 1\n        for (i <- 0 until n) {\n            if (count(i)\
    \ == 0) return -1\n            if (i + diff.toInt >= n) return -1\n          \
    \  if (count(i + diff.toInt) == 0) return -1\n            count(i + diff.toInt)\
    \ -= 1\n        }\n        return 1", "        val n = arr.length\n        val\
    \ sorted = arr.sorted\n        val max = sorted.max\n        val min = sorted.min\n\
    \        val diff = max - min\n        if (diff == 0) return 0\n        val count\
    \ = Array.fill(diff + 1)(0)\n        for (i <- 0 until n) {\n            count(sorted(i).toInt\
    \ - min.toInt) += 1\n        }\n        var i = 0\n        var j = diff\n    \
    \    var res = 0L\n        while (i <= j) {\n            if (i == j) {\n     \
    \           if (count(i) > 1) res += count(i) * (count(i) - 1) / 2\n         \
    \   } else {\n                res += count(i) * count(j)\n            }\n    \
    \        i += 1\n            j -= 1\n        }\n        res", "        val n =\
    \ arr.length\n        val sorted = arr.sorted\n        val max = sorted.max\n\
    \        val min = sorted.min\n        if (max - min > 1) return -1\n        if\
    \ (max == min) return (n * (n - 1) / 2) % 2\n        val count = sorted.groupBy(x\
    \ => x).map(x => (x._1, x._2.length)).toList\n        if (count.length == 1) return\
    \ -1\n        val (a, b) = count.head\n        val (c, d) = count.last\n     \
    \   if (a == c) return -1\n        if (a == b - 1 && c == d - 1) return (b * d)\
    \ % 2\n        if (a == b - 1) return d % 2\n        if (c == d - 1) return b\
    \ % 2\n        return -1", "        val sorted = arr.sorted\n        val max =\
    \ sorted.last\n        val min = sorted.head\n        val diff = max - min\n \
    \       if (diff == 0) return 0\n        if (diff % (arr.length - 1) != 0) return\
    \ -1\n        val step = diff / (arr.length - 1)\n        var i = 0\n        var\
    \ j = 1\n        while (j < arr.length) {\n            if (sorted(j) - sorted(i)\
    \ != step) return -1\n            i += 1\n            j += 1\n        }\n    \
    \    return step", "        val sorted = arr.sorted\n        for (i <- 0 until\
    \ sorted.length - 1) {\n            if (sorted(i) + sorted(i + 1) % 2 == 1) return\
    \ -1\n        }\n        return 1", "        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        val sum = sorted.sum\n        if (sum % 2 == 1) return\
    \ 0\n        val half = sum / 2\n        val dp = Array.fill(n + 1, half + 1)(0L)\n\
    \        dp(0)(0) = 1\n        for (i <- 1 to n) {\n            for (j <- 0 to\
    \ half) {\n                dp(i)(j) = dp(i - 1)(j)\n                if (j >= sorted(i\
    \ - 1)) dp(i)(j) += dp(i - 1)(j - sorted(i - 1))\n            }\n        }\n \
    \       dp(n)(half)", "        val n = arr.length\n        val arr2 = arr.sorted\n\
    \        val arr3 = arr2.reverse\n        val arr4 = arr3.zipWithIndex\n     \
    \   val arr5 = arr4.map(x => (x._1, x._2 + 1))\n        val arr6 = arr5.map(x\
    \ => (x._1, x._2.toLong))\n        val arr7 = arr6.map(x => (x._1, x._2 * x._2))\n\
    \        val arr8 = arr7.map(x => (x._1, x._2 * x._2))\n        val arr9 = arr8.map(x\
    \ => (x._1, x._2 * x._2))\n        val arr10 = arr9.map(x => (x._1, x._2 * x._2))\n\
    \        val arr11 = arr10.map(x => (x._1, x._2 * x._2))\n        val arr12 =\
    \ arr11.map(x => (x._1, x._2 * x._2))\n        val arr13 = arr12.map(x => (x._1,\
    \ x._2 * x._2))\n        val arr14 = arr13.map(x => (x._1, x._2 * x._2))\n   \
    \     val arr15 = arr14.map(x => (x._1, x._2 * x._2))\n        val arr16 = arr15.map(x\
    \ => (x._1, x._2 * x._2))\n        val arr17 = arr16.map(x => (x._1, x._2 * x._2))\n\
    \        val arr18 = arr17.map(x => (x._1, x._2 * x._2))\n        val arr19 =\
    \ arr18.map(x => (x._1, x._2 * x._2))\n        val arr20 = arr19.map(x => (x._1,\
    \ x._2 * x._2))\n        val arr21 = arr20.map(x => (x._1, x._2 * x._2))\n   \
    \     val arr22 = arr21.map(x => (x._1, x._2 * x._2))\n        val arr23 = arr",
  "        val n = arr.length\n        val sorted = arr.sorted\n        val max =\
    \ sorted.max\n        val min = sorted.min\n        val sum = sorted.sum\n   \
    \     if (sum % 2 == 1) return 0\n        val target = sum / 2\n        if (max\
    \ > target) return 0\n        if (min == target) return 1\n        val dp = Array.fill(target.toInt\
    \ + 1)(0L)\n        dp(0) = 1\n        for (i <- 0 until n) {\n            for\
    \ (j <- target.toInt to sorted(i).toInt by -1) {\n                dp(j) += dp(j\
    \ - sorted(i).toInt)\n            }\n        }\n        dp(target.toInt)", " \
    \       val n = arr.length\n        val sorted = arr.sorted\n        val max =\
    \ sorted.max\n        val min = sorted.min\n        if (max - min > 1) return\
    \ -1\n        val count = new Array[Long](n)\n        for (i <- 0 until n) count(i)\
    \ = sorted.count(_ == sorted(i))\n        if (max == min) {\n            if (count(0)\
    \ % 2 == 1) return -1\n            return count(0) / 2\n        }\n        if\
    \ (count(0) != count(n - 1)) return -1\n        return count(0)", "        val\
    \ n = arr.length\n        val dp = Array.fill(n)(0L)\n        dp(0) = arr(0)\n\
    \        for (i <- 1 until n) {\n            dp(i) = dp(i - 1) + arr(i)\n    \
    \    }\n        var res = 0L\n        for (i <- 0 until n) {\n            if (dp(i)\
    \ % 2 == 0) {\n                res += 1\n            }\n        }\n        res",
  "        val n = arr.length\n        val m = arr.max\n        val a = Array.fill(m.toInt\
    \ + 1)(0)\n        for (i <- 0 until n) a(arr(i).toInt) += 1\n        var sum\
    \ = 0L\n        for (i <- 0 to m.toInt) {\n            sum += a(i) * (a(i) - 1)\
    \ / 2\n            if (i + i <= m) sum += a(i) * a(i + i)\n        }\n       \
    \ sum", "        val n = arr.length\n        val sums = new Array[Long](n)\n \
    \       sums(0) = arr(0)\n        for (i <- 1 until n) {\n            sums(i)\
    \ = sums(i - 1) + arr(i)\n        }\n        var result = 0L\n        for (i <-\
    \ 0 until n) {\n            val j = i + 1\n            if (j < n) {\n        \
    \        val sum = sums(n - 1) - sums(j) + arr(j)\n                if (sum ==\
    \ arr(i)) result += 1\n            }\n        }\n        result", "        val\
    \ sorted = arr.sorted\n        val n = sorted.length\n        var i = 0\n    \
    \    var j = n - 1\n        var count = 0\n        while (i < j) {\n         \
    \   if (sorted(i) + sorted(j) == 0) {\n                count += 1\n          \
    \      i += 1\n                j -= 1\n            } else if (sorted(i) + sorted(j)\
    \ < 0) {\n                i += 1\n            } else {\n                j -= 1\n\
    \            }\n        }\n        count", "        var sum = 0L\n        var\
    \ max = 0L\n        for (i <- arr) {\n            sum += i\n            max =\
    \ max max i\n        }\n        if (sum % 2 == 1) return 0\n        val target\
    \ = sum / 2\n        if (max > target) return 0\n        val dp = Array.fill(target.toInt\
    \ + 1)(0L)\n        dp(0) = 1\n        for (i <- arr) {\n            for (j <-\
    \ target.toInt to i.toInt by -1) {\n                dp(j) += dp(j - i.toInt)\n\
    \            }\n        }\n        dp(target.toInt)", "        val n = arr.length\n\
    \        val sorted = arr.sorted\n        val max = sorted.last\n        val min\
    \ = sorted.head\n        val diff = max - min\n        if (diff % (n - 1) != 0)\
    \ return -1\n        val d = diff / (n - 1)\n        val m = HashMap[Long, Long]()\n\
    \        for (i <- 0 until n) {\n            m(sorted(i)) = i\n        }\n   \
    \     var result = 0L\n        for (i <- 0 until n) {\n            val x = sorted(i)\n\
    \            val y = x + d\n            if (m.contains(y)) {\n               \
    \ val j = m(y)\n                if (i < j) {\n                    result += j\
    \ - i - 1\n                } else {\n                    result += n - i - 1 +\
    \ j\n                }\n            } else {\n                return -1\n    \
    \        }\n        }\n        result", "        val n = arr.length\n        val\
    \ sorted = arr.sorted\n        var i = 0\n        var j = n - 1\n        var count\
    \ = 0\n        while (i < j) {\n            if (sorted(i) + sorted(j) == 0) {\n\
    \                count += 1\n                i += 1\n                j -= 1\n\
    \            } else if (sorted(i) + sorted(j) < 0) {\n                i += 1\n\
    \            } else {\n                j -= 1\n            }\n        }\n    \
    \    count", "        val n = arr.length\n        val sum = arr.sum\n        if\
    \ (sum % 2 == 1) return 0\n        val half = sum / 2\n        val dp = Array.fill(n\
    \ + 1, half + 1)(0L)\n        dp(0)(0) = 1\n        for (i <- 1 to n) {\n    \
    \        for (j <- 0 to half) {\n                dp(i)(j) = dp(i - 1)(j)\n   \
    \             if (j >= arr(i - 1)) dp(i)(j) += dp(i - 1)(j - arr(i - 1))\n   \
    \         }\n        }\n        dp(n)(half)", "        val n = arr.length\n  \
    \      val a = arr.sorted\n        val b = a.reverse\n        var i = 0\n    \
    \    var j = 0\n        var count = 0\n        while (i < n && j < n) {\n    \
    \        if (a(i) + b(j) == 0) {\n                count += 1\n               \
    \ i += 1\n                j += 1\n            } else if (a(i) + b(j) > 0) {\n\
    \                j += 1\n            } else {\n                i += 1\n      \
    \      }\n        }\n        count", "        val n = arr.length\n        val\
    \ m = arr.max\n        val s = arr.sum\n        if (s % 2 == 1) return 0\n   \
    \     val dp = Array.fill(n + 1, (s / 2 + 1).toInt)(0L)\n        dp(0)(0) = 1\n\
    \        for (i <- 1 to n) {\n            for (j <- 0 to (s / 2).toInt) {\n  \
    \              dp(i)(j) = dp(i - 1)(j)\n                if (j >= arr(i - 1)) dp(i)(j)\
    \ += dp(i - 1)(j - arr(i - 1).toInt)\n            }\n        }\n        dp(n)(s\
    \ / 2.toInt)", "        val sorted = arr.sorted\n        val n = sorted.length\n\
    \        var i = 0\n        while (i < n) {\n            val j = i + 1\n     \
    \       if (j < n && sorted(i) + sorted(j) % 2 == 0) {\n                i += 2\n\
    \            } else {\n                return -1\n            }\n        }\n \
    \       return 1", "        val n = arr.length\n        val sorted = arr.sorted\n\
    \        val max = sorted.last\n        val min = sorted.head\n        if (max\
    \ - min > 1) return -1\n        if (max == min) {\n            if (max == 0) return\
    \ (n * (n - 1) / 2)\n            else return -1\n        }\n        val count\
    \ = new Array[Long](2)\n        for (i <- 0 until n) {\n            count(arr(i).toInt)\
    \ += 1\n        }\n        if (count(0) == 0 || count(1) == 0) return -1\n   \
    \     if (count(0) == count(1)) return (count(0) * (count(0) - 1) / 2)\n     \
    \   if (count(0) > count(1)) return (count(1) * (count(1) - 1) / 2)\n        else\
    \ return (count(0) * (count(0) - 1) / 2)", "        val n = arr.length\n     \
    \   val dp = Array.fill(n)(0L)\n        dp(0) = arr(0)\n        for (i <- 1 until\
    \ n) {\n            dp(i) = dp(i - 1) + arr(i)\n        }\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            val j = i - 1\n          \
    \  if (j >= 0 && dp(i) - dp(j) <= arr(i)) result += 1\n        }\n        result",
  "        val n = arr.length\n        val sorted = arr.sorted\n        var i = 0\n\
    \        var j = n - 1\n        var count = 0\n        while (i < j) {\n     \
    \       if (sorted(i) + sorted(j) == 0) {\n                count += 1\n      \
    \          i += 1\n                j -= 1\n            } else if (sorted(i) +\
    \ sorted(j) < 0) {\n                i += 1\n            } else {\n           \
    \     j -= 1\n            }\n        }\n        count", "        val n = arr.length\n\
    \        val sorted = arr.sorted\n        val max = sorted.last\n        val min\
    \ = sorted.head\n        val diff = max - min\n        if (diff % (n - 1) != 0)\
    \ return -1\n        val step = diff / (n - 1)\n        var i = 0\n        while\
    \ (i < n) {\n            if (sorted(i) != min + step * i) return -1\n        \
    \    i += 1\n        }\n        return max", "        val arr2 = arr.sorted\n\
    \        val arr3 = arr2.zipWithIndex\n        val arr4 = arr3.map(x => (x._1,\
    \ x._2 + 1))\n        val arr5 = arr4.map(x => (x._1, x._2, x._1 - x._2))\n  \
    \      val arr6 = arr5.filter(x => x._3 >= 0)\n        val arr7 = arr6.map(x =>\
    \ (x._1, x._2, x._3, x._3 / x._2))\n        val arr8 = arr7.filter(x => x._4 ==\
    \ 0)\n        val arr9 = arr8.map(x => x._1)\n        if (arr9.length == 0) -1\
    \ else arr9.max", "        val n = arr.length\n        val sorted = arr.sorted\n\
    \        val max = sorted.last\n        val min = sorted.head\n        val maxIndex\
    \ = sorted.indexOf(max)\n        val minIndex = sorted.indexOf(min)\n        if\
    \ (maxIndex == 0) return -1\n        if (minIndex == n - 1) return -1\n      \
    \  if (maxIndex == n - 1) return maxIndex - 1\n        if (minIndex == 0) return\
    \ minIndex + 1\n        if (maxIndex < minIndex) return maxIndex\n        if (minIndex\
    \ > maxIndex) return minIndex\n        -1", "        val n = arr.length\n    \
    \    val sorted = arr.sorted\n        val max = sorted.max\n        val min =\
    \ sorted.min\n        val sum = sorted.sum\n        if (sum % 2 == 1) return 0\n\
    \        val target = sum / 2\n        if (max > target) return 0\n        if\
    \ (min == target) return 1\n        val dp = Array.fill(target.toInt + 1)(0L)\n\
    \        dp(0) = 1\n        for (i <- 0 until n) {\n            val x = sorted(i)\n\
    \            for (j <- target.toInt to x.toInt by -1) {\n                dp(j)\
    \ += dp(j - x.toInt)\n            }\n        }\n        dp(target.toInt)", " \
    \       val n = arr.length\n        val m = arr.max\n        val a = Array.fill(m.toInt\
    \ + 1)(0)\n        for (i <- 0 until n) a(arr(i).toInt) += 1\n        var sum\
    \ = 0L\n        for (i <- 0 to m.toInt) {\n            sum += a(i) * (a(i) - 1)\
    \ / 2\n            if (i + i <= m) sum += a(i) * a(i + i)\n        }\n       \
    \ sum", "        val n = arr.length\n        val dp = Array.fill(n)(0L)\n    \
    \    dp(0) = arr(0)\n        for (i <- 1 until n) dp(i) = dp(i - 1) + arr(i)\n\
    \        var result = 0L\n        for (i <- 0 until n) {\n            val left\
    \ = if (i == 0) 0 else dp(i - 1)\n            val right = dp(n - 1) - dp(i)\n\
    \            if (left == right) result += 1\n        }\n        result", "   \
    \     val sum = arr.sum\n        if (sum % 2 == 1) return 0\n        val half\
    \ = sum / 2\n        val dp = Array.fill(half + 1)(0L)\n        dp(0) = 1\n  \
    \      for (x <- arr) {\n            for (i <- half to x by -1) {\n          \
    \      dp(i) += dp(i - x)\n            }\n        }\n        dp(half)", "    \
    \    val n = arr.length\n        val sorted = arr.sorted\n        val min = sorted.head\n\
    \        val max = sorted.last\n        val diff = max - min\n        val diffs\
    \ = new Array[Long](n)\n        for (i <- 0 until n) {\n            diffs(i) =\
    \ sorted(i) - min\n        }\n        val count = new Array[Long](diff + 1)\n\
    \        for (i <- 0 until n) {\n            count(diffs(i).toInt) += 1\n    \
    \    }\n        var result = 0L\n        for (i <- 0 until n) {\n            val\
    \ c = count(diffs(i).toInt)\n            if (c > 1) {\n                result\
    \ += c * (c - 1) / 2\n            }\n        }\n        result", "        val\
    \ n = arr.length\n        val dp = Array.fill(n)(0L)\n        dp(0) = arr(0)\n\
    \        for (i <- 1 until n) dp(i) = dp(i - 1) + arr(i)\n        var max = 0L\n\
    \        for (i <- 0 until n) {\n            val x = arr(i)\n            val y\
    \ = dp(n - 1) - dp(i)\n            if (x == y) max = max max x\n        }\n  \
    \      max", "        val n = arr.length\n        val arr2 = arr.sorted\n    \
    \    var sum = 0L\n        for (i <- 0 until n) {\n            sum += arr2(i)\n\
    \        }\n        if (sum % 2 == 1) return 0\n        val target = sum / 2\n\
    \        val dp = Array.fill(n + 1)(0L)\n        dp(0) = 1\n        for (i <-\
    \ 0 until n) {\n            for (j <- (n - 1) to i by -1) {\n                dp(j)\
    \ += dp(j - 1)\n            }\n        }\n        var result = 0L\n        for\
    \ (i <- 0 until n) {\n            val j = arr2.indexOf(target - arr2(i))\n   \
    \         if (j != -1) {\n                result += dp(j) * dp(n - j - 1)\n  \
    \          }\n        }\n        result", "        val n = arr.length\n      \
    \  val arr2 = arr.sorted\n        val arr3 = arr2.reverse\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n\
    \        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n\
    \        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n\
    \        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n\
    \        var z = 0\n        var aa = 0\n        var bb = 0\n        var cc = 0\n\
    \        var dd = 0\n        var ee = 0\n        var ff = 0\n        var gg =\
    \ 0\n        var hh = 0\n        var ii = 0\n        var jj = 0\n        var kk\
    \ = 0\n        var ll = 0\n        var mm = 0\n        var nn = 0\n        var\
    \ oo = 0\n        var pp = 0\n        var qq = 0\n        var rr = 0\n       \
    \ var ss = 0\n        var tt = 0\n        var uu = 0\n        var vv = 0\n   \
    \     var ww = 0\n        var xx = 0\n        var yy = 0\n        var zz = 0\n\
    \        var aaa = 0\n        var bbb = 0\n        var ccc = 0\n        var ddd\
    \ = 0\n        var eee = 0\n        var fff = 0\n        var ggg = 0\n       \
    \ var hhh = 0\n        var iii = 0\n        var jjj = 0\n        var kkk = 0\n\
    \        var lll = 0\n        var mmm = 0\n        var nnn = 0\n        var ooo\
    \ = 0\n        var ppp = 0\n        var qqq = 0\n        var rrr = 0\n       \
    \ var sss = 0\n        var ttt = 0\n        var uuu = 0\n        var vvv = 0\n\
    \        var www = 0\n        var xxx = 0\n        var yyy = 0\n        var zzz\
    \ = 0\n        var aaaa = 0\n        var bbbb = 0\n        var cccc = 0", "  \
    \      val sorted = arr.sorted\n        val n = sorted.length\n        val max\
    \ = sorted(n - 1)\n        val min = sorted(0)\n        val diff = max - min\n\
    \        if (diff == 0) return 0\n        val d = diff / n\n        val r = diff\
    \ % n\n        if (r == 0) return d\n        if (n % 2 == 0) return -1\n     \
    \   val mid = sorted(n / 2)\n        if (mid - min > d) return -1\n        if\
    \ (max - mid > d) return -1\n        return d + 1", "        val n = arr.length\n\
    \        val arr2 = arr.sorted\n        var i = 0\n        while (i < n) {\n \
    \           if (arr2(i) >= 0) {\n                if (i == 0 || arr2(i) != arr2(i\
    \ - 1)) {\n                    var j = i + 1\n                    while (j < n\
    \ && arr2(j) < 0) {\n                        if (arr2(j) == -arr2(i)) {\n    \
    \                        arr2(i) = -1\n                            arr2(j) = -1\n\
    \                            j = n\n                        }\n              \
    \          j += 1\n                    }\n                }\n            }\n \
    \           i += 1\n        }\n        var count = 0\n        for (i <- 0 until\
    \ n) {\n            if (arr2(i) != -1) count += 1\n        }\n        if (count\
    \ % 2 == 0) 1 else 0", "        val n = arr.length\n        val sorted = arr.sorted\n\
    \        var i = 0\n        var j = n - 1\n        var count = 0\n        while\
    \ (i < j) {\n            if (sorted(i) + sorted(j) == 0) {\n                count\
    \ += 1\n                i += 1\n                j -= 1\n            } else if\
    \ (sorted(i) + sorted(j) < 0) {\n                i += 1\n            } else {\n\
    \                j -= 1\n            }\n        }\n        count", "        val\
    \ n = arr.length\n        val arr2 = arr.sorted\n        var i = 0\n        var\
    \ j = n - 1\n        while (i < j) {\n            if (arr2(i) + arr2(j) == 0)\
    \ {\n                i += 1\n                j -= 1\n            } else if (arr2(i)\
    \ + arr2(j) > 0) {\n                j -= 1\n            } else {\n           \
    \     i += 1\n            }\n        }\n        if (i == j) {\n            if\
    \ (arr2(i) == 0) 1 else 0\n        } else {\n            1\n        }", "    \
    \    val n = arr.length\n        val dp = Array.fill(n)(0)\n        for (i <-\
    \ 0 until n) {\n            val x = arr(i)\n            var j = i - 1\n      \
    \      while (j >= 0 && arr(j) >= x) j -= 1\n            if (j >= 0) dp(i) = dp(j)\
    \ + 1\n            else dp(i) = 1\n        }\n        dp.max", "        val sorted\
    \ = arr.sorted\n        val max = sorted.last\n        val min = sorted.head\n\
    \        if (max - min > 1) return -1\n        if (max - min == 1) {\n       \
    \     val count = sorted.count(_ == max)\n            if (count == 1) return sorted.indexOf(max)\n\
    \            else return -1\n        }\n        val count = sorted.count(_ ==\
    \ min)\n        if (count == 1) return sorted.indexOf(min)\n        else return\
    \ -1", "        val sorted = arr.sorted\n        var sum = 0L\n        for (i\
    \ <- 0 until sorted.length) {\n            sum += sorted(i)\n        }\n     \
    \   if (sum % 2 == 1) return 0\n        val target = sum / 2\n        val dp =\
    \ Array.fill(target.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 0 until\
    \ sorted.length) {\n            for (j <- target.toInt to sorted(i).toInt by -1)\
    \ {\n                dp(j) += dp(j - sorted(i).toInt)\n            }\n       \
    \ }\n        dp(target.toInt)", "        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        val max = sorted.last\n        val min = sorted.head\n\
    \        val diff = max - min\n        val sum = sorted.sum\n        if (sum %\
    \ 2 == 1) return 0\n        val target = sum / 2\n        if (diff > target) return\
    \ 0\n        val dp = Array.fill(target + 1)(0L)\n        dp(0) = 1\n        for\
    \ (i <- 0 until n) {\n            val cur = sorted(i)\n            for (j <- target\
    \ to cur by -1) {\n                dp(j) += dp(j - cur)\n            }\n     \
    \   }\n        dp(target) / 2", "        val n = arr.length\n        val dp =\
    \ Array.fill(n)(0L)\n        for (i <- 0 until n) {\n            val x = arr(i)\n\
    \            var j = i - 1\n            while (j >= 0 && arr(j) >= x) j -= 1\n\
    \            if (j == -1) dp(i) = 1\n            else dp(i) = dp(j) + 1\n    \
    \    }\n        dp.sum", "        val sorted = arr.sorted\n        var max = 0L\n\
    \        for (i <- 0 until sorted.length) {\n            val diff = sorted(i)\
    \ - sorted(i - 1)\n            if (diff > max) max = diff\n        }\n       \
    \ max", "        val n = arr.length\n        val m = arr.max\n        val dp =\
    \ Array.fill(n + 1)(0L)\n        for (i <- 0 until n) {\n            val a = arr(i)\n\
    \            for (j <- 1 to n) {\n                dp(j) = max(dp(j), dp(j - 1))\n\
    \                if (a <= j) dp(j) = max(dp(j), dp(j - a.toInt) + a)\n       \
    \     }\n        }\n        dp(n)", "        val sorted = arr.sorted\n       \
    \ var sum = 0L\n        for (i <- 0 until sorted.length) {\n            sum +=\
    \ sorted(i)\n        }\n        if (sum % 2 == 1) return 0\n        val target\
    \ = sum / 2\n        val dp = Array.fill(target.toInt + 1)(0L)\n        dp(0)\
    \ = 1\n        for (i <- 0 until sorted.length) {\n            for (j <- target.toInt\
    \ to sorted(i).toInt by -1) {\n                dp(j) += dp(j - sorted(i).toInt)\n\
    \            }\n        }\n        dp(target.toInt)", "        val n = arr.length\n\
    \        val sorted = arr.sorted\n        var i = 0\n        var j = n - 1\n \
    \       var count = 0\n        while (i < j) {\n            if (sorted(i) + sorted(j)\
    \ == 0) {\n                count += 1\n                i += 1\n              \
    \  j -= 1\n            } else if (sorted(i) + sorted(j) < 0) {\n             \
    \   i += 1\n            } else {\n                j -= 1\n            }\n    \
    \    }\n        count", "        val n = arr.length\n        val sum = arr.sum\n\
    \        if (sum % 2 == 1) return 0\n        val half = sum / 2\n        val dp\
    \ = Array.fill(n + 1, half + 1)(0)\n        dp(0)(0) = 1\n        for (i <- 1\
    \ to n) {\n            for (j <- 0 to half) {\n                dp(i)(j) = dp(i\
    \ - 1)(j)\n                if (j >= arr(i - 1)) dp(i)(j) += dp(i - 1)(j - arr(i\
    \ - 1))\n            }\n        }\n        dp(n)(half)", "        val sorted =\
    \ arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n \
    \       val count = new Array[Long](max.toInt + 1)\n        for (i <- sorted)\
    \ count(i.toInt) += 1\n        for (i <- min.toInt to max.toInt) {\n         \
    \   if (count(i) > 0) {\n                val j = i + 1\n                if (j\
    \ <= max.toInt && count(j) > 0) {\n                    count(i) -= 1\n       \
    \             count(j) -= 1\n                }\n            }\n        }\n   \
    \     count.sum / 2", "        val n = arr.length\n        val sorted = arr.sorted\n\
    \        val min = sorted.head\n        val max = sorted.last\n        val sum\
    \ = sorted.sum\n        if (sum % 2 == 1) return 0\n        val target = sum /\
    \ 2\n        if (min > target) return 0\n        if (max < target) return 0\n\
    \        val dp = Array.fill(n + 1, target.toInt + 1)(0)\n        for (i <- 0\
    \ to n) dp(i)(0) = 1\n        for (i <- 1 to n) {\n            for (j <- 1 to\
    \ target.toInt) {\n                dp(i)(j) = dp(i - 1)(j)\n                if\
    \ (j >= sorted(i - 1)) dp(i)(j) += dp(i - 1)(j - sorted(i - 1).toInt)\n      \
    \      }\n        }\n        dp(n)(target.toInt)", "        val n = arr.length\n\
    \        val m = arr.max\n        val a = Array.fill(m.toInt + 1)(0)\n       \
    \ for (i <- 0 until n) a(arr(i).toInt) += 1\n        var sum = 0L\n        for\
    \ (i <- 0 to m.toInt) {\n            sum += a(i) * (a(i) - 1) / 2\n          \
    \  for (j <- i + 1 to m.toInt) {\n                if ((i + j) % 2 == 0) {\n  \
    \                  val k = (i + j) / 2\n                    if (k <= m.toInt)\
    \ sum += a(i) * a(j) * a(k)\n                }\n            }\n        }\n   \
    \     sum", "        val n = arr.length\n        val max = arr.max\n        val\
    \ min = arr.min\n        val sum = arr.sum\n        if (sum % 2 == 1) return 0\n\
    \        val half = sum / 2\n        if (max > half) return 0\n        if (min\
    \ == half) return 1\n        val dp = Array.fill(half + 1)(0L)\n        dp(0)\
    \ = 1\n        for (i <- 0 until n) {\n            val x = arr(i)\n          \
    \  for (j <- half - x to 0 by -1) {\n                dp(j + x) += dp(j)\n    \
    \        }\n        }\n        dp(half)", "        val sorted = arr.sorted\n \
    \       val n = sorted.length\n        val sum = sorted.sum\n        if (sum %\
    \ 2 == 1) return 0\n        val half = sum / 2\n        val dp = Array.fill(n\
    \ + 1, half + 1)(0L)\n        dp(0)(0) = 1\n        for (i <- 1 to n) {\n    \
    \        for (j <- 0 to half) {\n                dp(i)(j) = dp(i - 1)(j)\n   \
    \             if (j >= sorted(i - 1)) dp(i)(j) += dp(i - 1)(j - sorted(i - 1))\n\
    \            }\n        }\n        dp(n)(half)", "        val n = arr.length\n\
    \        val arr2 = arr.sorted\n        val arr3 = arr2.reverse\n        var sum\
    \ = 0L\n        for (i <- 0 until n) {\n            if (i % 2 == 0) sum += arr3(i)\n\
    \            else sum -= arr3(i)\n        }\n        if (sum % 2 == 0) sum / 2\n\
    \        else -1", "        var sum = 0L\n        for (i <- arr) {\n         \
    \   sum += i\n        }\n        if (sum % 2 == 1) return 0\n        val half\
    \ = sum / 2\n        val dp = Array.fill(arr.length + 1)(0L)\n        dp(0) =\
    \ 1\n        for (i <- 0 until arr.length) {\n            for (j <- (half - arr(i)).toInt\
    \ to 0 by -1) {\n                dp(j + arr(i).toInt) += dp(j)\n            }\n\
    \        }\n        dp(half.toInt)", "        val n = arr.length\n        val\
    \ sorted = arr.sorted\n        val max = sorted.last\n        val min = sorted.head\n\
    \        val maxIndex = arr.indexOf(max)\n        val minIndex = arr.indexOf(min)\n\
    \        if (maxIndex == n - 1 || minIndex == 0) return -1\n        if (maxIndex\
    \ == minIndex) return maxIndex\n        if (maxIndex < minIndex) return maxIndex\n\
    \        if (minIndex < maxIndex) return minIndex\n        return -1", "     \
    \   val n = arr.length\n        val sorted = arr.sorted\n        val sum = sorted.sum\n\
    \        if (sum % 2 == 1) return 0\n        val half = sum / 2\n        val dp\
    \ = Array.fill(n + 1, half + 1)(0L)\n        dp(0)(0) = 1\n        for (i <- 1\
    \ to n) {\n            val x = sorted(i - 1)\n            for (j <- 0 to half)\
    \ {\n                dp(i)(j) = dp(i - 1)(j)\n                if (j >= x) dp(i)(j)\
    \ += dp(i - 1)(j - x)\n            }\n        }\n        dp(n)(half)", "     \
    \   val n = arr.length\n        var sum = 0L\n        for (i <- 0 until n) {\n\
    \            sum += arr(i)\n        }\n        if (sum % 2 == 1) return 0\n  \
    \      val half = sum / 2\n        val dp = Array.fill(n + 1)(0L)\n        dp(0)\
    \ = 1\n        for (i <- 0 until n) {\n            for (j <- n - 1 to 0 by -1)\
    \ {\n                if (dp(j) == 1 && arr(i) + j <= half) {\n               \
    \     dp(j + arr(i).toInt) = 1\n                }\n            }\n        }\n\
    \        if (dp(half.toInt) == 1) return 1\n        return 0", "        val sorted\
    \ = arr.sorted\n        val n = sorted.length\n        var i = 0\n        var\
    \ j = n - 1\n        var count = 0\n        while (i < j) {\n            if (sorted(i)\
    \ + sorted(j) == 0) {\n                count += 1\n                i += 1\n  \
    \              j -= 1\n            } else if (sorted(i) + sorted(j) < 0) {\n \
    \               i += 1\n            } else {\n                j -= 1\n       \
    \     }\n        }\n        count", "        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        var i = 0\n        var j = n - 1\n        var count =\
    \ 0\n        while (i < j) {\n            if (sorted(i) + sorted(j) == 0) {\n\
    \                count += 1\n                i += 1\n                j -= 1\n\
    \            } else if (sorted(i) + sorted(j) < 0) {\n                i += 1\n\
    \            } else {\n                j -= 1\n            }\n        }\n    \
    \    count", "        val n = arr.length\n        val sorted = arr.sorted\n  \
    \      val max = sorted.max\n        val min = sorted.min\n        val diff =\
    \ max - min\n        if (diff == 0) return 0\n        val count = Array.fill(diff.toInt\
    \ + 1)(0)\n        for (i <- 0 until n) {\n            count(sorted(i).toInt -\
    \ min.toInt) += 1\n        }\n        var result = 0L\n        for (i <- 0 until\
    \ n) {\n            val x = sorted(i)\n            val y = x - min\n         \
    \   if (y == 0) {\n                if (count(y) > 1) {\n                    result\
    \ += 1\n                    count(y) -= 2\n                }\n            } else\
    \ if (y == diff) {\n                if (count(y) > 1) {\n                    result\
    \ += 1\n                    count(y) -= 2\n                }\n            } else\
    \ {\n                if (count(y) > 0 && count(y - 1) > 0) {\n               \
    \     result += 1\n                    count(y) -= 1\n                    count(y\
    \ - 1) -= 1\n                }\n            }\n        }\n        result", " \
    \       val n = arr.length\n        val sorted = arr.sorted\n        val max =\
    \ sorted.max\n        val min = sorted.min\n        val diff = max - min\n   \
    \     if (diff % (n - 1) != 0) return -1\n        val d = diff / (n - 1)\n   \
    \     var i = 0\n        while (i < n) {\n            if (sorted(i) != min + d\
    \ * i) return -1\n            i += 1\n        }\n        return d", "        val\
    \ n = arr.length\n        val sorted = arr.sorted\n        val min = sorted.head\n\
    \        val max = sorted.last\n        val sum = arr.sum\n        if (sum % 2\
    \ == 1) return 0\n        if (min * 2 > sum) return 0\n        if (max * 2 < sum)\
    \ return 0\n        val dp = Array.fill(n + 1, n + 1)(0L)\n        dp(0)(0) =\
    \ 1\n        for (i <- 1 to n) {\n            for (j <- 0 to n) {\n          \
    \      dp(i)(j) = dp(i - 1)(j)\n                if (j >= sorted(i - 1)) dp(i)(j)\
    \ += dp(i - 1)(j - sorted(i - 1))\n            }\n        }\n        dp(n)(sum\
    \ / 2)", "        val n = arr.length\n        val arr2 = arr.sorted\n        val\
    \ arr3 = arr2.reverse\n        var i = 0\n        var j = 0\n        var count\
    \ = 0\n        while (i < n && j < n) {\n            if (arr2(i) == arr3(j)) {\n\
    \                count += 1\n                i += 1\n                j += 1\n\
    \            } else if (arr2(i) > arr3(j)) {\n                i += 1\n       \
    \     } else {\n                j += 1\n            }\n        }\n        if (count\
    \ == n) 1 else 0", "        val n = arr.length\n        val dp = Array.fill(n)(0L)\n\
    \        for (i <- 0 until n) {\n            val a = arr(i)\n            for (j\
    \ <- 0 until n) {\n                if (dp(j) == 0) {\n                    dp(j)\
    \ = a\n                    break\n                }\n                else if (dp(j)\
    \ % a == 0) {\n                    dp(j) = a\n                    break\n    \
    \            }\n            }\n        }\n        var count = 0L\n        for\
    \ (i <- 0 until n) {\n            if (dp(i) != 0) count += 1\n        }\n    \
    \    count", "        val n = arr.length\n        var sum = 0L\n        for (i\
    \ <- 0 until n) {\n            sum += arr(i)\n        }\n        if (sum % 2 ==\
    \ 1) return 0\n        val dp = Array.fill(n + 1, (sum / 2).toInt + 1)(0L)\n \
    \       dp(0)(0) = 1\n        for (i <- 1 to n) {\n            for (j <- 0 to\
    \ (sum / 2).toInt) {\n                dp(i)(j) = dp(i - 1)(j)\n              \
    \  if (j >= arr(i - 1)) {\n                    dp(i)(j) += dp(i - 1)(j - arr(i\
    \ - 1).toInt)\n                }\n            }\n        }\n        dp(n)((sum\
    \ / 2).toInt)", "        val sorted = arr.sorted\n        val min = sorted.head\n\
    \        val max = sorted.last\n        val sum = sorted.sum\n        if (sum\
    \ % 2 == 1) return 0\n        val target = sum / 2\n        if (target < min ||\
    \ target > max) return 0\n        val dp = Array.fill(target.toInt + 1)(0L)\n\
    \        dp(0) = 1\n        for (i <- sorted) {\n            for (j <- target.toInt\
    \ to i.toInt by -1) {\n                dp(j) += dp(j - i.toInt)\n            }\n\
    \        }\n        dp(target.toInt)", "        val n = arr.length\n        val\
    \ sorted = arr.sorted\n        val max = sorted.last\n        val min = sorted.head\n\
    \        val diff = max - min\n        if (diff % (n - 1) != 0) return -1\n  \
    \      val d = diff / (n - 1)\n        var i = 0\n        while (i < n) {\n  \
    \          if (sorted(i) != min + i * d) return -1\n            i += 1\n     \
    \   }\n        return max", "        val sorted = arr.sorted\n        val sum\
    \ = sorted.sum\n        if (sum % 2 == 1) return 0\n        val half = sum / 2\n\
    \        val dp = Array.fill(half.toInt + 1)(0L)\n        dp(0) = 1\n        for\
    \ (i <- 0 until sorted.length) {\n            for (j <- half.toInt to sorted(i).toInt\
    \ by -1) {\n                dp(j) += dp(j - sorted(i).toInt)\n            }\n\
    \        }\n        dp(half.toInt)", "        val n = arr.length\n        val\
    \ sorted = arr.sorted\n        val max = sorted.last\n        val min = sorted.head\n\
    \        if (max - min > 1) return -1\n        if (max - min == 1) {\n       \
    \     if (sorted.count(_ == max) == 1) return -1\n            else return sorted.indexOf(max)\n\
    \        }\n        return n - 1", "        val n = arr.length\n        val max\
    \ = arr.max\n        val sum = arr.sum\n        if (sum % 2 == 1) return 0\n \
    \       val half = sum / 2\n        val dp = Array.fill(n + 1, half + 1)(0L)\n\
    \        dp(0)(0) = 1\n        for (i <- 1 to n) {\n            for (j <- 0 to\
    \ half) {\n                dp(i)(j) = dp(i - 1)(j)\n                if (j >= arr(i\
    \ - 1)) dp(i)(j) += dp(i - 1)(j - arr(i - 1))\n            }\n        }\n    \
    \    dp(n)(half)", "        val n = arr.length\n        val sorted = arr.sorted\n\
    \        val max = sorted.last\n        val min = sorted.head\n        val diff\
    \ = max - min\n        if (diff % (n - 1) != 0) return -1\n        val d = diff\
    \ / (n - 1)\n        var i = 0\n        while (i < n - 1) {\n            if (sorted(i\
    \ + 1) - sorted(i) != d) return -1\n            i += 1\n        }\n        return\
    \ d", "        val n = arr.length\n        val arr2 = arr.sorted\n        val\
    \ arr3 = arr2.reverse\n        var sum = 0L\n        for (i <- 0 until n) {\n\
    \            sum += arr3(i)\n            if (sum < i + 1) return -1\n        }\n\
    \        sum", "        val sorted = arr.sorted\n        val max = sorted.last\n\
    \        val min = sorted.head\n        val diff = max - min\n        if (diff\
    \ == 0) return 0\n        val count = arr.count(_ == max)\n        if (count ==\
    \ arr.length) return -1\n        val maxCount = arr.count(_ == max)\n        val\
    \ minCount = arr.count(_ == min)\n        if (maxCount == minCount) return 0\n\
    \        val maxIndex = arr.indexOf(max)\n        val minIndex = arr.indexOf(min)\n\
    \        if (maxIndex < minIndex) return maxIndex\n        else return minIndex",
  "        val n = arr.length\n        val sorted = arr.sorted\n        val min =\
    \ sorted.head\n        val max = sorted.last\n        if (max - min > 1) return\
    \ -1\n        if (max - min == 1) {\n            val minCount = sorted.count(_\
    \ == min)\n            val maxCount = sorted.count(_ == max)\n            if (minCount\
    \ == maxCount) return 0\n            if (minCount == maxCount + 1) return 1\n\
    \            if (minCount == maxCount - 1) return 1\n            return -1\n \
    \       }\n        if (max - min == 0) {\n            val count = sorted.count(_\
    \ == min)\n            if (count % 2 == 0) return 0\n            return -1\n \
    \       }\n        return -1", "        val n = arr.length\n        val arr2 =\
    \ arr.sorted\n        var max = 0L\n        for (i <- 0 until n) {\n         \
    \   val x = arr2(i)\n            var j = i + 1\n            while (j < n && arr2(j)\
    \ <= x + 1) j += 1\n            max = max max (j - i)\n        }\n        max",
  "        var sum = 0L\n        for (x <- arr) {\n            sum += x\n        }\n\
    \        if (sum % 2 == 1) return 0\n        var count = 0L\n        for (x <-\
    \ arr) {\n            if (x % 2 == 1) count += 1\n        }\n        if (count\
    \ % 2 == 1) return 0\n        return 1", "        val n = arr.length\n       \
    \ val dp = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n            val\
    \ x = arr(i)\n            var j = i - 1\n            while (j >= 0 && arr(j) >=\
    \ x) {\n                dp(i) = max(dp(i), dp(j))\n                j -= 1\n  \
    \          }\n            dp(i) += x\n        }\n        dp.max", "        val\
    \ n = arr.length\n        val sorted = arr.sorted\n        var sum = 0L\n    \
    \    for (i <- 0 until n) {\n            sum += sorted(i)\n        }\n       \
    \ if (sum % 2 == 1) return 0\n        val half = sum / 2\n        val dp = Array.fill(n\
    \ + 1)(0L)\n        dp(0) = 1\n        for (i <- 0 until n) {\n            for\
    \ (j <- n to 0 by -1) {\n                if (j - sorted(i) >= 0) {\n         \
    \           dp(j) += dp(j - sorted(i))\n                }\n            }\n   \
    \     }\n        dp(half)", "        val n = arr.length\n        val sum = arr.sum\n\
    \        if (sum % 2 == 1) return 0\n        val half = sum / 2\n        val dp\
    \ = Array.fill(n + 1, half + 1)(0L)\n        dp(0)(0) = 1\n        for (i <- 1\
    \ to n) {\n            for (j <- 0 to half) {\n                dp(i)(j) = dp(i\
    \ - 1)(j)\n                if (j >= arr(i - 1)) dp(i)(j) += dp(i - 1)(j - arr(i\
    \ - 1))\n            }\n        }\n        dp(n)(half)", "        val n = arr.length\n\
    \        val dp = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n        \
    \    val x = arr(i)\n            for (j <- 0 until n) {\n                if (x\
    \ % arr(j) == 0) dp(i) += 1\n            }\n        }\n        var result = 0L\n\
    \        for (i <- 0 until n) {\n            val x = arr(i)\n            for (j\
    \ <- 0 until n) {\n                if (arr(j) % x == 0) result += dp(j)\n    \
    \        }\n            result -= dp(i)\n        }\n        result / 2", "   \
    \     val n = arr.length\n        val sorted = arr.sorted\n        val max = sorted.last\n\
    \        val min = sorted.head\n        if (max - min > 1) return -1\n       \
    \ if (max == min) {\n            if (max == 0) return (n * (n - 1)) / 2\n    \
    \        else return (n * (n - 1)) / 2 - 1\n        }\n        var count = 0\n\
    \        for (i <- 0 until n) {\n            if (sorted(i) == 0) count += 1\n\
    \        }\n        if (count == n) return (n * (n - 1)) / 2\n        if (count\
    \ == n - 1) return (n * (n - 1)) / 2 - 1\n        if (count == 0) return (n *\
    \ (n - 1)) / 2 - 1\n        if (count == 1) return (n * (n - 1)) / 2 - 2\n   \
    \     return -1", "        val sorted = arr.sorted\n        val sum = sorted.sum\n\
    \        if (sum % 2 == 1) return 0\n        val half = sum / 2\n        val dp\
    \ = Array.fill(half.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 0 until\
    \ sorted.length) {\n            for (j <- half.toInt to sorted(i).toInt by -1)\
    \ {\n                dp(j) += dp(j - sorted(i).toInt)\n            }\n       \
    \ }\n        dp(half.toInt)", "        val n = arr.length\n        val dp = Array.fill(n)(0L)\n\
    \        for (i <- 0 until n) {\n            dp(i) = arr(i)\n            for (j\
    \ <- 0 until i) {\n                if (arr(j) <= arr(i)) {\n                 \
    \   dp(i) = max(dp(i), dp(j) + arr(i))\n                }\n            }\n   \
    \     }\n        dp.max", "        var i = 0\n        var j = arr.length - 1\n\
    \        var sum = 0L\n        while (i < j) {\n            if (arr(i) == arr(j))\
    \ {\n                i += 1\n                j -= 1\n            } else if (arr(i)\
    \ < arr(j)) {\n                sum += arr(i)\n                i += 1\n       \
    \     } else {\n                sum -= arr(j)\n                j -= 1\n      \
    \      }\n        }\n        if (i == j) sum += arr(i)\n        if (sum == 0)\
    \ 1 else 0", "        val sorted = arr.sorted\n        var sum = 0L\n        for\
    \ (i <- 0 until sorted.length) {\n            sum += sorted(i)\n        }\n  \
    \      if (sum % 2 == 1) return 0\n        val target = sum / 2\n        val dp\
    \ = Array.fill(target.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 0 until\
    \ sorted.length) {\n            for (j <- target.toInt to sorted(i).toInt by -1)\
    \ {\n                dp(j) += dp(j - sorted(i).toInt)\n            }\n       \
    \ }\n        dp(target.toInt)", "        val n = arr.length\n        val s = arr.sorted\n\
    \        val m = s.max\n        val a = Array.fill(m.toInt + 1)(0)\n        for\
    \ (i <- 0 until n) {\n            a(s(i).toInt) += 1\n        }\n        var count\
    \ = 0\n        for (i <- 0 until n) {\n            val x = s(i)\n            if\
    \ (x == 0) {\n                if (a(x.toInt) >= 2) {\n                    count\
    \ += 1\n                    a(x.toInt) -= 2\n                }\n            }\
    \ else {\n                if (a(x.toInt) >= 1 && a(x.toInt - 1) >= 1) {\n    \
    \                count += 1\n                    a(x.toInt) -= 1\n           \
    \         a(x.toInt - 1) -= 1\n                }\n            }\n        }\n \
    \       count", "        val n = arr.length\n        val max = arr.max\n     \
    \   val count = Array.fill(max.toInt + 1)(0)\n        for (i <- 0 until n) {\n\
    \            count(arr(i).toInt) += 1\n        }\n        var result = 0L\n  \
    \      for (i <- 0 until n) {\n            val x = arr(i)\n            if (count(x.toInt)\
    \ > 0) {\n                count(x.toInt) -= 1\n                val y = x - 1\n\
    \                if (y >= 0 && count(y.toInt) > 0) {\n                    count(y.toInt)\
    \ -= 1\n                    result += 1\n                }\n            }\n  \
    \      }\n        result", "        val n = arr.length\n        val dp = Array.fill(n)(0L)\n\
    \        dp(0) = arr(0)\n        for (i <- 1 until n) {\n            dp(i) = dp(i\
    \ - 1) + arr(i)\n        }\n        var sum = 0L\n        for (i <- 0 until n)\
    \ {\n            if (dp(i) % 2 == 0) {\n                val index = binarySearch(dp,\
    \ dp(i) / 2)\n                if (index != -1) {\n                    sum += index\
    \ + 1\n                }\n            }\n        }\n        sum", "        val\
    \ sorted = arr.sorted\n        val n = sorted.length\n        val sum = sorted.sum\n\
    \        if (sum % 2 == 1) return 0\n        val target = sum / 2\n        val\
    \ dp = Array.fill(target + 1)(0L)\n        dp(0) = 1\n        for (i <- 0 until\
    \ n) {\n            for (j <- target to sorted(i) by -1) {\n                dp(j)\
    \ += dp(j - sorted(i))\n            }\n        }\n        dp(target) / 2", " \
    \       val n = arr.length\n        val arr2 = arr.sorted\n        var i = 0\n\
    \        while (i < n) {\n            if (arr2(i) != i + 1) return -1\n      \
    \      i += 1\n        }\n        return 1", "        val sorted = arr.sorted\n\
    \        val n = sorted.length\n        val max = sorted(n - 1)\n        val min\
    \ = sorted(0)\n        val diff = max - min\n        if (diff % 2 == 0) {\n  \
    \          val mid = min + diff / 2\n            var count = 0\n            for\
    \ (i <- 0 until n) {\n                if (sorted(i) == mid) count += 1\n     \
    \       }\n            if (count % 2 == 0) return 1\n            else return 0\n\
    \        }\n        else return 0", "        var max = arr.max\n        var sum\
    \ = arr.sum\n        if (sum % 2 == 1) return 0\n        var dp = Array.fill(sum.toInt\
    \ + 1)(0L)\n        dp(0) = 1\n        for (i <- 0 until arr.length) {\n     \
    \       for (j <- sum.toInt to arr(i).toInt by -1) {\n                dp(j) +=\
    \ dp(j - arr(i).toInt)\n            }\n        }\n        return dp(sum.toInt\
    \ / 2)", "        val n = arr.length\n        val sorted = arr.sorted\n      \
    \  val min = sorted.head\n        val max = sorted.last\n        val diff = max\
    \ - min\n        if (diff > n) return -1\n        val count = new Array[Long](n)\n\
    \        for (i <- 0 until n) count(i) = 0\n        for (i <- 0 until n) count(arr(i).toInt\
    \ - min.toInt) += 1\n        var d = 0\n        for (i <- 0 until n) {\n     \
    \       if (count(i) > 0) {\n                var j = i\n                while\
    \ (j < n && count(j) > 0) {\n                    count(j) -= 1\n             \
    \       j += diff\n                }\n                if (j != i + diff) return\
    \ -1\n            }\n        }\n        return 1", "        val n = arr.length\n\
    \        val arr2 = arr.sorted\n        var i = 0\n        var j = n - 1\n   \
    \     var count = 0\n        while (i < j) {\n            if (arr2(i) + arr2(j)\
    \ == 0) {\n                count += 1\n                i += 1\n              \
    \  j -= 1\n            } else if (arr2(i) + arr2(j) < 0) {\n                i\
    \ += 1\n            } else {\n                j -= 1\n            }\n        }\n\
    \        count", "        val n = arr.length\n        val sorted = arr.sorted\n\
    \        val max = sorted.last\n        val min = sorted.head\n        if (max\
    \ - min > 1) return -1\n        if (max == min) {\n            if (max == 0) return\
    \ (n * (n - 1)) / 2\n            else if (n % max == 0) return (n / max) * ((n\
    \ / max) - 1) / 2\n            else return -1\n        }\n        val zeros =\
    \ sorted.count(_ == 0)\n        val ones = sorted.count(_ == 1)\n        if (zeros\
    \ == 0) return (ones * (ones - 1)) / 2\n        else if (ones == 0) return (zeros\
    \ * (zeros - 1)) / 2\n        else return (zeros * ones) + (zeros * (zeros - 1))\
    \ / 2", "        val sorted = arr.sorted\n        var i = 0\n        var j = sorted.length\
    \ - 1\n        var count = 0\n        while (i < j) {\n            if (sorted(i)\
    \ + sorted(j) == 0) {\n                count += 1\n                i += 1\n  \
    \              j -= 1\n            } else if (sorted(i) + sorted(j) < 0) {\n \
    \               i += 1\n            } else {\n                j -= 1\n       \
    \     }\n        }\n        count", "        val sorted = arr.sorted\n       \
    \ val n = sorted.length\n        var i = 0\n        var j = n - 1\n        var\
    \ count = 0\n        while (i < j) {\n            if (sorted(i) + sorted(j) ==\
    \ 0) {\n                count += 1\n                i += 1\n                j\
    \ -= 1\n            } else if (sorted(i) + sorted(j) < 0) {\n                i\
    \ += 1\n            } else {\n                j -= 1\n            }\n        }\n\
    \        count", "        val n = arr.length\n        val dp = Array.fill(n)(0L)\n\
    \        for (i <- 0 until n) {\n            val x = arr(i)\n            var j\
    \ = i - 1\n            while (j >= 0 && arr(j) >= x) {\n                j -= 1\n\
    \            }\n            if (j >= 0) {\n                dp(i) = dp(j) + 1\n\
    \            }\n        }\n        dp.max", "        val n = arr.length\n    \
    \    val sorted = arr.sorted\n        val sum = arr.sum\n        if (sum % 2 ==\
    \ 1) return 0\n        val half = sum / 2\n        val dp = Array.fill(n + 1,\
    \ half + 1)(0L)\n        dp(0)(0) = 1\n        for (i <- 1 to n) {\n         \
    \   for (j <- 0 to half) {\n                dp(i)(j) = dp(i - 1)(j)\n        \
    \        if (j >= sorted(i - 1)) dp(i)(j) += dp(i - 1)(j - sorted(i - 1))\n  \
    \          }\n        }\n        dp(n)(half)", "        val sorted = arr.sorted\n\
    \        val sum = sorted.sum\n        if (sum % 2 == 1) return 0\n        val\
    \ half = sum / 2\n        val dp = Array.fill(half.toInt + 1)(0L)\n        dp(0)\
    \ = 1\n        for (i <- 0 until sorted.length) {\n            for (j <- half.toInt\
    \ to sorted(i).toInt by -1) {\n                dp(j) += dp(j - sorted(i).toInt)\n\
    \            }\n        }\n        dp(half.toInt)", "        val sorted = arr.sorted\n\
    \        val n = sorted.length\n        val max = sorted(n - 1)\n        val min\
    \ = sorted(0)\n        val diff = max - min\n        val sum = sorted.sum\n  \
    \      if (sum % 2 == 1) return 0\n        if (diff % 2 == 1) return 0\n     \
    \   val half = sum / 2\n        if (half < min) return 0\n        if (half > max)\
    \ return 0\n        val dp = Array.fill(half + 1)(0L)\n        dp(0) = 1\n   \
    \     for (i <- 0 until n) {\n            val x = sorted(i)\n            for (j\
    \ <- half to x by -1) {\n                dp(j) += dp(j - x)\n            }\n \
    \       }\n        dp(half)", "        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        var i = 0\n        var j = n - 1\n        var count =\
    \ 0\n        while (i < j) {\n            if (sorted(i) + sorted(j) == 0) {\n\
    \                count += 1\n                i += 1\n                j -= 1\n\
    \            } else if (sorted(i) + sorted(j) < 0) {\n                i += 1\n\
    \            } else {\n                j -= 1\n            }\n        }\n    \
    \    count", "        val n = arr.length\n        val dp = Array.fill(n)(0L)\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until i) {\n        \
    \        if (arr(j) <= arr(i)) {\n                    dp(i) = max(dp(i), dp(j)\
    \ + 1)\n                }\n            }\n        }\n        dp.max", "      \
    \  val n = arr.length\n        val sorted = arr.sorted\n        val max = sorted.last\n\
    \        val min = sorted.head\n        val diff = max - min\n        if (diff\
    \ == 0) return 0\n        if (diff % (n - 1) != 0) return -1\n        val step\
    \ = diff / (n - 1)\n        var i = 0\n        while (i < n - 1) {\n         \
    \   if (sorted(i + 1) - sorted(i) != step) return -1\n            i += 1\n   \
    \     }\n        return step", "        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        val max = sorted.last\n        val min = sorted.head\n\
    \        if (max - min > 1) return -1\n        if (max - min == 1) {\n       \
    \     if (sorted.count(_ == max) > 1) return -1\n            if (sorted.count(_\
    \ == min) > 1) return -1\n        }\n        var result = 0L\n        for (i <-\
    \ 0 until n) {\n            if (sorted(i) == max) result += 1\n            else\
    \ result += max - sorted(i)\n        }\n        result", "        val sorted =\
    \ arr.sorted\n        val n = sorted.length\n        val max = sorted(n - 1)\n\
    \        val min = sorted(0)\n        if (max - min > 1) return -1\n        if\
    \ (max == min) return (n * (n - 1)) / 2\n        val count = Array.fill(n)(0)\n\
    \        for (i <- 0 until n) {\n            count(i) = sorted.count(_ == sorted(i))\n\
    \        }\n        val countMax = count(n - 1)\n        val countMin = count(0)\n\
    \        if (countMax == countMin) return (countMax * (countMax - 1)) / 2\n  \
    \      else return countMax * countMin", "        val n = arr.length\n       \
    \ val sorted = arr.sorted\n        val max = sorted.last\n        val min = sorted.head\n\
    \        val sum = arr.sum\n        if (sum % 2 == 1) return 0\n        if (max\
    \ > sum / 2) return 0\n        if (min == max) {\n            if (n % 2 == 0)\
    \ return 1\n            else return 0\n        }\n        var count = 0L\n   \
    \     for (i <- 0 until n) {\n            if (arr(i) == min) count += 1\n    \
    \    }\n        if (count % 2 == 1) return 0\n        return 1", "        val\
    \ n = arr.length\n        val sorted = arr.sorted\n        val mid = sorted(n\
    \ / 2)\n        var sum = 0L\n        for (i <- 0 until n) {\n            sum\
    \ += abs(sorted(i) - mid)\n        }\n        sum", "        val sorted = arr.sorted\n\
    \        val n = sorted.length\n        val max = sorted(n - 1)\n        val min\
    \ = sorted(0)\n        val maxIndex = n - 1\n        val minIndex = 0\n      \
    \  var maxCount = 0\n        var minCount = 0\n        var i = 0\n        while\
    \ (i < n) {\n            if (sorted(i) == max) {\n                maxCount +=\
    \ 1\n            }\n            if (sorted(i) == min) {\n                minCount\
    \ += 1\n            }\n            i += 1\n        }\n        if (max == min)\
    \ {\n            if (maxCount % 2 == 0) {\n                return 1\n        \
    \    } else {\n                return 0\n            }\n        }\n        if\
    \ (maxCount == 1) {\n            if (minCount == 1) {\n                return\
    \ 1\n            } else {\n                return 0\n            }\n        }\n\
    \        if (minCount == 1) {\n            if (maxCount == 1) {\n            \
    \    return 1\n            } else {\n                return 0\n            }\n\
    \        }\n        if (maxCount > 1) {\n            if (minCount > 1) {\n   \
    \             return 0\n            } else {\n                return 1\n     \
    \       }\n        }\n        if (minCount > 1) {\n            if (maxCount >\
    \ 1) {\n                return 0\n            } else {\n                return\
    \ 1\n            }\n        }\n        return 0", "        val n = arr.length\n\
    \        val sorted = arr.sorted\n        val sum = sorted.sum\n        if (sum\
    \ % 2 == 1) return 0\n        val half = sum / 2\n        val dp = Array.fill(n\
    \ + 1, half + 1)(0L)\n        dp(0)(0) = 1\n        for (i <- 1 to n) {\n    \
    \        for (j <- 0 to half) {\n                dp(i)(j) = dp(i - 1)(j)\n   \
    \             if (j >= sorted(i - 1)) dp(i)(j) += dp(i - 1)(j - sorted(i - 1))\n\
    \            }\n        }\n        dp(n)(half)", "        val n = arr.length\n\
    \        val dp = Array.fill(n)(0)\n        for (i <- 0 until n) {\n         \
    \   var j = i - 1\n            while (j >= 0 && arr(j) >= arr(i)) j -= 1\n   \
    \         dp(i) = j\n        }\n        var result = 0L\n        for (i <- 0 until\
    \ n) {\n            var j = i + 1\n            while (j < n && dp(j) >= i) {\n\
    \                result += arr(i)\n                j = dp(j) + 1\n           \
    \ }\n        }\n        result", "        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        var i = 0\n        var j = n - 1\n        var count =\
    \ 0\n        while (i < j) {\n            if (sorted(i) + sorted(j) == 0) {\n\
    \                count += 1\n                i += 1\n                j -= 1\n\
    \            } else if (sorted(i) + sorted(j) < 0) {\n                i += 1\n\
    \            } else {\n                j -= 1\n            }\n        }\n    \
    \    count", "        val n = arr.length\n        val m = arr.max\n        val\
    \ dp = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n            val x =\
    \ arr(i)\n            if (x == m) dp(i) = 1\n            else {\n            \
    \    var j = i - 1\n                while (j >= 0 && arr(j) >= x) j -= 1\n   \
    \             if (j >= 0) dp(i) = dp(j) + 1\n            }\n        }\n      \
    \  dp.max", "        val sorted = arr.sorted\n        val n = sorted.length\n\
    \        val min = sorted(0)\n        val max = sorted(n - 1)\n        val sum\
    \ = sorted.sum\n        if (sum % 2 == 1) return 0\n        val target = sum /\
    \ 2\n        if (min == max) {\n            if (min * n == target) return 1\n\
    \            else return 0\n        }\n        val diff = max - min\n        if\
    \ (diff > target) return 0\n        if (diff == target) return 1\n        val\
    \ m = target - diff\n        val count = Array.fill(target.toInt + 1)(0)\n   \
    \     count(0) = 1\n        for (i <- 0 until n) {\n            val x = sorted(i)\n\
    \            for (j <- target.toInt to x.toInt by -1) {\n                count(j)\
    \ += count(j - x.toInt)\n            }\n        }\n        return count(target.toInt)",
  "        val sorted = arr.sorted\n        val sortedReverse = sorted.reverse\n \
    \       val sum = sorted.sum\n        if (sum % 2 == 1) return -1\n        val\
    \ half = sum / 2\n        val dp = Array.fill(half + 1)(0L)\n        dp(0) = 1\n\
    \        for (i <- 0 until sorted.length) {\n            for (j <- half to sorted(i)\
    \ by -1) {\n                dp(j) += dp(j - sorted(i))\n            }\n      \
    \  }\n        var result = 0L\n        for (i <- 0 until sortedReverse.length)\
    \ {\n            val j = half - sortedReverse(i)\n            if (j >= 0) result\
    \ += dp(j)\n        }\n        result", "        val n = arr.length\n        val\
    \ sorted = arr.sorted\n        var i = 0\n        while (i < n - 1) {\n      \
    \      if (sorted(i) * 2 != sorted(i + 1)) return -1\n            i += 2\n   \
    \     }\n        return 1", "        val n = arr.length\n        val sum = arr.sum\n\
    \        if (sum % 2 == 1) return 0\n        val half = sum / 2\n        val dp\
    \ = Array.fill(half + 1)(0L)\n        dp(0) = 1\n        for (i <- 0 until n)\
    \ {\n            val x = arr(i)\n            for (j <- half to x by -1) {\n  \
    \              dp(j) += dp(j - x)\n            }\n        }\n        dp(half)",
  "        val n = arr.length\n        val sorted = arr.sorted\n        val max =\
    \ sorted.last\n        val min = sorted.head\n        if (max - min > n - 1) return\
    \ -1\n        val count = Array.fill(n)(0L)\n        for (i <- 0 until n) count(arr(i).toInt\
    \ - min.toInt) += 1\n        var result = 0L\n        for (i <- 0 until n) {\n\
    \            if (count(i) > 0) {\n                val d = min + i\n          \
    \      val m = (n - 1 - i) min count(i)\n                result += m\n       \
    \         count(i) -= m\n                count(n - 1 - i) -= m\n            }\n\
    \        }\n        result", "        val n = arr.length\n        val dp = Array.fill(n)(0L)\n\
    \        for (i <- 0 until n) {\n            val x = arr(i)\n            var j\
    \ = i - 1\n            while (j >= 0 && arr(j) >= x) j -= 1\n            if (j\
    \ == -1) dp(i) = 1\n            else dp(i) = dp(j) + 1\n        }\n        dp.sum",
  "        val n = arr.length\n        val dp = Array.fill(n)(0L)\n        dp(0) =\
    \ arr(0)\n        for (i <- 1 until n) {\n            dp(i) = dp(i - 1) + arr(i)\n\
    \        }\n        var result = 0L\n        for (i <- 0 until n) {\n        \
    \    val x = arr(i)\n            val y = dp(n - 1) - dp(i)\n            if (x\
    \ == y) result += 1\n        }\n        result", "        val n = arr.length\n\
    \        val arr2 = arr.sorted\n        val arr3 = arr2.reverse\n        var sum\
    \ = 0L\n        for (i <- 0 until n) {\n            if (i % 2 == 0) sum += arr3(i)\n\
    \            else sum -= arr3(i)\n        }\n        if (sum % 2 == 0) sum / 2\
    \ else -1", "        val sorted = arr.sorted\n        val min = sorted.head\n\
    \        val max = sorted.last\n        val diff = max - min\n        val count\
    \ = arr.length\n        if (diff % (count - 1) != 0) return -1\n        val step\
    \ = diff / (count - 1)\n        var i = 0\n        while (i < count) {\n     \
    \       if (sorted(i) != min + i * step) return -1\n            i += 1\n     \
    \   }\n        return min", "        val n = arr.length\n        val sum = arr.sum\n\
    \        if (sum % 2 == 1) return 0\n        val half = sum / 2\n        val dp\
    \ = Array.fill(n + 1, half + 1)(0L)\n        dp(0)(0) = 1\n        for (i <- 1\
    \ to n) {\n            for (j <- 0 to half) {\n                dp(i)(j) = dp(i\
    \ - 1)(j)\n                if (j >= arr(i - 1)) dp(i)(j) += dp(i - 1)(j - arr(i\
    \ - 1))\n            }\n        }\n        return dp(n)(half)", "        var sum\
    \ = 0L\n        for (i <- arr) sum += i\n        if (sum % 2 == 1) return 0\n\
    \        val n = arr.length\n        val dp = Array.fill(n + 1, (sum / 2 + 1).toInt)(0L)\n\
    \        dp(0)(0) = 1\n        for (i <- 1 to n) {\n            for (j <- 0 to\
    \ sum / 2) {\n                dp(i)(j) = dp(i - 1)(j)\n                if (j >=\
    \ arr(i - 1)) dp(i)(j) += dp(i - 1)(j - arr(i - 1).toInt)\n            }\n   \
    \     }\n        dp(n)(sum / 2)", "        val n = arr.length\n        val dp\
    \ = Array.fill(n)(0L)\n        dp(0) = arr(0)\n        for (i <- 1 until n) {\n\
    \            dp(i) = dp(i - 1) + arr(i)\n        }\n        var max = 0L\n   \
    \     for (i <- 0 until n) {\n            var l = 0\n            var r = n - 1\n\
    \            while (l <= r) {\n                val m = (l + r) / 2\n         \
    \       if (dp(m) - dp(i) + arr(i) <= arr(i)) {\n                    max = max\
    \ max (m - i + 1)\n                    l = m + 1\n                } else {\n \
    \                   r = m - 1\n                }\n            }\n        }\n \
    \       max", "        val sorted = arr.sorted\n        val n = sorted.length\n\
    \        val max = sorted(n - 1)\n        val min = sorted(0)\n        val diff\
    \ = max - min\n        if (diff % 2 == 0) {\n            val half = diff / 2\n\
    \            val minIndex = sorted.indexOf(min + half)\n            val maxIndex\
    \ = sorted.indexOf(max - half)\n            if (minIndex != -1 && maxIndex !=\
    \ -1) {\n                if (minIndex == maxIndex) {\n                    if (sorted.count(_\
    \ == min + half) >= 2) {\n                        return 1\n                 \
    \   }\n                } else {\n                    return 1\n              \
    \  }\n            }\n        }\n        return -1", "        val sorted = arr.sorted\n\
    \        val min = sorted.head\n        val max = sorted.last\n        val range\
    \ = max - min + 1\n        if (range > arr.length) return -1\n        var count\
    \ = 0\n        var i = 0\n        while (i < arr.length) {\n            if (sorted(i)\
    \ == min + i) count += 1\n            i += 1\n        }\n        if (count ==\
    \ range) return arr.length - range\n        return -1", "        val n = arr.length\n\
    \        val sorted = arr.sorted\n        val min = sorted.head\n        val max\
    \ = sorted.last\n        val sum = sorted.sum\n        val diff = max - min\n\
    \        if (diff == 0) {\n            if (sum % 2 == 0) {\n                return\
    \ 1\n            } else {\n                return 0\n            }\n        }\n\
    \        if (diff == 1) {\n            if (sum % 2 == 0) {\n                return\
    \ 2\n            } else {\n                return 0\n            }\n        }\n\
    \        if (diff == 2) {\n            if (sum % 2 == 0) {\n                return\
    \ 3\n            } else {\n                return 1\n            }\n        }\n\
    \        if (diff == 3) {\n            if (sum % 2 == 0) {\n                return\
    \ 4\n            } else {\n                return 2\n            }\n        }\n\
    \        if (diff == 4) {\n            if (sum % 2 == 0) {\n                return\
    \ 5\n            } else {\n                return 3\n            }\n        }\n\
    \        if (diff == 5) {\n            if (sum % 2 == 0) {\n                return\
    \ 6\n            } else {\n                return 4\n            }\n        }\n\
    \        if (diff == 6) {\n            if (sum % 2 == 0) {\n                return\
    \ 7\n            } else {\n                return 5\n            }\n        }\n\
    \        if (diff == 7) {\n            if (sum % 2 == 0) {\n                return\
    \ 8\n            } else {\n                return 6\n            }\n        }\n\
    \        if (diff == 8) {\n            if (sum % 2 == 0) {\n                return\
    \ 9\n            } else {\n                return 7\n            }\n        }\n\
    \        if (diff == 9) {\n            if (sum % 2 == 0) {\n                return\
    \ 10\n            } else {\n                return 8\n            }\n        }\n\
    \        if (diff == 10) {\n            if (sum % 2 == 0) {\n                return\
    \ 11\n            } else {\n                return 9\n            }\n        }\n\
    \        if (diff == 11) {\n            if (sum % 2 == 0) {\n                return\
    \ 12\n            } else {\n                return 10\n", "        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val range = max - min + 1\n        val count = Array.fill(range.toInt)(0)\n\
    \        for (x <- sorted) count(x.toInt - min.toInt) += 1\n        var result\
    \ = 0L\n        for (i <- 0 until range.toInt) {\n            if (count(i) > 0)\
    \ {\n                val x = min + i\n                val y = 2 * x\n        \
    \        if (y <= max) {\n                    result += count(i) * count(y.toInt\
    \ - min.toInt)\n                }\n            }\n        }\n        result",
  "        val n = arr.length\n        val dp = Array.fill(n)(0L)\n        dp(0) =\
    \ 1\n        for (i <- 1 until n) {\n            val x = arr(i)\n            var\
    \ j = i - 1\n            while (j >= 0 && arr(j) >= x) j -= 1\n            if\
    \ (j == -1) dp(i) = dp(i - 1)\n            else dp(i) = dp(i - 1) + dp(j)\n  \
    \      }\n        dp(n - 1)", "        val n = arr.length\n        val a = arr.sorted\n\
    \        val b = arr.sorted.reverse\n        var i = 0\n        var j = 0\n  \
    \      var sum = 0L\n        while (i < n && j < n) {\n            if (i != j)\
    \ {\n                sum += a(i) * b(j)\n            }\n            i += 1\n \
    \           j += 1\n        }\n        sum", "        val n = arr.length\n   \
    \     val sorted = arr.sorted\n        val min = sorted.head\n        val max\
    \ = sorted.last\n        val diffs = sorted.zip(sorted.tail).map(x => x._2 - x._1)\n\
    \        val minDiff = diffs.min\n        val maxDiff = diffs.max\n        val\
    \ minDiffCount = diffs.count(_ == minDiff)\n        val maxDiffCount = diffs.count(_\
    \ == maxDiff)\n        if (minDiff == maxDiff) {\n            val n = diffs.length\n\
    \            val k = minDiffCount\n            val r = n - k\n            if (k\
    \ == r) (k * (k - 1)) / 2\n            else k * r\n        } else {\n        \
    \    minDiffCount * maxDiffCount\n        }", "        val n = arr.length\n  \
    \      val arr2 = arr.sorted\n        var i = 0\n        while (i < n - 1) {\n\
    \            if (arr2(i) == arr2(i + 1)) return 0\n            i += 1\n      \
    \  }\n        var sum = 0L\n        i = 0\n        while (i < n) {\n         \
    \   sum += arr2(i)\n            i += 1\n        }\n        if (sum % 2 == 1) return\
    \ 0\n        val half = sum / 2\n        val dp = Array.fill(n + 1)(0L)\n    \
    \    dp(0) = 1\n        i = 0\n        while (i < n) {\n            var j = n\n\
    \            while (j >= 0) {\n                if (dp(j) == 1 && j + arr2(i) <=\
    \ n) dp(j + arr2(i).toInt) = 1\n                j -= 1\n            }\n      \
    \      if (dp(half.toInt) == 1) return 1\n            i += 1\n        }\n    \
    \    0", "        var max = -1L\n        var min = Long.MaxValue\n        for\
    \ (i <- arr) {\n            max = max max i\n            min = min min i\n   \
    \     }\n        if (max - min > arr.length) return -1\n        val count = new\
    \ Array[Long](arr.length)\n        for (i <- arr) count(i.toInt - min.toInt) +=\
    \ 1\n        var i = 0\n        var j = 0\n        while (i < arr.length) {\n\
    \            if (count(i) > 0) {\n                arr(j) = i + min\n         \
    \       j += 1\n                count(i) -= 1\n            }\n            else\
    \ i += 1\n        }\n        var result = 0L\n        for (i <- 1 until arr.length)\
    \ {\n            if (arr(i) < arr(i - 1)) result += 1\n        }\n        result",
  "        val n = arr.length\n        val max = arr.max\n        val min = arr.min\n\
    \        if (max - min > n) return -1\n        val count = Array.fill(n)(0)\n\
    \        for (i <- 0 until n) count(arr(i).toInt - min.toInt) += 1\n        var\
    \ i = 0\n        var j = 0\n        while (i < n) {\n            if (count(i)\
    \ > 0) {\n                if (count(i) > 1) return -1\n                if (i +\
    \ min > arr(j)) return -1\n                count(i) -= 1\n                j +=\
    \ 1\n            }\n            i += 1\n        }\n        return j.toLong", " \
    \       val n = arr.length\n        val sorted = arr.sorted\n        val sum =\
    \ arr.sum\n        if (sum % 2 == 1) return 0\n        val half = sum / 2\n  \
    \      val dp = Array.fill(half + 1)(0L)\n        dp(0) = 1\n        for (i <-\
    \ 0 until n) {\n            val x = sorted(i)\n            for (j <- half to x\
    \ by -1) {\n                dp(j) += dp(j - x)\n            }\n        }\n   \
    \     dp(half)", "        val n = arr.length\n        val dp = Array.fill(n)(0)\n\
    \        for (i <- 0 until n) {\n            val x = arr(i)\n            var j\
    \ = i - 1\n            while (j >= 0 && arr(j) >= x) j -= 1\n            dp(i)\
    \ = j + 1\n        }\n        var ans = 0L\n        for (i <- 0 until n) {\n \
    \           val x = arr(i)\n            var j = i - 1\n            while (j >=\
    \ 0 && arr(j) > x) j -= 1\n            if (j >= 0) ans += (j - dp(i) + 1)\n  \
    \      }\n        ans", "        val sorted = arr.sorted\n        val sum = sorted.sum\n\
    \        if (sum % 2 == 1) return 0\n        val half = sum / 2\n        val dp\
    \ = Array.fill(half.toInt + 1)(0L)\n        dp(0) = 1\n        for (i <- 0 until\
    \ sorted.length) {\n            for (j <- half to sorted(i).toInt by -1) {\n \
    \               dp(j) += dp(j - sorted(i).toInt)\n            }\n        }\n \
    \       dp(half.toInt)", "        val n = arr.length\n        val sorted = arr.sorted\n\
    \        val max = sorted.last\n        val min = sorted.head\n        val diff\
    \ = max - min\n        if (diff % (n - 1) != 0) -1\n        else {\n         \
    \   var i = 0\n            var j = n - 1\n            var count = 0\n        \
    \    while (i < j) {\n                val a = sorted(i)\n                val b\
    \ = sorted(j)\n                if (a + b == diff) {\n                    count\
    \ += 1\n                    i += 1\n                    j -= 1\n             \
    \   }\n                else if (a + b < diff) i += 1\n                else j -=\
    \ 1\n            }\n            count\n        }", "        val n = arr.length\n\
    \        val m = arr.max\n        val dp = Array.fill(n + 1, m.toInt + 1)(0L)\n\
    \        dp(0)(0) = 1\n        for (i <- 1 to n) {\n            for (j <- 0 to\
    \ m.toInt) {\n                dp(i)(j) = dp(i - 1)(j)\n                if (j >=\
    \ arr(i - 1)) dp(i)(j) += dp(i - 1)(j - arr(i - 1).toInt)\n            }\n   \
    \     }\n        dp(n)(m.toInt)", "        val n = arr.length\n        val m =\
    \ arr.max\n        val dp = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n\
    \            dp(i) = arr(i)\n            for (j <- 0 until i) {\n            \
    \    if (arr(j) < arr(i)) dp(i) = max(dp(i), dp(j) + arr(i))\n            }\n\
    \        }\n        dp.max", "        val n = arr.length\n        val dp = Array.fill(n)(0L)\n\
    \        dp(0) = arr(0)\n        for (i <- 1 until n) {\n            dp(i) = dp(i\
    \ - 1) + arr(i)\n        }\n        var result = 0L\n        for (i <- 0 until\
    \ n) {\n            val j = i - 1\n            if (j >= 0 && dp(i) - dp(j) >=\
    \ arr(i)) result += 1\n        }\n        result", "        val sorted = arr.sorted\n\
    \        val n = sorted.length\n        for (i <- 0 until n) {\n            if\
    \ (sorted(i) != sorted(n - 1 - i)) return -1\n        }\n        return 1", " \
    \       var sum = 0L\n        for (i <- arr) sum += i\n        if (sum % 2 ==\
    \ 1) return 0\n        val half = sum / 2\n        val dp = Array.fill(half +\
    \ 1)(0L)\n        dp(0) = 1\n        for (i <- arr) {\n            for (j <- half\
    \ to i by -1) {\n                dp(j) += dp(j - i)\n            }\n        }\n\
    \        dp(half)", "        val n = arr.length\n        val arr2 = arr.sorted\n\
    \        val arr3 = arr2.reverse\n        var i = 0\n        var j = n - 1\n \
    \       var count = 0\n        while (i < j) {\n            if (arr2(i) + arr3(j)\
    \ == 0) {\n                count += 1\n                i += 1\n              \
    \  j -= 1\n            } else if (arr2(i) + arr3(j) > 0) {\n                j\
    \ -= 1\n            } else {\n                i += 1\n            }\n        }\n\
    \        count", "        val n = arr.length\n        val sorted = arr.sorted\n\
    \        val max = sorted.last\n        val min = sorted.head\n        if (max\
    \ - min > 1) return -1\n        if (max == min) {\n            if (max == 0) return\
    \ (n * (n - 1)) / 2\n            if (max == 1) return (n * (n - 1)) / 2\n    \
    \    }\n        var count = 0L\n        for (i <- 0 until n) {\n            if\
    \ (sorted(i) == max) {\n                count += n - i - 1\n            }\n  \
    \          else {\n                count += n - i\n            }\n        }\n\
    \        count", "        val n = arr.length\n        val sorted = arr.sorted\n\
    \        val max = sorted.last\n        val min = sorted.head\n        val diff\
    \ = max - min\n        if (diff % (n - 1) != 0) return -1\n        val d = diff\
    \ / (n - 1)\n        var i = 0\n        while (i < n - 1) {\n            if (sorted(i\
    \ + 1) - sorted(i) != d) return -1\n            i += 1\n        }\n        return\
    \ max", "        val sorted = arr.sorted\n        var i = 0\n        while (i\
    \ < sorted.length - 1) {\n            if (sorted(i) == sorted(i + 1)) return 0\n\
    \            i += 1\n        }\n        var j = 0\n        while (j < sorted.length\
    \ - 1) {\n            if (sorted(j) + 1 != sorted(j + 1)) return 0\n         \
    \   j += 1\n        }\n        return 1", "        val n = arr.length\n      \
    \  val sorted = arr.sorted\n        var i = 0\n        while (i < n) {\n     \
    \       if (sorted(i) >= 0) {\n                if (i == 0 || sorted(i) > sorted(i\
    \ - 1)) return -1\n                else return sorted(i - 1)\n            }\n\
    \            i += 1\n        }\n        return sorted(n - 1)", "        val n\
    \ = arr.length\n        val sorted = arr.sorted\n        val max = sorted.last\n\
    \        val min = sorted.head\n        if (max - min > 1) return -1\n       \
    \ if (max == min) {\n            if (max == 0) return (n * (n - 1)) / 2\n    \
    \        if (max % 2 == 0) return (n * (n - 1)) / 2\n            return -1\n \
    \       }\n        val count = new Array[Long](2)\n        for (i <- 0 until n)\
    \ {\n            if (sorted(i) == 0) count(0) += 1\n            else count(1)\
    \ += 1\n        }\n        if (count(0) % 2 == 1) return -1\n        return (count(0)\
    \ * (count(0) - 1)) / 2 + (count(1) * (count(1) - 1)) / 2", "        val n = arr.length\n\
    \        val m = arr.max\n        val a = Array.fill(m.toInt + 1)(0)\n       \
    \ for (i <- 0 until n) a(arr(i).toInt) += 1\n        var sum = 0L\n        for\
    \ (i <- 0 to m.toInt) {\n            sum += a(i) * i\n            a(i) = 0\n \
    \       }\n        if (sum % 2 == 1) return 0\n        val half = sum / 2\n  \
    \      var dp = Array.fill(half + 1)(0L)\n        dp(0) = 1\n        for (i <-\
    \ 0 to m.toInt) {\n            for (j <- half to i by -1) {\n                dp(j)\
    \ += dp(j - i) * a(i)\n            }\n        }\n        dp(half) / 2", "    \
    \    val n = arr.length\n        val sorted = arr.sorted\n        val max = sorted.max\n\
    \        val min = sorted.min\n        if (max - min > 1) return -1\n        if\
    \ (max == min) return (n - 1) / 2\n        val cnt = sorted.groupBy(x => x).mapValues(_.length)\n\
    \        val cnt0 = cnt.getOrElse(min, 0)\n        val cnt1 = cnt.getOrElse(max,\
    \ 0)\n        if (cnt0 > cnt1) return -1\n        if (cnt0 == cnt1) return (n\
    \ - 1) / 2\n        val diff = cnt1 - cnt0\n        if (diff % 2 == 1) return\
    \ -1\n        val k = diff / 2\n        var i = 0\n        var j = 0\n       \
    \ while (i < n && j < n) {\n            if (sorted(i) == min) i += 1\n       \
    \     else if (sorted(j) == max) j += 1\n            else {\n                if\
    \ (sorted(i) == sorted(j)) {\n                    i += 1\n                   \
    \ j += 1\n                } else if (sorted(i) < sorted(j)) {\n              \
    \      i += 1\n                    k -= 1\n                } else {\n        \
    \            j += 1\n                    k -= 1\n                }\n         \
    \   }\n            if (k == 0) return i - 1\n        }\n        -1", "       \
    \ val n = arr.length\n        val sorted = arr.sorted\n        val sum = sorted.sum\n\
    \        if (sum % 2 == 1) return 0\n        val half = sum / 2\n        val dp\
    \ = Array.fill(n + 1, half + 1)(0L)\n        dp(0)(0) = 1\n        for (i <- 1\
    \ to n) {\n            for (j <- 0 to half) {\n                dp(i)(j) = dp(i\
    \ - 1)(j)\n                if (j >= sorted(i - 1)) dp(i)(j) += dp(i - 1)(j - sorted(i\
    \ - 1))\n            }\n        }\n        dp(n)(half)"]
stop_tokens:
- "\n    }\n"
