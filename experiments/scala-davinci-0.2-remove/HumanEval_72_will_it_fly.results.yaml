language: scala
name: HumanEval_72_will_it_fly
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        var sum = 0L\n        for (i <- 0 until q.length) {\n            sum\
    \ += q(i)\n            if (sum > w) return false\n        }\n        sum == w\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmggqbn4_.scala:22)\n\tat Problem.main(tmpmggqbn4_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        val half = q.length / 2\n        val left = q.slice(0, half)\n      \
    \  val right = q.slice(half + 1, q.length)\n        if (left.sum + right.sum <=\
    \ w && left == right.reverse) return true\n        return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        val mid = q.length / 2\n        val left = q.slice(0, mid)\n        val\
    \ right = q.slice(mid + 1, q.length)\n        val leftSum = left.sum\n       \
    \ val rightSum = right.sum\n        if (leftSum > w || rightSum > w) return false\n\
    \        if (leftSum != rightSum) return false\n        return true\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val q2 = q.reverse\n\
    \        if (q == q2) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val isBalanced = q == q.reverse\n        isBalanced\
    \ && sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        if (s > w) return false\n        val m = q.max\n  \
    \      if (s - m <= m) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn4rd6e_m.scala:19)\n\tat Problem.main(tmpn4rd6e_m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        if (q.sum <= w) {\n            val m = q.length / 2\n            val\
    \ (a, b) = q.splitAt(m)\n            a == b.reverse\n        } else false\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpso8u7xn7.scala:21)\n\tat Problem.main(tmpso8u7xn7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val isPalindrome = q == q.reverse\n        sum <=\
    \ w && isPalindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        balanced &&\
    \ sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) true\n        else if (q.length % 2 == 0) false\n     \
    \   else {\n            val mid = q.length / 2\n            val left = q.slice(0,\
    \ mid)\n            val right = q.slice(mid + 1, q.length)\n            val leftSum\
    \ = left.sum\n            val rightSum = right.sum\n            if (leftSum <=\
    \ w && rightSum <= w && left == right.reverse) true\n            else false\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val n = q.length\n\
    \        for (i <- 0 until n / 2) {\n            if (q(i) != q(n - 1 - i)) return\
    \ false\n        }\n        true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009881
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        val b = q == q.reverse\n        s <= w && b\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        val mid = q.length / 2\n        val left = q.slice(0, mid)\n        val\
    \ right = q.slice(mid + 1, q.length)\n        if (left != right.reverse) return\
    \ false\n        val sum = q.sum\n        if (sum > w) return false\n        return\
    \ true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        val half = q.length / 2\n        val left = q.slice(0, half)\n      \
    \  val right = q.slice(half + 1, q.length)\n        val leftSum = left.sum\n \
    \       val rightSum = right.sum\n        if (leftSum != rightSum) return false\n\
    \        if (leftSum > w) return false\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val n = q.length\n\
    \        if (n % 2 == 0) return true\n        val m = n / 2\n        for (i <-\
    \ 0 until m) {\n            if (q(i) != q(n - 1 - i)) return false\n        }\n\
    \        return true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuy0vzuz3.scala:24)\n\tat Problem.main(tmpuy0vzuz3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val s = q.sorted\n\
    \        val n = s.length\n        for (i <- 0 until n / 2) {\n            if\
    \ (s(i) != s(n - i - 1)) return false\n        }\n        true\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_94c2m73.scala:22)\n\tat Problem.main(tmp_94c2m73.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val n = q.length\n\
    \        for (i <- 0 until n / 2) if (q(i) != q(n - 1 - i)) return false\n   \
    \     true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009881
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        val half = q.length / 2\n        val left = q.slice(0, half)\n      \
    \  val right = q.slice(half + 1, q.length)\n        val leftSum = left.sum\n \
    \       val rightSum = right.sum\n        if (leftSum > w || rightSum > w) return\
    \ false\n        if (leftSum != rightSum) return false\n        return true\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val qq = q.map(x\
    \ => x.toString)\n        val s = qq.mkString\n        val s2 = qq.reverse.mkString\n\
    \        if (s == s2) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        val balanced = q == q.reverse\n\
    \        sum <= w && balanced\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        val half = q.length / 2\n        val left = q.slice(0, half)\n      \
    \  val right = q.slice(half + 1, q.length)\n        if (left != right.reverse)\
    \ return false\n        if (left.sum + right.sum + q(half) > w) return false\n\
    \        return true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        balanced &&\
    \ sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.size == 1) return true\n        if (q.size % 2 == 0) return false\n\
    \        var sum = 0L\n        for (i <- 0 until q.size) {\n            if (i\
    \ < q.size / 2) sum += q(i)\n            else if (i > q.size / 2) sum -= q(i)\n\
    \        }\n        if (sum <= w) return true\n        return false\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmporig0qx_.scala:26)\n\tat Problem.main(tmporig0qx_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        val mid = q.length / 2\n        val left = q.slice(0, mid)\n        val\
    \ right = q.slice(mid + 1, q.length)\n        val leftSum = left.sum\n       \
    \ val rightSum = right.sum\n        if (leftSum == rightSum && leftSum <= w) return\
    \ true\n        return false\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val n = q.length\n\
    \        for (i <- 0 until n / 2) {\n            if (q(i) != q(n - 1 - i)) return\
    \ false\n        }\n        true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009881
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        (sum <= w) && (q == q.reverse)\
    \ && (max <= w)\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val q2 = q.reverse\n\
    \        if (q == q2) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        if (s > w) return false\n        val m = q.max\n  \
    \      if (m * q.length > w) return false\n        val a = q.sorted\n        val\
    \ b = a.reverse\n        a == b\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphbyenjyj.scala:21)\n\tat Problem.main(tmphbyenjyj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.sum <= w && q == q.reverse) true else false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        if (q.sum > w) return false\n        val mid = q.length / 2\n       \
    \ val left = q.take(mid)\n        val right = q.takeRight(mid)\n        val leftSum\
    \ = left.sum\n        val rightSum = right.sum\n        if (leftSum != rightSum)\
    \ return false\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        val p = q.reverse == q\n        s <= w && p\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length % 2 == 0) return false\n        val half = q.length / 2\n   \
    \     val left = q.slice(0, half)\n        val right = q.slice(half + 1, q.length)\n\
    \        val leftSum = left.sum\n        val rightSum = right.sum\n        if\
    \ (leftSum > w || rightSum > w) return false\n        if (leftSum == rightSum)\
    \ return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length == 2) return q(0) ==\
    \ q(1)\n        if (q.length % 2 == 0) return false\n        val half = q.length\
    \ / 2\n        val left = q.slice(0, half)\n        val right = q.slice(half +\
    \ 1, q.length)\n        val sum = left.sum + right.sum\n        if (sum > w) return\
    \ false\n        for (i <- 0 until half) {\n            if (left(i) != right(half\
    \ - 1 - i)) return false\n        }\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        val half = q.length / 2\n        val left = q.slice(0, half)\n      \
    \  val right = q.slice(half + 1, q.length)\n        val leftSum = left.sum\n \
    \       val rightSum = right.sum\n        if (leftSum > w || rightSum > w) return\
    \ false\n        if (leftSum != rightSum) return false\n        return true\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        if (s > w) return false\n        val qs = q.sorted\n\
    \        val qr = qs.reverse\n        if (qs != qr) return false\n        return\
    \ true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl1sa7227.scala:20)\n\tat Problem.main(tmpl1sa7227.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        balanced &&\
    \ sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        var sum = 0L\n        for (i <- 0 until q.length) {\n            if (i\
    \ < q.length / 2) sum += q(i)\n            else if (i > q.length / 2) sum -= q(i)\n\
    \        }\n        if (sum <= w) return true\n        return false\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkfpun7r6.scala:26)\n\tat Problem.main(tmpkfpun7r6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val s = q.sorted\n\
    \        val n = s.length\n        for (i <- 0 until n / 2) {\n            if\
    \ (s(i) != s(n - i - 1)) return false\n        }\n        true\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_94c2m73.scala:22)\n\tat Problem.main(tmp_94c2m73.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length % 2 == 0) {\n            false\n        } else {\n          \
    \  val q2 = q.slice(0, q.length / 2)\n            val q3 = q.slice(q.length /\
    \ 2 + 1, q.length)\n            val sum = q2.sum + q3.sum\n            if (sum\
    \ > w) {\n                false\n            } else {\n                val q2rev\
    \ = q2.reverse\n                q2rev == q3\n            }\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val s = q.sorted\n\
    \        val n = s.length\n        for (i <- 0 until n / 2) {\n            if\
    \ (s(i) != s(n - i - 1)) return false\n        }\n        true\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_94c2m73.scala:22)\n\tat Problem.main(tmp_94c2m73.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        if (s > w) return false\n        val qr = q.reverse\n\
    \        if (q == qr) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        if (s > w) return false\n        val m = q.max\n  \
    \      if (s - m > m) return false\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu_wjg_6a.scala:19)\n\tat Problem.main(tmpu_wjg_6a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val half = q.length\
    \ / 2\n        val (left, right) = q.splitAt(half)\n        left == right.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6c3y55a5.scala:19)\n\tat Problem.main(tmp6c3y55a5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        if (s > w) return false\n        val l = q.length\n\
    \        for (i <- 0 until l / 2) {\n            if (q(i) != q(l - i - 1)) return\
    \ false\n        }\n        true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && max * 2\
    \ <= sum) true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg52tdqqg.scala:19)\n\tat Problem.main(tmpg52tdqqg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val q2 = q.reverse\n\
    \        if (q == q2) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.sum <= w && q == q.reverse) true else false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        if (s > w) return false\n        val qq = q.reverse\n\
    \        for (i <- 0 until q.length) {\n            if (q(i) != qq(i)) return\
    \ false\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val q2 = q.reverse\n\
    \        for (i <- 0 until q.length) {\n            if (q(i) != q2(i)) return\
    \ false\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   var sum = 0L\n        for (i <- q) sum += i\n        if (sum > w) return false\n\
    \        var left = 0\n        var right = q.length - 1\n        while (left <\
    \ right) {\n            if (q(left) != q(right)) return false\n            left\
    \ += 1\n            right -= 1\n        }\n        return true\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        balanced &&\
    \ sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        if (s > w) return false\n        val m = q.max\n  \
    \      if (s - m > m) return false\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu_wjg_6a.scala:19)\n\tat Problem.main(tmpu_wjg_6a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val q2 = q.reverse\n\
    \        if (q == q2) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val half = q.length\
    \ / 2\n        val (left, right) = q.splitAt(half)\n        if (q.length % 2 ==\
    \ 1) {\n            val (left2, right2) = (left.init, right.tail)\n          \
    \  left2 == right2.reverse\n        } else {\n            left == right.reverse\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0enfqlvk.scala:24)\n\tat Problem.main(tmp0enfqlvk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val qq = q.sortWith(_\
    \ < _)\n        val qqr = qq.reverse\n        if (qq == qqr) return true\n   \
    \     return false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy7sfqcph.scala:20)\n\tat Problem.main(tmpy7sfqcph.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum <= w\
    \ && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        if (q.length == 3) return q(0) + q(2) <= w\n        var i = 0\n     \
    \   var j = q.length - 1\n        while (i < j) {\n            if (q(i) != q(j))\
    \ return false\n            i += 1\n            j -= 1\n        }\n        var\
    \ sum = 0L\n        for (x <- q) sum += x\n        return sum <= w\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1nzy7lec.scala:31)\n\tat Problem.main(tmp1nzy7lec.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009919
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        val half = q.length / 2\n        val left = q.slice(0, half)\n      \
    \  val right = q.slice(half + 1, q.length)\n        val leftSum = left.sum\n \
    \       val rightSum = right.sum\n        if (leftSum != rightSum) return false\n\
    \        return leftSum <= w\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length % 2 == 0) return false\n        if (q.sum > w) return false\n\
    \        val half = q.length / 2\n        for (i <- 0 until half) {\n        \
    \    if (q(i) != q(q.length - 1 - i)) return false\n        }\n        return\
    \ true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        sum <= w && q == q.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length == 2) return q(0) ==\
    \ q(1)\n        if (q.length % 2 == 0) return false\n        val half = q.length\
    \ / 2\n        val left = q.take(half)\n        val right = q.takeRight(half).reverse\n\
    \        if (left != right) return false\n        val sum = q.sum\n        if\
    \ (sum > w) return false\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val half = q.length\
    \ / 2\n        val left = q.take(half)\n        val right = q.drop(half + q.length\
    \ % 2)\n        if (left != right.reverse) return false\n        true\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        if (s > w) return false\n        val r = q.reverse\n\
    \        for (i <- 0 until q.length) {\n            if (q(i) != r(i)) return false\n\
    \        }\n        return true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        val half = q.length / 2\n        val left = q.slice(0, half)\n      \
    \  val right = q.slice(half + 1, q.length)\n        val leftSum = left.sum\n \
    \       val rightSum = right.sum\n        if (leftSum != rightSum) return false\n\
    \        if (leftSum > w) return false\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        val sum = q.sum\n        if (sum >\
    \ w) return false\n        val mid = q.length / 2\n        val (left, right) =\
    \ q.splitAt(mid)\n        if (q.length % 2 == 0) {\n            if (left != right.reverse)\
    \ return false\n        } else {\n            if (left.init != right.reverse)\
    \ return false\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp620d4kgn.scala:25)\n\tat Problem.main(tmp620d4kgn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        if (q.sum > w) return false\n        val half = q.length / 2\n      \
    \  val left = q.slice(0, half)\n        val right = q.slice(half + 1, q.length)\n\
    \        if (left.sum != right.sum) return false\n        return true\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val half = q.length\
    \ / 2\n        for (i <- 0 until half) {\n            if (q(i) != q(q.length -\
    \ 1 - i)) return false\n        }\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length % 2 == 0) return false\n        val m = q.length / 2\n      \
    \  val l = q.take(m)\n        val r = q.takeRight(m).reverse\n        if (l !=\
    \ r) return false\n        val s = q.sum\n        s <= w\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length == 2) return q(0) ==\
    \ q(1)\n        if (q.length % 2 == 0) return false\n        val mid = q.length\
    \ / 2\n        val left = q.slice(0, mid)\n        val right = q.slice(mid + 1,\
    \ q.length)\n        val leftSum = left.sum\n        val rightSum = right.sum\n\
    \        if (leftSum > w || rightSum > w) return false\n        if (leftSum !=\
    \ rightSum) return false\n        for (i <- 0 until mid) {\n            if (left(i)\
    \ != right(mid - i - 1)) return false\n        }\n        return true\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        balanced &&\
    \ sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val qq = q.reverse\n\
    \        for (i <- 0 until q.length) {\n            if (q(i) != qq(i)) return\
    \ false\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        val sum = q.sum\n        if (sum >\
    \ w) return false\n        val qs = q.sorted\n        val qr = qs.reverse\n  \
    \      if (qs == qr) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp583rvrqh.scala:21)\n\tat Problem.main(tmp583rvrqh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length % 2 == 0) return false\n        val half = q.length / 2\n   \
    \     val left = q.slice(0, half)\n        val right = q.slice(half + 1, q.length)\n\
    \        if (left != right.reverse) return false\n        val sum = q.sum\n  \
    \      if (sum > w) return false\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        balanced &&\
    \ sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val isPalindrome = q == q.reverse\n        isPalindrome\
    \ && sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val half = q.size\
    \ / 2\n        val left = q.take(half)\n        val right = q.drop(half + q.size\
    \ % 2)\n        val leftSum = left.sum\n        val rightSum = right.sum\n   \
    \     if (leftSum > rightSum) return false\n        val diff = rightSum - leftSum\n\
    \        if (diff > w - sum) return false\n        return true\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1kb2zgiv.scala:26)\n\tat Problem.main(tmp1kb2zgiv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val qs = q.sorted\n\
    \        val qr = qs.reverse\n        if (qs == qr) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_69ofdz4.scala:20)\n\tat Problem.main(tmp_69ofdz4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        val balanced = q == q.reverse\n\
    \        sum <= w && balanced && max <= w\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        if (s > w) return false\n        val m = q.max\n  \
    \      if (m * 2 > w) return false\n        val n = q.length\n        for (i <-\
    \ 0 until n / 2) {\n            if (q(i) != q(n - 1 - i)) return false\n     \
    \   }\n        return true\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3og5nk3e.scala:25)\n\tat Problem.main(tmp3og5nk3e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        val half = q.length / 2\n        val left = q.slice(0, half)\n      \
    \  val right = q.slice(half + 1, q.length)\n        val leftSum = left.sum\n \
    \       val rightSum = right.sum\n        if (leftSum != rightSum) return false\n\
    \        if (leftSum > w) return false\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val n = q.length\n\
    \        val m = n / 2\n        for (i <- 0 until m) {\n            if (q(i) !=\
    \ q(n - i - 1)) return false\n        }\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009921
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val half = q.length\
    \ / 2\n        val left = q.slice(0, half)\n        val right = q.slice(half +\
    \ q.length % 2, q.length)\n        left == right.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009921
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        balanced &&\
    \ sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val isBalanced = q == q.reverse\n        isBalanced\
    \ && sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        sum <= w && q == q.reverse\
    \ && max <= w / 2\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzrq29kfa.scala:19)\n\tat Problem.main(tmpzrq29kfa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val qq = q.map(_.toString).mkString\n\
    \        val qqq = qq.reverse\n        if (qq == qqq) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        if (s > w) return false\n        val qq = q.sorted\n\
    \        val l = qq.length\n        for (i <- 0 until l) {\n            if (qq(i)\
    \ != qq(l - i - 1)) return false\n        }\n        true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpukbeo2wj.scala:22)\n\tat Problem.main(tmpukbeo2wj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        sum <= w && q == q.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.size == 1) return true\n        if (q.size == 2) return q(0) == q(1)\n\
    \        val sum = q.sum\n        if (sum > w) return false\n        val half\
    \ = q.size / 2\n        val left = q.slice(0, half)\n        val right = q.slice(half,\
    \ q.size)\n        if (left.sum != right.sum) return false\n        return true\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpra0ehs9t.scala:23)\n\tat Problem.main(tmpra0ehs9t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        if (s > w) return false\n        val q2 = q.reverse\n\
    \        for (i <- 0 until q.length) {\n            if (q(i) != q2(i)) return\
    \ false\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        sum <= w && q == q.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   var sum = 0L\n        for (i <- q) sum += i\n        if (sum > w) return false\n\
    \        var left = 0\n        var right = q.length - 1\n        while (left <\
    \ right) {\n            if (q(left) != q(right)) return false\n            left\
    \ += 1\n            right -= 1\n        }\n        return true\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length == 2) return q(0) ==\
    \ q(1)\n        if (q.length % 2 == 0) return false\n        val mid = q.length\
    \ / 2\n        val left = q.slice(0, mid)\n        val right = q.slice(mid + 1,\
    \ q.length)\n        if (left != right.reverse) return false\n        val sum\
    \ = q.sum\n        if (sum > w) return false\n        return true\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val palindrome = q.reverse == q\n        palindrome\
    \ && sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val half = q.length\
    \ / 2\n        val left = q.slice(0, half)\n        val right = q.slice(half +\
    \ q.length % 2, q.length)\n        left == right.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009921
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val palindrome = q.reverse == q\n        palindrome\
    \ && sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        if (s > w) return false\n        val l = q.length\n\
    \        for (i <- 0 until l/2) {\n            if (q(i) != q(l-1-i)) return false\n\
    \        }\n        return true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length == 2) return q(0) ==\
    \ q(1)\n        if (q.length % 2 == 0) return false\n        val mid = q.length\
    \ / 2\n        val left = q.slice(0, mid)\n        val right = q.slice(mid + 1,\
    \ q.length)\n        if (left != right.reverse) return false\n        val sum\
    \ = q.sum\n        if (sum > w) return false\n        return true\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        val sum = q.sum\n        if (sum >\
    \ w) return false\n        val half = q.length / 2\n        val first = q.slice(0,\
    \ half)\n        val second = q.slice(half, q.length)\n        val reversed =\
    \ second.reverse\n        first == reversed\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsq1k1kvg.scala:22)\n\tat Problem.main(tmpsq1k1kvg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.sum <= w && q == q.reverse) true else false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        balanced &&\
    \ sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.size == 1) return true\n        if (q.size == 2) return q(0) == q(1)\n\
    \        if (q.size % 2 == 0) return false\n        val half = q.size / 2\n  \
    \      val left = q.slice(0, half)\n        val right = q.slice(half + 1, q.size)\n\
    \        val leftSum = left.sum\n        val rightSum = right.sum\n        if\
    \ (leftSum != rightSum) return false\n        if (leftSum > w) return false\n\
    \        return true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        if (q.length == 3) return q(0) + q(2) <= w\n        if (q.length == 5)\
    \ return q(0) + q(2) + q(4) <= w\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9zgf2dek.scala:23)\n\tat Problem.main(tmp9zgf2dek.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val qs = q.sorted\n\
    \        val qr = qs.reverse\n        if (qs != qr) return false\n        return\
    \ true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1_7cs4oj.scala:20)\n\tat Problem.main(tmp1_7cs4oj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009941
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        sum <= w && q == q.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val half = q.length\
    \ / 2\n        val first = q.take(half)\n        val second = q.takeRight(half).reverse\n\
    \        first == second\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length % 2 == 0) return false\n        val half = q.length / 2\n   \
    \     val left = q.slice(0, half)\n        val right = q.slice(half + 1, q.length)\n\
    \        if (left != right.reverse) return false\n        val sum = q.sum\n  \
    \      if (sum > w) return false\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val half = q.length\
    \ / 2\n        for (i <- 0 until half) {\n            if (q(i) != q(q.length -\
    \ 1 - i)) return false\n        }\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val s = q.sorted\n\
    \        val s2 = s.reverse\n        if (s == s2) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpufuk4yuq.scala:20)\n\tat Problem.main(tmpufuk4yuq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        val half = q.length / 2\n        val left = q.slice(0, half)\n      \
    \  val right = q.slice(half + 1, q.length)\n        val leftSum = left.sum\n \
    \       val rightSum = right.sum\n        if (leftSum != rightSum) return false\n\
    \        if (leftSum > w) return false\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        val balanced = q == q.reverse\n\
    \        balanced && sum <= w && max <= w\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        balanced &&\
    \ sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        balanced &&\
    \ sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val qs = q.sorted\n        val qs1 = qs.take(qs.length / 2)\n        val qs2\
    \ = qs.drop(qs.length / 2)\n        val qs2r = qs2.reverse\n        val qs1r =\
    \ qs1.reverse\n        val qs1r1 = if (qs.length % 2 == 0) qs1r else qs1r.tail\n\
    \        val qs2r1 = if (qs.length % 2 == 0) qs2r else qs2r.tail\n        qs1r1\
    \ == qs2r1 && qs.sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp61zkj_ws.scala:22)\n\tat Problem.main(tmp61zkj_ws.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009941
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        balanced &&\
    \ sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val isPalindrome = q == q.reverse\n        sum <=\
    \ w && isPalindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        val half = q.length / 2\n        val firstHalf = q.slice(0, half)\n \
    \       val secondHalf = q.slice(half + 1, q.length)\n        if (firstHalf.sum\
    \ + secondHalf.sum <= w && firstHalf == secondHalf.reverse) return true\n    \
    \    false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   def isPalindrome(q : List[Long]) : Boolean = {\n            if (q.length ==\
    \ 1) true\n            else if (q.length == 2) q(0) == q(1)\n            else\
    \ if (q(0) == q(q.length - 1)) isPalindrome(q.slice(1, q.length - 1))\n      \
    \      else false\n        }\n        def sum(q : List[Long]) : Long = {\n   \
    \         if (q.length == 1) q(0)\n            else q(0) + sum(q.slice(1, q.length))\n\
    \        }\n        if (isPalindrome(q) && sum(q) <= w) true\n        else false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009941
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        balanced &&\
    \ sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        val half = q.length / 2\n        val left = q.slice(0, half)\n      \
    \  val right = q.slice(half + 1, q.length)\n        val leftSum = left.sum\n \
    \       val rightSum = right.sum\n        if (leftSum != rightSum) return false\n\
    \        if (leftSum > w) return false\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        val balanced = q == q.reverse\n\
    \        sum <= w && balanced\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val s = q.sorted\n\
    \        val l = s.length\n        for (i <- 0 until l / 2) if (s(i) != s(l -\
    \ i - 1)) return false\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7ubq774u.scala:20)\n\tat Problem.main(tmp7ubq774u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009941
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.sum <= w && q == q.reverse)\
    \ return true\n        false\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009941
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        if (s > w) return false\n        val r = q.reverse\n\
    \        for (i <- 0 until q.length) {\n            if (q(i) != r(i)) return false\n\
    \        }\n        return true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val half = q.length\
    \ / 2\n        val (left, right) = q.splitAt(half)\n        if (q.length % 2 ==\
    \ 1) {\n            left == right.tail.reverse\n        } else {\n           \
    \ left == right.reverse\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009941
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length == 2) return q(0) ==\
    \ q(1)\n        if (q.length % 2 == 0) return false\n        val half = q.length\
    \ / 2\n        val left = q.slice(0, half)\n        val right = q.slice(half +\
    \ 1, q.length)\n        val leftSum = left.sum\n        val rightSum = right.sum\n\
    \        if (leftSum != rightSum) return false\n        if (leftSum > w) return\
    \ false\n        return true\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        val half = q.length / 2\n        val left = q.slice(0, half)\n      \
    \  val right = q.slice(half + 1, q.length)\n        if (left.sum + right.sum >\
    \ w) return false\n        if (left != right.reverse) return false\n        return\
    \ true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009941
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val isPalindrome = q == q.reverse\n        isPalindrome\
    \ && sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length == 2) return q(0) ==\
    \ q(1)\n        if (q.length % 2 == 0) return false\n        val half = q.length\
    \ / 2\n        val left = q.slice(0, half)\n        val right = q.slice(half +\
    \ 1, q.length)\n        val sum = left.sum + right.sum\n        if (sum > w) return\
    \ false\n        if (left != right.reverse) return false\n        return true\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009941
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length % 2 == 0) return false\n        var sum = 0L\n        for (i\
    \ <- 0 until q.length) {\n            if (i < q.length / 2) sum += q(i)\n    \
    \        else if (i > q.length / 2) sum -= q(i)\n        }\n        return sum\
    \ <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmxhw4bzd.scala:24)\n\tat Problem.main(tmpmxhw4bzd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   q.sum <= w && q == q.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        val half = q.length / 2\n        val left = q.slice(0, half)\n      \
    \  val right = q.slice(half + 1, q.length)\n        val leftSum = left.sum\n \
    \       val rightSum = right.sum\n        if (leftSum > w || rightSum > w) return\
    \ false\n        if (leftSum == rightSum) return true\n        return false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        val b = q == q.reverse\n        s <= w && b\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val n = q.length\n\
    \        for (i <- 0 until n / 2) if (q(i) != q(n - 1 - i)) return false\n   \
    \     true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009881
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val q2 = q.reverse\n\
    \        if (q == q2) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        s <= w && q == q.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        val half = q.length / 2\n        val left = q.slice(0, half)\n      \
    \  val right = q.slice(half + 1, q.length)\n        if (left != right.reverse)\
    \ return false\n        val sum = left.sum + right.sum + q(half)\n        if (sum\
    \ > w) return false\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        val b = q == q.reverse\n        s <= w && b\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val s = q.sum\n        if (s > w) return false\n        val n = q.length\n\
    \        for (i <- 0 until n / 2) {\n            if (q(i) != q(n - i - 1)) return\
    \ false\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length == 1) return true\n        if (q.length % 2 == 0) return false\n\
    \        val half = q.length / 2\n        val left = q.slice(0, half)\n      \
    \  val right = q.slice(half + 1, q.length)\n        if (left != right.reverse)\
    \ return false\n        val sum = left.sum + right.sum + q(half)\n        if (sum\
    \ > w) return false\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum <= w && q == q.reverse)\
    \ true else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val max = q.max\n        if (sum > w) return false\n\
    \        if (sum - max > w - max) return false\n        return true\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppn5d2311.scala:20)\n\tat Problem.main(tmppn5d2311.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009950
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val half = q.length\
    \ / 2\n        val first = q.take(half)\n        val second = q.takeRight(half).reverse\n\
    \        first == second\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val q2 = q.reverse\n\
    \        if (q == q2) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum <= w\
    \ && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        balanced &&\
    \ sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum <= w\
    \ && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val palindrome = q.reverse == q\n        if (sum\
    \ <= w && palindrome) true else false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum <= w\
    \ && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        sum <= w && q == q.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum <= w\
    \ && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.length % 2 == 0) return false\n        val half = q.length / 2\n   \
    \     if (q.take(half) != q.takeRight(half).reverse) return false\n        if\
    \ (q.sum <= w) return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        balanced &&\
    \ sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val q2 = q.reverse\n\
    \        if (q == q2) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        val balanced = q == q.reverse\n        sum <= w &&\
    \ balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val sum = q.sum\n        if (sum > w) return false\n        val half = q.length\
    \ / 2\n        val firstHalf = q.take(half)\n        val secondHalf = q.takeRight(half)\n\
    \        val firstHalfSum = firstHalf.sum\n        val secondHalfSum = secondHalf.sum\n\
    \        if (firstHalfSum != secondHalfSum) return false\n        return true\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   if (q.sum <= w && q == q.reverse) true else false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009899
