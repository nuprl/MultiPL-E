language: scala
name: HumanEval_10_make_palindrome
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        for (i <- 1 until n) {\n\
    \            var j = suffix(i - 1)\n            while (j > 0 && string(i) != string(j))\
    \ j = suffix(j - 1)\n            if (string(i) == string(j)) suffix(i) = j + 1\n\
    \            else suffix(i) = 0\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        prefix.reverse + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp7iymraz9.scala:11)\n\tat Problem$.main(tmp7iymraz9.scala:22)\n\
    \tat Problem.main(tmp7iymraz9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"*\" + string.reverse\n  \
    \      val n = s.length\n        val p = Array.fill(n)(0)\n        for (i <- 1\
    \ until n) {\n            var j = p(i - 1)\n            while (j > 0 && s(i) !=\
    \ s(j)) j = p(j - 1)\n            if (s(i) == s(j)) j += 1\n            p(i) =\
    \ j\n        }\n        string.substring(p(n - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4fqi9e3n.scala:23)\n\tat Problem.main(tmp4fqi9e3n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n        while (j\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(j)\
    \ = i + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (i == 0) {\n                    suffix(j) = 0\n      \
    \              j += 1\n                } else {\n                    i = suffix(i\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpp4jnnznv.scala:27)\n\tat Problem$.main(tmpp4jnnznv.scala:31)\n\
    \tat Problem.main(tmpp4jnnznv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2gll3o0.scala:21)\n\tat Problem.main(tmpl2gll3o0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val prefix = string.substring(0, string.length\
    \ - longestPalindromeSuffix(string).length)\n        string + prefix.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz83aylm5.scala:9:57 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mprefix\e[0m = string.substring(\e\
    [31m0\e[0m, string.length - longestPalindromeSuffix(string).length)\n\e[31m\e\
    [31m  |\e[0m                                                         ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                                        Not found: longestPalindromeSuffix\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010177
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val reversed = string.reverse\n        val s\
    \ = string + \"#\" + reversed\n        val lps = Array.fill(s.length)(0)\n   \
    \     for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n        \
    \    while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        reversed.substring(0, string.length - lps.last)\
    \ + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3fmcdc2r.scala:22)\n\tat Problem.main(tmp3fmcdc2r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n + 1)\n        val prefix = Array.ofDim[Int](n + 1)\n    \
    \    for (i <- 0 to n) {\n            suffix(i) = 0\n            prefix(i) = 0\n\
    \        }\n        for (i <- 1 to n) {\n            var j = suffix(i - 1)\n \
    \           while (j > 0 && string(i - 1) != string(j - 1)) j = suffix(j - 1)\n\
    \            if (string(i - 1) == string(j - 1)) suffix(i) = j + 1\n         \
    \   else suffix(i) = 0\n        }\n        for (i <- n - 1 to 0 by -1) {\n   \
    \         var j = prefix(i + 1)\n            while (j > 0 && string(i) != string(n\
    \ - j)) j = prefix(j)\n            if (string(i) == string(n - j)) prefix(i) =\
    \ j + 1\n            else prefix(i) = 0\n        }\n        var result = string\n\
    \        for (i <- 0 to n) {\n            if (suffix(i) == i) {\n            \
    \    val prefixLength = n - i\n                result = string.substring(0, prefixLength)\
    \ + result\n            }\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: String index out of range: -1\n\
    \tat java.base/java.lang.StringLatin1.charAt(StringLatin1.java:48)\n\tat java.base/java.lang.String.charAt(String.java:1515)\n\
    \tat scala.collection.StringOps$.apply$extension(StringOps.scala:185)\n\tat Problem$.makePalindrome$$anonfun$2(tmp3iexb353.scala:19)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.makePalindrome(tmp3iexb353.scala:21)\n\
    \tat Problem$.main(tmp3iexb353.scala:39)\n\tat Problem.main(tmp3iexb353.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        val reverse = string.reverse\n        for (i <-\
    \ 0 until n) {\n            var j = 0\n            while (i + j < n && j < n &&\
    \ string(i + j) == reverse(j)) j += 1\n            suffix(i) = j\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        prefix +\
    \ reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpn7kug0mx.scala:17)\n\tat Problem$.main(tmpn7kug0mx.scala:21)\n\
    \tat Problem.main(tmpn7kug0mx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n        while (j\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(j)\
    \ = i + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (i == 0) {\n                    suffix(j) = 0\n      \
    \              j += 1\n                } else {\n                    i = suffix(i\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        prefix.reverse + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpo7athp04.scala:27)\n\tat Problem$.main(tmpo7athp04.scala:31)\n\
    \tat Problem.main(tmpo7athp04.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val dp = Array.ofDim[Int](n,\
    \ n)\n        for (i <- 0 until n) dp(i)(i) = 1\n        for (i <- 0 until n -\
    \ 1) dp(i)(i + 1) = if (string(i) == string(i + 1)) 2 else 1\n        for (k <-\
    \ 3 to n) {\n            for (i <- 0 to n - k) {\n                val j = i +\
    \ k - 1\n                dp(i)(j) = if (string(i) == string(j)) dp(i + 1)(j -\
    \ 1) + 2 else max(dp(i + 1)(j), dp(i)(j - 1))\n            }\n        }\n    \
    \    val prefix = string.substring(0, n - dp(0)(n - 1))\n        prefix.reverse\
    \ + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpsyk79gjx.scala:19)\n\tat Problem$.main(tmpsyk79gjx.scala:23)\n\
    \tat Problem.main(tmpsyk79gjx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2gll3o0.scala:21)\n\tat Problem.main(tmpl2gll3o0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val reversed = string.reverse\n        val suffix\
    \ = string.zip(reversed).takeWhile(x => x._1 == x._2).map(_._1).mkString\n   \
    \     val prefix = string.substring(0, string.length - suffix.length)\n      \
    \  val result = prefix.reverse + string\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn2v019wh.scala:18)\n\tat Problem.main(tmpn2v019wh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val z = Array.fill(s.length)(0)\n        var\
    \ l = 0; var r = 0\n        for (i <- 1 until s.length) {\n            if (i <=\
    \ r) z(i) = min(z(i - l), r - i + 1)\n            while (i + z(i) < s.length &&\
    \ s(z(i)) == s(i + z(i))) z(i) += 1\n            if (i + z(i) - 1 > r) {\n   \
    \             l = i; r = i + z(i) - 1\n            }\n        }\n        val prefix\
    \ = string.substring(0, n - z(s.length - 1))\n        string + prefix.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfdp9lnjk.scala:27)\n\tat Problem.main(tmpfdp9lnjk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        var s = string\n        var l = s.length\n \
    \       var i = 0\n        var j = l - 1\n        while (i < j) {\n          \
    \  if (s(i) != s(j)) {\n                s = s.substring(0, j) + s.substring(i)\n\
    \                l = s.length\n                i = 0\n                j = l -\
    \ 1\n            } else {\n                i += 1\n                j -= 1\n  \
    \          }\n        }\n        s + s.reverse.substring(l - i)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\"\
    )));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010184
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val reversed = string.reverse\n        val s\
    \ = string + \"#\" + reversed\n        val lps = Array.fill(s.length)(0)\n   \
    \     for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n        \
    \    while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        val prefix = string.substring(0, string.length\
    \ - lps.last)\n        prefix.reverse + string\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps_b4eucy.scala:23)\n\tat Problem.main(tmps_b4eucy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2gll3o0.scala:21)\n\tat Problem.main(tmpl2gll3o0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j\
    \ = 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n  \
    \              suffix(i) = j + 1\n                i += 1\n                j +=\
    \ 1\n            } else {\n                if (j == 0) {\n                   \
    \ suffix(i) = 0\n                    i += 1\n                } else {\n      \
    \              j = suffix(j - 1)\n                }\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        prefix.reverse\
    \ + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp4vsaxt7t.scala:11)\n\tat Problem$.main(tmp4vsaxt7t.scala:32)\n\
    \tat Problem.main(tmp4vsaxt7t.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      val prefix = string.substring(0, string.length - lps.last)\n        prefix.reverse\
    \ + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmldlqcrq.scala:22)\n\tat Problem.main(tmpmldlqcrq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val prefix =\
    \ string.substring(0, n - 1)\n        val suffix = string.substring(n - 1, n)\n\
    \        val reversedPrefix = prefix.reverse\n        suffix + reversedPrefix\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 0, end -1, length 0\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.makePalindrome(tmpn7r662x9.scala:10)\n\tat Problem$.main(tmpn7r662x9.scala:16)\n\
    \tat Problem.main(tmpn7r662x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val z = Array.fill(s.length)(0)\n        var\
    \ l = 0; var r = 0\n        for (i <- 1 until s.length) {\n            if (i >\
    \ r) {\n                l = i; r = i\n                while (r < s.length && s(r\
    \ - l) == s(r)) r += 1\n                z(i) = r - l; r -= 1\n            } else\
    \ {\n                val k = i - l\n                if (z(k) < r - i + 1) z(i)\
    \ = z(k)\n                else {\n                    l = i\n                \
    \    while (r < s.length && s(r - l) == s(r)) r += 1\n                    z(i)\
    \ = r - l; r -= 1\n                }\n            }\n        }\n        val longestPalindrome\
    \ = z(n + 1)\n        string.substring(longestPalindrome) + string\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\
    \")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.makePalindrome(tmpfn__e99g.scala:28)\n\tat Problem$.main(tmpfn__e99g.scala:32)\n\
    \tat Problem.main(tmpfn__e99g.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n        while (j\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(j)\
    \ = i + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (i == 0) {\n                    suffix(j) = 0\n      \
    \              j += 1\n                } else {\n                    i = suffix(i\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpp4jnnznv.scala:27)\n\tat Problem$.main(tmpp4jnnznv.scala:31)\n\
    \tat Problem.main(tmpp4jnnznv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string + string.substring(n - lps(s.length\
    \ - 1)).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptz3f6pmm.scala:21)\n\tat Problem.main(tmptz3f6pmm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j\
    \ = 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n  \
    \              suffix(i) = j + 1\n                i += 1\n                j +=\
    \ 1\n            } else {\n                if (j == 0) {\n                   \
    \ suffix(i) = 0\n                    i += 1\n                } else {\n      \
    \              j = suffix(j - 1)\n                }\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        string +\
    \ prefix.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp80qi8hfo.scala:11)\n\tat Problem$.main(tmp80qi8hfo.scala:32)\n\
    \tat Problem.main(tmp80qi8hfo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val reverse =\
    \ string.reverse\n        val lps = Array.ofDim[Int](n)\n        var len = 0\n\
    \        for (i <- 1 until n) {\n            if (string(i) == string(len)) {\n\
    \                len += 1\n                lps(i) = len\n            } else {\n\
    \                if (len != 0) {\n                    len = lps(len - 1)\n   \
    \                 i -= 1\n                }\n            }\n        }\n      \
    \  string + reverse.substring(n - lps(n - 1))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb2b40_k6.scala:20:22 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                    i -= \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                    ^^^^\e[0m\n\e[31m   |\e[0m                    value\
    \ -= is not a member of Int - did you mean i.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n            var j = 0\n\
    \            while (i - j >= 0 && i + j < n && string(i - j) == string(i + j))\
    \ j += 1\n            suffix(i) = j\n        }\n        var max = 0\n        var\
    \ maxIndex = 0\n        for (i <- 0 until n) {\n            if (suffix(i) > max)\
    \ {\n                max = suffix(i)\n                maxIndex = i\n         \
    \   }\n        }\n        val prefix = string.substring(0, maxIndex - max + 1)\n\
    \        string + prefix.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 0, end 1, length 0\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.makePalindrome(tmphjv6atl3.scala:24)\n\tat Problem$.main(tmphjv6atl3.scala:28)\n\
    \tat Problem.main(tmphjv6atl3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val dp = Array.ofDim[Int](n\
    \ + 1, n + 1)\n        for (i <- 0 to n) dp(i)(0) = 0\n        for (j <- 0 to\
    \ n) dp(0)(j) = 0\n        for (i <- 1 to n; j <- 1 to n) {\n            if (string(i\
    \ - 1) == string(n - j)) dp(i)(j) = dp(i - 1)(j - 1) + 1\n            else dp(i)(j)\
    \ = max(dp(i - 1)(j), dp(i)(j - 1))\n        }\n        val prefix = string.substring(0,\
    \ n - dp(n)(n))\n        prefix.reverse + string\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzmoici5s.scala:23)\n\tat Problem.main(tmpzmoici5s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        for (i <- 1 until n) {\n\
    \            var j = suffix(i - 1)\n            while (j > 0 && string(i) != string(j))\
    \ j = suffix(j - 1)\n            if (string(i) == string(j)) j += 1\n        \
    \    suffix(i) = j\n        }\n        val prefix = string.substring(0, n - suffix(n\
    \ - 1))\n        string + prefix.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpurpzof4d.scala:11)\n\tat Problem$.main(tmpurpzof4d.scala:22)\n\
    \tat Problem.main(tmpurpzof4d.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010189
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n        while (j\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(j)\
    \ = i + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (i == 0) {\n                    suffix(j) = 0\n      \
    \              j += 1\n                } else {\n                    i = suffix(i\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpp4jnnznv.scala:27)\n\tat Problem$.main(tmpp4jnnznv.scala:31)\n\
    \tat Problem.main(tmpp4jnnznv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j\
    \ = 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n  \
    \              suffix(i) = j + 1\n                i += 1\n                j +=\
    \ 1\n            } else {\n                if (j == 0) {\n                   \
    \ suffix(i) = 0\n                    i += 1\n                } else {\n      \
    \              j = suffix(j - 1)\n                }\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        string +\
    \ prefix.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp80qi8hfo.scala:11)\n\tat Problem$.main(tmp80qi8hfo.scala:32)\n\
    \tat Problem.main(tmp80qi8hfo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        val reverse = string.reverse\n        for (i <-\
    \ 0 until n) {\n            var j = 0\n            while (i + j < n && string(j)\
    \ == reverse(i + j)) j += 1\n            suffix(i) = j\n        }\n        var\
    \ prefix = n - suffix(n - 1)\n        if (prefix == n) prefix = 0\n        string.substring(prefix)\
    \ + reverse.substring(0, n - prefix)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpzk0d59sn.scala:17)\n\tat Problem$.main(tmpzk0d59sn.scala:22)\n\
    \tat Problem.main(tmpzk0d59sn.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010191
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n        while (j\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(j)\
    \ = i + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (i == 0) {\n                    suffix(j) = 0\n      \
    \              j += 1\n                } else {\n                    i = suffix(i\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpp4jnnznv.scala:27)\n\tat Problem$.main(tmpp4jnnznv.scala:31)\n\
    \tat Problem.main(tmpp4jnnznv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2gll3o0.scala:21)\n\tat Problem.main(tmpl2gll3o0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ new Array[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j =\
    \ 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n    \
    \            suffix(i) = j + 1\n                i += 1\n                j += 1\n\
    \            } else {\n                if (j == 0) {\n                    suffix(i)\
    \ = 0\n                    i += 1\n                } else {\n                \
    \    j = suffix(j - 1)\n                }\n            }\n        }\n        val\
    \ prefix = string.substring(0, n - suffix(n - 1))\n        prefix.reverse + string\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp3ttta0el.scala:11)\n\tat Problem$.main(tmp3ttta0el.scala:32)\n\
    \tat Problem.main(tmp3ttta0el.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2gll3o0.scala:21)\n\tat Problem.main(tmpl2gll3o0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = string.substring(string.length\
    \ / 2)\n        val prefix = string.substring(0, string.length / 2)\n        val\
    \ palindromeSuffix = findPalindromeSuffix(suffix)\n        val prefixToAppend\
    \ = prefix.substring(0, prefix.length - palindromeSuffix.length)\n        return\
    \ prefixToAppend + string + prefixToAppend.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpit9l5e9_.scala:11:31 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mpalindromeSuffix\e[0m =\
    \ findPalindromeSuffix(suffix)\n\e[31m\e[31m   |\e[0m                        \
    \       ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \    Not found: findPalindromeSuffix\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010185
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n        while (j\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(j)\
    \ = i + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (i == 0) {\n                    suffix(j) = 0\n      \
    \              j += 1\n                } else {\n                    i = suffix(i\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        val suffixString = string.substring(n - suffix(n\
    \ - 1))\n        val reversePrefix = prefix.reverse\n        suffixString + reversePrefix\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp5mp5_pti.scala:27)\n\tat Problem$.main(tmp5mp5_pti.scala:33)\n\
    \tat Problem.main(tmp5mp5_pti.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010191
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val reversed = string.reverse\n        val s\
    \ = string + \"#\" + reversed\n        val lps = Array.fill(s.length)(0)\n   \
    \     for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n        \
    \    while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ j += 1\n            lps(i) = j\n        }\n        val prefix = string.substring(lps.last)\n\
    \        prefix.reverse + string\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk0xir24o.scala:24)\n\tat Problem.main(tmpk0xir24o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        var suffix = string\n        var prefix = \"\
    \"\n        while (suffix.length > 0) {\n            if (suffix.isPalindrome)\
    \ {\n                return prefix + string\n            }\n            prefix\
    \ = suffix.head + prefix\n            suffix = suffix.tail\n        }\n      \
    \  return prefix + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8na1ibwp.scala:12:23 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            \e[33mif\e[0m (suffix.isPalindrome) {\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \               value isPalindrome is not a member of String\n1 error found\n"
  stdout: ''
  timestamp: 1660010190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 1\n        var j = 0\n        while (i\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(i)\
    \ = j + 1\n                i += 1\n                j += 1\n            } else\
    \ if (j > 0) {\n                j = suffix(j - 1)\n            } else {\n    \
    \            suffix(i) = 0\n                i += 1\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        prefix.reverse\
    \ + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpldwhz7v7.scala:25)\n\tat Problem$.main(tmpldwhz7v7.scala:29)\n\
    \tat Problem.main(tmpldwhz7v7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010191
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val palindromeSuffix = findPalindromeSuffix(string)\n\
    \        val prefix = string.substring(0, string.length - palindromeSuffix.length)\n\
    \        prefix.reverse + string\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnskf86h9.scala:9:31 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mpalindromeSuffix\e[0m = findPalindromeSuffix(string)\n\
    \e[31m\e[31m  |\e[0m                               ^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m  |\e[0m                               Not found: findPalindromeSuffix\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010187
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2gll3o0.scala:21)\n\tat Problem.main(tmpl2gll3o0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        for (i <- 1 until n) {\n\
    \            var j = suffix(i - 1)\n            while (j > 0 && string(i) != string(j))\
    \ j = suffix(j - 1)\n            if (string(i) == string(j)) suffix(i) = j + 1\n\
    \            else suffix(i) = 0\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpd1x3a6rt.scala:11)\n\tat Problem$.main(tmpd1x3a6rt.scala:22)\n\
    \tat Problem.main(tmpd1x3a6rt.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n        while (j\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(j)\
    \ = i + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (i == 0) {\n                    suffix(j) = 0\n      \
    \              j += 1\n                } else {\n                    i = suffix(i\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpp4jnnznv.scala:27)\n\tat Problem$.main(tmpp4jnnznv.scala:31)\n\
    \tat Problem.main(tmpp4jnnznv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        def isPalindrome(string : String) : Boolean\
    \ = {\n            val length = string.length\n            for (i <- 0 until length\
    \ / 2) {\n                if (string(i) != string(length - 1 - i)) return false\n\
    \            }\n            return true\n        }\n        val length = string.length\n\
    \        for (i <- length to 0 by -1) {\n            if (isPalindrome(string.substring(length\
    \ - i))) {\n                return string + string.substring(0, length - i).reverse\n\
    \            }\n        }\n        return string + string.reverse\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\
    \")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val m = Array.ofDim[Int](n,\
    \ n)\n        for (i <- 0 until n) {\n            m(i)(i) = 1\n            if\
    \ (i + 1 < n) {\n                m(i)(i + 1) = if (string(i) == string(i + 1))\
    \ 2 else 0\n            }\n        }\n        for (k <- 3 to n) {\n          \
    \  for (i <- 0 until n - k + 1) {\n                val j = i + k - 1\n       \
    \         m(i)(j) = if (string(i) == string(j) && m(i + 1)(j - 1) > 0) m(i + 1)(j\
    \ - 1) + 2 else 0\n            }\n        }\n        var max = 0\n        var\
    \ maxIndex = 0\n        for (i <- 0 until n) {\n            if (m(0)(i) > max)\
    \ {\n                max = m(0)(i)\n                maxIndex = i\n           \
    \ }\n        }\n        val prefix = string.substring(0, maxIndex + 1)\n     \
    \   val suffix = string.substring(maxIndex + 1)\n        prefix + suffix.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 0, end 1, length 0\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.makePalindrome(tmpp0xrjqqq.scala:31)\n\tat Problem$.main(tmpp0xrjqqq.scala:36)\n\
    \tat Problem.main(tmpp0xrjqqq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val z = Array.fill(s.length)(0)\n        var\
    \ l = 0; var r = 0\n        for (i <- 1 until s.length) {\n            if (i >\
    \ r) {\n                l = i; r = i\n                while (r < s.length && s(r\
    \ - l) == s(r)) r += 1\n                z(i) = r - l; r -= 1\n            } else\
    \ {\n                val k = i - l\n                if (z(k) < r - i + 1) z(i)\
    \ = z(k)\n                else {\n                    l = i\n                \
    \    while (r < s.length && s(r - l) == s(r)) r += 1\n                    z(i)\
    \ = r - l; r -= 1\n                }\n            }\n        }\n        val longestPalindromeSuffix\
    \ = z(s.length - 1)\n        string + string.substring(longestPalindromeSuffix,\
    \ n).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqg2p6ur7.scala:34)\n\tat Problem.main(tmpqg2p6ur7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n        while (j\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(j)\
    \ = i + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (i == 0) {\n                    suffix(j) = 0\n      \
    \              j += 1\n                } else {\n                    i = suffix(i\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        prefix.reverse + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpo7athp04.scala:27)\n\tat Problem$.main(tmpo7athp04.scala:31)\n\
    \tat Problem.main(tmpo7athp04.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val reversed = string.reverse\n        val longestPalindrome\
    \ = (0 to string.length).map(i => string.substring(i) + reversed.substring(0,\
    \ string.length - i)).maxBy(s => s.length - s.reverse.indexOf(s))\n        longestPalindrome\
    \ + reversed.substring(longestPalindrome.length)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 2, end 1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.makePalindrome(tmp6ptypru_.scala:11)\n\
    \tat Problem$.main(tmp6ptypru_.scala:15)\n\tat Problem.main(tmp6ptypru_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val z = Array.fill(s.length)(0)\n        var\
    \ l = 0; var r = 0\n        for (i <- 1 until s.length) {\n            if (i >\
    \ r) {\n                l = i; r = i\n                while (r < s.length && s(r\
    \ - l) == s(r)) r += 1\n                z(i) = r - l; r -= 1\n            } else\
    \ {\n                val k = i - l\n                if (z(k) < r - i + 1) z(i)\
    \ = z(k)\n                else {\n                    l = i\n                \
    \    while (r < s.length && s(r - l) == s(r)) r += 1\n                    z(i)\
    \ = r - l; r -= 1\n                }\n            }\n        }\n        val longestPalindrome\
    \ = z.max\n        string.substring(longestPalindrome) + string\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\"\
    )));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsxs7hs51.scala:34)\n\tat Problem.main(tmpsxs7hs51.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        var i = 1\n        while (i\
    \ < s.length) {\n            if (s(i) == s(lps(i - 1))) lps(i) = lps(i - 1) +\
    \ 1\n            else {\n                var j = lps(i - 1)\n                while\
    \ (j > 0 && s(i) != s(j)) j = lps(j - 1)\n                if (s(i) == s(j)) lps(i)\
    \ = j + 1\n            }\n            i += 1\n        }\n        string.substring(lps(s.length\
    \ - 1)) + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp952saw08.scala:26)\n\tat Problem.main(tmp952saw08.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        var i = 1\n        while (i\
    \ < s.length) {\n            if (s(i) == s(lps(i - 1))) lps(i) = lps(i - 1) +\
    \ 1\n            else {\n                var j = lps(i - 1)\n                while\
    \ (j > 0 && s(i) != s(j)) j = lps(j - 1)\n                if (s(i) == s(j)) lps(i)\
    \ = j + 1\n            }\n            i += 1\n        }\n        string.substring(lps(s.length\
    \ - 1)) + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp952saw08.scala:26)\n\tat Problem.main(tmp952saw08.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = string.substring(string.length\
    \ / 2)\n        val prefix = string.substring(0, string.length / 2)\n        val\
    \ palindromeSuffix = findPalindromeSuffix(suffix)\n        val palindromePrefix\
    \ = prefix.substring(0, prefix.length - palindromeSuffix.length)\n        palindromePrefix\
    \ + suffix + palindromePrefix.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp86yn94a0.scala:11:31 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mpalindromeSuffix\e[0m =\
    \ findPalindromeSuffix(suffix)\n\e[31m\e[31m   |\e[0m                        \
    \       ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \    Not found: findPalindromeSuffix\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010188
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val reversed = string.reverse\n        val length\
    \ = string.length\n        val palindromeSuffix = (0 until length).find(i => string.substring(i)\
    \ == reversed.substring(0, length - i)).get\n        val prefix = string.substring(0,\
    \ length - palindromeSuffix)\n        string + prefix.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\"\
    )));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: None.get\n\tat scala.None$.get(Option.scala:627)\n\
    \tat scala.None$.get(Option.scala:626)\n\tat Problem$.makePalindrome(tmpu53l3uxa.scala:11)\n\
    \tat Problem$.main(tmpu53l3uxa.scala:16)\n\tat Problem.main(tmpu53l3uxa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        def isPalindrome(string : String) : Boolean\
    \ = {\n            for (i <- 0 until string.length / 2) {\n                if\
    \ (string(i) != string(string.length - 1 - i)) return false\n            }\n \
    \           return true\n        }\n        var longestPalindrome = \"\"\n   \
    \     for (i <- 0 until string.length) {\n            val substring = string.substring(i)\n\
    \            if (isPalindrome(substring) && substring.length > longestPalindrome.length)\
    \ longestPalindrome = substring\n        }\n        return string + string.substring(0,\
    \ string.length - longestPalindrome.length).reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        for (i <- 1 until n) {\n\
    \            var j = suffix(i - 1)\n            while (j > 0 && string(i) != string(j))\
    \ j = suffix(j - 1)\n            if (string(i) == string(j)) j += 1\n        \
    \    suffix(i) = j\n        }\n        val prefix = string.substring(0, n - suffix(n\
    \ - 1))\n        prefix.reverse + string\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp0lyghy9u.scala:11)\n\tat Problem$.main(tmp0lyghy9u.scala:22)\n\
    \tat Problem.main(tmp0lyghy9u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = string.reverse.takeWhile(c => string.startsWith(c.toString))\n\
    \        string + suffix.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdkh5ku52.scala:14)\n\tat Problem.main(tmpdkh5ku52.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val dp = Array.ofDim[Int](n,\
    \ n)\n        for (i <- 0 until n) dp(i)(i) = 1\n        for (i <- 0 until n -\
    \ 1) dp(i)(i + 1) = if (string(i) == string(i + 1)) 2 else 1\n        for (k <-\
    \ 3 to n) {\n            for (i <- 0 to n - k) {\n                dp(i)(i + k\
    \ - 1) = if (string(i) == string(i + k - 1)) dp(i + 1)(i + k - 2) + 2 else max(dp(i\
    \ + 1)(i + k - 1), dp(i)(i + k - 2))\n            }\n        }\n        val palindromeLength\
    \ = dp(0)(n - 1)\n        val prefix = string.substring(0, n - palindromeLength)\n\
    \        val suffix = string.substring(n - palindromeLength, n)\n        prefix.reverse\
    \ + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpkqhlvex3.scala:18)\n\tat Problem$.main(tmpkqhlvex3.scala:24)\n\
    \tat Problem.main(tmpkqhlvex3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val dp = Array.ofDim[Int](n,\
    \ n)\n        for (i <- 0 until n) dp(i)(i) = 1\n        for (i <- 0 until n -\
    \ 1) dp(i)(i + 1) = if (string(i) == string(i + 1)) 2 else 1\n        for (k <-\
    \ 3 to n) {\n            for (i <- 0 to n - k) {\n                val j = i +\
    \ k - 1\n                dp(i)(j) = if (string(i) == string(j)) dp(i + 1)(j -\
    \ 1) + 2 else max(dp(i + 1)(j), dp(i)(j - 1))\n            }\n        }\n    \
    \    val longestPalindrome = dp(0)(n - 1)\n        val prefix = string.substring(0,\
    \ n - longestPalindrome)\n        string + prefix.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpp4wfapqr.scala:19)\n\tat Problem$.main(tmpp4wfapqr.scala:24)\n\
    \tat Problem.main(tmpp4wfapqr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010196
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = string.substring(string.length\
    \ / 2)\n        val prefix = string.substring(0, string.length / 2)\n        val\
    \ palindromeSuffix = longestPalindromeSuffix(suffix)\n        val prefixToAppend\
    \ = prefix.substring(0, prefix.length - palindromeSuffix.length)\n        prefixToAppend\
    \ + suffix + prefixToAppend.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7lgq45a2.scala:11:31 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mpalindromeSuffix\e[0m =\
    \ longestPalindromeSuffix(suffix)\n\e[31m\e[31m   |\e[0m                     \
    \          ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \          Not found: longestPalindromeSuffix\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010193
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n            var j = 0\n\
    \            while (i - j >= 0 && i + j < n && string(i - j) == string(i + j))\
    \ j += 1\n            suffix(i) = j\n        }\n        var max = 0\n        var\
    \ maxIndex = 0\n        for (i <- 0 until n) {\n            if (suffix(i) > max)\
    \ {\n                max = suffix(i)\n                maxIndex = i\n         \
    \   }\n        }\n        string.substring(maxIndex + 1, n) + string\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\
    \")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 1, end 0, length 0\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.makePalindrome(tmp08hxz2ls.scala:24)\n\tat Problem$.main(tmp08hxz2ls.scala:27)\n\
    \tat Problem.main(tmp08hxz2ls.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010199
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string + string.reverse.substring(lps(s.length\
    \ - 1))\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010199
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val dp = Array.ofDim[Int](n,\
    \ n)\n        for (i <- 0 until n) {\n            dp(i)(i) = 1\n            if\
    \ (i < n - 1) {\n                if (string(i) == string(i + 1)) dp(i)(i + 1)\
    \ = 2\n                else dp(i)(i + 1) = 1\n            }\n        }\n     \
    \   for (k <- 3 to n) {\n            for (i <- 0 to n - k) {\n               \
    \ val j = i + k - 1\n                if (string(i) == string(j)) dp(i)(j) = dp(i\
    \ + 1)(j - 1) + 2\n                else dp(i)(j) = max(dp(i + 1)(j), dp(i)(j -\
    \ 1))\n            }\n        }\n        val longestPalindrome = dp(0)(n - 1)\n\
    \        val prefix = string.substring(0, n - longestPalindrome)\n        val\
    \ reversePrefix = prefix.reverse\n        string + reversePrefix\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\"\
    )));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpnyra9em5.scala:25)\n\tat Problem$.main(tmpnyra9em5.scala:31)\n\
    \tat Problem.main(tmpnyra9em5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n        while (j\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(j)\
    \ = i + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (i == 0) {\n                    suffix(j) = 0\n      \
    \              j += 1\n                } else {\n                    i = suffix(i\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        prefix.reverse + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpo7athp04.scala:27)\n\tat Problem$.main(tmpo7athp04.scala:31)\n\
    \tat Problem.main(tmpo7athp04.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val palindromeSuffix = string.substring(0, string.length\
    \ - longestPalindromeSuffix(string))\n        string + palindromeSuffix.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphem2mn0l.scala:9:67 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mpalindromeSuffix\e[0m = string.substring(\e\
    [31m0\e[0m, string.length - longestPalindromeSuffix(string))\n\e[31m\e[31m  |\e\
    [0m                                                                   ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                                        Not found: longestPalindromeSuffix\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010196
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val dp = Array.ofDim[Int](n,\
    \ n)\n        for (i <- 0 until n) {\n            dp(i)(i) = 1\n            if\
    \ (i + 1 < n) {\n                dp(i)(i + 1) = if (string(i) == string(i + 1))\
    \ 2 else 1\n            }\n        }\n        for (k <- 3 to n) {\n          \
    \  for (i <- 0 to n - k) {\n                val j = i + k - 1\n              \
    \  dp(i)(j) = if (string(i) == string(j)) dp(i + 1)(j - 1) + 2 else max(dp(i +\
    \ 1)(j), dp(i)(j - 1))\n            }\n        }\n        val longestPalindrome\
    \ = dp(0)(n - 1)\n        val prefix = string.substring(0, n - longestPalindrome)\n\
    \        val suffix = string.substring(n - longestPalindrome)\n        prefix.reverse\
    \ + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpu10jf9jb.scala:23)\n\tat Problem$.main(tmpu10jf9jb.scala:29)\n\
    \tat Problem.main(tmpu10jf9jb.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010202
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        val reverse = string.reverse\n        for (i <-\
    \ 0 until n) {\n            suffix(i) = if (string.substring(i) == reverse.substring(0,\
    \ n - i)) n - i else 0\n        }\n        string + reverse.substring(suffix(n\
    \ - 1))\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpc_tgp4sb.scala:15)\n\tat Problem$.main(tmpc_tgp4sb.scala:18)\n\
    \tat Problem.main(tmpc_tgp4sb.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010201
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ new Array[Int](n)\n        var i = 0\n        var j = 1\n        while (j <\
    \ n) {\n            if (string(i) == string(j)) {\n                suffix(j) =\
    \ i + 1\n                i += 1\n                j += 1\n            } else {\n\
    \                if (i == 0) {\n                    suffix(j) = 0\n          \
    \          j += 1\n                } else {\n                    i = suffix(i\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        prefix.reverse + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpem7ps1w0.scala:27)\n\tat Problem$.main(tmpem7ps1w0.scala:31)\n\
    \tat Problem.main(tmpem7ps1w0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010201
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val n = s.length\n        val pi = Array.fill(n)(0)\n        for (i <-\
    \ 1 until n) {\n            var j = pi(i - 1)\n            while (j > 0 && s(i)\
    \ != s(j)) j = pi(j - 1)\n            if (s(i) == s(j)) pi(i) = j + 1\n      \
    \  }\n        string.substring(pi(n - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpon755tex.scala:22)\n\tat Problem.main(tmpon755tex.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010202
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = string.substring(string.length\
    \ / 2)\n        val prefix = string.substring(0, string.length / 2)\n        val\
    \ reversedPrefix = prefix.reverse\n        val palindromeSuffix = suffix.substring(0,\
    \ suffix.length - suffix.reverse.indexOf(suffix))\n        val palindrome = palindromeSuffix\
    \ + reversedPrefix\n        palindrome\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 0, end 3, length 2\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.makePalindrome(tmp29di__49.scala:12)\n\tat Problem$.main(tmp29di__49.scala:19)\n\
    \tat Problem.main(tmp29di__49.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010202
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val p = Array.fill(s.length)(0)\n        for\
    \ (i <- 1 until s.length) {\n            var j = p(i - 1)\n            while (j\
    \ > 0 && s(i) != s(j)) j = p(j - 1)\n            if (s(i) == s(j)) j += 1\n  \
    \          p(i) = j\n        }\n        string.substring(p(s.length - 1)) + string\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxxpmloit.scala:23)\n\tat Problem.main(tmpxxpmloit.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val reversed = string.reverse\n        val s\
    \ = string + \"#\" + reversed\n        val lps = Array.fill(s.length)(0)\n   \
    \     var i = 1\n        var len = 0\n        while (i < s.length) {\n       \
    \     if (s(i) == s(len)) {\n                len += 1\n                lps(i)\
    \ = len\n                i += 1\n            } else {\n                if (len\
    \ != 0) {\n                    len = lps(len - 1)\n                } else {\n\
    \                    lps(i) = 0\n                    i += 1\n                }\n\
    \            }\n        }\n        string + reversed.substring(lps(s.length -\
    \ 1))\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010202
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string + string.substring(lps(s.length -\
    \ 1)).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjtgoryla.scala:22)\n\tat Problem.main(tmpjtgoryla.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010202
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = longestPalindromicSuffix(string)\n\
    \        val prefix = string.substring(0, string.length - suffix.length)\n   \
    \     val reversePrefix = prefix.reverse\n        reversePrefix + string\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\
    \")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0chyohgd.scala:9:21 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36msuffix\e[0m = longestPalindromicSuffix(string)\n\
    \e[31m\e[31m  |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                     Not found: longestPalindromicSuffix\n\e[31m  |\e\
    [0m\n\e[31m  |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010199
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string + string.substring(lps(s.length -\
    \ 1)).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjtgoryla.scala:22)\n\tat Problem.main(tmpjtgoryla.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010202
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n        while (j\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(j)\
    \ = i + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (i == 0) {\n                    suffix(j) = 0\n      \
    \              j += 1\n                } else {\n                    i = suffix(i\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpp4jnnznv.scala:27)\n\tat Problem$.main(tmpp4jnnznv.scala:31)\n\
    \tat Problem.main(tmpp4jnnznv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n            var j = i\n\
    \            while (j >= 0 && string(j) == string(n - 1 - i + j)) j -= 1\n   \
    \         suffix(i) = i - j\n        }\n        var i = 0\n        while (i <\
    \ n && suffix(i) < i + 1) i += 1\n        val prefix = string.substring(0, i)\n\
    \        prefix + prefix.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwc3y57zd.scala:23)\n\tat Problem.main(tmpwc3y57zd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val z = Array.fill(s.length)(0)\n        var\
    \ l = 0; var r = 0\n        for (i <- 1 until s.length) {\n            if (i >\
    \ r) {\n                l = i; r = i\n                while (r < s.length && s(r\
    \ - l) == s(r)) r += 1\n                z(i) = r - l; r -= 1\n            } else\
    \ {\n                val k = i - l\n                if (z(k) < r - i + 1) z(i)\
    \ = z(k)\n                else {\n                    l = i\n                \
    \    while (r < s.length && s(r - l) == s(r)) r += 1\n                    z(i)\
    \ = r - l; r -= 1\n                }\n            }\n        }\n        val longestPalindromeSuffix\
    \ = z(s.length - 1)\n        string + string.substring(longestPalindromeSuffix,\
    \ n).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqg2p6ur7.scala:34)\n\tat Problem.main(tmpqg2p6ur7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2gll3o0.scala:21)\n\tat Problem.main(tmpl2gll3o0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = string.substring(string.length\
    \ / 2)\n        val prefix = string.substring(0, string.length / 2)\n        val\
    \ reversedPrefix = prefix.reverse\n        val palindromeSuffix = longestPalindromeSuffix(suffix)\n\
    \        suffix + reversedPrefix + palindromeSuffix\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9qh4r4qg.scala:12:31 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mpalindromeSuffix\e[0m =\
    \ longestPalindromeSuffix(suffix)\n\e[31m\e[31m   |\e[0m                     \
    \          ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \          Not found: longestPalindromeSuffix\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010199
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string + string.substring(lps(s.length -\
    \ 1)).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjtgoryla.scala:22)\n\tat Problem.main(tmpjtgoryla.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010202
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2gll3o0.scala:21)\n\tat Problem.main(tmpl2gll3o0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        def isPalindrome(string : String) : Boolean\
    \ = {\n            for (i <- 0 until string.length / 2) {\n                if\
    \ (string(i) != string(string.length - 1 - i)) return false\n            }\n \
    \           return true\n        }\n        var longestPalindrome = \"\"\n   \
    \     for (i <- 0 until string.length) {\n            if (isPalindrome(string.substring(i)))\
    \ {\n                longestPalindrome = string.substring(i)\n            }\n\
    \        }\n        return string + string.substring(0, string.length - longestPalindrome.length).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvq8moh1p.scala:27)\n\tat Problem.main(tmpvq8moh1p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val n = s.length\n        val p = Array.fill(n)(0)\n        for (i <- 1\
    \ until n) {\n            var j = p(i - 1)\n            while (j > 0 && s(i) !=\
    \ s(j)) j = p(j - 1)\n            if (s(i) == s(j)) j += 1\n            p(i) =\
    \ j\n        }\n        string.substring(p(n - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdjk31637.scala:23)\n\tat Problem.main(tmpdjk31637.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        def isPalindrome(string : String) : Boolean\
    \ = {\n            for (i <- 0 until string.length / 2) {\n                if\
    \ (string(i) != string(string.length - 1 - i)) return false\n            }\n \
    \           return true\n        }\n        for (i <- string.length to 0 by -1)\
    \ {\n            if (isPalindrome(string.substring(i))) {\n                return\
    \ string + string.substring(0, i).reverse\n            }\n        }\n        return\
    \ string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp12dvdx67.scala:24)\n\tat Problem.main(tmp12dvdx67.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val stringLength = string.length\n        val\
    \ longestPalindrome = Array.fill(stringLength, stringLength)(0)\n        for (i\
    \ <- 0 until stringLength) longestPalindrome(i)(i) = 1\n        for (i <- 0 until\
    \ stringLength - 1) {\n            if (string(i) == string(i + 1)) longestPalindrome(i)(i\
    \ + 1) = 2\n        }\n        for (k <- 3 to stringLength) {\n            for\
    \ (i <- 0 until stringLength - k + 1) {\n                val j = i + k - 1\n \
    \               if (string(i) == string(j) && longestPalindrome(i + 1)(j - 1)\
    \ > 0) longestPalindrome(i)(j) = k\n            }\n        }\n        var maxLength\
    \ = 0\n        var maxIndex = 0\n        for (i <- 0 until stringLength) {\n \
    \           if (longestPalindrome(0)(i) > maxLength) {\n                maxLength\
    \ = longestPalindrome(0)(i)\n                maxIndex = i\n            }\n   \
    \     }\n        string.substring(maxIndex + 1) + string.substring(0, maxIndex\
    \ + 1).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 1, end 0, length 0\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat java.base/java.lang.String.substring(String.java:2680)\n\tat Problem$.makePalindrome(tmpk3diusq9.scala:29)\n\
    \tat Problem$.main(tmpk3diusq9.scala:32)\n\tat Problem.main(tmpk3diusq9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j\
    \ = 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n  \
    \              suffix(i) = j + 1\n                i += 1\n                j +=\
    \ 1\n            } else {\n                if (j == 0) {\n                   \
    \ suffix(i) = 0\n                    i += 1\n                } else {\n      \
    \              j = suffix(j - 1)\n                }\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        string +\
    \ prefix.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp80qi8hfo.scala:11)\n\tat Problem$.main(tmp80qi8hfo.scala:32)\n\
    \tat Problem.main(tmp80qi8hfo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string + string.substring(lps(s.length -\
    \ 1)).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjtgoryla.scala:22)\n\tat Problem.main(tmpjtgoryla.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010202
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = string.substring(string.length\
    \ / 2)\n        val prefix = string.substring(0, string.length / 2)\n        val\
    \ palindrome = prefix + suffix\n        val reverse = prefix.reverse\n       \
    \ palindrome + reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdcqbt02w.scala:18)\n\tat Problem.main(tmpdcqbt02w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010202
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ new Array[Int](n)\n        suffix(0) = 0\n        for (i <- 1 until n) {\n \
    \           var j = suffix(i - 1)\n            while (j > 0 && string(i) != string(j))\
    \ {\n                j = suffix(j - 1)\n            }\n            if (string(i)\
    \ == string(j)) {\n                suffix(i) = j + 1\n            } else {\n \
    \               suffix(i) = 0\n            }\n        }\n        val prefix =\
    \ string.substring(0, n - suffix(n - 1))\n        prefix.reverse + string\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\
    \")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp1r4s527i.scala:11)\n\tat Problem$.main(tmp1r4s527i.scala:27)\n\
    \tat Problem.main(tmp1r4s527i.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = string.substring(0, string.length\
    \ - 1)\n        val prefix = string.substring(string.length - 1, string.length)\n\
    \        val longestPalindrome = suffix.reverse.zip(suffix).takeWhile(p => p._1\
    \ == p._2).map(_._1).mkString\n        prefix + longestPalindrome + suffix\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 0, end -1, length 0\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.makePalindrome(tmp9ua916ek.scala:9)\n\tat Problem$.main(tmp9ua916ek.scala:15)\n\
    \tat Problem.main(tmp9ua916ek.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n        while (j\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(j)\
    \ = i + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (i == 0) {\n                    suffix(j) = 0\n      \
    \              j += 1\n                } else {\n                    i = suffix(i\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        prefix.reverse + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpo7athp04.scala:27)\n\tat Problem$.main(tmpo7athp04.scala:31)\n\
    \tat Problem.main(tmpo7athp04.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 1\n        var j = 0\n        while (i\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(i)\
    \ = j + 1\n                i += 1\n                j += 1\n            } else\
    \ if (j > 0) {\n                j = suffix(j - 1)\n            } else {\n    \
    \            suffix(i) = 0\n                i += 1\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        prefix.reverse\
    \ + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpldwhz7v7.scala:25)\n\tat Problem$.main(tmpldwhz7v7.scala:29)\n\
    \tat Problem.main(tmpldwhz7v7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010191
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        def isPalindrome(string : String) : Boolean\
    \ = {\n            val n = string.length\n            for (i <- 0 until n / 2)\
    \ if (string(i) != string(n - 1 - i)) return false\n            return true\n\
    \        }\n        val n = string.length\n        for (i <- n to 0 by -1) {\n\
    \            val suffix = string.substring(n - i, n)\n            if (isPalindrome(suffix))\
    \ {\n                val prefix = string.substring(0, n - i)\n               \
    \ return string + prefix.reverse\n            }\n        }\n        return string\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010207
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val palindrome\
    \ = Array.ofDim[Int](n)\n        var center = 0\n        var right = 0\n     \
    \   for (i <- 0 until n) {\n            val mirror = 2 * center - i\n        \
    \    if (i < right) palindrome(i) = min(right - i, palindrome(mirror))\n     \
    \       var a = i - (1 + palindrome(i))\n            var b = i + (1 + palindrome(i))\n\
    \            while (a >= 0 && b < n && string(a) == string(b)) {\n           \
    \     palindrome(i) += 1\n                a -= 1\n                b += 1\n   \
    \         }\n            if (i + palindrome(i) > right) {\n                center\
    \ = i\n                right = i + palindrome(i)\n            }\n        }\n \
    \       val maxPalindrome = palindrome.max\n        val prefix = string.substring(0,\
    \ n - maxPalindrome)\n        val suffix = string.substring(n - maxPalindrome)\n\
    \        prefix.reverse + string\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.makePalindrome(tmpm34muddh.scala:28)\n\tat Problem$.main(tmpm34muddh.scala:34)\n\
    \tat Problem.main(tmpm34muddh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010208
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2gll3o0.scala:21)\n\tat Problem.main(tmpl2gll3o0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j\
    \ = 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n  \
    \              suffix(i) = j + 1\n                i += 1\n                j +=\
    \ 1\n            } else {\n                if (j == 0) {\n                   \
    \ suffix(i) = 0\n                    i += 1\n                } else {\n      \
    \              j = suffix(j - 1)\n                }\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        string +\
    \ prefix.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp80qi8hfo.scala:11)\n\tat Problem$.main(tmp80qi8hfo.scala:32)\n\
    \tat Problem.main(tmp80qi8hfo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val dp = Array.ofDim[Int](n,\
    \ n)\n        for (i <- 0 until n) dp(i)(i) = 1\n        for (i <- 0 until n -\
    \ 1) dp(i)(i + 1) = if (string(i) == string(i + 1)) 2 else 1\n        for (k <-\
    \ 3 to n) {\n            for (i <- 0 to n - k) {\n                val j = i +\
    \ k - 1\n                dp(i)(j) = if (string(i) == string(j)) dp(i + 1)(j -\
    \ 1) + 2 else max(dp(i + 1)(j), dp(i)(j - 1))\n            }\n        }\n    \
    \    val i = 0\n        val j = n - 1\n        val k = dp(i)(j)\n        val sb\
    \ = new StringBuilder\n        if (k == n) return string\n        else {\n   \
    \         var l = i\n            var r = j\n            while (l < r) {\n    \
    \            if (string(l) == string(r)) {\n                    l += 1\n     \
    \               r -= 1\n                }\n                else if (dp(l + 1)(r)\
    \ > dp(l)(r - 1)) l += 1\n                else r -= 1\n            }\n       \
    \     sb.append(string.substring(0, l))\n            sb.append(string.substring(l,\
    \ n).reverse)\n        }\n        sb.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpxbbamhd6.scala:21)\n\tat Problem$.main(tmpxbbamhd6.scala:41)\n\
    \tat Problem.main(tmpxbbamhd6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j\
    \ = 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n  \
    \              suffix(i) = j + 1\n                i += 1\n                j +=\
    \ 1\n            } else {\n                if (j == 0) {\n                   \
    \ suffix(i) = 0\n                    i += 1\n                } else {\n      \
    \              j = suffix(j - 1)\n                }\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        prefix.reverse\
    \ + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp4vsaxt7t.scala:11)\n\tat Problem$.main(tmp4vsaxt7t.scala:32)\n\
    \tat Problem.main(tmp4vsaxt7t.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val reversed = string.reverse\n        val s\
    \ = string + \"#\" + reversed\n        val lps = Array.fill(s.length)(0)\n   \
    \     for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n        \
    \    while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ j += 1\n            lps(i) = j\n        }\n        reversed.substring(0, string.length\
    \ - lps.last) + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo5z4f8z2.scala:23)\n\tat Problem.main(tmpo5z4f8z2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2gll3o0.scala:21)\n\tat Problem.main(tmpl2gll3o0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      val prefix = string.substring(0, string.length - lps.last)\n        prefix.reverse\
    \ + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmldlqcrq.scala:22)\n\tat Problem.main(tmpmldlqcrq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n + 1)\n        suffix(n) = n\n        var i = n - 1\n    \
    \    while (i >= 0) {\n            var j = i\n            while (j >= 0 && string(j)\
    \ == string(n - 1 - i + j)) j -= 1\n            suffix(i) = i - j\n          \
    \  i -= 1\n        }\n        val prefix = Array.ofDim[Int](n + 1)\n        prefix(0)\
    \ = 0\n        i = 1\n        while (i <= n) {\n            var j = i\n      \
    \      while (j <= n && string(j - 1) == string(n - i)) j += 1\n            prefix(i)\
    \ = j - i\n            i += 1\n        }\n        var min = n\n        var minIndex\
    \ = 0\n        i = 0\n        while (i <= n) {\n            if (suffix(i) + prefix(n\
    \ - i) < min) {\n                min = suffix(i) + prefix(n - i)\n           \
    \     minIndex = i\n            }\n            i += 1\n        }\n        val\
    \ prefixString = string.substring(0, minIndex)\n        val suffixString = string.substring(minIndex,\
    \ minIndex + suffix(minIndex))\n        val reversePrefixString = prefixString.reverse\n\
    \        suffixString + reversePrefixString + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpglwp85o3.scala:45)\n\tat Problem.main(tmpglwp85o3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      val prefix = string.substring(0, string.length - lps.last)\n        prefix.reverse\
    \ + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmldlqcrq.scala:22)\n\tat Problem.main(tmpmldlqcrq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2gll3o0.scala:21)\n\tat Problem.main(tmpl2gll3o0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string + string.reverse.substring(lps(s.length\
    \ - 1))\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010199
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j\
    \ = 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n  \
    \              suffix(i) = j + 1\n                i += 1\n                j +=\
    \ 1\n            } else {\n                if (j == 0) {\n                   \
    \ suffix(i) = 0\n                    i += 1\n                } else {\n      \
    \              j = suffix(j - 1)\n                }\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        prefix.reverse\
    \ + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp4vsaxt7t.scala:11)\n\tat Problem$.main(tmp4vsaxt7t.scala:32)\n\
    \tat Problem.main(tmp4vsaxt7t.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        def isPalindrome(string : String) : Boolean\
    \ = {\n            for (i <- 0 until string.length / 2) {\n                if\
    \ (string(i) != string(string.length - 1 - i)) return false\n            }\n \
    \           return true\n        }\n        var longestPalindrome = \"\"\n   \
    \     for (i <- 0 until string.length) {\n            val candidate = string.substring(i)\n\
    \            if (isPalindrome(candidate) && candidate.length > longestPalindrome.length)\
    \ longestPalindrome = candidate\n        }\n        if (longestPalindrome.length\
    \ == string.length) return string\n        else return string + string.substring(0,\
    \ string.length - longestPalindrome.length).reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010211
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val dp = Array.ofDim[Int](n,\
    \ n)\n        for (i <- 0 until n) dp(i)(i) = 1\n        for (i <- 0 until n -\
    \ 1) dp(i)(i + 1) = if (string(i) == string(i + 1)) 2 else 1\n        for (k <-\
    \ 3 to n) {\n            for (i <- 0 to n - k) {\n                val j = i +\
    \ k - 1\n                dp(i)(j) = if (string(i) == string(j)) dp(i + 1)(j -\
    \ 1) + 2 else max(dp(i + 1)(j), dp(i)(j - 1))\n            }\n        }\n    \
    \    val palindromeSuffix = string.substring(n - dp(0)(n - 1), n)\n        val\
    \ palindromePrefix = string.substring(0, n - dp(0)(n - 1)).reverse\n        palindromeSuffix\
    \ + palindromePrefix\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp0a9gnjkt.scala:19)\n\tat Problem$.main(tmp0a9gnjkt.scala:24)\n\
    \tat Problem.main(tmp0a9gnjkt.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010211
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ new Array[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j =\
    \ 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n    \
    \            suffix(i) = j + 1\n                i += 1\n                j += 1\n\
    \            } else {\n                if (j == 0) {\n                    suffix(i)\
    \ = 0\n                    i += 1\n                } else {\n                \
    \    j = suffix(j - 1)\n                }\n            }\n        }\n        val\
    \ prefix = string.substring(0, n - suffix(n - 1))\n        prefix.reverse + string\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp3ttta0el.scala:11)\n\tat Problem$.main(tmp3ttta0el.scala:32)\n\
    \tat Problem.main(tmp3ttta0el.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val z = Array.fill(s.length)(0)\n        var\
    \ l = 0; var r = 0\n        for (i <- 1 until s.length) {\n            if (i <=\
    \ r) z(i) = min(z(i - l), r - i + 1)\n            while (i + z(i) < s.length &&\
    \ s(z(i)) == s(i + z(i))) z(i) += 1\n            if (i + z(i) - 1 > r) {\n   \
    \             l = i; r = i + z(i) - 1\n            }\n        }\n        string\
    \ + string.reverse.substring(0, n - z(s.length - 1))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7gh0vphm.scala:25)\n\tat Problem.main(tmp7gh0vphm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val longestPalindrome = longestPalindromeSuffix(string)\n\
    \        val prefix = string.substring(0, string.length - longestPalindrome.length)\n\
    \        prefix + longestPalindrome + prefix.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4kx1oiu2.scala:9:32 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mlongestPalindrome\e[0m =\
    \ longestPalindromeSuffix(string)\n\e[31m\e[31m  |\e[0m                      \
    \          ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m                      \
    \          Not found: longestPalindromeSuffix\n\e[31m  |\e[0m\n\e[31m  |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010208
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2gll3o0.scala:21)\n\tat Problem.main(tmpl2gll3o0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string + string.substring(lps(s.length -\
    \ 1)).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjtgoryla.scala:22)\n\tat Problem.main(tmpjtgoryla.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010202
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ new Array[Int](n)\n        // suffix[i] is the length of the longest palindromic\
    \ suffix of string[0..i]\n        // suffix[i] = 0 if string[0..i] is not a palindrome\n\
    \        // suffix[i] = 1 if string[0..i] is a palindrome\n        suffix(0) =\
    \ 1\n        for (i <- 1 until n) {\n            var j = i\n            while\
    \ (j > 0 && string(j) != string(n - i + j - 1)) j -= 1\n            suffix(i)\
    \ = i - j + 1\n        }\n        // Find the longest palindromic suffix\n   \
    \     var i = n - 1\n        while (i > 0 && suffix(i) != i + 1) i -= 1\n    \
    \    // Append reverse of string[0..i] to the end of string\n        val prefix\
    \ = string.substring(0, i).reverse\n        string + prefix\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpfal2izun.scala:14)\n\tat Problem$.main(tmpfal2izun.scala:28)\n\
    \tat Problem.main(tmpfal2izun.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val n = s.length\n        val z = new Array[Int](n)\n        var l = 0;\
    \ var r = 0\n        for (i <- 1 until n) {\n            if (i > r) {\n      \
    \          l = r = i\n                while (r < n && s(r - l) == s(r)) r += 1\n\
    \                z(i) = r - l; r -= 1\n            } else {\n                val\
    \ k = i - l\n                if (z(k) < r - i + 1) z(i) = z(k)\n             \
    \   else {\n                    l = i\n                    while (r < n && s(r\
    \ - l) == s(r)) r += 1\n                    z(i) = r - l; r -= 1\n           \
    \     }\n            }\n        }\n        string.substring(z(n - 1)) + string\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5jhib33p.scala:15:22\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m                l = r = i\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m           \
    \         Found:    Unit\n\e[31m   |\e[0m                    Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n            var j = 0\n\
    \            while (i - j >= 0 && i + j < n && string(i - j) == string(i + j))\
    \ j += 1\n            suffix(i) = j\n        }\n        var max = 0\n        var\
    \ maxIndex = 0\n        for (i <- 0 until n) {\n            if (suffix(i) > max)\
    \ {\n                max = suffix(i)\n                maxIndex = i\n         \
    \   }\n        }\n        val prefix = string.substring(0, maxIndex - max + 1)\n\
    \        string + prefix.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 0, end 1, length 0\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.makePalindrome(tmphjv6atl3.scala:24)\n\tat Problem$.main(tmphjv6atl3.scala:28)\n\
    \tat Problem.main(tmphjv6atl3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n            var j = 0\n\
    \            while (i - j >= 0 && i + j < n && string(i - j) == string(i + j))\
    \ j += 1\n            suffix(i) = j\n        }\n        var max = 0\n        var\
    \ maxIndex = 0\n        for (i <- 0 until n) {\n            if (suffix(i) > max)\
    \ {\n                max = suffix(i)\n                maxIndex = i\n         \
    \   }\n        }\n        val prefix = string.substring(0, maxIndex - max + 1)\n\
    \        val palindrome = string + prefix.reverse\n        palindrome\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\
    \")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 0, end 1, length 0\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.makePalindrome(tmpbe9lt65c.scala:24)\n\tat Problem$.main(tmpbe9lt65c.scala:29)\n\
    \tat Problem.main(tmpbe9lt65c.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ new Array[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j =\
    \ 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n    \
    \            suffix(i) = j + 1\n                i += 1\n                j += 1\n\
    \            } else {\n                if (j == 0) {\n                    suffix(i)\
    \ = 0\n                    i += 1\n                } else {\n                \
    \    j = suffix(j - 1)\n                }\n            }\n        }\n        val\
    \ prefix = string.substring(0, n - suffix(n - 1))\n        string + prefix.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpsnx7wz5c.scala:11)\n\tat Problem$.main(tmpsnx7wz5c.scala:32)\n\
    \tat Problem.main(tmpsnx7wz5c.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n            var j = 0\n\
    \            while (i - j >= 0 && i + j < n && string(i - j) == string(i + j))\
    \ j += 1\n            suffix(i) = j\n        }\n        var max = 0\n        var\
    \ maxIndex = 0\n        for (i <- 0 until n) {\n            if (suffix(i) > max)\
    \ {\n                max = suffix(i)\n                maxIndex = i\n         \
    \   }\n        }\n        val prefix = string.substring(0, maxIndex - max + 1)\n\
    \        prefix + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 0, end 1, length 0\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.makePalindrome(tmpq48ilux9.scala:24)\n\tat Problem$.main(tmpq48ilux9.scala:28)\n\
    \tat Problem.main(tmpq48ilux9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = string.substring(string.length\
    \ / 2)\n        val prefix = string.substring(0, string.length / 2)\n        val\
    \ reversedPrefix = prefix.reverse\n        val palindromeSuffix = findPalindromeSuffix(suffix)\n\
    \        val palindromePrefix = reversedPrefix.substring(reversedPrefix.length\
    \ - (suffix.length - palindromeSuffix.length))\n        palindromePrefix + suffix\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4c_onpqp.scala:12:31 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mpalindromeSuffix\e[0m =\
    \ findPalindromeSuffix(suffix)\n\e[31m\e[31m   |\e[0m                        \
    \       ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \    Not found: findPalindromeSuffix\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n        while (j\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(j)\
    \ = i + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (i == 0) {\n                    suffix(j) = 0\n      \
    \              j += 1\n                } else {\n                    i = suffix(i\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        prefix.reverse + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpo7athp04.scala:27)\n\tat Problem$.main(tmpo7athp04.scala:31)\n\
    \tat Problem.main(tmpo7athp04.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val reversed = string.reverse\n        val s\
    \ = string + \"#\" + reversed\n        val lps = Array.fill(s.length)(0)\n   \
    \     for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n        \
    \    while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        val prefix = string.substring(0, string.length\
    \ - lps.last)\n        prefix.reverse + string\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps_b4eucy.scala:23)\n\tat Problem.main(tmps_b4eucy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j\
    \ = 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n  \
    \              suffix(i) = j + 1\n                i += 1\n                j +=\
    \ 1\n            } else {\n                if (j == 0) {\n                   \
    \ suffix(i) = 0\n                    i += 1\n                } else {\n      \
    \              j = suffix(j - 1)\n                }\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        string +\
    \ prefix.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp80qi8hfo.scala:11)\n\tat Problem$.main(tmp80qi8hfo.scala:32)\n\
    \tat Problem.main(tmp80qi8hfo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val reversed = string.reverse\n        val suffix\
    \ = string.substring(0, string.length - reversed.indexOf(string))\n        val\
    \ prefix = string.substring(suffix.length)\n        prefix + suffix + reversed.substring(prefix.length)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuo96upl6.scala:16)\n\tat Problem.main(tmpuo96upl6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j\
    \ = 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n  \
    \              suffix(i) = j + 1\n                i += 1\n                j +=\
    \ 1\n            } else {\n                if (j == 0) {\n                   \
    \ suffix(i) = 0\n                    i += 1\n                } else {\n      \
    \              j = suffix(j - 1)\n                }\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        string +\
    \ prefix.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp80qi8hfo.scala:11)\n\tat Problem$.main(tmp80qi8hfo.scala:32)\n\
    \tat Problem.main(tmp80qi8hfo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"*\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        var i = 1\n        while (i\
    \ < s.length) {\n            if (s(i) == s(lps(i - 1))) {\n                lps(i)\
    \ = lps(i - 1) + 1\n            } else {\n                var j = lps(i - 1)\n\
    \                while (j > 0 && s(i) != s(j)) {\n                    j = lps(j\
    \ - 1)\n                }\n                if (s(i) == s(j)) {\n             \
    \       lps(i) = j + 1\n                }\n            }\n            i += 1\n\
    \        }\n        string.substring(lps(s.length - 1)) + string\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\"\
    )));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqwcnz5ao.scala:31)\n\tat Problem.main(tmpqwcnz5ao.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = string.reverse\n        val prefix\
    \ = string.substring(0, string.length - suffix.length)\n        suffix + prefix\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkfe0utjt.scala:16)\n\tat Problem.main(tmpkfe0utjt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = string.substring(string.length\
    \ / 2)\n        val prefix = string.substring(0, string.length / 2)\n        val\
    \ reversedPrefix = prefix.reverse\n        val palindromeSuffix = findPalindromeSuffix(suffix)\n\
    \        val palindrome = suffix + reversedPrefix + palindromeSuffix\n       \
    \ palindrome\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnjfg7s0l.scala:12:31 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mpalindromeSuffix\e[0m =\
    \ findPalindromeSuffix(suffix)\n\e[31m\e[31m   |\e[0m                        \
    \       ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \    Not found: findPalindromeSuffix\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j\
    \ = 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n  \
    \              suffix(i) = j + 1\n                i += 1\n                j +=\
    \ 1\n            } else {\n                if (j == 0) {\n                   \
    \ suffix(i) = 0\n                    i += 1\n                } else {\n      \
    \              j = suffix(j - 1)\n                }\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        string +\
    \ prefix.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp80qi8hfo.scala:11)\n\tat Problem$.main(tmp80qi8hfo.scala:32)\n\
    \tat Problem.main(tmp80qi8hfo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val p = Array.ofDim[Int](n)\n\
    \        var c = 0\n        var r = 0\n        for (i <- 1 until n) {\n      \
    \      val mirror = 2 * c - i\n            if (i < r) p(i) = min(r - i, p(mirror))\n\
    \            while (i + 1 + p(i) < n && i - 1 - p(i) >= 0 && string(i + 1 + p(i))\
    \ == string(i - 1 - p(i))) p(i) += 1\n            if (i + p(i) > r) {\n      \
    \          c = i\n                r = i + p(i)\n            }\n        }\n   \
    \     var max = 0\n        var maxIndex = 0\n        for (i <- 0 until n) {\n\
    \            if (p(i) > max) {\n                max = p(i)\n                maxIndex\
    \ = i\n            }\n        }\n        val prefix = string.substring(0, maxIndex\
    \ - max)\n        val suffix = string.substring(maxIndex + max)\n        prefix.reverse\
    \ + string + suffix\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6yrug378.scala:36)\n\tat Problem.main(tmp6yrug378.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010214
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j\
    \ = 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n  \
    \              suffix(i) = j + 1\n                i += 1\n                j +=\
    \ 1\n            } else {\n                if (j == 0) {\n                   \
    \ suffix(i) = 0\n                    i += 1\n                } else {\n      \
    \              j = suffix(j - 1)\n                }\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        string +\
    \ prefix.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp80qi8hfo.scala:11)\n\tat Problem$.main(tmp80qi8hfo.scala:32)\n\
    \tat Problem.main(tmp80qi8hfo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 1\n        var j = 0\n        while (i\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(i)\
    \ = j + 1\n                i += 1\n                j += 1\n            } else\
    \ if (j > 0) {\n                j = suffix(j - 1)\n            } else {\n    \
    \            suffix(i) = 0\n                i += 1\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        prefix.reverse\
    \ + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpldwhz7v7.scala:25)\n\tat Problem$.main(tmpldwhz7v7.scala:29)\n\
    \tat Problem.main(tmpldwhz7v7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010191
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j\
    \ = 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n  \
    \              suffix(i) = j + 1\n                i += 1\n                j +=\
    \ 1\n            } else {\n                if (j == 0) {\n                   \
    \ suffix(i) = 0\n                    i += 1\n                } else {\n      \
    \              j = suffix(j - 1)\n                }\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        prefix.reverse\
    \ + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp4vsaxt7t.scala:11)\n\tat Problem$.main(tmp4vsaxt7t.scala:32)\n\
    \tat Problem.main(tmp4vsaxt7t.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n + 1)\n        suffix(n) = n\n        var i = n - 1\n    \
    \    while (i >= 0) {\n            var j = i\n            while (j >= 0 && string(j)\
    \ == string(n - 1 - i + j)) j -= 1\n            suffix(i) = i - j\n          \
    \  i -= 1\n        }\n        var best = 0\n        var bestLength = 0\n     \
    \   i = 0\n        while (i < n) {\n            if (suffix(i) > bestLength) {\n\
    \                best = i\n                bestLength = suffix(i)\n          \
    \  }\n            i += 1\n        }\n        string + string.substring(0, n -\
    \ bestLength).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzqcrbexa.scala:34)\n\tat Problem.main(tmpzqcrbexa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010214
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  var i = 1\n        var j = 0\n        while (i < s.length) {\n            if\
    \ (s(i) == s(j)) {\n                lps(i) = j + 1\n                i += 1\n \
    \               j += 1\n            } else {\n                if (j == 0) {\n\
    \                    lps(i) = 0\n                    i += 1\n                }\
    \ else {\n                    j = lps(j - 1)\n                }\n            }\n\
    \        }\n        val prefix = string.substring(0, n - lps(s.length - 1))\n\
    \        prefix.reverse + string\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2tgl66ta.scala:34)\n\tat Problem.main(tmp2tgl66ta.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010214
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string + string.reverse.substring(lps(s.length\
    \ - 1))\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010199
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val reversed = string.reverse\n        val s\
    \ = string + \"#\" + reversed\n        val lps = Array.fill(s.length)(0)\n   \
    \     var i = 1\n        var len = 0\n        while (i < s.length) {\n       \
    \     if (s(i) == s(len)) {\n                len += 1\n                lps(i)\
    \ = len\n                i += 1\n            } else {\n                if (len\
    \ != 0) {\n                    len = lps(len - 1)\n                } else {\n\
    \                    lps(i) = 0\n                    i += 1\n                }\n\
    \            }\n        }\n        string + reversed.substring(lps(s.length -\
    \ 1))\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010202
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = string.substring(string.length\
    \ / 2)\n        val prefix = string.substring(0, string.length / 2)\n        val\
    \ reversedPrefix = prefix.reverse\n        val palindromeSuffix = findPalindromeSuffix(suffix)\n\
    \        val palindrome = suffix + reversedPrefix + palindromeSuffix\n       \
    \ palindrome\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnjfg7s0l.scala:12:31 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mpalindromeSuffix\e[0m =\
    \ findPalindromeSuffix(suffix)\n\e[31m\e[31m   |\e[0m                        \
    \       ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \    Not found: findPalindromeSuffix\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 1\n        var j = 0\n        while (i\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(i)\
    \ = j + 1\n                i += 1\n                j += 1\n            } else\
    \ if (j > 0) {\n                j = suffix(j - 1)\n            } else {\n    \
    \            suffix(i) = 0\n                i += 1\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        prefix.reverse\
    \ + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpldwhz7v7.scala:25)\n\tat Problem$.main(tmpldwhz7v7.scala:29)\n\
    \tat Problem.main(tmpldwhz7v7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010191
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = string.substring(string.length\
    \ / 2)\n        val prefix = string.substring(0, string.length / 2)\n        val\
    \ reversedPrefix = prefix.reverse\n        val palindromeSuffix = suffix.substring(suffix.indexOf(reversedPrefix))\n\
    \        val palindromePrefix = reversedPrefix.substring(0, reversedPrefix.length\
    \ - palindromeSuffix.length)\n        palindromePrefix + string + palindromeSuffix\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 0, end -1, length 0\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.makePalindrome(tmpeo789f6o.scala:13)\n\tat Problem$.main(tmpeo789f6o.scala:18)\n\
    \tat Problem.main(tmpeo789f6o.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010214
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val z = new Array[Int](s.length)\n       \
    \ z(0) = s.length\n        var l = 0; var r = 0\n        for (i <- 1 until s.length)\
    \ {\n            if (i > r) {\n                l = r = i\n                while\
    \ (r < s.length && s(r - l) == s(r)) r += 1\n                z(i) = r - l\n  \
    \              r -= 1\n            } else {\n                val k = i - l\n \
    \               if (z(k) < r - i + 1) z(i) = z(k)\n                else {\n  \
    \                  l = i\n                    while (r < s.length && s(r - l)\
    \ == s(r)) r += 1\n                    z(i) = r - l\n                    r -=\
    \ 1\n                }\n            }\n        }\n        string + string.substring(z(n\
    \ + 1)).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdxp7hka1.scala:16:22\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m                l = r = i\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m           \
    \         Found:    Unit\n\e[31m   |\e[0m                    Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010217
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val dp = Array.ofDim[Int](n,\
    \ n)\n        for (i <- 0 until n) dp(i)(i) = 1\n        for (i <- n - 1 to 0\
    \ by -1) {\n            for (j <- i + 1 until n) {\n                if (string(i)\
    \ == string(j)) dp(i)(j) = dp(i + 1)(j - 1) + 2\n                else dp(i)(j)\
    \ = max(dp(i + 1)(j), dp(i)(j - 1))\n            }\n        }\n        val suffix\
    \ = string.substring(n - dp(0)(n - 1), n)\n        val prefix = string.substring(0,\
    \ n - dp(0)(n - 1))\n        suffix + prefix.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp0ot6c9w7.scala:18)\n\tat Problem$.main(tmp0ot6c9w7.scala:23)\n\
    \tat Problem.main(tmp0ot6c9w7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010219
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val reversed = string.reverse\n        val longestPalindrome\
    \ = (0 to string.length).map(i => string.substring(0, i) + reversed).maxBy(s =>\
    \ s.length - s.reverse.indexOf(s))\n        longestPalindrome.substring(longestPalindrome.length\
    \ - string.length) + string\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqnnm0ult.scala:15)\n\tat Problem.main(tmpqnnm0ult.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010219
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = string.substring(string.length\
    \ / 2)\n        val prefix = string.substring(0, string.length / 2)\n        val\
    \ reversedPrefix = prefix.reverse\n        val palindromeSuffix = findPalindromeSuffix(suffix)\n\
    \        suffix + reversedPrefix + palindromeSuffix\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0_0db2w7.scala:12:31 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mpalindromeSuffix\e[0m =\
    \ findPalindromeSuffix(suffix)\n\e[31m\e[31m   |\e[0m                        \
    \       ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \    Not found: findPalindromeSuffix\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010215
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2gll3o0.scala:21)\n\tat Problem.main(tmpl2gll3o0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string + string.substring(lps(s.length -\
    \ 1)).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjtgoryla.scala:22)\n\tat Problem.main(tmpjtgoryla.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010202
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        var len = 0\n        var i =\
    \ 1\n        while (i < s.length) {\n            if (s(i) == s(len)) {\n     \
    \           len += 1\n                lps(i) = len\n                i += 1\n \
    \           } else {\n                if (len != 0) len = lps(len - 1)\n     \
    \           else {\n                    lps(i) = 0\n                    i += 1\n\
    \                }\n            }\n        }\n        val prefix = string.substring(lps(s.length\
    \ - 1))\n        prefix.reverse + string\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp11_7un_y.scala:32)\n\tat Problem.main(tmp11_7un_y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010221
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = string.substring(string.length\
    \ / 2)\n        val prefix = string.substring(0, string.length / 2)\n        val\
    \ reversedPrefix = prefix.reverse\n        val palindromeSuffix = suffix.findPalindromeSuffix\n\
    \        val palindromePrefix = reversedPrefix.findPalindromePrefix\n        val\
    \ palindrome = palindromeSuffix + palindromePrefix\n        val result = palindrome\
    \ + string\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp77uz53yz.scala:12:38 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mpalindromeSuffix\e[0m =\
    \ suffix.findPalindromeSuffix\n\e[31m\e[31m   |\e[0m                         \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    value\
    \ findPalindromeSuffix is not a member of String\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp77uz53yz.scala:13:46 ------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mpalindromePrefix\e[0m = reversedPrefix.findPalindromePrefix\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    value findPalindromePrefix is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1660010219
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val dp = Array.ofDim[Int](n,\
    \ n)\n        for (i <- 0 until n) dp(i)(i) = 1\n        for (i <- 0 until n -\
    \ 1) dp(i)(i + 1) = if (string(i) == string(i + 1)) 2 else 1\n        for (k <-\
    \ 3 to n) {\n            for (i <- 0 to n - k) {\n                val j = i +\
    \ k - 1\n                dp(i)(j) = if (string(i) == string(j)) dp(i + 1)(j -\
    \ 1) + 2 else max(dp(i + 1)(j), dp(i)(j - 1))\n            }\n        }\n    \
    \    val longestPalindrome = dp(0)(n - 1)\n        val prefix = string.substring(0,\
    \ n - longestPalindrome)\n        val suffix = string.substring(n - longestPalindrome,\
    \ n)\n        prefix.reverse + string\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpcvk07_8n.scala:19)\n\tat Problem$.main(tmpcvk07_8n.scala:25)\n\
    \tat Problem.main(tmpcvk07_8n.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010221
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val rev = string.reverse\n\
    \        val s = string + \"#\" + rev\n        val z = new Array[Int](s.length)\n\
    \        var l = 0; var r = 0\n        for (i <- 1 until s.length) {\n       \
    \     if (i > r) {\n                l = r = i\n                while (r < s.length\
    \ && s(r - l) == s(r)) r += 1\n                z(i) = r - l; r -= 1\n        \
    \    } else {\n                val k = i - l\n                if (z(k) < r - i\
    \ + 1) z(i) = z(k)\n                else {\n                    l = i\n      \
    \              while (r < s.length && s(r - l) == s(r)) r += 1\n             \
    \       z(i) = r - l; r -= 1\n                }\n            }\n        }\n  \
    \      val longestPalindromeSuffix = z(s.length - 1)\n        string + rev.substring(0,\
    \ n - longestPalindromeSuffix)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_94k94b8.scala:16:22\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m                l = r = i\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m           \
    \         Found:    Unit\n\e[31m   |\e[0m                    Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010219
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + '$' + string.reverse\n        val z = new Array[Int](s.length)\n        var\
    \ l = 0; var r = 0\n        for (i <- 1 until s.length) {\n            if (i >\
    \ r) {\n                l = r = i\n                while (r < s.length && s(r\
    \ - l) == s(r)) r += 1\n                z(i) = r - l; r -= 1\n            } else\
    \ {\n                val k = i - l\n                if (z(k) < r - i + 1) z(i)\
    \ = z(k)\n                else {\n                    l = i\n                \
    \    while (r < s.length && s(r - l) == s(r)) r += 1\n                    z(i)\
    \ = r - l; r -= 1\n                }\n            }\n        }\n        val prefix\
    \ = string.substring(0, n - z(n + 1))\n        prefix.reverse + string\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\
    \")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5zqx26wy.scala:15:22\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m                l = r = i\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m           \
    \         Found:    Unit\n\e[31m   |\e[0m                    Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010220
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n        while (j\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(j)\
    \ = i + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (i == 0) {\n                    suffix(j) = 0\n      \
    \              j += 1\n                } else {\n                    i = suffix(i\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        prefix.reverse + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpo7athp04.scala:27)\n\tat Problem$.main(tmpo7athp04.scala:31)\n\
    \tat Problem.main(tmpo7athp04.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val p = Array.ofDim[Int](n)\n\
    \        var c = 0\n        var r = 0\n        for (i <- 1 until n) {\n      \
    \      if (i > r) {\n                p(i) = 0\n                c = i\n       \
    \         r = i\n            } else {\n                val i2 = 2 * c - i\n  \
    \              if (p(i2) < (r - i)) {\n                    p(i) = p(i2)\n    \
    \            } else {\n                    p(i) = r - i\n                    c\
    \ = i\n                    r = i + p(i)\n                }\n            }\n  \
    \          while (i - p(i) - 1 >= 0 && i + p(i) + 1 < n && string(i - p(i) - 1)\
    \ == string(i + p(i) + 1)) {\n                p(i) += 1\n                c = i\n\
    \                r = i + p(i)\n            }\n        }\n        val max = p.max\n\
    \        val prefix = string.substring(0, n - max)\n        val suffix = string.substring(n\
    \ - max)\n        prefix + suffix.reverse + suffix\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.makePalindrome(tmpl8y94r6v.scala:34)\n\tat Problem$.main(tmpl8y94r6v.scala:40)\n\
    \tat Problem.main(tmpl8y94r6v.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010223
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n        while (j\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(j)\
    \ = i + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (i == 0) {\n                    suffix(j) = 0\n      \
    \              j += 1\n                } else {\n                    i = suffix(i\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpp4jnnznv.scala:27)\n\tat Problem$.main(tmpp4jnnznv.scala:31)\n\
    \tat Problem.main(tmpp4jnnznv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val reversed = string.reverse\n        val (prefix,\
    \ suffix) = string.zip(reversed).span(x => x._1 == x._2)\n        prefix.map(_._1).mkString\
    \ + string + suffix.map(_._2).mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyb59c33v.scala:15)\n\tat Problem.main(tmpyb59c33v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010223
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = longestPalindromicSuffix(string)\n\
    \        val prefix = string.substring(0, string.length - suffix.length)\n   \
    \     prefix.reverse + string\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb0com5u_.scala:9:21 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36msuffix\e[0m = longestPalindromicSuffix(string)\n\
    \e[31m\e[31m  |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                     Not found: longestPalindromicSuffix\n\e[31m  |\e\
    [0m\n\e[31m  |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010219
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ new Array[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j =\
    \ 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n    \
    \            suffix(i) = j + 1\n                i += 1\n                j += 1\n\
    \            } else {\n                if (j == 0) {\n                    suffix(i)\
    \ = 0\n                    i += 1\n                } else {\n                \
    \    j = suffix(j - 1)\n                }\n            }\n        }\n        val\
    \ prefix = string.substring(0, n - suffix(n - 1))\n        prefix.reverse + string\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp3ttta0el.scala:11)\n\tat Problem$.main(tmp3ttta0el.scala:32)\n\
    \tat Problem.main(tmp3ttta0el.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n            var j = 0\n\
    \            while (i - j >= 0 && i + j < n && string(i - j) == string(i + j))\
    \ j += 1\n            suffix(i) = j\n        }\n        var max = 0\n        var\
    \ maxIndex = 0\n        for (i <- 0 until n) {\n            if (suffix(i) > max)\
    \ {\n                max = suffix(i)\n                maxIndex = i\n         \
    \   }\n        }\n        val prefix = string.substring(0, maxIndex - max + 1)\n\
    \        prefix + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 0, end 1, length 0\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.makePalindrome(tmpq48ilux9.scala:24)\n\tat Problem$.main(tmpq48ilux9.scala:28)\n\
    \tat Problem.main(tmpq48ilux9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n            suffix(i) =\
    \ 0\n            var j = i\n            while (j >= 0 && string(j) == string(n\
    \ - 1 - i + j)) {\n                suffix(i) += 1\n                j -= 1\n  \
    \          }\n        }\n        var max = 0\n        var maxIndex = 0\n     \
    \   for (i <- 0 until n) {\n            if (suffix(i) > max) {\n             \
    \   max = suffix(i)\n                maxIndex = i\n            }\n        }\n\
    \        val prefix = string.substring(0, n - maxIndex - max)\n        prefix\
    \ + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 0, end -2, length 3\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.makePalindrome(tmp2fyxrzdy.scala:27)\n\tat Problem$.main(tmp2fyxrzdy.scala:33)\n\
    \tat Problem.main(tmp2fyxrzdy.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010224
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2gll3o0.scala:21)\n\tat Problem.main(tmpl2gll3o0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        var i = 1\n        while (i\
    \ < s.length) {\n            if (s(i) == s(lps(i - 1))) lps(i) = lps(i - 1) +\
    \ 1\n            else {\n                var j = lps(i - 1)\n                while\
    \ (j > 0 && s(i) != s(j)) j = lps(j - 1)\n                if (s(i) == s(j)) lps(i)\
    \ = j + 1\n            }\n            i += 1\n        }\n        string.substring(lps(s.length\
    \ - 1)) + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp952saw08.scala:26)\n\tat Problem.main(tmp952saw08.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val pi = Array.fill(s.length)(0)\n        for (i <- 1 until s.length) {\n\
    \            var j = pi(i - 1)\n            while (j > 0 && s(i) != s(j)) j =\
    \ pi(j - 1)\n            if (s(i) == s(j)) pi(i) = j + 1\n        }\n        string.substring(pi(s.length\
    \ - 1)) + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbeqbf5lr.scala:21)\n\tat Problem.main(tmpbeqbf5lr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010224
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val stringLength = string.length\n        val\
    \ stringReverse = string.reverse\n        val suffixLength = (0 until stringLength).find(i\
    \ => string.substring(i) == stringReverse.substring(0, stringLength - i)).get\n\
    \        string + stringReverse.substring(suffixLength)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: None.get\n\tat scala.None$.get(Option.scala:627)\n\
    \tat scala.None$.get(Option.scala:626)\n\tat Problem$.makePalindrome(tmpaxrqfq2g.scala:11)\n\
    \tat Problem$.main(tmpaxrqfq2g.scala:15)\n\tat Problem.main(tmpaxrqfq2g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010223
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        for (i <- 1 until n) {\n\
    \            var j = suffix(i - 1)\n            while (j > 0 && string(i) != string(j))\
    \ j = suffix(j - 1)\n            if (string(i) == string(j)) suffix(i) = j + 1\n\
    \            else suffix(i) = 0\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        prefix.reverse + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp7iymraz9.scala:11)\n\tat Problem$.main(tmp7iymraz9.scala:22)\n\
    \tat Problem.main(tmp7iymraz9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j\
    \ = 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n  \
    \              suffix(i) = j + 1\n                i += 1\n                j +=\
    \ 1\n            } else {\n                if (j == 0) {\n                   \
    \ suffix(i) = 0\n                    i += 1\n                } else {\n      \
    \              j = suffix(j - 1)\n                }\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        string +\
    \ prefix.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp80qi8hfo.scala:11)\n\tat Problem$.main(tmp80qi8hfo.scala:32)\n\
    \tat Problem.main(tmp80qi8hfo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n            var j = 0\n\
    \            while (i - j >= 0 && i + j < n && string(i - j) == string(i + j))\
    \ j += 1\n            suffix(i) = j\n        }\n        var max = 0\n        var\
    \ maxIndex = 0\n        for (i <- 0 until n) {\n            if (suffix(i) > max)\
    \ {\n                max = suffix(i)\n                maxIndex = i\n         \
    \   }\n        }\n        val prefix = string.substring(0, maxIndex - max + 1)\n\
    \        string + prefix.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 0, end 1, length 0\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.makePalindrome(tmphjv6atl3.scala:24)\n\tat Problem$.main(tmphjv6atl3.scala:28)\n\
    \tat Problem.main(tmphjv6atl3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n        while (j\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(j)\
    \ = i + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (i == 0) {\n                    suffix(j) = 0\n      \
    \              j += 1\n                } else {\n                    i = suffix(i\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpp4jnnznv.scala:27)\n\tat Problem$.main(tmpp4jnnznv.scala:31)\n\
    \tat Problem.main(tmpp4jnnznv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j\
    \ = 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n  \
    \              suffix(i) = j + 1\n                i += 1\n                j +=\
    \ 1\n            } else {\n                if (j == 0) {\n                   \
    \ suffix(i) = 0\n                    i += 1\n                } else {\n      \
    \              j = suffix(j - 1)\n                }\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        string +\
    \ prefix.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp80qi8hfo.scala:11)\n\tat Problem$.main(tmp80qi8hfo.scala:32)\n\
    \tat Problem.main(tmp80qi8hfo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = string.substring(string.length\
    \ / 2)\n        val prefix = string.substring(0, string.length / 2)\n        val\
    \ palindrome = suffix + prefix.reverse\n        palindrome\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwxp5ilqh.scala:17)\n\tat Problem.main(tmpwxp5ilqh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010223
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        var longestPalindrome = \"\"\n        var longestPalindromeLength\
    \ = 0\n        for (i <- 0 to string.length) {\n            val substring = string.substring(i)\n\
    \            if (substring.length > longestPalindromeLength && substring.reverse\
    \ == substring) {\n                longestPalindrome = substring\n           \
    \     longestPalindromeLength = substring.length\n            }\n        }\n \
    \       string + string.substring(0, string.length - longestPalindromeLength).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010224
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val suffix = string.substring(string.length\
    \ / 2)\n        val prefix = string.substring(0, string.length / 2)\n        val\
    \ palindromeSuffix = findPalindromeSuffix(suffix)\n        val palindromePrefix\
    \ = prefix.substring(0, prefix.length - palindromeSuffix.length)\n        palindromePrefix\
    \ + suffix + palindromePrefix.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp86yn94a0.scala:11:31 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mpalindromeSuffix\e[0m =\
    \ findPalindromeSuffix(suffix)\n\e[31m\e[31m   |\e[0m                        \
    \       ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \    Not found: findPalindromeSuffix\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010188
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        var longestPalindrome = \"\"\n        for (i\
    \ <- 0 to string.length) {\n            val prefix = string.substring(0, i)\n\
    \            val suffix = string.substring(i)\n            if (isPalindrome(suffix))\
    \ {\n                longestPalindrome = suffix\n                break\n     \
    \       }\n        }\n        string + reverse(string.substring(0, string.length\
    \ - longestPalindrome.length))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq20r52hc.scala:13:16 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            \e[33mif\e[0m (isPalindrome(suffix)) {\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \        Not found: isPalindrome\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpq20r52hc.scala:15:16 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m                break\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e\
    [31m   |\e[0m                Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpq20r52hc.scala:18:17 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        string + reverse(string.substring(\e[31m0\e[0m,\
    \ string.length - longestPalindrome.length))\n\e[31m\e[31m   |\e[0m          \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: reverse\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010221
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val dp = Array.ofDim[Int](n,\
    \ n)\n        for (i <- 0 until n) dp(i)(i) = 1\n        for (i <- 0 until n -\
    \ 1) dp(i)(i + 1) = if (string(i) == string(i + 1)) 2 else 1\n        for (k <-\
    \ 3 to n) {\n            for (i <- 0 until n - k + 1) {\n                val j\
    \ = i + k - 1\n                dp(i)(j) = if (string(i) == string(j)) dp(i + 1)(j\
    \ - 1) + 2 else max(dp(i + 1)(j), dp(i)(j - 1))\n            }\n        }\n  \
    \      val longestPalindrome = dp(0)(n - 1)\n        val prefix = string.substring(0,\
    \ n - longestPalindrome)\n        val suffix = string.substring(n - longestPalindrome,\
    \ n)\n        prefix.reverse + suffix\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpkwkth3oc.scala:19)\n\tat Problem$.main(tmpkwkth3oc.scala:25)\n\
    \tat Problem.main(tmpkwkth3oc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010224
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val z = new Array[Int](s.length)\n       \
    \ z(0) = s.length\n        var l = 0; var r = 0\n        for (i <- 1 until s.length)\
    \ {\n            if (i > r) {\n                l = r = i\n                while\
    \ (r < s.length && s(r - l) == s(r)) r += 1\n                z(i) = r - l\n  \
    \              r -= 1\n            } else {\n                val k = i - l\n \
    \               if (z(k) < r - i + 1) z(i) = z(k)\n                else {\n  \
    \                  l = i\n                    while (r < s.length && s(r - l)\
    \ == s(r)) r += 1\n                    z(i) = r - l\n                    r -=\
    \ 1\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - z(n + 1))\n        string + prefix.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprw4_7byg.scala:16:22\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m                l = r = i\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m           \
    \         Found:    Unit\n\e[31m   |\e[0m                    Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010224
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string + string.substring(lps(s.length -\
    \ 1)).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjtgoryla.scala:22)\n\tat Problem.main(tmpjtgoryla.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010202
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ string.substring(n / 2, n)\n        val prefix = string.substring(0, n / 2)\n\
    \        val reversedPrefix = prefix.reverse\n        val palindromeSuffix = findLongestPalindrome(suffix)\n\
    \        val palindrome = suffix + reversedPrefix + palindromeSuffix\n       \
    \ palindrome\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprktueqhi.scala:13:31 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mpalindromeSuffix\e[0m =\
    \ findLongestPalindrome(suffix)\n\e[31m\e[31m   |\e[0m                       \
    \        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \      Not found: findLongestPalindrome\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010222
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2gll3o0.scala:21)\n\tat Problem.main(tmpl2gll3o0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n        while (j\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(j)\
    \ = i + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (i == 0) {\n                    suffix(j) = 0\n      \
    \              j += 1\n                } else {\n                    i = suffix(i\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        prefix.reverse + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpo7athp04.scala:27)\n\tat Problem$.main(tmpo7athp04.scala:31)\n\
    \tat Problem.main(tmpo7athp04.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2gll3o0.scala:21)\n\tat Problem.main(tmpl2gll3o0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 0\n        while (i < n) {\n          \
    \  var j = 0\n            while (i - j >= 0 && i + j < n && string(i - j) == string(i\
    \ + j)) j += 1\n            suffix(i) = j\n            var k = 1\n           \
    \ while (i - k >= 0 && i + k < n && k + suffix(i - k) < j) {\n               \
    \ suffix(i + k) = suffix(i - k)\n                k += 1\n            }\n     \
    \       i += k\n        }\n        val prefix = Array.ofDim[Int](n)\n        i\
    \ = 0\n        while (i < n) {\n            var j = 0\n            while (i -\
    \ j >= 0 && i + j + 1 < n && string(i - j) == string(i + j + 1)) j += 1\n    \
    \        prefix(i) = j\n            var k = 1\n            while (i - k >= 0 &&\
    \ i + k < n && k + prefix(i - k) < j) {\n                prefix(i + k) = prefix(i\
    \ - k)\n                k += 1\n            }\n            i += k\n        }\n\
    \        var max = 0\n        var maxIndex = 0\n        for (i <- 0 until n) {\n\
    \            if (suffix(i) > max) {\n                max = suffix(i)\n       \
    \         maxIndex = i\n            }\n            if (prefix(i) > max) {\n  \
    \              max = prefix(i)\n                maxIndex = i\n            }\n\
    \        }\n        val prefixString = string.substring(0, maxIndex - max + 1)\n\
    \        val suffixString = string.substring(maxIndex + max)\n        prefixString\
    \ + suffixString.reverse + string\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 0, end 1, length 0\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.makePalindrome(tmpevgkw3t8.scala:48)\n\tat Problem$.main(tmpevgkw3t8.scala:53)\n\
    \tat Problem.main(tmpevgkw3t8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010225
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val dp = Array.ofDim[Int](n,\
    \ n)\n        for (i <- 0 until n) {\n            dp(i)(i) = 1\n            if\
    \ (i + 1 < n) {\n                dp(i)(i + 1) = if (string(i) == string(i + 1))\
    \ 2 else 1\n            }\n        }\n        for (k <- 3 to n) {\n          \
    \  for (i <- 0 to n - k) {\n                val j = i + k - 1\n              \
    \  dp(i)(j) = if (string(i) == string(j)) dp(i + 1)(j - 1) + 2 else max(dp(i +\
    \ 1)(j), dp(i)(j - 1))\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - dp(0)(n - 1))\n        val suffix = prefix.reverse\n        string + suffix\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpbxz_fmxc.scala:23)\n\tat Problem$.main(tmpbxz_fmxc.scala:28)\n\
    \tat Problem.main(tmpbxz_fmxc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010225
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ new Array[Int](n)\n        suffix(0) = 0\n        for (i <- 1 until n) {\n \
    \           var j = suffix(i - 1)\n            while (j > 0 && string(i) != string(j))\
    \ j = suffix(j - 1)\n            if (string(i) == string(j)) suffix(i) = j + 1\n\
    \            else suffix(i) = 0\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp48x7vunk.scala:11)\n\tat Problem$.main(tmp48x7vunk.scala:22)\n\
    \tat Problem.main(tmp48x7vunk.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010225
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n            var j = 0\n\
    \            while (i - j >= 0 && i + j < n && string(i - j) == string(i + j))\
    \ j += 1\n            suffix(i) = j\n        }\n        var max = 0\n        var\
    \ maxIndex = 0\n        for (i <- 0 until n) {\n            if (suffix(i) > max)\
    \ {\n                max = suffix(i)\n                maxIndex = i\n         \
    \   }\n        }\n        val prefix = string.substring(0, maxIndex - max + 1)\n\
    \        prefix + string\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 0, end 1, length 0\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.makePalindrome(tmpq48ilux9.scala:24)\n\tat Problem$.main(tmpq48ilux9.scala:28)\n\
    \tat Problem.main(tmpq48ilux9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ new Array[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j =\
    \ 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n    \
    \            suffix(i) = j + 1\n                i += 1\n                j += 1\n\
    \            } else {\n                if (j == 0) {\n                    suffix(i)\
    \ = 0\n                    i += 1\n                } else {\n                \
    \    j = suffix(j - 1)\n                }\n            }\n        }\n        val\
    \ prefix = string.substring(0, n - suffix(n - 1))\n        prefix.reverse + string\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp3ttta0el.scala:11)\n\tat Problem$.main(tmp3ttta0el.scala:32)\n\
    \tat Problem.main(tmp3ttta0el.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string + string.reverse.substring(lps(s.length\
    \ - 1))\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010199
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string + string.substring(lps(s.length -\
    \ 1)).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjtgoryla.scala:22)\n\tat Problem.main(tmpjtgoryla.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010202
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"*\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5k0brgbm.scala:21)\n\tat Problem.main(tmp5k0brgbm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010225
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val longestPalindrome = longestPalindromeSuffix(string)\n\
    \        val prefix = string.substring(0, string.length - longestPalindrome.length)\n\
    \        prefix + longestPalindrome + prefix.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4kx1oiu2.scala:9:32 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mlongestPalindrome\e[0m =\
    \ longestPalindromeSuffix(string)\n\e[31m\e[31m  |\e[0m                      \
    \          ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m                      \
    \          Not found: longestPalindromeSuffix\n\e[31m  |\e[0m\n\e[31m  |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010208
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n            var j = i\n\
    \            while (j >= 0 && string(j) == string(n - 1 - i + j)) j -= 1\n   \
    \         suffix(i) = i - j\n        }\n        var i = 0\n        while (i <\
    \ n && suffix(i) != i + 1) i += 1\n        val prefix = string.substring(0, n\
    \ - i)\n        prefix.reverse + string\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpui6j4agr.scala:23)\n\tat Problem.main(tmpui6j4agr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010226
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n        while (j\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(j)\
    \ = i + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (i == 0) {\n                    suffix(j) = 0\n      \
    \              j += 1\n                } else {\n                    i = suffix(i\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmpp4jnnznv.scala:27)\n\tat Problem$.main(tmpp4jnnznv.scala:31)\n\
    \tat Problem.main(tmpp4jnnznv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010180
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val z = Array.fill(s.length)(0)\n        var\
    \ l = 0; var r = 0\n        for (i <- 1 until s.length) {\n            if (i >\
    \ r) {\n                l = i; r = i\n                while (r < s.length && s(r\
    \ - l) == s(r)) r += 1\n                z(i) = r - l; r -= 1\n            } else\
    \ {\n                val k = i - l\n                if (z(k) < r - i + 1) z(i)\
    \ = z(k)\n                else {\n                    l = i\n                \
    \    while (r < s.length && s(r - l) == s(r)) r += 1\n                    z(i)\
    \ = r - l; r -= 1\n                }\n            }\n        }\n        val longestPalindrome\
    \ = z.max\n        string.substring(longestPalindrome) + string\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\"\
    )));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsxs7hs51.scala:34)\n\tat Problem.main(tmpsxs7hs51.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n            var j = 0\n\
    \            while (i - j >= 0 && i + j < n && string(i - j) == string(i + j))\
    \ j += 1\n            suffix(i) = j\n        }\n        var max = 0\n        var\
    \ maxIndex = 0\n        for (i <- 0 until n) {\n            if (suffix(i) > max)\
    \ {\n                max = suffix(i)\n                maxIndex = i\n         \
    \   }\n        }\n        string.substring(maxIndex + 1, n) + string\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\
    \")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 1, end 0, length 0\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.makePalindrome(tmp08hxz2ls.scala:24)\n\tat Problem$.main(tmp08hxz2ls.scala:27)\n\
    \tat Problem.main(tmp08hxz2ls.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010199
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j\
    \ = 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n  \
    \              suffix(i) = j + 1\n                i += 1\n                j +=\
    \ 1\n            } else {\n                if (j == 0) {\n                   \
    \ suffix(i) = 0\n                    i += 1\n                } else {\n      \
    \              j = suffix(j - 1)\n                }\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        string +\
    \ prefix.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp80qi8hfo.scala:11)\n\tat Problem$.main(tmp80qi8hfo.scala:32)\n\
    \tat Problem.main(tmp80qi8hfo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val reversed = string.reverse\n        val longestPalindrome\
    \ = (0 to string.length).map(i => string.substring(i)).find(s => s == reversed.substring(0,\
    \ s.length)).get\n        val prefix = string.substring(0, string.length - longestPalindrome.length)\n\
    \        prefix.reverse + string\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfl907_f5.scala:17)\n\tat Problem.main(tmpfl907_f5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010226
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string + string.reverse.substring(lps(s.length\
    \ - 1))\n    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
    \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n\
    \    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010199
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ new Array[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j =\
    \ 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n    \
    \            suffix(i) = j + 1\n                i += 1\n                j += 1\n\
    \            } else {\n                if (j == 0) {\n                    suffix(i)\
    \ = 0\n                    i += 1\n                } else {\n                \
    \    j = suffix(j - 1)\n                }\n            }\n        }\n        val\
    \ prefix = string.substring(0, n - suffix(n - 1))\n        prefix.reverse + string\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length\
    \ 0\n\tat Problem$.makePalindrome(tmp3ttta0el.scala:11)\n\tat Problem$.main(tmp3ttta0el.scala:32)\n\
    \tat Problem.main(tmp3ttta0el.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010190
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val s = string + \"#\" + string.reverse\n  \
    \      val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n   \
    \ assert(makePalindrome((\"x\")).equals((\"x\")));\n    assert(makePalindrome((\"\
    xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"xyx\")).equals((\"\
    xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2gll3o0.scala:21)\n\tat Problem.main(tmpl2gll3o0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        // suffix[i] is the length of the longest palindromic\
    \ suffix of string[0..i]\n        // suffix[i] is also the length of the longest\
    \ palindromic prefix of string[i..n-1]\n        for (i <- 0 until n) {\n     \
    \       var j = 0\n            while (i - j >= 0 && i + j < n && string(i - j)\
    \ == string(i + j)) j += 1\n            suffix(i) = j\n        }\n        var\
    \ max = 0\n        var maxIndex = 0\n        for (i <- 0 until n) {\n        \
    \    if (suffix(i) > max) {\n                max = suffix(i)\n               \
    \ maxIndex = i\n            }\n        }\n        val prefix = string.substring(0,\
    \ maxIndex - max + 1)\n        prefix + string\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 0, end 1, length 0\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.makePalindrome(tmpk4309zfk.scala:26)\n\tat Problem$.main(tmpk4309zfk.scala:30)\n\
    \tat Problem.main(tmpk4309zfk.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010226
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        var prefix = string\n        var suffix = \"\
    \"\n        var palindrome = \"\"\n        while (prefix.length > 0) {\n     \
    \       if (isPalindrome(prefix)) {\n                palindrome = prefix + suffix\n\
    \                break\n            }\n            suffix = prefix.charAt(0) +\
    \ suffix\n            prefix = prefix.substring(1)\n        }\n        palindrome\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\"\
    )).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
    \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
    xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"\
    jerryrrej\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2f1bifvz.scala:13:16 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            \e[33mif\e[0m (isPalindrome(prefix)) {\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \        Not found: isPalindrome\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp2f1bifvz.scala:15:16 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m                break\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e\
    [31m   |\e[0m                Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010225
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Find the shortest palindrome that begins with a supplied string.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
    \ : String) : String = {\n        val n = string.length\n        val suffix =\
    \ Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n            var j = 0\n\
    \            while (i - j >= 0 && i + j < n && string(i - j) == string(i + j))\
    \ j += 1\n            suffix(i) = j\n        }\n        var longest = 0\n    \
    \    var longestIndex = 0\n        for (i <- 0 until n) {\n            if (suffix(i)\
    \ > longest) {\n                longest = suffix(i)\n                longestIndex\
    \ = i\n            }\n        }\n        val prefix = string.substring(0, longestIndex\
    \ - longest + 1)\n        string + prefix.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(makePalindrome((\"\")).equals((\"\")));\n    assert(makePalindrome((\"\
    x\")).equals((\"x\")));\n    assert(makePalindrome((\"xyz\")).equals((\"xyzyx\"\
    )));\n    assert(makePalindrome((\"xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"\
    jerry\")).equals((\"jerryrrej\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 0, end 1, length 0\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.makePalindrome(tmph0_vlgn_.scala:24)\n\tat Problem$.main(tmph0_vlgn_.scala:28)\n\
    \tat Problem.main(tmph0_vlgn_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010226
