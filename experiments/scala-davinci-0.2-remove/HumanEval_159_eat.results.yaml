language: scala
name: HumanEval_159_eat
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var result = List[Long]()\n\
    \        result = result :+ (number + min(need, remaining))\n        result =\
    \ result :+ (max(remaining - need, 0))\n        return result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // your code here\n    \
    \    var result = List[Long]()\n        if (remaining >= need) {\n           \
    \ result = List(number + need, remaining - need)\n        } else {\n         \
    \   result = List(number + remaining, 0)\n        }\n        result\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) List(number + remaining, 0)\n        else List(number + need, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gnaittc.scala:32)\n\tat Problem.main(tmp5gnaittc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var total = number + remaining\n\
    \        var eaten = 0L\n        var left = 0L\n        if (total >= need) {\n\
    \            eaten = need\n            left = total - need\n        } else {\n\
    \            eaten = total\n            left = 0\n        }\n        List(eaten,\
    \ left)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_x9twjvd.scala:36)\n\tat Problem.main(tmp_x9twjvd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var list = List[Long]()\n\
    \        if (remaining >= need) {\n            list = List(number + need, remaining\
    \ - need)\n        } else {\n            list = List(number + remaining, 0)\n\
    \        }\n        list\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) List(number + remaining, 0)\n        else List(number + need, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gnaittc.scala:32)\n\tat Problem.main(tmp5gnaittc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, max(remaining - need, 0))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) List(number + remaining, 0)\n        else List(number + need, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gnaittc.scala:32)\n\tat Problem.main(tmp5gnaittc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) List(number + remaining, 0)\n        else List(number + need, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gnaittc.scala:32)\n\tat Problem.main(tmp5gnaittc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var total = number + remaining\n\
    \        var eaten = 0L\n        if (total >= need) {\n            eaten = need\n\
    \            total -= need\n        } else {\n            eaten = total\n    \
    \        total = 0\n        }\n        List(eaten, total)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm3ldmxrf.scala:35)\n\tat Problem.main(tmpm3ldmxrf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + need <= remaining)\
    \ List(number + need, remaining - need)\n        else List(remaining + number,\
    \ 0)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpallu2baz.scala:27)\n\tat Problem.main(tmpallu2baz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = min(number +\
    \ remaining, need)\n        List(eaten, remaining - (eaten - number))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa5h14qa6.scala:27)\n\tat Problem.main(tmpa5h14qa6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) {\n            List(number + remaining, 0)\n        } else {\n       \
    \     List(need, number + remaining - need)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1e5cwtza.scala:30)\n\tat Problem.main(tmp1e5cwtza.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var result = List[Long]()\n\
    \        if (remaining > need) {\n            result = List(number + need, remaining\
    \ - need)\n        } else {\n            result = List(number + remaining, 0)\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + need > remaining)\
    \ {\n            List(remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - number - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4x_v7ls3.scala:30)\n\tat Problem.main(tmp4x_v7ls3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var result = List[Long]()\n\
    \        var total = number + remaining\n        if (total >= need) {\n      \
    \      result = List(need, total - need)\n        } else {\n            result\
    \ = List(total, 0)\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpswf9r8nh.scala:33)\n\tat Problem.main(tmpswf9r8nh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + need <= remaining)\
    \ List(number + need, remaining - (number + need))\n        else List(remaining,\
    \ 0)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp38c33727.scala:27)\n\tat Problem.main(tmp38c33727.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // your code here\n    \
    \    return List(0, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpexd3vvg2.scala:27)\n\tat Problem.main(tmpexd3vvg2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + need <= remaining)\
    \ List(number + need, remaining - (number + need))\n        else List(remaining\
    \ + number, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq46qoqfa.scala:27)\n\tat Problem.main(tmpq46qoqfa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = min(number +\
    \ remaining, need)\n        val left = max(0, number + remaining - need)\n   \
    \     List(eaten, left)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk6m4bbzk.scala:28)\n\tat Problem.main(tmpk6m4bbzk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining >=\
    \ need) {\n            List(need, number + remaining - need)\n        } else {\n\
    \            List(number + remaining, 0)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpygeqhf0r.scala:30)\n\tat Problem.main(tmpygeqhf0r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = min(number +\
    \ remaining, need)\n        List(eaten, eaten - need)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_0szt483.scala:27)\n\tat Problem.main(tmp_0szt483.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + remaining\n\
    \        val eaten = if (total >= need) need else total\n        List(eaten, total\
    \ - eaten)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8srxjkgj.scala:28)\n\tat Problem.main(tmp8srxjkgj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) List(number + remaining, 0)\n        else List(number + need, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gnaittc.scala:32)\n\tat Problem.main(tmp5gnaittc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining >=\
    \ need) List(need, number + remaining - need)\n        else List(number + remaining,\
    \ 0)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9rfvbsgl.scala:27)\n\tat Problem.main(tmp9rfvbsgl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = min(number +\
    \ remaining, need)\n        val left = max(0, number + remaining - need)\n   \
    \     List(eaten, left)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk6m4bbzk.scala:28)\n\tat Problem.main(tmpk6m4bbzk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number >= need) return\
    \ List(number, remaining)\n        else if (remaining + number >= need) return\
    \ List(need, remaining + number - need)\n        else return List(remaining +\
    \ number, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnxr49nd_.scala:28)\n\tat Problem.main(tmpnxr49nd_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var total = number + remaining\n\
    \        var left = 0L\n        if (total >= need) {\n            total = need\n\
    \            left = total - need\n        }\n        List(total, left)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4x4w6ju6.scala:32)\n\tat Problem.main(tmp4x4w6ju6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var result = List[Long]()\n\
    \        if (remaining >= need) {\n            result = List(number + need, remaining\
    \ - need)\n        } else {\n            result = List(number + remaining, 0)\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // your code here\n    \
    \    val total = number + need\n        if (total <= remaining) List(total, remaining\
    \ - total)\n        else List(remaining + number, 0)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3gjanib4.scala:29)\n\tat Problem.main(tmp3gjanib4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining >= need) List(number\
    \ + need, remaining - need)\n        else List(number + remaining, 0)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // your code here\n    \
    \    val total = number + remaining\n        val eaten = if (total >= need) need\
    \ else total\n        val left = total - eaten\n        List(eaten, left)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph7o6cp0i.scala:30)\n\tat Problem.main(tmph7o6cp0i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, max(remaining - need, 0))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining >= need) List(number\
    \ + need, remaining - need)\n        else List(number + remaining, 0)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var total = number + min(need,\
    \ remaining)\n        var left = max(remaining - need, 0)\n        List(total,\
    \ left)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            return List(number + remaining, 0)\n        }\n        return List(number\
    \ + need, remaining - need)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var eaten = number\n   \
    \     var left = remaining\n        if (need <= remaining) {\n            eaten\
    \ += need\n            left -= need\n        } else {\n            eaten += remaining\n\
    \            left = 0\n        }\n        List(eaten, left)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = min(number +\
    \ remaining, need)\n        List(eaten, eaten - need)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_0szt483.scala:27)\n\tat Problem.main(tmp_0szt483.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + remaining\n\
    \        if (total >= need) {\n            List(need, total - need)\n        }\
    \ else {\n            List(total, 0)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_kqbjre8.scala:31)\n\tat Problem.main(tmp_kqbjre8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number >= need) {\n\
    \            List(number, remaining)\n        } else {\n            val total\
    \ = number + remaining\n            if (total >= need) {\n                List(need,\
    \ total - need)\n            } else {\n                List(total, 0)\n      \
    \      }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpja4ph76a.scala:35)\n\tat Problem.main(tmpja4ph76a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + remaining\n\
    \        val eaten = if (total >= need) need else total\n        List(eaten, total\
    \ - eaten)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8srxjkgj.scala:28)\n\tat Problem.main(tmp8srxjkgj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, max(remaining - need, 0))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining >= need) {\n\
    \            List(number + need, remaining - need)\n        } else {\n       \
    \     List(number + remaining, 0)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var result = List[Long]()\n\
    \        if (remaining < need) {\n            result = List(number + remaining,\
    \ 0)\n        } else {\n            result = List(number + need, remaining - need)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // your code here\n    \
    \    return List(0, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpexd3vvg2.scala:27)\n\tat Problem.main(tmpexd3vvg2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining >= need) List(number\
    \ + need, remaining - need)\n        else List(number + remaining, 0)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var eaten = number\n   \
    \     var left = remaining\n        while (eaten < need && left > 0) {\n     \
    \       eaten += 1\n            left -= 1\n        }\n        List(eaten, left)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk50tlwe6.scala:32)\n\tat Problem.main(tmpk50tlwe6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) List(number + remaining, 0)\n        else List(number + need, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gnaittc.scala:32)\n\tat Problem.main(tmp5gnaittc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) List(number + remaining, 0)\n        else List(number + need, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gnaittc.scala:32)\n\tat Problem.main(tmp5gnaittc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = min(number +\
    \ remaining, need)\n        List(eaten, remaining - (eaten - number))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa5h14qa6.scala:27)\n\tat Problem.main(tmpa5h14qa6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = min(number +\
    \ remaining, need)\n        val left = max(0, number + remaining - need)\n   \
    \     List(eaten, left)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk6m4bbzk.scala:28)\n\tat Problem.main(tmpk6m4bbzk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // your code here\n    \
    \    List(number, remaining)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgwpve91k.scala:27)\n\tat Problem.main(tmpgwpve91k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) List(number + remaining, 0)\n        else List(number + need, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gnaittc.scala:32)\n\tat Problem.main(tmp5gnaittc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) List(number + remaining, 0)\n        else List(number + need, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gnaittc.scala:32)\n\tat Problem.main(tmp5gnaittc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // your code here\n    \
    \    val total = number + min(need, remaining)\n        List(total, max(0, remaining\
    \ - need))\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = min(number +\
    \ remaining, need)\n        List(eaten, need - eaten)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxrfuahrp.scala:27)\n\tat Problem.main(tmpxrfuahrp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var result = List[Long]()\n\
    \        if (remaining < need) {\n            result = List(number + remaining,\
    \ 0)\n        } else {\n            result = List(number + need, remaining - need)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var total = number + min(need,\
    \ remaining)\n        var left = max(remaining - need, 0)\n        List(total,\
    \ left)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var total = number + min(need,\
    \ remaining)\n        var left = max(remaining - need, 0)\n        List(total,\
    \ left)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var result = List[Long]()\n\
    \        if (remaining >= need) {\n            result = List(number + need, remaining\
    \ - need)\n        } else {\n            result = List(number + remaining, 0)\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) {\n            List(number + remaining, 0)\n        } else {\n       \
    \     List(need, number + remaining - need)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1e5cwtza.scala:30)\n\tat Problem.main(tmp1e5cwtza.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = min(number +\
    \ remaining, need)\n        val left = max(0, remaining - (need - number))\n \
    \       List(eaten, left)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpob99mmym.scala:28)\n\tat Problem.main(tmpob99mmym.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eat = min(need, remaining)\n\
    \        List(number + eat, remaining - eat)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var total = number + min(need,\
    \ remaining)\n        var left = max(remaining - need, 0)\n        List(total,\
    \ left)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) {\n            List(number + remaining, 0)\n        } else {\n       \
    \     List(need, number + remaining - need)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1e5cwtza.scala:30)\n\tat Problem.main(tmp1e5cwtza.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, max(remaining - need, 0))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, max(remaining - need, 0))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // your code here\n    \
    \    List(number + min(need, remaining), max(0, remaining - need))\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) List(number + remaining, 0)\n        else List(number + need, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gnaittc.scala:32)\n\tat Problem.main(tmp5gnaittc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining >= need) {\n\
    \            List(number + need, remaining - need)\n        } else {\n       \
    \     List(number + remaining, 0)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var total = number\n   \
    \     if (remaining >= need) {\n            total += need\n            return\
    \ List(total, remaining - need)\n        }\n        else {\n            total\
    \ += remaining\n            return List(total, 0)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var total = number + min(need,\
    \ remaining)\n        var left = max(remaining - need, 0)\n        List(total,\
    \ left)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var result = List[Long]()\n\
    \        if (remaining >= need) {\n            result = List(number + need, remaining\
    \ - need)\n        } else {\n            result = List(number + remaining, 0)\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) List(number + remaining, 0)\n        else List(number + need, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gnaittc.scala:32)\n\tat Problem.main(tmp5gnaittc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var eaten = number\n   \
    \     var left = remaining\n        if (need > left) {\n            eaten += left\n\
    \            left = 0\n        } else {\n            eaten += need\n         \
    \   left -= need\n        }\n        List(eaten, left)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var result = List[Long]()\n\
    \        if (remaining < need) {\n            result = List(number + remaining,\
    \ 0)\n        } else {\n            result = List(number + need, remaining - need)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var eaten = number\n   \
    \     var left = remaining\n        if (need > left) {\n            eaten += left\n\
    \            left = 0\n        } else {\n            eaten += need\n         \
    \   left -= need\n        }\n        List(eaten, left)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) List(number + remaining, 0)\n        else List(number + need, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gnaittc.scala:32)\n\tat Problem.main(tmp5gnaittc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + need > remaining)\
    \ List(remaining, 0)\n        else List(number + need, remaining - (number + need))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvdcbvsn9.scala:27)\n\tat Problem.main(tmpvdcbvsn9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number >= need) return\
    \ List(number, remaining)\n        else if (remaining >= need - number) return\
    \ List(need, remaining - (need - number))\n        else return List(remaining\
    \ + number, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_krfio46.scala:28)\n\tat Problem.main(tmp_krfio46.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + need <= remaining)\
    \ List(number + need, remaining - (number + need))\n        else List(remaining\
    \ + number, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq46qoqfa.scala:27)\n\tat Problem.main(tmpq46qoqfa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var result = List[Long]()\n\
    \        if (remaining >= need) {\n            result = List(number + need, remaining\
    \ - need)\n        } else {\n            result = List(number + remaining, 0)\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // your code here\n    \
    \    List(0, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp48y3d3mw.scala:27)\n\tat Problem.main(tmp48y3d3mw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var total = number\n   \
    \     var left = remaining\n        if (need > left) {\n            total += left\n\
    \            left = 0\n        } else {\n            total += need\n         \
    \   left -= need\n        }\n        List(total, left)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining >= need) List(number\
    \ + need, remaining - need)\n        else List(number + remaining, 0)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) List(number + remaining, 0)\n        else List(number + need, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gnaittc.scala:32)\n\tat Problem.main(tmp5gnaittc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var total = number + min(need,\
    \ remaining)\n        var left = max(remaining - need, 0)\n        List(total,\
    \ left)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) List(number + remaining, 0)\n        else List(number + need, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gnaittc.scala:32)\n\tat Problem.main(tmp5gnaittc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var eaten = number\n   \
    \     var left = remaining\n        if (left + eaten >= need) {\n            eaten\
    \ += need\n            left -= need\n        } else {\n            eaten += left\n\
    \            left = 0\n        }\n        List(eaten, left)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm29mooof.scala:40)\n\tat Problem.main(tmpm29mooof.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var eaten = number\n   \
    \     var left = remaining\n        if (need <= left) {\n            eaten +=\
    \ need\n            left -= need\n        } else {\n            eaten += left\n\
    \            left = 0\n        }\n        List(eaten, left)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // your code here\n    \
    \    val total = number + min(need, remaining)\n        List(total, remaining\
    \ - min(need, remaining))\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // your code here\n    \
    \    val total = number + remaining\n        val eaten = min(total, need)\n  \
    \      val left = total - eaten\n        List(eaten, left)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg4z827lm.scala:30)\n\tat Problem.main(tmpg4z827lm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, max(remaining - need, 0))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var result = List[Long]()\n\
    \        if (remaining < need) {\n            result = List(number + remaining,\
    \ 0)\n        } else {\n            result = List(number + need, remaining - need)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // Your code here\n    \
    \    List(number + min(need, remaining), max(0, remaining - need))\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + need <= remaining)\
    \ List(number + need, remaining - (number + need))\n        else List(remaining,\
    \ 0)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp38c33727.scala:27)\n\tat Problem.main(tmp38c33727.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, max(remaining - need, 0))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) List(number + remaining, 0)\n        else List(number + need, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gnaittc.scala:32)\n\tat Problem.main(tmp5gnaittc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) List(number\
    \ + remaining, 0)\n        else List(number + need, remaining - need)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = min(need, remaining)\n\
    \        List(number + eaten, remaining - eaten)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + remaining\n\
    \        val eaten = if (total < need) total else need\n        List(eaten, total\
    \ - eaten)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmrqsaovq.scala:28)\n\tat Problem.main(tmpmrqsaovq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var total = number\n   \
    \     var left = remaining\n        if (left < need) {\n            total += left\n\
    \            left = 0\n        } else {\n            total += need\n         \
    \   left -= need\n        }\n        List(total, left)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // your code here\n    \
    \    var total = number + remaining\n        var eaten = 0L\n        if (total\
    \ >= need) {\n            eaten = need\n            total -= need\n        } else\
    \ {\n            eaten = total\n            total = 0\n        }\n        List(eaten,\
    \ total)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp967feac2.scala:36)\n\tat Problem.main(tmp967feac2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + need <= remaining)\
    \ {\n            List(number + need, remaining - (number + need))\n        } else\
    \ {\n            List(remaining, 0)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa18sdb6s.scala:30)\n\tat Problem.main(tmpa18sdb6s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, max(remaining - need, 0))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var eaten = number\n   \
    \     if (need > remaining) {\n            eaten += remaining\n        } else\
    \ {\n            eaten += need\n        }\n        return List(eaten, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfzdo_ud2.scala:35)\n\tat Problem.main(tmpfzdo_ud2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) {\n            List(number + remaining, 0)\n        } else {\n       \
    \     List(need, number + remaining - need)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1e5cwtza.scala:30)\n\tat Problem.main(tmp1e5cwtza.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + need <= remaining)\
    \ List(number + need, remaining - (number + need))\n        else List(remaining,\
    \ 0)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp38c33727.scala:27)\n\tat Problem.main(tmp38c33727.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = min(need, remaining)\n\
    \        List(number + eaten, remaining - eaten)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) List(number + remaining, 0)\n        else List(number + need, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gnaittc.scala:32)\n\tat Problem.main(tmp5gnaittc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var result = List[Long]()\n\
    \        if (remaining < need) {\n            result = List(number + remaining,\
    \ 0)\n        } else {\n            result = List(number + need, remaining - need)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + need <= remaining)\
    \ List(number + need, remaining - (number + need))\n        else List(remaining,\
    \ 0)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp38c33727.scala:27)\n\tat Problem.main(tmp38c33727.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) List(number + remaining, 0)\n        else List(number + need, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gnaittc.scala:32)\n\tat Problem.main(tmp5gnaittc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        // your code here\n    \
    \    if (remaining < need) {\n            List(number + remaining, 0)\n      \
    \  } else {\n            List(number + need, remaining - need)\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) {\n            List(number + remaining, 0)\n        } else {\n       \
    \     List(need, number + remaining - need)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1e5cwtza.scala:30)\n\tat Problem.main(tmp1e5cwtza.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining >= need) List(number\
    \ + need, remaining - need)\n        else List(number + remaining, 0)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var total = number + min(need,\
    \ remaining)\n        var left = max(remaining - need, 0)\n        List(total,\
    \ left)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + need <= remaining)\
    \ List(number + need, remaining - (number + need))\n        else List(remaining\
    \ + number, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq46qoqfa.scala:27)\n\tat Problem.main(tmpq46qoqfa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining < need) {\n\
    \            List(number + remaining, 0)\n        } else {\n            List(number\
    \ + need, remaining - need)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        val left = max(remaining - need, 0)\n        List(total,\
    \ left)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, max(remaining - need, 0))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (remaining >= need) List(number\
    \ + need, remaining - need)\n        else List(number + remaining, 0)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var result = List[Long]()\n\
    \        if (remaining >= need) {\n            result = List(number + need, remaining\
    \ - need)\n        } else {\n            result = List(number + remaining, 0)\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var eaten = number\n   \
    \     var left = remaining\n        if (need > left) {\n            eaten += left\n\
    \            left = 0\n        } else {\n            eaten += need\n         \
    \   left -= need\n        }\n        List(eaten, left)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        var result = List[Long]()\n\
    \        if (remaining >= need) {\n            result = List(number + need, remaining\
    \ - need)\n        } else {\n            result = List(number + remaining, 0)\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        if (number + remaining <\
    \ need) List(number + remaining, 0)\n        else List(number + need, remaining\
    \ - need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gnaittc.scala:32)\n\tat Problem.main(tmp5gnaittc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val total = number + min(need,\
    \ remaining)\n        List(total, remaining - min(need, remaining))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009964
