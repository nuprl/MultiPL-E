name: HumanEval_69_search
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a non-empty list of positive integers. Return the greatest\
  \ integer that is greater than \n    // zero, and has a frequency greater than or\
  \ equal to the value of the integer itself. \n    // The frequency of an integer\
  \ is the number of times it appears in the list.\n    // If no such a value exist,\
  \ return -1.\n    // Examples:\n    def search(lst : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(search((List[Long](5l.toLong,\
  \ 5l.toLong, 5l.toLong, 5l.toLong, 1l.toLong))) == (1l));\n    assert(search((List[Long](4l.toLong,\
  \ 1l.toLong, 4l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](3l.toLong,\
  \ 3l.toLong))) == (-1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 8l.toLong,\
  \ 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong))) == (8l));\n    assert(search((List[Long](2l.toLong,\
  \ 3l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](2l.toLong,\
  \ 7l.toLong, 8l.toLong, 8l.toLong, 4l.toLong, 8l.toLong, 7l.toLong, 3l.toLong, 9l.toLong,\
  \ 6l.toLong, 5l.toLong, 10l.toLong, 4l.toLong, 3l.toLong, 6l.toLong, 7l.toLong,\
  \ 1l.toLong, 7l.toLong, 4l.toLong, 10l.toLong, 8l.toLong, 1l.toLong))) == (1l));\n\
  \    assert(search((List[Long](3l.toLong, 2l.toLong, 8l.toLong, 2l.toLong))) ==\
  \ (2l));\n    assert(search((List[Long](6l.toLong, 7l.toLong, 1l.toLong, 8l.toLong,\
  \ 8l.toLong, 10l.toLong, 5l.toLong, 8l.toLong, 5l.toLong, 3l.toLong, 10l.toLong)))\
  \ == (1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 3l.toLong, 6l.toLong,\
  \ 5l.toLong, 6l.toLong, 4l.toLong))) == (-1l));\n    assert(search((List[Long](6l.toLong,\
  \ 9l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 4l.toLong, 7l.toLong, 1l.toLong, 8l.toLong,\
  \ 8l.toLong, 9l.toLong, 8l.toLong, 10l.toLong, 10l.toLong, 8l.toLong, 4l.toLong,\
  \ 10l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong,\
  \ 7l.toLong, 9l.toLong))) == (1l));\n    assert(search((List[Long](1l.toLong, 9l.toLong,\
  \ 10l.toLong, 1l.toLong, 3l.toLong))) == (1l));\n    assert(search((List[Long](6l.toLong,\
  \ 9l.toLong, 7l.toLong, 5l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 3l.toLong, 7l.toLong,\
  \ 5l.toLong, 10l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 10l.toLong, 2l.toLong,\
  \ 8l.toLong, 6l.toLong, 5l.toLong, 4l.toLong, 9l.toLong, 5l.toLong, 3l.toLong, 10l.toLong)))\
  \ == (5l));\n    assert(search((List[Long](1l.toLong))) == (1l));\n    assert(search((List[Long](8l.toLong,\
  \ 8l.toLong, 10l.toLong, 6l.toLong, 4l.toLong, 3l.toLong, 5l.toLong, 8l.toLong,\
  \ 2l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 6l.toLong, 10l.toLong,\
  \ 4l.toLong, 2l.toLong, 1l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
  \ 5l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong, 10l.toLong, 4l.toLong,\
  \ 8l.toLong, 2l.toLong, 10l.toLong, 5l.toLong, 1l.toLong, 2l.toLong, 9l.toLong,\
  \ 5l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 8l.toLong, 6l.toLong, 4l.toLong, 10l.toLong)))\
  \ == (2l));\n    assert(search((List[Long](1l.toLong, 6l.toLong, 10l.toLong, 1l.toLong,\
  \ 6l.toLong, 9l.toLong, 10l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 7l.toLong,\
  \ 3l.toLong))) == (1l));\n    assert(search((List[Long](9l.toLong, 2l.toLong, 4l.toLong,\
  \ 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 2l.toLong, 5l.toLong, 7l.toLong, 7l.toLong,\
  \ 7l.toLong, 3l.toLong, 10l.toLong, 1l.toLong, 5l.toLong, 4l.toLong, 2l.toLong,\
  \ 8l.toLong, 4l.toLong, 1l.toLong, 9l.toLong, 10l.toLong, 7l.toLong, 10l.toLong,\
  \ 2l.toLong, 8l.toLong, 10l.toLong, 9l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong,\
  \ 6l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 4l.toLong,\
  \ 10l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 7l.toLong, 8l.toLong, 8l.toLong,\
  \ 3l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 2l.toLong, 10l.toLong, 7l.toLong)))\
  \ == (4l));\n    assert(search((List[Long](9l.toLong, 8l.toLong, 6l.toLong, 10l.toLong,\
  \ 2l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 7l.toLong, 8l.toLong, 10l.toLong,\
  \ 3l.toLong, 8l.toLong, 2l.toLong, 6l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))\
  \ == (2l));\n    assert(search((List[Long](5l.toLong, 5l.toLong, 3l.toLong, 9l.toLong,\
  \ 5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 5l.toLong, 6l.toLong, 10l.toLong,\
  \ 10l.toLong, 6l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 7l.toLong, 7l.toLong,\
  \ 10l.toLong, 8l.toLong))) == (-1l));\n    assert(search((List[Long](10l.toLong)))\
  \ == (-1l));\n    assert(search((List[Long](9l.toLong, 7l.toLong, 7l.toLong, 2l.toLong,\
  \ 4l.toLong, 7l.toLong, 2l.toLong, 10l.toLong, 9l.toLong, 7l.toLong, 5l.toLong,\
  \ 7l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](5l.toLong, 4l.toLong,\
  \ 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 3l.toLong, 6l.toLong,\
  \ 1l.toLong, 8l.toLong))) == (1l));\n    assert(search((List[Long](7l.toLong, 9l.toLong,\
  \ 9l.toLong, 9l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 1l.toLong,\
  \ 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 7l.toLong, 5l.toLong, 6l.toLong,\
  \ 7l.toLong, 6l.toLong, 7l.toLong, 7l.toLong, 6l.toLong))) == (1l));\n    assert(search((List[Long](3l.toLong,\
  \ 10l.toLong, 10l.toLong, 9l.toLong, 2l.toLong))) == (-1l));\n    }\n\n}\n"
completions: ["        val freq = new HashMap[Long, Long]\n        for (i <- lst)\
    \ {\n            if (freq.contains(i)) freq(i) += 1\n            else freq +=\
    \ (i -> 1)\n        }\n        var result = -1L\n        for (i <- lst) {\n  \
    \          if (freq(i) >= i && i > result) result = i\n        }\n        result",
  "        val map = new HashMap[Long, Long]()\n        for (i <- lst) {\n       \
    \     if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n\
    \        var max = -1L\n        for (i <- map.keys) {\n            if (i <= map(i)\
    \ && i > max) max = i\n        }\n        max", "        val m = lst.groupBy(x\
    \ => x).mapValues(_.size)\n        val k = m.keys.toList.sorted\n        val v\
    \ = m.values.toList.sorted\n        val n = k.length\n        for (i <- 0 until\
    \ n) {\n            if (k(i) <= v(i)) return k(i)\n        }\n        return -1",
  "        val counts = lst.groupBy(x => x).mapValues(_.size)\n        val max = counts.keys.max\n\
    \        if (counts(max) >= max) max else -1", "        val m = lst.groupBy(identity).mapValues(_.size)\n\
    \        val v = m.filter(x => x._1 <= x._2).keys.toList.sorted\n        if (v.isEmpty)\
    \ -1 else v.last", "        val freq = new HashMap[Long, Long]\n        for (i\
    \ <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n            else\
    \ freq(i) = 1\n        }\n        var max = -1\n        for (i <- freq.keys) {\n\
    \            if (freq(i) >= i && i > max) max = i.toInt\n        }\n        max",
  "        val freq = new HashMap[Long, Long]\n        for (i <- lst) {\n        \
    \    if (freq.contains(i)) freq(i) += 1\n            else freq(i) = 1\n      \
    \  }\n        for (i <- lst.sorted.reverse) {\n            if (freq(i) >= i) return\
    \ i\n        }\n        return -1", "        val freq = new HashMap[Long, Long]\n\
    \        for (x <- lst) {\n            if (freq.contains(x)) freq(x) += 1\n  \
    \          else freq(x) = 1\n        }\n        var max = -1\n        for (x <-\
    \ freq.keys) {\n            if (freq(x) >= x && x > max) max = x.toInt\n     \
    \   }\n        max", "        val m = lst.groupBy(x => x).mapValues(_.size)\n\
    \        val max = m.keys.max\n        if (m(max) >= max) max else -1", "    \
    \    val m = lst.groupBy(x => x).mapValues(_.size)\n        val max = m.keys.max\n\
    \        if (m(max) >= max) max else -1", "        val freq = new HashMap[Long,\
    \ Long]\n        for (i <- lst) {\n            if (freq.contains(i)) freq(i) +=\
    \ 1\n            else freq(i) = 1\n        }\n        var max = -1\n        for\
    \ (i <- lst) {\n            if (freq(i) >= i && i > max) max = i.toInt\n     \
    \   }\n        max", "        val freq = new HashMap[Long, Long]()\n        for\
    \ (x <- lst) {\n            if (freq.contains(x)) freq(x) += 1\n            else\
    \ freq(x) = 1\n        }\n        var max = -1\n        for (x <- freq.keys) {\n\
    \            if (freq(x) >= x && x > max) max = x.toInt\n        }\n        max",
  "        val sorted = lst.sorted\n        val map = new HashMap[Long, Long]\n  \
    \      for (i <- 0 until sorted.length) {\n            if (map.contains(sorted(i)))\
    \ map(sorted(i)) += 1\n            else map(sorted(i)) = 1\n        }\n      \
    \  for (i <- sorted.length - 1 to 0 by -1) {\n            if (map(sorted(i)) >=\
    \ sorted(i)) return sorted(i)\n        }\n        return -1", "        val m =\
    \ lst.groupBy(x => x).map(x => (x._1, x._2.length)).toList.sortBy(x => x._1)\n\
    \        var i = 0\n        while (i < m.length && m(i)._1 <= m(i)._2) i += 1\n\
    \        if (i == m.length) -1 else m(i)._1", "        val m = lst.groupBy(x =>\
    \ x).mapValues(_.size)\n        val max = lst.max\n        for (i <- max to 1\
    \ by -1) {\n            if (m.contains(i) && m(i) >= i) return i\n        }\n\
    \        return -1", "        val freq = new HashMap[Long, Long]()\n        for\
    \ (i <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n            else\
    \ freq(i) = 1\n        }\n        var max = -1\n        for (i <- freq.keys) {\n\
    \            if (freq(i) >= i && i > max) max = i.toInt\n        }\n        max",
  "        var map = Map[Long, Long]()\n        for (i <- lst) {\n            if (map.contains(i))\
    \ map(i) += 1\n            else map(i) = 1\n        }\n        var max = -1L\n\
    \        for (i <- map.keys) {\n            if (i <= map(i) && i > max) max =\
    \ i\n        }\n        return max", "        val freq = new HashMap[Long, Long]\n\
    \        for (i <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n  \
    \          else freq(i) = 1\n        }\n        var max = -1L\n        for (i\
    \ <- freq.keys) {\n            if (freq(i) >= i && i > max) max = i\n        }\n\
    \        max", "        val freq = new HashMap[Long, Long]()\n        for (i <-\
    \ lst) {\n            if (freq.contains(i)) freq(i) += 1\n            else freq(i)\
    \ = 1\n        }\n        var result = -1L\n        for (i <- freq.keys) {\n \
    \           if (i <= freq(i) && i > result) result = i\n        }\n        result",
  "        val map = new HashMap[Long, Long]\n        for (i <- lst) {\n         \
    \   if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n\
    \        var max = -1\n        for (i <- lst) {\n            if (map(i) >= i &&\
    \ i > max) max = i.toInt\n        }\n        max", "        val freq = new HashMap[Long,\
    \ Long]\n        for (i <- lst) {\n            if (freq.contains(i)) freq(i) +=\
    \ 1\n            else freq(i) = 1\n        }\n        var max = -1\n        for\
    \ (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max = i.toInt\n\
    \        }\n        max", "        val counts = lst.groupBy(identity).mapValues(_.size)\n\
    \        val max = counts.keys.max\n        if (counts(max) >= max) max else -1",
  "        val map = new HashMap[Long, Long]()\n        for (x <- lst) {\n       \
    \     if (map.contains(x)) map(x) += 1\n            else map(x) = 1\n        }\n\
    \        var result = -1\n        for (x <- lst) {\n            if (map(x) >=\
    \ x && x > result) result = x\n        }\n        result", "        val freq =\
    \ new HashMap[Long, Long]\n        for (i <- lst) {\n            if (freq.contains(i))\
    \ freq(i) += 1\n            else freq(i) = 1\n        }\n        var max = -1L\n\
    \        for (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max\
    \ = i\n        }\n        max", "        val freq = new HashMap[Long, Long]()\n\
    \        for (i <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n  \
    \          else freq(i) = 1\n        }\n        var max = -1\n        for (i <-\
    \ freq.keys) {\n            if (freq(i) >= i && i > max) max = i.toInt\n     \
    \   }\n        max", "        val m = lst.groupBy(identity).mapValues(_.size).toList.sortBy(_._1)\n\
    \        val n = m.filter(x => x._1 <= x._2).map(_._1).max\n        if (n == 0)\
    \ -1 else n", "        val map = new HashMap[Long, Long]()\n        for (i <-\
    \ lst) {\n            if (map.contains(i)) map(i) += 1\n            else map(i)\
    \ = 1\n        }\n        var result = -1L\n        for (i <- lst) {\n       \
    \     if (map(i) >= i && i > result) result = i\n        }\n        result", " \
    \       val map = new HashMap[Long, Long]\n        for (x <- lst) {\n        \
    \    if (map.contains(x)) map(x) += 1 else map(x) = 1\n        }\n        var\
    \ max = -1L\n        for (x <- map.keys) {\n            if (x > 0 && map(x) >=\
    \ x && x > max) max = x\n        }\n        max", "        val map = new HashMap[Long,\
    \ Long]()\n        for (i <- lst) {\n            if (map.contains(i)) map(i) +=\
    \ 1\n            else map(i) = 1\n        }\n        var max = -1L\n        for\
    \ (i <- lst) {\n            if (map(i) >= i && i > max) max = i\n        }\n \
    \       max", "        val freq = new HashMap[Long, Long]()\n        for (i <-\
    \ lst) {\n            if (freq.contains(i)) freq(i) += 1\n            else freq(i)\
    \ = 1\n        }\n        var max = -1\n        for (i <- freq.keys) {\n     \
    \       if (freq(i) >= i && i > max) max = i.toInt\n        }\n        max", " \
    \       val freq = new HashMap[Long, Long]()\n        for (i <- lst) {\n     \
    \       if (freq.contains(i)) freq(i) += 1\n            else freq(i) = 1\n   \
    \     }\n        var result = -1L\n        for (i <- lst) {\n            if (freq(i)\
    \ >= i && i > result) result = i\n        }\n        result", "        val freq\
    \ = new HashMap[Long, Long]\n        for (i <- lst) {\n            if (freq.contains(i))\
    \ freq(i) += 1\n            else freq(i) = 1\n        }\n        var max = -1\n\
    \        for (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max\
    \ = i.toInt\n        }\n        max", "        val freq = new HashMap[Long, Long]\n\
    \        for (x <- lst) freq(x) = freq.getOrElse(x, 0) + 1\n        val sorted\
    \ = freq.toList.sortBy(_._1)\n        for (x <- sorted) {\n            if (x._1\
    \ <= x._2) return x._1\n        }\n        -1", "        val freq = new HashMap[Long,\
    \ Long]\n        for (i <- lst) {\n            if (freq.contains(i)) freq(i) +=\
    \ 1\n            else freq(i) = 1\n        }\n        var result = -1L\n     \
    \   for (i <- freq.keys) {\n            if (i <= freq(i) && i > result) result\
    \ = i\n        }\n        result", "        val freq = new HashMap[Long, Long]()\n\
    \        for (i <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n  \
    \          else freq(i) = 1\n        }\n        var max = -1\n        for (i <-\
    \ freq.keys) {\n            if (freq(i) >= i && i > max) max = i.toInt\n     \
    \   }\n        max", "        val freq = lst.groupBy(identity).mapValues(_.size)\n\
    \        val max = freq.keys.max\n        if (freq(max) >= max) max else -1",
  "        val freq = new HashMap[Long, Long]\n        for (x <- lst) {\n        \
    \    if (freq.contains(x)) freq(x) += 1\n            else freq(x) = 1\n      \
    \  }\n        var result = -1L\n        for (x <- freq.keys) {\n            if\
    \ (x <= freq(x) && x > result) result = x\n        }\n        result", "     \
    \   val freq = new HashMap[Long, Long]\n        for (i <- lst) {\n           \
    \ if (freq.contains(i)) freq(i) += 1\n            else freq(i) = 1\n        }\n\
    \        var max = -1L\n        for (i <- freq.keys) {\n            if (freq(i)\
    \ >= i && i > max) max = i\n        }\n        max", "        val m = lst.groupBy(identity).mapValues(_.size).toList.sortBy(_._1)\n\
    \        val m2 = m.filter(x => x._1 <= x._2)\n        if (m2.isEmpty) -1 else\
    \ m2.last._1", "        val freq = new HashMap[Long, Long]\n        for (i <-\
    \ lst) {\n            if (freq.contains(i)) freq(i) += 1\n            else freq(i)\
    \ = 1\n        }\n        var max = -1\n        for (i <- freq.keys) {\n     \
    \       if (freq(i) >= i && i > max) max = i.toInt\n        }\n        max", " \
    \       val map = new HashMap[Long, Long]\n        for (i <- lst) {\n        \
    \    if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n\
    \        var max = -1\n        for (i <- lst) {\n            if (map(i) >= i &&\
    \ i > max) max = i.toInt\n        }\n        max", "        val m = lst.groupBy(x\
    \ => x).mapValues(_.size)\n        val max = m.keys.max\n        if (m(max) >=\
    \ max) max else -1", "        val freq = new HashMap[Long, Long]\n        for\
    \ (i <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n            else\
    \ freq(i) = 1\n        }\n        var max = -1L\n        for (i <- lst) {\n  \
    \          if (freq(i) >= i && i > max) max = i\n        }\n        max", "  \
    \      val freq = lst.groupBy(x => x).map(x => (x._1, x._2.length))\n        val\
    \ max = freq.maxBy(x => x._1)\n        if (max._2 >= max._1) max._1 else -1",
  "        val m = new HashMap[Long, Long]\n        for (i <- lst) {\n           \
    \ if (m.contains(i)) m(i) += 1\n            else m(i) = 1\n        }\n       \
    \ var max = -1L\n        for (i <- m.keys) {\n            if (i <= m(i) && i >\
    \ max) max = i\n        }\n        max", "        val freq = new HashMap[Long,\
    \ Long]()\n        for (i <- lst) {\n            if (freq.contains(i)) freq(i)\
    \ += 1\n            else freq(i) = 1\n        }\n        var max = -1\n      \
    \  for (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max = i.toInt\n\
    \        }\n        max", "        val freq = new HashMap[Long, Long]\n      \
    \  for (i <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n        \
    \    else freq(i) = 1\n        }\n        val keys = freq.keys.toList.sorted\n\
    \        for (i <- keys.length - 1 to 0 by -1) {\n            if (freq(keys(i))\
    \ >= keys(i)) return keys(i)\n        }\n        return -1", "        val map\
    \ = new HashMap[Long, Long]()\n        for (i <- lst) {\n            if (map.contains(i))\
    \ map(i) += 1\n            else map(i) = 1\n        }\n        var max = -1\n\
    \        for (i <- lst) {\n            if (map(i) >= i && i > max) max = i.toInt\n\
    \        }\n        max", "        val freq = new HashMap[Long, Long]\n      \
    \  for (i <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n        \
    \    else freq(i) = 1\n        }\n        var max = -1L\n        for (i <- freq.keys)\
    \ {\n            if (freq(i) >= i && i > max) max = i\n        }\n        max",
  "        val freq = new HashMap[Long, Long]\n        for (i <- lst) {\n        \
    \    if (freq.contains(i)) freq(i) += 1 else freq(i) = 1\n        }\n        var\
    \ result = -1L\n        for (i <- lst) {\n            if (freq(i) >= i && i >\
    \ result) result = i\n        }\n        result", "        val m = lst.groupBy(identity).mapValues(_.size)\n\
    \        val max = m.keys.max\n        if (m(max) >= max) max else -1", "    \
    \    val freq = new HashMap[Long, Long]\n        for (i <- lst) {\n          \
    \  if (freq.contains(i)) freq(i) += 1\n            else freq(i) = 1\n        }\n\
    \        val sorted = freq.toList.sortWith((a, b) => a._1 < b._1)\n        for\
    \ (i <- sorted) {\n            if (i._1 <= i._2) return i._1\n        }\n    \
    \    return -1", "        val freq = new HashMap[Long, Long]()\n        for (i\
    \ <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n            else\
    \ freq(i) = 1\n        }\n        var result = -1\n        for (i <- lst) {\n\
    \            if (freq(i) >= i && i > result) result = i\n        }\n        result",
  "        val freq = new HashMap[Long, Long]()\n        for (e <- lst) {\n      \
    \      if (freq.contains(e)) freq(e) += 1\n            else freq(e) = 1\n    \
    \    }\n        var result = -1L\n        for (e <- freq.keys) {\n           \
    \ if (e <= freq(e) && e > result) result = e\n        }\n        result", "  \
    \      val m = lst.groupBy(identity).mapValues(_.size)\n        val keys = m.keys.toList.sorted\n\
    \        for (i <- keys) {\n            if (m(i) >= i) return i\n        }\n \
    \       return -1", "        val freq = new HashMap[Long, Long]\n        for (i\
    \ <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n            else\
    \ freq(i) = 1\n        }\n        var max = -1\n        for (i <- lst) {\n   \
    \         if (freq(i) >= i && i > max) max = i.toInt\n        }\n        max",
  "        val m = lst.groupBy(identity).mapValues(_.size)\n        val max = m.keys.max\n\
    \        if (m(max) >= max) max else -1", "        val m = lst.groupBy(x => x).mapValues(_.size)\n\
    \        val max = m.keys.max\n        if (m(max) >= max) max else -1", "    \
    \    val freq = lst.groupBy(identity).mapValues(_.size).toList.sortBy(_._1)\n\
    \        val max = freq.map(_._1).max\n        val maxFreq = freq.filter(_._1\
    \ == max).head._2\n        if (maxFreq >= max) max else -1", "        val freq\
    \ = new HashMap[Long, Long]\n        for (i <- lst) {\n            if (freq.contains(i))\
    \ freq(i) += 1\n            else freq(i) = 1\n        }\n        var max = -1L\n\
    \        for (i <- lst) {\n            if (freq(i) >= i && i > max) max = i\n\
    \        }\n        max", "        val m = lst.groupBy(x => x).mapValues(_.size)\n\
    \        val keys = m.keys.toList.sorted\n        val values = m.values.toList.sorted\n\
    \        val max = keys.max\n        if (values.last < max) -1 else max", "  \
    \      val m = lst.groupBy(x => x).mapValues(_.size)\n        val l = m.keys.toList.sorted\n\
    \        for (i <- l.size - 1 to 0 by -1) {\n            if (m(l(i)) >= l(i))\
    \ return l(i)\n        }\n        return -1", "        val freq = new HashMap[Long,\
    \ Long]\n        for (i <- lst) {\n            if (freq.contains(i)) freq(i) +=\
    \ 1\n            else freq(i) = 1\n        }\n        var max = -1\n        for\
    \ (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max = i.toInt\n\
    \        }\n        max", "        val m = lst.groupBy(x => x).mapValues(_.size)\n\
    \        val max = lst.max\n        for (i <- max to 1 by -1) {\n            if\
    \ (m.contains(i) && m(i) >= i) return i\n        }\n        return -1", "    \
    \    val map = new HashMap[Long, Long]()\n        for (i <- lst) {\n         \
    \   if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n\
    \        var max = -1\n        for (i <- map.keys) {\n            if (i <= map(i)\
    \ && i > max) max = i.toInt\n        }\n        max", "        val m = new HashMap[Long,\
    \ Long]\n        for (i <- lst) {\n            if (m.contains(i)) m(i) += 1\n\
    \            else m(i) = 1\n        }\n        var max = -1L\n        for (i <-\
    \ m.keys) {\n            if (i <= m(i) && i > max) max = i\n        }\n      \
    \  max", "        val freq = new HashMap[Long, Long]\n        for (i <- lst) {\n\
    \            if (freq.contains(i)) freq(i) += 1\n            else freq(i) = 1\n\
    \        }\n        val keys = freq.keys.toList.sorted\n        for (i <- keys)\
    \ {\n            if (i <= freq(i)) return i\n        }\n        -1", "       \
    \ val freq = new HashMap[Long, Long]\n        for (i <- lst) {\n            if\
    \ (freq.contains(i)) freq(i) += 1\n            else freq(i) = 1\n        }\n \
    \       var max = -1\n        for (i <- freq.keys) {\n            if (freq(i)\
    \ >= i && i > max) max = i.toInt\n        }\n        max", "        val m = lst.groupBy(identity).mapValues(_.size)\n\
    \        val l = m.keys.toList.sorted\n        val r = l.filter(x => m(x) >= x)\n\
    \        if (r.isEmpty) -1 else r.last", "        val map = new HashMap[Long,\
    \ Long]\n        for (i <- lst) {\n            if (map.contains(i)) map(i) +=\
    \ 1\n            else map(i) = 1\n        }\n        var max = -1L\n        for\
    \ (i <- map.keys) {\n            if (i <= map(i) && i > max) max = i\n       \
    \ }\n        max", "        val map = new HashMap[Long, Long]\n        for (x\
    \ <- lst) {\n            if (map.contains(x)) map(x) += 1\n            else map(x)\
    \ = 1\n        }\n        var max = -1\n        for (x <- map.keys) {\n      \
    \      if (x <= map(x) && x > max) max = x.toInt\n        }\n        max", " \
    \       val freq = new HashMap[Long, Long]\n        for (i <- lst) {\n       \
    \     if (freq.contains(i)) freq(i) += 1\n            else freq(i) = 1\n     \
    \   }\n        var max = -1\n        for (i <- freq.keys) {\n            if (freq(i)\
    \ >= i && i > max) max = i.toInt\n        }\n        max", "        val freq =\
    \ new HashMap[Long, Long]()\n        for (i <- lst) {\n            if (freq.contains(i))\
    \ freq(i) += 1\n            else freq(i) = 1\n        }\n        var max = -1\n\
    \        for (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max\
    \ = i.toInt\n        }\n        max", "        val freq = lst.groupBy(identity).mapValues(_.size)\n\
    \        val keys = freq.keys.toList.sorted\n        val values = freq.values.toList.sorted\n\
    \        val max = keys.max\n        val min = keys.min\n        val maxFreq =\
    \ values.max\n        val minFreq = values.min\n        if (maxFreq < max) -1\n\
    \        else if (minFreq > min) min\n        else {\n            var i = max\
    \ - 1\n            while (i >= min) {\n                if (freq(i) >= i) return\
    \ i\n                i -= 1\n            }\n            -1\n        }", "    \
    \    val map = new HashMap[Long, Long]()\n        for (i <- lst) {\n         \
    \   if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n\
    \        var max = -1\n        for (i <- lst) {\n            if (map(i) >= i &&\
    \ i > max) max = i.toInt\n        }\n        max", "        val freq = new HashMap[Long,\
    \ Long]()\n        for (i <- lst) {\n            if (freq.contains(i)) freq(i)\
    \ += 1\n            else freq(i) = 1\n        }\n        var result = -1L\n  \
    \      for (i <- freq.keys) {\n            if (i > 0 && freq(i) >= i && i > result)\
    \ result = i\n        }\n        result", "        val map = new HashMap[Long,\
    \ Long]\n        for (i <- lst) {\n            if (map.contains(i)) map(i) +=\
    \ 1\n            else map(i) = 1\n        }\n        var max = -1\n        for\
    \ (i <- map.keys) {\n            if (i <= map(i) && i > max) max = i.toInt\n \
    \       }\n        max", "        val m = lst.groupBy(x => x).mapValues(_.size)\n\
    \        val keys = m.keys.toList.sorted\n        val values = m.values.toList.sorted\n\
    \        val max = keys.max\n        val maxFreq = values.max\n        if (maxFreq\
    \ >= max) max else -1", "        val map = new HashMap[Long, Long]\n        for\
    \ (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n            else\
    \ map(i) = 1\n        }\n        var max = -1\n        for (i <- lst) {\n    \
    \        if (map(i) >= i && i > max) max = i.toInt\n        }\n        max", " \
    \       val m = lst.groupBy(x => x).mapValues(_.size)\n        val max = m.maxBy(_._1)\n\
    \        if (max._1 <= max._2) max._1 else -1", "        val freq = new HashMap[Long,\
    \ Long]\n        lst.foreach(x => freq(x) = freq.getOrElse(x, 0) + 1)\n      \
    \  val max = freq.maxBy(_._2)\n        if (max._1 <= max._2) max._1 else -1",
  "        val m = lst.groupBy(x => x).map(x => (x._1, x._2.length)).toList.sortBy(x\
    \ => x._1)\n        var i = 0\n        while (i < m.length) {\n            if\
    \ (m(i)._1 <= m(i)._2) return m(i)._1\n            i += 1\n        }\n       \
    \ return -1", "        val counts = lst.groupBy(identity).mapValues(_.size)\n\
    \        val max = counts.keys.max\n        val maxCount = counts(max)\n     \
    \   if (maxCount >= max) max else -1", "        val map = new HashMap[Long, Long]()\n\
    \        for (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n    \
    \        else map(i) = 1\n        }\n        var max = -1L\n        for (i <-\
    \ map.keys) {\n            if (i <= map(i) && i > max) max = i\n        }\n  \
    \      max", "        val freq = new HashMap[Long, Long]()\n        for (i <-\
    \ lst) {\n            if (freq.contains(i)) freq(i) += 1\n            else freq(i)\
    \ = 1\n        }\n        var max = -1L\n        for (i <- freq.keys) {\n    \
    \        if (freq(i) >= i && i > max) max = i\n        }\n        max", "    \
    \    val map = new HashMap[Long, Long]()\n        for (x <- lst) {\n         \
    \   if (map.contains(x)) map(x) += 1\n            else map(x) = 1\n        }\n\
    \        var max = -1L\n        for (x <- lst) {\n            if (map(x) >= x\
    \ && x > max) max = x\n        }\n        max", "        val freq = new HashMap[Long,\
    \ Long]()\n        for (i <- lst) {\n            if (freq.contains(i)) freq(i)\
    \ += 1\n            else freq += (i -> 1)\n        }\n        var ans = -1L\n\
    \        for (i <- freq.keys) {\n            if (i <= freq(i) && i > ans) ans\
    \ = i\n        }\n        ans", "        val freq = new HashMap[Long, Long]\n\
    \        for (i <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n  \
    \          else freq(i) = 1\n        }\n        val sorted = freq.toList.sortWith((a,\
    \ b) => a._1 < b._1)\n        var result = -1L\n        for (i <- sorted) {\n\
    \            if (i._1 <= i._2) result = i._1\n        }\n        result", "  \
    \      val freq = new HashMap[Long, Long]()\n        for (i <- lst) {\n      \
    \      if (freq.contains(i)) freq(i) += 1\n            else freq(i) = 1\n    \
    \    }\n        var max = -1L\n        for (i <- freq.keys) {\n            if\
    \ (freq(i) >= i && i > max) max = i\n        }\n        max", "        val map\
    \ = new HashMap[Long, Long]()\n        for (i <- lst) {\n            if (map.contains(i))\
    \ map(i) += 1\n            else map += (i -> 1)\n        }\n        var max =\
    \ -1\n        for (i <- map.keys) {\n            if (i <= map(i) && i > max) max\
    \ = i.toInt\n        }\n        max", "        val map = new HashMap[Long, Long]\n\
    \        for (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n    \
    \        else map(i) = 1\n        }\n        var max = -1L\n        for (i <-\
    \ lst) {\n            if (map(i) >= i && i > max) max = i\n        }\n       \
    \ max", "        val map = new HashMap[Long, Long]()\n        for (i <- lst) {\n\
    \            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n \
    \       }\n        var max = -1\n        for (i <- lst) {\n            if (map(i)\
    \ >= i && i > max) max = i.toInt\n        }\n        max", "        val m = new\
    \ HashMap[Long, Long]\n        for (i <- lst) {\n            if (m.contains(i))\
    \ m(i) += 1\n            else m(i) = 1\n        }\n        var max = -1L\n   \
    \     for (i <- lst) {\n            if (i > max && m(i) >= i) max = i\n      \
    \  }\n        max", "        val freq = new HashMap[Long, Long]\n        for (i\
    \ <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n            else\
    \ freq(i) = 1\n        }\n        var max = -1L\n        for (i <- freq.keys)\
    \ {\n            if (freq(i) >= i && i > max) max = i\n        }\n        max",
  "        val map = new HashMap[Long, Long]()\n        for (i <- lst) {\n       \
    \     if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n\
    \        var max = -1L\n        for (i <- map.keys) {\n            if (i <= map(i)\
    \ && i > max) max = i\n        }\n        max", "        val map = new HashMap[Long,\
    \ Long]()\n        for (i <- lst) {\n            if (map.contains(i)) map(i) +=\
    \ 1\n            else map(i) = 1\n        }\n        var max = -1\n        for\
    \ (i <- map.keys) {\n            if (i <= map(i) && i > max) max = i.toInt\n \
    \       }\n        max", "        val map = new HashMap[Long, Long]\n        for\
    \ (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n            else\
    \ map(i) = 1\n        }\n        var max = -1\n        for (i <- map.keys) {\n\
    \            if (i <= map(i) && i > max) max = i.toInt\n        }\n        max",
  "        val freq = new HashMap[Long, Long]()\n        for (i <- lst) {\n      \
    \      if (freq.contains(i)) freq(i) += 1\n            else freq(i) = 1\n    \
    \    }\n        var max = -1L\n        for (i <- freq.keys) {\n            if\
    \ (freq(i) >= i && i > max) max = i\n        }\n        max", "        val freq\
    \ = new HashMap[Long, Long]()\n        for (i <- lst) {\n            if (freq.contains(i))\
    \ freq(i) += 1\n            else freq(i) = 1\n        }\n        var max = -1\n\
    \        for (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max\
    \ = i.toInt\n        }\n        max", "        val map = new HashMap[Long, Long]\n\
    \        for (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n    \
    \        else map(i) = 1\n        }\n        var max = -1L\n        for (i <-\
    \ lst) {\n            if (map(i) >= i && i > max) max = i\n        }\n       \
    \ max", "        val freq = new HashMap[Long, Long]\n        for (i <- lst) {\n\
    \            if (freq.contains(i)) freq(i) += 1\n            else freq(i) = 1\n\
    \        }\n        var max = -1L\n        for (i <- lst) {\n            if (freq(i)\
    \ >= i && i > max) max = i\n        }\n        max", "        val m = lst.groupBy(identity).mapValues(_.size)\n\
    \        val k = m.keys.toList.sorted\n        val v = m.values.toList.sorted\n\
    \        val n = k.size\n        for (i <- 0 until n) {\n            if (k(i)\
    \ <= v(i)) return k(i)\n        }\n        return -1", "        val map = new\
    \ HashMap[Long, Long]()\n        for (x <- lst) {\n            if (map.contains(x))\
    \ map(x) += 1\n            else map(x) = 1\n        }\n        var max = -1\n\
    \        for (x <- lst) {\n            if (map(x) >= x && x > max) max = x.toInt\n\
    \        }\n        return max", "        val map = new HashMap[Long, Long]\n\
    \        for (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n    \
    \        else map(i) = 1\n        }\n        var result = -1L\n        for (i\
    \ <- lst) {\n            if (map(i) >= i && i > result) result = i\n        }\n\
    \        result", "        val map = new HashMap[Long, Long]()\n        for (i\
    \ <- lst) {\n            if (map.contains(i)) map(i) += 1\n            else map(i)\
    \ = 1\n        }\n        var max = -1\n        for (i <- lst) {\n           \
    \ if (map(i) >= i && i > max) max = i.toInt\n        }\n        max", "      \
    \  val freq = new HashMap[Long, Long]()\n        for (i <- lst) {\n          \
    \  if (freq.contains(i)) freq(i) += 1\n            else freq += (i -> 1)\n   \
    \     }\n        var max = -1\n        for (i <- freq.keys) {\n            if\
    \ (freq(i) >= i && i > max) max = i.toInt\n        }\n        max", "        val\
    \ freq = new HashMap[Long, Long]\n        for (i <- lst) {\n            if (freq.contains(i))\
    \ freq(i) += 1\n            else freq(i) = 1\n        }\n        var max = -1\n\
    \        for (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max\
    \ = i.toInt\n        }\n        max", "        val map = new HashMap[Long, Long]\n\
    \        for (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n    \
    \        else map(i) = 1\n        }\n        val result = map.filter(x => x._1\
    \ <= x._2).maxBy(_._1)\n        if (result._1 == 0) -1 else result._1", "    \
    \    val m = lst.groupBy(x => x).mapValues(_.size)\n        val keys = m.keys.toList.sorted\n\
    \        for (i <- keys.length - 1 to 0 by -1) {\n            if (m(keys(i)) >=\
    \ keys(i)) return keys(i)\n        }\n        return -1", "        val m = new\
    \ HashMap[Long, Long]\n        for (i <- lst) {\n            if (m.contains(i))\
    \ m(i) += 1\n            else m(i) = 1\n        }\n        var result = -1\n \
    \       for (i <- m.keys) {\n            if (i <= m(i) && i > result) result =\
    \ i\n        }\n        result", "        val freq = new HashMap[Long, Long]\n\
    \        for (i <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n  \
    \          else freq(i) = 1\n        }\n        var max = -1L\n        for (i\
    \ <- lst) {\n            if (freq(i) >= i && i > max) max = i\n        }\n   \
    \     max", "        val map = new HashMap[Long, Long]\n        for (i <- lst)\
    \ {\n            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n\
    \        }\n        var max = -1L\n        for (i <- map.keys) {\n           \
    \ if (i <= map(i) && i > max) max = i\n        }\n        max", "        val m\
    \ = lst.groupBy(x => x).mapValues(_.size)\n        val max = m.keys.max\n    \
    \    if (m(max) >= max) max else -1", "        val map = new HashMap[Long, Long]\n\
    \        for (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n    \
    \        else map(i) = 1\n        }\n        var result = -1L\n        for (i\
    \ <- lst) {\n            if (map(i) >= i && i > result) result = i\n        }\n\
    \        result", "        val freq = new HashMap[Long, Long]()\n        for (i\
    \ <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n            else\
    \ freq(i) = 1\n        }\n        var max = -1\n        for (i <- freq.keys) {\n\
    \            if (freq(i) >= i && i > max) max = i.toInt\n        }\n        max",
  "        val m = lst.groupBy(x => x).mapValues(_.size)\n        val max = m.keys.max\n\
    \        if (m(max) >= max) max else -1", "        val map = new HashMap[Long,\
    \ Long]()\n        for (i <- lst) {\n            if (map.contains(i)) map(i) +=\
    \ 1\n            else map(i) = 1\n        }\n        var max = -1L\n        for\
    \ (i <- map.keys) {\n            if (i <= map(i) && i > max) max = i\n       \
    \ }\n        max", "        val freq = new HashMap[Long, Long]()\n        for\
    \ (x <- lst) {\n            if (freq.contains(x)) freq(x) += 1\n            else\
    \ freq += (x -> 1)\n        }\n        var max = -1\n        for (x <- freq.keys)\
    \ {\n            if (freq(x) >= x && x > max) max = x.toInt\n        }\n     \
    \   max", "        val map = new HashMap[Long, Long]\n        for (i <- lst) {\n\
    \            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n \
    \       }\n        var max = -1\n        for (i <- map.keys) {\n            if\
    \ (i <= map(i) && i > max) max = i.toInt\n        }\n        max", "        val\
    \ freq = new HashMap[Long, Long]()\n        for (i <- lst) {\n            if (freq.contains(i))\
    \ freq(i) += 1\n            else freq(i) = 1\n        }\n        var max = -1\n\
    \        for (i <- lst) {\n            if (freq(i) >= i && i > max) max = i.toInt\n\
    \        }\n        max", "        val map = new HashMap[Long, Long]()\n     \
    \   for (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n         \
    \   else map(i) = 1\n        }\n        var max = -1\n        for (i <- lst) {\n\
    \            if (map(i) >= i && i > max) max = i.toInt\n        }\n        max",
  "        val freq = new HashMap[Long, Long]()\n        for (i <- lst) {\n      \
    \      if (freq.contains(i)) freq(i) += 1\n            else freq(i) = 1\n    \
    \    }\n        var max = -1L\n        for (i <- freq.keys) {\n            if\
    \ (freq(i) >= i && i > max) max = i\n        }\n        max", "        val m =\
    \ lst.groupBy(x => x).mapValues(_.size)\n        val keys = m.keys.toList.sorted\n\
    \        val values = m.values.toList.sorted\n        val max = keys.max\n   \
    \     val min = keys.min\n        if (min == 1) return -1\n        if (max ==\
    \ min) return max\n        val index = keys.indexOf(min)\n        if (values(index)\
    \ >= min) return min\n        -1", "        val freq = new HashMap[Long, Long]\n\
    \        for (x <- lst) {\n            if (freq.contains(x)) freq(x) += 1\n  \
    \          else freq(x) = 1\n        }\n        var result = -1L\n        for\
    \ (x <- freq.keys) {\n            if (x <= freq(x) && x > result) result = x\n\
    \        }\n        result", "        val freq = new HashMap[Long, Long]\n   \
    \     for (i <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n     \
    \       else freq(i) = 1\n        }\n        var max = -1L\n        for (i <-\
    \ freq.keys) {\n            if (freq(i) >= i && i > max) max = i\n        }\n\
    \        max", "        val freq = new HashMap[Long, Long]()\n        for (x <-\
    \ lst) {\n            if (freq.contains(x)) freq(x) += 1\n            else freq(x)\
    \ = 1\n        }\n        var result = -1L\n        for (x <- lst) {\n       \
    \     if (freq(x) >= x && x > result) result = x\n        }\n        result",
  "        val map = new HashMap[Long, Long]\n        for (i <- lst) {\n         \
    \   if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n\
    \        val keys = map.keys.toList.sorted\n        var result = -1L\n       \
    \ for (i <- keys) {\n            if (i <= map(i)) result = i\n        }\n    \
    \    result", "        val freq = new HashMap[Long, Long]\n        for (x <- lst)\
    \ {\n            if (freq.contains(x)) freq(x) += 1\n            else freq(x)\
    \ = 1\n        }\n        var max = -1L\n        for (x <- freq.keys) {\n    \
    \        if (freq(x) >= x && x > max) max = x\n        }\n        max", "    \
    \    val freq = new HashMap[Long, Long]\n        for (i <- lst) {\n          \
    \  if (freq.contains(i)) freq(i) += 1\n            else freq(i) = 1\n        }\n\
    \        var max = -1L\n        for (i <- freq.keys) {\n            if (freq(i)\
    \ >= i && i > max) max = i\n        }\n        max", "        val map = new HashMap[Long,\
    \ Long]()\n        for (i <- lst) {\n            if (map.contains(i)) map(i) +=\
    \ 1\n            else map(i) = 1\n        }\n        var max = -1L\n        for\
    \ (i <- map.keys) {\n            if (i <= map(i) && i > max) max = i\n       \
    \ }\n        max", "        val map = new HashMap[Long, Long]\n        for (x\
    \ <- lst) {\n            if (map.contains(x)) map(x) += 1\n            else map\
    \ += (x -> 1)\n        }\n        var max = -1\n        for (x <- map.keys) {\n\
    \            if (x <= map(x) && x > max) max = x.toInt\n        }\n        max",
  "        val m = lst.groupBy(x => x).mapValues(_.size)\n        val keys = m.keys.toList.sorted\n\
    \        val values = m.values.toList.sorted\n        val max = keys.max\n   \
    \     val min = keys.min\n        if (max == min) {\n            if (max >= values.max)\
    \ max else -1\n        } else {\n            val index = keys.indexWhere(x =>\
    \ x >= values(x - min))\n            if (index == -1) -1 else keys(index)\n  \
    \      }", "        val counts = lst.groupBy(x => x).mapValues(_.size)\n     \
    \   val max = counts.keys.max\n        if (counts(max) >= max) max else -1", " \
    \       val freq = new HashMap[Long, Long]()\n        for (i <- lst) {\n     \
    \       if (freq.contains(i)) freq(i) += 1\n            else freq(i) = 1\n   \
    \     }\n        var max = -1L\n        for (i <- freq.keys) {\n            if\
    \ (freq(i) >= i && i > max) max = i\n        }\n        max", "        val map\
    \ = new HashMap[Long, Long]\n        for (x <- lst) {\n            if (map.contains(x))\
    \ map(x) += 1\n            else map(x) = 1\n        }\n        var result = -1L\n\
    \        for (x <- lst) {\n            if (map(x) >= x && x > result) result =\
    \ x\n        }\n        result", "        val freq = new HashMap[Long, Long]\n\
    \        for (x <- lst) {\n            if (freq.contains(x)) freq(x) += 1\n  \
    \          else freq(x) = 1\n        }\n        var max = -1L\n        for (x\
    \ <- freq.keys) {\n            if (freq(x) >= x && x > max) max = x\n        }\n\
    \        max", "        val freq = lst.groupBy(identity).mapValues(_.size)\n \
    \       val max = lst.max\n        for (i <- max to 1 by -1) {\n            if\
    \ (freq.contains(i) && freq(i) >= i) return i\n        }\n        return -1",
  "        val counts = lst.groupBy(identity).mapValues(_.size)\n        val max =\
    \ counts.keys.max\n        if (counts(max) >= max) max else -1", "        val\
    \ m = lst.groupBy(x => x).mapValues(_.size)\n        val keys = m.keys.toList.sorted\n\
    \        val values = m.values.toList.sorted\n        val max = keys.max\n   \
    \     val min = keys.min\n        if (max == min) return -1\n        for (i <-\
    \ min to max) {\n            if (m.contains(i) && m(i) >= i) return i\n      \
    \  }\n        return -1", "        val map = new HashMap[Long, Long]\n       \
    \ for (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n           \
    \ else map(i) = 1\n        }\n        var max = -1L\n        for (i <- map.keys)\
    \ {\n            if (i <= map(i) && i > max) max = i\n        }\n        max",
  "        val m = lst.groupBy(identity).mapValues(_.size)\n        val r = m.filter(x\
    \ => x._1 <= x._2).toList.sortBy(_._1).reverse\n        if (r.isEmpty) -1 else\
    \ r.head._1", "        val freq = new HashMap[Long, Long]\n        for (x <- lst)\
    \ {\n            if (freq.contains(x)) freq(x) += 1\n            else freq(x)\
    \ = 1\n        }\n        var max = -1\n        for (x <- freq.keys) {\n     \
    \       if (freq(x) >= x && x > max) max = x.toInt\n        }\n        max", " \
    \       val m = lst.groupBy(identity).mapValues(_.size)\n        val max = m.keys.max\n\
    \        if (m(max) >= max) max else -1", "        val map = new HashMap[Long,\
    \ Long]\n        for (i <- lst) {\n            if (map.contains(i)) map(i) +=\
    \ 1\n            else map(i) = 1\n        }\n        var max = -1\n        for\
    \ (i <- map.keys) {\n            if (i <= map(i) && i > max) max = i.toInt\n \
    \       }\n        max", "        val freq = new HashMap[Long, Long]\n       \
    \ for (i <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n         \
    \   else freq(i) = 1\n        }\n        var max = -1\n        for (i <- freq.keys)\
    \ {\n            if (freq(i) >= i && i > max) max = i.toInt\n        }\n     \
    \   max", "        val m = lst.groupBy(x => x).mapValues(_.size)\n        val\
    \ max = m.keys.max\n        if (m(max) >= max) max else -1", "        val freq\
    \ = new HashMap[Long, Long]\n        for (i <- lst) {\n            if (freq.contains(i))\
    \ freq(i) += 1\n            else freq(i) = 1\n        }\n        var max = -1\n\
    \        for (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max\
    \ = i.toInt\n        }\n        max", "        val m = new HashMap[Long, Long]\n\
    \        for (x <- lst) {\n            if (m.contains(x)) m(x) += 1\n        \
    \    else m(x) = 1\n        }\n        var max = -1L\n        for (x <- m.keys)\
    \ {\n            if (x <= m(x) && x > max) max = x\n        }\n        max", " \
    \       val freq = new HashMap[Long, Long]()\n        for (x <- lst) {\n     \
    \       if (freq.contains(x)) freq(x) += 1\n            else freq(x) = 1\n   \
    \     }\n        var max = -1\n        for (x <- freq.keys) {\n            if\
    \ (freq(x) >= x && x > max) max = x.toInt\n        }\n        max", "        val\
    \ m = lst.groupBy(x => x).mapValues(_.size)\n        val max = m.keys.max\n  \
    \      if (m(max) >= max) max else -1", "        val freq = lst.groupBy(identity).mapValues(_.size)\n\
    \        val max = freq.keys.max\n        if (freq(max) >= max) max else -1",
  "        val map = new HashMap[Long, Long]\n        for (i <- lst) {\n         \
    \   if (map.contains(i)) map(i) += 1\n            else map += (i -> 1)\n     \
    \   }\n        var max = -1L\n        for (i <- map.keys) {\n            if (i\
    \ <= map(i) && i > max) max = i\n        }\n        max", "        val freq =\
    \ new HashMap[Long, Long]\n        for (i <- lst) {\n            if (freq.contains(i))\
    \ freq(i) += 1\n            else freq(i) = 1\n        }\n        var max = -1\n\
    \        for (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max\
    \ = i.toInt\n        }\n        max", "        val m = lst.groupBy(identity).mapValues(_.size)\n\
    \        val max = m.keys.max\n        if (m(max) >= max) max else -1", "    \
    \    val m = lst.groupBy(x => x).map(x => (x._1, x._2.length)).toList.sortBy(x\
    \ => x._1)\n        val m2 = m.filter(x => x._1 <= x._2)\n        if (m2.length\
    \ == 0) -1 else m2.last._1", "        val m = new HashMap[Long, Long]\n      \
    \  for (i <- lst) {\n            if (m.contains(i)) m(i) += 1\n            else\
    \ m(i) = 1\n        }\n        var max = -1L\n        for (i <- lst) {\n     \
    \       if (i > max && m(i) >= i) max = i\n        }\n        max", "        val\
    \ map = new HashMap[Long, Long]\n        for (i <- lst) {\n            if (map.contains(i))\
    \ map(i) += 1\n            else map(i) = 1\n        }\n        var max = -1\n\
    \        for (i <- map.keys) {\n            if (i <= map(i) && i > max) max =\
    \ i.toInt\n        }\n        max", "        val map = new HashMap[Long, Long]\n\
    \        for (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n    \
    \        else map(i) = 1\n        }\n        var max = -1\n        for (i <- map.keys)\
    \ {\n            if (i <= map(i) && i > max) max = i.toInt\n        }\n      \
    \  max", "        val m = lst.groupBy(identity).mapValues(_.size).toList.sortBy(_._1)\n\
    \        var i = 0\n        while (i < m.length) {\n            if (m(i)._1 <=\
    \ m(i)._2) return m(i)._1\n            i += 1\n        }\n        -1", "     \
    \   val freq = new HashMap[Long, Long]()\n        for (x <- lst) {\n         \
    \   if (freq.contains(x)) freq(x) += 1\n            else freq(x) = 1\n       \
    \ }\n        var max = -1\n        for (x <- freq.keys) {\n            if (freq(x)\
    \ >= x && x > max) max = x.toInt\n        }\n        max", "        val m = lst.groupBy(identity).mapValues(_.size)\n\
    \        val keys = m.keys.toList.sorted\n        val values = m.values.toList.sorted\n\
    \        val n = keys.size\n        for (i <- 0 until n) {\n            if (keys(i)\
    \ <= values(i)) return keys(i)\n        }\n        return -1", "        val freq\
    \ = new HashMap[Long, Long]()\n        for (i <- lst) {\n            if (freq.contains(i))\
    \ freq(i) += 1\n            else freq(i) = 1\n        }\n        var max = -1L\n\
    \        for (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max\
    \ = i\n        }\n        max", "        val map = new HashMap[Long, Long]()\n\
    \        for (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n    \
    \        else map(i) = 1\n        }\n        var max = -1\n        for (i <- map.keys)\
    \ {\n            if (i <= map(i) && i > max) max = i.toInt\n        }\n      \
    \  max", "        val freq = new HashMap[Long, Long]()\n        for (i <- lst)\
    \ {\n            if (freq.contains(i)) freq(i) += 1\n            else freq(i)\
    \ = 1\n        }\n        var result = -1L\n        for (i <- freq.keys) {\n \
    \           if (i <= freq(i) && i > result) result = i\n        }\n        result",
  "        val map = new HashMap[Long, Long]\n        for (i <- lst) {\n         \
    \   if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n\
    \        var max = -1L\n        for (i <- map.keys) {\n            if (i <= map(i)\
    \ && i > max) max = i\n        }\n        max", "        val freq = new HashMap[Long,\
    \ Long]\n        for (x <- lst) {\n            if (freq.contains(x)) freq(x) +=\
    \ 1\n            else freq(x) = 1\n        }\n        var max = -1\n        for\
    \ (x <- freq.keys) {\n            if (freq(x) >= x && x > max) max = x.toInt\n\
    \        }\n        max", "        val m = lst.groupBy(x => x).mapValues(_.size)\n\
    \        val max = m.keys.max\n        if (m(max) >= max) max else -1", "    \
    \    val map = new HashMap[Long, Long]\n        for (i <- lst) {\n           \
    \ if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n \
    \       var max = -1\n        for (i <- lst) {\n            if (map(i) >= i &&\
    \ i > max) max = i.toInt\n        }\n        max", "        val freq = new HashMap[Long,\
    \ Long]()\n        for (i <- lst) {\n            if (freq.contains(i)) freq(i)\
    \ += 1\n            else freq(i) = 1\n        }\n        var max = -1L\n     \
    \   for (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max = i\n\
    \        }\n        max", "        val freq = new HashMap[Long, Long]\n      \
    \  for (i <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n        \
    \    else freq(i) = 1\n        }\n        var max = -1\n        for (i <- freq.keys)\
    \ {\n            if (freq(i) >= i && i > max) max = i.toInt\n        }\n     \
    \   max", "        val map = new HashMap[Long, Long]\n        for (i <- lst) {\n\
    \            if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n \
    \       }\n        var max = -1\n        for (i <- map.keys) {\n            if\
    \ (i <= map(i) && i > max) max = i.toInt\n        }\n        max", "        val\
    \ m = lst.groupBy(identity).mapValues(_.size)\n        val max = m.keys.max\n\
    \        if (m(max) >= max) max else -1", "        val freq = new HashMap[Long,\
    \ Long]()\n        for (i <- lst) {\n            if (freq.contains(i)) freq(i)\
    \ += 1\n            else freq(i) = 1\n        }\n        var max = -1L\n     \
    \   for (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max = i\n\
    \        }\n        max", "        val freq = new HashMap[Long, Long]()\n    \
    \    lst.foreach(x => freq(x) = freq.getOrElse(x, 0) + 1)\n        val max = freq.keys.max\n\
    \        if (freq(max) >= max) max else -1", "        val freq = new HashMap[Long,\
    \ Long]\n        for (i <- lst) {\n            if (freq.contains(i)) freq(i) +=\
    \ 1\n            else freq(i) = 1\n        }\n        var max = -1\n        for\
    \ (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max = i.toInt\n\
    \        }\n        max", "        val map = new HashMap[Long, Long]\n       \
    \ for (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n           \
    \ else map(i) = 1\n        }\n        var max = -1\n        for (i <- map.keys)\
    \ {\n            if (i <= map(i) && i > max) max = i.toInt\n        }\n      \
    \  max", "        val freq = new HashMap[Long, Long]()\n        for (i <- lst)\
    \ {\n            if (freq.contains(i)) freq(i) += 1\n            else freq(i)\
    \ = 1\n        }\n        var max = -1L\n        for (i <- freq.keys) {\n    \
    \        if (freq(i) >= i && i > max) max = i\n        }\n        max", "    \
    \    val m = new HashMap[Long, Long]\n        for (i <- lst) {\n            if\
    \ (m.contains(i)) m(i) += 1\n            else m(i) = 1\n        }\n        var\
    \ max = -1L\n        for (i <- m.keys) {\n            if (i > 0 && m(i) >= i &&\
    \ i > max) max = i\n        }\n        max", "        val freq = new HashMap[Long,\
    \ Long]\n        for (x <- lst) {\n            if (freq.contains(x)) freq(x) +=\
    \ 1\n            else freq(x) = 1\n        }\n        var max = -1L\n        for\
    \ (x <- freq.keys) {\n            if (freq(x) >= x && x > max) max = x\n     \
    \   }\n        max", "        val m = new HashMap[Long, Long]\n        for (i\
    \ <- lst) {\n            if (m.contains(i)) m(i) += 1 else m(i) = 1\n        }\n\
    \        var result = -1L\n        for (i <- lst) {\n            if (m(i) >= i\
    \ && i > result) result = i\n        }\n        result", "        val freq = new\
    \ HashMap[Long, Long]()\n        for (i <- lst) {\n            if (freq.contains(i))\
    \ freq(i) += 1\n            else freq(i) = 1\n        }\n        var max = -1\n\
    \        for (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max\
    \ = i.toInt\n        }\n        max", "        val freq = new HashMap[Long, Long]\n\
    \        for (i <- lst) {\n            if (freq.contains(i)) freq(i) += 1 else\
    \ freq(i) = 1\n        }\n        var max = -1L\n        for (i <- freq.keys)\
    \ {\n            if (freq(i) >= i && i > max) max = i\n        }\n        max",
  "        val map = new HashMap[Long, Long]\n        for (i <- lst) {\n         \
    \   if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n\
    \        var max = -1\n        for (i <- map.keys) {\n            if (i <= map(i)\
    \ && i > max) max = i.toInt\n        }\n        max", "        val freq = new\
    \ HashMap[Long, Long]\n        for (i <- lst) {\n            if (freq.contains(i))\
    \ freq(i) += 1\n            else freq(i) = 1\n        }\n        var max = -1\n\
    \        for (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max\
    \ = i.toInt\n        }\n        max", "        val map = new HashMap[Long, Long]()\n\
    \        for (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n    \
    \        else map += (i -> 1)\n        }\n        var result = -1\n        for\
    \ (i <- map.keys) {\n            if (i <= map(i) && i > result) result = i\n \
    \       }\n        result", "        val map = new HashMap[Long, Long]()\n   \
    \     for (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n       \
    \     else map(i) = 1\n        }\n        var max = -1L\n        for (i <- map.keys)\
    \ {\n            if (i <= map(i) && i > max) max = i\n        }\n        max",
  "        val map = new HashMap[Long, Long]\n        for (i <- lst) {\n         \
    \   if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n\
    \        var max = -1\n        for (i <- map.keys) {\n            if (i <= map(i)\
    \ && i > max) max = i.toInt\n        }\n        max", "        val freq = new\
    \ HashMap[Long, Long]\n        for (i <- lst) {\n            if (freq.contains(i))\
    \ freq(i) += 1\n            else freq(i) = 1\n        }\n        var max = -1\n\
    \        for (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max\
    \ = i.toInt\n        }\n        max", "        val freq = new HashMap[Long, Long]\n\
    \        for (i <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n  \
    \          else freq(i) = 1\n        }\n        var max = -1\n        for (i <-\
    \ freq.keys) {\n            if (freq(i) >= i && i > max) max = i.toInt\n     \
    \   }\n        max", "        val freq = new HashMap[Long, Long]\n        for\
    \ (i <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n            else\
    \ freq(i) = 1\n        }\n        var max = -1L\n        for (i <- freq.keys)\
    \ {\n            if (freq(i) >= i && i > max) max = i\n        }\n        max",
  "        val freq = new HashMap[Long, Long]()\n        for (x <- lst) {\n      \
    \      if (freq.contains(x)) freq(x) += 1\n            else freq(x) = 1\n    \
    \    }\n        var max = -1\n        for (x <- freq.keys) {\n            if (freq(x)\
    \ >= x && x > max) max = x.toInt\n        }\n        max", "        val freq =\
    \ new HashMap[Long, Long]\n        for (i <- lst) {\n            if (freq.contains(i))\
    \ freq(i) += 1\n            else freq(i) = 1\n        }\n        var max = -1\n\
    \        for (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max\
    \ = i.toInt\n        }\n        max", "        val map = new HashMap[Long, Long]()\n\
    \        for (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n    \
    \        else map(i) = 1\n        }\n        var max = -1L\n        for (i <-\
    \ map.keys) {\n            if (i <= map(i) && i > max) max = i\n        }\n  \
    \      max", "        val m = lst.groupBy(identity).mapValues(_.size).toList.sortBy(_._1)\n\
    \        for (i <- m.indices) {\n            if (m(i)._1 <= m(i)._2) return m(i)._1\n\
    \        }\n        -1", "        val freq = new HashMap[Long, Long]\n       \
    \ for (i <- lst) {\n            if (freq.contains(i)) freq(i) += 1\n         \
    \   else freq(i) = 1\n        }\n        var result = -1L\n        for (i <- freq.keys)\
    \ {\n            if (i <= freq(i) && i > result) result = i\n        }\n     \
    \   result", "        val m = lst.groupBy(identity).mapValues(_.size)\n      \
    \  val v = m.filter(x => x._1 <= x._2).map(x => x._1).toList.sorted\n        if\
    \ (v.isEmpty) -1 else v.last", "        val map = new HashMap[Long, Long]()\n\
    \        for (i <- lst) {\n            if (map.contains(i)) map(i) += 1\n    \
    \        else map(i) = 1\n        }\n        var max = -1L\n        for (i <-\
    \ lst) {\n            if (map(i) >= i && i > max) max = i\n        }\n       \
    \ max", "        val map = lst.groupBy(x => x).mapValues(_.size)\n        val\
    \ keys = map.keys.toList.sorted\n        val max = keys.last\n        for (i <-\
    \ keys) {\n            if (map(i) >= i) return i\n        }\n        return -1",
  "        val map = new HashMap[Long, Long]\n        for (i <- lst) {\n         \
    \   if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n\
    \        var max = -1L\n        for (i <- lst) {\n            if (map(i) >= i\
    \ && i > max) max = i\n        }\n        max", "        val freq = new HashMap[Long,\
    \ Long]\n        for (i <- lst) {\n            if (freq.contains(i)) freq(i) +=\
    \ 1\n            else freq(i) = 1\n        }\n        var result = -1L\n     \
    \   for (i <- lst) {\n            if (freq(i) >= i && i > result) result = i\n\
    \        }\n        result"]
stop_tokens:
- "\n    }\n"
