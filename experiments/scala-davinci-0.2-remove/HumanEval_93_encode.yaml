name: HumanEval_93_encode
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that takes a message, and encodes in such a \n    // way\
  \ that it swaps case of all letters, replaces all vowels in \n    // the message\
  \ with the letter that appears 2 places ahead of that \n    // vowel in the english\
  \ alphabet. \n    // Assume only letters. \n    // Examples:\n    def encode(message\
  \ : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
  )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n\
  \    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"This is\
  \ a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw\
  \ WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
completions: ["        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        message.map(c => if (vowels.contains(c.toLower)) alphabet((alphabet.indexOf(c.toLower)\
    \ + 2) % 26) else c).map(c => if (c.isUpper) c.toLower else c.toUpper)", "   \
    \     val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabet2 = alphabet + alphabet\n        val vowelMap = Map('a'\
    \ -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'y')\n        val vowelMap2\
    \ = Map('a' -> 'e', 'e' -> 'i', 'i' -> 'o', 'o' -> 'u', 'u' -> 'a')\n        val\
    \ vowelMap3 = Map('a' -> 'i', 'e' -> 'o', 'i' -> 'u', 'o' -> 'a', 'u' -> 'e')\n\
    \        val vowelMap4 = Map('a' -> 'o', 'e' -> 'u', 'i' -> 'a', 'o' -> 'e', 'u'\
    \ -> 'i')\n        val vowelMap5 = Map('a' -> 'u', 'e' -> 'a', 'i' -> 'e', 'o'\
    \ -> 'i', 'u' -> 'o')\n        val vowelMap6 = Map('a' -> 'a', 'e' -> 'e', 'i'\
    \ -> 'i', 'o' -> 'o', 'u' -> 'u')\n        val vowelMap7 = Map('a' -> 'b', 'e'\
    \ -> 'f', 'i' -> 'j', 'o' -> 'p', 'u' -> 'v')\n        val vowelMap8 = Map('a'\
    \ -> 'd', 'e' -> 'h', 'i' -> 'l', 'o' -> 'r', 'u' -> 'x')\n        val vowelMap9\
    \ = Map('a' -> 'f', 'e' -> 'j', 'i' -> 'n', 'o' -> 't', 'u' -> 'z')\n        val\
    \ vowelMap10 = Map('a' -> 'h', 'e' -> 'l', 'i' -> 'p', 'o' -> 'v', 'u' -> 'b')\n\
    \        val vowelMap11 = Map('a' -> 'j', 'e' -> 'n', 'i' -> 'r', 'o' -> 'x',\
    \ 'u' -> 'd", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val encoded = message.toLowerCase.map(c => {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabet.indexOf(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                c\n         \
    \   }\n        })\n        encoded.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        message.map(x => if (vowels.contains(x.toLower))\
    \ vowelsMap2((vowelsMap(x.toLower) + 2) % 5) else alphabetMap2((alphabetMap(x.toLower)\
    \ + 2) % 26)).mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = 'a' to 'z'\n        val alphabetMap = alphabet.zip(alphabet.tail.tail).toMap\n\
    \        message.map(c => if (vowels.contains(c.toLower)) alphabetMap(c.toLower)\
    \ else c)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageMap = message.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageMap2 = message.zipWithIndex.toMap\n\
    \        val messageMap3 = message.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap4 = message.zipWithIndex.toMap\n        val messageMap5\
    \ = message.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val messageMap6\
    \ = message.zipWithIndex.toMap\n        val messageMap7 = message.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageMap8 = message.zipWithIndex.toMap\n\
    \        val messageMap9 = message.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap10 = message.zipWithIndex.toMap\n        val messageMap11\
    \ = message.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val messageMap12\
    \ = message.zipWithIndex.toMap\n        val messageMap13 = message.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageMap14 = message.zipWithIndex.toMap\n\
    \        val messageMap15 = message.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap16 = message.zipWithIndex.toMap\n        val messageMap17\
    \ = message.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val messageMap18\
    \ = message.zipWithIndex.toMap\n        val messageMap19", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = (alphabet zip alphabet.tail).toMap\n        val alphabetMap2\
    \ = (alphabet zip alphabet.tail.tail).toMap\n        message.map(c => if (vowels.contains(c))\
    \ alphabetMap2(c.toLower) else alphabetMap(c.toLower)).map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "        val vowels = \"aeiou\"\n     \
    \   val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val alphabetMapInv\
    \ = alphabetMap.map(_.swap)\n        val vowelsMapInv = vowelsMap.map(_.swap)\n\
    \        val vowelsMap2 = vowelsMap.map(x => (x._1, (x._2 + 2) % 5))\n       \
    \ val vowelsMap2Inv = vowelsMap2.map(_.swap)\n        val messageEncoded = message.map(x\
    \ => {\n            if (vowels.contains(x.toLower)) {\n                if (x.isUpper)\
    \ vowelsMap2Inv(x.toLower).toUpper\n                else vowelsMap2Inv(x)\n  \
    \          }\n            else if (alphabet.contains(x.toLower)) {\n         \
    \       if (x.isUpper) alphabetMapInv(x.toLower).toUpper\n                else\
    \ alphabetMapInv(x)\n            }\n            else x\n        })\n        messageEncoded",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val encoded =\
    \ message.map(x => {\n            if (vowels.contains(x.toLower)) {\n        \
    \        val index = alphabetMap(x.toLower)\n                val newIndex = (index\
    \ + 2) % 26\n                alphabetMap2(newIndex).toUpper\n            } else\
    \ {\n                x.toUpper\n            }\n        })\n        encoded", " \
    \       val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val encodedAlphabet = alphabet.map(x => {\n            if (vowels.contains(x))\
    \ {\n                val index = alphabetMap(x)\n                val nextIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(nextIndex)\n     \
    \       } else {\n                x\n            }\n        })\n        val encodedAlphabetMap\
    \ = alphabet.zip(encodedAlphabet).toMap\n        message.map(x => {\n        \
    \    if (x.isUpper) {\n                encodedAlphabetMap(x.toLower).toUpper\n\
    \            } else {\n                encodedAlphabetMap(x)\n            }\n\
    \        })", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val\
    \ alphabet = ('a' to 'z').toList\n        val encoded = message.map(c => {\n \
    \           if (vowels.contains(c.toLower)) {\n                val index = alphabet.indexOf(c.toLower)\n\
    \                alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                c\n            }\n        })\n        encoded.mkString", "  \
    \      val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x =>\
    \ (x._2, x._1)).toMap\n        val encoded = message.map(x => {\n            val\
    \ letter = x.toLower\n            if (vowels.contains(letter)) {\n           \
    \     val index = vowelsMap(letter)\n                val newIndex = (index + 2)\
    \ % vowels.length\n                val newLetter = vowelsMap2(newIndex)\n    \
    \            if (x.isUpper) newLetter.toUpper else newLetter\n            } else\
    \ {\n                val index = alphabetMap(letter)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                val newLetter = alphabetMap2(newIndex)\n\
    \                if (x.isUpper) newLetter.toUpper else newLetter\n           \
    \ }\n        })\n        encoded", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val encoded = message.map(c\
    \ => if (vowels.contains(c.toLower)) alphabet((alphabet.indexOf(c.toLower) + 2)\
    \ % alphabet.length) else c)\n        encoded.map(c => if (c.isUpper) c.toLower\
    \ else c.toUpper).mkString", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageMap = message.toLowerCase.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageMap2 = message.toLowerCase.zipWithIndex.toMap\n\
    \        val messageMap3 = message.toLowerCase.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap4 = message.toLowerCase.zipWithIndex.toMap\n        val\
    \ messageMap5 = message.toLowerCase.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap6 = message.toLowerCase.zipWithIndex.toMap\n        val\
    \ messageMap7 = message.toLowerCase.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap8 = message.toLowerCase.zipWithIndex.toMap\n        val\
    \ messageMap9 = message.toLowerCase.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap10 = message.toLowerCase.zipWithIndex.toMap\n        val\
    \ messageMap11 = message.toLowerCase.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap12 = message.toLowerCase.zipWithIndex.toMap\n        val\
    \ messageMap13 = message.toLowerCase.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap14 = message.toLowerCase.zipWithIndex.toMap\n        val\
    \ messageMap15 = message.toLowerCase.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val message", "        val vowels = \"aeiou\"\n        val alphabet =\
    \ \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val newIndex = (index + 2) % vowels.length\n\
    \                vowels(newIndex).toString\n            } else if (alphabet.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex).toString\n\
    \            } else {\n                c.toString\n            }\n        })\n\
    \        encoded.mkString", "        val vowels = List('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageList = message.toLowerCase.toList\n\
    \        val encodedList = messageList.map(x => {\n            if (vowels.contains(x))\
    \ {\n                val index = vowelsMap(x)\n                val newIndex =\
    \ (index + 2) % vowels.length\n                vowelsMap2(newIndex)\n        \
    \    } else if (alphabet.contains(x)) {\n                val index = alphabetMap(x)\n\
    \                val newIndex = (index + 2) % alphabet.length\n              \
    \  alphabetMap2(newIndex)\n            } else {\n                x\n         \
    \   }\n        })\n        encodedList.mkString", "        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ encoded = message.map(c => {\n            val index = alphabet.indexOf(c.toLower)\n\
    \            if (index == -1) c\n            else if (vowels.contains(c.toLower))\
    \ alphabet((index + 2) % alphabet.length)\n            else alphabet((index +\
    \ alphabet.length - 2) % alphabet.length)\n        })\n        encoded.map(c =>\
    \ if (c.isUpper) c.toLower else c.toUpper).mkString", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ map = alphabet.zip(alphabet.drop(2) ::: alphabet.take(2)).toMap\n        message.map(c\
    \ => if (vowels.contains(c.toLower)) map(c.toLower) else c).map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "        val vowels = \"aeiou\"\n     \
    \   val alpha = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphaMap = alpha.zipWithIndex.toMap\n\
    \        val alphaMap2 = alpha.zipWithIndex.map(x => (x._2, x._1)).toMap\n   \
    \     val vowelsMap = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphaMap3 = alpha.zipWithIndex.map(x =>\
    \ (x._2, (x._2 + 2) % 26)).toMap\n        val vowelsMap3 = vowels.zipWithIndex.map(x\
    \ => (x._2, (x._2 + 2) % 5)).toMap\n        val alphaMap4 = alpha.zipWithIndex.map(x\
    \ => (x._2, (x._2 + 24) % 26)).toMap\n        val vowelsMap4 = vowels.zipWithIndex.map(x\
    \ => (x._2, (x._2 + 3) % 5)).toMap\n        val alphaMap5 = alpha.zipWithIndex.map(x\
    \ => (x._2, (x._2 + 24) % 26)).toMap\n        val vowelsMap5 = vowels.zipWithIndex.map(x\
    \ => (x._2, (x._2 + 3) % 5)).toMap\n        val alphaMap6 = alpha.zipWithIndex.map(x\
    \ => (x._2, (x._2 + 24) % 26)).toMap\n        val vowelsMap6 = vowels.zipWithIndex.map(x\
    \ => (x._2, (x._2 + 3) % 5)).toMap\n        val alphaMap7 = alpha.zipWithIndex.map(x\
    \ => (x._2, (x._2 + 24) % 26)).toMap\n        val vowelsMap7 = vowels.zipWithIndex.map(x\
    \ => (x._2, (x._2 + 3) % 5)).toMap\n        val alphaMap8 = alpha.zipWithIndex.map(x\
    \ => (x._2, (x._2 + 24) % 26)).toMap\n        val vowelsMap8 =", "        val\
    \ vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val encoded = message.map(x => {\n         \
    \   if (vowels.contains(x.toLower)) {\n                val index = vowelsMap(x.toLower)\n\
    \                val newIndex = (index + 2) % 5\n                vowelsMap2(newIndex).toUpper\n\
    \            } else {\n                val index = alphabetMap(x.toLower)\n  \
    \              val newIndex = (index + 2) % 26\n                alphabetMap2(newIndex).toUpper\n\
    \            }\n        })\n        encoded", "        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val encoded =\
    \ message.map(c => {\n            if (vowels.contains(c.toLower)) {\n        \
    \        val index = alphabet.indexOf(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex).toUpper\n\
    \            } else {\n                c.toUpper\n            }\n        })\n\
    \        encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n      \
    \  val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2((alphabetMap(x.toLower)\
    \ + 2) % 26) else x)", "        val vowels = \"aeiou\"\n        val alphabet =\
    \ \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (vowelsMap.contains(c.toLower)) {\n                val\
    \ index = vowelsMap(c.toLower)\n                val nextIndex = (index + 2) %\
    \ vowels.length\n                val nextVowel = vowels(nextIndex)\n         \
    \       if (c.isUpper) nextVowel.toUpper else nextVowel\n            } else if\
    \ (alphabetMap.contains(c.toLower)) {\n                val index = alphabetMap(c.toLower)\n\
    \                val nextIndex = (index + 2) % alphabet.length\n             \
    \   val nextLetter = alphabet(nextIndex)\n                if (c.isUpper) nextLetter.toUpper\
    \ else nextLetter\n            } else c\n        })\n        encoded", "     \
    \   val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val encodedAlphabet = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x)\
    \ + 2) % 26) else x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (x.isUpper) encodedAlphabetMap(x.toLower).toUpper\
    \ else encodedAlphabetMap(x))", "        val vowels = List('a', 'e', 'i', 'o',\
    \ 'u')\n        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = (vowels.indexOf(c) + 2) % vowels.length\n   \
    \             vowels(index)\n            } else {\n                c\n       \
    \     }\n        }\n        message.map(c => if (c.isUpper) encodeChar(c.toLower).toUpper\
    \ else encodeChar(c))", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val alphabetList =\
    \ alphabet.toList\n        val vowelsList = vowels.toList\n        val messageList\
    \ = message.toList\n        val encodedList = messageList.map(c => {\n       \
    \     if (vowelsMap.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowelsList.length\n            \
    \    val newChar = vowelsList(newIndex)\n                if (c.isUpper) newChar.toUpper\
    \ else newChar\n            } else if (alphabetMap.contains(c.toLower)) {\n  \
    \              val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabetList.length\n                val newChar = alphabetList(newIndex)\n\
    \                if (c.isUpper) newChar.toUpper else newChar\n            } else\
    \ c\n        })\n        encodedList.mkString", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        var\
    \ encoded = \"\"\n        for (c <- message) {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabet.indexOf(c)\n                encoded\
    \ += alphabet((index + 2) % alphabet.length)\n            } else {\n         \
    \       encoded += c\n            }\n        }\n        encoded", "        val\
    \ vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val map = Map(\n            'a' -> 'c',\n            'e' -> 'g',\n  \
    \          'i' -> 'k',\n            'o' -> 'q',\n            'u' -> 's'\n    \
    \    )\n        val encoded = message.map(c => {\n            if (vowels.contains(c))\
    \ {\n                map(c)\n            } else {\n                c\n       \
    \     }\n        })\n        encoded.map(c => {\n            if (alphabet.contains(c))\
    \ {\n                if (c == 'z') {\n                    'a'\n              \
    \  } else {\n                    alphabet(alphabet.indexOf(c) + 1)\n         \
    \       }\n            } else {\n                c\n            }\n        })",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val next = (index + 2) % vowels.length\n                vowels(next).toString\n\
    \            } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val next = (index + 2) % alphabet.length\n\
    \                alphabet(next).toString\n            } else {\n             \
    \   c.toString\n            }\n        })\n        encoded.mkString", "      \
    \  val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val alphabetMap3\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap4\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap5\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap6\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap7\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap8\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap9\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap10\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap11\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap12\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap13\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap14\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap15\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap16\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap17\
    \ =", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = ('a' to 'z').toList\n        val encoded = for (c <- message) yield {\n  \
    \          if (vowels.contains(c)) {\n                val index = alphabet.indexOf(c)\n\
    \                alphabet((index + 2) % alphabet.length)\n            } else if\
    \ (c.isUpper) {\n                c.toLower\n            } else {\n           \
    \     c.toUpper\n            }\n        }\n        encoded.mkString", "      \
    \  val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val encodedAlphabet = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x)\
    \ + 2) % 26) else x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (x.isUpper) encodedAlphabetMap(x.toLower).toUpper\
    \ else encodedAlphabetMap(x))", "        val vowels = List('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val vowelMap = vowels.zipWithIndex.toMap\n\
    \        val newAlphabet = alphabet.drop(2) ++ alphabet.take(2)\n        val newVowelMap\
    \ = vowels.zip(newAlphabet).toMap\n        val newAlphabetMap = alphabet.zip(newAlphabet).toMap\n\
    \        message.map(c => if (vowelMap.contains(c.toLower)) newVowelMap(c.toLower)\
    \ else newAlphabetMap(c.toLower))", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val map = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q',\
    \ 'u' -> 'y')\n        message.map(c => if (vowels.contains(c)) map(c) else c).map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper)", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x\
    \ => if (vowels.contains(x)) alphabet((alphabetMap(x) + 2) % alphabet.length)\
    \ else x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (x.isUpper) encodedAlphabetMap(x.toLower).toUpper\
    \ else encodedAlphabetMap(x))", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        def encodeChar(c :\
    \ Char) : Char = {\n            if (vowels.contains(c)) {\n                val\
    \ index = alphabet.indexOf(c)\n                alphabet((index + 2) % alphabet.length)\n\
    \            } else {\n                if (c.isUpper) c.toLower else c.toUpper\n\
    \            }\n        }\n        message.map(encodeChar)", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to 'z'\n        val\
    \ alphabetMap = alphabet.zip(alphabet.tail :+ 'a').toMap\n        message.map(c\
    \ => if (vowels.contains(c)) alphabetMap(c) else c).map(c => if (c.isUpper) c.toLower\
    \ else c.toUpper)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n     \
    \   val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetSize = alphabet.size\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabetSize\n\
    \                alphabet(newIndex)\n            } else {\n                c\n\
    \            }\n        })\n        encoded.map(c => if (c.isUpper) c.toLower\
    \ else c.toUpper).mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val next = c + 2\n                if (next > 'z') {\n   \
    \                 ('a' + (next - 'z') - 1).toChar\n                } else {\n\
    \                    next.toChar\n                }\n            } else {\n  \
    \              c\n            }\n        }\n        message.map(c => if (c.isUpper)\
    \ encodeChar(c.toLower).toUpper else encodeChar(c)).mkString", "        val vowels\
    \ = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n       \
    \ val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowelsMap.contains(c))\
    \ {\n                val index = vowelsMap(c)\n                val newIndex =\
    \ (index + 2) % vowels.length\n                vowels(newIndex)\n            }\
    \ else {\n                val index = alphabetMap(c)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex)\n      \
    \      }\n        }\n        message.map(c => if (c.isUpper) encodeChar(c.toLower).toUpper\
    \ else encodeChar(c))", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val encoded = message.map(x => {\n         \
    \   val index = alphabetMap(x.toLower)\n            if (vowels.contains(x.toLower))\
    \ {\n                val newIndex = (index + 2) % alphabet.length\n          \
    \      val newChar = vowelsMap2(newIndex)\n                if (x.isUpper) newChar.toUpper\
    \ else newChar\n            } else {\n                val newChar = alphabetMap2(index)\n\
    \                if (x.isUpper) newChar.toUpper else newChar\n            }\n\
    \        })\n        encoded", "        val vowels = List('a', 'e', 'i', 'o',\
    \ 'u')\n        message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowels.indexOf(c.toLower)\n                val\
    \ next = (index + 2) % vowels.length\n                vowels(next).toUpper\n \
    \           } else {\n                c.toUpper\n            }\n        })", " \
    \       val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val map = alphabet.zip(alphabet.drop(2) ::: alphabet.take(2)).toMap\n\
    \        message.map(c => if (vowels.contains(c.toLower)) map(c.toLower) else\
    \ c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet\
    \ = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x) + 2) %\
    \ alphabet.size) else x)\n        val alphabetMapEncoded = encodedAlphabet.zipWithIndex.toMap\n\
    \        val encodedMessage = message.map(x => if (vowels.contains(x)) encodedAlphabet(alphabetMap(x))\
    \ else x)\n        encodedMessage", "        val vowels = \"aeiou\"\n        val\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encodedAlphabet\
    \ = alphabet.drop(2) + alphabet.take(2)\n        val encodedVowels = vowels.drop(2)\
    \ + vowels.take(2)\n        val encodedVowelsMap = encodedVowels.zipWithIndex.toMap\n\
    \        val encodedAlphabetMap = encodedAlphabet.zipWithIndex.toMap\n       \
    \ val encodedMessage = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val encodedIndex\
    \ = encodedVowelsMap(vowels(index))\n                encodedAlphabet(encodedIndex).toUpperCase\n\
    \            } else {\n                val index = alphabetMap(c.toLower)\n  \
    \              val encodedIndex = encodedAlphabetMap(alphabet(index))\n      \
    \          encodedAlphabet(encodedIndex)\n            }\n        })\n        encodedMessage",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                c.toUpper\n \
    \           }\n        }\n        message.map(encodeChar)", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet\
    \ = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x) + 2) %\
    \ alphabet.size) else x)\n        val encodedAlphabetMap = encodedAlphabet.zipWithIndex.toMap\n\
    \        val encodedMessage = message.map(x => if (vowels.contains(x.toLower))\
    \ encodedAlphabet(encodedAlphabetMap(x.toLower)) else x)\n        encodedMessage.map(x\
    \ => if (x.isUpper) x.toLower else x.toUpper).mkString", "        val vowels =\
    \ \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        def\
    \ encodeChar(c : Char) : Char = {\n            if (vowels.contains(c)) {\n   \
    \             val index = alphabet.indexOf(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else if (alphabet.contains(c)) {\n  \
    \              alphabet((alphabet.indexOf(c) + alphabet.length / 2) % alphabet.length)\n\
    \            } else {\n                c\n            }\n        }\n        message.map(encodeChar)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to\
    \ 'z'\n        val alphabetMap = alphabet.zip(alphabet.drop(2) ++ alphabet.take(2)).toMap\n\
    \        message.map(c => if (vowels.contains(c.toLower)) alphabetMap(c.toLower)\
    \ else c)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val nextIndex = (index + 2) % vowels.length\n               \
    \ vowels(nextIndex).toString\n            } else {\n                c.toString\n\
    \            }\n        })\n        encoded.mkString", "        val vowels = \"\
    aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val vowelsMap2 = vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageArray = message.toCharArray\n        for (i <- 0 until messageArray.length)\
    \ {\n            if (vowels.contains(messageArray(i))) {\n                val\
    \ index = vowelsMap(messageArray(i))\n                messageArray(i) = vowelsMap2((index\
    \ + 2) % 5)\n            }\n            else if (alphabet.contains(messageArray(i)))\
    \ {\n                val index = alphabetMap(messageArray(i))\n              \
    \  messageArray(i) = alphabetMap2((index + 2) % 26)\n            }\n        }\n\
    \        messageArray.mkString", "        val vowels = \"aeiou\"\n        val\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageMap = message.map(x => (x, alphabetMap(x.toLower))).toMap\n\
    \        val messageMap2 = messageMap.map(x => (x._1, if (vowelsMap.contains(x._2))\
    \ vowelsMap2((x._2 + 2) % 5) else alphabetMap2((x._2 + 2) % 26)))\n        messageMap2.map(x\
    \ => if (x._1.isUpper) x._2.toUpper else x._2).mkString", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val alphabetMap3\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap4\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap5\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap6\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap7\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap8\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap9\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap10\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap11\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap12\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap13\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap14\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap15\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap16\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap17\
    \ = alphabet.zipWithIndex.map", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = 'a' to 'z'\n        val alphabetMap = alphabet.zip(alphabet.drop(2)\
    \ ++ alphabet.take(2)).toMap\n        message.map(c => if (vowels.contains(c.toLower))\
    \ alphabetMap(c.toLower) else c)", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val nextVowel = (c\
    \ : Char) => {\n            val index = alphabet.indexOf(c)\n            val nextIndex\
    \ = (index + 2) % alphabet.length\n            alphabet(nextIndex)\n        }\n\
    \        val encodeChar = (c : Char) => {\n            if (vowels.contains(c))\
    \ nextVowel(c)\n            else if (c.isUpper) c.toLower\n            else c.toUpper\n\
    \        }\n        message.map(encodeChar)", "        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val map = Map[Char,\
    \ Char]()\n        for (i <- 0 until vowels.length) {\n            val index =\
    \ alphabet.indexOf(vowels(i))\n            val newIndex = (index + 2) % alphabet.length\n\
    \            map += (vowels(i) -> alphabet(newIndex))\n        }\n        message.map(x\
    \ => if (vowels.contains(x)) map(x) else x).map(x => if (x.isUpper) x.toLower\
    \ else x.toUpper).mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageMap = message.toLowerCase.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageMap2 = message.toLowerCase.zipWithIndex.toMap\n\
    \        val messageMap3 = message.toLowerCase.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap4 = message.toLowerCase.zipWithIndex.toMap\n        val\
    \ messageMap5 = message.toLowerCase.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap6 = message.toLowerCase.zipWithIndex.toMap\n        val\
    \ messageMap7 = message.toLowerCase.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap8 = message.toLowerCase.zipWithIndex.toMap\n        val\
    \ messageMap9 = message.toLowerCase.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap10 = message.toLowerCase.zipWithIndex.toMap\n        val\
    \ messageMap11 = message.toLowerCase.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap12 = message.toLowerCase.zipWithIndex.toMap\n        val\
    \ messageMap13 = message.toLowerCase.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap14 = message.toLowerCase.zipWithIndex.toMap\n        val\
    \ messageMap15 = message.toLowerCase.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap16 = message.toLowerCase.zipWithIndex.toMap\n        val\
    \ messageMap17 = message.toLowerCase.zipWithIndex.map(x", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ alphabet((index + 2) % alphabet.length)\n            } else {\n            \
    \    if (c.isUpper) c.toLower else c.toUpper\n            }\n        })\n    \
    \    encoded.mkString", "        val vowels = List('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val encodeMap = vowels.map(x => (x, alphabet((alphabetMap(x) + 2) % 26))).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) encodeMap(x.toLower)\
    \ else x)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x =>\
    \ (x._2, x._1)).toMap\n        val encoded = message.map(x => {\n            if\
    \ (vowels.contains(x.toLower)) {\n                val index = vowelsMap(x.toLower)\n\
    \                val newIndex = (index + 2) % 5\n                val newChar =\
    \ vowelsMap2(newIndex)\n                if (x.isUpper) newChar.toUpper else newChar\n\
    \            } else {\n                val index = alphabetMap(x.toLower)\n  \
    \              val newIndex = (index + 2) % 26\n                val newChar =\
    \ alphabetMap2(newIndex)\n                if (x.isUpper) newChar.toUpper else\
    \ newChar\n            }\n        })\n        encoded", "        val vowels =\
    \ Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toArray\n\
    \        message.map(c => if (vowels.contains(c)) alphabet((alphabet.indexOf(c)\
    \ + 2) % alphabet.length) else c).map(c => if (c.isUpper) c.toLower else c.toUpper)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap7 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap9 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap11 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap12 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap13 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap15 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap16 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap17 = alphabet.zipWithIndex.map", "        val vowels =\
    \ \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        var\
    \ encoded = \"\"\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ val newIndex = (index + 2) % alphabet.length\n                encoded += alphabet(newIndex)\n\
    \            } else {\n                encoded += c\n            }\n        }\n\
    \        encoded", "        val vowels = \"aeiou\"\n        val alphabet = \"\
    abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (vowelsMap.contains(c.toLower)) {\n                val\
    \ index = (vowelsMap(c.toLower) + 2) % 5\n                vowels(index).toString\n\
    \            } else if (alphabetMap.contains(c.toLower)) {\n                val\
    \ index = (alphabetMap(c.toLower) + 2) % 26\n                alphabet(index).toString\n\
    \            } else {\n                c.toString\n            }\n        })\n\
    \        encoded.mkString", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val newIndex = (index + 2) % vowels.length\n\
    \                vowels(newIndex).toString\n            } else if (alphabet.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex).toString\n\
    \            } else {\n                c.toString\n            }\n        })\n\
    \        encoded.mkString", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            val cLower = c.toLower\n            if (vowelsMap.contains(cLower))\
    \ {\n                val index = vowelsMap(cLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                val newVowel = vowels(newIndex)\n\
    \                if (c.isUpper) newVowel.toUpper else newVowel\n            }\
    \ else if (alphabetMap.contains(cLower)) {\n                val index = alphabetMap(cLower)\n\
    \                val newIndex = (index + 2) % alphabet.length\n              \
    \  val newLetter = alphabet(newIndex)\n                if (c.isUpper) newLetter.toUpper\
    \ else newLetter\n            } else c\n        })\n        encoded", "      \
    \  val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val encodedAlphabet = alphabet.map(x => {\n            if (vowels.contains(x))\
    \ {\n                val index = alphabetMap(x)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                x\n         \
    \   }\n        })\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => {\n            if (x.isUpper) {\n                encodedAlphabetMap(x.toLower).toUpper\n\
    \            } else {\n                encodedAlphabetMap(x)\n            }\n\
    \        })", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap3 = vowels.zipWithIndex.map(x =>\
    \ (x._2, (x._2 + 2) % 5)).toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap3 = alphabet.zipWithIndex.map(x\
    \ => (x._2, (x._2 + 2) % 26)).toMap\n        val messageMap = message.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageMap2 = message.zipWithIndex.map(x\
    \ => (x._2, x._1.toLower)).toMap\n        val messageMap3 = message.zipWithIndex.map(x\
    \ => (x._2, x._1.toUpper)).toMap\n        val messageMap4 = message.zipWithIndex.map(x\
    \ => (x._2, x._1.isUpper)).toMap\n        val messageMap5 = message.zipWithIndex.map(x\
    \ => (x._2, x._1.isLower)).toMap\n        val messageMap6 = message.zipWithIndex.map(x\
    \ => (x._2, x._1.isLetter)).toMap\n        val messageMap7 = message.zipWithIndex.map(x\
    \ => (x._2, x._1.isDigit)).toMap\n        val messageMap8 = message.zipWithIndex.map(x\
    \ => (x._2, x._1.isLetterOrDigit)).toMap\n        val messageMap9 = message.zipWithIndex.map(x\
    \ => (x._2, x._1.isWhitespace)).toMap\n        val messageMap10 = message.zipWithIndex.map(x\
    \ => (x._2, x._1.isSpaceChar)).toMap\n        val messageMap11 =", "        val\
    \ vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encodedVowels = vowels.map(c => alphabet((alphabetMap(c)\
    \ + 2) % 26))\n        val encodedVowelsMap = encodedVowels.zipWithIndex.toMap\n\
    \        val encodedAlphabet = alphabet.map(c => if (vowelsMap.contains(c)) encodedVowels(vowelsMap(c))\
    \ else c)\n        val encodedAlphabetMap = encodedAlphabet.zipWithIndex.toMap\n\
    \        message.map(c => if (alphabetMap.contains(c)) encodedAlphabet(alphabetMap(c))\
    \ else c)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMapReverse = alphabetMap.map(_.swap)\n\
    \        val vowelsMapReverse = vowelsMap.map(_.swap)\n        val messageList\
    \ = message.toList\n        val encodedList = messageList.map(c => {\n       \
    \     if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % 5\n                val newChar =\
    \ vowelsMapReverse(newIndex)\n                if (c.isUpper) newChar.toUpper else\
    \ newChar\n            } else {\n                val index = alphabetMap(c.toLower)\n\
    \                val newIndex = (index + 2) % 26\n                val newChar\
    \ = alphabetMapReverse(newIndex)\n                if (c.isUpper) newChar.toUpper\
    \ else newChar\n            }\n        })\n        encodedList.mkString", "  \
    \      val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val encodedAlphabet = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x)\
    \ + 2) % alphabet.size) else x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (x.isUpper) encodedAlphabetMap(x.toLower).toUpper\
    \ else encodedAlphabetMap(x))", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        def encodeChar(c : Char) : Char = {\n      \
    \      if (c.isUpper) {\n                val index = alphabetMap(c.toLower)\n\
    \                alphabetMap2(index).toUpper\n            } else if (vowels.contains(c))\
    \ {\n                val index = vowelsMap(c)\n                vowelsMap2((index\
    \ + 2) % 5)\n            } else {\n                c\n            }\n        }\n\
    \        message.map(encodeChar)", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower))\
    \ alphabetMap2(alphabetMap(x.toLower)) else x)", "        val vowels = \"aeiou\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val encoded =\
    \ message.map(c => if (vowels.contains(c.toLower)) {\n            val index =\
    \ alphabet.indexOf(c.toLower)\n            val newIndex = (index + 2) % alphabet.length\n\
    \            alphabet(newIndex)\n        } else if (c.isUpper) {\n           \
    \ c.toLower\n        } else {\n            c.toUpper\n        })\n        encoded",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val message2 = message.map(x => if (x.isUpper)\
    \ x.toLower else x)\n        val message3 = message2.map(x => if (vowelsMap.contains(x))\
    \ vowelsMap2((vowelsMap(x) + 2) % 5) else x)\n        val message4 = message3.map(x\
    \ => if (alphabetMap.contains(x)) alphabetMap2((alphabetMap(x) + 13) % 26) else\
    \ x)\n        val message5 = message4.map(x => if (x.isUpper) x.toLower else x)\n\
    \        val message6 = message5.map(x => if (x.isUpper) x.toLower else x)\n \
    \       val message7 = message6.map(x => if (x.isUpper) x.toLower else x)\n  \
    \      val message8 = message7.map(x => if (x.isUpper) x.toLower else x)\n   \
    \     val message9 = message8.map(x => if (x.isUpper) x.toLower else x)\n    \
    \    val message10 = message9.map(x => if (x.isUpper) x.toLower else x)\n    \
    \    val message11 = message10.map(x => if (x.isUpper) x.toLower else x)\n   \
    \     val message12 = message11.map(x => if (x.isUpper) x.toLower else x)\n  \
    \      val message13 = message12.map(x => if (x.isUpper) x.toLower else x)\n \
    \       val message14 = message13.map(x => if (x.isUpper) x.to", "        val\
    \ vowels = List('a', 'e', 'i', 'o', 'u')\n        message.map(c => if (vowels.contains(c.toLower))\
    \ vowels((vowels.indexOf(c.toLower) + 2) % vowels.length) else c).map(c => if\
    \ (c.isUpper) c.toLower else c.toUpper)", "        val vowels = Set('a', 'e',\
    \ 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val encodeMap\
    \ = Map(\n            'a' -> 'c',\n            'e' -> 'g',\n            'i' ->\
    \ 'k',\n            'o' -> 'q',\n            'u' -> 's'\n        )\n        message.map(c\
    \ => if (vowels.contains(c)) encodeMap(c) else c)", "        val vowels = \"aeiou\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n  \
    \          } else {\n                val index = alphabetMap(c.toLower)\n    \
    \            val newIndex = (index + 2) % alphabet.length\n                alphabet(newIndex).toUpper\n\
    \            }\n        })\n        encoded", "        var encoded = \"\"\n  \
    \      for (c <- message) {\n            if (c.isUpper) encoded += c.toLower\n\
    \            else if (c.isLower) encoded += c.toUpper\n            else encoded\
    \ += c\n        }\n        encoded", "        val vowels = List('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val encoded = message.map(c => {\n  \
    \          if (vowels.contains(c.toLower)) {\n                val index = alphabetMap(c.toLower)\n\
    \                val next = (index + 2) % alphabet.length\n                alphabet(next)\n\
    \            } else {\n                c\n            }\n        })\n        encoded.map(c\
    \ => {\n            if (c.isUpper) c.toLower else c.toUpper\n        }).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to\
    \ 'z'\n        val alphabetMap = alphabet.zip(alphabet.drop(2) ++ alphabet.take(2)).toMap\n\
    \        message.map(c => if (vowels.contains(c.toLower)) alphabetMap(c.toLower)\
    \ else c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString", "     \
    \   val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageArray = message.toLowerCase.toCharArray\n\
    \        for (i <- 0 until messageArray.length) {\n            if (vowels.contains(messageArray(i)))\
    \ {\n                val index = vowelsMap(messageArray(i))\n                val\
    \ newIndex = (index + 2) % 5\n                messageArray(i) = vowelsMap2(newIndex)\n\
    \            }\n            else {\n                val index = alphabetMap(messageArray(i))\n\
    \                val newIndex = (index + 2) % 26\n                messageArray(i)\
    \ = alphabetMap2(newIndex)\n            }\n        }\n        messageArray.mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowelsMap.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                val\
    \ newChar = vowels(newIndex)\n                if (c.isUpper) newChar.toUpper else\
    \ newChar\n            } else if (alphabetMap.contains(c.toLower)) {\n       \
    \         val index = alphabetMap(c.toLower)\n                val newIndex = (index\
    \ + 2) % alphabet.length\n                val newChar = alphabet(newIndex)\n \
    \               if (c.isUpper) newChar.toUpper else newChar\n            } else\
    \ c\n        })\n        encoded", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val encoded = message.toLowerCase.map(c\
    \ => if (vowels.contains(c)) alphabet((alphabet.indexOf(c) + 2) % alphabet.length)\
    \ else c).map(c => if (c.isLetter) if (c.isUpper) c.toLower else c.toUpper else\
    \ c)\n        encoded", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        message.map(c => {\n\
    \            if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toString\n\
    \            } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                alphabet(newIndex).toString\n            } else {\n         \
    \       c.toString\n            }\n        }).mkString", "        val vowels =\
    \ \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val vowelsMap2 = vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val sb = new StringBuilder\n        for (c <- message) {\n           \
    \ if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % 5\n                sb.append(vowelsMap2(newIndex).toUpper)\n\
    \            } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % 26\n\
    \                sb.append(alphabetMap2(newIndex).toUpper)\n            } else\
    \ sb.append(c)\n        }\n        sb.toString", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val vowels2 = Set('c', 'f', 'j', 'n', 'q')\n  \
    \      val vowels3 = Set('b', 'd', 'h', 'l', 'p', 'r', 't', 'v', 'x', 'z')\n \
    \       val vowels4 = Set('s', 'w', 'y')\n        val vowels5 = Set('g', 'k',\
    \ 'm')\n        val vowels6 = Set('a', 'e', 'i', 'o', 'u')\n        val vowels7\
    \ = Set('c', 'f', 'j', 'n', 'q')\n        val vowels8 = Set('b', 'd', 'h', 'l',\
    \ 'p', 'r', 't', 'v', 'x', 'z')\n        val vowels9 = Set('s', 'w', 'y')\n  \
    \      val vowels10 = Set('g', 'k', 'm')\n        val vowels11 = Set('a', 'e',\
    \ 'i', 'o', 'u')\n        val vowels12 = Set('c', 'f', 'j', 'n', 'q')\n      \
    \  val vowels13 = Set('b', 'd', 'h', 'l', 'p', 'r', 't', 'v', 'x', 'z')\n    \
    \    val vowels14 = Set('s', 'w', 'y')\n        val vowels15 = Set('g', 'k', 'm')\n\
    \        val vowels16 = Set('a', 'e', 'i', 'o', 'u')\n        val vowels17 = Set('c',\
    \ 'f', 'j', 'n', 'q')\n        val vowels18 = Set('b', 'd', 'h', 'l', 'p', 'r',\
    \ 't', 'v', 'x', 'z')\n        val vowels19 = Set('s', 'w', 'y')\n        val\
    \ vowels20 = Set('g', 'k', 'm')\n        val vowels21 = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val vowels22 = Set('c', 'f', 'j', '", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap3 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap4 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        message.map(x => if (vowels.contains(x))\
    \ alphabetMap3(alphabetMap(x)) else alphabetMap4(alphabetMap(x)))", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val encodedAlphabet = alphabet.drop(2) ++ alphabet.take(2)\n        val\
    \ encodedVowels = vowels.map(v => encodedAlphabet(alphabet.indexOf(v)))\n    \
    \    val encodedVowelsMap = vowels.zip(encodedVowels).toMap\n        message.map(c\
    \ => if (vowels.contains(c.toLower)) encodedVowelsMap(c.toLower) else c)", " \
    \       val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x =>\
    \ (x._2, x._1)).toMap\n        val vowelsMap3 = vowels.zipWithIndex.map(x => (x._2,\
    \ (x._2 + 2) % 5)).toMap\n        val messageMap = message.toLowerCase.map(x =>\
    \ (x, alphabetMap.getOrElse(x, vowelsMap.getOrElse(x, -1))))\n        val encodedMap\
    \ = messageMap.map(x => (x._1, if (x._2 == -1) x._1 else if (x._2 < 26) alphabetMap2((x._2\
    \ + 2) % 26) else vowelsMap2(vowelsMap3(x._2 - 26))))\n        val encodedMessage\
    \ = encodedMap.map(x => if (x._1.isUpper) x._2.toUpper else x._2).mkString\n \
    \       encodedMessage", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val alphabetMap2 =\
    \ alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val vowelsMap2 =\
    \ vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val result = new StringBuilder\n\
    \        for (c <- message) {\n            if (c.isUpper) {\n                if\
    \ (vowels.contains(c.toLower)) {\n                    val index = (vowelsMap(c.toLower)\
    \ + 2) % 5\n                    result += vowelsMap2(index).toUpper\n        \
    \        } else {\n                    val index = (alphabetMap(c.toLower) + 2)\
    \ % 26\n                    result += alphabetMap2(index).toUpper\n          \
    \      }\n            } else {\n                if (vowels.contains(c)) {\n  \
    \                  val index = (vowelsMap(c) + 2) % 5\n                    result\
    \ += vowelsMap2(index)\n                } else {\n                    val index\
    \ = (alphabetMap(c) + 2) % 26\n                    result += alphabetMap2(index)\n\
    \                }\n            }\n        }\n        result.toString", "    \
    \    val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x =>\
    \ (x._2, x._1)).toMap\n        def encodeChar(c : Char) : Char = {\n         \
    \   if (c.isUpper) {\n                if (vowels.contains(c.toLower)) {\n    \
    \                val index = vowelsMap(c.toLower)\n                    alphabetMap2((index\
    \ + 2) % alphabet.length).toUpper\n                } else {\n                \
    \    alphabetMap2(alphabetMap(c.toLower)).toUpper\n                }\n       \
    \     } else {\n                if (vowels.contains(c)) {\n                  \
    \  val index = vowelsMap(c)\n                    alphabetMap2((index + 2) % alphabet.length)\n\
    \                } else {\n                    alphabetMap2(alphabetMap(c))\n\
    \                }\n            }\n        }\n        message.map(encodeChar)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val i = alphabet.indexOf(c.toLower)\n                alphabet((i\
    \ + 2) % alphabet.length)\n            } else {\n                c\n         \
    \   }\n        })\n        encoded.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        def encodeChar(c : Char) : Char = {\n            val vowels = \"aeiou\"\
    \n            val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n            if (vowels.contains(c))\
    \ {\n                val index = alphabet.indexOf(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else if (alphabet.contains(c)) {\n  \
    \              alphabet((alphabet.indexOf(c) + alphabet.length / 2) % alphabet.length)\n\
    \            } else {\n                c\n            }\n        }\n        message.map(encodeChar)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val vowels2 = alphabet.zipWithIndex.filter(x => vowels.contains(x._1)).map(x\
    \ => (x._1, alphabet(x._2 + 2)))\n        val nonVowels = alphabet.zipWithIndex.filter(x\
    \ => !vowels.contains(x._1)).map(x => (x._1, alphabet(x._2 + 2)))\n        val\
    \ map = vowels2.toMap ++ nonVowels.toMap\n        message.map(x => map(x)).mkString",
  "        def encodeChar(c : Char) : Char = {\n            val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n            val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n            if (vowels.contains(c)) {\n                val index = alphabet.indexOf(c)\n\
    \                alphabet(index + 2)\n            } else if (c.isUpper) {\n  \
    \              c.toLower\n            } else {\n                c.toUpper\n  \
    \          }\n        }\n        message.map(encodeChar)", "        def encodeChar(c\
    \ : Char) : Char = {\n            if (c.isUpper) {\n                c.toLower\n\
    \            } else {\n                c.toUpper\n            }\n        }\n \
    \       def encodeVowel(c : Char) : Char = {\n            val vowels = \"aeiou\"\
    \n            if (vowels.contains(c)) {\n                val index = vowels.indexOf(c)\n\
    \                val next = (index + 2) % vowels.length\n                vowels(next)\n\
    \            } else {\n                c\n            }\n        }\n        message.map(encodeChar).map(encodeVowel)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val vowels2 = Set('c',\
    \ 'f', 'j', 'n', 'q')\n        val vowels3 = Set('b', 'd', 'h', 'l', 'p', 'r',\
    \ 't', 'v', 'x', 'z')\n        val vowels4 = Set('s', 'w', 'y')\n        val vowels5\
    \ = Set('g', 'k', 'm')\n        val vowels6 = Set('a', 'e', 'i', 'o', 'u')\n \
    \       val vowels7 = Set('c', 'f', 'j', 'n', 'q')\n        val vowels8 = Set('b',\
    \ 'd', 'h', 'l', 'p', 'r', 't', 'v', 'x', 'z')\n        val vowels9 = Set('s',\
    \ 'w', 'y')\n        val vowels10 = Set('g', 'k', 'm')\n        val vowels11 =\
    \ Set('a', 'e', 'i', 'o', 'u')\n        val vowels12 = Set('c', 'f', 'j', 'n',\
    \ 'q')\n        val vowels13 = Set('b', 'd', 'h', 'l', 'p', 'r', 't', 'v', 'x',\
    \ 'z')\n        val vowels14 = Set('s', 'w', 'y')\n        val vowels15 = Set('g',\
    \ 'k', 'm')\n        val vowels16 = Set('a', 'e', 'i', 'o', 'u')\n        val\
    \ vowels17 = Set('c', 'f', 'j', 'n', 'q')\n        val vowels18 = Set('b', 'd',\
    \ 'h', 'l', 'p', 'r', 't', 'v', 'x', 'z')\n        val vowels19 = Set('s', 'w',\
    \ 'y')\n        val vowels20 = Set('g', 'k', 'm')\n        val vowels21 = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val vowels22 = Set('c', 'f', 'j', '", "       \
    \ val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to 'z'\n\
    \        val alphabetMap = alphabet.zip(alphabet.drop(2) ++ alphabet.take(2)).toMap\n\
    \        message.map(c => if (vowels.contains(c.toLower)) alphabetMap(c.toLower)\
    \ else c)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val newAlphabet = alphabet.map(x => if (vowels.contains(x)) alphabetMap2((alphabetMap(x)\
    \ + 2) % 26) else x)\n        val alphabetMap3 = alphabet.zip(newAlphabet).toMap\n\
    \        message.map(x => if (x.isLower) alphabetMap3(x) else alphabetMap3(x.toLower).toUpper)",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetList = alphabet.toList\n  \
    \      val vowelsList = vowels.toList\n        def encodeChar(c : Char) : Char\
    \ = {\n            if (c.isUpper) {\n                alphabetList(alphabetMap(c.toLower)\
    \ + 2).toUpper\n            } else if (vowelsMap.contains(c)) {\n            \
    \    vowelsList(vowelsMap(c) + 2)\n            } else {\n                c\n \
    \           }\n        }\n        message.map(encodeChar)", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val alphabetMap3\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap4\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap5\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap6\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap7\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap8\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap9\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap10\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap11\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap12\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap13\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap14\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap15\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap16\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap17\
    \ = alphabet.zipWithIndex.map", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val next = c.toLower + 2\n                if (next > 'z')\
    \ {\n                    (next - 'z' + 'a' - 1).toChar\n                } else\
    \ {\n                    next.toChar\n                }\n            } else {\n\
    \                c\n            }\n        })\n        encoded.map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        def\
    \ encodeChar(c : Char) : Char = {\n            if (vowels.contains(c)) {\n   \
    \             val index = alphabet.indexOf(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else if (c.isUpper) {\n             \
    \   c.toLower\n            } else {\n                c.toUpper\n            }\n\
    \        }\n        message.map(encodeChar)", "        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x\
    \ => {\n            val index = alphabetMap(x)\n            if (vowels.contains(x))\
    \ {\n                val newIndex = (index + 2) % alphabet.length\n          \
    \      alphabet(newIndex)\n            } else {\n                x\n         \
    \   }\n        })\n        val encodedMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => {\n            val encoded = encodedMap(x.toLower)\n\
    \            if (x.isUpper) encoded.toUpper else encoded\n        })", "     \
    \   val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val vowelsMap = vowels.zipWithIndex.toMap\n        val encodedVowels = vowels.map(v\
    \ => {\n            val index = vowelsMap(v)\n            val nextIndex = (index\
    \ + 2) % vowels.length\n            vowels(nextIndex)\n        })\n        val\
    \ vowelsMapEncoded = vowels.zip(encodedVowels).toMap\n        val encodedAlphabet\
    \ = alphabet.map(c => {\n            if (vowels.contains(c)) {\n             \
    \   vowelsMapEncoded(c)\n            } else {\n                c\n           \
    \ }\n        })\n        val encodedAlphabetMap = encodedAlphabet.zipWithIndex.toMap\n\
    \        val encodedMessage = message.map(c => {\n            if (alphabet.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                val encodedIndex\
    \ = (index + encodedAlphabet.length / 2) % encodedAlphabet.length\n          \
    \      encodedAlphabet(encodedIndex)\n            } else {\n                c\n\
    \            }\n        })\n        encodedMessage", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x\
    \ => if (vowels.contains(x)) alphabet((alphabetMap(x) + 2) % alphabet.size) else\
    \ x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n \
    \       message.map(x => if (x.isUpper) encodedAlphabetMap(x.toLower).toUpper\
    \ else encodedAlphabetMap(x))", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map\
    \ { case (c, i) => (c, (i + 2) % alphabet.length) }.toMap\n        val alphabetMap3\
    \ = alphabet.zipWithIndex.map { case (c, i) => (c, (i + 2) % alphabet.length)\
    \ }.toMap\n        val alphabetMap4 = alphabet.zipWithIndex.map { case (c, i)\
    \ => (c, (i + 2) % alphabet.length) }.toMap\n        val alphabetMap5 = alphabet.zipWithIndex.map\
    \ { case (c, i) => (c, (i + 2) % alphabet.length) }.toMap\n        val alphabetMap6\
    \ = alphabet.zipWithIndex.map { case (c, i) => (c, (i + 2) % alphabet.length)\
    \ }.toMap\n        val alphabetMap7 = alphabet.zipWithIndex.map { case (c, i)\
    \ => (c, (i + 2) % alphabet.length) }.toMap\n        val alphabetMap8 = alphabet.zipWithIndex.map\
    \ { case (c, i) => (c, (i + 2) % alphabet.length) }.toMap\n        val alphabetMap9\
    \ = alphabet.zipWithIndex.map { case (c, i) => (c, (i + 2) % alphabet.length)\
    \ }.toMap\n        val alphabetMap10 = alphabet.zipWithIndex.map { case (c, i)\
    \ => (c, (i + 2) % alphabet.length) }.toMap\n        val alphabetMap11 = alphabet.zipWithIndex.map\
    \ { case (c, i) => (c, (i + 2) % alphabet.length) }.toMap\n        val alphabetMap12\
    \ = alphabet.zipWithIndex.map { case (c, i) => (c, (i + 2) % alphabet.length)\
    \ }.toMap\n        val alphabetMap13 = alphabet.zipWithIndex.map { case (c, i)\
    \ => (c, (", "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val\
    \ alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap7 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap9 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap11 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap12 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap13 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap15 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap16 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap17 = alphabet.zipWithIndex.map", "        val vowels =\
    \ \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n  \
    \          } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                alphabet(newIndex).toUpper\n            } else {\n          \
    \      c\n            }\n        })\n        encoded", "        var encodedMessage\
    \ = \"\"\n        for (c <- message) {\n            if (c.isUpper) {\n       \
    \         encodedMessage += c.toLower\n            } else if (c.isLower) {\n \
    \               encodedMessage += c.toUpper\n            } else {\n          \
    \      encodedMessage += c\n            }\n        }\n        encodedMessage",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.drop(2)\
    \ + alphabet.take(2)\n        val encodedVowels = vowels.drop(2) + vowels.take(2)\n\
    \        val encodedVowelsMap = encodedVowels.zipWithIndex.toMap\n        val\
    \ encodedAlphabetMap = encodedAlphabet.zipWithIndex.toMap\n        val encodedMessage\
    \ = message.map(c => {\n            if (vowels.contains(c.toLower)) {\n      \
    \          if (c.isUpper) encodedVowels(vowelsMap(c.toLower)).toUpper\n      \
    \          else encodedVowels(vowelsMap(c))\n            }\n            else {\n\
    \                if (c.isUpper) encodedAlphabet(alphabetMap(c.toLower)).toUpper\n\
    \                else encodedAlphabet(alphabetMap(c))\n            }\n       \
    \ })\n        encodedMessage", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val encodedIndex = (index + 2) % vowels.length\n\
    \                vowels(encodedIndex).toString\n            } else {\n       \
    \         val index = alphabetMap(c.toLower)\n                val encodedIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(encodedIndex).toString\n\
    \            }\n        })\n        encoded.mkString", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val nextIndex = (index + 2) % alphabet.length\n\
    \                alphabet(nextIndex)\n            } else {\n                c\n\
    \            }\n        })\n        encoded.map(c => if (c.isUpper) c.toLower\
    \ else c.toUpper).mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val encoded = message.map(x => {\n         \
    \   if (vowels.contains(x.toLower)) {\n                val index = alphabetMap(x.toLower)\n\
    \                alphabetMap2((index + 2) % 26)\n            } else {\n      \
    \          if (x.isUpper) alphabetMap2(alphabetMap(x.toLower)).toUpper else alphabetMap2(alphabetMap(x.toLower))\n\
    \            }\n        })\n        encoded.mkString", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower))\
    \ alphabetMap2(alphabetMap(x.toLower)) else x)", "        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val vowelsMap2 = vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val messageList = message.toList\n        val encodedList = messageList.map(x\
    \ => {\n            if (vowels.contains(x)) {\n                val index = vowelsMap(x)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowelsMap2(newIndex)\n\
    \            } else if (alphabet.contains(x)) {\n                val index = alphabetMap(x)\n\
    \                val newIndex = (index + 2) % alphabet.length\n              \
    \  alphabetMap2(newIndex)\n            } else {\n                x\n         \
    \   }\n        })\n        encodedList.mkString", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val vowels2 = Set('c', 'f', 'j', 'n', 'q')\n  \
    \      val alphabet = ('a' to 'z').toList\n        val alphabet2 = ('c' to 'z').toList\
    \ ::: ('a' to 'b').toList\n        val map = (alphabet zip alphabet2).toMap\n\
    \        message.map(c => if (vowels.contains(c)) map(c) else c).map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "        val vowels = List('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val vowelsMap2 = vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val vowelsMap3 = vowels.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 - 2, x._1)).toMap\n\
    \        val vowelsMap4 = vowels.zipWithIndex.map(x => (x._2 - 2, x._1)).toMap\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = vowelsMap(c)\n                val newIndex =\
    \ if (index + 2 > 4) index - 3 else index + 2\n                vowelsMap2(newIndex)\n\
    \            } else {\n                val index = alphabetMap(c)\n          \
    \      val newIndex = if (index + 2 > 25) index - 23 else index + 2\n        \
    \        alphabetMap2(newIndex)\n            }\n        }\n        message.map(x\
    \ => if (x.isUpper) encodeChar(x.toLower).toUpper else encodeChar(x))", "    \
    \    val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val encodedAlphabet = alphabet.map(c => if (vowels.contains(c)) alphabet((alphabetMap(c)\
    \ + 2) % alphabet.size) else c)\n        val encodedAlphabetMap = encodedAlphabet.zipWithIndex.toMap\n\
    \        message.map(c => if (vowels.contains(c)) encodedAlphabet(alphabetMap(c))\
    \ else c)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val mapping = Map[Char, Char]()\n        for (i <- 0 until alphabet.length)\
    \ {\n            val c = alphabet(i)\n            if (vowels.contains(c)) {\n\
    \                val next = alphabet((i + 2) % alphabet.length)\n            \
    \    mapping += (c -> next)\n            }\n        }\n        message.map(c =>\
    \ if (vowels.contains(c)) mapping(c) else c)", "        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ encodedAlphabet = alphabet.drop(2) ++ alphabet.take(2)\n        val encodedVowels\
    \ = vowels.map(x => encodedAlphabet(alphabet.indexOf(x)))\n        val encodedVowelsMap\
    \ = vowels.zip(encodedVowels).toMap\n        val encodedMessage = message.map(x\
    \ => if (vowels.contains(x.toLower)) encodedVowelsMap(x.toLower) else x)\n   \
    \     encodedMessage.map(x => if (x.isUpper) x.toLower else x.toUpper).mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n\
    \            } else {\n                c match {\n                    case c if\
    \ c.isUpper => alphabet(alphabetMap(c.toLower)).toUpper\n                    case\
    \ c if c.isLower => alphabet(alphabetMap(c)).toLower\n                    case\
    \ _ => c\n                }\n            }\n        })\n        encoded", "  \
    \      val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ alphabet((index + 2) % alphabet.length)\n            } else {\n            \
    \    c\n            }\n        })\n        encoded.mkString", "        val vowels\
    \ = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet\
    \ = alphabet.map(x => {\n            if (vowels.contains(x)) {\n             \
    \   val index = alphabetMap(x)\n                val nextIndex = if (index + 2\
    \ > alphabet.length - 1) (index + 2) % alphabet.length else index + 2\n      \
    \          alphabet(nextIndex)\n            } else x\n        })\n        val\
    \ encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n        message.map(x\
    \ => {\n            if (x.isUpper) encodedAlphabetMap(x.toLower).toUpper else\
    \ encodedAlphabetMap(x)\n        })", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap3 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap4 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap5 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap6 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap7 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap8 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap9 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap10 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap11 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap12 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap13 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap14 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap15 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap16 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap17 = alphabet.zipWithIndex.map",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x =>\
    \ (x._2, x._1)).toMap\n        val encoded = message.map(x => {\n            if\
    \ (vowels.contains(x.toLower)) {\n                val index = vowelsMap(x.toLower)\n\
    \                val newIndex = (index + 2) % 5\n                if (x.isUpper)\
    \ vowelsMap2(newIndex).toUpper else vowelsMap2(newIndex)\n            } else if\
    \ (alphabet.contains(x.toLower)) {\n                val index = alphabetMap(x.toLower)\n\
    \                val newIndex = (index + 2) % 26\n                if (x.isUpper)\
    \ alphabetMap2(newIndex).toUpper else alphabetMap2(newIndex)\n            } else\
    \ x\n        })\n        encoded", "        val vowels = \"aeiou\"\n        val\
    \ vowels2 = \"cdfghjklmnpqrstvwxyz\"\n        val vowels3 = \"bdfhjlnprtvxz\"\n\
    \        val vowels4 = \"aeiou\"\n        val vowels5 = \"cdfghjklmnpqrstvwxyz\"\
    \n        val vowels6 = \"bdfhjlnprtvxz\"\n        val vowels7 = \"aeiou\"\n \
    \       val vowels8 = \"cdfghjklmnpqrstvwxyz\"\n        val vowels9 = \"bdfhjlnprtvxz\"\
    \n        val vowels10 = \"aeiou\"\n        val vowels11 = \"cdfghjklmnpqrstvwxyz\"\
    \n        val vowels12 = \"bdfhjlnprtvxz\"\n        val vowels13 = \"aeiou\"\n\
    \        val vowels14 = \"cdfghjklmnpqrstvwxyz\"\n        val vowels15 = \"bdfhjlnprtvxz\"\
    \n        val vowels16 = \"aeiou\"\n        val vowels17 = \"cdfghjklmnpqrstvwxyz\"\
    \n        val vowels18 = \"bdfhjlnprtvxz\"\n        val vowels19 = \"aeiou\"\n\
    \        val vowels20 = \"cdfghjklmnpqrstvwxyz\"\n        val vowels21 = \"bdfhjlnprtvxz\"\
    \n        val vowels22 = \"aeiou\"\n        val vowels23 = \"cdfghjklmnpqrstvwxyz\"\
    \n        val vowels24 = \"bdfhjlnprtvxz\"\n        val vowels25 = \"aeiou\"\n\
    \        val vowels26 = \"cdfghjklmnpqrstvwxyz\"\n        val vowels27 = \"bdfhjlnprtvxz\"\
    \n        val vowels28 = \"aeiou\"\n        val vowels29 = \"cdfghjklmnpqrstvwxyz\"\
    \n", "        val vowels = \"aeiou\"\n        val vowels2 = \"cdfghjklmnpqrstvwxyz\"\
    \n        val vowels3 = \"bdfhjlnprtvxz\"\n        val vowels4 = \"aeiou\"\n \
    \       val vowels5 = \"cdfghjklmnpqrstvwxyz\"\n        val vowels6 = \"bdfhjlnprtvxz\"\
    \n        val vowels7 = \"aeiou\"\n        val vowels8 = \"cdfghjklmnpqrstvwxyz\"\
    \n        val vowels9 = \"bdfhjlnprtvxz\"\n        val vowels10 = \"aeiou\"\n\
    \        val vowels11 = \"cdfghjklmnpqrstvwxyz\"\n        val vowels12 = \"bdfhjlnprtvxz\"\
    \n        val vowels13 = \"aeiou\"\n        val vowels14 = \"cdfghjklmnpqrstvwxyz\"\
    \n        val vowels15 = \"bdfhjlnprtvxz\"\n        val vowels16 = \"aeiou\"\n\
    \        val vowels17 = \"cdfghjklmnpqrstvwxyz\"\n        val vowels18 = \"bdfhjlnprtvxz\"\
    \n        val vowels19 = \"aeiou\"\n        val vowels20 = \"cdfghjklmnpqrstvwxyz\"\
    \n        val vowels21 = \"bdfhjlnprtvxz\"\n        val vowels22 = \"aeiou\"\n\
    \        val vowels23 = \"cdfghjklmnpqrstvwxyz\"\n        val vowels24 = \"bdfhjlnprtvxz\"\
    \n        val vowels25 = \"aeiou\"\n        val vowels26 = \"cdfghjklmnpqrstvwxyz\"\
    \n        val vowels27 = \"bdfhjlnprtvxz\"\n        val vowels28 = \"aeiou\"\n\
    \        val vowels29 = \"cdfghjklmnpqrstvwxyz\"\n", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x\
    \ => if (vowels.contains(x)) alphabet((alphabetMap(x) + 2) % alphabet.length)\
    \ else x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (x.isUpper) encodedAlphabetMap(x.toLower).toUpper\
    \ else encodedAlphabetMap(x)).mkString", "        val vowels = \"aeiou\"\n   \
    \     val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                val newChar = vowels(newIndex)\n\
    \                if (c.isUpper) newChar.toUpper else newChar\n            } else\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                val newChar = alphabet(newIndex)\n\
    \                if (c.isUpper) newChar.toUpper else newChar\n            }\n\
    \        })\n        encoded", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val newIndex = (index + 2) % vowels.length\n\
    \                vowels(newIndex).toString\n            } else {\n           \
    \     val index = alphabetMap(c.toLower)\n                val newIndex = (index\
    \ + 2) % alphabet.length\n                alphabet(newIndex).toString\n      \
    \      }\n        })\n        encoded.mkString", "        val vowels = \"aeiou\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = for (c <- message) yield {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                val newChar = vowels(newIndex)\n\
    \                if (c.isUpper) newChar.toUpper else newChar\n            } else\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                val newChar = alphabet(newIndex)\n\
    \                if (c.isUpper) newChar.toUpper else newChar\n            }\n\
    \        }\n        encoded.mkString", "        val vowels = List('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x\
    \ => {\n            val index = alphabetMap(x)\n            val newIndex = (index\
    \ + 2) % alphabet.length\n            alphabet(newIndex)\n        })\n       \
    \ val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n        message.map(x\
    \ => {\n            if (vowels.contains(x.toLower)) {\n                encodedAlphabetMap(x.toLower)\n\
    \            } else {\n                x\n            }\n        })", "      \
    \  val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = for (c <- message) yield\
    \ {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val newIndex = (index + 2) % vowels.length\n\
    \                val newChar = vowels(newIndex)\n                if (c.isUpper)\
    \ newChar.toUpper else newChar\n            } else {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                val newChar = alphabet(newIndex)\n                if (c.isUpper)\
    \ newChar.toUpper else newChar\n            }\n        }\n        encoded.mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toArray\n        val alphabetMap = (alphabet zip alphabet.tail.tail).toMap\n\
    \        message.map(c => if (vowels.contains(c)) alphabetMap(c) else c).map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).mkString", "        val vowels =\
    \ \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val messageMap = message.zipWithIndex.toMap\n        val encoded = messageMap.map(x\
    \ => {\n            val letter = x._1\n            val index = x._2\n        \
    \    val lower = letter.toLower\n            val upper = letter.toUpper\n    \
    \        val isVowel = vowels.contains(lower)\n            val isLower = alphabet.contains(lower)\n\
    \            val isUpper = alphabet.contains(upper)\n            if (isVowel)\
    \ {\n                val vowelIndex = vowelsMap(lower)\n                val newVowelIndex\
    \ = (vowelIndex + 2) % vowels.length\n                val newVowel = vowels(newVowelIndex)\n\
    \                if (isLower) newVowel else newVowel.toUpper\n            } else\
    \ if (isLower) {\n                val newIndex = (alphabetMap(lower) + 2) % alphabet.length\n\
    \                alphabet(newIndex)\n            } else if (isUpper) {\n     \
    \           val newIndex = (alphabetMap(upper) + 2) % alphabet.length\n      \
    \          alphabet(newIndex).toUpper\n            } else letter\n        })\n\
    \        encoded.mkString", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap3 = vowels.zipWithIndex.map(x =>\
    \ (x._2, (x._2 + 2) % vowels.length)).toMap\n        val alphabetMap3 = alphabet.zipWithIndex.map(x\
    \ => (x._2, (x._2 + 2) % alphabet.length)).toMap\n        val messageMap = message.toLowerCase.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageMap2 = message.toLowerCase.zipWithIndex.map(x\
    \ => (x._2, if (vowelsMap.contains(x._1)) vowelsMap3(vowelsMap(x._1)) else (x._1\
    \ - 'a' + 2) % alphabet.length)).toMap\n        val messageMap3 = message.toLowerCase.zipWithIndex.map(x\
    \ => (x._2, if (vowelsMap.contains(x._1)) vowelsMap2(vowelsMap3(vowelsMap(x._1)))\
    \ else alphabetMap2(messageMap2(x._2)))).toMap\n        val messageMap4 = message.toLowerCase.zipWithIndex.map(x\
    \ => (x._2, if (vowelsMap.contains(x._1)) vowelsMap2(vowelsMap3(vowelsMap(x._1))).toUpper\
    \ else alphabetMap2(messageMap2(x._2)).toUpper)).toMap\n        val messageMap5\
    \ = message.toLowerCase.zipWithIndex.map(x => (x._2, if (vowelsMap.contains(x._1))\
    \ vowelsMap2(vowelsMap3(vowels", "        val vowels = \"aeiou\"\n        val\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        var encoded = \"\"\n    \
    \    for (c <- message) {\n            if (vowels.contains(c.toLower)) {\n   \
    \             val index = alphabet.indexOf(c.toLower)\n                encoded\
    \ += alphabet((index + 2) % alphabet.length)\n            } else {\n         \
    \       encoded += c\n            }\n        }\n        encoded", "        val\
    \ vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.drop(2)\
    \ + alphabet.take(2)\n        val encodedVowels = vowels.drop(2) + vowels.take(2)\n\
    \        val encodedVowelsMap = encodedVowels.zipWithIndex.toMap\n        val\
    \ encodedAlphabetMap = encodedAlphabet.zipWithIndex.toMap\n        val encodedMessage\
    \ = new StringBuilder\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                encodedMessage.append(encodedVowels(vowelsMap(c.toLower)))\n\
    \            } else {\n                encodedMessage.append(encodedAlphabet(alphabetMap(c.toLower)))\n\
    \            }\n        }\n        encodedMessage.toString", "        val vowels\
    \ = Array('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toArray\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encoded =\
    \ message.map(c => {\n            if (vowels.contains(c.toLower)) {\n        \
    \        val index = alphabetMap(c.toLower)\n                val newIndex = (index\
    \ + 2) % alphabet.length\n                alphabet(newIndex)\n            } else\
    \ {\n                c\n            }\n        })\n        encoded.map(c => {\n\
    \            if (c.isUpper) c.toLower else c.toUpper\n        }).mkString", " \
    \       val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val next = (index + 2) % vowels.length\n                vowels(next).toString\n\
    \            } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val next = (index + 2) % alphabet.length\n\
    \                alphabet(next).toString\n            } else {\n             \
    \   c.toString\n            }\n        })\n        encoded.mkString", "      \
    \  val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x =>\
    \ (x._2, x._1)).toMap\n        def encodeChar(c : Char) : Char = {\n         \
    \   val c2 = if (c.isUpper) c.toLower else c\n            if (vowels.contains(c2))\
    \ {\n                val index = vowelsMap(c2)\n                val index2 = (index\
    \ + 2) % vowels.length\n                val c3 = vowelsMap2(index2)\n        \
    \        if (c.isUpper) c3.toUpper else c3\n            } else {\n           \
    \     val index = alphabetMap(c2)\n                val index2 = (index + 2) %\
    \ alphabet.length\n                val c3 = alphabetMap2(index2)\n           \
    \     if (c.isUpper) c3.toUpper else c3\n            }\n        }\n        message.map(encodeChar)",
  "        var result = \"\"\n        for (c <- message) {\n            if (c.isUpper)\
    \ {\n                result += c.toLower\n            } else if (c.isLower) {\n\
    \                result += c.toUpper\n            } else {\n                result\
    \ += c\n            }\n        }\n        result", "        var encoded = \"\"\
    \n        for (c <- message) {\n            if (c.isUpper) {\n               \
    \ encoded += c.toLower\n            } else if (c.isLower) {\n                encoded\
    \ += c.toUpper\n            } else {\n                encoded += c\n         \
    \   }\n        }\n        encoded", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toArray\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val nextVowelMap = alphabet.zipWithIndex.filter(x\
    \ => vowels.contains(x._1)).map(x => (x._1, alphabetMap2(x._2 + 2))).toMap\n \
    \       val nextVowelMap2 = alphabet.zipWithIndex.filter(x => vowels.contains(x._1)).map(x\
    \ => (x._1, alphabetMap2(x._2 + 2))).toMap\n        val nextVowelMap3 = alphabet.zipWithIndex.filter(x\
    \ => vowels.contains(x._1)).map(x => (x._1, alphabetMap2(x._2 + 2))).toMap\n \
    \       val nextVowelMap4 = alphabet.zipWithIndex.filter(x => vowels.contains(x._1)).map(x\
    \ => (x._1, alphabetMap2(x._2 + 2))).toMap\n        val nextVowelMap5 = alphabet.zipWithIndex.filter(x\
    \ => vowels.contains(x._1)).map(x => (x._1, alphabetMap2(x._2 + 2))).toMap\n \
    \       val nextVowelMap6 = alphabet.zipWithIndex.filter(x => vowels.contains(x._1)).map(x\
    \ => (x._1, alphabetMap2(x._2 + 2))).toMap\n        val nextVowelMap7 = alphabet.zipWithIndex.filter(x\
    \ => vowels.contains(x._1)).map(x => (x._1, alphabetMap2(x._2 + 2))).toMap\n \
    \       val nextVowelMap8 = alphabet.zipWithIndex.filter(x => vowels.contains(x._1)).map(x\
    \ => (x._1, alphabetMap2(x._2 + 2))).toMap\n        val nextVowelMap9 = alphabet.zipWithIndex.filter(x",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x =>\
    \ (x._2, x._1)).toMap\n        val alphabetMap3 = alphabet.zipWithIndex.map(x\
    \ => (x._1, x._2)).toMap\n        val vowelsMap3 = vowels.zipWithIndex.map(x =>\
    \ (x._1, x._2)).toMap\n        val alphabetMap4 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap4 = vowels.zipWithIndex.map(x =>\
    \ (x._2, x._1)).toMap\n        val alphabetMap5 = alphabet.zipWithIndex.map(x\
    \ => (x._1, x._2)).toMap\n        val vowelsMap5 = vowels.zipWithIndex.map(x =>\
    \ (x._1, x._2)).toMap\n        val alphabetMap6 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap6 = vowels.zipWithIndex.map(x =>\
    \ (x._2, x._1)).toMap\n        val alphabetMap7 = alphabet.zipWithIndex.map(x\
    \ => (x._1, x._2)).toMap\n        val vowelsMap7 = vowels.zipWithIndex.map(x =>\
    \ (x._1, x._2)).toMap\n        val alphabetMap8 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap8 = vowels.zipWithIndex.map(x =>\
    \ (x._2, x._1)).toMap\n        val alphabetMap9 = alphabet.zipWithIndex.map(x\
    \ => (x._1, x._2)).toMap\n        val vowelsMap9 = vowels.zipWithIndex.map", " \
    \       val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toArray\n        val encoded = message.map(c => {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabet.indexOf(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                if (c.isUpper)\
    \ c.toLower else c.toUpper\n            }\n        })\n        encoded.mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                val\
    \ newVowel = vowels(newIndex)\n                if (c.isUpper) newVowel.toUpper\
    \ else newVowel\n            } else {\n                val index = alphabetMap(c.toLower)\n\
    \                val newIndex = (index + 2) % alphabet.length\n              \
    \  val newLetter = alphabet(newIndex)\n                if (c.isUpper) newLetter.toUpper\
    \ else newLetter\n            }\n        })\n        encoded", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._2, x._1))\n        val alphabetMap3\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2, x._1))\n        val alphabetMap4\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2, x._1))\n        val alphabetMap5\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2, x._1))\n        val alphabetMap6\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2, x._1))\n        val alphabetMap7\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2, x._1))\n        val alphabetMap8\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2, x._1))\n        val alphabetMap9\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2, x._1))\n        val alphabetMap10\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2, x._1))\n        val alphabetMap11\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2, x._1))\n        val alphabetMap12\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2, x._1))\n        val alphabetMap13\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2, x._1))\n        val alphabetMap14\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2, x._1))\n        val alphabetMap15\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2, x._1))\n        val alphabetMap16\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._", "        val vowels = \"aeiou\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                val newChar = vowels(newIndex)\n\
    \                if (c.isUpper) newChar.toUpper else newChar\n            } else\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                val newChar = alphabet(newIndex)\n\
    \                if (c.isUpper) newChar.toUpper else newChar\n            }\n\
    \        })\n        encoded", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val newIndex = (index + 2) % vowels.length\n\
    \                vowels(newIndex).toUpper\n            } else {\n            \
    \    if (c.isUpper) alphabet(alphabetMap(c.toLower)).toUpper\n               \
    \ else alphabet(alphabetMap(c.toLower))\n            }\n        })\n        encoded",
  "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val encodedAlphabet = alphabet.map(x => {\n            val index = alphabetMap(x)\n\
    \            val newIndex = if (index + 2 > alphabet.length - 1) index + 2 - alphabet.length\
    \ else index + 2\n            alphabet(newIndex)\n        })\n        val encodedAlphabetMap\
    \ = alphabet.zip(encodedAlphabet).toMap\n        message.map(x => {\n        \
    \    if (vowels.contains(x.toLower)) {\n                if (x.isUpper) encodedAlphabetMap(x.toLower).toUpper\n\
    \                else encodedAlphabetMap(x)\n            }\n            else {\n\
    \                if (x.isUpper) x.toLower\n                else x.toUpper\n  \
    \          }\n        })", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val encodedAlphabet = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x)\
    \ + 2) % alphabet.size) else x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (x.isUpper) encodedAlphabetMap(x.toLower).toUpper\
    \ else encodedAlphabetMap(x))", "        val vowels = List('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x =>\
    \ if (vowels.contains(x)) alphabet((alphabetMap(x) + 2) % 26) else x)\n      \
    \  val encodedMap = alphabet.zip(encodedAlphabet).toMap\n        message.map(x\
    \ => if (x.isUpper) encodedMap(x.toLower).toUpper else encodedMap(x))", "    \
    \    val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val newMessage = message.map(x => {\n      \
    \      if (vowels.contains(x.toLower)) {\n                val index = vowelsMap(x.toLower)\n\
    \                val newIndex = (index + 2) % 5\n                val newChar =\
    \ vowelsMap2(newIndex)\n                if (x.isUpper) newChar.toUpper else newChar\n\
    \            } else {\n                val index = alphabetMap(x.toLower)\n  \
    \              val newIndex = (index + 2) % 26\n                val newChar =\
    \ alphabetMap2(newIndex)\n                if (x.isUpper) newChar.toUpper else\
    \ newChar\n            }\n        })\n        newMessage", "        val vowels\
    \ = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n       \
    \ val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val nextIndex\
    \ = (index + 2) % vowels.length\n                val nextChar = vowels(nextIndex)\n\
    \                if (c.isUpper) nextChar.toUpper else nextChar\n            }\
    \ else {\n                val index = alphabetMap(c.toLower)\n               \
    \ val nextIndex = (index + 2) % alphabet.length\n                val nextChar\
    \ = alphabet(nextIndex)\n                if (c.isUpper) nextChar.toUpper else\
    \ nextChar\n            }\n        })\n        encoded", "        val vowels =\
    \ \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encodedAlphabet = alphabet.tail + alphabet.head\n        val encodedVowels\
    \ = vowels.tail + vowels.head\n        val encodedAlphabetMap = encodedAlphabet.zipWithIndex.toMap\n\
    \        val encodedVowelsMap = encodedVowels.zipWithIndex.toMap\n        val\
    \ encodedMessage = message.map(c => {\n            if (alphabetMap.contains(c.toLower))\
    \ {\n                if (c.isUpper) encodedAlphabet(alphabetMap(c.toLower)).toUpper\n\
    \                else encodedAlphabet(alphabetMap(c.toLower))\n            }\n\
    \            else if (vowelsMap.contains(c.toLower)) {\n                if (c.isUpper)\
    \ encodedVowels(vowelsMap(c.toLower)).toUpper\n                else encodedVowels(vowelsMap(c.toLower))\n\
    \            }\n            else c\n        })\n        encodedMessage", "   \
    \     val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val nextIndex = (index + 2) % vowels.length\n               \
    \ val nextVowel = vowels(nextIndex)\n                if (c.isUpper) nextVowel.toUpper\
    \ else nextVowel\n            } else {\n                val index = alphabetMap(c.toLower)\n\
    \                val nextIndex = (index + 2) % alphabet.length\n             \
    \   val nextLetter = alphabet(nextIndex)\n                if (c.isUpper) nextLetter.toUpper\
    \ else nextLetter\n            }\n        })\n        encoded", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet\
    \ = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x) + 2) %\
    \ alphabet.size) else x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (x.isLower) encodedAlphabetMap(x) else encodedAlphabetMap(x.toLower).toUpper)",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageMap = message.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageMap2 = message.zipWithIndex.toMap\n\
    \        val messageMap3 = message.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap4 = message.zipWithIndex.toMap\n        val messageMap5\
    \ = message.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val messageMap6\
    \ = message.zipWithIndex.toMap\n        val messageMap7 = message.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageMap8 = message.zipWithIndex.toMap\n\
    \        val messageMap9 = message.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap10 = message.zipWithIndex.toMap\n        val messageMap11\
    \ = message.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val messageMap12\
    \ = message.zipWithIndex.toMap\n        val messageMap13 = message.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageMap14 = message.zipWithIndex.toMap\n\
    \        val messageMap15 = message.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageMap16 = message.zipWithIndex.toMap\n        val messageMap17\
    \ = message.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val messageMap18\
    \ = message.zipWithIndex.toMap\n        val messageMap19", "        val vowels\
    \ = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n       \
    \ val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val alphabetMapReverse = alphabetMap.map(_.swap)\n        val vowelsMapReverse\
    \ = vowelsMap.map(_.swap)\n        val encoded = message.map(x => {\n        \
    \    if (vowels.contains(x.toLower)) {\n                val index = vowelsMap(x.toLower)\n\
    \                val newIndex = (index + 2) % 5\n                val newChar =\
    \ vowelsMapReverse(newIndex)\n                if (x.isUpper) newChar.toUpper else\
    \ newChar\n            } else {\n                val index = alphabetMap(x.toLower)\n\
    \                val newIndex = (index + 2) % 26\n                val newChar\
    \ = alphabetMapReverse(newIndex)\n                if (x.isUpper) newChar.toUpper\
    \ else newChar\n            }\n        })\n        encoded", "        val vowels\
    \ = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n       \
    \ val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encodedAlphabet = alphabet.drop(2) + alphabet.take(2)\n        val\
    \ encodedVowels = vowels.drop(2) + vowels.take(2)\n        val encodedVowelsMap\
    \ = encodedVowels.zipWithIndex.toMap\n        val encodedAlphabetMap = encodedAlphabet.zipWithIndex.toMap\n\
    \        val encodedMessage = message.map(c => {\n            if (vowelsMap.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                if (c.isUpper)\
    \ encodedVowels(index).toUpper else encodedVowels(index)\n            } else {\n\
    \                val index = alphabetMap(c.toLower)\n                if (c.isUpper)\
    \ encodedAlphabet(index).toUpper else encodedAlphabet(index)\n            }\n\
    \        })\n        encodedMessage", "        val vowels = \"aeiouAEIOU\"\n \
    \       val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x => if (vowels.contains(x))\
    \ alphabetMap2(alphabetMap(x.toLower)) else x)", "        val vowels = \"aeiou\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encodedAlphabet = alphabet.drop(2) + alphabet.take(2)\n        val\
    \ encodedVowels = vowels.drop(2) + vowels.take(2)\n        val encodedVowelsMap\
    \ = encodedVowels.zipWithIndex.toMap\n        val encodedAlphabetMap = encodedAlphabet.zipWithIndex.toMap\n\
    \        val encodedMessage = message.map(c => if (vowelsMap.contains(c.toLower))\
    \ encodedVowels(vowelsMap(c.toLower)) else if (alphabetMap.contains(c.toLower))\
    \ encodedAlphabet(alphabetMap(c.toLower)) else c)\n        encodedMessage", " \
    \       val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val encodedAlphabet = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x)\
    \ + 2) % alphabet.size) else x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (x.isUpper) encodedAlphabetMap(x.toLower).toUpper\
    \ else encodedAlphabetMap(x))", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toArray\n        val map = Map('a'\
    \ -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 's')\n        message.map(c\
    \ => if (vowels.contains(c)) map(c) else c).map(c => if (c.isUpper) c.toLower\
    \ else c.toUpper).mkString", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encodedVowels\
    \ = vowels.map(c => {\n            val index = vowelsMap(c)\n            val newIndex\
    \ = (index + 2) % vowels.length\n            vowels(newIndex)\n        })\n  \
    \      val encodedVowelsMap = vowels.zip(encodedVowels).toMap\n        message.map(c\
    \ => {\n            if (vowels.contains(c)) {\n                encodedVowelsMap(c)\n\
    \            } else if (alphabet.contains(c)) {\n                val index = alphabetMap(c)\n\
    \                val newIndex = (index + 2) % alphabet.length\n              \
    \  alphabet(newIndex)\n            } else {\n                c\n            }\n\
    \        })", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val\
    \ alphabet = ('a' to 'z').toList\n        message.map(c => if (vowels.contains(c))\
    \ alphabet((alphabet.indexOf(c) + 2) % alphabet.length) else c).map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper)", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encodedVowels\
    \ = vowels.map(c => {\n            val index = vowelsMap(c)\n            val newIndex\
    \ = (index + 2) % vowels.length\n            vowels(newIndex)\n        })\n  \
    \      val vowelsEncodedMap = vowels.zip(encodedVowels).toMap\n        message.map(c\
    \ => {\n            if (vowels.contains(c)) {\n                vowelsEncodedMap(c)\n\
    \            } else {\n                val index = alphabetMap(c.toLower)\n  \
    \              val newIndex = (index + 2) % alphabet.length\n                val\
    \ newChar = alphabet(newIndex)\n                if (c.isUpper) newChar.toUpper\
    \ else newChar\n            }\n        })", "        val vowels = \"aeiou\"\n\
    \        val encoded = message.map(c => if (vowels.contains(c.toLower)) vowels((vowels.indexOf(c.toLower)\
    \ + 2) % vowels.length) else c)\n        encoded.map(c => if (c.isUpper) c.toLower\
    \ else c.toUpper).mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toArray\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c)) {\n                val index = alphabet.indexOf(c)\n\
    \                alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                c\n            }\n        })\n        encoded.map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "        val vowels = List('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        def encodeChar(c\
    \ : Char) : Char = {\n            if (vowels.contains(c)) {\n                val\
    \ index = alphabet.indexOf(c)\n                alphabet((index + 2) % alphabet.length)\n\
    \            } else if (c.isUpper) {\n                c.toLower\n            }\
    \ else {\n                c.toUpper\n            }\n        }\n        message.map(encodeChar)",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toString\n\
    \            } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                alphabet(newIndex).toString\n            } else {\n         \
    \       c.toString\n            }\n        })\n        encoded.mkString", "  \
    \      var result = \"\"\n        for (c <- message) {\n            if (c.isUpper)\
    \ {\n                result += c.toLower\n            } else if (c.isLower) {\n\
    \                result += c.toUpper\n            } else {\n                result\
    \ += c\n            }\n        }\n        result", "        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower))\
    \ alphabetMap2(alphabetMap(x.toLower)) else x)", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \        message.map(c => if (vowels.contains(c.toLower)) alphabet((alphabet.indexOf(c.toLower)\
    \ + 2) % alphabet.length) else c)", "        val vowels = \"aeiou\"\n        val\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabet2 = alphabet\
    \ + alphabet\n        val alphabet3 = alphabet2 + alphabet2\n        val alphabet4\
    \ = alphabet3 + alphabet3\n        val alphabet5 = alphabet4 + alphabet4\n   \
    \     val alphabet6 = alphabet5 + alphabet5\n        val alphabet7 = alphabet6\
    \ + alphabet6\n        val alphabet8 = alphabet7 + alphabet7\n        val alphabet9\
    \ = alphabet8 + alphabet8\n        val alphabet10 = alphabet9 + alphabet9\n  \
    \      val alphabet11 = alphabet10 + alphabet10\n        val alphabet12 = alphabet11\
    \ + alphabet11\n        val alphabet13 = alphabet12 + alphabet12\n        val\
    \ alphabet14 = alphabet13 + alphabet13\n        val alphabet15 = alphabet14 +\
    \ alphabet14\n        val alphabet16 = alphabet15 + alphabet15\n        val alphabet17\
    \ = alphabet16 + alphabet16\n        val alphabet18 = alphabet17 + alphabet17\n\
    \        val alphabet19 = alphabet18 + alphabet18\n        val alphabet20 = alphabet19\
    \ + alphabet19\n        val alphabet21 = alphabet20 + alphabet20\n        val\
    \ alphabet22 = alphabet21 + alphabet21\n        val alphabet23 = alphabet22 +\
    \ alphabet22\n        val alphabet24 = alphabet23 + alphabet23\n        val alphabet25\
    \ = alphabet24 + alphabet24\n        val alphabet26 = alphabet25 + alphabet25\n\
    \        val alphabet27 = alphabet26 + alphabet26\n        val alphabet28 = alphabet27\
    \ + alphabet27\n        val alphabet29 = alphabet28 + alphabet28\n        val\
    \ alphabet30 = alphabet29 + alphabet29\n        val alphabet31 = alphabet30 +\
    \ alphabet30\n        val alphabet32 = alphabet31 + alphabet31\n        val alphabet33\
    \ = alphabet32 + alphabet32\n        val alphabet34 = alphabet33 + alphabet33\n\
    \        val alphabet35 = alphabet34 + alphabet34\n        val alphabet36 = alphabet35\
    \ + alphabet35\n        val alphabet37 = alphabet36 + alphabet36\n        val\
    \ alphabet38 = alphabet37 + alphabet37\n        val alphabet39 = alphabet38 +\
    \ alphabet38\n        val alphabet40 = alphabet39 + alphabet39\n        val alphabet41\
    \ = alphabet40 + alphabet40\n        val alphabet42 = alphabet41 + alphabet41\n\
    \        val alphabet43 = alphabet42 + alphabet42\n        val alphabet44 = alphabet43\
    \ + alphabet43\n        val alphabet45 = alphabet44 +", "        val vowels =\
    \ \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val vowelsMap2 = vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val result = new StringBuilder\n        for (c <- message) {\n       \
    \     if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                if (index == 4) {\n                    result += alphabetMap2(0)\n\
    \                } else {\n                    result += alphabetMap2(index +\
    \ 2)\n                }\n            } else if (alphabet.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                if (index\
    \ == 25) {\n                    result += alphabetMap2(0)\n                } else\
    \ {\n                    result += alphabetMap2(index + 1)\n                }\n\
    \            } else {\n                result += c\n            }\n        }\n\
    \        result.toString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val encodeMap = Map('a' ->\
    \ 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 's')\n        val encodeMap2\
    \ = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 's')\n        val\
    \ encodeMap3 = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 's')\n\
    \        val encodeMap4 = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q',\
    \ 'u' -> 's')\n        val encodeMap5 = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k',\
    \ 'o' -> 'q', 'u' -> 's')\n        val encodeMap6 = Map('a' -> 'c', 'e' -> 'g',\
    \ 'i' -> 'k', 'o' -> 'q', 'u' -> 's')\n        val encodeMap7 = Map('a' -> 'c',\
    \ 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 's')\n        val encodeMap8 = Map('a'\
    \ -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 's')\n        val encodeMap9\
    \ = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 's')\n        val\
    \ encodeMap10 = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 's')\n\
    \        val encodeMap11 = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q',\
    \ 'u' -> 's')\n        val encode", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        message.map(c => {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else if (c.isUpper) {\n             \
    \   c.toLower\n            } else {\n                c.toUpper\n            }\n\
    \        })", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        def encodeChar(c : Char) : Char = {\n      \
    \      val index = alphabetMap(c.toLower)\n            val newIndex = if (vowels.contains(c.toLower))\
    \ (index + 2) % 26 else index\n            if (c.isUpper) alphabetMap2(newIndex).toUpper\
    \ else alphabetMap2(newIndex)\n        }\n        message.map(encodeChar)", " \
    \       val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(x => {\n    \
    \        if (vowels.contains(x.toLower)) {\n                val index = vowelMap(x.toLower)\n\
    \                val newIndex = (index + 2) % 5\n                vowels(newIndex).toUpper\n\
    \            } else {\n                if (x.isUpper) {\n                    alphabet(alphabetMap(x.toLower)).toUpper\n\
    \                } else {\n                    alphabet(alphabetMap(x)).toLower\n\
    \                }\n            }\n        })\n        encoded", "        val\
    \ vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ alphabet((index + 2) % alphabet.length)\n            } else {\n            \
    \    c\n            }\n        })\n        encoded.map(c => if (c.isUpper) c.toLower\
    \ else c.toUpper).mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap7 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap9 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap11 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap12 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap13 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap15 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap16 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap17 = alphabet.zipWithIndex.map", "        val vowels =\
    \ Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        def encodeChar(c : Char) : Char = {\n            if (c.isUpper) c.toLower\n\
    \            else if (c.isLower) c.toUpper\n            else if (vowels.contains(c))\
    \ {\n                val index = alphabet.indexOf(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            }\n            else c\n        }\n    \
    \    message.map(encodeChar)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        message.map(c => if (vowels.contains(c.toLower)) {\n            val next\
    \ = c.toLower + 2\n            if (next > 'z') {\n                (next - 'z'\
    \ + 'a' - 1).toChar\n            } else {\n                next.toChar\n     \
    \       }\n        } else {\n            c\n        }).map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        def encodeChar(c : Char) : Char = {\n      \
    \      if (vowels.contains(c)) alphabetMap2((alphabetMap(c) + 2) % 26)\n     \
    \       else if (c.isUpper) c.toLower\n            else c.toUpper\n        }\n\
    \        message.map(encodeChar)", "        val vowels = \"aeiou\"\n        val\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val alphabetMap2 =\
    \ alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val vowelsMap2 =\
    \ vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val result = message.map(x\
    \ => if (vowels.contains(x.toLower)) {\n            val index = vowelsMap(x.toLower)\n\
    \            val newIndex = (index + 2) % 5\n            val newChar = vowelsMap2(newIndex)\n\
    \            if (x.isUpper) newChar.toUpper else newChar\n        } else {\n \
    \           val index = alphabetMap(x.toLower)\n            val newIndex = (index\
    \ + 2) % 26\n            val newChar = alphabetMap2(newIndex)\n            if\
    \ (x.isUpper) newChar.toUpper else newChar\n        })\n        result", "   \
    \     val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val encodedAlphabet = alphabet.map(x => {\n            if (vowels.contains(x))\
    \ {\n                val index = alphabetMap(x)\n                val nextIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(nextIndex)\n     \
    \       } else {\n                x\n            }\n        })\n        val encodedAlphabetMap\
    \ = alphabet.zip(encodedAlphabet).toMap\n        message.map(x => {\n        \
    \    if (x.isUpper) {\n                encodedAlphabetMap(x.toLower).toUpper\n\
    \            } else {\n                encodedAlphabetMap(x)\n            }\n\
    \        })", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.drop(2)\
    \ + alphabet.take(2)\n        val encodedVowels = vowels.drop(2) + vowels.take(2)\n\
    \        val encodedVowelsMap = encodedVowels.zipWithIndex.toMap\n        val\
    \ encodedAlphabetMap = encodedAlphabet.zipWithIndex.toMap\n        val encodedMessage\
    \ = message.map(c => {\n            if (vowels.contains(c.toLower)) {\n      \
    \          if (c.isUpper) {\n                    encodedVowels(encodedVowelsMap(c.toLower.toString)).toUpper\n\
    \                } else {\n                    encodedVowels(encodedVowelsMap(c.toLower.toString))\n\
    \                }\n            } else {\n                if (c.isUpper) {\n \
    \                   encodedAlphabet(encodedAlphabetMap(c.toLower.toString)).toUpper\n\
    \                } else {\n                    encodedAlphabet(encodedAlphabetMap(c.toLower.toString))\n\
    \                }\n            }\n        })\n        encodedMessage", "    \
    \    val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to\
    \ 'z'\n        val alphabetMap = alphabet.zip(alphabet.tail ++ List('a')).toMap\n\
    \        message.map(c => if (vowels.contains(c)) alphabetMap(c) else c).map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).mkString", "        val vowels =\
    \ \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val\
    \ encoded = message.map(c => {\n            if (vowels.contains(c.toLower)) {\n\
    \                val index = (vowels.indexOf(c.toLower) + 2) % 5\n           \
    \     if (c.isUpper) vowels(index).toUpper else vowels(index)\n            } else\
    \ if (alphabet.contains(c.toLower)) {\n                val index = (alphabet.indexOf(c.toLower)\
    \ + 2) % 26\n                if (c.isUpper) alphabet(index).toUpper else alphabet(index)\n\
    \            } else c\n        })\n        encoded", "        val vowels = \"\
    aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val next\
    \ = (index + 2) % vowels.length\n                vowels(next).toString\n     \
    \       } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val next = (index + 2) % alphabet.length\n\
    \                alphabet(next).toString\n            } else {\n             \
    \   c.toString\n            }\n        })\n        encoded.mkString", "      \
    \  val vowels = Set('a', 'e', 'i', 'o', 'u')\n        var result = \"\"\n    \
    \    for (c <- message) {\n            if (vowels.contains(c.toLower)) {\n   \
    \             val newC = if (c.isUpper) {\n                    (c + 2).toChar.toUpper\n\
    \                } else {\n                    (c + 2).toChar\n              \
    \  }\n                result += newC\n            } else {\n                val\
    \ newC = if (c.isUpper) {\n                    c.toLower\n                } else\
    \ {\n                    c.toUpper\n                }\n                result\
    \ += newC\n            }\n        }\n        result", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        message.map(c => if (vowels.contains(c))\
    \ alphabet((alphabetMap(c) + 2) % alphabet.size) else c).map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper)", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val alphabetMap2 =\
    \ alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val vowelsMap2 =\
    \ vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val encoded = message.map(x\
    \ => {\n            if (vowels.contains(x.toLower)) {\n                val index\
    \ = vowelsMap(x.toLower)\n                val newIndex = (index + 2) % 5\n   \
    \             val newChar = vowelsMap2(newIndex)\n                if (x.isUpper)\
    \ newChar.toUpper else newChar\n            } else {\n                val index\
    \ = alphabetMap(x.toLower)\n                val newIndex = (index + 2) % 26\n\
    \                val newChar = alphabetMap2(newIndex)\n                if (x.isUpper)\
    \ newChar.toUpper else newChar\n            }\n        })\n        encoded", " \
    \       val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a'\
    \ to 'z'\n        val alphabetMap = alphabet.zip(alphabet.drop(2) ++ alphabet.take(2)).toMap\n\
    \        message.map(c => if (vowels.contains(c.toLower)) alphabetMap(c.toLower)\
    \ else c)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val vowelsMap = Map[Char, Char]()\n        for (i <- 0 until vowels.length)\
    \ {\n            vowelsMap += (vowels(i) -> vowels((i + 2) % vowels.length))\n\
    \        }\n        val alphabetMap = Map[Char, Char]()\n        for (i <- 0 until\
    \ alphabet.length) {\n            alphabetMap += (alphabet(i) -> alphabet((i +\
    \ 2) % alphabet.length))\n        }\n        val result = new StringBuilder\n\
    \        for (c <- message) {\n            if (vowels.contains(c)) {\n       \
    \         result += vowelsMap(c)\n            } else if (alphabet.contains(c))\
    \ {\n                result += alphabetMap(c)\n            } else {\n        \
    \        result += c\n            }\n        }\n        result.toString", "  \
    \      val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encoded =\
    \ message.map(c => {\n            if (vowels.contains(c.toLower)) {\n        \
    \        val index = alphabetMap(c.toLower)\n                val newIndex = (index\
    \ + 2) % alphabet.length\n                alphabet(newIndex).toUpper\n       \
    \     } else {\n                c.toUpper\n            }\n        })\n       \
    \ encoded"]
stop_tokens:
- "\n    }\n"
