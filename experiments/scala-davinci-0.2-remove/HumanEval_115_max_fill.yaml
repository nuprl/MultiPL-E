name: HumanEval_115_max_fill
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n    // and each 1 in a row represents a single unit of water.\n    // Each\
  \ well has a corresponding bucket that can be used to extract water from it, \n\
  \    // and all buckets have the same capacity.\n    // Your task is to use the\
  \ buckets to empty the wells.\n    // Output the number of times you need to lower\
  \ the buckets.\n    // Example 1:\n    // Example 2:\n    // Example 3:\n    //\
  \ Constraints:\n    // * all wells have the same length\n    // * 1 <= grid.length\
  \ <= 10^2\n    // * 1 <= grid[:,1].length <= 10^2\n    // * grid[i][j] -> 0 | 1\n\
  \    // * 1 <= capacity <= 10\n    def maxFill(grid : List[List[Long]], capacity\
  \ : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
  \ 0l.toLong, 1l.toLong, 0l.toLong), List[Long](0l.toLong, 1l.toLong, 0l.toLong,\
  \ 0l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))), (1l)) ==\
  \ (6l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong, 0l.toLong,\
  \ 1l.toLong, 1l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong),\
  \ List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong), List[Long](0l.toLong,\
  \ 1l.toLong, 1l.toLong, 1l.toLong))), (2l)) == (5l));\n    assert(maxFill((List[List[Long]](List[Long](0l.toLong,\
  \ 0l.toLong, 0l.toLong), List[Long](0l.toLong, 0l.toLong, 0l.toLong))), (5l)) ==\
  \ (0l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
  \ (2l)) == (4l));\n    assert(maxFill((List[List[Long]](List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 1l.toLong), List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))),\
  \ (9l)) == (2l));\n    }\n\n}\n"
completions: ["        val maxFill = grid.map(x => x.sum).max\n        val numBuckets\
    \ = maxFill / capacity\n        if (maxFill % capacity == 0) numBuckets else numBuckets\
    \ + 1", "        val n = grid.length\n        val m = grid(0).length\n       \
    \ var total = 0L\n        for (i <- 0 until n) {\n            var sum = 0L\n \
    \           for (j <- 0 until m) {\n                sum += grid(i)(j)\n      \
    \      }\n            total += sum / capacity\n            if (sum % capacity\
    \ != 0) total += 1\n        }\n        return total", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val wells = grid.map(x => x.sum).toArray\n\
    \        val buckets = Array.fill(n)(capacity)\n        var count = 0\n      \
    \  while (wells.sum > 0) {\n            for (i <- 0 until n) {\n             \
    \   if (wells(i) > 0) {\n                    val delta = min(buckets(i), wells(i))\n\
    \                    wells(i) -= delta\n                    buckets(i) -= delta\n\
    \                }\n            }\n            count += 1\n            for (i\
    \ <- 0 until n) {\n                if (buckets(i) == 0) {\n                  \
    \  buckets(i) = capacity\n                }\n            }\n        }\n      \
    \  count", "        val n = grid.length\n        val m = grid(0).length\n    \
    \    val wells = grid.map(x => x.sum).toArray\n        val buckets = Array.fill(m)(capacity)\n\
    \        var count = 0\n        while (wells.sum > 0) {\n            for (i <-\
    \ 0 until m) {\n                if (wells(i) > 0) {\n                    val fill\
    \ = min(buckets(i), wells(i))\n                    wells(i) -= fill\n        \
    \            buckets(i) -= fill\n                }\n            }\n          \
    \  count += 1\n            for (i <- 0 until m) buckets(i) = capacity\n      \
    \  }\n        count", "        val maxFill = grid.map(row => row.sum).max\n  \
    \      val numFills = maxFill / capacity\n        val remainder = maxFill % capacity\n\
    \        if (remainder == 0) numFills else numFills + 1", "        var maxFill\
    \ = 0\n        for (row <- grid) {\n            var fill = 0\n            for\
    \ (well <- row) {\n                if (well == 1) {\n                    fill\
    \ += 1\n                } else {\n                    if (fill > 0) {\n      \
    \                  maxFill += 1\n                        fill = 0\n          \
    \          }\n                }\n            }\n            if (fill > 0) {\n\
    \                maxFill += 1\n            }\n        }\n        maxFill", " \
    \       val n = grid.length\n        val m = grid(0).length\n        var count\
    \ = 0L\n        for (i <- 0 until n) {\n            var sum = 0L\n           \
    \ for (j <- 0 until m) {\n                sum += grid(i)(j)\n                if\
    \ (sum == capacity) {\n                    count += 1\n                    sum\
    \ = 0\n                }\n            }\n            if (sum > 0) count += 1\n\
    \        }\n        count", "        var count = 0L\n        for (i <- 0 until\
    \ grid.length) {\n            var sum = 0L\n            for (j <- 0 until grid(i).length)\
    \ {\n                sum += grid(i)(j)\n            }\n            count += (sum\
    \ - 1) / capacity + 1\n        }\n        count", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m)\n  \
    \      for (i <- 0 until n) {\n            for (j <- 0 until m) {\n          \
    \      if (grid(i)(j) == 1) {\n                    dp(i)(j) = 1\n            \
    \    } else {\n                    dp(i)(j) = 0\n                }\n         \
    \   }\n        }\n        var ans = 0\n        for (i <- 0 until n) {\n      \
    \      for (j <- 0 until m) {\n                if (dp(i)(j) == 1) {\n        \
    \            var count = 0\n                    var k = i\n                  \
    \  while (k < n && count < capacity) {\n                        if (dp(k)(j) ==\
    \ 1) {\n                            count += 1\n                            dp(k)(j)\
    \ = 0\n                        }\n                        k += 1\n           \
    \         }\n                    ans += 1\n                }\n            }\n\
    \        }\n        ans", "        val maxFill = grid.map(row => row.sum).max\n\
    \        val minFill = grid.map(row => row.sum).min\n        val minFillCount\
    \ = grid.map(row => row.count(_ == 1)).min\n        val maxFillCount = grid.map(row\
    \ => row.count(_ == 1)).max\n        val minFillCountRow = grid.filter(row =>\
    \ row.count(_ == 1) == minFillCount).head\n        val maxFillCountRow = grid.filter(row\
    \ => row.count(_ == 1) == maxFillCount).head\n        val minFillCountRowIndex\
    \ = grid.indexOf(minFillCountRow)\n        val maxFillCountRowIndex = grid.indexOf(maxFillCountRow)\n\
    \        val minFillCountRowFill = minFillCountRow.sum\n        val maxFillCountRowFill\
    \ = maxFillCountRow.sum\n        val minFillCountRowFillIndex = minFillCountRow.indexOf(1)\n\
    \        val maxFillCountRowFillIndex = maxFillCountRow.indexOf(1)\n        val\
    \ minFillCountRowFillCount = minFillCountRow.count(_ == 1)\n        val maxFillCountRowFillCount\
    \ = maxFillCountRow.count(_ == 1)\n        val minFillCountRowFillCountIndex =\
    \ minFillCountRow.indexOf(1)\n        val maxFillCountRowFillCountIndex = maxFillCountRow.indexOf(1)\n\
    \        val minFillCountRowFillCountIndexes = minFillCountRow.zipWithIndex.filter(_._1\
    \ == 1).map(_._2)\n        val maxFillCountRowFillCountIndexes = maxFillCountRow.zipWithIndex.filter(_._1\
    \ == 1).map(_._2)\n        val minFillCountRowFillCountIndexesLength = minFillCountRowFillCountIndexes.length\n\
    \        val maxFillCountRowFillCountIndexesLength = maxFillCountRowFillCountIndexes.length\n\
    \        val minFillCountRowFillCountIndexesLast = minFillCountRowFillCountIndexes.last\n\
    \        val maxFillCountRowFillCountIndexesLast = maxFillCountRowFillCountIndexes.last\n\
    \        val minFillCountRowFillCountIndexesLastIndex = minFillCountRow.indexOf(1,\
    \ minFillCountRowFillCountIndexesLast)", "        val n = grid.length\n      \
    \  val m = grid(0).length\n        var result = 0L\n        for (i <- 0 until\
    \ n) {\n            var sum = 0L\n            for (j <- 0 until m) {\n       \
    \         sum += grid(i)(j)\n                if (sum > capacity) {\n         \
    \           result += sum - capacity\n                    sum = capacity\n   \
    \             }\n            }\n        }\n        result", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m)\n  \
    \      for (i <- 0 until n) {\n            for (j <- 0 until m) {\n          \
    \      dp(i)(j) = grid(i)(j)\n                if (i > 0) dp(i)(j) = max(dp(i)(j),\
    \ dp(i - 1)(j))\n                if (j > 0) dp(i)(j) = max(dp(i)(j), dp(i)(j -\
    \ 1))\n            }\n        }\n        var result = 0L\n        for (i <- 0\
    \ until n) {\n            for (j <- 0 until m) {\n                val fill = capacity\
    \ - dp(i)(j)\n                if (fill > 0) {\n                    result += fill\n\
    \                    dp(i)(j) += fill\n                    if (i > 0) dp(i - 1)(j)\
    \ = max(dp(i - 1)(j), dp(i)(j))\n                    if (j > 0) dp(i)(j - 1) =\
    \ max(dp(i)(j - 1), dp(i)(j))\n                }\n            }\n        }\n \
    \       result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        var fill = 0L\n        var i = 0\n        while (i < n) {\n         \
    \   var j = 0\n            while (j < m) {\n                if (grid(i)(j) ==\
    \ 1) {\n                    fill += 1\n                    j += 1\n          \
    \      } else {\n                    var k = j\n                    while (k <\
    \ m && grid(i)(k) == 0) k += 1\n                    if (k < m) {\n           \
    \             val diff = k - j\n                        if (diff > capacity) {\n\
    \                            fill += diff / capacity\n                       \
    \     if (diff % capacity > 0) fill += 1\n                        } else fill\
    \ += 1\n                        j = k\n                    } else j = k\n    \
    \            }\n            }\n            i += 1\n        }\n        fill", " \
    \       val rows = grid.length\n        val cols = grid(0).length\n        val\
    \ maxFill = Array.ofDim[Long](rows, cols)\n        for (i <- 0 until rows) {\n\
    \            for (j <- 0 until cols) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = capacity\n                }\n           \
    \ }\n        }\n        var count = 0\n        while (maxFill.map(_.sum).sum >\
    \ 0) {\n            for (i <- 0 until rows) {\n                for (j <- 0 until\
    \ cols) {\n                    if (maxFill(i)(j) > 0) {\n                    \
    \    if (i > 0 && maxFill(i - 1)(j) > 0) {\n                            val diff\
    \ = min(maxFill(i)(j), maxFill(i - 1)(j))\n                            maxFill(i)(j)\
    \ -= diff\n                            maxFill(i - 1)(j) -= diff\n           \
    \             }\n                        if (j > 0 && maxFill(i)(j - 1) > 0) {\n\
    \                            val diff = min(maxFill(i)(j), maxFill(i)(j - 1))\n\
    \                            maxFill(i)(j) -= diff\n                         \
    \   maxFill(i)(j - 1) -= diff\n                        }\n                   \
    \     if (i < rows - 1 && maxFill(i + 1)(j) > 0) {\n                         \
    \   val diff = min(maxFill(i)(j), maxFill(i + 1)(j))\n                       \
    \     maxFill(i)(j) -= diff\n                            maxFill(i + 1)(j) -=\
    \ diff\n                        }\n                        if (j < cols - 1 &&\
    \ maxFill(i)(j + 1) > 0) {\n                            val diff = min(maxFill(i)(j),\
    \ maxFill(i)(j + 1))\n                            maxFill(i)(j) -= diff\n    \
    \                        maxFill(i)(j + 1) -= diff\n                        }\n\
    \                    }\n                }\n            }\n            count +=\
    \ 1\n        }\n        count", "        var maxFill = 0L\n        for (row <-\
    \ grid) {\n            var fill = 0L\n            for (well <- row) {\n      \
    \          if (well == 1) fill += 1\n                else if (fill > 0) {\n  \
    \                  maxFill += min(fill, capacity)\n                    fill =\
    \ 0\n                }\n            }\n            maxFill += min(fill, capacity)\n\
    \        }\n        maxFill", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = capacity\n                }\n           \
    \ }\n        }\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (grid(i)(j) == 1) {\n                    if (i - 1\
    \ >= 0 && grid(i - 1)(j) == 1) {\n                        maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i - 1)(j) + capacity)\n                    }\n                    if\
    \ (j - 1 >= 0 && grid(i)(j - 1) == 1) {\n                        maxFill(i)(j)\
    \ = min(maxFill(i)(j), maxFill(i)(j - 1) + capacity)\n                    }\n\
    \                }\n            }\n        }\n        var result = 0L\n      \
    \  for (i <- n - 1 to 0 by -1) {\n            for (j <- m - 1 to 0 by -1) {\n\
    \                if (grid(i)(j) == 1) {\n                    if (i + 1 < n &&\
    \ grid(i + 1)(j) == 1) {\n                        maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i + 1)(j) + capacity)\n                    }\n                    if\
    \ (j + 1 < m && grid(i)(j + 1) == 1) {\n                        maxFill(i)(j)\
    \ = min(maxFill(i)(j), maxFill(i)(j + 1) + capacity)\n                    }\n\
    \                    result = max(result, maxFill(i)(j))\n                }\n\
    \            }\n        }\n        result", "        val wells = grid.map(row\
    \ => row.sum).toArray\n        val max = wells.max\n        val min = wells.min\n\
    \        var count = 0L\n        for (i <- min to max) {\n            for (j <-\
    \ 0 until wells.length) {\n                if (wells(j) > i) {\n             \
    \       wells(j) -= capacity\n                    count += 1\n               \
    \ }\n            }\n        }\n        count", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val maxFill = Array.ofDim[Long](n, m)\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = capacity\n\
    \                }\n            }\n        }\n        for (i <- 1 until n) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = min(maxFill(i)(j), maxFill(i - 1)(j) + capacity)\n\
    \                }\n            }\n        }\n        for (i <- 0 until n) {\n\
    \            for (j <- 1 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j - 1) + capacity)\n\
    \                }\n            }\n        }\n        for (i <- n - 2 to 0 by\
    \ -1) {\n            for (j <- 0 until m) {\n                if (grid(i)(j) ==\
    \ 1) {\n                    maxFill(i)(j) = min(maxFill(i)(j), maxFill(i + 1)(j)\
    \ + capacity)\n                }\n            }\n        }\n        for (i <-\
    \ 0 until n) {\n            for (j <- m - 2 to 0 by -1) {\n                if\
    \ (grid(i)(j) == 1) {\n                    maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i)(j + 1) + capacity)\n                }\n            }\n        }\n\
    \        var result = 0L\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                if (grid(i)(j) == 1) {\n                    result\
    \ += maxFill(i)(j) / capacity\n                }\n            }\n        }\n \
    \       result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = capacity\n                }\n           \
    \ }\n        }\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i > 0) {\n                    maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i - 1)(j))\n                }\n                if (j > 0) {\n      \
    \              maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j - 1))\n       \
    \         }\n            }\n        }\n        var result = 0L\n        for (i\
    \ <- n - 1 to 0 by -1) {\n            for (j <- m - 1 to 0 by -1) {\n        \
    \        if (grid(i)(j) == 1) {\n                    val fill = maxFill(i)(j)\n\
    \                    if (fill < capacity) {\n                        result +=\
    \ 1\n                    }\n                    if (i < n - 1) {\n           \
    \             maxFill(i + 1)(j) = min(maxFill(i + 1)(j), fill)\n             \
    \       }\n                    if (j < m - 1) {\n                        maxFill(i)(j\
    \ + 1) = min(maxFill(i)(j + 1), fill)\n                    }\n               \
    \ }\n            }\n        }\n        result", "        val maxFill = grid.map(row\
    \ => row.sum).max\n        if (maxFill <= capacity) 1 else maxFill / capacity\
    \ + 1", "        // grid[i][j] -> 0 | 1\n        // capacity -> 1..10\n      \
    \  // grid.length -> 1..100\n        // grid[0].length -> 1..100\n        // grid[i].length\
    \ == grid[j].length\n        // grid[i][j] == grid[j][i]\n        // grid[i][j]\
    \ = 0 | 1\n        // grid[i][j] = 0 | 1\n        // grid[i][j] = 0 | 1\n    \
    \    // grid[i][j] = 0 | 1\n        // grid[i][j] = 0 | 1\n        // grid[i][j]\
    \ = 0 | 1\n        // grid[i][j] = 0 | 1\n        // grid[i][j] = 0 | 1\n    \
    \    // grid[i][j] = 0 | 1\n        // grid[i][j] = 0 | 1\n        // grid[i][j]\
    \ = 0 | 1\n        // grid[i][j] = 0 | 1\n        // grid[i][j] = 0 | 1\n    \
    \    // grid[i][j] = 0 | 1\n        // grid[i][j] = 0 | 1\n        // grid[i][j]\
    \ = 0 | 1\n        // grid[i][j] = 0 | 1\n        // grid[i][j] = 0 | 1\n    \
    \    // grid[i][j] = 0 | 1\n        // grid[i][j] = 0 | 1\n        // grid[i][j]\
    \ = 0 | 1\n        // grid[i][j] = 0 | 1\n        // grid[i][j] = 0 | 1\n    \
    \    // grid[i][j] = 0 | 1\n        // grid[i][j] = 0 | 1\n        // grid[i][j]\
    \ = 0 | 1\n        // grid[i][j] = 0 | 1\n        // grid[i][j] = 0 | 1\n    \
    \    // grid[i][j] = 0 | 1\n        // grid[i][j] = 0 | 1\n        // grid[i][j]\
    \ = 0 | 1\n        // grid[i][j] = 0 | 1\n        // grid[i][j] = 0 | 1\n    \
    \    // grid[i][j] =", "        // Fill the wells from the bottom up.\n      \
    \  // If the well is empty, fill it with the capacity.\n        // If the well\
    \ is full, fill it with the capacity and increment the number of times you lowered\
    \ the bucket.\n        // If the well is partially filled, fill it with the capacity\
    \ and increment the number of times you lowered the bucket.\n        // If the\
    \ well is partially filled and the capacity is greater than the amount of water\
    \ in the well,\n        // fill it with the capacity and increment the number\
    \ of times you lowered the bucket.\n        // If the well is partially filled\
    \ and the capacity is less than the amount of water in the well,\n        // fill\
    \ it with the capacity and increment the number of times you lowered the bucket.\n\
    \        // If the well is partially filled and the capacity is equal to the amount\
    \ of water in the well,\n        // fill it with the capacity and increment the\
    \ number of times you lowered the bucket.\n        // If the well is partially\
    \ filled and the capacity is greater than the amount of water in the well,\n \
    \       // fill it with the capacity and increment the number of times you lowered\
    \ the bucket.\n        // If the well is partially filled and the capacity is\
    \ less than the amount of water in the well,\n        // fill it with the capacity\
    \ and increment the number of times you lowered the bucket.\n        // If the\
    \ well is partially filled and the capacity is equal to the amount of water in\
    \ the well,\n        // fill it with the capacity and increment the number of\
    \ times you lowered the bucket.\n        // If the well is partially filled and\
    \ the capacity is greater than the amount of water in the well,\n        // fill\
    \ it with the capacity and increment the number of times you lowered the bucket.\n\
    \        // If the well is partially filled and the capacity is less than the\
    \ amount of water in the well,\n        // fill it with the capacity and increment\
    \ the number of times you lowered the bucket.\n        // If the well is partially\
    \ filled and the capacity is equal to the amount of water in the well,\n     \
    \   // fill it with the capacity and increment the number of times you lowered\
    \ the bucket.\n        // If the well is partially filled and the capacity is\
    \ greater than the amount of water in the well,\n        // fill it with the capacity\
    \ and increment the number of times you lowered the bucket.\n        // If the\
    \ well is partially filled and the capacity is less than", "        val n = grid.length\n\
    \        val m = grid(0).length\n        var result = 0L\n        for (i <- 0\
    \ until n) {\n            var sum = 0L\n            for (j <- 0 until m) {\n \
    \               sum += grid(i)(j)\n                if (sum == capacity) {\n  \
    \                  result += 1\n                    sum = 0\n                }\
    \ else if (sum > capacity) {\n                    result += 1\n              \
    \      sum = grid(i)(j)\n                }\n            }\n            if (sum\
    \ > 0) result += 1\n        }\n        result", "        val maxRow = grid.map(row\
    \ => row.sum).max\n        val maxCol = grid.transpose.map(col => col.sum).max\n\
    \        max(maxRow, maxCol)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        var fill = 0L\n        for (i <- 0 until n) {\n            var sum =\
    \ 0L\n            for (j <- 0 until m) {\n                sum += grid(i)(j)\n\
    \                if (sum > capacity) {\n                    fill += sum - capacity\n\
    \                    sum = capacity\n                }\n            }\n      \
    \  }\n        fill", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n  \
    \          for (j <- 0 until m) {\n                dp(i)(j) = grid(i)(j)\n   \
    \             if (i > 0) dp(i)(j) = max(dp(i)(j), dp(i - 1)(j))\n            \
    \    if (j > 0) dp(i)(j) = max(dp(i)(j), dp(i)(j - 1))\n            }\n      \
    \  }\n        var result = 0L\n        for (i <- 0 until n) {\n            for\
    \ (j <- 0 until m) {\n                val fill = capacity - dp(i)(j)\n       \
    \         if (fill > 0) {\n                    result += fill\n              \
    \      dp(i)(j) += fill\n                    if (i > 0) dp(i - 1)(j) = max(dp(i\
    \ - 1)(j), dp(i)(j))\n                    if (j > 0) dp(i)(j - 1) = max(dp(i)(j\
    \ - 1), dp(i)(j))\n                }\n            }\n        }\n        result",
  "        val rowCount = grid.length\n        val colCount = grid(0).length\n   \
    \     val fillCount = Array.fill(rowCount)(0L)\n        var totalFillCount = 0L\n\
    \        for (col <- 0 until colCount) {\n            var row = 0\n          \
    \  while (row < rowCount) {\n                if (grid(row)(col) == 1) {\n    \
    \                fillCount(row) += 1\n                    if (fillCount(row) ==\
    \ capacity) {\n                        fillCount(row) = 0\n                  \
    \      totalFillCount += 1\n                    }\n                }\n       \
    \         row += 1\n            }\n        }\n        totalFillCount", "     \
    \   val maxFill = grid.map(row => row.sum).max\n        val numRows = grid.length\n\
    \        val numCols = grid(0).length\n        val numBuckets = maxFill / capacity\n\
    \        val numBucketsPerRow = numBuckets / numRows\n        val numBucketsPerCol\
    \ = numBuckets / numCols\n        val numBucketsPerRowRemainder = numBuckets %\
    \ numRows\n        val numBucketsPerColRemainder = numBuckets % numCols\n    \
    \    val numBucketsPerRowRemainderPerCol = numBucketsPerRowRemainder / numCols\n\
    \        val numBucketsPerColRemainderPerRow = numBucketsPerColRemainder / numRows\n\
    \        val numBucketsPerRowRemainderPerColRemainder = numBucketsPerRowRemainder\
    \ % numCols\n        val numBucketsPerColRemainderPerRowRemainder = numBucketsPerColRemainder\
    \ % numRows\n        val numBucketsPerRowRemainderPerColRemainderPerRow = numBucketsPerRowRemainderPerColRemainder\
    \ / numRows\n        val numBucketsPerColRemainderPerRowRemainderPerCol = numBucketsPerColRemainderPerRowRemainder\
    \ / numCols\n        val numBucketsPerRowRemainderPerColRemainderPerRowRemainder\
    \ = numBucketsPerRowRemainderPerColRemainder % numRows\n        val numBucketsPerColRemainderPerRowRemainderPerColRemainder\
    \ = numBucketsPerColRemainderPerRowRemainder % numCols\n        val numBucketsPerRowRemainderPerColRemainderPerRowRemainderPerCol\
    \ = numBucketsPerRowRemainderPerColRemainderPerRowRemainder / numCols\n      \
    \  val numBucketsPerColRemainderPerRowRemainderPerColRemainderPerRow = numBucketsPerColRemainderPerRowRemainderPerColRemainder\
    \ / numRows\n        val numBucketsPerRowRemain", "        // fill the wells\n\
    \        // find the max of the row\n        // fill the wells\n        // find\
    \ the max of the row\n        // fill the wells\n        // find the max of the\
    \ row\n        // ...\n        // return the number of times we filled the wells\n\
    \        def fill(grid : List[List[Long]]) : List[List[Long]] = {\n          \
    \  val max = grid.map(row => row.max).max\n            grid.map(row => row.map(x\
    \ => max - x))\n        }\n        def fillAll(grid : List[List[Long]], capacity\
    \ : Long) : Long = {\n            if (grid.forall(row => row.forall(x => x ==\
    \ 0))) 0\n            else 1 + fillAll(fill(grid), capacity)\n        }\n    \
    \    fillAll(grid, capacity)", "        val maxFill = grid.map(row => row.sum).max\n\
    \        if (maxFill > capacity) {\n            maxFill / capacity + (if (maxFill\
    \ % capacity == 0) 0 else 1)\n        } else {\n            1\n        }", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val fill\
    \ = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n            var sum\
    \ = 0L\n            for (j <- 0 until m) {\n                sum += grid(i)(j)\n\
    \                fill(i)(j) = sum\n            }\n        }\n        var count\
    \ = 0L\n        for (j <- 0 until m) {\n            var max = 0L\n           \
    \ for (i <- 0 until n) {\n                max = max(fill(i)(j), max)\n       \
    \     }\n            count += max / capacity\n            if (max % capacity !=\
    \ 0) count += 1\n        }\n        count", "        val n = grid.length\n   \
    \     val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m)\n     \
    \   for (i <- 0 until n) {\n            for (j <- 0 until m) {\n             \
    \   if (grid(i)(j) == 1) {\n                    dp(i)(j) = capacity\n        \
    \        }\n            }\n        }\n        for (i <- 0 until n) {\n       \
    \     for (j <- 0 until m) {\n                if (i > 0) {\n                 \
    \   dp(i)(j) = min(dp(i)(j), dp(i - 1)(j))\n                }\n              \
    \  if (j > 0) {\n                    dp(i)(j) = min(dp(i)(j), dp(i)(j - 1))\n\
    \                }\n            }\n        }\n        var result = 0L\n      \
    \  for (i <- n - 1 to 0 by -1) {\n            for (j <- m - 1 to 0 by -1) {\n\
    \                if (dp(i)(j) > 0) {\n                    result += 1\n      \
    \              var x = i\n                    var y = j\n                    while\
    \ (x < n && y < m && dp(x)(y) > 0) {\n                        dp(x)(y) -= 1\n\
    \                        if (x < n - 1 && dp(x + 1)(y) > 0) {\n              \
    \              x += 1\n                        } else if (y < m - 1 && dp(x)(y\
    \ + 1) > 0) {\n                            y += 1\n                        } else\
    \ {\n                            x += 1\n                            y += 1\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n        result", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.ofDim[Long](n, m)\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                if (i ==\
    \ 0) {\n                    dp(i)(j) = grid(i)(j)\n                } else {\n\
    \                    dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n                }\n\
    \            }\n        }\n        var result = 0L\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                if (dp(i)(j) > capacity)\
    \ {\n                    result += dp(i)(j) - capacity\n                    dp(i)(j)\
    \ = capacity\n                }\n            }\n        }\n        result", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until m) {\n                if (grid(i)(j) == 1) {\n                  \
    \  maxFill(i)(j) = capacity\n                }\n            }\n        }\n   \
    \     for (i <- 0 until n) {\n            for (j <- 0 until m) {\n           \
    \     if (i > 0) {\n                    maxFill(i)(j) = min(maxFill(i)(j), maxFill(i\
    \ - 1)(j))\n                }\n                if (j > 0) {\n                \
    \    maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j - 1))\n                }\n\
    \            }\n        }\n        var result = 0L\n        for (i <- n - 1 to\
    \ 0 by -1) {\n            for (j <- m - 1 to 0 by -1) {\n                if (grid(i)(j)\
    \ == 1) {\n                    result += capacity - maxFill(i)(j)\n          \
    \      }\n            }\n        }\n        result", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val wells = grid.map(row => row.map(x\
    \ => if (x == 1) capacity else 0))\n        var count = 0\n        while (wells.exists(row\
    \ => row.exists(x => x > 0))) {\n            count += 1\n            for (i <-\
    \ 0 until n) {\n                for (j <- 0 until m) {\n                    if\
    \ (wells(i)(j) > 0) {\n                        if (i > 0 && wells(i - 1)(j) <\
    \ capacity) {\n                            val diff = min(wells(i)(j), capacity\
    \ - wells(i - 1)(j))\n                            wells(i)(j) -= diff\n      \
    \                      wells(i - 1)(j) += diff\n                        }\n  \
    \                      if (i < n - 1 && wells(i + 1)(j) < capacity) {\n      \
    \                      val diff = min(wells(i)(j), capacity - wells(i + 1)(j))\n\
    \                            wells(i)(j) -= diff\n                           \
    \ wells(i + 1)(j) += diff\n                        }\n                       \
    \ if (j > 0 && wells(i)(j - 1) < capacity) {\n                            val\
    \ diff = min(wells(i)(j), capacity - wells(i)(j - 1))\n                      \
    \      wells(i)(j) -= diff\n                            wells(i)(j - 1) += diff\n\
    \                        }\n                        if (j < m - 1 && wells(i)(j\
    \ + 1) < capacity) {\n                            val diff = min(wells(i)(j),\
    \ capacity - wells(i)(j + 1))\n                            wells(i)(j) -= diff\n\
    \                            wells(i)(j + 1) += diff\n                       \
    \ }\n                    }\n                }\n            }\n        }\n    \
    \    count", "        val wells = grid.map(x => x.sum).toArray\n        val n\
    \ = wells.length\n        var result = 0L\n        for (i <- 0 until n) {\n  \
    \          val diff = capacity - wells(i)\n            if (diff > 0) {\n     \
    \           wells(i) = capacity\n                result += diff\n            }\n\
    \        }\n        result", "        val m = grid.length\n        val n = grid(0).length\n\
    \        val maxFill = Array.ofDim[Long](m, n)\n        for (i <- 0 until m) {\n\
    \            for (j <- 0 until n) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = capacity\n                }\n           \
    \ }\n        }\n        for (i <- 0 until m) {\n            for (j <- 0 until\
    \ n) {\n                if (i > 0) {\n                    maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i - 1)(j))\n                }\n                if (j > 0) {\n      \
    \              maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j - 1))\n       \
    \         }\n            }\n        }\n        var result = 0L\n        for (i\
    \ <- m - 1 to 0 by -1) {\n            for (j <- n - 1 to 0 by -1) {\n        \
    \        if (grid(i)(j) == 1) {\n                    val fill = maxFill(i)(j)\n\
    \                    if (fill > 0) {\n                        result += 1\n  \
    \                      if (i > 0) {\n                            maxFill(i - 1)(j)\
    \ -= fill\n                        }\n                        if (j > 0) {\n \
    \                           maxFill(i)(j - 1) -= fill\n                      \
    \  }\n                    }\n                }\n            }\n        }\n   \
    \     result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n  \
    \          for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n  \
    \                  dp(i)(j) = capacity\n                }\n            }\n   \
    \     }\n        var ans = 0L\n        for (i <- 0 until n) {\n            for\
    \ (j <- 0 until m) {\n                if (dp(i)(j) > 0) {\n                  \
    \  if (i > 0) {\n                        dp(i)(j) = min(dp(i)(j), dp(i - 1)(j)\
    \ + 1)\n                    }\n                    if (j > 0) {\n            \
    \            dp(i)(j) = min(dp(i)(j), dp(i)(j - 1) + 1)\n                    }\n\
    \                    ans += dp(i)(j)\n                }\n            }\n     \
    \   }\n        ans", "        val rows = grid.length\n        val cols = grid(0).length\n\
    \        val maxFill = Array.ofDim[Long](rows, cols)\n        for (i <- 0 until\
    \ rows) {\n            for (j <- 0 until cols) {\n                if (grid(i)(j)\
    \ == 1) {\n                    maxFill(i)(j) = capacity\n                }\n \
    \           }\n        }\n        for (i <- 0 until rows) {\n            for (j\
    \ <- 0 until cols) {\n                if (grid(i)(j) == 1) {\n               \
    \     if (i > 0) {\n                        maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i - 1)(j) + capacity)\n                    }\n                    if\
    \ (j > 0) {\n                        maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j\
    \ - 1) + capacity)\n                    }\n                }\n            }\n\
    \        }\n        maxFill(rows - 1)(cols - 1)", "        val maxFill = grid.map(row\
    \ => row.sum).max\n        val maxFillCount = maxFill / capacity\n        val\
    \ maxFillRemainder = maxFill % capacity\n        if (maxFillRemainder == 0) maxFillCount\
    \ else maxFillCount + 1", "        var count = 0L\n        for (i <- 0 until grid.length)\
    \ {\n            var sum = 0L\n            for (j <- 0 until grid(i).length) {\n\
    \                sum += grid(i)(j)\n            }\n            if (sum > capacity)\
    \ {\n                count += (sum - capacity)\n            }\n        }\n   \
    \     count", "        val n = grid.length\n        val m = grid(0).length\n \
    \       val wells = grid.map(row => row.sum).toArray\n        val buckets = Array.fill(n)(capacity)\n\
    \        var count = 0\n        while (wells.sum > 0) {\n            for (i <-\
    \ 0 until n) {\n                if (wells(i) > 0) {\n                    val fill\
    \ = min(buckets(i), wells(i))\n                    wells(i) -= fill\n        \
    \            buckets(i) -= fill\n                }\n            }\n          \
    \  count += 1\n            for (i <- 0 until n) buckets(i) = capacity\n      \
    \  }\n        count", "        var maxFill = 0L\n        for (i <- 0 until grid.length)\
    \ {\n            var fill = 0L\n            for (j <- 0 until grid(i).length)\
    \ {\n                if (grid(i)(j) == 1) fill += 1\n            }\n         \
    \   maxFill = max(maxFill, fill)\n        }\n        maxFill", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        var result = 0L\n   \
    \     var i = 0\n        while (i < n) {\n            var j = 0\n            while\
    \ (j < m) {\n                if (grid(i)(j) == 1) {\n                    result\
    \ += 1\n                    var k = i + 1\n                    while (k < n &&\
    \ grid(k)(j) == 1) {\n                        grid(k)(j) = 0\n               \
    \         k += 1\n                    }\n                }\n                j\
    \ += 1\n            }\n            i += 1\n        }\n        result", "     \
    \   val n = grid.length\n        val m = grid(0).length\n        val fill = Array.ofDim[Long](n,\
    \ m)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n   \
    \             if (grid(i)(j) == 1) {\n                    fill(i)(j) = capacity\n\
    \                }\n            }\n        }\n        var count = 0\n        while\
    \ (true) {\n            var found = false\n            for (i <- 0 until n) {\n\
    \                for (j <- 0 until m) {\n                    if (fill(i)(j) >\
    \ 0) {\n                        found = true\n                        if (i >\
    \ 0 && fill(i - 1)(j) < capacity) {\n                            val diff = min(fill(i)(j),\
    \ capacity - fill(i - 1)(j))\n                            fill(i)(j) -= diff\n\
    \                            fill(i - 1)(j) += diff\n                        }\n\
    \                        if (i < n - 1 && fill(i + 1)(j) < capacity) {\n     \
    \                       val diff = min(fill(i)(j), capacity - fill(i + 1)(j))\n\
    \                            fill(i)(j) -= diff\n                            fill(i\
    \ + 1)(j) += diff\n                        }\n                        if (j >\
    \ 0 && fill(i)(j - 1) < capacity) {\n                            val diff = min(fill(i)(j),\
    \ capacity - fill(i)(j - 1))\n                            fill(i)(j) -= diff\n\
    \                            fill(i)(j - 1) += diff\n                        }\n\
    \                        if (j < m - 1 && fill(i)(j + 1) < capacity) {\n     \
    \                       val diff = min(fill(i)(j), capacity - fill(i)(j + 1))\n\
    \                            fill(i)(j) -= diff\n                            fill(i)(j\
    \ + 1) += diff\n                        }\n                    }\n           \
    \     }\n            }\n            if (!found) return count\n            count\
    \ += 1\n        }\n        return count", "        val rows = grid.length\n  \
    \      val cols = grid(0).length\n        val maxFill = Array.ofDim[Long](rows,\
    \ cols)\n        for (i <- 0 until rows) {\n            for (j <- 0 until cols)\
    \ {\n                if (i == 0) {\n                    maxFill(i)(j) = grid(i)(j)\n\
    \                } else {\n                    maxFill(i)(j) = max(maxFill(i -\
    \ 1)(j), grid(i)(j))\n                }\n            }\n        }\n        var\
    \ result = 0L\n        for (i <- 0 until rows) {\n            for (j <- 0 until\
    \ cols) {\n                if (maxFill(i)(j) > 0) {\n                    result\
    \ += maxFill(i)(j) / capacity\n                    if (maxFill(i)(j) % capacity\
    \ > 0) result += 1\n                }\n            }\n        }\n        result",
  "        val maxFill = grid.map(row => row.sum).max\n        val numRows = grid.length\n\
    \        val numCols = grid(0).length\n        val numBuckets = min(numRows, numCols)\n\
    \        val buckets = Array.fill(numBuckets)(capacity)\n        var numFills\
    \ = 0\n        while (buckets.exists(_ > 0)) {\n            for (i <- 0 until\
    \ numBuckets) {\n                if (buckets(i) > 0) {\n                    val\
    \ row = grid(i)\n                    val numCols = row.length\n              \
    \      for (j <- 0 until numCols) {\n                        val col = row(j)\n\
    \                        val numFills = min(buckets(i), col)\n               \
    \         buckets(i) -= numFills\n                        grid(i)(j) -= numFills\n\
    \                    }\n                }\n            }\n            numFills\
    \ += 1\n        }\n        numFills", "        // Fill the wells from the top\
    \ down.\n        // If a well is not full, fill it with the remaining water from\
    \ the previous well.\n        // If the well is full, fill it with the remaining\
    \ water from the previous well and\n        // then fill the next well with the\
    \ remaining water from the current well.\n        // If the well is full and the\
    \ next well is full, fill the next well with the remaining\n        // water from\
    \ the current well and then fill the next well with the remaining water from\n\
    \        // the current well.\n        // If the well is full and the next well\
    \ is not full, fill the next well with the remaining\n        // water from the\
    \ current well and then fill the next well with the remaining water from\n   \
    \     // the current well.\n        // If the well is full and the next well is\
    \ not full, fill the next well with the remaining\n        // water from the current\
    \ well and then fill the next well with the remaining water from\n        // the\
    \ current well.\n        // If the well is full and the next well is not full,\
    \ fill the next well with the remaining\n        // water from the current well\
    \ and then fill the next well with the remaining water from\n        // the current\
    \ well.\n        // If the well is full and the next well is not full, fill the\
    \ next well with the remaining\n        // water from the current well and then\
    \ fill the next well with the remaining water from\n        // the current well.\n\
    \        // If the well is full and the next well is not full, fill the next well\
    \ with the remaining\n        // water from the current well and then fill the\
    \ next well with the remaining water from\n        // the current well.\n    \
    \    // If the well is full and the next well is not full, fill the next well\
    \ with the remaining\n        // water from the current well and then fill the\
    \ next well with the remaining water from\n        // the current well.\n    \
    \    // If the well is full and the next well is not full, fill the next well\
    \ with the remaining\n        // water from the current well and then fill the\
    \ next well with the remaining water from\n        // the current well.\n    \
    \    // If the well is full and the next well is not full, fill the next well\
    \ with the remaining\n        // water from the current well and then fill the\
    \ next well with the remaining water from\n        // the current well.\n    \
    \    //", "        var maxFill = 0L\n        for (row <- grid) {\n           \
    \ var fill = 0L\n            for (well <- row) {\n                if (well ==\
    \ 1) fill += 1\n                else {\n                    maxFill = max(maxFill,\
    \ fill)\n                    fill = 0\n                }\n            }\n    \
    \        maxFill = max(maxFill, fill)\n        }\n        maxFill", "        val\
    \ maxFill = grid.map(row => row.sum).max\n        val numFill = ceil(maxFill.toDouble\
    \ / capacity.toDouble).toLong\n        numFill", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m)\n  \
    \      for (i <- 0 until n) {\n            for (j <- 0 until m) {\n          \
    \      if (grid(i)(j) == 1) {\n                    dp(i)(j) = capacity\n     \
    \           }\n            }\n        }\n        var ans = 0L\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                if (dp(i)(j)\
    \ == capacity) {\n                    ans += 1\n                    dfs(i, j,\
    \ dp, capacity)\n                }\n            }\n        }\n        ans", " \
    \       val rows = grid.length\n        val columns = grid(0).length\n       \
    \ val maxFill = Array.ofDim[Long](rows, columns)\n        for (i <- 0 until rows)\
    \ {\n            for (j <- 0 until columns) {\n                if (grid(i)(j)\
    \ == 1) {\n                    maxFill(i)(j) = capacity\n                }\n \
    \           }\n        }\n        var count = 0\n        while (true) {\n    \
    \        var filled = false\n            for (i <- 0 until rows) {\n         \
    \       for (j <- 0 until columns) {\n                    if (maxFill(i)(j) >\
    \ 0) {\n                        filled = true\n                        if (i >\
    \ 0 && maxFill(i - 1)(j) < capacity) {\n                            val diff =\
    \ min(maxFill(i)(j), capacity - maxFill(i - 1)(j))\n                         \
    \   maxFill(i)(j) -= diff\n                            maxFill(i - 1)(j) += diff\n\
    \                        }\n                        if (i < rows - 1 && maxFill(i\
    \ + 1)(j) < capacity) {\n                            val diff = min(maxFill(i)(j),\
    \ capacity - maxFill(i + 1)(j))\n                            maxFill(i)(j) -=\
    \ diff\n                            maxFill(i + 1)(j) += diff\n              \
    \          }\n                        if (j > 0 && maxFill(i)(j - 1) < capacity)\
    \ {\n                            val diff = min(maxFill(i)(j), capacity - maxFill(i)(j\
    \ - 1))\n                            maxFill(i)(j) -= diff\n                 \
    \           maxFill(i)(j - 1) += diff\n                        }\n           \
    \             if (j < columns - 1 && maxFill(i)(j + 1) < capacity) {\n       \
    \                     val diff = min(maxFill(i)(j), capacity - maxFill(i)(j +\
    \ 1))\n                            maxFill(i)(j) -= diff\n                   \
    \         maxFill(i)(j + 1) += diff\n                        }\n             \
    \       }\n                }\n            }\n            if (!filled) return count\n\
    \            count += 1\n        }\n        return count", "        val maxFill\
    \ = grid.map(row => row.sum).max\n        val numFills = maxFill / capacity\n\
    \        val remainder = maxFill % capacity\n        if (remainder == 0) numFills\
    \ else numFills + 1", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = capacity\n                }\n           \
    \ }\n        }\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i > 0) {\n                    maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i - 1)(j))\n                }\n                if (j > 0) {\n      \
    \              maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j - 1))\n       \
    \         }\n            }\n        }\n        var result = 0L\n        for (i\
    \ <- n - 1 to 0 by -1) {\n            for (j <- m - 1 to 0 by -1) {\n        \
    \        if (grid(i)(j) == 1) {\n                    if (i < n - 1) {\n      \
    \                  maxFill(i)(j) = min(maxFill(i)(j), maxFill(i + 1)(j))\n   \
    \                 }\n                    if (j < m - 1) {\n                  \
    \      maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j + 1))\n               \
    \     }\n                    result += capacity - maxFill(i)(j)\n            \
    \    }\n            }\n        }\n        result", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val maxFill = Array.ofDim[Long](n, m)\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = capacity\n\
    \                }\n            }\n        }\n        var count = 0\n        while\
    \ (maxFill.map(_.sum).sum > 0) {\n            for (i <- 0 until n) {\n       \
    \         for (j <- 0 until m) {\n                    if (maxFill(i)(j) > 0) {\n\
    \                        if (i > 0 && maxFill(i - 1)(j) > 0) {\n             \
    \               val diff = min(maxFill(i)(j), maxFill(i - 1)(j))\n           \
    \                 maxFill(i)(j) -= diff\n                            maxFill(i\
    \ - 1)(j) -= diff\n                        }\n                        if (j >\
    \ 0 && maxFill(i)(j - 1) > 0) {\n                            val diff = min(maxFill(i)(j),\
    \ maxFill(i)(j - 1))\n                            maxFill(i)(j) -= diff\n    \
    \                        maxFill(i)(j - 1) -= diff\n                        }\n\
    \                        if (i < n - 1 && maxFill(i + 1)(j) > 0) {\n         \
    \                   val diff = min(maxFill(i)(j), maxFill(i + 1)(j))\n       \
    \                     maxFill(i)(j) -= diff\n                            maxFill(i\
    \ + 1)(j) -= diff\n                        }\n                        if (j <\
    \ m - 1 && maxFill(i)(j + 1) > 0) {\n                            val diff = min(maxFill(i)(j),\
    \ maxFill(i)(j + 1))\n                            maxFill(i)(j) -= diff\n    \
    \                        maxFill(i)(j + 1) -= diff\n                        }\n\
    \                    }\n                }\n            }\n            count +=\
    \ 1\n        }\n        count", "        val n = grid.length\n        val m =\
    \ grid(0).length\n        val maxFill = Array.ofDim[Long](n, m)\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    maxFill(i)(j) = capacity\n                }\n \
    \           }\n        }\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                if (grid(i)(j) == 1) {\n                    if\
    \ (i > 0) {\n                        maxFill(i)(j) = min(maxFill(i)(j), maxFill(i\
    \ - 1)(j) + capacity)\n                    }\n                    if (j > 0) {\n\
    \                        maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j - 1)\
    \ + capacity)\n                    }\n                }\n            }\n     \
    \   }\n        maxFill(n - 1)(m - 1)", "        var maxFill = 0L\n        for\
    \ (row <- grid) {\n            var fill = 0L\n            for (well <- row) {\n\
    \                if (well == 1) fill += 1\n                else {\n          \
    \          if (fill > 0) {\n                        maxFill += 1\n           \
    \             fill = 0\n                    }\n                }\n           \
    \ }\n            if (fill > 0) maxFill += 1\n        }\n        maxFill", "  \
    \      val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until m) {\n                if (grid(i)(j) == 1) {\n                  \
    \  val maxFillLeft = if (j == 0) 0 else maxFill(i)(j - 1)\n                  \
    \  val maxFillUp = if (i == 0) 0 else maxFill(i - 1)(j)\n                    maxFill(i)(j)\
    \ = max(maxFillLeft, maxFillUp) + 1\n                }\n            }\n      \
    \  }\n        var result = 0L\n        for (i <- 0 until n) {\n            for\
    \ (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n               \
    \     val maxFillLeft = if (j == 0) 0 else maxFill(i)(j - 1)\n               \
    \     val maxFillUp = if (i == 0) 0 else maxFill(i - 1)(j)\n                 \
    \   val maxFillCurrent = max(maxFillLeft, maxFillUp) + 1\n                   \
    \ result += max(0, maxFillCurrent - capacity)\n                }\n           \
    \ }\n        }\n        result", "        val n = grid.length\n        val m =\
    \ grid(0).length\n        var ans = 0\n        for (i <- 0 until n) {\n      \
    \      var sum = 0\n            for (j <- 0 until m) {\n                sum +=\
    \ grid(i)(j)\n                if (sum == capacity) {\n                    ans\
    \ += 1\n                    sum = 0\n                }\n            }\n      \
    \      if (sum > 0) ans += 1\n        }\n        ans", "        var maxFill =\
    \ 0L\n        for (row <- grid) {\n            var fill = 0L\n            for\
    \ (well <- row) {\n                if (well == 1) fill += 1\n                else\
    \ {\n                    maxFill = max(maxFill, fill)\n                    fill\
    \ = 0\n                }\n            }\n            maxFill = max(maxFill, fill)\n\
    \        }\n        maxFill / capacity", "        val n = grid.length\n      \
    \  val m = grid(0).length\n        val maxFill = Array.ofDim[Long](n, m)\n   \
    \     for (i <- 0 until n) {\n            for (j <- 0 until m) {\n           \
    \     if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = capacity\n \
    \               }\n            }\n        }\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (i > 0) {\n          \
    \          maxFill(i)(j) = min(maxFill(i)(j), maxFill(i - 1)(j))\n           \
    \     }\n                if (j > 0) {\n                    maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i)(j - 1))\n                }\n            }\n        }\n        var\
    \ result = 0L\n        for (i <- n - 1 to 0 by -1) {\n            for (j <- m\
    \ - 1 to 0 by -1) {\n                if (grid(i)(j) == 1) {\n                \
    \    if (i < n - 1) {\n                        maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i + 1)(j))\n                    }\n                    if (j < m - 1)\
    \ {\n                        maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j +\
    \ 1))\n                    }\n                    result += maxFill(i)(j)\n  \
    \              }\n            }\n        }\n        result", "        // Fill\
    \ the wells with the buckets.\n        // Return the number of times the buckets\
    \ were lowered.\n        def fill(grid : List[List[Long]], capacity : Long) :\
    \ Long = {\n            // Fill the wells with the buckets.\n            // Return\
    \ the number of times the buckets were lowered.\n            def fill(grid : List[List[Long]],\
    \ capacity : Long) : Long = {\n                // Fill the wells with the buckets.\n\
    \                // Return the number of times the buckets were lowered.\n   \
    \             def fill(grid : List[List[Long]], capacity : Long) : Long = {\n\
    \                    // Fill the wells with the buckets.\n                   \
    \ // Return the number of times the buckets were lowered.\n                  \
    \  def fill(grid : List[List[Long]], capacity : Long) : Long = {\n           \
    \             // Fill the wells with the buckets.\n                        //\
    \ Return the number of times the buckets were lowered.\n                     \
    \   def fill(grid : List[List[Long]], capacity : Long) : Long = {\n          \
    \                  // Fill the wells with the buckets.\n                     \
    \       // Return the number of times the buckets were lowered.\n            \
    \                def fill(grid : List[List[Long]], capacity : Long) : Long = {\n\
    \                                // Fill the wells with the buckets.\n       \
    \                         // Return the number of times the buckets were lowered.\n\
    \                                def fill(grid : List[List[Long]], capacity :\
    \ Long) : Long = {\n                                    // Fill the wells with\
    \ the buckets.\n                                    // Return the number of times\
    \ the buckets were lowered.\n                                    def fill(grid\
    \ : List[List[Long]], capacity : Long) : Long = {\n                          \
    \              // Fill the wells with the buckets.\n                         \
    \               // Return the number of times the buckets were lowered.\n    \
    \                                    def fill(grid : List[List[Long]], capacity\
    \ : Long) : Long = {\n                                            // Fill the\
    \ wells with the buckets.\n                                            // Return\
    \ the number of times the buckets were lowered.\n                            \
    \                def fill(grid : List[List[Long]], capacity : Long) : Long = {\n\
    \                                                // Fill the wells with the buckets.\n\
    \                                                // Return the number of times\
    \ the buckets were lowered.\n                                                def\
    \ fill(grid : List[List[Long]], capacity", "        // Fill each well to capacity.\n\
    \        // If a well is already at capacity, then skip it.\n        // If a well\
    \ is not at capacity, then fill it to capacity.\n        // If a well is over\
    \ capacity, then fill it to capacity and spill over to the next well.\n      \
    \  // If the next well is at capacity, then skip it.\n        // If the next well\
    \ is not at capacity, then fill it to capacity.\n        // If the next well is\
    \ over capacity, then fill it to capacity and spill over to the next well.\n \
    \       // Repeat until all wells are at capacity.\n        // Return the number\
    \ of times you filled a well to capacity.\n        // Example 1:\n        // Example\
    \ 2:\n        // Example 3:\n        // Constraints:\n        // * all wells have\
    \ the same length\n        // * 1 <= grid.length <= 10^2\n        // * 1 <= grid[:,1].length\
    \ <= 10^2\n        // * grid[i][j] -> 0 | 1\n        // * 1 <= capacity <= 10\n\
    \        // * 1 <= result <= 10^2\n        def maxFill(grid : List[List[Long]],\
    \ capacity : Long, result : Long) : Long = {\n            if (grid.forall(row\
    \ => row.forall(well => well == capacity))) result\n            else {\n     \
    \           val newGrid = grid.map(row => {\n                    var newRow =\
    \ row\n                    for (i <- 0 until row.length) {\n                 \
    \       if (row(i) < capacity) {\n                            val newWell = min(capacity,\
    \ row(i) + 1)\n                            newRow = newRow.updated(i, newWell)\n\
    \                            if (newWell == capacity && i < row.length - 1) {\n\
    \                                val nextWell = min(capacity, row(i + 1) + 1)\n\
    \                                newRow = newRow.updated(i + 1, nextWell)\n  \
    \                          }\n                        }\n                    }\n\
    \                    newRow\n                })\n                maxFill(newGrid,\
    \ capacity, result + 1)\n            }\n        }\n        maxFill(grid, capacity,\
    \ 0)", "        val n = grid.length\n        val m = grid(0).length\n        val\
    \ maxFill = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n        \
    \    for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n        \
    \            maxFill(i)(j) = capacity\n                }\n            }\n    \
    \    }\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n \
    \               if (i > 0) {\n                    maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i - 1)(j))\n                }\n                if (j > 0) {\n      \
    \              maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j - 1))\n       \
    \         }\n            }\n        }\n        var count = 0L\n        for (i\
    \ <- n - 1 to 0 by -1) {\n            for (j <- m - 1 to 0 by -1) {\n        \
    \        if (grid(i)(j) == 1) {\n                    if (i < n - 1) {\n      \
    \                  maxFill(i)(j) = min(maxFill(i)(j), maxFill(i + 1)(j))\n   \
    \                 }\n                    if (j < m - 1) {\n                  \
    \      maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j + 1))\n               \
    \     }\n                    count += capacity - maxFill(i)(j)\n             \
    \   }\n            }\n        }\n        count", "        val maxFill = grid.map(row\
    \ => row.sum)\n        val maxFillSum = maxFill.sum\n        val maxFillMax =\
    \ maxFill.max\n        val maxFillMin = maxFill.min\n        val maxFillAvg =\
    \ maxFillSum / maxFill.length\n        val maxFillMed = if (maxFill.length % 2\
    \ == 0) (maxFill(maxFill.length / 2) + maxFill(maxFill.length / 2 - 1)) / 2 else\
    \ maxFill(maxFill.length / 2)\n        val maxFillMode = maxFill.groupBy(identity).maxBy(_._2.length)._1\n\
    \        val maxFillRange = maxFillMax - maxFillMin\n        val maxFillStdDev\
    \ = sqrt(maxFill.map(x => pow(x - maxFillAvg, 2)).sum / maxFill.length)\n    \
    \    val maxFillVariance = maxFill.map(x => pow(x - maxFillAvg, 2)).sum / maxFill.length\n\
    \        val maxFillSkewness = maxFill.map(x => pow(x - maxFillAvg, 3)).sum /\
    \ (maxFill.length * pow(maxFillStdDev, 3))\n        val maxFillKurtosis = maxFill.map(x\
    \ => pow(x - maxFillAvg, 4)).sum / (maxFill.length * pow(maxFillStdDev, 4))\n\
    \        val maxFillCoefficientOfVariation = maxFillStdDev / maxFillAvg\n    \
    \    val maxFillZScore = maxFill.map(x => (x - maxFillAvg) / maxFillStdDev)\n\
    \        val maxFillPercentile = maxFill.map(x => (maxFill.filter(_ < x).length\
    \ + 0.5 * maxFill.filter(_ == x).length) / maxFill.length)\n        val maxFillHistogram\
    \ = maxFill.groupBy(identity).map(x => (x._1, x._2.length))\n        val maxFillBoxPlot\
    \ = (maxFillMin, maxFillMax, maxFillMed - maxFillMin, maxFillMax - maxFillMed)\n\
    \        val maxFillInterquartileRange = maxFillBoxPlot._3 + maxFillBoxPlot._4\n\
    \        val maxFillOutliers = maxFill.filter", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m)\n  \
    \      for (i <- 0 until n) {\n            for (j <- 0 until m) {\n          \
    \      if (grid(i)(j) == 1) {\n                    dp(i)(j) = capacity\n     \
    \               if (i > 0) dp(i)(j) = min(dp(i)(j), dp(i - 1)(j) + capacity)\n\
    \                    if (j > 0) dp(i)(j) = min(dp(i)(j), dp(i)(j - 1) + capacity)\n\
    \                }\n            }\n        }\n        var ans = 0L\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    ans += capacity - dp(i)(j)\n                }\n\
    \            }\n        }\n        ans", "        val n = grid.length\n      \
    \  val m = grid(0).length\n        val wells = Array.ofDim[Long](n, m)\n     \
    \   for (i <- 0 until n) {\n            var sum = 0L\n            for (j <- 0\
    \ until m) {\n                sum += grid(i)(j)\n                wells(i)(j) =\
    \ sum\n            }\n        }\n        val dp = Array.ofDim[Long](n, m)\n  \
    \      for (i <- 0 until n) {\n            for (j <- 0 until m) {\n          \
    \      if (i == 0) {\n                    dp(i)(j) = wells(i)(j)\n           \
    \     } else {\n                    var min = Long.MaxValue\n                \
    \    for (k <- 0 to j) {\n                        val fill = wells(i)(j) - wells(i)(k)\n\
    \                        val empty = capacity - fill\n                       \
    \ val prev = if (k == 0) 0 else dp(i - 1)(k - 1)\n                        min\
    \ = min min (prev + empty)\n                    }\n                    dp(i)(j)\
    \ = min\n                }\n            }\n        }\n        dp(n - 1)(m - 1)",
  "        val n = grid.length\n        val m = grid(0).length\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            var sum = 0L\n           \
    \ for (j <- 0 until m) {\n                sum += grid(i)(j)\n                if\
    \ (sum == capacity) {\n                    result += 1\n                    sum\
    \ = 0\n                } else if (sum > capacity) {\n                    result\
    \ += 1\n                    sum = grid(i)(j)\n                }\n            }\n\
    \            if (sum > 0) result += 1\n        }\n        result", "        //\
    \ Fill the wells with water until they are full.\n        // Then, empty the wells\
    \ until they are empty.\n        // Repeat until all wells are empty.\n      \
    \  // Time - O(n^2)\n        // Space - O(n)\n        def fill(grid : List[List[Long]])\
    \ : Long = {\n            var count = 0\n            for (row <- grid) {\n   \
    \             var sum = 0\n                for (i <- 0 until row.length) {\n \
    \                   sum += row(i)\n                    if (sum == capacity) {\n\
    \                        count += 1\n                        sum = 0\n       \
    \             }\n                }\n            }\n            count\n       \
    \ }\n        def empty(grid : List[List[Long]]) : Long = {\n            var count\
    \ = 0\n            for (row <- grid) {\n                var sum = 0\n        \
    \        for (i <- row.length - 1 to 0 by -1) {\n                    sum += row(i)\n\
    \                    if (sum == capacity) {\n                        count +=\
    \ 1\n                        sum = 0\n                    }\n                }\n\
    \            }\n            count\n        }\n        def isEmpty(grid : List[List[Long]])\
    \ : Boolean = {\n            for (row <- grid) {\n                for (i <- 0\
    \ until row.length) {\n                    if (row(i) == 1) return false\n   \
    \             }\n            }\n            true\n        }\n        var count\
    \ = 0\n        while (!isEmpty(grid)) {\n            count += fill(grid)\n   \
    \         count += empty(grid)\n        }\n        count", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val wells = Array.ofDim[Long](n, m)\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        wells(i)(j) = grid(i)(j)\n            }\n        }\n        var count\
    \ = 0\n        var done = false\n        while (!done) {\n            done = true\n\
    \            for (i <- 0 until n) {\n                for (j <- 0 until m) {\n\
    \                    if (wells(i)(j) > 0) {\n                        done = false\n\
    \                        wells(i)(j) -= capacity\n                        if (wells(i)(j)\
    \ < 0) wells(i)(j) = 0\n                    }\n                }\n           \
    \ }\n            count += 1\n        }\n        count - 1", "        val n = grid.length\n\
    \        val m = grid(0).length\n        var ans = 0\n        for (i <- 0 until\
    \ n) {\n            var sum = 0\n            for (j <- 0 until m) {\n        \
    \        sum += grid(i)(j)\n                if (sum == capacity) {\n         \
    \           ans += 1\n                    sum = 0\n                }\n       \
    \     }\n            if (sum > 0) ans += 1\n        }\n        ans", "       \
    \ val n = grid.length\n        val m = grid(0).length\n        val maxFill = Array.ofDim[Long](n,\
    \ m)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n   \
    \             if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = capacity\n\
    \                }\n            }\n        }\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (i > 0) {\n          \
    \          maxFill(i)(j) = min(maxFill(i)(j), maxFill(i - 1)(j))\n           \
    \     }\n                if (j > 0) {\n                    maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i)(j - 1))\n                }\n            }\n        }\n        var\
    \ result = 0L\n        for (i <- n - 1 to 0 by -1) {\n            for (j <- m\
    \ - 1 to 0 by -1) {\n                if (grid(i)(j) == 1) {\n                \
    \    if (i < n - 1) {\n                        maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i + 1)(j))\n                    }\n                    if (j < m - 1)\
    \ {\n                        maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j +\
    \ 1))\n                    }\n                    result += maxFill(i)(j)\n  \
    \              }\n            }\n        }\n        result", "        var maxFill\
    \ = 0\n        for (row <- grid) {\n            var fill = 0\n            for\
    \ (well <- row) {\n                if (well == 1) {\n                    fill\
    \ += 1\n                } else {\n                    if (fill > 0) {\n      \
    \                  maxFill += 1\n                        fill = 0\n          \
    \          }\n                }\n            }\n            if (fill > 0) {\n\
    \                maxFill += 1\n            }\n        }\n        return maxFill",
  "        val n = grid.length\n        val m = grid(0).length\n        val fill =\
    \ Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until m) {\n                if (grid(i)(j) == 1) {\n                  \
    \  fill(i)(j) = capacity\n                }\n            }\n        }\n      \
    \  var count = 0\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (fill(i)(j) > 0) {\n                    if (i > 0 &&\
    \ fill(i - 1)(j) > 0) {\n                        val diff = min(fill(i)(j), fill(i\
    \ - 1)(j))\n                        fill(i)(j) -= diff\n                     \
    \   fill(i - 1)(j) -= diff\n                        count += 1\n             \
    \       }\n                    if (j > 0 && fill(i)(j - 1) > 0) {\n          \
    \              val diff = min(fill(i)(j), fill(i)(j - 1))\n                  \
    \      fill(i)(j) -= diff\n                        fill(i)(j - 1) -= diff\n  \
    \                      count += 1\n                    }\n                }\n\
    \            }\n        }\n        count", "        val n = grid.length\n    \
    \    val m = grid(0).length\n        val maxFill = Array.ofDim[Long](n, m)\n \
    \       for (i <- 0 until n) {\n            for (j <- 0 until m) {\n         \
    \       if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = capacity\n\
    \                }\n            }\n        }\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    if (i > 0) {\n                        maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i - 1)(j) + capacity)\n                    }\n                    if\
    \ (j > 0) {\n                        maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j\
    \ - 1) + capacity)\n                    }\n                }\n            }\n\
    \        }\n        maxFill(n - 1)(m - 1)", "        val n = grid.length\n   \
    \     val m = grid(0).length\n        var result = 0\n        for (i <- 0 until\
    \ n) {\n            var sum = 0\n            for (j <- 0 until m) {\n        \
    \        sum += grid(i)(j)\n                if (sum == capacity) {\n         \
    \           result += 1\n                    sum = 0\n                }\n    \
    \        }\n            if (sum > 0) result += 1\n        }\n        result",
  "        val m = grid.length\n        val n = grid(0).length\n        val maxFill\
    \ = Array.ofDim[Long](m, n)\n        for (i <- 0 until m) {\n            for (j\
    \ <- 0 until n) {\n                if (grid(i)(j) == 1) {\n                  \
    \  maxFill(i)(j) = capacity\n                }\n            }\n        }\n   \
    \     for (i <- 0 until m) {\n            for (j <- 0 until n) {\n           \
    \     if (i > 0) {\n                    maxFill(i)(j) = min(maxFill(i)(j), maxFill(i\
    \ - 1)(j))\n                }\n                if (j > 0) {\n                \
    \    maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j - 1))\n                }\n\
    \            }\n        }\n        var result = 0L\n        for (i <- m - 1 to\
    \ 0 by -1) {\n            for (j <- n - 1 to 0 by -1) {\n                if (grid(i)(j)\
    \ == 1) {\n                    if (i < m - 1) {\n                        maxFill(i)(j)\
    \ = min(maxFill(i)(j), maxFill(i + 1)(j))\n                    }\n           \
    \         if (j < n - 1) {\n                        maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i)(j + 1))\n                    }\n                    result += capacity\
    \ - maxFill(i)(j)\n                }\n            }\n        }\n        result",
  "        val n = grid.length\n        val m = grid(0).length\n        val fill =\
    \ Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until m) {\n                if (grid(i)(j) == 1) {\n                  \
    \  fill(i)(j) = capacity\n                }\n            }\n        }\n      \
    \  var count = 0\n        while (true) {\n            var changed = false\n  \
    \          for (i <- 0 until n) {\n                for (j <- 0 until m) {\n  \
    \                  if (fill(i)(j) > 0) {\n                        if (i > 0 &&\
    \ fill(i - 1)(j) < capacity) {\n                            val diff = min(fill(i)(j),\
    \ capacity - fill(i - 1)(j))\n                            fill(i)(j) -= diff\n\
    \                            fill(i - 1)(j) += diff\n                        \
    \    changed = true\n                        }\n                        if (i\
    \ < n - 1 && fill(i + 1)(j) < capacity) {\n                            val diff\
    \ = min(fill(i)(j), capacity - fill(i + 1)(j))\n                            fill(i)(j)\
    \ -= diff\n                            fill(i + 1)(j) += diff\n              \
    \              changed = true\n                        }\n                   \
    \     if (j > 0 && fill(i)(j - 1) < capacity) {\n                            val\
    \ diff = min(fill(i)(j), capacity - fill(i)(j - 1))\n                        \
    \    fill(i)(j) -= diff\n                            fill(i)(j - 1) += diff\n\
    \                            changed = true\n                        }\n     \
    \                   if (j < m - 1 && fill(i)(j + 1) < capacity) {\n          \
    \                  val diff = min(fill(i)(j), capacity - fill(i)(j + 1))\n   \
    \                         fill(i)(j) -= diff\n                            fill(i)(j\
    \ + 1) += diff\n                            changed = true\n                 \
    \       }\n                    }\n                }\n            }\n         \
    \   if (!changed) return count\n            count += 1\n        }\n        return\
    \ count", "        val n = grid.length\n        val m = grid(0).length\n     \
    \   val maxFill = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n  \
    \          for (j <- 0 until m) {\n                if (i == 0) maxFill(i)(j) =\
    \ grid(i)(j)\n                else maxFill(i)(j) = maxFill(i - 1)(j) + grid(i)(j)\n\
    \            }\n        }\n        var count = 0\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (maxFill(i)(j) > capacity)\
    \ {\n                    count += 1\n                    for (k <- 0 to i) {\n\
    \                        maxFill(k)(j) -= capacity\n                    }\n  \
    \              }\n            }\n        }\n        count", "        val rows\
    \ = grid.length\n        val cols = grid(0).length\n        var result = 0\n \
    \       for (i <- 0 until rows) {\n            var rowSum = 0\n            for\
    \ (j <- 0 until cols) {\n                rowSum += grid(i)(j)\n            }\n\
    \            result += (rowSum / capacity)\n            if (rowSum % capacity\
    \ != 0) result += 1\n        }\n        result", "        val maxRow = grid.map(row\
    \ => row.sum).max\n        val maxCol = grid.transpose.map(col => col.sum).max\n\
    \        max(maxRow, maxCol)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        var result = 0L\n        for (i <- 0 until n) {\n            var sum\
    \ = 0L\n            for (j <- 0 until m) {\n                sum += grid(i)(j)\n\
    \                if (sum == capacity) {\n                    result += 1\n   \
    \                 sum = 0\n                } else if (sum > capacity) {\n    \
    \                result += 1\n                    sum = grid(i)(j)\n         \
    \       }\n            }\n            if (sum > 0) result += 1\n        }\n  \
    \      result", "        var maxFill = 0L\n        for (row <- grid) {\n     \
    \       var currentFill = 0L\n            for (well <- row) {\n              \
    \  if (well == 1) {\n                    currentFill += 1\n                } else\
    \ {\n                    if (currentFill > maxFill) {\n                      \
    \  maxFill = currentFill\n                    }\n                    currentFill\
    \ = 0\n                }\n            }\n            if (currentFill > maxFill)\
    \ {\n                maxFill = currentFill\n            }\n        }\n       \
    \ maxFill", "        var maxFill = 0\n        for (i <- 0 until grid.length) {\n\
    \            var fill = 0\n            for (j <- 0 until grid(i).length) {\n \
    \               if (grid(i)(j) == 1) fill += 1\n            }\n            maxFill\
    \ = max(maxFill, fill)\n        }\n        maxFill", "        var maxFill = 0L\n\
    \        for (i <- 0 until grid.length) {\n            var fill = 0L\n       \
    \     for (j <- 0 until grid(i).length) {\n                if (grid(i)(j) == 1)\
    \ fill += 1\n            }\n            maxFill = max(maxFill, fill)\n       \
    \ }\n        maxFill", "        var maxFill = 0L\n        for (i <- 0 until grid.length)\
    \ {\n            var fill = 0L\n            for (j <- 0 until grid(i).length)\
    \ {\n                if (grid(i)(j) == 1) fill += 1\n            }\n         \
    \   maxFill = max(maxFill, fill)\n        }\n        maxFill", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        var result = 0L\n   \
    \     for (i <- 0 until n) {\n            var sum = 0L\n            for (j <-\
    \ 0 until m) {\n                sum += grid(i)(j)\n                if (sum > capacity)\
    \ {\n                    result += sum - capacity\n                    sum = capacity\n\
    \                }\n            }\n        }\n        result", "        val rows\
    \ = grid.length\n        val cols = grid(0).length\n        val maxFill = Array.ofDim[Long](rows,\
    \ cols)\n        for (i <- 0 until rows) {\n            for (j <- 0 until cols)\
    \ {\n                if (grid(i)(j) == 1) {\n                    maxFill(i)(j)\
    \ = capacity\n                }\n            }\n        }\n        var count =\
    \ 0\n        while (maxFill.map(_.sum).sum > 0) {\n            for (i <- 0 until\
    \ rows) {\n                for (j <- 0 until cols) {\n                    if (maxFill(i)(j)\
    \ > 0) {\n                        if (i > 0 && maxFill(i - 1)(j) > 0) {\n    \
    \                        val diff = min(maxFill(i)(j), maxFill(i - 1)(j))\n  \
    \                          maxFill(i)(j) -= diff\n                           \
    \ maxFill(i - 1)(j) -= diff\n                        }\n                     \
    \   if (j > 0 && maxFill(i)(j - 1) > 0) {\n                            val diff\
    \ = min(maxFill(i)(j), maxFill(i)(j - 1))\n                            maxFill(i)(j)\
    \ -= diff\n                            maxFill(i)(j - 1) -= diff\n           \
    \             }\n                        if (i < rows - 1 && maxFill(i + 1)(j)\
    \ > 0) {\n                            val diff = min(maxFill(i)(j), maxFill(i\
    \ + 1)(j))\n                            maxFill(i)(j) -= diff\n              \
    \              maxFill(i + 1)(j) -= diff\n                        }\n        \
    \                if (j < cols - 1 && maxFill(i)(j + 1) > 0) {\n              \
    \              val diff = min(maxFill(i)(j), maxFill(i)(j + 1))\n            \
    \                maxFill(i)(j) -= diff\n                            maxFill(i)(j\
    \ + 1) -= diff\n                        }\n                    }\n           \
    \     }\n            }\n            count += 1\n        }\n        count", " \
    \       var max = 0L\n        for (row <- grid) {\n            var sum = 0L\n\
    \            for (col <- row) {\n                sum += col\n                if\
    \ (sum > capacity) {\n                    max += 1\n                    sum =\
    \ col\n                }\n            }\n            if (sum > 0) max += 1\n \
    \       }\n        max", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val wells = grid.map(_.toArray).toArray\n        var count = 0L\n   \
    \     for (i <- 0 until n) {\n            var sum = 0L\n            for (j <-\
    \ 0 until m) {\n                sum += wells(i)(j)\n                if (sum >\
    \ capacity) {\n                    count += sum - capacity\n                 \
    \   wells(i)(j) = capacity\n                    sum = capacity\n             \
    \   }\n            }\n        }\n        count", "        val m = grid.length\n\
    \        val n = grid(0).length\n        val maxFill = Array.ofDim[Long](m, n)\n\
    \        for (i <- 0 until m) {\n            for (j <- 0 until n) {\n        \
    \        if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = capacity\n\
    \                }\n            }\n        }\n        for (i <- 0 until m) {\n\
    \            for (j <- 0 until n) {\n                if (grid(i)(j) == 1) {\n\
    \                    if (i > 0) {\n                        maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i - 1)(j) + capacity)\n                    }\n                    if\
    \ (j > 0) {\n                        maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j\
    \ - 1) + capacity)\n                    }\n                }\n            }\n\
    \        }\n        maxFill(m - 1)(n - 1)", "        val n = grid.length\n   \
    \     val m = grid(0).length\n        var count = 0L\n        for (i <- 0 until\
    \ n) {\n            var sum = 0L\n            for (j <- 0 until m) {\n       \
    \         sum += grid(i)(j)\n                if (sum == capacity) {\n        \
    \            count += 1\n                    sum = 0\n                }\n    \
    \        }\n            if (sum > 0) count += 1\n        }\n        count", " \
    \       val n = grid.length\n        val m = grid(0).length\n        var total\
    \ = 0L\n        for (i <- 0 until n) {\n            var sum = 0L\n           \
    \ for (j <- 0 until m) {\n                sum += grid(i)(j)\n            }\n \
    \           total += sum / capacity\n            if (sum % capacity != 0) total\
    \ += 1\n        }\n        total", "        val n = grid.length\n        val m\
    \ = grid(0).length\n        val dp = Array.ofDim[Long](n, m)\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until m) {\n                dp(i)(j) =\
    \ grid(i)(j)\n                if (i > 0) dp(i)(j) = max(dp(i)(j), dp(i - 1)(j))\n\
    \                if (j > 0) dp(i)(j) = max(dp(i)(j), dp(i)(j - 1))\n         \
    \   }\n        }\n        var result = 0L\n        for (i <- 0 until n) {\n  \
    \          for (j <- 0 until m) {\n                val fill = min(capacity, dp(i)(j))\n\
    \                result += fill\n                dp(i)(j) -= fill\n          \
    \      if (i > 0) dp(i - 1)(j) = max(dp(i - 1)(j), dp(i)(j))\n               \
    \ if (j > 0) dp(i)(j - 1) = max(dp(i)(j - 1), dp(i)(j))\n            }\n     \
    \   }\n        result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val wells = grid.map(_.toArray).toArray\n        var count = 0L\n   \
    \     for (i <- 0 until n) {\n            var sum = 0L\n            for (j <-\
    \ 0 until m) {\n                sum += wells(i)(j)\n                if (sum >\
    \ capacity) {\n                    wells(i)(j) -= (sum - capacity)\n         \
    \           count += (sum - capacity)\n                    sum = capacity\n  \
    \              }\n            }\n        }\n        for (j <- 0 until m) {\n \
    \           var sum = 0L\n            for (i <- 0 until n) {\n               \
    \ sum += wells(i)(j)\n                if (sum > capacity) {\n                \
    \    wells(i)(j) -= (sum - capacity)\n                    count += (sum - capacity)\n\
    \                    sum = capacity\n                }\n            }\n      \
    \  }\n        count", "        val rows = grid.length\n        val cols = grid(0).length\n\
    \        val maxFill = Array.ofDim[Long](rows, cols)\n        for (i <- 0 until\
    \ rows) {\n            for (j <- 0 until cols) {\n                if (grid(i)(j)\
    \ == 1) {\n                    maxFill(i)(j) = capacity\n                }\n \
    \           }\n        }\n        var count = 0\n        var done = false\n  \
    \      while (!done) {\n            done = true\n            for (i <- 0 until\
    \ rows) {\n                for (j <- 0 until cols) {\n                    if (maxFill(i)(j)\
    \ > 0) {\n                        done = false\n                        val fill\
    \ = min(maxFill(i)(j), capacity)\n                        maxFill(i)(j) -= fill\n\
    \                        if (i > 0) maxFill(i - 1)(j) += fill\n              \
    \          if (i < rows - 1) maxFill(i + 1)(j) += fill\n                     \
    \   if (j > 0) maxFill(i)(j - 1) += fill\n                        if (j < cols\
    \ - 1) maxFill(i)(j + 1) += fill\n                    }\n                }\n \
    \           }\n            count += 1\n        }\n        count - 1", "      \
    \  val maxFill = grid.map(x => x.sum).max\n        val fillCount = maxFill / capacity\n\
    \        val remainder = maxFill % capacity\n        if (remainder == 0) fillCount\
    \ else fillCount + 1", "        // for each row, find the first and last 1\n \
    \       // if the distance between them is less than capacity, then fill the row\n\
    \        // otherwise, fill the row until the first 1, then fill the row until\
    \ the last 1\n        // then fill the row until the first 1, then fill the row\
    \ until the last 1, etc.\n        // until the row is filled\n        // then\
    \ repeat for the next row\n        // return the number of times you filled the\
    \ row\n        val n = grid.length\n        val m = grid(0).length\n        var\
    \ count = 0L\n        for (i <- 0 until n) {\n            var first = -1\n   \
    \         var last = -1\n            for (j <- 0 until m) {\n                if\
    \ (grid(i)(j) == 1) {\n                    if (first == -1) first = j\n      \
    \              last = j\n                }\n            }\n            if (last\
    \ - first + 1 <= capacity) {\n                count += 1\n            } else {\n\
    \                var j = first\n                while (j <= last) {\n        \
    \            count += 1\n                    j += capacity\n                }\n\
    \            }\n        }\n        count", "        val m = grid.length\n    \
    \    val n = grid(0).length\n        val dp = Array.ofDim[Long](m, n)\n      \
    \  for (i <- 0 until m) {\n            for (j <- 0 until n) {\n              \
    \  dp(i)(j) = grid(i)(j)\n                if (i > 0) dp(i)(j) = max(dp(i)(j),\
    \ dp(i - 1)(j))\n                if (j > 0) dp(i)(j) = max(dp(i)(j), dp(i)(j -\
    \ 1))\n            }\n        }\n        var result = 0L\n        for (i <- 0\
    \ until m) {\n            for (j <- 0 until n) {\n                if (dp(i)(j)\
    \ > 0) {\n                    result += dp(i)(j) / capacity\n                \
    \    if (dp(i)(j) % capacity > 0) result += 1\n                }\n           \
    \ }\n        }\n        result", "        val n = grid.length\n        val m =\
    \ grid(0).length\n        val dp = Array.ofDim[Long](n, m)\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until m) {\n                if (i == 0)\
    \ {\n                    dp(i)(j) = grid(i)(j)\n                } else {\n   \
    \                 dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n                }\n  \
    \          }\n        }\n        var ans = 0L\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (dp(i)(j) > capacity)\
    \ {\n                    ans += dp(i)(j) - capacity\n                    dp(i)(j)\
    \ = capacity\n                }\n            }\n        }\n        ans", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until m) {\n                if (grid(i)(j) == 1) {\n                  \
    \  maxFill(i)(j) = capacity\n                }\n            }\n        }\n   \
    \     for (i <- 0 until n) {\n            for (j <- 0 until m) {\n           \
    \     if (i > 0) {\n                    maxFill(i)(j) = min(maxFill(i)(j), maxFill(i\
    \ - 1)(j))\n                }\n                if (j > 0) {\n                \
    \    maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j - 1))\n                }\n\
    \            }\n        }\n        var result = 0L\n        for (i <- n - 1 to\
    \ 0 by -1) {\n            for (j <- m - 1 to 0 by -1) {\n                if (grid(i)(j)\
    \ == 1) {\n                    if (i < n - 1) {\n                        maxFill(i)(j)\
    \ = min(maxFill(i)(j), maxFill(i + 1)(j))\n                    }\n           \
    \         if (j < m - 1) {\n                        maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i)(j + 1))\n                    }\n                    result += capacity\
    \ - maxFill(i)(j)\n                }\n            }\n        }\n        result",
  "        val rows = grid.length\n        val cols = grid(0).length\n        val\
    \ maxFill = Array.ofDim[Long](rows, cols)\n        for (i <- 0 until rows) {\n\
    \            for (j <- 0 until cols) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = capacity\n                }\n           \
    \ }\n        }\n        for (i <- 0 until rows) {\n            for (j <- 0 until\
    \ cols) {\n                if (i > 0) {\n                    maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i - 1)(j))\n                }\n                if (j > 0) {\n      \
    \              maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j - 1))\n       \
    \         }\n            }\n        }\n        for (i <- rows - 1 to 0 by -1)\
    \ {\n            for (j <- cols - 1 to 0 by -1) {\n                if (i < rows\
    \ - 1) {\n                    maxFill(i)(j) = min(maxFill(i)(j), maxFill(i + 1)(j))\n\
    \                }\n                if (j < cols - 1) {\n                    maxFill(i)(j)\
    \ = min(maxFill(i)(j), maxFill(i)(j + 1))\n                }\n            }\n\
    \        }\n        var result = 0L\n        for (i <- 0 until rows) {\n     \
    \       for (j <- 0 until cols) {\n                if (grid(i)(j) == 1) {\n  \
    \                  result += capacity - maxFill(i)(j)\n                }\n   \
    \         }\n        }\n        result", "        val n = grid.length\n      \
    \  val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m)\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (i\
    \ == 0) dp(i)(j) = grid(i)(j)\n                else dp(i)(j) = dp(i - 1)(j) +\
    \ grid(i)(j)\n            }\n        }\n        var ans = 0L\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until m) {\n                if (dp(i)(j)\
    \ > capacity) {\n                    ans += dp(i)(j) - capacity\n            \
    \        for (k <- 0 to i) dp(k)(j) = capacity\n                }\n          \
    \  }\n        }\n        ans", "        val maxFill = grid.map(x => x.sum).max\n\
    \        if (maxFill <= capacity) return 1\n        val maxFillRow = grid.zipWithIndex.filter(x\
    \ => x._1.sum == maxFill).head._2\n        val maxFillCol = grid(maxFillRow).zipWithIndex.filter(x\
    \ => x._1 == 1).head._2\n        val maxFillRowCount = grid(maxFillRow).count(x\
    \ => x == 1)\n        val maxFillColCount = grid.map(x => x(maxFillCol)).count(x\
    \ => x == 1)\n        val maxFillRowCountFill = (maxFillRowCount / capacity).toLong\
    \ + (if (maxFillRowCount % capacity == 0) 0 else 1)\n        val maxFillColCountFill\
    \ = (maxFillColCount / capacity).toLong + (if (maxFillColCount % capacity == 0)\
    \ 0 else 1)\n        max(maxFillRowCountFill, maxFillColCountFill)", "       \
    \ var maxFill = 0L\n        for (row <- grid) {\n            var fill = 0L\n \
    \           for (well <- row) {\n                if (well == 1) fill += 1\n  \
    \              else {\n                    maxFill = max(maxFill, fill)\n    \
    \                fill = 0\n                }\n            }\n            maxFill\
    \ = max(maxFill, fill)\n        }\n        maxFill / capacity", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val maxFill = Array.ofDim[Long](n,\
    \ m)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n   \
    \             if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = capacity\n\
    \                }\n            }\n        }\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (i > 0) {\n          \
    \          maxFill(i)(j) = min(maxFill(i)(j), maxFill(i - 1)(j))\n           \
    \     }\n                if (j > 0) {\n                    maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i)(j - 1))\n                }\n            }\n        }\n        var\
    \ result = 0L\n        for (i <- n - 1 to 0 by -1) {\n            for (j <- m\
    \ - 1 to 0 by -1) {\n                if (grid(i)(j) == 1) {\n                \
    \    val fill = maxFill(i)(j)\n                    if (fill > 0) {\n         \
    \               result += 1\n                        if (i > 0) {\n          \
    \                  maxFill(i - 1)(j) -= fill\n                        }\n    \
    \                    if (j > 0) {\n                            maxFill(i)(j -\
    \ 1) -= fill\n                        }\n                    }\n             \
    \   }\n            }\n        }\n        result", "        var total = 0L\n  \
    \      var max = 0L\n        for (i <- 0 until grid.length) {\n            var\
    \ count = 0L\n            for (j <- 0 until grid(i).length) {\n              \
    \  if (grid(i)(j) == 1) count += 1\n            }\n            if (count > max)\
    \ max = count\n            total += count\n        }\n        val result = total\
    \ / capacity\n        if (total % capacity == 0) result\n        else result +\
    \ 1", "        val n = grid.length\n        val m = grid(0).length\n        val\
    \ maxFill = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n        \
    \    for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n        \
    \            maxFill(i)(j) = capacity\n                }\n            }\n    \
    \    }\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n \
    \               if (grid(i)(j) == 1) {\n                    if (i > 0) {\n   \
    \                     maxFill(i)(j) = min(maxFill(i)(j), maxFill(i - 1)(j) + capacity)\n\
    \                    }\n                    if (j > 0) {\n                   \
    \     maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j - 1) + capacity)\n     \
    \               }\n                }\n            }\n        }\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n \
    \               if (grid(i)(j) == 1) {\n                    result = max(result,\
    \ maxFill(i)(j))\n                }\n            }\n        }\n        result",
  "        val height = grid.length\n        val width = grid(0).length\n        val\
    \ maxFill = Array.fill(height)(Array.fill(width)(0L))\n        for (i <- 0 until\
    \ height) {\n            for (j <- 0 until width) {\n                if (grid(i)(j)\
    \ == 1) {\n                    maxFill(i)(j) = capacity\n                }\n \
    \           }\n        }\n        for (i <- 1 until height) {\n            for\
    \ (j <- 0 until width) {\n                if (grid(i)(j) == 1) {\n           \
    \         maxFill(i)(j) = min(maxFill(i - 1)(j), capacity)\n                }\n\
    \            }\n        }\n        for (i <- height - 2 to 0 by -1) {\n      \
    \      for (j <- 0 until width) {\n                if (grid(i)(j) == 1) {\n  \
    \                  maxFill(i)(j) = min(maxFill(i + 1)(j), maxFill(i)(j))\n   \
    \             }\n            }\n        }\n        var count = 0L\n        for\
    \ (i <- 0 until height) {\n            for (j <- 0 until width) {\n          \
    \      if (grid(i)(j) == 1) {\n                    count += capacity - maxFill(i)(j)\n\
    \                }\n            }\n        }\n        count", "        val n =\
    \ grid.length\n        val m = grid(0).length\n        var ans = 0L\n        for\
    \ (i <- 0 until n) {\n            var sum = 0L\n            for (j <- 0 until\
    \ m) {\n                sum += grid(i)(j)\n                if (sum == capacity)\
    \ {\n                    ans += 1\n                    sum = 0\n             \
    \   } else if (sum > capacity) {\n                    ans += 1\n             \
    \       sum = grid(i)(j)\n                }\n            }\n            if (sum\
    \ > 0) ans += 1\n        }\n        ans", "        val n = grid.length\n     \
    \   val m = grid(0).length\n        val wells = Array.ofDim[Long](n, m)\n    \
    \    for (i <- 0 until n) {\n            for (j <- 0 until m) {\n            \
    \    wells(i)(j) = grid(i)(j)\n            }\n        }\n        var count = 0\n\
    \        var done = false\n        while (!done) {\n            done = true\n\
    \            for (i <- 0 until n) {\n                for (j <- 0 until m) {\n\
    \                    if (wells(i)(j) > 0) {\n                        done = false\n\
    \                        wells(i)(j) -= capacity\n                        count\
    \ += 1\n                    }\n                }\n            }\n        }\n \
    \       count", "        var maxFill = 0L\n        for (i <- 0 until grid.length)\
    \ {\n            var fill = 0L\n            for (j <- 0 until grid(i).length)\
    \ {\n                if (grid(i)(j) == 1) fill += 1\n            }\n         \
    \   maxFill = max(maxFill, fill)\n        }\n        maxFill", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val wells = grid.map(row\
    \ => row.sum)\n        val buckets = new Array[Long](n)\n        var count = 0\n\
    \        while (true) {\n            var filled = false\n            for (i <-\
    \ 0 until n) {\n                if (buckets(i) < capacity && wells(i) > 0) {\n\
    \                    filled = true\n                    buckets(i) += 1\n    \
    \                wells(i) -= 1\n                }\n            }\n           \
    \ if (!filled) return count\n            count += 1\n        }\n        return\
    \ count", "        val n = grid.length\n        val m = grid(0).length\n     \
    \   val maxFill = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n  \
    \          for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n  \
    \                  maxFill(i)(j) = capacity\n                }\n            }\n\
    \        }\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                if (i > 0) {\n                    maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i - 1)(j))\n                }\n                if (j > 0) {\n      \
    \              maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j - 1))\n       \
    \         }\n            }\n        }\n        var result = 0L\n        for (i\
    \ <- n - 1 to 0 by -1) {\n            for (j <- m - 1 to 0 by -1) {\n        \
    \        if (grid(i)(j) == 1) {\n                    var fill = maxFill(i)(j)\n\
    \                    if (i < n - 1) {\n                        fill = min(fill,\
    \ maxFill(i + 1)(j))\n                    }\n                    if (j < m - 1)\
    \ {\n                        fill = min(fill, maxFill(i)(j + 1))\n           \
    \         }\n                    if (fill < maxFill(i)(j)) {\n               \
    \         maxFill(i)(j) = fill\n                        result += 1\n        \
    \            }\n                }\n            }\n        }\n        result",
  "        val maxFill = grid.map(row => row.sum).max\n        val numFills = maxFill\
    \ / capacity\n        val remainder = maxFill % capacity\n        if (remainder\
    \ == 0) numFills else numFills + 1", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val maxFill = Array.ofDim[Long](n, m)\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    maxFill(i)(j) = capacity\n                }\n \
    \           }\n        }\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                if (grid(i)(j) == 1) {\n                    if\
    \ (i > 0) {\n                        maxFill(i)(j) = min(maxFill(i)(j), maxFill(i\
    \ - 1)(j) + capacity)\n                    }\n                    if (j > 0) {\n\
    \                        maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j - 1)\
    \ + capacity)\n                    }\n                }\n            }\n     \
    \   }\n        maxFill(n - 1)(m - 1)", "        val wells = grid.map(row => row.sum).toArray\n\
    \        var total = wells.sum\n        var count = 0\n        while (total >\
    \ 0) {\n            for (i <- 0 until wells.length) {\n                if (wells(i)\
    \ > 0) {\n                    wells(i) -= min(wells(i), capacity)\n          \
    \          total -= min(wells(i), capacity)\n                }\n            }\n\
    \            count += 1\n        }\n        count", "        // 1. find the max\
    \ value in the grid\n        // 2. find the max value in each row\n        //\
    \ 3. find the max value in each column\n        // 4. find the max value in each\
    \ diagonal\n        // 5. find the max value in each anti-diagonal\n        //\
    \ 6. find the max value in each sub-grid\n        // 7. find the max value in\
    \ each sub-grid with a hole\n        // 8. find the max value in each sub-grid\
    \ with a hole and a diagonal\n        // 9. find the max value in each sub-grid\
    \ with a hole and an anti-diagonal\n        // 10. find the max value in each\
    \ sub-grid with a hole and a diagonal and an anti-diagonal\n        // 11. find\
    \ the max value in each sub-grid with a hole and a diagonal and an anti-diagonal\
    \ and a row\n        // 12. find the max value in each sub-grid with a hole and\
    \ a diagonal and an anti-diagonal and a column\n        // 13. find the max value\
    \ in each sub-grid with a hole and a diagonal and an anti-diagonal and a row and\
    \ a column\n        // 14. find the max value in each sub-grid with a hole and\
    \ a diagonal and an anti-diagonal and a row and a column and a diagonal\n    \
    \    // 15. find the max value in each sub-grid with a hole and a diagonal and\
    \ an anti-diagonal and a row and a column and an anti-diagonal\n        // 16.\
    \ find the max value in each sub-grid with a hole and a diagonal and an anti-diagonal\
    \ and a row and a column and a diagonal and an anti-diagonal\n        // 17. find\
    \ the max value in each sub-grid with a hole and a diagonal and an anti-diagonal\
    \ and a row and a column and a diagonal and an anti-diagonal and a row\n     \
    \   // 18. find the max value in each sub-grid with a hole and a diagonal and\
    \ an anti-diagonal and a row and a column and a diagonal and an anti-diagonal\
    \ and a column\n        // 19. find the max value in each sub-grid with a hole\
    \ and a diagonal and an anti-diagonal and a row and a column and a diagonal and\
    \ an anti-diagonal and a row and a column\n        // 20. find the max value in",
  "        val maxFill = grid.map(row => row.sum).max\n        val numBuckets = maxFill\
    \ / capacity\n        if (maxFill % capacity == 0) numBuckets else numBuckets\
    \ + 1", "        // Fill the first row\n        var filled = grid(0).map(x =>\
    \ if (x > capacity) capacity else x)\n        // Fill the remaining rows\n   \
    \     for (i <- 1 until grid.length) {\n            val row = grid(i)\n      \
    \      val newFilled = new Array[Long](row.length)\n            for (j <- 0 until\
    \ row.length) {\n                newFilled(j) = min(filled(j), row(j))\n     \
    \       }\n            filled = newFilled\n        }\n        // Count the number\
    \ of times we had to fill the buckets\n        var count = 0L\n        for (i\
    \ <- 0 until grid.length) {\n            val row = grid(i)\n            for (j\
    \ <- 0 until row.length) {\n                count += (row(j) - filled(j))\n  \
    \          }\n        }\n        count", "        val rowCount = grid.length\n\
    \        val colCount = grid(0).length\n        val rowMax = grid.map(row => row.sum)\n\
    \        val colMax = (0 until colCount).map(col => grid.map(row => row(col)).sum)\n\
    \        val rowMaxCount = rowMax.map(x => (x + capacity - 1) / capacity).sum\n\
    \        val colMaxCount = colMax.map(x => (x + capacity - 1) / capacity).sum\n\
    \        val maxCount = max(rowMaxCount, colMaxCount)\n        maxCount", "  \
    \      var count = 0\n        var filled = 0\n        for (i <- 0 until grid.length)\
    \ {\n            var row = grid(i)\n            var fill = 0\n            for\
    \ (j <- 0 until row.length) {\n                if (row(j) == 1) {\n          \
    \          fill += 1\n                }\n            }\n            if (fill >\
    \ capacity) {\n                count += fill - capacity\n                filled\
    \ += capacity\n            } else {\n                filled += fill\n        \
    \    }\n        }\n        return count", "        val rows = grid.length\n  \
    \      val cols = grid(0).length\n        val maxFill = new Array[Array[Long]](rows)\n\
    \        for (i <- 0 until rows) {\n            maxFill(i) = new Array[Long](cols)\n\
    \            for (j <- 0 until cols) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = capacity\n                }\n           \
    \ }\n        }\n        for (i <- 0 until rows) {\n            for (j <- 0 until\
    \ cols) {\n                if (grid(i)(j) == 1) {\n                    if (i >\
    \ 0) {\n                        val fill = min(maxFill(i - 1)(j), capacity - maxFill(i)(j))\n\
    \                        maxFill(i - 1)(j) -= fill\n                        maxFill(i)(j)\
    \ += fill\n                    }\n                    if (j > 0) {\n         \
    \               val fill = min(maxFill(i)(j - 1), capacity - maxFill(i)(j))\n\
    \                        maxFill(i)(j - 1) -= fill\n                        maxFill(i)(j)\
    \ += fill\n                    }\n                }\n            }\n        }\n\
    \        var count = 0\n        for (i <- 0 until rows) {\n            for (j\
    \ <- 0 until cols) {\n                if (grid(i)(j) == 1) {\n               \
    \     count += 1\n                }\n            }\n        }\n        count",
  "        var fillCount = 0\n        var maxFill = 0\n        for (row <- grid) {\n\
    \            for (well <- row) {\n                if (well == 1) {\n         \
    \           fillCount += 1\n                    if (fillCount == capacity) {\n\
    \                        maxFill += 1\n                        fillCount = 0\n\
    \                    }\n                }\n            }\n        }\n        maxFill",
  "        val n = grid.length\n        val m = grid(0).length\n        var count\
    \ = 0\n        for (i <- 0 until n) {\n            var sum = 0\n            for\
    \ (j <- 0 until m) {\n                sum += grid(i)(j)\n                if (sum\
    \ == capacity) {\n                    count += 1\n                    sum = 0\n\
    \                }\n            }\n            if (sum > 0) count += 1\n     \
    \   }\n        count", "        val maxFill = grid.map(row => row.sum).max\n \
    \       if (maxFill <= capacity) return 1\n        val numRows = grid.length\n\
    \        val numCols = grid(0).length\n        val numBuckets = numRows * numCols\n\
    \        val buckets = Array.fill(numBuckets)(0L)\n        var numFills = 0\n\
    \        while (buckets.sum < numBuckets * capacity) {\n            numFills +=\
    \ 1\n            for (i <- 0 until numRows) {\n                for (j <- 0 until\
    \ numCols) {\n                    val bucketIndex = i * numCols + j\n        \
    \            if (buckets(bucketIndex) < capacity) {\n                        val\
    \ fill = min(capacity - buckets(bucketIndex), grid(i)(j))\n                  \
    \      buckets(bucketIndex) += fill\n                        grid(i)(j) -= fill\n\
    \                    }\n                }\n            }\n        }\n        numFills",
  "        val n = grid.length\n        val m = grid(0).length\n        val fill =\
    \ Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n            var sum\
    \ = 0L\n            for (j <- 0 until m) {\n                sum += grid(i)(j)\n\
    \                fill(i)(j) = sum\n            }\n        }\n        var result\
    \ = 0L\n        for (j <- 0 until m) {\n            var sum = 0L\n           \
    \ for (i <- 0 until n) {\n                sum += fill(i)(j)\n                if\
    \ (sum > capacity) {\n                    result += sum - capacity\n         \
    \           sum = capacity\n                }\n            }\n        }\n    \
    \    result", "        val n = grid.length\n        val m = grid(0).length\n \
    \       val wells = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                wells(i)(j) = grid(i)(j)\n\
    \            }\n        }\n        var count = 0\n        var done = false\n \
    \       while (!done) {\n            done = true\n            for (i <- 0 until\
    \ n) {\n                for (j <- 0 until m) {\n                    if (wells(i)(j)\
    \ > 0) {\n                        done = false\n                        wells(i)(j)\
    \ -= capacity\n                        if (wells(i)(j) < 0) wells(i)(j) = 0\n\
    \                    }\n                }\n            }\n            count +=\
    \ 1\n        }\n        count - 1", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val maxFill = Array.ofDim[Long](n, m)\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    maxFill(i)(j) = capacity\n                }\n \
    \           }\n        }\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                if (i > 0) {\n                    maxFill(i)(j)\
    \ = min(maxFill(i)(j), maxFill(i - 1)(j))\n                }\n               \
    \ if (j > 0) {\n                    maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j\
    \ - 1))\n                }\n            }\n        }\n        for (i <- n - 1\
    \ to 0 by -1) {\n            for (j <- m - 1 to 0 by -1) {\n                if\
    \ (i < n - 1) {\n                    maxFill(i)(j) = min(maxFill(i)(j), maxFill(i\
    \ + 1)(j))\n                }\n                if (j < m - 1) {\n            \
    \        maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j + 1))\n             \
    \   }\n            }\n        }\n        var count = 0L\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j) ==\
    \ 1) {\n                    count += capacity - maxFill(i)(j)\n              \
    \  }\n            }\n        }\n        count", "        var total = 0L\n    \
    \    for (i <- 0 until grid.length) {\n            var fill = 0L\n           \
    \ for (j <- 0 until grid(i).length) {\n                if (grid(i)(j) == 1) fill\
    \ += 1\n            }\n            total += (fill / capacity)\n            if\
    \ (fill % capacity != 0) total += 1\n        }\n        total", "        var fill\
    \ = 0L\n        for (i <- 0 until grid.length) {\n            var row = grid(i)\n\
    \            var sum = 0L\n            for (j <- 0 until row.length) {\n     \
    \           sum += row(j)\n            }\n            fill += ceil(sum.toDouble\
    \ / capacity).toLong\n        }\n        fill", "        val maxFill = grid.map(x\
    \ => x.sum).max\n        if (maxFill <= capacity) 1 else (maxFill / capacity)\
    \ + 1", "        var result = 0L\n        for (i <- 0 until grid.length) {\n \
    \           var sum = 0L\n            for (j <- 0 until grid(i).length) {\n  \
    \              sum += grid(i)(j)\n            }\n            result += (sum /\
    \ capacity)\n            if (sum % capacity != 0) result += 1\n        }\n   \
    \     return result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (i == 0 && j == 0) maxFill(i)(j)\
    \ = grid(i)(j)\n                else if (i == 0) maxFill(i)(j) = maxFill(i)(j\
    \ - 1) + grid(i)(j)\n                else if (j == 0) maxFill(i)(j) = maxFill(i\
    \ - 1)(j) + grid(i)(j)\n                else maxFill(i)(j) = max(maxFill(i - 1)(j),\
    \ maxFill(i)(j - 1)) + grid(i)(j)\n            }\n        }\n        val maxFill2\
    \ = Array.ofDim[Long](n, m)\n        for (i <- n - 1 to 0 by -1) {\n         \
    \   for (j <- m - 1 to 0 by -1) {\n                if (i == n - 1 && j == m -\
    \ 1) maxFill2(i)(j) = grid(i)(j)\n                else if (i == n - 1) maxFill2(i)(j)\
    \ = maxFill2(i)(j + 1) + grid(i)(j)\n                else if (j == m - 1) maxFill2(i)(j)\
    \ = maxFill2(i + 1)(j) + grid(i)(j)\n                else maxFill2(i)(j) = max(maxFill2(i\
    \ + 1)(j), maxFill2(i)(j + 1)) + grid(i)(j)\n            }\n        }\n      \
    \  var result = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                val maxFill3 = maxFill(i)(j) + maxFill2(i)(j) - grid(i)(j)\n\
    \                if (maxFill3 > capacity) result += maxFill3 - capacity\n    \
    \        }\n        }\n        result", "        var count = 0L\n        for (i\
    \ <- 0 until grid.length) {\n            var sum = 0L\n            for (j <- 0\
    \ until grid(i).length) {\n                sum += grid(i)(j)\n            }\n\
    \            count += sum / capacity\n            if (sum % capacity != 0) count\
    \ += 1\n        }\n        count", "        // Fill the wells from the bottom\
    \ up.\n        // If the well is already full, then fill the next well.\n    \
    \    // If the well is not full, then fill it up.\n        // If the well is overfilled,\
    \ then fill the next well.\n        // If the well is filled, then move on to\
    \ the next well.\n        // If the well is not filled, then fill it up.\n   \
    \     // If the well is overfilled, then fill the next well.\n        // If the\
    \ well is filled, then move on to the next well.\n        // If the well is not\
    \ filled, then fill it up.\n        // If the well is overfilled, then fill the\
    \ next well.\n        // If the well is filled, then move on to the next well.\n\
    \        // If the well is not filled, then fill it up.\n        // If the well\
    \ is overfilled, then fill the next well.\n        // If the well is filled, then\
    \ move on to the next well.\n        // If the well is not filled, then fill it\
    \ up.\n        // If the well is overfilled, then fill the next well.\n      \
    \  // If the well is filled, then move on to the next well.\n        // If the\
    \ well is not filled, then fill it up.\n        // If the well is overfilled,\
    \ then fill the next well.\n        // If the well is filled, then move on to\
    \ the next well.\n        // If the well is not filled, then fill it up.\n   \
    \     // If the well is overfilled, then fill the next well.\n        // If the\
    \ well is filled, then move on to the next well.\n        // If the well is not\
    \ filled, then fill it up.\n        // If the well is overfilled, then fill the\
    \ next well.\n        // If the well is filled, then move on to the next well.\n\
    \        // If the well is not filled, then fill it up.\n        // If the well\
    \ is overfilled, then fill the next well.\n        // If the well is filled, then\
    \ move on to the next well.\n        // If the well is not filled, then fill it\
    \ up.\n        // If the well is overfilled, then fill the next well.\n      \
    \  // If the well is filled, then move on to the next well.\n        // If the",
  "        def fill(grid : List[List[Long]], capacity : Long, max : Long) : Long =\
    \ {\n            if (grid.isEmpty) max\n            else {\n                val\
    \ row = grid.head\n                val filled = row.map(min(_, capacity))\n  \
    \              val maxFilled = filled.max\n                val newGrid = grid.tail.map(row\
    \ => row.zip(filled).map(x => x._1 - x._2))\n                fill(newGrid, capacity,\
    \ max + maxFilled)\n            }\n        }\n        fill(grid, capacity, 0)",
  "        val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until m) {\n                if (grid(i)(j) == 1) {\n                  \
    \  maxFill(i)(j) = capacity\n                }\n            }\n        }\n   \
    \     val dp = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n     \
    \       for (j <- 0 until m) {\n                if (i == 0 && j == 0) {\n    \
    \                dp(i)(j) = maxFill(i)(j)\n                } else if (i == 0)\
    \ {\n                    dp(i)(j) = dp(i)(j - 1) + maxFill(i)(j)\n           \
    \     } else if (j == 0) {\n                    dp(i)(j) = dp(i - 1)(j) + maxFill(i)(j)\n\
    \                } else {\n                    dp(i)(j) = min(dp(i - 1)(j), dp(i)(j\
    \ - 1)) + maxFill(i)(j)\n                }\n            }\n        }\n       \
    \ dp(n - 1)(m - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        var result = 0L\n        for (i <- 0 until n) {\n            var sum\
    \ = 0L\n            for (j <- 0 until m) {\n                sum += grid(i)(j)\n\
    \                if (sum == capacity) {\n                    result += 1\n   \
    \                 sum = 0\n                } else if (sum > capacity) {\n    \
    \                result += 1\n                    sum = grid(i)(j)\n         \
    \       }\n            }\n            if (sum > 0) result += 1\n        }\n  \
    \      result", "        val rowCount = grid.length\n        val colCount = grid(0).length\n\
    \        var fillCount = 0L\n        for (i <- 0 until rowCount) {\n         \
    \   var fill = 0L\n            for (j <- 0 until colCount) {\n               \
    \ if (grid(i)(j) == 1) {\n                    fill += 1\n                }\n \
    \           }\n            if (fill > capacity) {\n                fillCount +=\
    \ fill / capacity\n                if (fill % capacity != 0) {\n             \
    \       fillCount += 1\n                }\n            }\n        }\n        fillCount",
  "        var count = 0L\n        while (grid.exists(x => x.sum > 0)) {\n       \
    \     for (i <- 0 until grid.length) {\n                if (grid(i).sum > 0) {\n\
    \                    for (j <- 0 until grid(i).length) {\n                   \
    \     if (grid(i)(j) > 0) {\n                            grid(i)(j) = max(grid(i)(j)\
    \ - capacity, 0)\n                        }\n                    }\n         \
    \           count += 1\n                }\n            }\n        }\n        count",
  "        val n = grid.length\n        val m = grid(0).length\n        val filled\
    \ = Array.fill(n)(0L)\n        var total = 0L\n        for (i <- 0 until n) {\n\
    \            var j = 0\n            while (j < m && grid(i)(j) == 0) j += 1\n\
    \            if (j < m) {\n                val fill = min(capacity, m - j)\n \
    \               filled(i) = fill\n                total += fill\n            }\n\
    \        }\n        var result = 0L\n        while (total > 0) {\n           \
    \ result += 1\n            total = 0\n            for (i <- 0 until n) {\n   \
    \             val fill = min(capacity, filled(i))\n                filled(i) -=\
    \ fill\n                total += fill\n            }\n        }\n        result",
  "        val n = grid.length\n        val m = grid(0).length\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            var sum = 0L\n           \
    \ for (j <- 0 until m) {\n                sum += grid(i)(j)\n                if\
    \ (sum > capacity) {\n                    result += sum - capacity\n         \
    \           sum = capacity\n                }\n            }\n        }\n    \
    \    result", "        val n = grid.length\n        val m = grid(0).length\n \
    \       val dp = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n   \
    \         for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n   \
    \                 dp(i)(j) = capacity\n                }\n            }\n    \
    \    }\n        var ans = 0L\n        while (true) {\n            var flag = false\n\
    \            for (i <- 0 until n) {\n                for (j <- 0 until m) {\n\
    \                    if (dp(i)(j) == 0) {\n                        if (i > 0 &&\
    \ dp(i - 1)(j) > 0) {\n                            dp(i)(j) = dp(i - 1)(j) - 1\n\
    \                            flag = true\n                        }\n        \
    \                if (j > 0 && dp(i)(j - 1) > 0) {\n                          \
    \  dp(i)(j) = dp(i)(j - 1) - 1\n                            flag = true\n    \
    \                    }\n                        if (i < n - 1 && dp(i + 1)(j)\
    \ > 0) {\n                            dp(i)(j) = dp(i + 1)(j) - 1\n          \
    \                  flag = true\n                        }\n                  \
    \      if (j < m - 1 && dp(i)(j + 1) > 0) {\n                            dp(i)(j)\
    \ = dp(i)(j + 1) - 1\n                            flag = true\n              \
    \          }\n                    }\n                }\n            }\n      \
    \      if (!flag) {\n                break\n            }\n            ans +=\
    \ 1\n        }\n        ans", "        val maxFill = grid.map(x => x.sum).max\n\
    \        if (maxFill <= capacity) return 1\n        val numRows = grid.length\n\
    \        val numCols = grid(0).length\n        val numBuckets = numRows * numCols\n\
    \        val buckets = Array.fill(numBuckets)(0L)\n        val bucketCapacity\
    \ = capacity / numBuckets\n        var numFills = 0L\n        var numEmpty = 0L\n\
    \        while (numEmpty < numBuckets) {\n            numFills += 1\n        \
    \    for (i <- 0 until numRows) {\n                for (j <- 0 until numCols)\
    \ {\n                    val bucket = i * numCols + j\n                    if\
    \ (buckets(bucket) < bucketCapacity) {\n                        val amount = min(bucketCapacity\
    \ - buckets(bucket), grid(i)(j))\n                        buckets(bucket) += amount\n\
    \                        grid(i)(j) -= amount\n                        if (grid(i)(j)\
    \ == 0) numEmpty += 1\n                    }\n                }\n            }\n\
    \        }\n        numFills", "        val rows = grid.length\n        val cols\
    \ = grid(0).length\n        val rowMax = grid.map(row => row.sum)\n        val\
    \ colMax = (0 until cols).map(i => grid.map(row => row(i)).sum)\n        val max\
    \ = rowMax.max\n        val maxCol = colMax.indexOf(colMax.max)\n        val maxRow\
    \ = rowMax.indexOf(max)\n        var count = 0L\n        var row = 0\n       \
    \ while (row < rows) {\n            var col = 0\n            while (col < cols)\
    \ {\n                if (grid(row)(col) == 1) {\n                    if (row ==\
    \ maxRow && col == maxCol) {\n                        count += 1\n           \
    \         } else {\n                        count += 2\n                    }\n\
    \                }\n                col += 1\n            }\n            row +=\
    \ 1\n        }\n        count", "        val n = grid.length\n        val m =\
    \ grid(0).length\n        val wells = grid.map(_.toArray).toArray\n        var\
    \ total = 0L\n        for (i <- 0 until n) {\n            var sum = 0L\n     \
    \       for (j <- 0 until m) {\n                sum += wells(i)(j)\n         \
    \       if (sum > capacity) {\n                    wells(i)(j) = wells(i)(j) -\
    \ (sum - capacity)\n                    total += sum - capacity\n            \
    \        sum = capacity\n                }\n            }\n        }\n       \
    \ for (j <- 0 until m) {\n            var sum = 0L\n            for (i <- 0 until\
    \ n) {\n                sum += wells(i)(j)\n                if (sum > capacity)\
    \ {\n                    wells(i)(j) = wells(i)(j) - (sum - capacity)\n      \
    \              total += sum - capacity\n                    sum = capacity\n \
    \               }\n            }\n        }\n        total", "        val n =\
    \ grid.length\n        val m = grid(0).length\n        val wells = grid.map(x\
    \ => x.sum).toArray\n        var max = wells.max\n        var min = wells.min\n\
    \        var result = 0L\n        while (max > min) {\n            val mid = (max\
    \ + min) / 2\n            var sum = 0L\n            for (i <- 0 until n) {\n \
    \               var count = 0L\n                for (j <- 0 until m) {\n     \
    \               if (grid(i)(j) > mid) {\n                        count += grid(i)(j)\
    \ - mid\n                    }\n                }\n                sum += count\
    \ / capacity\n                if (count % capacity != 0) sum += 1\n          \
    \  }\n            if (sum <= n) {\n                max = mid\n               \
    \ result = sum\n            } else {\n                min = mid + 1\n        \
    \    }\n        }\n        result", "        val rows = grid.length\n        val\
    \ cols = grid(0).length\n        val maxRow = grid.map(row => row.sum).max\n \
    \       val maxCol = (0 until cols).map(col => (0 until rows).map(row => grid(row)(col)).sum).max\n\
    \        val max = max(maxRow, maxCol)\n        val min = min(maxRow, maxCol)\n\
    \        if (max == min) max\n        else if (maxRow == max) maxRow + min\n \
    \       else if (maxCol == max) maxCol + min\n        else max", "        var\
    \ count = 0L\n        var max = 0L\n        for (i <- 0 until grid.length) {\n\
    \            max = 0L\n            for (j <- 0 until grid(i).length) {\n     \
    \           if (grid(i)(j) == 1) {\n                    max += 1\n           \
    \     }\n            }\n            if (max > capacity) {\n                count\
    \ += max - capacity\n            }\n        }\n        count", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val wells = grid.map(x\
    \ => x.sum).toArray\n        var total = wells.sum\n        var count = 0\n  \
    \      while (total > 0) {\n            var max = 0\n            for (i <- 0 until\
    \ n) {\n                if (wells(i) > wells(max)) max = i\n            }\n  \
    \          wells(max) -= min(wells(max), capacity)\n            total -= min(wells(max),\
    \ capacity)\n            count += 1\n        }\n        count", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val wells = grid.map(x\
    \ => x.sum).toArray\n        val buckets = new Array[Long](n)\n        var count\
    \ = 0L\n        while (true) {\n            var min = Long.MaxValue\n        \
    \    for (i <- 0 until n) {\n                if (wells(i) > 0) {\n           \
    \         min = min min wells(i)\n                }\n            }\n         \
    \   if (min == Long.MaxValue) return count\n            for (i <- 0 until n) {\n\
    \                if (wells(i) > 0) {\n                    wells(i) -= min\n  \
    \                  buckets(i) += min\n                }\n            }\n     \
    \       for (i <- 0 until n) {\n                if (buckets(i) > capacity) {\n\
    \                    val diff = buckets(i) - capacity\n                    buckets(i)\
    \ = capacity\n                    wells(i) += diff\n                }\n      \
    \      }\n            count += 1\n        }\n        count", "        val wells\
    \ = grid.map(_.sum)\n        val maxWell = wells.max\n        val maxWellIndex\
    \ = wells.indexOf(maxWell)\n        val maxWellFill = maxWell / capacity\n   \
    \     val maxWellFillRemainder = maxWell % capacity\n        val maxWellFillRemainderIndex\
    \ = wells.indexOf(maxWellFillRemainder)\n        val maxWellFillRemainderIndex2\
    \ = wells.indexOf(maxWellFillRemainder, maxWellFillRemainderIndex + 1)\n     \
    \   val maxWellFillRemainderIndex3 = wells.indexOf(maxWellFillRemainder, maxWellFillRemainderIndex2\
    \ + 1)\n        val maxWellFillRemainderIndex4 = wells.indexOf(maxWellFillRemainder,\
    \ maxWellFillRemainderIndex3 + 1)\n        val maxWellFillRemainderIndex5 = wells.indexOf(maxWellFillRemainder,\
    \ maxWellFillRemainderIndex4 + 1)\n        val maxWellFillRemainderIndex6 = wells.indexOf(maxWellFillRemainder,\
    \ maxWellFillRemainderIndex5 + 1)\n        val maxWellFillRemainderIndex7 = wells.indexOf(maxWellFillRemainder,\
    \ maxWellFillRemainderIndex6 + 1)\n        val maxWellFillRemainderIndex8 = wells.indexOf(maxWellFillRemainder,\
    \ maxWellFillRemainderIndex7 + 1)\n        val maxWellFillRemainderIndex9 = wells.indexOf(maxWellFillRemainder,\
    \ maxWellFillRemainderIndex8 + 1)\n        val maxWellFillRemainderIndex10 = wells.indexOf(maxWellFillRemainder,\
    \ maxWellFillRemainderIndex9 + 1)\n        val maxWellFillRemainderIndex11 = wells.indexOf(maxWellFillRemainder,\
    \ maxWellFillRemainderIndex10 + 1)\n        val maxWellFillRemainderIndex12 =\
    \ wells.indexOf(maxWellFillRemainder, maxWellFillRemainderIndex11 + 1)\n     \
    \   val maxWellFillRemainderIndex13 = wells.indexOf(maxWellFillRemainder, maxWellFillRemainderIndex12\
    \ + 1)\n        val maxWellFillRemainder", "        var result = 0L\n        for\
    \ (i <- 0 until grid.length) {\n            var sum = 0L\n            for (j <-\
    \ 0 until grid(i).length) {\n                sum += grid(i)(j)\n            }\n\
    \            result += ceil(sum.toDouble / capacity).toLong\n        }\n     \
    \   return result", "        val rows = grid.length\n        val cols = grid(0).length\n\
    \        val maxFill = Array.ofDim[Long](rows, cols)\n        for (i <- 0 until\
    \ rows) {\n            for (j <- 0 until cols) {\n                if (grid(i)(j)\
    \ == 1) {\n                    maxFill(i)(j) = capacity\n                }\n \
    \           }\n        }\n        for (i <- 0 until rows) {\n            for (j\
    \ <- 0 until cols) {\n                if (i > 0) {\n                    maxFill(i)(j)\
    \ = min(maxFill(i)(j), maxFill(i - 1)(j))\n                }\n               \
    \ if (j > 0) {\n                    maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j\
    \ - 1))\n                }\n            }\n        }\n        var result = 0L\n\
    \        for (i <- rows - 1 to 0 by -1) {\n            for (j <- cols - 1 to 0\
    \ by -1) {\n                if (grid(i)(j) == 1) {\n                    var fill\
    \ = maxFill(i)(j)\n                    if (i < rows - 1) {\n                 \
    \       fill = min(fill, maxFill(i + 1)(j))\n                    }\n         \
    \           if (j < cols - 1) {\n                        fill = min(fill, maxFill(i)(j\
    \ + 1))\n                    }\n                    maxFill(i)(j) = fill\n   \
    \                 result += fill\n                }\n            }\n        }\n\
    \        result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = capacity\n                }\n           \
    \ }\n        }\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (grid(i)(j) == 1) {\n                    if (i > 0)\
    \ {\n                        maxFill(i)(j) = min(maxFill(i)(j), maxFill(i - 1)(j)\
    \ + 1)\n                    }\n                    if (j > 0) {\n            \
    \            maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j - 1) + 1)\n     \
    \               }\n                }\n            }\n        }\n        for (i\
    \ <- n - 1 to 0 by -1) {\n            for (j <- m - 1 to 0 by -1) {\n        \
    \        if (grid(i)(j) == 1) {\n                    if (i < n - 1) {\n      \
    \                  maxFill(i)(j) = min(maxFill(i)(j), maxFill(i + 1)(j) + 1)\n\
    \                    }\n                    if (j < m - 1) {\n               \
    \         maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j + 1) + 1)\n        \
    \            }\n                }\n            }\n        }\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n \
    \               if (grid(i)(j) == 1) {\n                    result += maxFill(i)(j)\n\
    \                }\n            }\n        }\n        result", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val rowMax = grid.map(row\
    \ => row.sum)\n        val colMax = (0 until m).map(j => grid.map(row => row(j)).sum)\n\
    \        val rowMaxSum = rowMax.sum\n        val colMaxSum = colMax.sum\n    \
    \    val rowMaxMax = rowMax.max\n        val colMaxMax = colMax.max\n        val\
    \ rowMaxMin = rowMax.min\n        val colMaxMin = colMax.min\n        val rowMaxAvg\
    \ = rowMaxSum / n\n        val colMaxAvg = colMaxSum / m\n        val rowMaxMed\
    \ = rowMax.sorted.apply(n / 2)\n        val colMaxMed = colMax.sorted.apply(m\
    \ / 2)\n        val rowMaxMode = rowMax.groupBy(x => x).mapValues(_.size).maxBy(_._2)._1\n\
    \        val colMaxMode = colMax.groupBy(x => x).mapValues(_.size).maxBy(_._2)._1\n\
    \        val rowMaxVar = rowMax.map(x => pow(x - rowMaxAvg, 2)).sum / n\n    \
    \    val colMaxVar = colMax.map(x => pow(x - colMaxAvg, 2)).sum / m\n        val\
    \ rowMaxStd = sqrt(rowMaxVar)\n        val colMaxStd = sqrt(colMaxVar)\n     \
    \   val rowMaxSkew = rowMax.map(x => pow(x - rowMaxAvg, 3)).sum / n\n        val\
    \ colMaxSkew = colMax.map(x => pow(x - colMaxAvg, 3)).sum / m\n        val rowMaxKurt\
    \ = rowMax.map(x => pow(x - rowMaxAvg, 4)).sum / n\n        val colMaxKurt = colMax.map(x\
    \ => pow(x - colMaxAvg, 4)).sum / m\n        val rowMaxRange = rowMaxMax - rowMaxMin\n\
    \        val colMaxRange = colMaxMax - colMaxMin\n        val rowMaxMidRange =\
    \ (rowMaxMax + rowMaxMin) / 2\n        val colMaxMidRange = (colMaxMax + colMaxMin",
  "        val n = grid.length\n        val m = grid(0).length\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            var sum = 0L\n           \
    \ for (j <- 0 until m) {\n                sum += grid(i)(j)\n                if\
    \ (sum == capacity) {\n                    result += 1\n                    sum\
    \ = 0\n                } else if (sum > capacity) {\n                    result\
    \ += 1\n                    sum = grid(i)(j)\n                }\n            }\n\
    \            if (sum > 0) result += 1\n        }\n        result", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val maxFill = Array.ofDim[Long](n,\
    \ m)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n   \
    \             if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = capacity\n\
    \                }\n            }\n        }\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    if (i > 0) {\n                        maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i - 1)(j) + capacity)\n                    }\n                    if\
    \ (j > 0) {\n                        maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j\
    \ - 1) + capacity)\n                    }\n                }\n            }\n\
    \        }\n        var result = 0L\n        for (i <- 0 until n) {\n        \
    \    for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n        \
    \            result = max(result, maxFill(i)(j))\n                }\n        \
    \    }\n        }\n        result", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val wells = new Array[Long](n)\n        for (i <-\
    \ 0 until n) wells(i) = grid(i).sum\n        var ans = 0L\n        while (true)\
    \ {\n            var filled = 0L\n            for (i <- 0 until n) {\n       \
    \         if (wells(i) > 0) {\n                    filled += min(wells(i), capacity)\n\
    \                    wells(i) -= min(wells(i), capacity)\n                }\n\
    \            }\n            if (filled == 0) return ans\n            ans += 1\n\
    \        }\n        ans", "        val rows = grid.length\n        val cols =\
    \ grid(0).length\n        var max = 0L\n        for (i <- 0 until rows) {\n  \
    \          for (j <- 0 until cols) {\n                if (grid(i)(j) == 1) {\n\
    \                    max = max max (i + 1)\n                }\n            }\n\
    \        }\n        max", "        val n = grid.length\n        val m = grid(0).length\n\
    \        var result = 0L\n        for (i <- 0 until n) {\n            var sum\
    \ = 0L\n            for (j <- 0 until m) {\n                sum += grid(i)(j)\n\
    \                if (sum > capacity) {\n                    result += sum - capacity\n\
    \                    sum = capacity\n                }\n            }\n      \
    \  }\n        result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        var ans = 0L\n        for (i <- 0 until n) {\n            var sum = 0L\n\
    \            for (j <- 0 until m) {\n                sum += grid(i)(j)\n     \
    \           if (sum == capacity) {\n                    ans += 1\n           \
    \         sum = 0\n                } else if (sum > capacity) {\n            \
    \        ans += 1\n                    sum = grid(i)(j)\n                }\n \
    \           }\n            if (sum > 0) ans += 1\n        }\n        ans", " \
    \       val maxFill = grid.map(row => row.sum).max\n        val maxFillRows =\
    \ grid.filter(row => row.sum == maxFill)\n        val maxFillRow = maxFillRows.head\n\
    \        val maxFillRowLength = maxFillRow.length\n        val maxFillRowSum =\
    \ maxFillRow.sum\n        val maxFillRowSumDivCapacity = maxFillRowSum / capacity\n\
    \        val maxFillRowSumModCapacity = maxFillRowSum % capacity\n        val\
    \ maxFillRowSumDivCapacityPlusOne = maxFillRowSumDivCapacity + 1\n        val\
    \ maxFillRowSumModCapacityDivMaxFillRowLength = maxFillRowSumModCapacity / maxFillRowLength\n\
    \        val maxFillRowSumModCapacityModMaxFillRowLength = maxFillRowSumModCapacity\
    \ % maxFillRowLength\n        val maxFillRowSumModCapacityDivMaxFillRowLengthPlusOne\
    \ = maxFillRowSumModCapacityDivMaxFillRowLength + 1\n        val maxFillRowSumModCapacityModMaxFillRowLengthPlusOne\
    \ = maxFillRowSumModCapacityModMaxFillRowLength + 1\n        val maxFillRowSumModCapacityDivMaxFillRowLengthPlusOneDivCapacity\
    \ = maxFillRowSumModCapacityDivMaxFillRowLengthPlusOne / capacity\n        val\
    \ maxFillRowSumModCapacityDivMaxFillRowLengthPlusOneModCapacity = maxFillRowSumModCapacityDivMaxFillRowLengthPlusOne\
    \ % capacity\n        val maxFillRowSumModCapacityModMaxFillRowLengthPlusOneDivCapacity\
    \ = maxFillRowSumModCapacityModMaxFillRowLengthPlusOne / capacity\n        val\
    \ maxFillRowSumModCapacityModMaxFillRowLengthPlusOneModCapacity = maxFillRowSumModCapacityModMaxFillRowLengthPlusOne\
    \ % capacity\n        val maxFillRowSumModCapacityDivMaxFillRowLengthPlusOneDivCapacityPlusOne\
    \ = maxFillRowSumModCapacityDivMaxFillRowLengthPlusOneDivCapacity + 1\n      \
    \  val maxFillRowSumModCapacityModMaxFillRowLengthPlusOneDivCapacityPlusOne =\
    \ maxFillRowSumModCapacityModMaxFillRowLengthPlusOneDivCapacity + 1\n        val\
    \ maxFillRowSumModCapacityDivMaxFillRowLengthPlusOneModCapacityDivMaxFillRowLength\
    \ = max", "        val n = grid.length\n        val m = grid(0).length\n     \
    \   val maxFill = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n  \
    \          for (j <- 0 until m) {\n                maxFill(i)(j) = grid(i)(j)\n\
    \                if (i > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i - 1)(j))\n\
    \                if (j > 0) maxFill(i)(j) = max(maxFill(i)(j), maxFill(i)(j -\
    \ 1))\n            }\n        }\n        var result = 0L\n        for (i <- 0\
    \ until n) {\n            for (j <- 0 until m) {\n                val fill = maxFill(i)(j)\n\
    \                if (fill > 0) {\n                    result += fill\n       \
    \             var k = i\n                    while (k >= 0 && maxFill(k)(j) >\
    \ 0) {\n                        maxFill(k)(j) -= fill\n                      \
    \  k -= 1\n                    }\n                    k = j\n                \
    \    while (k >= 0 && maxFill(i)(k) > 0) {\n                        maxFill(i)(k)\
    \ -= fill\n                        k -= 1\n                    }\n           \
    \     }\n            }\n        }\n        result", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val fill = Array.ofDim[Long](n, m)\n\
    \        var count = 0L\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                if (grid(i)(j) == 1) {\n                    fill(i)(j)\
    \ = capacity\n                    count += 1\n                }\n            }\n\
    \        }\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                if (fill(i)(j) > 0) {\n                    if (i > 0 && fill(i\
    \ - 1)(j) > 0) {\n                        val diff = min(fill(i)(j), fill(i -\
    \ 1)(j))\n                        fill(i)(j) -= diff\n                       \
    \ fill(i - 1)(j) -= diff\n                        count += diff\n            \
    \        }\n                    if (j > 0 && fill(i)(j - 1) > 0) {\n         \
    \               val diff = min(fill(i)(j), fill(i)(j - 1))\n                 \
    \       fill(i)(j) -= diff\n                        fill(i)(j - 1) -= diff\n \
    \                       count += diff\n                    }\n               \
    \ }\n            }\n        }\n        count", "        val filled = Array.fill(grid.length)(0L)\n\
    \        var count = 0L\n        for (i <- 0 until grid.length) {\n          \
    \  val row = grid(i)\n            var sum = 0L\n            for (j <- 0 until\
    \ row.length) {\n                sum += row(j)\n                if (sum > capacity)\
    \ {\n                    count += 1\n                    filled(i) = sum - capacity\n\
    \                    sum = capacity\n                }\n            }\n      \
    \  }\n        for (i <- 0 until grid.length) {\n            val row = grid(i)\n\
    \            var sum = filled(i)\n            for (j <- 0 until row.length) {\n\
    \                sum += row(j)\n                if (sum > capacity) {\n      \
    \              count += 1\n                    sum = capacity\n              \
    \  }\n            }\n        }\n        count", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val maxFill = Array.ofDim[Long](n, m)\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0) maxFill(i)(j) = grid(i)(j)\n                else maxFill(i)(j)\
    \ = maxFill(i - 1)(j) + grid(i)(j)\n            }\n        }\n        var count\
    \ = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n \
    \               if (maxFill(i)(j) >= capacity) {\n                    count +=\
    \ maxFill(i)(j) / capacity\n                    maxFill(i)(j) = maxFill(i)(j)\
    \ % capacity\n                }\n            }\n        }\n        count", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until m) {\n                if (grid(i)(j) == 1) {\n                  \
    \  maxFill(i)(j) = capacity\n                }\n            }\n        }\n   \
    \     for (i <- 0 until n) {\n            for (j <- 0 until m) {\n           \
    \     if (grid(i)(j) == 1) {\n                    if (i > 0) {\n             \
    \           maxFill(i)(j) = min(maxFill(i)(j), maxFill(i - 1)(j) + capacity)\n\
    \                    }\n                    if (j > 0) {\n                   \
    \     maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j - 1) + capacity)\n     \
    \               }\n                }\n            }\n        }\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n \
    \               if (grid(i)(j) == 1) {\n                    result = max(result,\
    \ maxFill(i)(j))\n                }\n            }\n        }\n        result",
  "        val n = grid.length\n        val m = grid(0).length\n        val maxFill\
    \ = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until m) {\n                if (grid(i)(j) == 1) {\n                  \
    \  maxFill(i)(j) = capacity\n                }\n            }\n        }\n   \
    \     for (i <- 1 until n) {\n            for (j <- 0 until m) {\n           \
    \     if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i - 1)(j) + capacity)\n                }\n            }\n        }\n\
    \        for (i <- n - 2 to 0 by -1) {\n            for (j <- 0 until m) {\n \
    \               if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i + 1)(j) + capacity)\n                }\n            }\n        }\n\
    \        for (i <- 0 until n) {\n            for (j <- 1 until m) {\n        \
    \        if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i)(j - 1) + capacity)\n                }\n            }\n        }\n\
    \        for (i <- 0 until n) {\n            for (j <- m - 2 to 0 by -1) {\n \
    \               if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i)(j + 1) + capacity)\n                }\n            }\n        }\n\
    \        var result = 0L\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until m) {\n                if (grid(i)(j) == 1) {\n                    result\
    \ += capacity - maxFill(i)(j)\n                }\n            }\n        }\n \
    \       result", "        // The number of times you need to lower the buckets\
    \ is the number of times you need to fill the buckets.\n        // The number\
    \ of times you need to fill the buckets is the sum of the number of times you\
    \ need to fill each bucket.\n        // The number of times you need to fill each\
    \ bucket is the number of units of water in the bucket divided by the capacity\
    \ of the bucket.\n        // The number of units of water in the bucket is the\
    \ sum of the number of units of water in each well.\n        // The number of\
    \ units of water in each well is the number of 1s in the well.\n        grid.map(x\
    \ => x.sum).sum / capacity", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.ofDim[Long](n + 1, m + 1)\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                dp(i + 1)(j + 1) = dp(i)(j\
    \ + 1) + dp(i + 1)(j) - dp(i)(j) + grid(i)(j)\n            }\n        }\n    \
    \    var result = 0L\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                for (k <- i + 1 to n) {\n                    for\
    \ (l <- j + 1 to m) {\n                        val total = dp(k)(l) - dp(i)(l)\
    \ - dp(k)(j) + dp(i)(j)\n                        if (total <= capacity) result\
    \ = max(result, total)\n                    }\n                }\n           \
    \ }\n        }\n        result", "        def fill(grid : List[List[Long]], capacity\
    \ : Long, count : Long) : Long = {\n            if (grid.forall(row => row.forall(_\
    \ == 0))) return count\n            val max = grid.map(row => row.sum).max\n \
    \           if (max <= capacity) return count + max\n            val filled =\
    \ grid.map(row => row.map(cell => min(cell, capacity)))\n            val remaining\
    \ = grid.zip(filled).map(pair => pair._1.zip(pair._2).map(pair => pair._1 - pair._2))\n\
    \            fill(remaining, capacity, count + capacity)\n        }\n        fill(grid,\
    \ capacity, 0)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        var result = 0L\n        for (i <- 0 until n) {\n            var sum\
    \ = 0L\n            for (j <- 0 until m) {\n                sum += grid(i)(j)\n\
    \                if (sum == capacity) {\n                    result += 1\n   \
    \                 sum = 0\n                } else if (sum > capacity) {\n    \
    \                result += 1\n                    sum = grid(i)(j)\n         \
    \       }\n            }\n            if (sum > 0) result += 1\n        }\n  \
    \      result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    maxFill(i)(j) = capacity\n                }\n           \
    \ }\n        }\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i > 0) {\n                    maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i - 1)(j))\n                }\n                if (j > 0) {\n      \
    \              maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j - 1))\n       \
    \         }\n            }\n        }\n        for (i <- n - 1 to 0 by -1) {\n\
    \            for (j <- m - 1 to 0 by -1) {\n                if (i < n - 1) {\n\
    \                    maxFill(i)(j) = min(maxFill(i)(j), maxFill(i + 1)(j))\n \
    \               }\n                if (j < m - 1) {\n                    maxFill(i)(j)\
    \ = min(maxFill(i)(j), maxFill(i)(j + 1))\n                }\n            }\n\
    \        }\n        var ans = 0L\n        for (i <- 0 until n) {\n           \
    \ for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n           \
    \         ans += capacity - maxFill(i)(j)\n                }\n            }\n\
    \        }\n        ans", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val buckets = new Array[Long](m)\n        var count = 0L\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (grid(i)(j)\
    \ == 1) {\n                    if (buckets(j) < capacity) {\n                \
    \        buckets(j) += 1\n                        count += 1\n               \
    \     }\n                }\n            }\n        }\n        return count", " \
    \       var result = 0L\n        for (i <- 0 until grid.length) {\n          \
    \  var sum = 0L\n            for (j <- 0 until grid(i).length) {\n           \
    \     sum += grid(i)(j)\n            }\n            if (sum > capacity) {\n  \
    \              result += sum - capacity\n            }\n        }\n        return\
    \ result", "        val n = grid.length\n        val m = grid(0).length\n    \
    \    val dp = Array.ofDim[Long](n + 1, m + 1)\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                dp(i + 1)(j + 1) = dp(i)(j\
    \ + 1) + dp(i + 1)(j) - dp(i)(j) + grid(i)(j)\n            }\n        }\n    \
    \    var result = 0L\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                for (k <- i + 1 to n) {\n                    for\
    \ (l <- j + 1 to m) {\n                        val sum = dp(k)(l) - dp(i)(l) -\
    \ dp(k)(j) + dp(i)(j)\n                        if (sum <= capacity) result = max(result,\
    \ sum)\n                    }\n                }\n            }\n        }\n \
    \       result", "        val maxFill = grid.map(x => x.sum).max\n        if (maxFill\
    \ <= capacity) return 1\n        val numRows = grid.length\n        val numCols\
    \ = grid(0).length\n        val numBuckets = min(numRows, numCols)\n        val\
    \ buckets = Array.fill(numBuckets)(capacity)\n        var numTimes = 0\n     \
    \   while (buckets.exists(_ > 0)) {\n            numTimes += 1\n            for\
    \ (i <- 0 until numRows) {\n                for (j <- 0 until numCols) {\n   \
    \                 if (buckets(i) > 0 && grid(i)(j) > 0) {\n                  \
    \      val amount = min(buckets(i), grid(i)(j))\n                        buckets(i)\
    \ -= amount\n                        grid(i)(j) -= amount\n                  \
    \  }\n                }\n            }\n        }\n        numTimes", "      \
    \  val n = grid.length\n        val m = grid(0).length\n        var max = 0L\n\
    \        for (i <- 0 until n) {\n            var sum = 0L\n            for (j\
    \ <- 0 until m) {\n                sum += grid(i)(j)\n                if (sum\
    \ > capacity) {\n                    max += sum - capacity\n                 \
    \   sum = capacity\n                }\n            }\n        }\n        max",
  "        val n = grid.length\n        val m = grid(0).length\n        var result\
    \ = 0L\n        for (i <- 0 until n) {\n            var sum = 0L\n           \
    \ for (j <- 0 until m) {\n                sum += grid(i)(j)\n                if\
    \ (sum > capacity) {\n                    result += sum - capacity\n         \
    \           sum = capacity\n                }\n            }\n        }\n    \
    \    result", "        // Fill each well to capacity.\n        // If the well\
    \ is already at capacity, then skip it.\n        // If the well is not at capacity,\
    \ then fill it.\n        // If the well is over capacity, then fill it to capacity.\n\
    \        // If the well is not at capacity, then fill it.\n        // If the well\
    \ is over capacity, then fill it to capacity.\n        // If the well is not at\
    \ capacity, then fill it.\n        // If the well is over capacity, then fill\
    \ it to capacity.\n        // If the well is not at capacity, then fill it.\n\
    \        // If the well is over capacity, then fill it to capacity.\n        //\
    \ If the well is not at capacity, then fill it.\n        // If the well is over\
    \ capacity, then fill it to capacity.\n        // If the well is not at capacity,\
    \ then fill it.\n        // If the well is over capacity, then fill it to capacity.\n\
    \        // If the well is not at capacity, then fill it.\n        // If the well\
    \ is over capacity, then fill it to capacity.\n        // If the well is not at\
    \ capacity, then fill it.\n        // If the well is over capacity, then fill\
    \ it to capacity.\n        // If the well is not at capacity, then fill it.\n\
    \        // If the well is over capacity, then fill it to capacity.\n        //\
    \ If the well is not at capacity, then fill it.\n        // If the well is over\
    \ capacity, then fill it to capacity.\n        // If the well is not at capacity,\
    \ then fill it.\n        // If the well is over capacity, then fill it to capacity.\n\
    \        // If the well is not at capacity, then fill it.\n        // If the well\
    \ is over capacity, then fill it to capacity.\n        // If the well is not at\
    \ capacity, then fill it.\n        // If the well is over capacity, then fill\
    \ it to capacity.\n        // If the well is not at capacity, then fill it.\n\
    \        // If the well is over capacity, then fill it to capacity.\n        //\
    \ If the well is not at capacity, then fill it.\n        // If the well is over\
    \ capacity, then fill it to capacity.\n        // If the well is not at capacity,\
    \ then fill it.\n        // If the well is over", "        val maxFill = grid.map(row\
    \ => row.max).max\n        val maxFillCount = grid.map(row => row.count(_ == maxFill)).max\n\
    \        val minFill = grid.map(row => row.min).min\n        val minFillCount\
    \ = grid.map(row => row.count(_ == minFill)).max\n        val fillCount = grid.map(row\
    \ => row.count(_ == maxFill)).sum\n        val fillCount2 = grid.map(row => row.count(_\
    \ == minFill)).sum\n        val fillCount3 = grid.map(row => row.count(_ == maxFill\
    \ - 1)).sum\n        val fillCount4 = grid.map(row => row.count(_ == minFill +\
    \ 1)).sum\n        val fillCount5 = grid.map(row => row.count(_ == maxFill - 2)).sum\n\
    \        val fillCount6 = grid.map(row => row.count(_ == minFill + 2)).sum\n \
    \       val fillCount7 = grid.map(row => row.count(_ == maxFill - 3)).sum\n  \
    \      val fillCount8 = grid.map(row => row.count(_ == minFill + 3)).sum\n   \
    \     val fillCount9 = grid.map(row => row.count(_ == maxFill - 4)).sum\n    \
    \    val fillCount10 = grid.map(row => row.count(_ == minFill + 4)).sum\n    \
    \    val fillCount11 = grid.map(row => row.count(_ == maxFill - 5)).sum\n    \
    \    val fillCount12 = grid.map(row => row.count(_ == minFill + 5)).sum\n    \
    \    val fillCount13 = grid.map(row => row.count(_ == maxFill - 6)).sum\n    \
    \    val fillCount14 = grid.map(row => row.count(_ == minFill + 6)).sum\n    \
    \    val fillCount15 = grid.map(row => row.count(_ == maxFill - 7)).sum\n    \
    \    val fillCount16 = grid.map(row => row.count(_ == minFill + 7)).sum\n    \
    \    val fillCount17 = grid.map(row => row.count(_ == maxFill - 8)).sum\n    \
    \    val fillCount18 = grid.map(row => row.count(_ == minFill + 8)).sum\n    \
    \    val fillCount19 =", "        val rows = grid.length\n        val cols = grid(0).length\n\
    \        val maxFill = Array.ofDim[Long](rows, cols)\n        for (i <- 0 until\
    \ rows) {\n            for (j <- 0 until cols) {\n                if (grid(i)(j)\
    \ == 1) {\n                    val maxFillAbove = if (i == 0) 0 else maxFill(i\
    \ - 1)(j)\n                    val maxFillLeft = if (j == 0) 0 else maxFill(i)(j\
    \ - 1)\n                    maxFill(i)(j) = max(maxFillAbove, maxFillLeft) + 1\n\
    \                }\n            }\n        }\n        var result = 0L\n      \
    \  for (i <- 0 until rows) {\n            for (j <- 0 until cols) {\n        \
    \        if (grid(i)(j) == 1) {\n                    val maxFillAbove = if (i\
    \ == 0) 0 else maxFill(i - 1)(j)\n                    val maxFillLeft = if (j\
    \ == 0) 0 else maxFill(i)(j - 1)\n                    val maxFill = max(maxFillAbove,\
    \ maxFillLeft) + 1\n                    result += maxFill / capacity\n       \
    \             if (maxFill % capacity != 0) result += 1\n                }\n  \
    \          }\n        }\n        result", "        val n = grid.length\n     \
    \   val m = grid(0).length\n        val maxFill = Array.ofDim[Long](n, m)\n  \
    \      for (i <- 0 until n) {\n            for (j <- 0 until m) {\n          \
    \      if (grid(i)(j) == 1) {\n                    maxFill(i)(j) = capacity\n\
    \                }\n            }\n        }\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (i > 0) {\n          \
    \          maxFill(i)(j) = min(maxFill(i)(j), maxFill(i - 1)(j))\n           \
    \     }\n                if (j > 0) {\n                    maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i)(j - 1))\n                }\n            }\n        }\n        var\
    \ result = 0L\n        for (i <- n - 1 to 0 by -1) {\n            for (j <- m\
    \ - 1 to 0 by -1) {\n                if (grid(i)(j) == 1) {\n                \
    \    if (i < n - 1) {\n                        maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i + 1)(j))\n                    }\n                    if (j < m - 1)\
    \ {\n                        maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j +\
    \ 1))\n                    }\n                    result += maxFill(i)(j)\n  \
    \              }\n            }\n        }\n        result", "        // grid.map(row\
    \ => row.map(x => if (x == 1) capacity else 0))\n        // grid.map(row => row.map(x\
    \ => if (x == 1) capacity else 0))\n        // grid.map(row => row.map(x => if\
    \ (x == 1) capacity else 0))\n        // grid.map(row => row.map(x => if (x ==\
    \ 1) capacity else 0))\n        // grid.map(row => row.map(x => if (x == 1) capacity\
    \ else 0))\n        // grid.map(row => row.map(x => if (x == 1) capacity else\
    \ 0))\n        // grid.map(row => row.map(x => if (x == 1) capacity else 0))\n\
    \        // grid.map(row => row.map(x => if (x == 1) capacity else 0))\n     \
    \   // grid.map(row => row.map(x => if (x == 1) capacity else 0))\n        //\
    \ grid.map(row => row.map(x => if (x == 1) capacity else 0))\n        // grid.map(row\
    \ => row.map(x => if (x == 1) capacity else 0))\n        // grid.map(row => row.map(x\
    \ => if (x == 1) capacity else 0))\n        // grid.map(row => row.map(x => if\
    \ (x == 1) capacity else 0))\n        // grid.map(row => row.map(x => if (x ==\
    \ 1) capacity else 0))\n        // grid.map(row => row.map(x => if (x == 1) capacity\
    \ else 0))\n        // grid.map(row => row.map(x => if (x == 1) capacity else\
    \ 0))\n        // grid.map(row => row.map(x => if (x == 1) capacity else 0))\n\
    \        // grid.map(row => row.map(x => if (x == 1) capacity else 0))\n     \
    \   // grid.map(row => row.map(x => if (x == 1) capacity else 0))\n        //\
    \ grid.map(row => row.map(x => if (x == 1) capacity else 0))\n        // grid.map(row\
    \ => row.map", "        val height = grid.length\n        val width = grid(0).length\n\
    \        val maxFill = Array.fill(height, width)(0L)\n        for (i <- 0 until\
    \ height) {\n            for (j <- 0 until width) {\n                if (grid(i)(j)\
    \ == 1) {\n                    maxFill(i)(j) = capacity\n                }\n \
    \           }\n        }\n        for (i <- 0 until height) {\n            for\
    \ (j <- 0 until width) {\n                if (grid(i)(j) == 1) {\n           \
    \         if (i > 0) {\n                        maxFill(i)(j) = min(maxFill(i)(j),\
    \ maxFill(i - 1)(j) + capacity)\n                    }\n                    if\
    \ (j > 0) {\n                        maxFill(i)(j) = min(maxFill(i)(j), maxFill(i)(j\
    \ - 1) + capacity)\n                    }\n                }\n            }\n\
    \        }\n        maxFill(height - 1)(width - 1)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m)\n  \
    \      for (i <- 0 until n) {\n            for (j <- 0 until m) {\n          \
    \      if (i == 0) {\n                    dp(i)(j) = grid(i)(j)\n            \
    \    } else {\n                    dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n    \
    \            }\n            }\n        }\n        var result = 0L\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (dp(i)(j)\
    \ > capacity) {\n                    result += dp(i)(j) - capacity\n         \
    \           dp(i)(j) = capacity\n                }\n            }\n        }\n\
    \        result", "        var maxFill = 0L\n        for (row <- grid) {\n   \
    \         var fill = 0L\n            for (well <- row) {\n                if (well\
    \ == 1) fill += 1\n                else {\n                    maxFill = max(maxFill,\
    \ fill)\n                    fill = 0\n                }\n            }\n    \
    \        maxFill = max(maxFill, fill)\n        }\n        maxFill", "        val\
    \ maxFill = grid.map(row => row.sum).max\n        maxFill / capacity + (if (maxFill\
    \ % capacity == 0) 0 else 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        var result = 0L\n        for (i <- 0 until n) {\n            var sum\
    \ = 0L\n            for (j <- 0 until m) {\n                sum += grid(i)(j)\n\
    \                if (sum == capacity) {\n                    result += 1\n   \
    \                 sum = 0\n                } else if (sum > capacity) {\n    \
    \                result += 1\n                    sum = grid(i)(j)\n         \
    \       }\n            }\n            if (sum > 0) result += 1\n        }\n  \
    \      result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val maxFill = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n\
    \                    if (i == 0) maxFill(i)(j) = capacity\n                  \
    \  else maxFill(i)(j) = maxFill(i - 1)(j) + capacity\n                }\n    \
    \            else {\n                    if (i == 0) maxFill(i)(j) = 0\n     \
    \               else maxFill(i)(j) = maxFill(i - 1)(j)\n                }\n  \
    \          }\n        }\n        val min = maxFill.map(x => x.min).min\n     \
    \   maxFill.map(x => x.map(y => y - min).sum).sum", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m)\n  \
    \      for (i <- 0 until n) {\n            for (j <- 0 until m) {\n          \
    \      dp(i)(j) = grid(i)(j)\n                if (i > 0) dp(i)(j) = max(dp(i)(j),\
    \ dp(i - 1)(j))\n                if (j > 0) dp(i)(j) = max(dp(i)(j), dp(i)(j -\
    \ 1))\n            }\n        }\n        var result = 0L\n        for (i <- 0\
    \ until n) {\n            for (j <- 0 until m) {\n                val fill = capacity\
    \ - dp(i)(j)\n                if (fill > 0) {\n                    result += fill\n\
    \                    dp(i)(j) += fill\n                    if (i > 0) dp(i - 1)(j)\
    \ = max(dp(i - 1)(j), dp(i)(j))\n                    if (j > 0) dp(i)(j - 1) =\
    \ max(dp(i)(j - 1), dp(i)(j))\n                }\n            }\n        }\n \
    \       result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.ofDim[Long](n, m)\n        for (i <- 0 until n) {\n  \
    \          for (j <- 0 until m) {\n                dp(i)(j) = grid(i)(j)\n   \
    \             if (i > 0) dp(i)(j) = max(dp(i)(j), dp(i - 1)(j))\n            \
    \    if (j > 0) dp(i)(j) = max(dp(i)(j), dp(i)(j - 1))\n            }\n      \
    \  }\n        var ans = 0L\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until m) {\n                val fill = capacity - dp(i)(j)\n          \
    \      if (fill > 0) {\n                    ans += fill\n                    dp(i)(j)\
    \ += fill\n                    if (i > 0) dp(i - 1)(j) = max(dp(i - 1)(j), dp(i)(j))\n\
    \                    if (j > 0) dp(i)(j - 1) = max(dp(i)(j - 1), dp(i)(j))\n \
    \               }\n            }\n        }\n        ans", "        var fill =\
    \ 0L\n        for (i <- 0 until grid.length) {\n            var row = grid(i)\n\
    \            var count = 0L\n            for (j <- 0 until row.length) {\n   \
    \             if (row(j) == 1) count += 1\n            }\n            fill +=\
    \ ceil(count / capacity).toLong\n        }\n        fill", "        val maxFill\
    \ = grid.map(row => row.sum).max\n        val numBuckets = maxFill / capacity\n\
    \        val remainder = maxFill % capacity\n        if (remainder == 0) numBuckets\
    \ else numBuckets + 1", "        var count = 0\n        var max = 0\n        for\
    \ (i <- 0 until grid.length) {\n            var sum = 0\n            for (j <-\
    \ 0 until grid(i).length) {\n                sum += grid(i)(j)\n            }\n\
    \            if (sum > max) max = sum\n        }\n        for (i <- 0 until grid.length)\
    \ {\n            var sum = 0\n            for (j <- 0 until grid(i).length) {\n\
    \                sum += grid(i)(j)\n            }\n            if (sum < max)\
    \ {\n                count += (max - sum)\n            }\n        }\n        count",
  "        val n = grid.length\n        val m = grid(0).length\n        var count\
    \ = 0\n        for (i <- 0 until n) {\n            var sum = 0\n            for\
    \ (j <- 0 until m) {\n                sum += grid(i)(j)\n                if (sum\
    \ > capacity) {\n                    count += sum / capacity\n               \
    \     sum %= capacity\n                }\n            }\n            count +=\
    \ sum / capacity\n        }\n        count", "        val maxFill = grid.map(row\
    \ => row.sum).max\n        if (maxFill <= capacity) 1\n        else {\n      \
    \      val numBuckets = maxFill / capacity\n            if (maxFill % capacity\
    \ == 0) numBuckets\n            else numBuckets + 1\n        }", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val maxFill = Array.ofDim[Long](n,\
    \ m)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n   \
    \             maxFill(i)(j) = grid(i)(j)\n                if (i > 0) maxFill(i)(j)\
    \ = max(maxFill(i)(j), maxFill(i - 1)(j))\n                if (j > 0) maxFill(i)(j)\
    \ = max(maxFill(i)(j), maxFill(i)(j - 1))\n            }\n        }\n        var\
    \ result = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until m)\
    \ {\n                val fill = maxFill(i)(j)\n                if (fill > 0) {\n\
    \                    result += 1\n                    var x = i\n            \
    \        var y = j\n                    while (x >= 0 && y >= 0) {\n         \
    \               val fill = maxFill(x)(y)\n                        if (fill > 0)\
    \ {\n                            maxFill(x)(y) -= capacity\n                 \
    \           if (maxFill(x)(y) < 0) maxFill(x)(y) = 0\n                       \
    \ }\n                        x -= 1\n                        y -= 1\n        \
    \            }\n                }\n            }\n        }\n        result"]
stop_tokens:
- "\n    }\n"
