name: HumanEval_6_parse_nested_parens
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n    // For each of the group, output the deepest\
  \ level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of\
  \ nesting while ((())) has three.\n    def parseNestedParens(paren_string : String)\
  \ : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
  (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
  \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
  )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
completions: ["        val parens = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (paren <- parens) {\n            var max_level =\
    \ 0\n            var level = 0\n            for (c <- paren) {\n             \
    \   if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result =\
    \ result :+ max_level\n        }\n        return result", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n \
    \       for (group <- paren_groups) {\n            var max_depth = 0\n       \
    \     var depth = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') depth += 1\n                else if (c == ')') depth -= 1\n           \
    \     if (depth > max_depth) max_depth = depth\n            }\n            result\
    \ += max_depth\n        }\n        result.toList", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n   \
    \     for (group <- paren_groups) {\n            var max_depth = 0\n         \
    \   var depth = 0\n            for (ch <- group) {\n                if (ch ==\
    \ '(') depth += 1\n                else if (ch == ')') depth -= 1\n          \
    \      max_depth = max(max_depth, depth)\n            }\n            result +=\
    \ max_depth\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.toCharArray.map(y =>\
    \ if (y == '(') 1 else -1).scanLeft(0)(_ + _).max)\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                if (depth > max_depth) max_depth = depth\n            }\n   \
    \         result += max_depth\n        }\n        result.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') depth += 1\n                else depth -= 1\n                max_depth\
    \ = max(max_depth, depth)\n            }\n            result += max_depth\n  \
    \      }\n        result.toList", "        val groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') {\n                    level += 1\n   \
    \                 max_level = max(max_level, level)\n                } else if\
    \ (paren == ')') {\n                    level -= 1\n                }\n      \
    \      }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var depth\
    \ = 0\n            var max_depth = 0\n            for (c <- group) {\n       \
    \         if (c == '(') depth += 1\n                else if (c == ')') depth -=\
    \ 1\n                max_depth = max(max_depth, depth)\n            }\n      \
    \      result += max_depth\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x =>\
    \ x.count(y => y == '(') - x.count(y => y == ')'))\n        val max_level = paren_levels.max\n\
    \        val min_level = paren_levels.min\n        val result = new ListBuffer[Long]\n\
    \        for (i <- min_level to max_level) {\n            result += paren_levels.count(x\
    \ => x == i)\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nestings = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var max_nesting = 0\n            var current_nesting\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               current_nesting += 1\n                    max_nesting = max(max_nesting,\
    \ current_nesting)\n                } else if (c == ')') {\n                 \
    \   current_nesting -= 1\n                }\n            }\n            max_nestings\
    \ += max_nesting\n        }\n        max_nestings.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (i <- 0 until group.length) {\n        \
    \        if (group(i) == '(') {\n                    level += 1\n            \
    \        max_level = max(max_level, level)\n                } else if (group(i)\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        var max_nesting =\
    \ 0\n        var current_nesting = 0\n        var result = List[Long]()\n    \
    \    for (group <- paren_groups) {\n            for (c <- group) {\n         \
    \       if (c == '(') {\n                    current_nesting += 1\n          \
    \          max_nesting = max(max_nesting, current_nesting)\n                }\
    \ else if (c == ')') {\n                    current_nesting -= 1\n           \
    \     }\n            }\n            result = max_nesting :: result\n         \
    \   max_nesting = 0\n            current_nesting = 0\n        }\n        result.reverse",
  "        var max_depth = 0\n        var depth = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                depth += 1\n               \
    \ max_depth = max(max_depth, depth)\n            } else if (c == ')') {\n    \
    \            depth -= 1\n            }\n        }\n        List(max_depth)", " \
    \       val paren_groups = paren_string.split(\" \")\n        paren_groups.map(x\
    \ => parseNestedParensHelper(x, 0, 0)).toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        paren_groups.map(x => parseNestedParens(x, 0, 0)).toList", "  \
    \      val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val parens = paren_string.split(\" \")\n        val depths = new ListBuffer[Long]\n\
    \        for (p <- parens) {\n            var depth = 0\n            var max_depth\
    \ = 0\n            for (c <- p) {\n                if (c == '(') depth += 1\n\
    \                else if (c == ')') depth -= 1\n                if (depth > max_depth)\
    \ max_depth = depth\n            }\n            depths += max_depth\n        }\n\
    \        depths.toList", "        val paren_groups = paren_string.split(\" \"\
    )\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    depth +=\
    \ 1\n                    max_depth = max(max_depth, depth)\n                }\
    \ else if (c == ')') {\n                    depth -= 1\n                }\n  \
    \          }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result +=\
    \ max_level\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var depth = 0\n            var max_depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n\
    \        for (group <- groups) {\n            var max_depth = 0\n            var\
    \ depth = 0\n            for (c <- group) {\n                if (c == '(') depth\
    \ += 1\n                else if (c == ')') depth -= 1\n                max_depth\
    \ = max(max_depth, depth)\n            }\n            result += max_depth\n  \
    \      }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var current_level = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_level += 1\n                    max_level = max(max_level, current_level)\n\
    \                } else if (c == ')') {\n                    current_level -=\
    \ 1\n                }\n            }\n            result = result :+ max_level\n\
    \        }\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var current_depth = 0\n            for (c <- group) {\n   \
    \             if (c == '(') {\n                    current_depth += 1\n      \
    \              max_depth = max(max_depth, current_depth)\n                } else\
    \ if (c == ')') {\n                    current_depth -= 1\n                }\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_levels =\
    \ new ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_level = 0\n            var current_level = 0\n            for (paren <-\
    \ group) {\n                if (paren == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (paren == ')') {\n                    current_level -= 1\n\
    \                }\n            }\n            max_levels += max_level\n     \
    \   }\n        max_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_depth += 1\n                    max_depth = max(max_depth, current_depth)\n\
    \                } else if (c == ')') {\n                    current_depth -=\
    \ 1\n                }\n            }\n            result += max_depth\n     \
    \   }\n        result.toList", "        val groups = paren_string.split(\" \"\
    )\n        val result = new ListBuffer[Long]\n        for (group <- groups) {\n\
    \            var max_depth = 0\n            var depth = 0\n            for (c\
    \ <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        paren_groups.map(x\
    \ => parseNestedParens(x, 0, 0)).toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting_level = 0\n            var current_nesting_level = 0\n    \
    \        for (paren <- group) {\n                if (paren == '(') {\n       \
    \             current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(group => {\n            var\
    \ level = 0\n            var max_level = 0\n            for (paren <- group) {\n\
    \                if (paren == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (paren\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            max_level\n        })\n        paren_levels.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var current_depth = 0\n            for (c <- group) {\n               \
    \ if (c == '(') {\n                    current_depth += 1\n                  \
    \  max_depth = max(max_depth, current_depth)\n                } else if (c ==\
    \ ')') {\n                    current_depth -= 1\n                }\n        \
    \    }\n            result += max_depth\n        }\n        result.toList", " \
    \       val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') level += 1\n                else if (c == ')')\
    \ level -= 1\n                if (level > max_level) max_level = level\n     \
    \       }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(parseParens(_))\n        paren_levels.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val max_levels = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            max_levels += max_level\n \
    \       }\n        max_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_depth += 1\n                    max_depth = max(max_depth, current_depth)\n\
    \                } else if (c == ')') {\n                    current_depth -=\
    \ 1\n                }\n            }\n            result += max_depth\n     \
    \   }\n        result.toList", "        var max_depth = 0\n        var depth =\
    \ 0\n        var result = List[Long]()\n        for (c <- paren_string) {\n  \
    \          if (c == '(') {\n                depth += 1\n                max_depth\
    \ = max(max_depth, depth)\n            } else if (c == ')') {\n              \
    \  depth -= 1\n            } else if (c == ' ') {\n                result = max_depth\
    \ :: result\n                max_depth = 0\n                depth = 0\n      \
    \      }\n        }\n        result = max_depth :: result\n        result.reverse",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (paren <- paren_group)\
    \ {\n                if (paren == '(') depth += 1\n                else if (paren\
    \ == ')') depth -= 1\n                if (depth > max_depth) max_depth = depth\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_nesting\
    \ = 0\n            var current_nesting = 0\n            for (c <- group) {\n \
    \               if (c == '(') current_nesting += 1\n                else if (c\
    \ == ')') current_nesting -= 1\n                if (current_nesting > max_nesting)\
    \ max_nesting = current_nesting\n            }\n            result += max_nesting\n\
    \        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ depth -= 1\n                max_depth = max(max_depth, depth)\n            }\n\
    \            result += max_depth\n        }\n        result.toList", "       \
    \ val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = paren_groups.map(group => {\n            var max_level = 0\n            var\
    \ current_level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    current_level += 1\n                    max_level\
    \ = max(max_level, current_level)\n                } else if (c == ')') {\n  \
    \                  current_level -= 1\n                }\n            }\n    \
    \        max_level\n        })\n        max_nesting_levels.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(group\
    \ => {\n            var level = 0\n            var max_level = 0\n           \
    \ for (c <- group) {\n                if (c == '(') {\n                    level\
    \ += 1\n                    max_level = max(max_level, level)\n              \
    \  } else if (c == ')') {\n                    level -= 1\n                }\n\
    \            }\n            max_level\n        })\n        paren_levels.toList",
  "        var result = List[Long]()\n        for (group <- paren_string.split(\"\
    \ \")) {\n            var depth = 0\n            var max_depth = 0\n         \
    \   for (paren <- group) {\n                if (paren == '(') depth += 1\n   \
    \             else if (paren == ')') depth -= 1\n                max_depth = max(max_depth,\
    \ depth)\n            }\n            result = result :+ max_depth\n        }\n\
    \        return result", "        val paren_groups = paren_string.split(\" \"\
    )\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (paren <- group) {\n                if (paren == '(') {\n         \
    \           current_depth += 1\n                    max_depth = max(max_depth,\
    \ current_depth)\n                } else if (paren == ')') {\n               \
    \     current_depth -= 1\n                }\n            }\n            result\
    \ += max_depth\n        }\n        result.toList", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n   \
    \     for (group <- paren_groups) {\n            var max_level = 0\n         \
    \   var current_level = 0\n            for (paren <- group) {\n              \
    \  if (paren == '(') current_level += 1\n                else if (paren == ')')\
    \ current_level -= 1\n                if (current_level > max_level) max_level\
    \ = current_level\n            }\n            result += max_level\n        }\n\
    \        result.toList", "        val paren_groups = paren_string.split(\" \"\
    )\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_depth += 1\n                    max_depth = max(max_depth, current_depth)\n\
    \                } else if (c == ')') {\n                    current_depth -=\
    \ 1\n                }\n            }\n            result += max_depth\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var depth = 0\n            var max_depth = 0\n            for\
    \ (i <- 0 until group.length) {\n                if (group(i) == '(') depth +=\
    \ 1\n                else if (group(i) == ')') depth -= 1\n                max_depth\
    \ = max(max_depth, depth)\n            }\n            result += max_depth\n  \
    \      }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') level += 1\n                else\
    \ if (c == ')') level -= 1\n                if (level > max_level) max_level =\
    \ level\n            }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') level += 1\n                else if (paren\
    \ == ')') level -= 1\n                if (level > max_level) max_level = level\n\
    \            }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  result += max_depth\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n \
    \       for (group <- paren_groups) {\n            var max_depth = 0\n       \
    \     var current_depth = 0\n            for (c <- group) {\n                if\
    \ (c == '(') {\n                    current_depth += 1\n                    max_depth\
    \ = max(max_depth, current_depth)\n                } else if (c == ')') {\n  \
    \                  current_depth -= 1\n                }\n            }\n    \
    \        result += max_depth\n        }\n        result.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val paren_levels = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val parens = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (p <- parens)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- p) {\n                if (c == '(') depth += 1\n                else depth\
    \ -= 1\n                max_depth = max(max_depth, depth)\n            }\n   \
    \         result += max_depth\n        }\n        result.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') depth += 1\n                else if (c == ')') depth -= 1\n           \
    \     if (depth > max_depth) max_depth = depth\n            }\n            result\
    \ += max_depth\n        }\n        result.toList", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n   \
    \     for (group <- paren_groups) {\n            var max_level = 0\n         \
    \   var level = 0\n            for (c <- group) {\n                if (c == '(')\
    \ {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        var result = List[Long]()\n        var\
    \ max_depth = 0\n        var current_depth = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                current_depth += 1\n       \
    \         max_depth = max(max_depth, current_depth)\n            } else if (c\
    \ == ')') {\n                current_depth -= 1\n            } else if (c == '\
    \ ') {\n                result = result :+ max_depth\n                max_depth\
    \ = 0\n                current_depth = 0\n            }\n        }\n        result\
    \ = result :+ max_depth\n        return result", "        // Split the string\
    \ into groups separated by spaces.\n        val groups = paren_string.split(\"\
    \ \")\n        // For each group, find the deepest level of nesting.\n       \
    \ val max_nesting_levels = groups.map(group => {\n            // Keep track of\
    \ the current nesting level.\n            var current_nesting_level = 0\n    \
    \        // Keep track of the maximum nesting level.\n            var max_nesting_level\
    \ = 0\n            // For each character in the group, update the current nesting\
    \ level and the maximum nesting level.\n            for (i <- 0 until group.length)\
    \ {\n                if (group(i) == '(') {\n                    current_nesting_level\
    \ += 1\n                    max_nesting_level = max(max_nesting_level, current_nesting_level)\n\
    \                } else if (group(i) == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            // Return the maximum nesting\
    \ level.\n            max_nesting_level\n        })\n        // Return the maximum\
    \ nesting levels.\n        max_nesting_levels.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n \
    \       for (group <- paren_groups) {\n            var max_depth = 0\n       \
    \     var depth = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') depth += 1\n                else if (c == ')') depth -= 1\n           \
    \     if (depth > max_depth) max_depth = depth\n            }\n            result\
    \ += max_depth\n        }\n        result.toList", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n   \
    \     for (group <- paren_groups) {\n            var max_depth = 0\n         \
    \   var depth = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') depth += 1\n                else if (paren == ')') depth -= 1\n    \
    \            max_depth = max(max_depth, depth)\n            }\n            result\
    \ += max_depth\n        }\n        result.toList", "        val groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- groups)\
    \ {\n            var max_nesting = 0\n            var nesting = 0\n          \
    \  for (c <- group) {\n                if (c == '(') nesting += 1\n          \
    \      else if (c == ')') nesting -= 1\n                max_nesting = max(max_nesting,\
    \ nesting)\n            }\n            result += max_nesting\n        }\n    \
    \    result.toList", "        val paren_groups = paren_string.split(\" \")\n \
    \       val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        var max_depth = 0\n        var depth = 0\n        var result = List[Long]()\n\
    \        for (c <- paren_string) {\n            if (c == '(') {\n            \
    \    depth += 1\n                max_depth = max(max_depth, depth)\n         \
    \   } else if (c == ')') {\n                depth -= 1\n            } else if\
    \ (c == ' ') {\n                result = max_depth :: result\n               \
    \ max_depth = 0\n                depth = 0\n            }\n        }\n       \
    \ result = max_depth :: result\n        result.reverse", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n \
    \       for (group <- paren_groups) {\n            var max_level = 0\n       \
    \     var level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') level += 1\n                else if (paren\
    \ == ')') level -= 1\n                if (level > max_level) max_level = level\n\
    \            }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val parens = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n\
    \        for (paren <- parens) {\n            var level = 0\n            var max_level\
    \ = 0\n            for (c <- paren) {\n                if (c == '(') level +=\
    \ 1\n                else if (c == ')') level -= 1\n                if (level\
    \ > max_level) max_level = level\n            }\n            result += max_level\n\
    \        }\n        result.toList", "        val parens = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (paren <- parens)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (i <- 0 until paren.length) {\n                if (paren(i) == '(') depth +=\
    \ 1\n                else depth -= 1\n                max_depth = max(max_depth,\
    \ depth)\n            }\n            result += max_depth\n        }\n        result.toList",
  "        var result = List[Long]()\n        var max_depth = 0\n        var current_depth\
    \ = 0\n        for (c <- paren_string) {\n            if (c == '(') {\n      \
    \          current_depth += 1\n                max_depth = max(max_depth, current_depth)\n\
    \            } else if (c == ')') {\n                current_depth -= 1\n    \
    \        } else if (c == ' ') {\n                result = result :+ max_depth\n\
    \                max_depth = 0\n                current_depth = 0\n          \
    \  }\n        }\n        result = result :+ max_depth\n        return result",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (i <- 0 until group.length)\
    \ {\n                if (group(i) == '(') depth += 1\n                else depth\
    \ -= 1\n                max_depth = max(max_depth, depth)\n            }\n   \
    \         result += max_depth\n        }\n        result.toList", "        val\
    \ groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n\
    \        for (group <- groups) {\n            var max_level = 0\n            var\
    \ level = 0\n            for (c <- group) {\n                if (c == '(') {\n\
    \                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = new ListBuffer[Long]()\n        for (group\
    \ <- paren_groups) {\n            var max_level = 0\n            var current_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               current_level += 1\n                    max_level = max(max_level,\
    \ current_level)\n                } else if (c == ')') {\n                   \
    \ current_level -= 1\n                }\n            }\n            max_nesting_levels\
    \ += max_level\n        }\n        max_nesting_levels.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n \
    \       for (group <- paren_groups) {\n            var max_level = 0\n       \
    \     var level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_depth += 1\n                    max_depth = max(max_depth, current_depth)\n\
    \                } else if (c == ')') {\n                    current_depth -=\
    \ 1\n                }\n            }\n            result += max_depth\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var depth = 0\n            var max_depth = 0\n            for\
    \ (paren <- group) {\n                if (paren == '(') depth += 1\n         \
    \       else if (paren == ')') depth -= 1\n                if (depth > max_depth)\
    \ max_depth = depth\n            }\n            result += max_depth\n        }\n\
    \        result.toList", "        val groups = paren_string.split(\" \")\n   \
    \     val result = groups.map(group => {\n            var max_nesting = 0\n  \
    \          var current_nesting = 0\n            for (c <- group) {\n         \
    \       if (c == '(') {\n                    current_nesting += 1\n          \
    \          max_nesting = max(max_nesting, current_nesting)\n                }\
    \ else if (c == ')') {\n                    current_nesting -= 1\n           \
    \     }\n            }\n            max_nesting\n        }).toList\n        result",
  "        val paren_groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') depth += 1\n                else if (c == ')') depth -= 1\n           \
    \     if (depth > max_depth) max_depth = depth\n            }\n            result\
    \ += max_depth\n        }\n        result.toList", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n   \
    \     for (group <- paren_groups) {\n            var max_depth = 0\n         \
    \   var depth = 0\n            for (c <- group) {\n                if (c == '(')\
    \ depth += 1\n                else if (c == ')') depth -= 1\n                max_depth\
    \ = max(max_depth, depth)\n            }\n            result += max_depth\n  \
    \      }\n        result.toList", "        var result = List[Long]()\n       \
    \ var max_depth = 0\n        var current_depth = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                current_depth += 1\n       \
    \         max_depth = max(max_depth, current_depth)\n            } else if (c\
    \ == ')') {\n                current_depth -= 1\n            } else if (c == '\
    \ ') {\n                result = result :+ max_depth\n                max_depth\
    \ = 0\n                current_depth = 0\n            }\n        }\n        result\
    \ = result :+ max_depth\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (paren <- group) {\n                if (paren == '(') depth += 1\n         \
    \       else depth -= 1\n                max_depth = max(max_depth, depth)\n \
    \           }\n            result += max_depth\n        }\n        result.toList",
  "        val groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n\
    \        for (group <- groups) {\n            var max_depth = 0\n            var\
    \ depth = 0\n            for (paren <- group) {\n                if (paren ==\
    \ '(') depth += 1\n                else if (paren == ')') depth -= 1\n       \
    \         max_depth = max(max_depth, depth)\n            }\n            result\
    \ += max_depth\n        }\n        result.toList", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n   \
    \     for (group <- paren_groups) {\n            var max_depth = 0\n         \
    \   var depth = 0\n            for (c <- group) {\n                if (c == '(')\
    \ depth += 1\n                else if (c == ')') depth -= 1\n                if\
    \ (depth > max_depth) max_depth = depth\n            }\n            result +=\
    \ max_depth\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (c <- group) {\n                if (c == '(') current_depth += 1\n\
    \                else if (c == ')') current_depth -= 1\n                max_depth\
    \ = max(max_depth, current_depth)\n            }\n            result += max_depth\n\
    \        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_nesting\
    \ = 0\n            var current_nesting = 0\n            for (paren <- group) {\n\
    \                if (paren == '(') {\n                    current_nesting += 1\n\
    \                    max_nesting = max(max_nesting, current_nesting)\n       \
    \         } else if (paren == ')') {\n                    current_nesting -= 1\n\
    \                }\n            }\n            result += max_nesting\n       \
    \ }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (paren <- group) {\n                if (paren == '(') depth += 1\n         \
    \       else if (paren == ')') depth -= 1\n                if (depth > max_depth)\
    \ max_depth = depth\n            }\n            result += max_depth\n        }\n\
    \        result.toList", "        val paren_groups = paren_string.split(\" \"\
    )\n        val paren_levels = paren_groups.map(x => x.foldLeft(0L)((acc, c) =>\
    \ if (c == '(') acc + 1 else acc - 1)).toList\n        val paren_levels_sorted\
    \ = paren_levels.sorted\n        val paren_levels_sorted_unique = paren_levels_sorted.distinct\n\
    \        val paren_levels_sorted_unique_count = paren_levels_sorted_unique.map(x\
    \ => paren_levels_sorted.count(_ == x))\n        val paren_levels_sorted_unique_count_sorted\
    \ = paren_levels_sorted_unique_count.sorted\n        val paren_levels_sorted_unique_count_sorted_unique\
    \ = paren_levels_sorted_unique_count_sorted.distinct\n        val paren_levels_sorted_unique_count_sorted_unique_count\
    \ = paren_levels_sorted_unique_count_sorted_unique.map(x => paren_levels_sorted_unique_count_sorted.count(_\
    \ == x))\n        val paren_levels_sorted_unique_count_sorted_unique_count_sorted\
    \ = paren_levels_sorted_unique_count_sorted_unique_count.sorted\n        val paren_levels_sorted_unique_count_sorted_unique_count_sorted_unique\
    \ = paren_levels_sorted_unique_count_sorted_unique_count_sorted.distinct\n   \
    \     val paren_levels_sorted_unique_count_sorted_unique_count_sorted_unique_count\
    \ = paren_levels_sorted_unique_count_sorted_unique_count_sorted_unique.map(x =>\
    \ paren_levels_sorted_unique_count_sorted_unique_count_sorted.count(_ == x))\n\
    \        val paren_levels_sorted_unique_count_sorted_unique_count_sorted_unique_count_sorted\
    \ = paren_levels_sorted_unique_count_sorted_unique_count_", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val max_nesting_levels = paren_groups.map(group\
    \ => {\n            var max_nesting_level = 0\n            var current_nesting_level\
    \ = 0\n            for (paren <- group) {\n                if (paren == '(') {\n\
    \                    current_nesting_level += 1\n                    max_nesting_level\
    \ = max(max_nesting_level, current_nesting_level)\n                } else if (paren\
    \ == ')') {\n                    current_nesting_level -= 1\n                }\n\
    \            }\n            max_nesting_level\n        })\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  result += max_depth\n        }\n        result.toList", "        val parens\
    \ = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n     \
    \   for (p <- parens) {\n            var max_depth = 0\n            var depth\
    \ = 0\n            for (c <- p) {\n                if (c == '(') depth += 1\n\
    \                else if (c == ')') depth -= 1\n                max_depth = max(max_depth,\
    \ depth)\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') depth += 1\n                else if (paren == ')') depth -= 1\n    \
    \            max_depth = max(max_depth, depth)\n            }\n            result\
    \ += max_depth\n        }\n        result.toList", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n   \
    \     for (group <- paren_groups) {\n            var max_depth = 0\n         \
    \   var depth = 0\n            for (c <- group) {\n                if (c == '(')\
    \ depth += 1\n                else depth -= 1\n                max_depth = max(max_depth,\
    \ depth)\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(group => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (c == ')') {\n                    level -= 1\n    \
    \            }\n            }\n            max_level\n        })\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_counts\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_depth = 0\n            var depth = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') depth += 1\n                else if (paren\
    \ == ')') depth -= 1\n                if (depth > max_depth) max_depth = depth\n\
    \            }\n            paren_counts += max_depth\n        }\n        paren_counts.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') level += 1\n                else if (paren\
    \ == ')') level -= 1\n                if (level > max_level) max_level = level\n\
    \            }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n          \
    \  var max_nesting = 0\n            var current_nesting = 0\n            for (c\
    \ <- paren_group) {\n                if (c == '(') {\n                    current_nesting\
    \ += 1\n                    max_nesting = max(max_nesting, current_nesting)\n\
    \                } else if (c == ')') {\n                    current_nesting -=\
    \ 1\n                }\n            }\n            result += max_nesting\n   \
    \     }\n        result.toList", "        // Split the string into groups\n  \
    \      val groups = paren_string.split(\" \")\n        // For each group, count\
    \ the maximum level of nesting\n        groups.map(g => {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- g) {\n               \
    \ if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            max_level\n\
    \        }).toList", "        val parens = paren_string.toCharArray\n        var\
    \ stack = new Stack[Char]\n        var max_depth = 0\n        var depth = 0\n\
    \        var result = List[Long]()\n        for (paren <- parens) {\n        \
    \    if (paren == '(') {\n                depth += 1\n                max_depth\
    \ = max(max_depth, depth)\n                stack.push(paren)\n            } else\
    \ if (paren == ')') {\n                depth -= 1\n                stack.pop\n\
    \            } else if (paren == ' ') {\n                result = max_depth ::\
    \ result\n                max_depth = 0\n                depth = 0\n         \
    \   }\n        }\n        result = max_depth :: result\n        result.reverse",
  "        val groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]\n\
    \        for (group <- groups) {\n            var depth = 0\n            var max_depth\
    \ = 0\n            for (c <- group) {\n                if (c == '(') depth +=\
    \ 1\n                else if (c == ')') depth -= 1\n                if (depth\
    \ > max_depth) max_depth = depth\n            }\n            result += max_depth\n\
    \        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = paren_groups.map(group => {\n        \
    \    var max_nesting_level = 0\n            var current_nesting_level = 0\n  \
    \          for (c <- group) {\n                if (c == '(') {\n             \
    \       current_nesting_level += 1\n                    max_nesting_level = max(max_nesting_level,\
    \ current_nesting_level)\n                } else if (c == ')') {\n           \
    \         current_nesting_level -= 1\n                }\n            }\n     \
    \       max_nesting_level\n        })\n        max_nesting_levels.toList", " \
    \       val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseParens(x))\n        paren_levels.toList", "   \
    \     val paren_groups = paren_string.split(\" \")\n        val paren_levels =\
    \ paren_groups.map(paren_group => {\n            var level = 0\n            var\
    \ max_level = 0\n            for (paren <- paren_group) {\n                if\
    \ (paren == '(') level += 1\n                else if (paren == ')') level -= 1\n\
    \                if (level > max_level) max_level = level\n            }\n   \
    \         max_level\n        })\n        paren_levels.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x =>\
    \ parseNestedParens(x, 0, 0))\n        paren_levels.toList", "        // Split\
    \ the string into groups\n        val groups = paren_string.split(\" \")\n   \
    \     // For each group, find the maximum depth of nesting\n        val depths\
    \ = groups.map(group => {\n            var depth = 0\n            var max_depth\
    \ = 0\n            for (c <- group) {\n                if (c == '(') depth +=\
    \ 1\n                else if (c == ')') depth -= 1\n                max_depth\
    \ = max(max_depth, depth)\n            }\n            max_depth\n        })\n\
    \        depths.toList", "        val paren_groups = paren_string.split(\" \"\
    )\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (paren <- group) {\n       \
    \         if (paren == '(') {\n                    level += 1\n              \
    \      max_level = max(max_level, level)\n                } else if (paren ==\
    \ ')') {\n                    level -= 1\n                }\n            }\n \
    \           result += max_level\n        }\n        result.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') depth += 1\n                else depth -= 1\n                max_depth\
    \ = max(max_depth, depth)\n            }\n            result += max_depth\n  \
    \      }\n        result.toList", "        var result = List[Long]()\n       \
    \ var max_depth = 0\n        var current_depth = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                current_depth += 1\n       \
    \         max_depth = max(max_depth, current_depth)\n            } else if (c\
    \ == ')') {\n                current_depth -= 1\n            } else if (c == '\
    \ ') {\n                result = result :+ max_depth\n                max_depth\
    \ = 0\n                current_depth = 0\n            }\n        }\n        result\
    \ = result :+ max_depth\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = new ListBuffer[Long]()\n        for (group\
    \ <- paren_groups) {\n            var max_nesting_level = 0\n            var current_nesting_level\
    \ = 0\n            for (paren <- group) {\n                if (paren == '(') {\n\
    \                    current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) {\n                        max_nesting_level = current_nesting_level\n\
    \                    }\n                } else if (paren == ')') {\n         \
    \           current_nesting_level -= 1\n                }\n            }\n   \
    \         max_nesting_levels += max_nesting_level\n        }\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_nesting\
    \ = 0\n            var nesting = 0\n            for (c <- group) {\n         \
    \       if (c == '(') nesting += 1\n                else if (c == ')') nesting\
    \ -= 1\n                max_nesting = max(max_nesting, nesting)\n            }\n\
    \            result += max_nesting\n        }\n        result.toList", "     \
    \   val paren_groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') depth += 1\n                else if (c == ')') depth -= 1\n           \
    \     max_depth = max(max_depth, depth)\n            }\n            result +=\
    \ max_depth\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (paren <- group) {\n                if (paren == '(') {\n                  \
    \  level += 1\n                    max_level = max(max_level, level)\n       \
    \         } else if (paren == ')') {\n                    level -= 1\n       \
    \         }\n            }\n            result += max_level\n        }\n     \
    \   result.toList", "        val paren_groups = paren_string.split(\" \")\n  \
    \      val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  result += max_depth\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val max_nesting_levels = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_nesting_level = 0\n\
    \            var current_nesting_level = 0\n            for (paren <- group) {\n\
    \                if (paren == '(') {\n                    current_nesting_level\
    \ += 1\n                    if (current_nesting_level > max_nesting_level) max_nesting_level\
    \ = current_nesting_level\n                }\n                else if (paren ==\
    \ ')') {\n                    current_nesting_level -= 1\n                }\n\
    \            }\n            max_nesting_levels += max_nesting_level\n        }\n\
    \        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = paren_groups.map(x => x.count(y => y ==\
    \ '(') - x.count(y => y == ')')).toList\n        val max_nesting_levels_abs =\
    \ max_nesting_levels.map(x => abs(x))\n        val max_nesting_level = max_nesting_levels_abs.max\n\
    \        val result = max_nesting_levels.map(x => max_nesting_level - abs(x))\n\
    \        result", "        val paren_groups = paren_string.split(\" \")\n    \
    \    val paren_levels = paren_groups.map(x => {\n            var level = 0\n \
    \           var max_level = 0\n            for (i <- 0 until x.length) {\n   \
    \             if (x(i) == '(') level += 1\n                else if (x(i) == ')')\
    \ level -= 1\n                if (level > max_level) max_level = level\n     \
    \       }\n            max_level\n        })\n        paren_levels.toList", " \
    \       val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var depth\
    \ = 0\n            var max_depth = 0\n            for (c <- group) {\n       \
    \         if (c == '(') depth += 1\n                else if (c == ')') depth -=\
    \ 1\n                max_depth = max(max_depth, depth)\n            }\n      \
    \      result += max_depth\n        }\n        result.toList", "        val parens\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n \
    \       for (paren <- parens) {\n            var max_level = 0\n            var\
    \ level = 0\n            for (c <- paren) {\n                if (c == '(') level\
    \ += 1\n                else if (c == ')') level -= 1\n                max_level\
    \ = max(max_level, level)\n            }\n            result += max_level\n  \
    \      }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val results = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                if (depth > max_depth) max_depth = depth\n            }\n   \
    \         results += max_depth\n        }\n        results.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val paren_levels = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = new ListBuffer[Long]()\n        for (group\
    \ <- paren_groups) {\n            var nesting_level = 0\n            var max_nesting_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') nesting_level\
    \ += 1\n                else if (c == ')') nesting_level -= 1\n              \
    \  if (nesting_level > max_nesting_level) max_nesting_level = nesting_level\n\
    \            }\n            max_nesting_levels += max_nesting_level\n        }\n\
    \        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else depth -= 1\n            \
    \    max_depth = max(max_depth, depth)\n            }\n            result += max_depth\n\
    \        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (paren <- group) {\n                if (paren == '(') {\n                  \
    \  level += 1\n                    max_level = max(max_level, level)\n       \
    \         } else if (paren == ')') {\n                    level -= 1\n       \
    \         }\n            }\n            result += max_level\n        }\n     \
    \   result.toList", "        val paren_groups = paren_string.split(\" \")\n  \
    \      val max_nesting_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var nesting_level = 0\n            var max_nesting_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               nesting_level += 1\n                    if (nesting_level > max_nesting_level)\
    \ max_nesting_level = nesting_level\n                }\n                else if\
    \ (c == ')') {\n                    nesting_level -= 1\n                }\n  \
    \          }\n            max_nesting_levels += max_nesting_level\n        }\n\
    \        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = paren_groups.map(group => {\n            var max_nesting_level = 0\n     \
    \       var current_nesting_level = 0\n            for (paren <- group) {\n  \
    \              if (paren == '(') {\n                    current_nesting_level\
    \ += 1\n                    max_nesting_level = max(max_nesting_level, current_nesting_level)\n\
    \                } else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_level\n    \
    \    })\n        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (c <- group) {\n                if (c == '(') {\n           \
    \         level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (c == ')') {\n                    level -= 1\n    \
    \            }\n            }\n            paren_levels += max_level\n       \
    \ }\n        paren_levels.toList", "        val groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]\n        for (group <- groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (paren <- group) {\n                if (paren == '(') depth += 1\n         \
    \       else if (paren == ')') depth -= 1\n                max_depth = max(max_depth,\
    \ depth)\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result +=\
    \ max_level\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var depth = 0\n            var max_depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') level += 1\n                else if (c == ')') level -= 1\n\
    \                max_level = max(max_level, level)\n            }\n          \
    \  result += max_level\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') level += 1\n                else\
    \ if (c == ')') level -= 1\n                max_level = max(max_level, level)\n\
    \            }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') level += 1\n                else if (c == ')') level -= 1\n\
    \                if (level > max_level) max_level = level\n            }\n   \
    \         result += max_level\n        }\n        result.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x\
    \ => {\n            var level = 0\n            var max_level = 0\n           \
    \ for (c <- x) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            max_level\n        })\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val depths = new\
    \ ListBuffer[Long]\n        for (group <- paren_groups) {\n            var depth\
    \ = 0\n            var max_depth = 0\n            for (c <- group) {\n       \
    \         if (c == '(') depth += 1\n                else if (c == ')') depth -=\
    \ 1\n                if (depth > max_depth) max_depth = depth\n            }\n\
    \            depths += max_depth\n        }\n        depths.toList", "       \
    \ val paren_groups = paren_string.split(\" \")\n        val paren_levels = new\
    \ ListBuffer[Long]()\n        for (i <- 0 until paren_groups.length) {\n     \
    \       val paren_group = paren_groups(i)\n            var level = 0\n       \
    \     var max_level = 0\n            for (j <- 0 until paren_group.length) {\n\
    \                if (paren_group(j) == '(') level += 1\n                else if\
    \ (paren_group(j) == ')') level -= 1\n                if (level > max_level) max_level\
    \ = level\n            }\n            paren_levels += max_level\n        }\n \
    \       paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- group) {\n                if (paren == '(') level +=\
    \ 1\n                else if (paren == ')') level -= 1\n                if (level\
    \ > max_level) max_level = level\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (paren <- group) {\n       \
    \         if (paren == '(') depth += 1\n                else depth -= 1\n    \
    \            max_depth = max(max_depth, depth)\n            }\n            result\
    \ += max_depth\n        }\n        result.toList", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n   \
    \     for (group <- paren_groups) {\n            var max_depth = 0\n         \
    \   var depth = 0\n            for (c <- group) {\n                if (c == '(')\
    \ {\n                    depth += 1\n                    max_depth = max(max_depth,\
    \ depth)\n                } else if (c == ')') {\n                    depth -=\
    \ 1\n                }\n            }\n            result += max_depth\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = new ListBuffer[Long]()\n        for (group\
    \ <- paren_groups) {\n            var nesting_level = 0\n            var max_nesting_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') nesting_level\
    \ += 1\n                else if (c == ')') nesting_level -= 1\n              \
    \  if (nesting_level > max_nesting_level) max_nesting_level = nesting_level\n\
    \            }\n            max_nesting_levels += max_nesting_level\n        }\n\
    \        max_nesting_levels.toList", "        // Split the string into groups.\n\
    \        val groups = paren_string.split(\" \")\n        // For each group, find\
    \ the maximum nesting level.\n        val max_nesting_levels = groups.map(group\
    \ => {\n            // Keep track of the maximum nesting level.\n            var\
    \ max_nesting_level = 0\n            // Keep track of the current nesting level.\n\
    \            var current_nesting_level = 0\n            // For each character\
    \ in the group, update the nesting level.\n            group.foreach(c => {\n\
    \                if (c == '(') {\n                    current_nesting_level +=\
    \ 1\n                    if (current_nesting_level > max_nesting_level) max_nesting_level\
    \ = current_nesting_level\n                }\n                else if (c == ')')\
    \ {\n                    current_nesting_level -= 1\n                }\n     \
    \       })\n            max_nesting_level\n        })\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result +=\
    \ max_level\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (i <- 0 until\
    \ paren_groups.length) {\n            val paren_group = paren_groups(i)\n    \
    \        var max_depth = 0\n            var depth = 0\n            for (j <- 0\
    \ until paren_group.length) {\n                if (paren_group(j) == '(') depth\
    \ += 1\n                else if (paren_group(j) == ')') depth -= 1\n         \
    \       if (depth > max_depth) max_depth = depth\n            }\n            result\
    \ += max_depth\n        }\n        result.toList", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n       \
    \ for (group <- paren_groups) {\n            var max_depth = 0\n            var\
    \ current_depth = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    current_depth += 1\n                    max_depth\
    \ = max(max_depth, current_depth)\n                } else if (c == ')') {\n  \
    \                  current_depth -= 1\n                }\n            }\n    \
    \        result += max_depth\n        }\n        result.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x\
    \ => parseParens(x))\n        paren_levels.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = new ListBuffer[Long]()\n\
    \        for (i <- 0 until paren_groups.length) {\n            val paren_group\
    \ = paren_groups(i)\n            var level = 0\n            var max_level = 0\n\
    \            for (j <- 0 until paren_group.length) {\n                val c =\
    \ paren_group(j)\n                if (c == '(') {\n                    level +=\
    \ 1\n                    if (level > max_level) max_level = level\n          \
    \      } else if (c == ')') {\n                    level -= 1\n              \
    \  }\n            }\n            paren_levels += max_level\n        }\n      \
    \  paren_levels.toList", "        val groups = paren_string.split(\" \")\n   \
    \     val result = new ListBuffer[Long]\n        for (group <- groups) {\n   \
    \         var depth = 0\n            var max_depth = 0\n            for (c <-\
    \ group) {\n                if (c == '(') depth += 1\n                else if\
    \ (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n \
    \           }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_levels =\
    \ new ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ level = 0\n            var max_level = 0\n            for (paren <- group) {\n\
    \                if (paren == '(') level += 1\n                else if (paren\
    \ == ')') level -= 1\n                if (level > max_level) max_level = level\n\
    \            }\n            max_levels += max_level\n        }\n        max_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (i <- 0 until x.length) {\n                if (x(i) ==\
    \ '(') level += 1\n                else if (x(i) == ')') level -= 1\n        \
    \        if (level > max_level) max_level = level\n            }\n           \
    \ max_level\n        })\n        paren_levels.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n \
    \       for (group <- paren_groups) {\n            var max_level = 0\n       \
    \     var level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.foldLeft(0L)((acc, x)\
    \ => if (x == '(') acc + 1 else acc - 1)).toList\n        val max_levels = paren_levels.map(x\
    \ => if (x < 0) 0 else x)\n        max_levels", "        var result = List[Long]()\n\
    \        var current_level = 0\n        var max_level = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                current_level += 1\n       \
    \         max_level = max(max_level, current_level)\n            } else if (c\
    \ == ')') {\n                current_level -= 1\n            } else if (c == '\
    \ ') {\n                result = result :+ max_level\n                max_level\
    \ = 0\n                current_level = 0\n            }\n        }\n        result\
    \ = result :+ max_level\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(group => {\n            var\
    \ level = 0\n            var max_level = 0\n            for (c <- group) {\n \
    \               if (c == '(') {\n                    level += 1\n            \
    \        max_level = max(max_level, level)\n                } else if (c == ')')\
    \ {\n                    level -= 1\n                }\n            }\n      \
    \      max_level\n        })\n        paren_levels.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (paren == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (c <- group) {\n                if (c == '(') level += 1\n  \
    \              else if (c == ')') level -= 1\n                if (level > max_level)\
    \ max_level = level\n            }\n            paren_levels += max_level\n  \
    \      }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = paren_groups.map(group => {\n        \
    \    var max_nesting_level = 0\n            var current_nesting_level = 0\n  \
    \          for (i <- 0 until group.length) {\n                if (group(i) ==\
    \ '(') {\n                    current_nesting_level += 1\n                   \
    \ max_nesting_level = max(max_nesting_level, current_nesting_level)\n        \
    \        } else if (group(i) == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_level\n    \
    \    })\n        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (c <- group) {\n                if (c == '(') level += 1\n  \
    \              else if (c == ')') level -= 1\n                if (level > max_level)\
    \ max_level = level\n            }\n            paren_levels += max_level\n  \
    \      }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        paren_groups.map(x\
    \ => parseNestedParens(x, 0)).toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (i <- 0 until group.length) {\n                if (group(i) == '(') level +=\
    \ 1\n                else if (group(i) == ')') level -= 1\n                if\
    \ (level > max_level) max_level = level\n            }\n            result +=\
    \ max_level\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.count(y => y == '(')\
    \ - x.count(y => y == ')'))\n        val max_level = paren_levels.max\n      \
    \  val min_level = paren_levels.min\n        val max_level_groups = paren_groups.zip(paren_levels).filter(x\
    \ => x._2 == max_level).map(x => x._1)\n        val min_level_groups = paren_groups.zip(paren_levels).filter(x\
    \ => x._2 == min_level).map(x => x._1)\n        val max_level_count = max_level_groups.map(x\
    \ => x.count(y => y == '(')).sum\n        val min_level_count = min_level_groups.map(x\
    \ => x.count(y => y == '(')).sum\n        List(max_level_count, min_level_count)",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var current_depth = 0\n            for (ch <- group) {\n  \
    \              if (ch == '(') {\n                    current_depth += 1\n    \
    \                max_depth = max(max_depth, current_depth)\n                }\
    \ else if (ch == ')') {\n                    current_depth -= 1\n            \
    \    }\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') level += 1\n                else if (c == ')') level -= 1\n\
    \                max_level = max(max_level, level)\n            }\n          \
    \  result += max_level\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n \
    \       for (group <- paren_groups) {\n            var max_level = 0\n       \
    \     var level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            val stack = new Stack[Char]()\n            var max_nesting =\
    \ 0\n            var current_nesting = 0\n            for (paren <- group) {\n\
    \                if (paren == '(') {\n                    stack.push(paren)\n\
    \                    current_nesting += 1\n                    max_nesting = max(max_nesting,\
    \ current_nesting)\n                } else if (paren == ')') {\n             \
    \       if (stack.isEmpty) {\n                        throw new Exception(\"Invalid\
    \ paren string\")\n                    }\n                    stack.pop()\n  \
    \                  current_nesting -= 1\n                }\n            }\n  \
    \          if (!stack.isEmpty) {\n                throw new Exception(\"Invalid\
    \ paren string\")\n            }\n            result += max_nesting\n        }\n\
    \        result.toList", "        val paren_groups = paren_string.split(\" \"\
    )\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_nesting = 0\n            var current_nesting = 0\n  \
    \          for (paren <- group) {\n                if (paren == '(') current_nesting\
    \ += 1\n                else current_nesting -= 1\n                max_nesting\
    \ = max(max_nesting, current_nesting)\n            }\n            result += max_nesting\n\
    \        }\n        result.toList", "        var result = List[Long]()\n     \
    \   for (group <- paren_string.split(\" \")) {\n            var stack = new Stack[Char]()\n\
    \            var max_depth = 0\n            var depth = 0\n            for (c\
    \ <- group) {\n                if (c == '(') {\n                    stack.push(c)\n\
    \                    depth += 1\n                    max_depth = max(max_depth,\
    \ depth)\n                } else if (c == ')') {\n                    stack.pop\n\
    \                    depth -= 1\n                }\n            }\n          \
    \  result = result :+ max_depth\n        }\n        return result", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val paren_levels = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (paren == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (i <- 0 until\
    \ paren_groups.length) {\n            var max_depth = 0\n            var depth\
    \ = 0\n            for (j <- 0 until paren_groups(i).length) {\n             \
    \   if (paren_groups(i)(j) == '(') depth += 1\n                else if (paren_groups(i)(j)\
    \ == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n    \
    \        }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') level += 1\n                else if (c == ')')\
    \ level -= 1\n                if (level > max_level) max_level = level\n     \
    \       }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(group => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') level +=\
    \ 1\n                else if (c == ')') level -= 1\n                if (level\
    \ > max_level) max_level = level\n            }\n            max_level\n     \
    \   })\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(group => {\n            var\
    \ level = 0\n            var max_level = 0\n            for (c <- group) {\n \
    \               if (c == '(') level += 1\n                else if (c == ')') level\
    \ -= 1\n                max_level = max(max_level, level)\n            }\n   \
    \         max_level\n        })\n        paren_levels.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n \
    \       for (group <- paren_groups) {\n            var max_depth = 0\n       \
    \     var depth = 0\n            for (ch <- group) {\n                if (ch ==\
    \ '(') depth += 1\n                else if (ch == ')') depth -= 1\n          \
    \      max_depth = max(max_depth, depth)\n            }\n            result +=\
    \ max_depth\n        }\n        result.toList", "        val groups = paren_string.split(\"\
    \ \")\n        val depths = new ListBuffer[Long]\n        for (group <- groups)\
    \ {\n            var depth = 0\n            var max_depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            depths += max_depth\n        }\n        depths.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting_level = 0\n            var current_nesting_level = 0\n    \
    \        for (paren <- group) {\n                if (paren == '(') {\n       \
    \             current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (paren == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (c <- group) {\n                if (c == '(') {\n           \
    \         level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (c == ')') {\n                    level -= 1\n    \
    \            }\n            }\n            paren_levels += max_level\n       \
    \ }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.count(y => y == '(')\
    \ - x.count(y => y == ')'))\n        val max_level = paren_levels.max\n      \
    \  val min_level = paren_levels.min\n        val max_level_groups = paren_groups.zip(paren_levels).filter(x\
    \ => x._2 == max_level).map(x => x._1)\n        val min_level_groups = paren_groups.zip(paren_levels).filter(x\
    \ => x._2 == min_level).map(x => x._1)\n        val max_level_parens = max_level_groups.map(x\
    \ => x.count(y => y == '(')).max\n        val min_level_parens = min_level_groups.map(x\
    \ => x.count(y => y == '(')).min\n        val max_level_parens_groups = max_level_groups.filter(x\
    \ => x.count(y => y == '(') == max_level_parens)\n        val min_level_parens_groups\
    \ = min_level_groups.filter(x => x.count(y => y == '(') == min_level_parens)\n\
    \        val max_level_parens_groups_length = max_level_parens_groups.map(x =>\
    \ x.length).max\n        val min_level_parens_groups_length = min_level_parens_groups.map(x\
    \ => x.length).min\n        val max_level_parens_groups_length_groups = max_level_parens_groups.filter(x\
    \ => x.length == max_level_parens_groups_length)\n        val min_level_parens_groups_length_groups\
    \ = min_level_parens_groups.filter(x => x.length == min_level_parens_groups_length)\n\
    \        val max_level_parens_groups_length_groups_sorted = max_level_parens_groups_length_groups.sortWith((x,\
    \ y) => x < y)\n        val min_level_", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_depth += 1\n                    max_depth = max(max_depth, current_depth)\n\
    \                } else if (c == ')') {\n                    current_depth -=\
    \ 1\n                }\n            }\n            result += max_depth\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_counts = paren_groups.map(group => {\n            var\
    \ count = 0\n            var max_count = 0\n            for (c <- group) {\n \
    \               if (c == '(') count += 1\n                else if (c == ')') count\
    \ -= 1\n                max_count = max(max_count, count)\n            }\n   \
    \         max_count\n        })\n        paren_counts.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n     \
    \   for (group <- paren_groups) {\n            var max_depth = 0\n           \
    \ var current_depth = 0\n            for (c <- group) {\n                if (c\
    \ == '(') {\n                    current_depth += 1\n                    max_depth\
    \ = max(max_depth, current_depth)\n                } else if (c == ')') {\n  \
    \                  current_depth -= 1\n                }\n            }\n    \
    \        result += max_depth\n        }\n        result.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(group\
    \ => {\n            var max_level = 0\n            var current_level = 0\n   \
    \         for (c <- group) {\n                if (c == '(') {\n              \
    \      current_level += 1\n                    max_level = max(max_level, current_level)\n\
    \                } else if (c == ')') {\n                    current_level -=\
    \ 1\n                }\n            }\n            max_level\n        })\n   \
    \     paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(group => {\n            val\
    \ stack = new Stack[Char]\n            var level = 0\n            var max_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               stack.push(c)\n                    level += 1\n              \
    \      max_level = max(max_level, level)\n                } else if (c == ')')\
    \ {\n                    if (stack.isEmpty) {\n                        return\
    \ -1\n                    } else {\n                        stack.pop\n      \
    \                  level -= 1\n                    }\n                }\n    \
    \        }\n            if (stack.isEmpty) {\n                max_level\n    \
    \        } else {\n                -1\n            }\n        })\n        paren_levels.toList.map(x\
    \ => x.toLong)", "        val paren_groups = paren_string.split(\" \")\n     \
    \   val levels = new ListBuffer[Long]\n        for (group <- paren_groups) {\n\
    \            var level = 0\n            var max_level = 0\n            for (c\
    \ <- group) {\n                if (c == '(') level += 1\n                else\
    \ if (c == ')') level -= 1\n                max_level = max(max_level, level)\n\
    \            }\n            levels += max_level\n        }\n        levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(group => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') level +=\
    \ 1\n                else if (c == ')') level -= 1\n                if (level\
    \ > max_level) max_level = level\n            }\n            max_level\n     \
    \   })\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_groups_list = paren_groups.toList\n        val paren_groups_list_length\
    \ = paren_groups_list.length\n        val paren_groups_list_length_range = 0 until\
    \ paren_groups_list_length\n        val paren_groups_list_length_range_list =\
    \ paren_groups_list_length_range.toList\n        val paren_groups_list_length_range_list_map\
    \ = paren_groups_list_length_range_list.map(x => x.toLong)\n        val paren_groups_list_length_range_list_map_zip\
    \ = paren_groups_list_length_range_list_map.zip(paren_groups_list)\n        val\
    \ paren_groups_list_length_range_list_map_zip_map = paren_groups_list_length_range_list_map_zip.map(x\
    \ => (x._1, x._2.toList))\n        val paren_groups_list_length_range_list_map_zip_map_map\
    \ = paren_groups_list_length_range_list_map_zip_map.map(x => (x._1, x._2.map(y\
    \ => y.toString)))\n        val paren_groups_list_length_range_list_map_zip_map_map_map\
    \ = paren_groups_list_length_range_list_map_zip_map_map.map(x => (x._1, x._2.map(y\
    \ => y.toList)))\n        val paren_groups_list_length_range_list_map_zip_map_map_map_map\
    \ = paren_groups_list_length_range_list_map_zip_map_map_map.map(x => (x._1, x._2.map(y\
    \ => y.map(z => z.toString))))\n        val paren_groups_list_length_range_list_map_zip_map_map_map_map_map\
    \ = paren_groups_list_length_range_list_map_zip_map_map_map_map", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val max_nesting_levels = paren_groups.map(group\
    \ => {\n            var max_nesting_level = 0\n            var current_nesting_level\
    \ = 0\n            for (paren <- group) {\n                if (paren == '(') {\n\
    \                    current_nesting_level += 1\n                    max_nesting_level\
    \ = max(max_nesting_level, current_nesting_level)\n                } else if (paren\
    \ == ')') {\n                    current_nesting_level -= 1\n                }\n\
    \            }\n            max_nesting_level\n        })\n        max_nesting_levels.toList",
  "        val groups = paren_string.split(\" \")\n        val results = new ListBuffer[Long]\n\
    \        for (group <- groups) {\n            var max_nesting = 0\n          \
    \  var nesting = 0\n            for (c <- group) {\n                if (c == '(')\
    \ nesting += 1\n                else if (c == ')') nesting -= 1\n            \
    \    if (nesting > max_nesting) max_nesting = nesting\n            }\n       \
    \     results += max_nesting\n        }\n        results.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val paren_levels = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        // Split the string into groups\n\
    \        val groups = paren_string.split(\" \")\n        // For each group, find\
    \ the deepest level of nesting\n        val depths = groups.map(group => {\n \
    \           // Keep track of the current depth of nesting\n            var depth\
    \ = 0\n            // Keep track of the maximum depth of nesting\n           \
    \ var max_depth = 0\n            // For each character in the group, update the\
    \ depth of nesting\n            for (c <- group) {\n                c match {\n\
    \                    case '(' => depth += 1\n                    case ')' => depth\
    \ -= 1\n                }\n                // Update the maximum depth of nesting\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  // Return the maximum depth of nesting\n            max_depth\n        })\n\
    \        // Return the maximum depths of nesting for each group\n        depths.toList",
  "        val parens = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (paren <- parens) {\n            var max_level = 0\n            var\
    \ level = 0\n            for (c <- paren) {\n                if (c == '(') level\
    \ += 1\n                else if (c == ')') level -= 1\n                if (level\
    \ > max_level) max_level = level\n            }\n            result = max_level\
    \ :: result\n        }\n        result.reverse", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- group) {\n                if (paren == '(') level +=\
    \ 1\n                else if (paren == ')') level -= 1\n                if (level\
    \ > max_level) max_level = level\n            }\n            max_levels += max_level\n\
    \        }\n        max_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') level += 1\n                else\
    \ if (c == ')') level -= 1\n                max_level = max(max_level, level)\n\
    \            }\n            result += max_level\n        }\n        result.toList"]
stop_tokens:
- "\n    }\n"
