language: scala
name: HumanEval_109_move_one_ball
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val a = arr.toArray\n        val b = new Array[Long](n)\n\
    \        for (i <- 0 until n) b(i) = a(i)\n        for (i <- 0 until n) {\n  \
    \          val j = (i + 1) % n\n            if (b(i) > b(j)) {\n             \
    \   val t = b(i)\n                b(i) = b(j)\n                b(j) = t\n    \
    \            if (isSorted(b)) return true\n                b(j) = b(i)\n     \
    \           b(i) = t\n            }\n        }\n        return false\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2z2uhevt.scala:33:20 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                \e[33mif\e[0m (isSorted(b)) \e[33mreturn\e\
    [0m \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: isSorted\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009100
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        val maxIndex = arr.indexOf(max)\n        val\
    \ minIndex = arr.indexOf(min)\n        if (maxIndex == 0) {\n            if (minIndex\
    \ == n - 1) return true\n            else return false\n        }\n        else\
    \ if (minIndex == n - 1) return false\n        else {\n            if (maxIndex\
    \ == n - 1) return true\n            else return false\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu3170i1r.scala:38)\n\tat Problem.main(tmpu3170i1r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val a = arr.toArray\n\
    \        val dp = Array.fill(n)(0)\n        for (i <- 0 until n) {\n         \
    \   dp(i) = 1\n            for (j <- 0 until i) {\n                if (a(j) <=\
    \ a(i)) dp(i) = max(dp(i), dp(j) + 1)\n            }\n        }\n        dp.max\
    \ >= n\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpain99mm2.scala:34)\n\tat Problem.main(tmpain99mm2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val sorted = arr.sorted\n        val diff = (0 until n).map(i\
    \ => arr(i) - sorted(i)).toList\n        val maxDiff = diff.max\n        val minDiff\
    \ = diff.min\n        if (maxDiff - minDiff > 1) return false\n        if (maxDiff\
    \ == minDiff) return true\n        val maxDiffIndex = diff.indexOf(maxDiff)\n\
    \        val minDiffIndex = diff.indexOf(minDiff)\n        if (maxDiffIndex ==\
    \ 0) return true\n        if (minDiffIndex == n - 1) return true\n        if (maxDiffIndex\
    \ == n - 1) return false\n        if (minDiffIndex == 0) return false\n      \
    \  if (arr(maxDiffIndex - 1) <= sorted(maxDiffIndex)) return true\n        if\
    \ (arr(minDiffIndex + 1) >= sorted(minDiffIndex)) return true\n        false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbxkyfgtb.scala:41)\n\tat Problem.main(tmpbxkyfgtb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val a = arr.toArray\n        val b = new Array[Long](n)\n\
    \        for (i <- 0 until n) b(i) = a(i)\n        for (i <- 0 until n) {\n  \
    \          val x = a(i)\n            var j = i\n            while (j > 0 && b(j\
    \ - 1) > x) {\n                b(j) = b(j - 1)\n                j -= 1\n     \
    \       }\n            b(j) = x\n        }\n        for (i <- 0 until n) if (a(i)\
    \ != b(i)) return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdxqm61ks.scala:42)\n\tat Problem.main(tmpdxqm61ks.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        val maxIndex = arr.indexOf(max)\n        val\
    \ minIndex = arr.indexOf(min)\n        if (maxIndex == n - 1) {\n            if\
    \ (minIndex == 0) {\n                return true\n            } else {\n     \
    \           return false\n            }\n        } else {\n            if (minIndex\
    \ == 0) {\n                return true\n            } else {\n               \
    \ return false\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp0bp6cdn.scala:42)\n\tat Problem.main(tmpp0bp6cdn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val dp = Array.fill(n)(0)\n        for (i <- 1 until n)\
    \ {\n            if (arr(i) < arr(i - 1)) {\n                dp(i) = dp(i - 1)\
    \ + 1\n            }\n        }\n        for (i <- 1 until n) {\n            if\
    \ (dp(i) > dp(i - 1)) return false\n        }\n        return true\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3qy__yox.scala:36)\n\tat Problem.main(tmp3qy__yox.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val max = arr.max\n        val min = arr.min\n        if\
    \ (max - min == n - 1) return true\n        else return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa21kw7xm.scala:31)\n\tat Problem.main(tmpa21kw7xm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        if (max - min > 1) return false\n        if\
    \ (max - min == 1) {\n            val maxIndex = arr.indexOf(max)\n          \
    \  val minIndex = arr.indexOf(min)\n            if (maxIndex - minIndex == 1)\
    \ return false\n            if (maxIndex - minIndex == n - 1) return false\n \
    \       }\n        return true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1c2k32tl.scala:35)\n\tat Problem.main(tmp1c2k32tl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val a = arr.toArray\n        val b = Array.fill(n)(0)\n\
    \        for (i <- 0 until n) {\n            b(i) = a(i)\n        }\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until n) {\n                if (b(j)\
    \ == i) {\n                    a(i) = j\n                    break\n         \
    \       }\n            }\n        }\n        for (i <- 0 until n - 1) {\n    \
    \        if (a(i) > a(i + 1)) return false\n        }\n        return true\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjqics09z.scala:27:20\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            b(i) = a(i)\n\e[31m\e\
    [31m   |\e[0m                   ^^^^\e[0m\n\e[31m   |\e[0m                   Found:\
    \    Long\n\e[31m   |\e[0m                   Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpjqics09z.scala:33:20 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val a = arr.toArray\n\
    \        val b = new Array[Long](n)\n        val c = new Array[Long](n)\n    \
    \    for (i <- 0 until n) {\n            b(i) = a(i)\n            c(i) = a(i)\n\
    \        }\n        scala.util.Sorting.quickSort(b)\n        var i = 0\n     \
    \   while (i < n) {\n            if (b(i) != c(i)) {\n                val j =\
    \ c.indexOf(b(i))\n                val temp = c(i)\n                c(i) = c(j)\n\
    \                c(j) = temp\n                if (c.mkString(\" \") == b.mkString(\"\
    \ \")) return true\n                else return false\n            }\n       \
    \     i += 1\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0ob0x6t0.scala:46)\n\tat Problem.main(tmp0ob0x6t0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val a = arr.toArray\n\
    \        val b = Array.fill(n)(0)\n        for (i <- 0 until n) {\n          \
    \  b(i) = a(i)\n        }\n        for (i <- 0 until n) {\n            if (b(i)\
    \ != i + 1) {\n                var j = i + 1\n                while (j < n &&\
    \ b(j) != i + 1) {\n                    j += 1\n                }\n          \
    \      if (j == n) return false\n                for (k <- j - 1 to i by -1) {\n\
    \                    b(k + 1) = b(k)\n                }\n                b(i)\
    \ = i + 1\n            }\n        }\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkltzyi1j.scala:26:20\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            b(i) = a(i)\n\e[31m\e\
    [31m   |\e[0m                   ^^^^\e[0m\n\e[31m   |\e[0m                   Found:\
    \    Long\n\e[31m   |\e[0m                   Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        val maxIndex = arr.indexOf(max)\n        val\
    \ minIndex = arr.indexOf(min)\n        if (maxIndex == n - 1) {\n            if\
    \ (minIndex == 0) {\n                return true\n            } else {\n     \
    \           return false\n            }\n        } else {\n            if (minIndex\
    \ == 0) {\n                return true\n            } else {\n               \
    \ return false\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp0bp6cdn.scala:42)\n\tat Problem.main(tmpp0bp6cdn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val dp = Array.fill(n)(0)\n\
    \        for (i <- 0 until n) {\n            dp(i) = 1\n            for (j <-\
    \ 0 until i) {\n                if (arr(j) <= arr(i)) dp(i) = max(dp(i), dp(j)\
    \ + 1)\n            }\n        }\n        dp.max >= n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt0rjz_q8.scala:33)\n\tat Problem.main(tmpt0rjz_q8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val dp = Array.fill(n)(0)\n        for (i <- 1 until n)\
    \ {\n            if (arr(i) >= arr(i - 1)) dp(i) = dp(i - 1) + 1\n           \
    \ else dp(i) = dp(i - 1)\n        }\n        dp(n - 1) <= n - 1\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptpegdbh1.scala:34)\n\tat Problem.main(tmptpegdbh1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val a = Array.fill(n)(0L)\n        for (i <- 0 until n)\
    \ a(i) = arr(i)\n        val max = a.max\n        val min = a.min\n        if\
    \ (max - min == n - 1) return true\n        val dp = Array.fill(n)(0L)\n     \
    \   for (i <- 0 until n) {\n            dp(i) = a(i) - min\n        }\n      \
    \  val count = Array.fill(n)(0L)\n        for (i <- 0 until n) {\n           \
    \ count(dp(i).toInt) += 1\n        }\n        for (i <- 1 until n) {\n       \
    \     if (count(i) > 1) return false\n        }\n        return true\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 9 out of bounds for length\
    \ 5\n\tat Problem$.moveOneBall$$anonfun$3(tmpjryzd32y.scala:35)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall(tmpjryzd32y.scala:36)\n\
    \tat Problem$.main(tmpjryzd32y.scala:44)\n\tat Problem.main(tmpjryzd32y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009105
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr2 =\
    \ arr.toArray\n        for (i <- 0 until n) {\n            val tmp = arr2(i)\n\
    \            arr2(i) = arr2(n - 1)\n            arr2(n - 1) = tmp\n          \
    \  if (arr2.sorted.sameElements(arr2)) return true\n            arr2(n - 1) =\
    \ arr2(i)\n            arr2(i) = tmp\n        }\n        false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe7i9__4k.scala:35)\n\tat Problem.main(tmpe7i9__4k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if (arr.length == 0) return true\n    \
    \    val n = arr.length\n        val min = arr.min\n        val max = arr.max\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        if (minIndex == 0 && maxIndex == n - 1) return true\n        if (minIndex\
    \ == 0 && maxIndex == n - 2) return true\n        if (minIndex == 1 && maxIndex\
    \ == n - 1) return true\n        if (minIndex == 1 && maxIndex == n - 2) return\
    \ true\n        return false\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm18c39o5.scala:35)\n\tat Problem.main(tmpm18c39o5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if (arr.size == 0) return true\n      \
    \  var min = arr(0)\n        var max = arr(0)\n        for (i <- 1 until arr.size)\
    \ {\n            if (arr(i) < min) min = arr(i)\n            if (arr(i) > max)\
    \ max = arr(i)\n        }\n        if (min == max) return true\n        var minIndex\
    \ = -1\n        var maxIndex = -1\n        for (i <- 0 until arr.size) {\n   \
    \         if (arr(i) == min) minIndex = i\n            if (arr(i) == max) maxIndex\
    \ = i\n        }\n        if (minIndex == 0) return false\n        if (maxIndex\
    \ == arr.size - 1) return false\n        if (minIndex == -1 || maxIndex == -1)\
    \ return false\n        if (minIndex < maxIndex) return false\n        return\
    \ true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnqeh4s_s.scala:45)\n\tat Problem.main(tmpnqeh4s_s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr2 =\
    \ arr.toArray\n        val arr3 = new Array[Long](n)\n        for (i <- 0 until\
    \ n) {\n            arr3(i) = arr2(i)\n        }\n        for (i <- 0 until n)\
    \ {\n            if (arr2(i) != arr3(i)) {\n                val temp = arr2(i)\n\
    \                arr2(i) = arr3(i)\n                arr3(i) = temp\n         \
    \       return true\n            }\n        }\n        return false\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp80xqa5j3.scala:39)\n\tat Problem.main(tmp80xqa5j3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val max = arr.max\n        val min = arr.min\n        val\
    \ maxIndex = arr.indexOf(max)\n        val minIndex = arr.indexOf(min)\n     \
    \   if (maxIndex == n - 1) return true\n        if (minIndex == 0) return false\n\
    \        if (maxIndex == minIndex + 1) return true\n        if (maxIndex == 0)\
    \ return false\n        if (minIndex == n - 1) return true\n        if (maxIndex\
    \ < minIndex) return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7ibc5ww2.scala:40)\n\tat Problem.main(tmp7ibc5ww2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        var i = 0\n        while (i < n - 1) {\n            if\
    \ (arr(i) > arr(i + 1)) {\n                var j = i + 1\n                while\
    \ (j < n && arr(j) < arr(i)) j += 1\n                if (j == n) return false\n\
    \                else {\n                    var k = j\n                    while\
    \ (k > i) {\n                        val temp = arr(k)\n                     \
    \   arr(k) = arr(k - 1)\n                        arr(k - 1) = temp\n         \
    \               k -= 1\n                    }\n                }\n           \
    \ }\n            i += 1\n        }\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2zx6258d.scala:34:24 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                        arr(k) = arr(k - \e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                        ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp2zx6258d.scala:35:24 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                        arr(k - \e[31m1\e[0m) = temp\n\
    \e[31m\e[31m   |\e[0m                        ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009103
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        var i = 0\n\
    \        while (i < n - 1) {\n            if (arr(i) > arr(i + 1)) {\n       \
    \         val temp = arr(i)\n                arr(i) = arr(i + 1)\n           \
    \     arr(i + 1) = temp\n                return true\n            }\n        \
    \    i += 1\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp90tg_wac.scala:27:16 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                arr(i) = arr(i + \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a\
    \ member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp90tg_wac.scala:28:16 ------------------------\e[0m\e[0m\n\
    \e[31m28 |\e[0m                arr(i + \e[31m1\e[0m) = temp\n\e[31m\e[31m   |\e\
    [0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of\
    \ List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        val maxIndex = arr.indexOf(max)\n        val\
    \ minIndex = arr.indexOf(min)\n        if (maxIndex == n - 1) {\n            if\
    \ (minIndex == 0) {\n                return true\n            } else {\n     \
    \           return false\n            }\n        } else {\n            if (minIndex\
    \ == 0) {\n                return true\n            } else {\n               \
    \ return false\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp0bp6cdn.scala:42)\n\tat Problem.main(tmpp0bp6cdn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr2 =\
    \ arr.toArray\n        for (i <- 0 until n) {\n            val temp = arr2(i)\n\
    \            arr2(i) = arr2(i + 1)\n            arr2(i + 1) = temp\n         \
    \   if (arr2.sorted == arr2) return true\n            arr2(i + 1) = arr2(i)\n\
    \            arr2(i) = temp\n        }\n        false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length\
    \ 5\n\tat Problem$.moveOneBall$$anonfun$1(tmp2g2decu0.scala:26)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall(tmp2g2decu0.scala:31)\n\
    \tat Problem$.main(tmp2g2decu0.scala:35)\n\tat Problem.main(tmp2g2decu0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        for (i <- 0 until n) {\n            val newArr = arr.slice(i,\
    \ n) ++ arr.slice(0, i)\n            if (newArr == sorted) return true\n     \
    \   }\n        return false\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbsjidrd4.scala:35)\n\tat Problem.main(tmpbsjidrd4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009113
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.toArray\n        var i = 0\n        while\
    \ (i < n - 1) {\n            if (arr2(i) > arr2(i + 1)) {\n                var\
    \ j = i + 1\n                while (j < n && arr2(j) < arr2(i)) j += 1\n     \
    \           if (j == n) return false\n                else {\n               \
    \     val temp = arr2(j)\n                    for (k <- j - 1 to i by -1) arr2(k\
    \ + 1) = arr2(k)\n                    arr2(i) = temp\n                }\n    \
    \        }\n            i += 1\n        }\n        true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp627acngf.scala:42)\n\tat Problem.main(tmp627acngf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        var i = 0\n        while (i < n) {\n            if (arr(i)\
    \ != sorted(i)) {\n                var j = i + 1\n                while (j < n\
    \ && arr(j) != sorted(i)) j += 1\n                if (j == n) return false\n \
    \               while (j > i) {\n                    val temp = arr(j)\n     \
    \               arr(j) = arr(j - 1)\n                    arr(j - 1) = temp\n \
    \                   j -= 1\n                }\n            }\n            i +=\
    \ 1\n        }\n        true\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0rkb2517.scala:32:20 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    arr(j) = arr(j - \e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update\
    \ is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp0rkb2517.scala:33:20 ------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m                    arr(j - \e[31m1\e[0m) = temp\n\e[31m\e\
    [31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009113
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val max = arr.max\n        val min = arr.min\n        if\
    \ (max - min > 1) return false\n        if (max == min) return true\n        val\
    \ maxIndex = arr.indexOf(max)\n        val minIndex = arr.indexOf(min)\n     \
    \   if (maxIndex == n - 1) return true\n        if (minIndex == 0) return true\n\
    \        if (maxIndex == minIndex + 1) return true\n        if (maxIndex == minIndex\
    \ - 1) return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc7iq4s3t.scala:37)\n\tat Problem.main(tmpc7iq4s3t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009115
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val a = arr.toArray\n        val b = new Array[Long](n)\n\
    \        for (i <- 0 until n) {\n            b(i) = a(i)\n        }\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until n) {\n                if (b(j)\
    \ == i) {\n                    a(i) = j\n                    b(j) = -1\n     \
    \           }\n            }\n        }\n        for (i <- 0 until n - 1) {\n\
    \            if (a(i) > a(i + 1)) return false\n        }\n        true\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8z3una09.scala:43)\n\tat Problem.main(tmp8z3una09.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009115
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if (arr.length == 0) return true\n    \
    \    val arr2 = arr.toArray\n        val n = arr2.length\n        var i = 0\n\
    \        while (i < n) {\n            if (i == n - 1) return true\n          \
    \  if (arr2(i) > arr2(i + 1)) {\n                var j = i + 1\n             \
    \   while (j < n && arr2(j) < arr2(i)) j += 1\n                if (j == n) return\
    \ false\n                val temp = arr2(j)\n                for (k <- j to i\
    \ by -1) arr2(k) = arr2(k - 1)\n                arr2(i) = temp\n            }\n\
    \            i += 1\n        }\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1agttfzb.scala:41)\n\tat Problem.main(tmp1agttfzb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        if (max - min > n) return false\n        val\
    \ count = Array.fill(n)(0)\n        for (i <- 0 until n) {\n            count(arr(i).toInt\
    \ - 1) += 1\n        }\n        var maxCount = 0\n        for (i <- 0 until n)\
    \ {\n            maxCount = max(maxCount, count(i))\n        }\n        return\
    \ maxCount <= n / 2 + 1\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpa8thjtjc.scala:32:23 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            maxCount = max(maxCount, count(i))\n\e[31m\e\
    [31m   |\e[0m                       ^^^\e[0m\n\e[31m   |\e[0m                \
    \       \e[33mvalue\e[0m \e[35mmax\e[0m does not take parameters\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009112
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.max\n\
    \        val min = arr.min\n        val minIndex = arr.indexOf(min)\n        val\
    \ maxIndex = arr.indexOf(m)\n        if (minIndex == 0 && maxIndex == n - 1) return\
    \ true\n        if (minIndex == 0 && maxIndex == n - 2) return true\n        if\
    \ (minIndex == 1 && maxIndex == n - 1) return true\n        return false\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdhyvkqs0.scala:33)\n\tat Problem.main(tmpdhyvkqs0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009115
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val sorted = arr.sorted\n        val min\
    \ = sorted.head\n        val max = sorted.last\n        val minIndex = arr.indexOf(min)\n\
    \        val maxIndex = arr.indexOf(max)\n        if (minIndex == 0) {\n     \
    \       if (maxIndex == arr.length - 1) {\n                return true\n     \
    \       } else {\n                return false\n            }\n        } else\
    \ {\n            if (maxIndex == arr.length - 1) {\n                return false\n\
    \            } else {\n                return true\n            }\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg4tyotem.scala:44)\n\tat Problem.main(tmpg4tyotem.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009116
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if (arr.length == 0) return true\n    \
    \    val sorted = arr.sorted\n        val diff = arr.zip(sorted).map(x => x._1\
    \ - x._2)\n        val diff2 = diff.zipWithIndex.map(x => (x._1, x._2 + 1)).filter(x\
    \ => x._1 != 0)\n        if (diff2.length == 0) return true\n        val maxDiff\
    \ = diff2.maxBy(x => x._1)\n        val maxDiffIndex = maxDiff._2\n        val\
    \ maxDiffValue = maxDiff._1\n        val maxDiffIndex2 = diff2.filter(x => x._1\
    \ == maxDiffValue).map(x => x._2).max\n        if (maxDiffIndex2 == maxDiffIndex)\
    \ return false\n        val maxDiffIndex3 = diff2.filter(x => x._1 == maxDiffValue).map(x\
    \ => x._2).min\n        val maxDiffIndex4 = diff2.filter(x => x._1 == maxDiffValue).map(x\
    \ => x._2).max\n        if (maxDiffIndex4 - maxDiffIndex3 + 1 == maxDiffValue)\
    \ return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb_f1v82c.scala:38)\n\tat Problem.main(tmpb_f1v82c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009116
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr2 =\
    \ arr.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr3 = Array.fill(n)(0)\n\
    \        for (i <- 0 until n) {\n            arr3(arr2(i)) = i\n        }\n  \
    \      val arr4 = Array.fill(n)(0)\n        for (i <- 0 until n) {\n         \
    \   arr4(i) = arr3(i) - i\n        }\n        val arr5 = arr4.sorted\n       \
    \ for (i <- 0 until n) {\n            if (arr4(i) != arr5(i)) return false\n \
    \       }\n        true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbyu53zhf.scala:39)\n\tat Problem.main(tmpbyu53zhf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009116
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val sorted = arr.sorted\n        val diff = new Array[Long](n)\n\
    \        for (i <- 0 until n) diff(i) = sorted(i) - arr(i)\n        val max =\
    \ diff.max\n        val min = diff.min\n        if (max == 0) return true\n  \
    \      if (min < 0) return false\n        val maxIndex = diff.indexOf(max)\n \
    \       val minIndex = diff.indexOf(min)\n        if (maxIndex == 0) return true\n\
    \        if (minIndex == n - 1) return true\n        if (maxIndex < minIndex)\
    \ return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf7jsqjr3.scala:39)\n\tat Problem.main(tmpf7jsqjr3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009116
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        val diff = arr.zip(sorted).map(x => x._1 - x._2).toArray\n\
    \        val diffSum = diff.sum\n        if (diffSum == 0) return true\n     \
    \   if (diffSum < 0) return false\n        val diffMax = diff.max\n        val\
    \ diffMin = diff.min\n        if (diffMax > 0 && diffMin < 0) return false\n \
    \       if (diffMax > 0) {\n            val diffMaxCount = diff.count(_ == diffMax)\n\
    \            if (diffMaxCount == 1) return true\n            if (diffMaxCount\
    \ == n) return false\n            if (diffMaxCount == n - 1) {\n             \
    \   val diffMinCount = diff.count(_ == diffMin)\n                if (diffMinCount\
    \ == 1) return true\n                if (diffMinCount == n - 1) return false\n\
    \            }\n        }\n        if (diffMin < 0) {\n            val diffMinCount\
    \ = diff.count(_ == diffMin)\n            if (diffMinCount == 1) return true\n\
    \            if (diffMinCount == n) return false\n            if (diffMinCount\
    \ == n - 1) {\n                val diffMaxCount = diff.count(_ == diffMax)\n \
    \               if (diffMaxCount == 1) return true\n                if (diffMaxCount\
    \ == n - 1) return false\n            }\n        }\n        return false\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn6urh5sy.scala:56)\n\tat Problem.main(tmpn6urh5sy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009116
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val sorted = arr.sorted\n        val diff = arr.zip(sorted).map(x\
    \ => x._1 - x._2).toArray\n        val max = diff.max\n        val min = diff.min\n\
    \        if (max - min > 1) return false\n        if (max == min) return true\n\
    \        val maxIndex = diff.indexOf(max)\n        val minIndex = diff.indexOf(min)\n\
    \        if (maxIndex == 0) {\n            if (minIndex == n - 1) return true\n\
    \            else return false\n        }\n        if (minIndex == 0) {\n    \
    \        if (maxIndex == n - 1) return true\n            else return false\n \
    \       }\n        if (maxIndex == n - 1) {\n            if (minIndex == 0) return\
    \ true\n            else return false\n        }\n        if (minIndex == n -\
    \ 1) {\n            if (maxIndex == 0) return true\n            else return false\n\
    \        }\n        return true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp64d9g789.scala:51)\n\tat Problem.main(tmp64d9g789.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009116
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        val diff = arr.zip(sorted).map(x => x._1 - x._2).toArray\n\
    \        val dp = Array.fill(n)(0)\n        for (i <- 0 until n) {\n         \
    \   var j = i\n            while (j < n && diff(j) == 0) j += 1\n            if\
    \ (j == n) return true\n            if (diff(j) > 0) return false\n          \
    \  dp(i) = j - i\n        }\n        for (i <- 0 until n) {\n            var j\
    \ = i\n            while (j < n && dp(j) > 0) j += dp(j)\n            if (j ==\
    \ n) return true\n        }\n        false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3_uk96vp.scala:41)\n\tat Problem.main(tmp3_uk96vp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009116
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr2 =\
    \ arr.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr3 = arr2.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr4 = arr3.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr5\
    \ = arr4.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr6 = arr5.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr7 = arr6.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr8\
    \ = arr7.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr9 = arr8.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr10 = arr9.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr11\
    \ = arr10.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr12 = arr11.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr13 = arr12.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr14\
    \ = arr13.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr15 = arr14.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr16 = arr15.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr17\
    \ = arr16.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr18 = arr17.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr19 = arr18.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr20\
    \ = arr19.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr21 = arr20.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr22 = arr21.zipWithIndex.sortBy(_._1).map(_._2)\n\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphio6tj3u.scala:45:5\
    \ ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009115
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr2 =\
    \ arr.toArray\n        for (i <- 0 until n) {\n            val temp = arr2(i)\n\
    \            arr2(i) = arr2(n - 1)\n            arr2(n - 1) = temp\n         \
    \   if (arr2.sorted.sameElements(arr2)) return true\n            arr2(n - 1) =\
    \ arr2(i)\n            arr2(i) = temp\n        }\n        false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8tqx0te4.scala:35)\n\tat Problem.main(tmp8tqx0te4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009116
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.toArray\n        var i = 0\n        while\
    \ (i < n - 1) {\n            if (arr2(i) > arr2(i + 1)) {\n                var\
    \ j = i + 1\n                while (j < n && arr2(j) < arr2(i)) j += 1\n     \
    \           if (j == n) return false\n                else {\n               \
    \     val temp = arr2(j)\n                    for (k <- j - 1 to i by -1) arr2(k\
    \ + 1) = arr2(k)\n                    arr2(i) = temp\n                }\n    \
    \        }\n            i += 1\n        }\n        true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp627acngf.scala:42)\n\tat Problem.main(tmp627acngf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009115
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr2 =\
    \ arr.toArray\n        var i = 0\n        while (i < n) {\n            if (i +\
    \ 1 < n && arr2(i) > arr2(i + 1)) {\n                val temp = arr2(i)\n    \
    \            arr2(i) = arr2(i + 1)\n                arr2(i + 1) = temp\n     \
    \           i += 2\n            } else i += 1\n        }\n        for (i <- 0\
    \ until n - 1) {\n            if (arr2(i) > arr2(i + 1)) return false\n      \
    \  }\n        true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3047ocp.scala:39)\n\tat Problem.main(tmpf3047ocp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009116
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val max = arr.max\n        val min = arr.min\n        if\
    \ (max - min > 1) return false\n        val count = arr.count(_ == max)\n    \
    \    if (count == n) return true\n        if (count == 1) return true\n      \
    \  if (count == n - 1) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5hbfhm_y.scala:34)\n\tat Problem.main(tmp5hbfhm_y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009116
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        for (i <- 0 until n) {\n            val shifted = arr.slice(i,\
    \ n) ++ arr.slice(0, i)\n            if (shifted == sorted) return true\n    \
    \    }\n        return false\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjqpjtog8.scala:35)\n\tat Problem.main(tmpjqpjtog8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009116
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if (arr.length == 0) return true\n    \
    \    var max = arr(0)\n        for (i <- 1 until arr.length) {\n            if\
    \ (arr(i) < max) return false\n            else max = arr(i)\n        }\n    \
    \    return true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkv4zjakk.scala:31)\n\tat Problem.main(tmpkv4zjakk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009116
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        if (max - min > 1) return false\n        if\
    \ (max == min) return true\n        val maxIndex = arr.indexOf(max)\n        val\
    \ minIndex = arr.indexOf(min)\n        if (maxIndex == 0) return true\n      \
    \  if (minIndex == n - 1) return true\n        if (maxIndex == n - 1) return false\n\
    \        if (minIndex == 0) return false\n        if (maxIndex > minIndex) return\
    \ true\n        return false\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcv2d9f8n.scala:37)\n\tat Problem.main(tmpcv2d9f8n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009116
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val a = arr.toArray\n        val b = new Array[Long](n)\n\
    \        for (i <- 0 until n) b(i) = a(i)\n        for (i <- 0 until n) {\n  \
    \          val j = (i + 1) % n\n            if (a(i) > a(j)) {\n             \
    \   b(i) = a(j)\n                b(j) = a(i)\n                for (k <- 0 until\
    \ n) a(k) = b(k)\n                return true\n            }\n        }\n    \
    \    return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7t8y4x97.scala:41)\n\tat Problem.main(tmp7t8y4x97.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009116
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val sorted = arr.sorted\n        var i = 0\n        while\
    \ (i < n) {\n            if (arr(i) != sorted(i)) {\n                val j = arr.indexOf(sorted(i))\n\
    \                val k = arr.indexOf(sorted(i + 1))\n                if (j ==\
    \ k - 1) {\n                    val temp = arr(j)\n                    arr(j)\
    \ = arr(j + 1)\n                    arr(j + 1) = temp\n                } else\
    \ {\n                    val temp = arr(j)\n                    arr(j) = arr(j\
    \ - 1)\n                    arr(j - 1) = temp\n                }\n           \
    \     return arr == sorted\n            }\n            i += 1\n        }\n   \
    \     true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaad82h_y.scala:32:20 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    arr(j) = arr(j + \e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update\
    \ is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpaad82h_y.scala:33:20 ------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m                    arr(j + \e[31m1\e[0m) = temp\n\e[31m\e\
    [31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpaad82h_y.scala:36:20 ------------------------\e[0m\e[0m\n\
    \e[31m36 |\e[0m                    arr(j) = arr(j - \e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not a\
    \ member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpaad82h_y.scala:37:20 ------------------------\e[0m\e[0m\n\
    \e[31m37 |\e[0m                    arr(j - \e[31m1\e[0m) = temp\n\e[31m\e[31m\
    \   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not a\
    \ member of List[Long] - did you mean arr.updated?\n4 errors found\n"
  stdout: ''
  timestamp: 1660009123
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val sorted = arr.sorted\n        val diff = new Array[Int](n)\n\
    \        for (i <- 0 until n) {\n            diff(i) = arr.indexOf(sorted(i))\
    \ - i\n        }\n        val gcd = diff.foldLeft(diff(0))((a, b) => gcd(a, b))\n\
    \        if (gcd == 0) return true\n        for (i <- 0 until n) {\n         \
    \   if (diff(i) % gcd != 0) return false\n        }\n        return true\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgvfwrwyz.scala:29:51 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mgcd\e[0m = diff.foldLeft(diff(\e\
    [31m0\e[0m))((\e[36ma\e[0m, \e[36mb\e[0m) => gcd(a, b))\n\e[31m\e[31m   |\e[0m\
    \                                                   ^\e[0m\n\e[31m   |\e[0m  \
    \                                        Recursive \e[33mvalue\e[0m \e[35mgcd\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009120
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if (arr.length == 0) return true\n    \
    \    var min = arr(0)\n        for (i <- 1 until arr.length) {\n            if\
    \ (arr(i) < min) return false\n            min = min min arr(i)\n        }\n \
    \       return true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2dabgnzz.scala:31)\n\tat Problem.main(tmp2dabgnzz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009124
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.toArray\n        var i = 0\n        while\
    \ (i < n) {\n            if (i < n - 1 && arr2(i) > arr2(i + 1)) {\n         \
    \       var j = i + 1\n                while (j < n && arr2(j) < arr2(j - 1))\
    \ {\n                    val temp = arr2(j)\n                    arr2(j) = arr2(j\
    \ - 1)\n                    arr2(j - 1) = temp\n                    j += 1\n \
    \               }\n                return true\n            }\n            i +=\
    \ 1\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4dha4urf.scala:44)\n\tat Problem.main(tmp4dha4urf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009126
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.toArray\n        val arr3 = new Array[Long](n)\n\
    \        for (i <- 0 until n) {\n            arr3(i) = arr2(i)\n        }\n  \
    \      scala.util.Sorting.quickSort(arr2)\n        for (i <- 0 until n) {\n  \
    \          if (arr2(i) != arr3(i)) {\n                val j = arr3.indexOf(arr2(i))\n\
    \                val temp = arr3(i)\n                arr3(i) = arr3(j)\n     \
    \           arr3(j) = temp\n                break\n            }\n        }\n\
    \        for (i <- 0 until n) {\n            if (arr2(i) != arr3(i)) return false\n\
    \        }\n        return true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvwoecaxf.scala:36:16 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009122
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        if (max == min) return true\n        val maxIndex\
    \ = arr.indexOf(max)\n        val minIndex = arr.indexOf(min)\n        if (maxIndex\
    \ == n - 1 && minIndex == 0) return false\n        if (maxIndex == n - 1) return\
    \ true\n        if (minIndex == 0) return true\n        if (maxIndex == minIndex\
    \ + 1) return true\n        if (maxIndex == minIndex - 1) return true\n      \
    \  return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.moveOneBall(tmp0s07emai.scala:23)\n\tat Problem$.main(tmp0s07emai.scala:40)\n\
    \tat Problem.main(tmp0s07emai.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009127
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        val maxIndex = arr.indexOf(max)\n        val\
    \ minIndex = arr.indexOf(min)\n        if (maxIndex == 0) {\n            if (minIndex\
    \ == n - 1) {\n                return true\n            } else {\n           \
    \     return false\n            }\n        } else {\n            if (minIndex\
    \ == n - 1) {\n                return false\n            } else {\n          \
    \      return true\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg2k1sgrw.scala:45)\n\tat Problem.main(tmpg2k1sgrw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009127
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.toArray\n        val arr3 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr2(i) = arr(n - 1 - i)\n      \
    \  }\n        for (i <- 0 until n) {\n            arr3(i) = arr2(n - 1 - i)\n\
    \        }\n        val arr4 = arr.toArray\n        for (i <- 0 until n) {\n \
    \           arr4(i) = arr3(n - 1 - i)\n        }\n        val arr5 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr5(i) = arr4(n - 1 - i)\n     \
    \   }\n        val arr6 = arr.toArray\n        for (i <- 0 until n) {\n      \
    \      arr6(i) = arr5(n - 1 - i)\n        }\n        val arr7 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr7(i) = arr6(n - 1 - i)\n     \
    \   }\n        val arr8 = arr.toArray\n        for (i <- 0 until n) {\n      \
    \      arr8(i) = arr7(n - 1 - i)\n        }\n        val arr9 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr9(i) = arr8(n - 1 - i)\n     \
    \   }\n        val arr10 = arr.toArray\n        for (i <- 0 until n) {\n     \
    \       arr10(i) = arr9(n - 1 - i)\n        }\n        val arr11 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr11(i) = arr10(n - 1 - i)\n   \
    \     }\n        val arr12 = arr.toArray\n        for (i <- 0 until n) {\n   \
    \         arr12(i) = arr11(n - 1 - i)\n        }\n        val arr13 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr13(i) = arr12(n - 1 - i)\n   \
    \     }\n        val\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpps_9tlyz.scala:72:11 ---------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m        \e[33mval\e[0m\n\e[31m\e[31m   |\e[0m       \
    \    ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpps_9tlyz.scala:73:5 ---------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009126
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val dp = Array.fill(n)(0)\n        for (i <- 1 until n)\
    \ {\n            if (arr(i) > arr(i - 1)) dp(i) = dp(i - 1) + 1\n            else\
    \ dp(i) = dp(i - 1)\n        }\n        val max = dp.max\n        if (max == n\
    \ - 1) return true\n        val min = dp.min\n        if (min == 0) return false\n\
    \        for (i <- 0 until n) {\n            if (dp(i) == min) {\n           \
    \     val newArr = arr.slice(i, n) ++ arr.slice(0, i)\n                if (moveOneBall(newArr))\
    \ return true\n            }\n        }\n        false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwsjszokv.scala:42)\n\tat Problem.main(tmpwsjszokv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009127
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val sorted = arr.sorted\n        var i = 0\n        while\
    \ (i < n) {\n            if (arr(i) != sorted(i)) {\n                if (i ==\
    \ n - 1) return false\n                if (arr(i + 1) == sorted(i)) {\n      \
    \              val temp = arr(i)\n                    arr(i) = arr(i + 1)\n  \
    \                  arr(i + 1) = temp\n                    return true\n      \
    \          }\n                else return false\n            }\n            i\
    \ += 1\n        }\n        true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0titzb8r.scala:31:20 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    arr(i) = arr(i + \e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update\
    \ is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp0titzb8r.scala:32:20 ------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m                    arr(i + \e[31m1\e[0m) = temp\n\e[31m\e\
    [31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009127
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val a = arr.toArray\n\
    \        val b = new Array[Long](n)\n        for (i <- 0 until n) b(i) = a(i)\n\
    \        for (i <- 0 until n) {\n            val x = a(i)\n            val j =\
    \ (i + x) % n\n            b(j) = x\n        }\n        for (i <- 0 until n -\
    \ 1) if (b(i) > b(i + 1)) return false\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp66swu4a6.scala:29:14\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            b(j) = x\n\e[31m\e\
    [31m   |\e[0m              ^\e[0m\n\e[31m   |\e[0m              Found:    (j :\
    \ Long)\n\e[31m   |\e[0m              Required: Int\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009126
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val sorted = arr.sorted\n        var i = 0\n        while\
    \ (i < n) {\n            if (arr(i) != sorted(i)) {\n                if (i ==\
    \ n - 1) return false\n                if (arr(i + 1) == sorted(i)) {\n      \
    \              val temp = arr(i)\n                    arr(i) = arr(i + 1)\n  \
    \                  arr(i + 1) = temp\n                    return true\n      \
    \          }\n                else return false\n            }\n            i\
    \ += 1\n        }\n        true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0titzb8r.scala:31:20 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    arr(i) = arr(i + \e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update\
    \ is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp0titzb8r.scala:32:20 ------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m                    arr(i + \e[31m1\e[0m) = temp\n\e[31m\e\
    [31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009127
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.toArray\n        val arr3 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr2(i) = arr(n - 1 - i)\n      \
    \  }\n        for (i <- 0 until n) {\n            arr3(i) = arr2(n - 1 - i)\n\
    \        }\n        val sorted = arr.sorted\n        val sorted2 = arr2.sorted\n\
    \        val sorted3 = arr3.sorted\n        if (sorted == arr || sorted2 == arr\
    \ || sorted3 == arr) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmptjmvbbhw.scala:35:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mif\e[0m (sorted == arr || sorted2 == arr\
    \ || sorted3 == arr) \e[33mreturn\e[0m \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m\
    \                             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues of types\
    \ Array[Long] and List[Long] cannot be compared with == or !=\n\e[31m\e[31m--\
    \ Error: /tmp/tmptjmvbbhw.scala:35:47 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mif\e[0m (sorted == arr || sorted2 == arr\
    \ || sorted3 == arr) \e[33mreturn\e[0m \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m\
    \                                               ^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mValues of types Array[Long] and List[Long] cannot be compared with ==\
    \ or !=\n2 errors found\n"
  stdout: ''
  timestamp: 1660009127
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.toArray\n        val arr3 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr2(i) = arr(n - 1 - i)\n      \
    \  }\n        for (i <- 0 until n) {\n            arr3(i) = arr2(n - 1 - i)\n\
    \        }\n        val arr4 = arr.toArray\n        for (i <- 0 until n) {\n \
    \           arr4(i) = arr3(n - 1 - i)\n        }\n        val arr5 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr5(i) = arr4(n - 1 - i)\n     \
    \   }\n        val arr6 = arr.toArray\n        for (i <- 0 until n) {\n      \
    \      arr6(i) = arr5(n - 1 - i)\n        }\n        val arr7 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr7(i) = arr6(n - 1 - i)\n     \
    \   }\n        val arr8 = arr.toArray\n        for (i <- 0 until n) {\n      \
    \      arr8(i) = arr7(n - 1 - i)\n        }\n        val arr9 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr9(i) = arr8(n - 1 - i)\n     \
    \   }\n        val arr10 = arr.toArray\n        for (i <- 0 until n) {\n     \
    \       arr10(i) = arr9(n - 1 - i)\n        }\n        val arr11 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr11(i) = arr10(n - 1 - i)\n   \
    \     }\n        val arr12 = arr.toArray\n        for (i <- 0 until n) {\n   \
    \         arr12(i) = arr11(n - 1 - i)\n        }\n        val arr13 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr13(i) = arr12(n - 1 - i)\n   \
    \     }\n        val\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpps_9tlyz.scala:72:11 ---------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m        \e[33mval\e[0m\n\e[31m\e[31m   |\e[0m       \
    \    ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpps_9tlyz.scala:73:5 ---------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009126
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        // We can move one ball at a time.\n  \
    \      // We can move a ball from the left to the right.\n        // We can move\
    \ a ball from the right to the left.\n        // We can move a ball from the left\
    \ to the right and then back to the left.\n        // We can move a ball from\
    \ the right to the left and then back to the right.\n        // We can move a\
    \ ball from the left to the right and then back to the left and then back to the\
    \ right.\n        // We can move a ball from the right to the left and then back\
    \ to the right and then back to the left.\n        // We can move a ball from\
    \ the left to the right and then back to the left and then back to the right and\
    \ then back to the left.\n        // We can move a ball from the right to the\
    \ left and then back to the right and then back to the left and then back to the\
    \ right.\n        // We can move a ball from the left to the right and then back\
    \ to the left and then back to the right and then back to the left and then back\
    \ to the right.\n        // We can move a ball from the right to the left and\
    \ then back to the right and then back to the left and then back to the right\
    \ and then back to the left.\n        // We can move a ball from the left to the\
    \ right and then back to the left and then back to the right and then back to\
    \ the left and then back to the right and then back to the left.\n        // We\
    \ can move a ball from the right to the left and then back to the right and then\
    \ back to the left and then back to the right and then back to the left and then\
    \ back to the right.\n        // We can move a ball from the left to the right\
    \ and then back to the left and then back to the right and then back to the left\
    \ and then back to the right and then back to the left and then back to the right.\n\
    \        // We can move a ball from the right to the left and then back to the\
    \ right and then back to the left and then back to the right and then back to\
    \ the left and then back to the right and then back to the left.\n        // We\
    \ can move a ball from the left to the right and then back to the left and then\
    \ back to the right and then back to the left and then back to the right\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg10lk8vl.scala:21:50\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m    \e[33mdef\e[0m \e[36mmoveOneBall\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mBoolean\e[0m =\
    \ {\n\e[31m\e[31m   |\e[0m                                                  ^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   Unit\n\e[31m   |\e[0m                                                  Required:\
    \ Boolean\n\e[31m22 |\e[0m        \e[34m// We can move one ball at a time.\e[0m\n\
    \e[31m23 |\e[0m        \e[34m// We can move a ball from the left to the right.\e\
    [0m\n\e[31m24 |\e[0m        \e[34m// We can move a ball from the right to the\
    \ left.\e[0m\n\e[31m25 |\e[0m        \e[34m// We can move a ball from the left\
    \ to the right and then back to the left.\e[0m\n\e[31m26 |\e[0m        \e[34m//\
    \ We can move a ball from the right to the left and then back to the right.\e\
    [0m\n\e[31m27 |\e[0m        \e[34m// We can move a ball from the left to the right\
    \ and then back to the left and then back to the right.\e[0m\n\e[31m28 |\e[0m\
    \        \e[34m// We can move a ball from the right to the left and then back\
    \ to the right and then back to the left.\e[0m\n\e[31m29 |\e[0m        \e[34m//\
    \ We can move a ball from the left to the right and then back to the left and\
    \ then back to the right and then back to the left.\e[0m\n\e[31m30 |\e[0m    \
    \    \e[34m// We can move a ball from the right to the left and then back to the\
    \ right and then back to the left and then back to the right.\e[0m\n\e[31m31 |\e\
    [0m        \e[34m// We can move a ball from the left to the right and then back\
    \ to the left and then back to the right and then back to the left and then back\
    \ to the right.\e[0m\n\e[31m32 |\e[0m        \e[34m// We can move a ball from\
    \ the right to the left and then back to the right and then back to the left and\
    \ then back to the right and then back to the left.\e[0m\n\e[31m33 |\e[0m    \
    \    \e[34m// We can move a ball from the left to the right and then back to the\
    \ left and then back to the right and then back to the left and then back to the\
    \ right and then back to the "
  stdout: ''
  timestamp: 1660009126
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.toArray\n        var i = 0\n        while\
    \ (i < n - 1) {\n            if (arr2(i) > arr2(i + 1)) {\n                var\
    \ j = i + 1\n                while (j < n && arr2(j) < arr2(i)) j += 1\n     \
    \           if (j == n) return false\n                var k = j\n            \
    \    while (k > i) {\n                    val temp = arr2(k)\n               \
    \     arr2(k) = arr2(k - 1)\n                    arr2(k - 1) = temp\n        \
    \            k -= 1\n                }\n            }\n            i += 1\n  \
    \      }\n        true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_iz2pp1d.scala:44)\n\tat Problem.main(tmp_iz2pp1d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        val dp = Array.fill(n)(0)\n        for (i <- 0 until n)\
    \ {\n            if (arr(i) == sorted(i)) dp(i) = 1\n        }\n        for (i\
    \ <- 1 until n) {\n            if (dp(i) == 0) {\n                var j = i -\
    \ 1\n                while (j >= 0 && dp(j) == 0) {\n                    j -=\
    \ 1\n                }\n                if (j >= 0) {\n                    dp(j)\
    \ = 0\n                    dp(i) = 1\n                }\n            }\n     \
    \   }\n        dp.sum == n\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7sgkyzt7.scala:43)\n\tat Problem.main(tmp7sgkyzt7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val dp = Array.fill(n)(0)\n        dp(0) = 1\n        for\
    \ (i <- 1 until n) {\n            var max = 0\n            for (j <- 0 until i)\
    \ {\n                if (arr(j) <= arr(i)) {\n                    max = max max\
    \ dp(j)\n                }\n            }\n            dp(i) = max + 1\n     \
    \   }\n        dp(n - 1) == n\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps3se4nsj.scala:38)\n\tat Problem.main(tmps3se4nsj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.toArray\n        var i = n - 1\n       \
    \ while (i > 0 && arr2(i - 1) <= arr2(i)) i -= 1\n        if (i == 0) return false\n\
    \        var j = n - 1\n        while (j > 0 && arr2(j) >= arr2(i - 1)) j -= 1\n\
    \        val temp = arr2(i - 1)\n        arr2(i - 1) = arr2(j)\n        arr2(j)\
    \ = temp\n        j = n - 1\n        while (i < j) {\n            val temp = arr2(i)\n\
    \            arr2(i) = arr2(j)\n            arr2(j) = temp\n            i += 1\n\
    \            j -= 1\n        }\n        for (i <- 0 until n - 1) if (arr2(i) >\
    \ arr2(i + 1)) return false\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp_3k2qwu.scala:45)\n\tat Problem.main(tmpp_3k2qwu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val dp = Array.fill(n)(0)\n\
    \        for (i <- 0 until n) {\n            dp(i) = 1\n            for (j <-\
    \ 0 until i) {\n                if (arr(j) <= arr(i)) {\n                    dp(i)\
    \ = max(dp(i), dp(j) + 1)\n                }\n            }\n        }\n     \
    \   dp.max >= n\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm98v98e_.scala:35)\n\tat Problem.main(tmpm98v98e_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val l = arr.toArray\n        val m = Array.fill(n)(0)\n\
    \        for (i <- 0 until n) {\n            val x = l(i)\n            m(x) =\
    \ i\n        }\n        var i = 0\n        while (i < n) {\n            if (m(i)\
    \ != i) {\n                val x = l(i)\n                l(i) = l(m(i))\n    \
    \            l(m(i)) = x\n                m(x) = m(i)\n                m(i) =\
    \ i\n            }\n            i += 1\n        }\n        for (i <- 0 until n\
    \ - 1) if (l(i) > l(i + 1)) return false\n        true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5fucwkcv.scala:28:14\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            m(x) = i\n\e[31m\e\
    [31m   |\e[0m              ^\e[0m\n\e[31m   |\e[0m              Found:    (x :\
    \ Long)\n\e[31m   |\e[0m              Required: Int\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp5fucwkcv.scala:36:18 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                m(x) = m(i)\n\e[31m\e[31m   |\e[0m  \
    \                ^\e[0m\n\e[31m   |\e[0m                  Found:    (x : Long)\n\
    \e[31m   |\e[0m                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009127
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr2 =\
    \ arr.toArray\n        val arr3 = arr.toArray\n        for (i <- 0 until n) {\n\
    \            arr2(i) = arr(n - 1 - i)\n        }\n        for (i <- 0 until n)\
    \ {\n            arr3(i) = arr2(n - 1 - i)\n        }\n        val arr4 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr4(i) = arr3(n - 1 - i)\n     \
    \   }\n        val arr5 = arr.toArray\n        for (i <- 0 until n) {\n      \
    \      arr5(i) = arr4(n - 1 - i)\n        }\n        val arr6 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr6(i) = arr5(n - 1 - i)\n     \
    \   }\n        val arr7 = arr.toArray\n        for (i <- 0 until n) {\n      \
    \      arr7(i) = arr6(n - 1 - i)\n        }\n        val arr8 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr8(i) = arr7(n - 1 - i)\n     \
    \   }\n        val arr9 = arr.toArray\n        for (i <- 0 until n) {\n      \
    \      arr9(i) = arr8(n - 1 - i)\n        }\n        val arr10 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr10(i) = arr9(n - 1 - i)\n    \
    \    }\n        val arr11 = arr.toArray\n        for (i <- 0 until n) {\n    \
    \        arr11(i) = arr10(n - 1 - i)\n        }\n        val arr12 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr12(i) = arr11(n - 1 - i)\n   \
    \     }\n        val arr13 = arr.toArray\n        for (i <- 0 until n) {\n   \
    \         arr13(i) = arr12(n - 1 - i)\n        }\n        val arr14 = arr.toArray\n\
    \        for\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpyajn99c3.scala:72:11 ---------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m        \e[33mfor\e[0m\n\e[31m\e[31m   |\e[0m       \
    \    ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val min = arr.min\n\
    \        val max = arr.max\n        val minIndex = arr.indexOf(min)\n        val\
    \ maxIndex = arr.indexOf(max)\n        if (minIndex == 0) {\n            if (maxIndex\
    \ == n - 1) {\n                return true\n            } else {\n           \
    \     return false\n            }\n        } else {\n            if (maxIndex\
    \ == n - 1) {\n                return false\n            } else {\n          \
    \      return true\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpln8oyl75.scala:44)\n\tat Problem.main(tmpln8oyl75.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        // We can move a ball if the ball is not\
    \ in the right position.\n        // The ball is in the right position if the\
    \ ball is the smallest ball in the\n        // array.\n        // We can move\
    \ a ball if the ball is not the smallest ball in the array.\n        // We can\
    \ move a ball if the ball is not the largest ball in the array.\n        // We\
    \ can move a ball if the ball is not the smallest ball in the array.\n       \
    \ // We can move a ball if the ball is not the smallest ball in the array.\n \
    \       // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the ball is not the smallest ball in the array.\n\
    \        // We can move a ball if the\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4jime873.scala:21:50\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m    \e[33mdef\e[0m \e[36mmoveOneBall\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mBoolean\e[0m =\
    \ {\n\e[31m\e[31m   |\e[0m                                                  ^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   Unit\n\e[31m   |\e[0m                                                  Required:\
    \ Boolean\n\e[31m22 |\e[0m        \e[34m// We can move a ball if the ball is not\
    \ in the right position.\e[0m\n\e[31m23 |\e[0m        \e[34m// The ball is in\
    \ the right position if the ball is the smallest ball in the\e[0m\n\e[31m24 |\e\
    [0m        \e[34m// array.\e[0m\n\e[31m25 |\e[0m        \e[34m// We can move a\
    \ ball if the ball is not the smallest ball in the array.\e[0m\n\e[31m26 |\e[0m\
    \        \e[34m// We can move a ball if the ball is not the largest ball in the\
    \ array.\e[0m\n\e[31m27 |\e[0m        \e[34m// We can move a ball if the ball\
    \ is not the smallest ball in the array.\e[0m\n\e[31m28 |\e[0m        \e[34m//\
    \ We can move a ball if the ball is not the smallest ball in the array.\e[0m\n\
    \e[31m29 |\e[0m        \e[34m// We can move a ball if the ball is not the smallest\
    \ ball in the array.\e[0m\n\e[31m30 |\e[0m        \e[34m// We can move a ball\
    \ if the ball is not the smallest ball in the array.\e[0m\n\e[31m31 |\e[0m   \
    \     \e[34m// We can move a ball if the ball is not the smallest ball in the\
    \ array.\e[0m\n\e[31m32 |\e[0m        \e[34m// We can move a ball if the ball\
    \ is not the smallest ball in the array.\e[0m\n\e[31m33 |\e[0m        \e[34m//\
    \ We can move a ball if the ball is not the smallest ball in the array.\e[0m\n\
    \e[31m34 |\e[0m        \e[34m// We can move a ball if the ball is not the smallest\
    \ ball in the array.\e[0m\n\e[31m35 |\e[0m        \e[34m// We can move a ball\
    \ if the ball is not the smallest ball in the array.\e[0m\n\e[31m36 |\e[0m   \
    \     \e[34m// We can move a ball if the ball is not the smallest ball in the\
    \ array.\e[0m\n\e[31m37 |\e[0m        \e[34m// We can move a ball if the ball\
    \ is not the smallest ball in the array.\e[0m\n\e[31m38 |\e[0m     "
  stdout: ''
  timestamp: 1660009127
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val sorted = arr.sorted\n        val diff = arr.zip(sorted).map(x\
    \ => x._1 - x._2)\n        val maxDiff = diff.max\n        val minDiff = diff.min\n\
    \        if (maxDiff == 0) return true\n        if (maxDiff - minDiff > 1) return\
    \ false\n        val maxDiffIndex = diff.indexOf(maxDiff)\n        val minDiffIndex\
    \ = diff.indexOf(minDiff)\n        if (maxDiffIndex == 0) return true\n      \
    \  if (minDiffIndex == n - 1) return true\n        if (minDiffIndex == 0) return\
    \ true\n        if (maxDiffIndex == n - 1) return true\n        if (maxDiffIndex\
    \ == minDiffIndex + 1) return true\n        if (minDiffIndex == maxDiffIndex +\
    \ 1) return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp50pqq9hh.scala:41)\n\tat Problem.main(tmp50pqq9hh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sortedArr\
    \ = arr.sorted\n        val diff = new Array[Long](n)\n        for (i <- 0 until\
    \ n) diff(i) = sortedArr(i) - arr(i)\n        val maxDiff = diff.max\n       \
    \ val minDiff = diff.min\n        if (maxDiff == 0) return true\n        if (maxDiff\
    \ == 1 && minDiff == -1) return true\n        if (maxDiff > 1) return false\n\
    \        val maxDiffIndex = diff.indexOf(maxDiff)\n        val minDiffIndex =\
    \ diff.indexOf(minDiff)\n        if (maxDiffIndex == 0) return false\n       \
    \ if (minDiffIndex == n - 1) return false\n        if (maxDiffIndex - minDiffIndex\
    \ == 1) return false\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3xl_9hhc.scala:39)\n\tat Problem.main(tmp3xl_9hhc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009133
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val dp = Array.fill(n)(0)\n\
    \        for (i <- 0 until n) {\n            var j = i\n            while (j <\
    \ n) {\n                if (arr(j) >= arr(i)) {\n                    dp(i) = max(dp(i),\
    \ j - i + 1)\n                }\n                j += 1\n            }\n     \
    \   }\n        for (i <- 0 until n) {\n            if (dp(i) == n - i) return\
    \ true\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphv9wncin.scala:41)\n\tat Problem.main(tmphv9wncin.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009135
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if (arr.length == 0) return true\n    \
    \    val sorted = arr.sorted\n        val min = sorted.head\n        val max =\
    \ sorted.last\n        val minIndex = arr.indexOf(min)\n        val maxIndex =\
    \ arr.indexOf(max)\n        if (minIndex == 0) return true\n        if (maxIndex\
    \ == arr.length - 1) return true\n        if (minIndex == maxIndex) return true\n\
    \        if (minIndex > maxIndex) return true\n        if (minIndex < maxIndex)\
    \ {\n            val sub = arr.slice(minIndex, maxIndex + 1)\n            if (sub.sorted\
    \ == sub) return true\n        }\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpij7mm8q7.scala:41)\n\tat Problem.main(tmpij7mm8q7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009135
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val dp = Array.fill(n)(false)\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        if (i != j) {\n                    if (arr(i) > arr(j)) {\n         \
    \               if (dp(j) == false) {\n                            dp(i) = true\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n        dp.forall(x => x == true)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg1m5vxnf.scala:38)\n\tat Problem.main(tmpg1m5vxnf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009137
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr2 =\
    \ arr.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr3 = arr2.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr4 = arr3.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr5\
    \ = arr4.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr6 = arr5.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr7 = arr6.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr8\
    \ = arr7.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr9 = arr8.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr10 = arr9.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr11\
    \ = arr10.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr12 = arr11.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr13 = arr12.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr14\
    \ = arr13.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr15 = arr14.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr16 = arr15.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr17\
    \ = arr16.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr18 = arr17.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr19 = arr18.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr20\
    \ = arr19.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr21 = arr20.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr22 = arr21.zipWithIndex.sortBy(_._1).map(_._2)\n\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphio6tj3u.scala:45:5\
    \ ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009115
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val max = arr.max\n        val min = arr.min\n        if\
    \ (max - min > n) return false\n        val count = Array.fill(n)(0)\n       \
    \ for (i <- 0 until n) {\n            count(arr(i).toInt) += 1\n        }\n  \
    \      var i = 0\n        while (i < n) {\n            if (count(i) == 0) {\n\
    \                i += 1\n            } else if (count(i) == 1) {\n           \
    \     return true\n            } else {\n                return false\n      \
    \      }\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length\
    \ 5\n\tat Problem$.moveOneBall$$anonfun$1(tmpmodba5cz.scala:29)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall(tmpmodba5cz.scala:30)\n\
    \tat Problem$.main(tmpmodba5cz.scala:44)\n\tat Problem.main(tmpmodba5cz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009137
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.zipWithIndex.sortBy(_._1).map(_._2)\n  \
    \      val arr3 = Array.fill(n)(0)\n        for (i <- 0 until n) {\n         \
    \   val j = (arr2(i) + 1) % n\n            arr3(j) += 1\n        }\n        arr3.forall(_\
    \ == 1)\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgkk1gm8z.scala:35)\n\tat Problem.main(tmpgkk1gm8z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009137
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val a = arr.toArray\n\
    \        for (i <- 0 until n) {\n            val j = (i + 1) % n\n           \
    \ if (a(i) > a(j)) {\n                val temp = a(i)\n                a(i) =\
    \ a(j)\n                a(j) = temp\n                return true\n           \
    \ }\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzh0h52l2.scala:38)\n\tat Problem.main(tmpzh0h52l2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009138
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        val diff = (0 until n).map(i => sorted(i) - arr(i)).toList\n\
    \        val max = diff.max\n        val min = diff.min\n        if (max == 0)\
    \ return true\n        if (max - min > 1) return false\n        val maxIndex =\
    \ diff.indexOf(max)\n        val minIndex = diff.indexOf(min)\n        if (maxIndex\
    \ == 0) return true\n        if (minIndex == n - 1) return true\n        if (arr(maxIndex\
    \ - 1) < arr(minIndex + 1)) return true\n        return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxuiwsg5e.scala:37)\n\tat Problem.main(tmpxuiwsg5e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.toArray\n        val arr3 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr2(i) = arr(n - 1 - i)\n      \
    \  }\n        for (i <- 0 until n) {\n            arr3(i) = arr2(n - 1 - i)\n\
    \        }\n        val arr4 = arr.toArray\n        for (i <- 0 until n) {\n \
    \           arr4(i) = arr3(n - 1 - i)\n        }\n        val arr5 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr5(i) = arr4(n - 1 - i)\n     \
    \   }\n        val arr6 = arr.toArray\n        for (i <- 0 until n) {\n      \
    \      arr6(i) = arr5(n - 1 - i)\n        }\n        val arr7 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr7(i) = arr6(n - 1 - i)\n     \
    \   }\n        val arr8 = arr.toArray\n        for (i <- 0 until n) {\n      \
    \      arr8(i) = arr7(n - 1 - i)\n        }\n        val arr9 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr9(i) = arr8(n - 1 - i)\n     \
    \   }\n        val arr10 = arr.toArray\n        for (i <- 0 until n) {\n     \
    \       arr10(i) = arr9(n - 1 - i)\n        }\n        val arr11 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr11(i) = arr10(n - 1 - i)\n   \
    \     }\n        val arr12 = arr.toArray\n        for (i <- 0 until n) {\n   \
    \         arr12(i) = arr11(n - 1 - i)\n        }\n        val arr13 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr13(i) = arr12(n - 1 - i)\n   \
    \     }\n        val\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpps_9tlyz.scala:72:11 ---------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m        \e[33mval\e[0m\n\e[31m\e[31m   |\e[0m       \
    \    ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpps_9tlyz.scala:73:5 ---------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009126
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val a = arr.toArray\n        val b = new Array[Long](n)\n\
    \        for (i <- 0 until n) b(i) = a(i)\n        for (i <- 0 until n) {\n  \
    \          val x = a(i)\n            b(i) = -1\n            if (i == 0) {\n  \
    \              if (x > a(i + 1)) return false\n            } else if (i == n -\
    \ 1) {\n                if (x < a(i - 1)) return false\n            } else {\n\
    \                if (x < a(i - 1) || x > a(i + 1)) return false\n            }\n\
    \            b(i) = x\n        }\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoe029g0o.scala:42)\n\tat Problem.main(tmpoe029g0o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009138
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.max\n\
    \        val min = arr.min\n        if (m == min) return true\n        val maxIndex\
    \ = arr.indexOf(m)\n        if (maxIndex == 0) return false\n        val minIndex\
    \ = arr.indexOf(min)\n        if (minIndex == n - 1) return false\n        if\
    \ (maxIndex == n - 1) return true\n        if (minIndex == 0) return true\n  \
    \      return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgfhq2wzd.scala:35)\n\tat Problem.main(tmpgfhq2wzd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009138
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n <= 1)\
    \ return true\n        val dp = Array.fill(n)(0L)\n        dp(0) = arr(0)\n  \
    \      for (i <- 1 until n) {\n            dp(i) = dp(i - 1) + arr(i)\n      \
    \  }\n        val dp2 = Array.fill(n)(0L)\n        dp2(n - 1) = arr(n - 1)\n \
    \       for (i <- n - 2 to 0 by -1) {\n            dp2(i) = dp2(i + 1) + arr(i)\n\
    \        }\n        for (i <- 0 until n - 1) {\n            if (dp(i) > dp2(i\
    \ + 1)) return false\n        }\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcoholeri.scala:40)\n\tat Problem.main(tmpcoholeri.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        val map = new HashMap[Long, Int]\n        for (i <- 0\
    \ until n) {\n            map(arr(i)) = i\n        }\n        for (i <- 0 until\
    \ n) {\n            if (arr(i) != sorted(i)) {\n                val j = map(sorted(i))\n\
    \                if (j == 0) return false\n                map(arr(i)) = j - 1\n\
    \                map(arr(j - 1)) = i\n                val temp = arr(i)\n    \
    \            arr(i) = arr(j - 1)\n                arr(j - 1) = temp\n        \
    \    }\n        }\n        true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo3kx6n9i.scala:35:16 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                arr(i) = arr(j - \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a\
    \ member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpo3kx6n9i.scala:36:16 ------------------------\e[0m\e[0m\n\
    \e[31m36 |\e[0m                arr(j - \e[31m1\e[0m) = temp\n\e[31m\e[31m   |\e\
    [0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of\
    \ List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        if (n == 0) return true\n        if (n ==\
    \ 1) return true\n        if (n == 2) return true\n        if (n == 3) {\n   \
    \         if (arr(0) < arr(1) && arr(1) < arr(2)) return true\n            else\
    \ return false\n        }\n        if (max == min) return true\n        val maxIndex\
    \ = arr.indexOf(max)\n        val minIndex = arr.indexOf(min)\n        if (maxIndex\
    \ == 0) {\n            if (arr(1) < max) return true\n            else return\
    \ false\n        }\n        if (maxIndex == n - 1) {\n            if (arr(n -\
    \ 2) < max) return true\n            else return false\n        }\n        if\
    \ (minIndex == 0) {\n            if (min < arr(1)) return true\n            else\
    \ return false\n        }\n        if (minIndex == n - 1) {\n            if (min\
    \ < arr(n - 2)) return true\n            else return false\n        }\n      \
    \  if (maxIndex == 1) {\n            if (max < arr(2)) return true\n         \
    \   else return false\n        }\n        if (maxIndex == n - 2) {\n         \
    \   if (max < arr(n - 3)) return true\n            else return false\n       \
    \ }\n        if (minIndex == 1) {\n            if (arr(0) < min) return true\n\
    \            else return false\n        }\n        if (minIndex == n - 2) {\n\
    \            if (arr(n - 1) < min) return true\n            else return false\n\
    \        }\n        if (maxIndex == 2) {\n            if (max < arr(3)) return\
    \ true\n            else return false\n        }\n        if (maxIndex == n -\
    \ 3) {\n            if (max < arr(n - 4)) return true\n            else return\
    \ false\n        }\n        if (minIndex == 2) {\n            if (arr(0) < min\
    \ && min < arr(3)) return true\n            else return false\n        }\n   \
    \     if (minIndex == n - 3) {\n            if (arr(n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpowg04mgj.scala:81:4 ----------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpowg04mgj.scala:91:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m91 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpowg04mgj.scala:80:19 --------------------\e[0m\e[0m\n\
    \e[31m80 |\e[0m            \e[33mif\e[0m (arr(n\n\e[31m\e[31m   |\e[0m       \
    \         ^^^^^\e[0m\n\e[31m   |\e[0m                Found:    Long\n\e[31m  \
    \ |\e[0m                Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpowg04mgj.scala:90:1 ---------------------\e[0m\e\
    [0m\n\e[31m90 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:  \
    \  Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpowg04mgj.scala:82:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m82 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009138
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        if (max - min > 1) return false\n        if\
    \ (max == min) return true\n        val maxIndex = arr.indexOf(max)\n        val\
    \ minIndex = arr.indexOf(min)\n        if (maxIndex == n - 1 && minIndex == 0)\
    \ return true\n        if (maxIndex == n - 1) return moveOneBall(arr.slice(0,\
    \ n - 1))\n        if (minIndex == 0) return moveOneBall(arr.slice(1, n))\n  \
    \      moveOneBall(arr.slice(0, minIndex)) && moveOneBall(arr.slice(minIndex +\
    \ 1, n))\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpebh290sh.scala:35)\n\tat Problem.main(tmpebh290sh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr2 =\
    \ arr.toArray\n        val arr3 = arr.toArray\n        for (i <- 0 until n) {\n\
    \            arr2(i) = arr(n - 1 - i)\n        }\n        for (i <- 0 until n)\
    \ {\n            arr3(i) = arr2(n - 1 - i)\n        }\n        val arr4 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr4(i) = arr3(n - 1 - i)\n     \
    \   }\n        val arr5 = arr.toArray\n        for (i <- 0 until n) {\n      \
    \      arr5(i) = arr4(n - 1 - i)\n        }\n        val arr6 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr6(i) = arr5(n - 1 - i)\n     \
    \   }\n        val arr7 = arr.toArray\n        for (i <- 0 until n) {\n      \
    \      arr7(i) = arr6(n - 1 - i)\n        }\n        val arr8 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr8(i) = arr7(n - 1 - i)\n     \
    \   }\n        val arr9 = arr.toArray\n        for (i <- 0 until n) {\n      \
    \      arr9(i) = arr8(n - 1 - i)\n        }\n        val arr10 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr10(i) = arr9(n - 1 - i)\n    \
    \    }\n        val arr11 = arr.toArray\n        for (i <- 0 until n) {\n    \
    \        arr11(i) = arr10(n - 1 - i)\n        }\n        val arr12 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr12(i) = arr11(n - 1 - i)\n   \
    \     }\n        val arr13 = arr.toArray\n        for (i <- 0 until n) {\n   \
    \         arr13(i) = arr12(n - 1 - i)\n        }\n        val arr14 = arr.toArray\n\
    \        for\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpyajn99c3.scala:72:11 ---------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m        \e[33mfor\e[0m\n\e[31m\e[31m   |\e[0m       \
    \    ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val sorted = arr.sorted\n        val sortedReverse\
    \ = arr.sorted.reverse\n        val sortedReverseShift = sortedReverse.tail :+\
    \ sortedReverse.head\n        if (arr == sorted || arr == sortedReverse || arr\
    \ == sortedReverseShift) return true\n        else return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjcw6x7oy.scala:29)\n\tat Problem.main(tmpjcw6x7oy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        for (i <- 0 until n) {\n            if (arr(i) != sorted(i))\
    \ {\n                val j = (i + 1) % n\n                if (arr(j) == sorted(i))\
    \ {\n                    val temp = arr(i)\n                    arr(i) = arr(j)\n\
    \                    arr(j) = temp\n                    return true\n        \
    \        }\n            }\n        }\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqxau_910.scala:29:20 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    arr(i) = arr(j)\n\e[31m\e[31m   |\e\
    [0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpqxau_910.scala:30:20 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m                    arr(j) = temp\n\e[31m\e[31m   |\e[0m                  \
    \  ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long] - did\
    \ you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009138
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.sorted\n        var i = 0\n        while\
    \ (i < n) {\n            if (arr(i) != arr2(i)) {\n                val j = arr.indexOf(arr2(i))\n\
    \                val arr3 = arr.take(j) ++ arr.drop(j + 1) ++ List(arr(j))\n \
    \               if (arr3 == arr2) return true\n                else return false\n\
    \            }\n            i += 1\n        }\n        return true\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvcify01_.scala:38)\n\tat Problem.main(tmpvcify01_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009138
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val dp = Array.fill(n)(0)\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until i) {\n        \
    \        if (arr(j) <= arr(i)) dp(i) = max(dp(i), dp(j) + 1)\n            }\n\
    \        }\n        dp.max >= n - 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppcjehm8_.scala:32)\n\tat Problem.main(tmppcjehm8_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009139
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        var max = arr(0)\n        for (i <- 1 until n) {\n    \
    \        if (arr(i) < max) return false\n            max = max max arr(i)\n  \
    \      }\n        return true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpma3kxrxg.scala:32)\n\tat Problem.main(tmpma3kxrxg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009139
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val a = arr.toArray\n\
    \        var i = 0\n        while (i < n - 1) {\n            if (a(i) > a(i +\
    \ 1)) {\n                var j = i + 1\n                while (j < n && a(j) <\
    \ a(j - 1)) {\n                    val temp = a(j)\n                    a(j) =\
    \ a(j - 1)\n                    a(j - 1) = temp\n                    j += 1\n\
    \                }\n                return true\n            }\n            i\
    \ += 1\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbiyetvis.scala:43)\n\tat Problem.main(tmpbiyetvis.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009139
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.toArray\n        var i = 0\n        while\
    \ (i < n) {\n            if (i == n - 1) return true\n            if (arr2(i)\
    \ > arr2(i + 1)) {\n                val temp = arr2(i)\n                arr2(i)\
    \ = arr2(i + 1)\n                arr2(i + 1) = temp\n                return true\n\
    \            }\n            i += 1\n        }\n        return false\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppbcv7xv9.scala:41)\n\tat Problem.main(tmppbcv7xv9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009139
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        var i = 0\n        while (i < n - 1) {\n            if\
    \ (arr(i) > arr(i + 1)) {\n                var j = i + 1\n                while\
    \ (j < n && arr(j) < arr(i)) j += 1\n                if (j == n) return false\n\
    \                var temp = arr(j)\n                for (k <- j - 1 to i by -1)\
    \ arr(k + 1) = arr(k)\n                arr(i) = temp\n            }\n        \
    \    i += 1\n        }\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt0b2h1r6.scala:31:44 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                \e[33mfor\e[0m (k <- j - \e[31m1\e[0m\
    \ to i by -\e[31m1\e[0m) arr(k + \e[31m1\e[0m) = arr(k)\n\e[31m\e[31m   |\e[0m\
    \                                            ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpt0b2h1r6.scala:32:16 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                arr(i) = temp\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009139
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        if (max - min == n - 1) true\n        else\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_610pqof.scala:30)\n\tat Problem.main(tmp_610pqof.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009139
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        val maxIndex = arr.indexOf(max)\n        val\
    \ minIndex = arr.indexOf(min)\n        if (maxIndex == n - 1) {\n            if\
    \ (minIndex == 0) {\n                return false\n            } else {\n    \
    \            return true\n            }\n        } else {\n            if (minIndex\
    \ == 0) {\n                return true\n            } else {\n               \
    \ return false\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpel3ljl71.scala:42)\n\tat Problem.main(tmpel3ljl71.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val max = arr.max\n        val min = arr.min\n        if\
    \ (max - min == n - 1) return true\n        else return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa21kw7xm.scala:31)\n\tat Problem.main(tmpa21kw7xm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr2 =\
    \ arr.toArray\n        val arr3 = new Array[Long](n)\n        for (i <- 0 until\
    \ n) {\n            arr3(i) = arr2(i)\n        }\n        for (i <- 0 until n)\
    \ {\n            arr3(i) = arr2(i)\n            for (j <- 0 until n) {\n     \
    \           if (arr3(j) > arr3(i)) {\n                    val temp = arr3(j)\n\
    \                    arr3(j) = arr3(i)\n                    arr3(i) = temp\n \
    \               }\n            }\n            if (arr3.toList == arr) return true\n\
    \        }\n        return false\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm_wytsfo.scala:42)\n\tat Problem.main(tmpm_wytsfo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009147
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val dp = Array.fill(n)(false)\n\
    \        for (i <- 0 until n) {\n            val x = arr(i)\n            for (j\
    \ <- 0 until n) {\n                if (dp(j) && arr(j) <= x) {\n             \
    \       dp(j) = false\n                    dp(i) = true\n                    return\
    \ true\n                }\n            }\n            dp(i) = true\n        }\n\
    \        return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8n99bd12.scala:40)\n\tat Problem.main(tmp8n99bd12.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009146
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr2 =\
    \ arr.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr3 = arr2.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr4 = arr3.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr5\
    \ = arr4.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr6 = arr5.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr7 = arr6.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr8\
    \ = arr7.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr9 = arr8.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr10 = arr9.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr11\
    \ = arr10.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr12 = arr11.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr13 = arr12.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr14\
    \ = arr13.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr15 = arr14.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr16 = arr15.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr17\
    \ = arr16.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr18 = arr17.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr19 = arr18.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr20\
    \ = arr19.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr21 = arr20.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr22 = arr21.zipWithIndex.sortBy(_._1).map(_._2)\n\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphio6tj3u.scala:45:5\
    \ ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        if (max - min > n) return false\n        val\
    \ count = Array.fill(n)(0)\n        for (i <- 0 until n) {\n            count(arr(i).toInt)\
    \ += 1\n        }\n        var maxCount = 0\n        for (i <- 0 until n) {\n\
    \            maxCount = max(maxCount, count(i))\n        }\n        return maxCount\
    \ <= n / 2 + 1\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp4y0xsd0d.scala:32:23 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            maxCount = max(maxCount, count(i))\n\e[31m\e\
    [31m   |\e[0m                       ^^^\e[0m\n\e[31m   |\e[0m                \
    \       \e[33mvalue\e[0m \e[35mmax\e[0m does not take parameters\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val a = arr.toArray\n\
    \        val b = new Array[Long](n)\n        for (i <- 0 until n) b(i) = a(i)\n\
    \        for (i <- 0 until n) {\n            val x = a(i)\n            var j =\
    \ i\n            while (j > 0 && b(j - 1) > x) {\n                b(j) = b(j -\
    \ 1)\n                j -= 1\n            }\n            b(j) = x\n          \
    \  if (b.toList == arr) return true\n        }\n        false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt5c5p_li.scala:41)\n\tat Problem.main(tmpt5c5p_li.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        if (max == min) return true\n        val maxIndex\
    \ = arr.indexOf(max)\n        val minIndex = arr.indexOf(min)\n        if (maxIndex\
    \ == 0) return false\n        if (minIndex == n - 1) return false\n        if\
    \ (maxIndex < minIndex) return true\n        if (maxIndex == n - 1) return true\n\
    \        if (minIndex == 0) return true\n        if (maxIndex - minIndex == 1)\
    \ return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp91y628om.scala:40)\n\tat Problem.main(tmp91y628om.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.toArray\n        for (i <- 0 until n) {\n\
    \            val temp = arr2(i)\n            arr2(i) = arr2(n - 1)\n         \
    \   arr2(n - 1) = temp\n            if (arr2.sorted == arr2) return true\n   \
    \         arr2(n - 1) = arr2(i)\n            arr2(i) = temp\n        }\n     \
    \   return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxnp_2l3i.scala:36)\n\tat Problem.main(tmpxnp_2l3i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        val diff = new Array[Long](n)\n        for (i <- 0 until\
    \ n) diff(i) = arr(i) - sorted(i)\n        val maxDiff = diff.max\n        var\
    \ maxDiffIndex = -1\n        for (i <- 0 until n) if (diff(i) == maxDiff) maxDiffIndex\
    \ = i\n        var maxDiffIndex2 = -1\n        for (i <- 0 until n) if (i != maxDiffIndex\
    \ && diff(i) == maxDiff) maxDiffIndex2 = i\n        if (maxDiffIndex2 == -1) return\
    \ true\n        var minDiff = Long.MaxValue\n        for (i <- 0 until n) if (i\
    \ != maxDiffIndex && i != maxDiffIndex2 && diff(i) < minDiff) minDiff = diff(i)\n\
    \        if (maxDiff - minDiff > 1) return false\n        return true\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi0aqlntu.scala:38)\n\tat Problem.main(tmpi0aqlntu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        var i = 0\n        while (i < n - 1) {\n            if\
    \ (arr(i) > arr(i + 1)) {\n                val temp = arr(i)\n               \
    \ arr(i) = arr(i + 1)\n                arr(i + 1) = temp\n                return\
    \ true\n            }\n            i += 1\n        }\n        return false\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvo0m09n2.scala:28:16 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                arr(i) = arr(i + \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a\
    \ member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpvo0m09n2.scala:29:16 ------------------------\e[0m\e[0m\n\
    \e[31m29 |\e[0m                arr(i + \e[31m1\e[0m) = temp\n\e[31m\e[31m   |\e\
    [0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of\
    \ List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009148
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        var i = 0\n        while (i < n - 1) {\n            if\
    \ (arr(i) > arr(i + 1)) {\n                var j = i + 1\n                while\
    \ (j < n - 1 && arr(j) > arr(j + 1)) j += 1\n                val temp = arr(j)\n\
    \                for (k <- j to i by -1) arr(k) = arr(k - 1)\n               \
    \ arr(i) = temp\n                return true\n            }\n            i +=\
    \ 1\n        }\n        false\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo8k74krd.scala:30:40 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33mfor\e[0m (k <- j to i by -\e[31m1\e\
    [0m) arr(k) = arr(k - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                   \
    \                     ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpo8k74krd.scala:31:16 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m                arr(i) = temp\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\
    \e[31m   |\e[0m  value update is not a member of List[Long] - did you mean arr.updated?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009148
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val dp = Array.fill(n)(0)\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until i) {\n        \
    \        if (arr(j) <= arr(i)) dp(i) = max(dp(i), dp(j) + 1)\n            }\n\
    \        }\n        dp.max >= n - 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppcjehm8_.scala:32)\n\tat Problem.main(tmppcjehm8_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009139
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr2 =\
    \ arr.toArray\n        val arr3 = arr.toArray\n        for (i <- 0 until n) {\n\
    \            arr2(i) = arr(n - 1 - i)\n        }\n        for (i <- 0 until n)\
    \ {\n            arr3(i) = arr2(n - 1 - i)\n        }\n        for (i <- 0 until\
    \ n) {\n            if (arr(i) != arr2(i) && arr(i) != arr3(i)) return false\n\
    \        }\n        return true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0bs6br69.scala:39)\n\tat Problem.main(tmp0bs6br69.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.zipWithIndex.sortBy(_._1).map(_._2)\n  \
    \      val arr3 = arr2.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr4 =\
    \ arr3.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr5 = arr4.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr6 = arr5.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr7\
    \ = arr6.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr8 = arr7.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr9 = arr8.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr10\
    \ = arr9.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr11 = arr10.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr12 = arr11.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr13\
    \ = arr12.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr14 = arr13.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr15 = arr14.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr16\
    \ = arr15.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr17 = arr16.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr18 = arr17.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr19\
    \ = arr18.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr20 = arr19.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr21 = arr20.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr22\
    \ = arr21.zipWithIndex.sortBy\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpk5f99264.scala:44:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36marr22\e[0m = arr21.zipWithIndex.sortBy\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0mNo implicit Ordering defined for Any..\n\e[31m   |\e[0mI found:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\
    \e[31m   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[Any]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[Any].\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpk5f99264.scala:45:5 ---------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        val diff = new Array[Long](n)\n        for (i <- 0 until\
    \ n) {\n            diff(i) = arr(i) - sorted(i)\n        }\n        val maxDiff\
    \ = diff.max\n        val minDiff = diff.min\n        if (maxDiff == minDiff)\
    \ return true\n        if (maxDiff - minDiff == 1) {\n            val maxDiffCount\
    \ = diff.count(_ == maxDiff)\n            val minDiffCount = diff.count(_ == minDiff)\n\
    \            if (maxDiffCount == 1 && minDiffCount == n - 1) return true\n   \
    \         if (maxDiffCount == n - 1 && minDiffCount == 1) return true\n      \
    \  }\n        return false\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx_2alzb9.scala:40)\n\tat Problem.main(tmpx_2alzb9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009150
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        if (max - min > n - 1) return false\n    \
    \    val count = Array.fill(n)(0)\n        for (i <- 0 until n) {\n          \
    \  count(arr(i).toInt) += 1\n        }\n        val maxCount = count.max\n   \
    \     if (maxCount > n / 2) return false\n        return true\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length\
    \ 5\n\tat Problem$.moveOneBall$$anonfun$1(tmpkutw_tli.scala:28)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall(tmpkutw_tli.scala:29)\n\
    \tat Problem$.main(tmpkutw_tli.scala:35)\n\tat Problem.main(tmpkutw_tli.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009150
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val a = arr.toArray\n\
    \        val dp = Array.fill(n)(0)\n        for (i <- 0 until n) {\n         \
    \   var max = 0\n            for (j <- 0 until i) {\n                if (a(j)\
    \ <= a(i)) {\n                    max = max max dp(j)\n                }\n   \
    \         }\n            dp(i) = max + 1\n        }\n        dp.max >= n - 1\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy5j4bk0e.scala:37)\n\tat Problem.main(tmpy5j4bk0e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009150
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val sorted = arr.sorted\n        val diff = new Array[Long](n)\n\
    \        for (i <- 0 until n) diff(i) = arr(i) - sorted(i)\n        val max =\
    \ diff.max\n        val min = diff.min\n        if (max == min) return true\n\
    \        if (max - min > 1) return false\n        val maxIndex = diff.indexOf(max)\n\
    \        val minIndex = diff.indexOf(min)\n        if (maxIndex == 0) return true\n\
    \        if (minIndex == n - 1) return true\n        if (maxIndex == n - 1) return\
    \ false\n        if (minIndex == 0) return false\n        if (diff(maxIndex -\
    \ 1) == min) return true\n        if (diff(minIndex + 1) == max) return true\n\
    \        return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvj4evz_r.scala:42)\n\tat Problem.main(tmpvj4evz_r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009150
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr2 =\
    \ arr.toArray\n        val arr3 = arr.toArray\n        for (i <- 0 until n) {\n\
    \            arr2(i) = arr(n - 1 - i)\n        }\n        for (i <- 0 until n)\
    \ {\n            arr3(i) = arr2(n - 1 - i)\n        }\n        val arr4 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr4(i) = arr3(n - 1 - i)\n     \
    \   }\n        val arr5 = arr.toArray\n        for (i <- 0 until n) {\n      \
    \      arr5(i) = arr4(n - 1 - i)\n        }\n        val arr6 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr6(i) = arr5(n - 1 - i)\n     \
    \   }\n        val arr7 = arr.toArray\n        for (i <- 0 until n) {\n      \
    \      arr7(i) = arr6(n - 1 - i)\n        }\n        val arr8 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr8(i) = arr7(n - 1 - i)\n     \
    \   }\n        val arr9 = arr.toArray\n        for (i <- 0 until n) {\n      \
    \      arr9(i) = arr8(n - 1 - i)\n        }\n        val arr10 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr10(i) = arr9(n - 1 - i)\n    \
    \    }\n        val arr11 = arr.toArray\n        for (i <- 0 until n) {\n    \
    \        arr11(i) = arr10(n - 1 - i)\n        }\n        val arr12 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr12(i) = arr11(n - 1 - i)\n   \
    \     }\n        val arr13 = arr.toArray\n        for (i <- 0 until n) {\n   \
    \         arr13(i) = arr12(n - 1 - i)\n        }\n        val arr14 = arr.toArray\n\
    \        for\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpyajn99c3.scala:72:11 ---------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m        \e[33mfor\e[0m\n\e[31m\e[31m   |\e[0m       \
    \    ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val dp = Array.fill(n)(0)\n\
    \        for (i <- 1 until n) {\n            val cur = arr(i)\n            var\
    \ j = i - 1\n            while (j >= 0 && arr(j) > cur) {\n                dp(i)\
    \ += 1\n                j -= 1\n            }\n        }\n        val max = dp.max\n\
    \        max <= 1\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwkh5fk4i.scala:36)\n\tat Problem.main(tmpwkh5fk4i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009150
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val dp = Array.fill(n)(0)\n\
    \        for (i <- 0 until n) {\n            val x = arr(i)\n            if (i\
    \ == 0) dp(i) = 1\n            else {\n                var j = i - 1\n       \
    \         while (j >= 0 && arr(j) <= x) {\n                    dp(i) = max(dp(i),\
    \ dp(j) + 1)\n                    j -= 1\n                }\n                if\
    \ (j == -1) dp(i) = max(dp(i), 1)\n            }\n        }\n        dp(n - 1)\
    \ == n\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu19l97c1.scala:39)\n\tat Problem.main(tmpu19l97c1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009150
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr2 =\
    \ arr.toArray\n        val arr3 = arr.toArray\n        for (i <- 0 until n) {\n\
    \            arr2(i) = arr(n - 1 - i)\n        }\n        for (i <- 0 until n)\
    \ {\n            arr3(i) = arr2(n - 1 - i)\n        }\n        val arr4 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr4(i) = arr3(n - 1 - i)\n     \
    \   }\n        val arr5 = arr.toArray\n        for (i <- 0 until n) {\n      \
    \      arr5(i) = arr4(n - 1 - i)\n        }\n        val arr6 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr6(i) = arr5(n - 1 - i)\n     \
    \   }\n        val arr7 = arr.toArray\n        for (i <- 0 until n) {\n      \
    \      arr7(i) = arr6(n - 1 - i)\n        }\n        val arr8 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr8(i) = arr7(n - 1 - i)\n     \
    \   }\n        val arr9 = arr.toArray\n        for (i <- 0 until n) {\n      \
    \      arr9(i) = arr8(n - 1 - i)\n        }\n        val arr10 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr10(i) = arr9(n - 1 - i)\n    \
    \    }\n        val arr11 = arr.toArray\n        for (i <- 0 until n) {\n    \
    \        arr11(i) = arr10(n - 1 - i)\n        }\n        val arr12 = arr.toArray\n\
    \        for (i <- 0 until n) {\n            arr12(i) = arr11(n - 1 - i)\n   \
    \     }\n        val arr13 = arr.toArray\n        for (i <- 0 until n) {\n   \
    \         arr13(i) = arr12(n - 1 - i)\n        }\n        val arr14 = arr.toArray\n\
    \        for\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpyajn99c3.scala:72:11 ---------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m        \e[33mfor\e[0m\n\e[31m\e[31m   |\e[0m       \
    \    ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val max = arr.max\n        val min = arr.min\n        if\
    \ (max - min > n - 1) return false\n        val count = Array.fill(n)(0)\n   \
    \     for (i <- 0 until n) {\n            count(arr(i).toInt) += 1\n        }\n\
    \        var i = 0\n        while (i < n) {\n            if (count(i) == 0) {\n\
    \                i += 1\n            } else if (count(i) == 1) {\n           \
    \     return true\n            } else {\n                return false\n      \
    \      }\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length\
    \ 5\n\tat Problem$.moveOneBall$$anonfun$1(tmploplll8c.scala:29)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall(tmploplll8c.scala:30)\n\
    \tat Problem$.main(tmploplll8c.scala:44)\n\tat Problem.main(tmploplll8c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009151
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val dp = Array.fill(n)(0)\n\
    \        for (i <- 1 until n) {\n            if (arr(i) > arr(i - 1)) dp(i) =\
    \ dp(i - 1) + 1\n            else dp(i) = dp(i - 1)\n        }\n        dp(n -\
    \ 1) <= n / 2\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjhn6o1yu.scala:31)\n\tat Problem.main(tmpjhn6o1yu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009151
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val dp = Array.fill(n)(0)\n        for (i <- 0 until n)\
    \ {\n            var max = 0\n            for (j <- 0 until i) {\n           \
    \     if (arr(j) <= arr(i)) {\n                    max = max max dp(j)\n     \
    \           }\n            }\n            dp(i) = max + 1\n        }\n       \
    \ dp.max >= n - 1\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzetaqm4h.scala:37)\n\tat Problem.main(tmpzetaqm4h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009150
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val dp = Array.fill(n)(0)\n\
    \        for (i <- 1 until n) {\n            if (arr(i) > arr(i - 1)) dp(i) =\
    \ dp(i - 1) + 1\n            else dp(i) = dp(i - 1)\n        }\n        dp(n -\
    \ 1) <= n / 2\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjhn6o1yu.scala:31)\n\tat Problem.main(tmpjhn6o1yu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009151
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        if (max - min > 1) return false\n        if\
    \ (max == min) return true\n        val maxIndex = arr.indexOf(max)\n        val\
    \ minIndex = arr.indexOf(min)\n        if (maxIndex == 0) return true\n      \
    \  if (minIndex == n - 1) return true\n        if (maxIndex == n - 1) return false\n\
    \        if (minIndex == 0) return false\n        if (maxIndex == n - 2) return\
    \ true\n        if (minIndex == 1) return true\n        return false\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphc7cjyoy.scala:38)\n\tat Problem.main(tmphc7cjyoy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009150
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val max = arr.max\n        val min = arr.min\n        if\
    \ (max - min == n - 1) return true\n        else return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa21kw7xm.scala:31)\n\tat Problem.main(tmpa21kw7xm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        var i = 0\n\
    \        while (i < n - 1) {\n            if (arr(i) > arr(i + 1)) {\n       \
    \         return false\n            }\n            i += 1\n        }\n       \
    \ return true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjqnw_mzs.scala:33)\n\tat Problem.main(tmpjqnw_mzs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009150
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val dp = Array.fill(n)(0)\n\
    \        for (i <- 1 until n) {\n            if (arr(i) > arr(i - 1)) dp(i) =\
    \ dp(i - 1) + 1\n            else dp(i) = dp(i - 1)\n        }\n        dp(n -\
    \ 1) <= n / 2\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjhn6o1yu.scala:31)\n\tat Problem.main(tmpjhn6o1yu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009151
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.toArray\n        var i = 0\n        while\
    \ (i < n) {\n            if (i + 1 < n && arr2(i) > arr2(i + 1)) {\n         \
    \       val temp = arr2(i)\n                arr2(i) = arr2(i + 1)\n          \
    \      arr2(i + 1) = temp\n                return arr2.toList == arr2.sorted\n\
    \            }\n            i += 1\n        }\n        return true\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp3s79cf5d.scala:31:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                \e[33mreturn\e[0m arr2.toList == arr2.sorted\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mValues of types List[Long] and Array[Long] cannot be compared with\
    \ == or !=\n1 error found\n"
  stdout: ''
  timestamp: 1660009153
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        val diff = new Array[Int](n)\n        for (i <- 0 until\
    \ n) diff(i) = arr(i) - sorted(i)\n        for (i <- 0 until n) if (diff(i) !=\
    \ 0) {\n            val j = (i + 1) % n\n            if (diff(i) < 0) return false\n\
    \            if (diff(j) > 0) return false\n            diff(i) -= 1\n       \
    \     diff(j) += 1\n        }\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpetj953x6.scala:25:39\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m0\e[0m until n) diff(i) = arr(i) - sorted(i)\n\e[31m\e[31m   |\e[0m  \
    \                                     ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                       Found:    Long\n\e[31m   |\e[0m      \
    \                                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009153
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        // We will use a stack to keep track of\
    \ the balls.\n        val stack = new Stack[Long]\n        for (i <- arr) {\n\
    \            if (stack.isEmpty) stack.push(i)\n            else {\n          \
    \      if (stack.top > i) return false\n                else stack.push(i)\n \
    \           }\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphuzjghz1.scala:34)\n\tat Problem.main(tmphuzjghz1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009158
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val sorted = arr.sorted\n        val diff = new Array[Long](n)\n\
    \        for (i <- 0 until n) diff(i) = arr(i) - sorted(i)\n        for (i <-\
    \ 0 until n) {\n            if (diff(i) < 0) return false\n            if (diff(i)\
    \ > 0) {\n                if (i == 0) return false\n                if (diff(i\
    \ - 1) > 0) return false\n                diff(i - 1) -= diff(i)\n           \
    \     diff(i) = 0\n            }\n        }\n        true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl5i2r3bn.scala:39)\n\tat Problem.main(tmpl5i2r3bn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009159
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val min = arr.min\n\
    \        val max = arr.max\n        val minIndex = arr.indexOf(min)\n        val\
    \ maxIndex = arr.indexOf(max)\n        val left = arr.slice(0, minIndex)\n   \
    \     val right = arr.slice(minIndex + 1, n)\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSortedReverse = leftSorted.reverse\n\
    \        val rightSortedReverse = rightSorted.reverse\n        if (minIndex ==\
    \ 0) {\n            if (rightSorted.head < max) {\n                return true\n\
    \            }\n            else {\n                return false\n           \
    \ }\n        }\n        else if (minIndex == n - 1) {\n            if (leftSortedReverse.head\
    \ > min) {\n                return true\n            }\n            else {\n \
    \               return false\n            }\n        }\n        else {\n     \
    \       if (leftSortedReverse.head > min && rightSorted.head < max) {\n      \
    \          return true\n            }\n            else {\n                return\
    \ false\n            }\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpetqta_wy.scala:61)\n\tat Problem.main(tmpetqta_wy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009159
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        if (max - min == n - 1) true\n        else\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_610pqof.scala:30)\n\tat Problem.main(tmp_610pqof.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009139
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        val index = arr.zipWithIndex.map(x => (x._1, x._2)).toMap\n\
    \        val sortedIndex = sorted.zipWithIndex.map(x => (x._1, x._2)).toMap\n\
    \        val diff = arr.zip(sorted).map(x => (x._1 - x._2).abs).sum\n        if\
    \ (diff == 0) return true\n        if (diff % 2 == 1) return false\n        val\
    \ diffIndex = arr.zip(sorted).map(x => (x._1 - x._2).abs).zipWithIndex.filter(x\
    \ => x._1 != 0).map(x => x._2)\n        val diffIndex1 = diffIndex.map(x => index(arr(x))).sorted\n\
    \        val diffIndex2 = diffIndex.map(x => sortedIndex(sorted(x))).sorted\n\
    \        val diffIndex3 = diffIndex1.zip(diffIndex2).map(x => (x._1 - x._2).abs).sum\n\
    \        if (diffIndex3 == diffIndex.length) return true\n        return false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo7cq2_3s.scala:37)\n\tat Problem.main(tmpo7cq2_3s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009160
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        if (max == min) return true\n        if (max\
    \ - min == 1) {\n            val maxCount = arr.count(_ == max)\n            val\
    \ minCount = arr.count(_ == min)\n            if (maxCount == 1 && minCount ==\
    \ n - 1) return true\n            if (maxCount == n - 1 && minCount == 1) return\
    \ true\n            return false\n        }\n        return false\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1hfz7g9o.scala:36)\n\tat Problem.main(tmp1hfz7g9o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009160
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val dp = Array.fill(n)(0)\n        for (i <- 1 until n)\
    \ {\n            if (arr(i) < arr(i - 1)) {\n                dp(i) = dp(i - 1)\
    \ + 1\n            }\n        }\n        dp.max <= 1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009161
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val sorted = arr.sorted\n        val diff\
    \ = (arr, sorted).zipped.map(_ - _)\n        val max = diff.max\n        val min\
    \ = diff.min\n        if (max == 0) return true\n        if (max - min > 1) return\
    \ false\n        if (max == min) return true\n        val maxIndex = diff.indexOf(max)\n\
    \        val minIndex = diff.indexOf(min)\n        val maxIndexSorted = sorted.indexOf(arr(maxIndex))\n\
    \        val minIndexSorted = sorted.indexOf(arr(minIndex))\n        if (maxIndexSorted\
    \ == minIndexSorted) return true\n        if (maxIndexSorted > minIndexSorted)\
    \ return false\n        if (maxIndexSorted == minIndexSorted - 1) return true\n\
    \        if (maxIndexSorted == 0) return true\n        if (minIndexSorted == arr.length\
    \ - 1) return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnnxbq1iw.scala:41)\n\tat Problem.main(tmpnnxbq1iw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009161
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        val diff = arr.zip(sorted).map(x => x._1 - x._2).toArray\n\
    \        val sum = diff.sum\n        if (sum == 0) return true\n        if (sum\
    \ < 0) return false\n        val max = diff.max\n        val min = diff.min\n\
    \        if (max > 0 && min < 0) return false\n        if (max > 0) {\n      \
    \      val maxIndex = diff.indexOf(max)\n            val maxCount = diff.count(_\
    \ == max)\n            if (maxCount == 1) {\n                if (maxIndex == 0)\
    \ return true\n                if (maxIndex == n - 1) return true\n          \
    \      if (diff(maxIndex - 1) == 0) return true\n                if (diff(maxIndex\
    \ + 1) == 0) return true\n                return false\n            } else {\n\
    \                if (maxIndex == 0) return true\n                if (maxIndex\
    \ == n - 1) return true\n                if (diff(maxIndex - 1) == 0) return true\n\
    \                if (diff(maxIndex + 1) == 0) return true\n                return\
    \ false\n            }\n        } else {\n            val minIndex = diff.indexOf(min)\n\
    \            val minCount = diff.count(_ == min)\n            if (minCount ==\
    \ 1) {\n                if (minIndex == 0) return true\n                if (minIndex\
    \ == n - 1) return true\n                if (diff(minIndex - 1) == 0) return true\n\
    \                if (diff(minIndex + 1) == 0) return true\n                return\
    \ false\n            } else {\n                if (minIndex == 0) return true\n\
    \                if (minIndex == n - 1) return true\n                if (diff(minIndex\
    \ - 1) == 0) return true\n                if (diff(minIndex + 1) == 0) return\
    \ true\n                return false\n            }\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ujc94i5.scala:68)\n\tat Problem.main(tmp2ujc94i5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009161
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        val maxIndex = arr.indexOf(max)\n        val\
    \ minIndex = arr.indexOf(min)\n        if (maxIndex == 0) {\n            if (minIndex\
    \ == n - 1) {\n                return true\n            } else {\n           \
    \     return false\n            }\n        } else {\n            if (minIndex\
    \ == n - 1) {\n                return false\n            } else {\n          \
    \      return true\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg2k1sgrw.scala:45)\n\tat Problem.main(tmpg2k1sgrw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009127
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val sorted = arr.sorted\n        val diff = new Array[Int](n)\n\
    \        for (i <- 0 until n) {\n            diff(i) = arr.indexOf(sorted(i))\
    \ - i\n        }\n        var count = 0\n        for (i <- 0 until n) {\n    \
    \        if (diff(i) == 0) {\n                count += 1\n            }\n    \
    \    }\n        if (count == n) return true\n        var max = 0\n        for\
    \ (i <- 0 until n) {\n            if (diff(i) > max) max = diff(i)\n        }\n\
    \        if (max > n - count) return false\n        return true\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5etm843w.scala:46)\n\tat Problem.main(tmp5etm843w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009161
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val a = arr.toArray\n\
    \        var i = 0\n        while (i < n - 1) {\n            if (a(i) > a(i +\
    \ 1)) {\n                val temp = a(i)\n                a(i) = a(i + 1)\n  \
    \              a(i + 1) = temp\n                return true\n            }\n \
    \           i += 1\n        }\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2iuzvcn4.scala:39)\n\tat Problem.main(tmp2iuzvcn4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009161
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val sorted = arr.sorted\n        val n\
    \ = arr.length\n        val m = sorted.length\n        if (n == 0) return true\n\
    \        if (n == 1) return true\n        if (n == 2) return true\n        if\
    \ (n == 3) {\n            if (arr(0) <= arr(1) && arr(1) <= arr(2)) return true\n\
    \            else return false\n        }\n        val a = arr.toArray\n     \
    \   val b = sorted.toArray\n        val dp = Array.ofDim[Boolean](n, n)\n    \
    \    for (i <- 0 until n) dp(i)(i) = true\n        for (i <- 0 until n - 1) {\n\
    \            if (a(i) <= a(i + 1)) dp(i)(i + 1) = true\n            else dp(i)(i\
    \ + 1) = false\n        }\n        for (k <- 2 until n) {\n            for (i\
    \ <- 0 until n - k) {\n                val j = i + k\n                if (a(i)\
    \ <= a(j)) dp(i)(j) = dp(i + 1)(j)\n                else dp(i)(j) = false\n  \
    \          }\n        }\n        val dp2 = Array.ofDim[Boolean](n, n)\n      \
    \  for (i <- 0 until n) dp2(i)(i) = true\n        for (i <- 0 until n - 1) {\n\
    \            if (b(i) <= b(i + 1)) dp2(i)(i + 1) = true\n            else dp2(i)(i\
    \ + 1) = false\n        }\n        for (k <- 2 until n) {\n            for (i\
    \ <- 0 until n - k) {\n                val j = i + k\n                if (b(i)\
    \ <= b(j)) dp2(i)(j) = dp2(i + 1)(j)\n                else dp2(i)(j) = false\n\
    \            }\n        }\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until n) {\n                if (dp(i)(j) && dp2(i)(j)) return true\n\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgvttrwyh.scala:74:0 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgvttrwyh.scala:60:8\
    \ ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m0\e[0m until n) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m\
    \        Found:    Unit\n\e[31m   |\e[0m        Required: Boolean\n\e[31m61 |\e\
    [0m            \e[33mfor\e[0m (j <- \e[31m0\e[0m until n) {\n\e[31m62 |\e[0m \
    \               \e[33mif\e[0m (dp(i)(j) && dp2(i)(j)) \e[33mreturn\e[0m \e[31mtrue\e\
    [0m\n\e[31m63 |\e[0m    }\n\e[31m64 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e\
    [36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m65 |\e[0m    assert(moveOneBall((List[\e\
    [35mLong\e[0m](\e[31m3l\e[0m.toLong, \e[31m4l\e[0m.toLong, \e[31m5l\e[0m.toLong,\
    \ \e[31m1l\e[0m.toLong, \e[31m2l\e[0m.toLong))) == (\e[31mtrue\e[0m));\n\e[31m66\
    \ |\e[0m    assert(moveOneBall((List[\e[35mLong\e[0m](\e[31m3l\e[0m.toLong, \e\
    [31m5l\e[0m.toLong, \e[31m10l\e[0m.toLong, \e[31m1l\e[0m.toLong, \e[31m2l\e[0m.toLong)))\
    \ == (\e[31mtrue\e[0m));\n\e[31m67 |\e[0m    assert(moveOneBall((List[\e[35mLong\e\
    [0m](\e[31m4l\e[0m.toLong, \e[31m3l\e[0m.toLong, \e[31m1l\e[0m.toLong, \e[31m2l\e\
    [0m.toLong))) == (\e[31mfalse\e[0m));\n\e[31m68 |\e[0m    assert(moveOneBall((List[\e\
    [35mLong\e[0m](\e[31m3l\e[0m.toLong, \e[31m5l\e[0m.toLong, \e[31m4l\e[0m.toLong,\
    \ \e[31m1l\e[0m.toLong, \e[31m2l\e[0m.toLong))) == (\e[31mfalse\e[0m));\n\e[31m69\
    \ |\e[0m    assert(moveOneBall((List[\e[35mLong\e[0m]())) == (\e[31mtrue\e[0m));\n\
    \e[31m70 |\e[0m    }\n\e[31m71 |\e[0m}\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009161
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val sorted = arr.sorted\n        val index = arr.indexOf(sorted(0))\n\
    \        if (index == 0) return true\n        val arr1 = arr.slice(index, n) ++\
    \ arr.slice(0, index)\n        val arr2 = arr.slice(n - index, n) ++ arr.slice(0,\
    \ n - index)\n        val arr3 = arr.slice(n - index, n) ++ arr.slice(index, n\
    \ - index) ++ arr.slice(0, index)\n        val arr4 = arr.slice(index, n) ++ arr.slice(0,\
    \ n - index) ++ arr.slice(n - index, index)\n        val arr5 = arr.slice(n -\
    \ index, n) ++ arr.slice(index, n - index) ++ arr.slice(0, n - index)\n      \
    \  val arr6 = arr.slice(index, n) ++ arr.slice(0, index) ++ arr.slice(n - index,\
    \ index)\n        val arr7 = arr.slice(n - index, n) ++ arr.slice(0, n - index)\
    \ ++ arr.slice(index, n - index)\n        val arr8 = arr.slice(index, n) ++ arr.slice(0,\
    \ index) ++ arr.slice(n - index, n - index)\n        val arr9 = arr.slice(n -\
    \ index, n) ++ arr.slice(0, n - index) ++ arr.slice(index, index)\n        val\
    \ arr10 = arr.slice(index, n) ++ arr.slice(0, index) ++ arr.slice(n - index, n)\n\
    \        val arr11 = arr.slice(n - index, n) ++ arr.slice(0, n - index) ++ arr.slice(index,\
    \ n)\n        val arr12 = arr.slice(index, n) ++ arr.slice(0, index) ++ arr.slice(n\
    \ - index, n - index) ++ arr.slice(index, index)\n        val arr13 = arr.slice(n\
    \ - index, n) ++ arr.slice(0, n - index) ++ arr.slice(index, index) ++ arr.slice(\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0hjncl_z.scala:39:111 --------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36marr13\e[0m = arr.slice(n\
    \ - index, n) ++ arr.slice(\e[31m0\e[0m, n - index) ++ arr.slice(index, index)\
    \ ++ arr.slice(\n\e[31m\e[31m   |\e[0m                                       \
    \                                                                        ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0hjncl_z.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009161
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if (arr.length == 0) return true\n    \
    \    val sorted = arr.sorted\n        val diff = arr.zip(sorted).map(x => x._1\
    \ - x._2)\n        val max = diff.max\n        val min = diff.min\n        if\
    \ (max - min > 1) return false\n        else if (max - min == 1) return diff.count(_\
    \ == max) == 1\n        else return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_hjzlogm.scala:32)\n\tat Problem.main(tmp_hjzlogm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        val diff = new Array[Long](n)\n        for (i <- 0 until\
    \ n) diff(i) = sorted(i) - arr(i)\n        for (i <- 0 until n) {\n          \
    \  if (diff(i) < 0) {\n                if (i == 0) return false\n            \
    \    else if (diff(i - 1) <= 0) return false\n                else diff(i - 1)\
    \ -= 1\n            }\n        }\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpep2c0wfd.scala:36)\n\tat Problem.main(tmpep2c0wfd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val dp = Array.fill(n)(0)\n\
    \        for (i <- 1 until n) {\n            if (arr(i) > arr(i - 1)) dp(i) =\
    \ dp(i - 1) + 1\n            else dp(i) = dp(i - 1)\n        }\n        dp(n -\
    \ 1) <= n / 2\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjhn6o1yu.scala:31)\n\tat Problem.main(tmpjhn6o1yu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009151
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        if (max - min > n - 1) return false\n    \
    \    val count = Array.fill(n)(0)\n        for (i <- 0 until n) {\n          \
    \  count(arr(i).toInt) += 1\n        }\n        var i = 0\n        var j = 0\n\
    \        while (i < n) {\n            if (count(i) == 0) {\n                i\
    \ += 1\n            } else {\n                if (i != j) return false\n     \
    \           j += 1\n                count(i) -= 1\n            }\n        }\n\
    \        true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length\
    \ 5\n\tat Problem$.moveOneBall$$anonfun$1(tmpycpqb34q.scala:28)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall(tmpycpqb34q.scala:29)\n\
    \tat Problem$.main(tmpycpqb34q.scala:44)\n\tat Problem.main(tmpycpqb34q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val max = arr.max\n        val min = arr.min\n        if\
    \ (max - min <= 1) return true\n        val count = arr.groupBy(x => x).map(x\
    \ => (x._1, x._2.length)).toList.sortBy(x => x._1)\n        val maxCount = count.maxBy(x\
    \ => x._2)._2\n        if (maxCount > n / 2) return false\n        return true\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcliyrlw9.scala:35)\n\tat Problem.main(tmpcliyrlw9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009162
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr2 =\
    \ arr.toArray\n        val arr3 = arr.toArray\n        for (i <- 0 until n) {\n\
    \            arr2(i) = arr(i)\n            arr3(i) = arr(i)\n        }\n     \
    \   for (i <- 0 until n) {\n            arr2(i) = arr(n - 1 - i)\n           \
    \ arr3(i) = arr(n - 1 - i)\n        }\n        for (i <- 0 until n) {\n      \
    \      arr2(i) = arr(i)\n            arr3(i) = arr(i)\n        }\n        for\
    \ (i <- 0 until n) {\n            arr2(i) = arr(n - 1 - i)\n            arr3(i)\
    \ = arr(n - 1 - i)\n        }\n        for (i <- 0 until n) {\n            arr2(i)\
    \ = arr(i)\n            arr3(i) = arr(i)\n        }\n        for (i <- 0 until\
    \ n) {\n            arr2(i) = arr(n - 1 - i)\n            arr3(i) = arr(n - 1\
    \ - i)\n        }\n        for (i <- 0 until n) {\n            arr2(i) = arr(i)\n\
    \            arr3(i) = arr(i)\n        }\n        for (i <- 0 until n) {\n   \
    \         arr2(i) = arr(n - 1 - i)\n            arr3(i) = arr(n - 1 - i)\n   \
    \     }\n        for (i <- 0 until n) {\n            arr2(i) = arr(i)\n      \
    \      arr3(i) = arr(i)\n        }\n        for (i <- 0 until n) {\n         \
    \   arr2(i) = arr(n - 1 - i)\n            arr3(i) = arr(n - 1 - i)\n        }\n\
    \        for (i <- 0 until n) {\n            arr2(i) = arr(i)\n            arr3(i)\
    \ = arr(i)\n        }\n        for (i <- 0 until n) {\n            arr2(i) = arr(n\
    \ - 1 - i\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfhkalmxo.scala:71:4 ----------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfhkalmxo.scala:81:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m81 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpfhkalmxo.scala:80:1 ---------------------\e[0m\e[0m\n\
    \e[31m80 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpfhkalmxo.scala:72:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m72 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660009161
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val a = arr.toArray\n        var i = 0\n        while (i\
    \ < n - 1) {\n            if (a(i) > a(i + 1)) {\n                var j = i +\
    \ 1\n                while (j < n && a(j) < a(j - 1)) {\n                    val\
    \ temp = a(j)\n                    a(j) = a(j - 1)\n                    a(j -\
    \ 1) = temp\n                    j += 1\n                }\n                return\
    \ false\n            }\n            i += 1\n        }\n        true\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7455txy8.scala:42)\n\tat Problem.main(tmp7455txy8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val dp = Array.fill(n)(0)\n\
    \        for (i <- 1 until n) {\n            if (arr(i) > arr(i - 1)) dp(i) =\
    \ dp(i - 1) + 1\n            else dp(i) = dp(i - 1)\n        }\n        dp(n -\
    \ 1) <= n / 2\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjhn6o1yu.scala:31)\n\tat Problem.main(tmpjhn6o1yu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009151
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val max = arr.max\n        val min = arr.min\n        if\
    \ (max - min > 1) return false\n        if (max == min) return true\n        val\
    \ maxIndex = arr.indexOf(max)\n        val minIndex = arr.indexOf(min)\n     \
    \   if (maxIndex == 0) return true\n        if (minIndex == n - 1) return true\n\
    \        if (maxIndex == n - 1) return false\n        if (minIndex == 0) return\
    \ false\n        if (maxIndex < minIndex) return true\n        val left = arr.slice(0,\
    \ maxIndex)\n        val right = arr.slice(maxIndex + 1, n)\n        val leftMax\
    \ = left.max\n        val rightMin = right.min\n        if (leftMax < rightMin)\
    \ return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaii2ymn.scala:43)\n\tat Problem.main(tmpkaii2ymn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009162
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val dp = Array.fill(n)(false)\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        if (i == j) dp(i)(j) = true\n                else if (i == 0) dp(i)(j)\
    \ = arr(i) <= arr(j)\n                else dp(i)(j) = dp(i - 1)(j) && arr(i) <=\
    \ arr(j)\n            }\n        }\n        dp(n - 1)(n - 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbbkj6qu4.scala:26:28 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mif\e[0m (i == j) dp(i)(j) = \e\
    [31mtrue\e[0m\n\e[31m\e[31m   |\e[0m                            ^^^^^\e[0m\n\e\
    [31m   |\e[0m                            value update is not a member of Boolean\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbbkj6qu4.scala:27:33 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (i == \e\
    [31m0\e[0m) dp(i)(j) = arr(i) <= arr(j)\n\e[31m\e[31m   |\e[0m               \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \  value update is not a member of Boolean\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpbbkj6qu4.scala:28:21 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m                \e[33melse\e[0m dp(i)(j) = dp(i - \e[31m1\e[0m)(j) && arr(i)\
    \ <= arr(j)\n\e[31m\e[31m   |\e[0m                     ^^^^^\e[0m\n\e[31m   |\e\
    [0m                     value update is not a member of Boolean\n\e[31m\e[31m--\
    \ [E050] Type Error: /tmp/tmpbbkj6qu4.scala:28:34 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33melse\e[0m dp(i)(j) = dp(i - \e\
    [31m1\e[0m)(j) && arr(i) <= arr(j)\n\e[31m\e[31m   |\e[0m                    \
    \            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \e[33mmethod\e[0m \e\
    [35mapply\e[0m in \e[33mclass\e[0m \e[35mArray\e[0m does not take more parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpbbkj6qu4.scala:31:10 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        dp(n - \e[31m1\e[0m)(n - \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \e[33mmethod\e[0m\
    \ \e[35mapply\e[0m in \e[33mclass\e[0m \e[35mArray\e[0m does not take more parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val sorted = arr.sorted\n        val n\
    \ = arr.length\n        val m = sorted.length\n        var i = 0\n        var\
    \ j = 0\n        while (i < n && j < m) {\n            if (arr(i) == sorted(j))\
    \ {\n                i += 1\n                j += 1\n            } else {\n  \
    \              i += 1\n            }\n        }\n        j == m\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8ktvsp5j.scala:38)\n\tat Problem.main(tmp8ktvsp5j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.toArray\n        val arr3 = new Array[Long](n)\n\
    \        for (i <- 0 until n) {\n            arr3(i) = arr2(i)\n        }\n  \
    \      scala.util.Sorting.quickSort(arr2)\n        for (i <- 0 until n) {\n  \
    \          if (arr2(i) != arr3(i)) {\n                val j = arr3.indexOf(arr2(i))\n\
    \                for (k <- j until n - 1) {\n                    arr3(k) = arr3(k\
    \ + 1)\n                }\n                arr3(n - 1) = arr2(i)\n           \
    \     if (arr3.toList == arr2.toList) return true\n            }\n        }\n\
    \        return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ocjtcix.scala:45)\n\tat Problem.main(tmp5ocjtcix.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009165
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val a = arr.toArray\n\
    \        val b = new Array[Long](n)\n        for (i <- 0 until n) {\n        \
    \    b(i) = a(i)\n        }\n        for (i <- 0 until n) {\n            if (i\
    \ == 0) {\n                if (b(i) > b(i + 1)) {\n                    val temp\
    \ = b(i)\n                    b(i) = b(i + 1)\n                    b(i + 1) =\
    \ temp\n                    return b.toList == arr\n                }\n      \
    \      } else if (i == n - 1) {\n                if (b(i) < b(i - 1)) {\n    \
    \                val temp = b(i)\n                    b(i) = b(i - 1)\n      \
    \              b(i - 1) = temp\n                    return b.toList == arr\n \
    \               }\n            } else {\n                if (b(i) > b(i + 1) &&\
    \ b(i) < b(i - 1)) {\n                    val temp = b(i)\n                  \
    \  b(i) = b(i + 1)\n                    b(i + 1) = temp\n                    return\
    \ b.toList == arr\n                } else if (b(i) < b(i + 1) && b(i) > b(i -\
    \ 1)) {\n                    val temp = b(i)\n                    b(i) = b(i -\
    \ 1)\n                    b(i - 1) = temp\n                    return b.toList\
    \ == arr\n                }\n            }\n        }\n        return false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1sdgj3e7.scala:60)\n\tat Problem.main(tmp1sdgj3e7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009166
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        val maxIndex = arr.indexOf(max)\n        val\
    \ minIndex = arr.indexOf(min)\n        if (maxIndex == n - 1) {\n            if\
    \ (minIndex == 0) {\n                return true\n            } else {\n     \
    \           return false\n            }\n        } else {\n            if (minIndex\
    \ == 0) {\n                return true\n            } else {\n               \
    \ return false\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp0bp6cdn.scala:42)\n\tat Problem.main(tmpp0bp6cdn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009104
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.zipWithIndex.sortBy(_._1).map(_._2)\n  \
    \      val arr3 = arr2.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr4 =\
    \ arr3.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr5 = arr4.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr6 = arr5.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr7\
    \ = arr6.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr8 = arr7.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr9 = arr8.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr10\
    \ = arr9.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr11 = arr10.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr12 = arr11.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr13\
    \ = arr12.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr14 = arr13.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr15 = arr14.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr16\
    \ = arr15.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr17 = arr16.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr18 = arr17.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr19\
    \ = arr18.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr20 = arr19.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr21 = arr20.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr22\
    \ = arr21.zipWithIndex.sortBy\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpk5f99264.scala:44:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36marr22\e[0m = arr21.zipWithIndex.sortBy\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0mNo implicit Ordering defined for Any..\n\e[31m   |\e[0mI found:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\
    \e[31m   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[Any]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[Any].\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpk5f99264.scala:45:5 ---------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val a = arr.toArray\n\
    \        val b = new Array[Long](n)\n        for (i <- 0 until n) b(i) = a(i)\n\
    \        for (i <- 0 until n) {\n            val x = a(i)\n            var j =\
    \ i\n            while (j > 0 && b(j - 1) > x) {\n                b(j) = b(j -\
    \ 1)\n                j -= 1\n            }\n            b(j) = x\n          \
    \  if (b.sameElements(a)) return true\n        }\n        false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi6_0yw4f.scala:41)\n\tat Problem.main(tmpi6_0yw4f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009169
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val m = arr.max\n        val p = arr.indexOf(m)\n     \
    \   if (p == 0) return true\n        if (p == n - 1) return false\n        val\
    \ l = arr.slice(0, p)\n        val r = arr.slice(p + 1, n)\n        if (l.min\
    \ < m && r.min < m) return false\n        if (l.min < m) return moveOneBall(r)\n\
    \        if (r.min < m) return moveOneBall(l)\n        return true\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmow1_bg6.scala:36)\n\tat Problem.main(tmpmow1_bg6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009170
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if (arr.length == 0) return true\n    \
    \    val sorted = arr.sorted\n        val diff = arr.zip(sorted).map(x => x._1\
    \ - x._2)\n        val max = diff.max\n        val min = diff.min\n        if\
    \ (max - min > 1) return false\n        if (max == min) return true\n        val\
    \ maxIndex = diff.indexOf(max)\n        val minIndex = diff.indexOf(min)\n   \
    \     if (maxIndex == 0) return true\n        if (minIndex == arr.length - 1)\
    \ return true\n        if (maxIndex == arr.length - 1) return true\n        if\
    \ (minIndex == 0) return true\n        if (maxIndex == minIndex + 1) return true\n\
    \        if (minIndex == maxIndex + 1) return true\n        return false\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxvcagt_0.scala:40)\n\tat Problem.main(tmpxvcagt_0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009170
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val dp = Array.fill(n)(0)\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until i) {\n        \
    \        if (arr(j) <= arr(i)) {\n                    dp(i) = max(dp(i), dp(j)\
    \ + 1)\n                }\n            }\n        }\n        dp.max >= n - 1\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbil6leqd.scala:34)\n\tat Problem.main(tmpbil6leqd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.max\n\
    \        val dp = Array.fill(n + 1)(0)\n        for (i <- 1 to n) {\n        \
    \    val x = arr(i - 1)\n            dp(i) = dp(i - 1) + (m - x)\n        }\n\
    \        dp(n) % 2 == 0\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8qb_f_j7.scala:27:20\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            dp(i) = dp(i - \e\
    [31m1\e[0m) + (m - x)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Found:    Long\n\e[31m   |\e[0m      \
    \              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009169
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val dp = Array.fill(n)(0)\n        dp(0) = 1\n        for\
    \ (i <- 1 until n) {\n            if (arr(i) >= arr(i - 1)) dp(i) = dp(i - 1)\
    \ + 1\n            else dp(i) = 1\n        }\n        dp.max >= n\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4r0qx5as.scala:33)\n\tat Problem.main(tmp4r0qx5as.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009172
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val dp = Array.fill(n)(0)\n\
    \        for (i <- 0 until n) {\n            var max = 0\n            for (j <-\
    \ 0 until i) {\n                if (arr(j) < arr(i)) {\n                    max\
    \ = max max dp(j)\n                }\n            }\n            dp(i) = max +\
    \ 1\n        }\n        dp.max >= n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo7apcdls.scala:36)\n\tat Problem.main(tmpo7apcdls.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009172
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val a = arr.toArray\n\
    \        val b = new Array[Long](n)\n        for (i <- 0 until n) b(i) = a(i)\n\
    \        for (i <- 0 until n) {\n            val j = (i + 1) % n\n           \
    \ if (b(i) > b(j)) {\n                val t = b(i)\n                b(i) = b(j)\n\
    \                b(j) = t\n                return b.toList == arr.sorted\n   \
    \         }\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt36q8b5l.scala:38)\n\tat Problem.main(tmpt36q8b5l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        val map = new HashMap[Long, Int]\n        for (i <- 0\
    \ until n) {\n            map(arr(i)) = i\n        }\n        for (i <- 0 until\
    \ n) {\n            if (arr(i) != sorted(i)) {\n                val j = map(sorted(i))\n\
    \                if (j == 0) {\n                    return false\n           \
    \     }\n                else {\n                    val temp = arr(j - 1)\n \
    \                   arr(j - 1) = arr(j)\n                    arr(j) = temp\n \
    \                   map(arr(j)) = j\n                    map(arr(j - 1)) = j -\
    \ 1\n                }\n            }\n        }\n        true\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpslhn48_u.scala:36:20 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                    arr(j - \e[31m1\e[0m) = arr(j)\n\e\
    [31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update\
    \ is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpslhn48_u.scala:37:20 ------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m                    arr(j) = temp\n\e[31m\e[31m   |\e[0m \
    \                   ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of\
    \ List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009171
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val dp = Array.fill(n)(0)\n\
    \        for (i <- 0 until n) {\n            var min = Long.MaxValue\n       \
    \     for (j <- 0 until n) {\n                if (arr(j) < min) {\n          \
    \          min = arr(j)\n                    dp(i) = j\n                }\n  \
    \          }\n            arr(dp(i)) = Long.MaxValue\n        }\n        for (i\
    \ <- 1 until n) {\n            if (dp(i) < dp(i - 1)) return false\n        }\n\
    \        return true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpexkoxx6f.scala:32:12 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            arr(dp(i)) = Long.MaxValue\n\e[31m\e[31m\
    \   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n1 error found\n"
  stdout: ''
  timestamp: 1660009171
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.zipWithIndex.sortBy(_._1).map(_._2)\n  \
    \      val arr3 = arr2.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr4 =\
    \ arr3.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr5 = arr4.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr6 = arr5.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr7\
    \ = arr6.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr8 = arr7.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr9 = arr8.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr10\
    \ = arr9.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr11 = arr10.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr12 = arr11.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr13\
    \ = arr12.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr14 = arr13.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr15 = arr14.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr16\
    \ = arr15.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr17 = arr16.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr18 = arr17.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr19\
    \ = arr18.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr20 = arr19.zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val arr21 = arr20.zipWithIndex.sortBy(_._1).map(_._2)\n        val arr22\
    \ = arr21.zipWithIndex.sortBy\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpk5f99264.scala:44:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36marr22\e[0m = arr21.zipWithIndex.sortBy\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0mNo implicit Ordering defined for Any..\n\e[31m   |\e[0mI found:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\
    \e[31m   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[Any]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[Any].\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpk5f99264.scala:45:5 ---------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val m = arr.max\n        val c = arr.count(_ == m)\n  \
    \      if (c == n) return true\n        if (c > 1) return false\n        val i\
    \ = arr.indexOf(m)\n        if (i == 0) return true\n        if (i == n - 1) return\
    \ true\n        if (arr(i - 1) < arr(i + 1)) return true\n        return false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjsiny3jt.scala:35)\n\tat Problem.main(tmpjsiny3jt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009172
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val a = arr.toArray\n\
    \        for (i <- 0 until n - 1) {\n            if (a(i) > a(i + 1)) {\n    \
    \            for (j <- i + 1 until n) {\n                    if (a(j) < a(i))\
    \ {\n                        val temp = a(i)\n                        a(i) = a(j)\n\
    \                        a(j) = temp\n                        return true\n  \
    \                  }\n                }\n                return false\n      \
    \      }\n        }\n        true\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvwxlbe8e.scala:42)\n\tat Problem.main(tmpvwxlbe8e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009173
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = Array.ofDim[Long](n,\
    \ n)\n        for (i <- 0 until n) {\n            m(i)(i) = arr(i)\n         \
    \   for (j <- i + 1 until n) {\n                m(i)(j) = m(i)(j - 1) + arr(j)\n\
    \            }\n        }\n        val dp = Array.ofDim[Boolean](n, n)\n     \
    \   for (i <- 0 until n) {\n            dp(i)(i) = true\n            for (j <-\
    \ i + 1 until n) {\n                dp(i)(j) = false\n            }\n        }\n\
    \        for (l <- 2 to n) {\n            for (i <- 0 to n - l) {\n          \
    \      val j = i + l - 1\n                for (k <- i to j - 1) {\n          \
    \          if (dp(i)(k) && dp(k + 1)(j) && m(i)(k) <= m(k + 1)(j)) {\n       \
    \                 dp(i)(j) = true\n                    }\n                }\n\
    \            }\n        }\n        dp(0)(n - 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpceiqre_5.scala:50)\n\tat Problem.main(tmpceiqre_5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009173
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        var a = arr\n        var i = 0\n      \
    \  while (i < a.length) {\n            if (i == a.length - 1) {\n            \
    \    if (a(i) > a(0)) {\n                    val temp = a(i)\n               \
    \     a = a.updated(i, a(0))\n                    a = a.updated(0, temp)\n   \
    \             }\n            } else {\n                if (a(i) > a(i + 1)) {\n\
    \                    val temp = a(i)\n                    a = a.updated(i, a(i\
    \ + 1))\n                    a = a.updated(i + 1, temp)\n                }\n \
    \           }\n            i += 1\n        }\n        var j = 0\n        while\
    \ (j < a.length - 1) {\n            if (a(j) > a(j + 1)) return false\n      \
    \      j += 1\n        }\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkk5o_oef.scala:48)\n\tat Problem.main(tmpkk5o_oef.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009172
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val a = arr.toArray\n\
    \        var i = n - 1\n        while (i > 0 && a(i - 1) <= a(i)) i -= 1\n   \
    \     if (i == 0) return true\n        while (i < n - 1 && a(i + 1) >= a(i)) i\
    \ += 1\n        if (i == n - 1) return false\n        while (i < n - 1 && a(i\
    \ + 1) <= a(i)) i += 1\n        if (i == n - 1) return true\n        return false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy7pd7ocq.scala:34)\n\tat Problem.main(tmpy7pd7ocq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009173
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val a = arr.toArray\n\
    \        val b = new Array[Long](n)\n        for (i <- 0 until n) {\n        \
    \    b(i) = a(i)\n        }\n        for (i <- 0 until n) {\n            val j\
    \ = i + 1\n            if (j < n && b(i) > b(j)) {\n                val temp =\
    \ b(i)\n                b(i) = b(j)\n                b(j) = temp\n           \
    \     return true\n            }\n        }\n        return false\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvbt9aoag.scala:42)\n\tat Problem.main(tmpvbt9aoag.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009173
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if (arr.length == 0) return true\n    \
    \    var max = arr(0)\n        for (i <- 1 until arr.length) {\n            if\
    \ (arr(i) < max) return false\n            else max = arr(i)\n        }\n    \
    \    return true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkv4zjakk.scala:31)\n\tat Problem.main(tmpkv4zjakk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009116
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if (arr.length == 0) return true\n    \
    \    val min = arr.min\n        val max = arr.max\n        val minIndex = arr.indexOf(min)\n\
    \        val maxIndex = arr.indexOf(max)\n        if (minIndex == 0) return true\n\
    \        if (maxIndex == arr.length - 1) return true\n        if (minIndex ==\
    \ arr.length - 1) return false\n        if (maxIndex == 0) return false\n    \
    \    if (minIndex < maxIndex) return true\n        return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf7237kwx.scala:35)\n\tat Problem.main(tmpf7237kwx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009173
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val a = arr.toArray\n        var i = n - 1\n        while\
    \ (i > 0 && a(i - 1) <= a(i)) i -= 1\n        if (i == 0) return true\n      \
    \  while (i < n - 1 && a(i + 1) >= a(i)) i += 1\n        if (i == n - 1) return\
    \ false\n        return true\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmhpfqkh0.scala:33)\n\tat Problem.main(tmpmhpfqkh0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009173
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val sorted = arr.sorted\n        val sortedReverse\
    \ = arr.sorted.reverse\n        val diff = arr.zip(sorted).map(x => x._1 - x._2).filter(_\
    \ != 0)\n        val diffReverse = arr.zip(sortedReverse).map(x => x._1 - x._2).filter(_\
    \ != 0)\n        if (diff.length == 0 || diffReverse.length == 0) true\n     \
    \   else if (diff.length == 1 || diffReverse.length == 1) true\n        else false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv6p2q36y.scala:31)\n\tat Problem.main(tmpv6p2q36y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009173
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val sorted = arr.sorted\n        for (i <- 0 until n) {\n\
    \            val shifted = arr.slice(i, n) ++ arr.slice(0, i)\n            if\
    \ (shifted == sorted) return true\n        }\n        return false\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009174
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        var i = 0\n        var j = 0\n        while (i < n &&\
    \ j < n) {\n            if (arr(i) == sorted(j)) {\n                i += 1\n \
    \               j += 1\n            } else {\n                i += 1\n       \
    \     }\n        }\n        j == n\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsu037vce.scala:37)\n\tat Problem.main(tmpsu037vce.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009173
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val sorted = arr.sorted\n        val diff = new Array[Int](n)\n\
    \        for (i <- 0 until n) {\n            diff(i) = arr.indexOf(sorted(i))\
    \ - i\n        }\n        for (i <- 0 until n) {\n            if (diff(i) < 0)\
    \ return false\n        }\n        val gcd = diff.foldLeft(diff(0))((a, b) =>\
    \ gcd(a, b))\n        return gcd == 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgxmg2_mq.scala:32:51 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mgcd\e[0m = diff.foldLeft(diff(\e\
    [31m0\e[0m))((\e[36ma\e[0m, \e[36mb\e[0m) => gcd(a, b))\n\e[31m\e[31m   |\e[0m\
    \                                                   ^\e[0m\n\e[31m   |\e[0m  \
    \                                        Recursive \e[33mvalue\e[0m \e[35mgcd\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009173
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.sorted\n        var i = 0\n        while\
    \ (i < n) {\n            if (arr(i) != arr2(i)) {\n                if (i == n\
    \ - 1) return false\n                if (arr(i + 1) != arr2(i)) return false\n\
    \                else {\n                    val temp = arr(i)\n             \
    \       arr(i) = arr(i + 1)\n                    arr(i + 1) = temp\n         \
    \           i += 2\n                }\n            }\n            else i += 1\n\
    \        }\n        true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyrp5dj5p.scala:32:20 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    arr(i) = arr(i + \e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update\
    \ is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpyrp5dj5p.scala:33:20 ------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m                    arr(i + \e[31m1\e[0m) = temp\n\e[31m\e\
    [31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009176
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val max = arr.max\n        val min = arr.min\n        if\
    \ (max - min == n - 1) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9czm6ouc.scala:31)\n\tat Problem.main(tmp9czm6ouc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009178
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr2 =\
    \ arr.toArray\n        for (i <- 0 until n) {\n            val temp = arr2(i)\n\
    \            arr2(i) = arr2(n - 1)\n            arr2(n - 1) = temp\n         \
    \   if (arr2.sorted == arr2) return true\n        }\n        return false\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphzqzh01c.scala:33)\n\tat Problem.main(tmphzqzh01c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009178
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if (arr.length == 0) return true\n    \
    \    val sorted = arr.sorted\n        val diff = arr.zip(sorted).map(x => x._1\
    \ - x._2)\n        val max = diff.max\n        val min = diff.min\n        if\
    \ (max - min > 1) return false\n        if (max == min) return true\n        val\
    \ maxIndex = diff.indexOf(max)\n        val minIndex = diff.indexOf(min)\n   \
    \     if (maxIndex == 0) return true\n        if (minIndex == arr.length - 1)\
    \ return true\n        if (maxIndex == arr.length - 1) return false\n        if\
    \ (minIndex == 0) return false\n        if (arr(maxIndex - 1) < arr(maxIndex +\
    \ 1)) return true\n        if (arr(minIndex - 1) < arr(minIndex + 1)) return true\n\
    \        return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmsj9qxzk.scala:40)\n\tat Problem.main(tmpmsj9qxzk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009179
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        val diff = arr.zip(sorted).map(x => x._1 - x._2).toArray\n\
    \        val max = diff.max\n        val min = diff.min\n        if (max - min\
    \ > 1) return false\n        if (max == min) return true\n        val maxIndex\
    \ = diff.indexOf(max)\n        val minIndex = diff.indexOf(min)\n        if (maxIndex\
    \ == 0) return true\n        if (maxIndex == n - 1) return true\n        if (minIndex\
    \ == 0) return true\n        if (minIndex == n - 1) return true\n        if (diff(maxIndex\
    \ - 1) == min) return true\n        if (diff(maxIndex + 1) == min) return true\n\
    \        if (diff(minIndex - 1) == max) return true\n        if (diff(minIndex\
    \ + 1) == max) return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp86uloiok.scala:42)\n\tat Problem.main(tmp86uloiok.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009179
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val sorted\
    \ = arr.sorted\n        val sortedIndex = arr.map(sorted.indexOf(_))\n       \
    \ val maxIndex = sortedIndex.max\n        val minIndex = sortedIndex.min\n   \
    \     if (maxIndex - minIndex == n - 1) {\n            return true\n        }\n\
    \        val maxIndexCount = sortedIndex.count(_ == maxIndex)\n        val minIndexCount\
    \ = sortedIndex.count(_ == minIndex)\n        if (maxIndexCount == 1 && minIndexCount\
    \ == 1) {\n            return true\n        }\n        if (maxIndexCount == 1\
    \ && minIndexCount == 2) {\n            return true\n        }\n        if (maxIndexCount\
    \ == 2 && minIndexCount == 1) {\n            return true\n        }\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfwz7urom.scala:46)\n\tat Problem.main(tmpfwz7urom.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009179
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr2 = arr.toArray\n        val arr3 = arr.toArray\n\
    \        val arr4 = arr.toArray\n        for (i <- 0 until n) {\n            arr2(i)\
    \ = arr(n - 1 - i)\n            arr3(i) = arr(n - 1 - i)\n            arr4(i)\
    \ = arr(n - 1 - i)\n        }\n        for (i <- 0 until n) {\n            arr2(i)\
    \ = arr(n - 1 - i)\n            arr3(i) = arr(n - 1 - i)\n            arr4(i)\
    \ = arr(n - 1 - i)\n        }\n        for (i <- 0 until n) {\n            arr2(i)\
    \ = arr(n - 1 - i)\n            arr3(i) = arr(n - 1 - i)\n            arr4(i)\
    \ = arr(n - 1 - i)\n        }\n        for (i <- 0 until n) {\n            arr2(i)\
    \ = arr(n - 1 - i)\n            arr3(i) = arr(n - 1 - i)\n            arr4(i)\
    \ = arr(n - 1 - i)\n        }\n        for (i <- 0 until n) {\n            arr2(i)\
    \ = arr(n - 1 - i)\n            arr3(i) = arr(n - 1 - i)\n            arr4(i)\
    \ = arr(n - 1 - i)\n        }\n        for (i <- 0 until n) {\n            arr2(i)\
    \ = arr(n - 1 - i)\n            arr3(i) = arr(n - 1 - i)\n            arr4(i)\
    \ = arr(n - 1 - i)\n        }\n        for (i <- 0 until n) {\n            arr2(i)\
    \ = arr(n - 1 - i)\n            arr3(i) = arr(n - 1 - i)\n            arr4(i)\
    \ = arr(n - 1 - i)\n        }\n        for (i <- 0 until n) {\n            arr2(i)\
    \ = arr(n - 1 - i)\n            arr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpadeua93x.scala:75:0 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpadeua93x.scala:74:1\
    \ ---------------------\e[0m\e[0m\n\e[31m74 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpadeua93x.scala:66:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m66 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1660009178
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val a = arr.toArray\n\
    \        val b = new Array[Long](n)\n        for (i <- 0 until n) b(i) = a(i)\n\
    \        for (i <- 0 until n) {\n            val x = a(i)\n            for (j\
    \ <- i + 1 until n) {\n                if (a(j) < x) {\n                    b(i)\
    \ = a(j)\n                    b(j) = x\n                    return b.toList ==\
    \ arr.sorted\n                }\n            }\n        }\n        return false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk8o3_a1p.scala:39)\n\tat Problem.main(tmpk8o3_a1p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009179
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val sorted = arr.sorted\n        var i\
    \ = 0\n        var j = 0\n        while (i < arr.length && j < arr.length) {\n\
    \            if (arr(i) == sorted(j)) {\n                i += 1\n            \
    \    j += 1\n            } else {\n                i += 1\n            }\n   \
    \     }\n        if (j == arr.length) true else false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyv5ys2cl.scala:36)\n\tat Problem.main(tmpyv5ys2cl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009179
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val sorted = arr.sorted\n        for (i <- 0 until n) {\n\
    \            val shifted = arr.slice(i, n) ++ arr.slice(0, i)\n            if\
    \ (shifted == sorted) return true\n        }\n        return false\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009174
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val N = arr.length\n        val a = arr.toArray\n\
    \        var i = 0\n        while (i < N - 1) {\n            if (a(i) > a(i +\
    \ 1)) {\n                val temp = a(i)\n                a(i) = a(i + 1)\n  \
    \              a(i + 1) = temp\n                i += 2\n            } else i +=\
    \ 1\n        }\n        for (i <- 0 until N - 1) if (a(i) > a(i + 1)) return false\n\
    \        true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpok_hy5rv.scala:37)\n\tat Problem.main(tmpok_hy5rv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009179
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val max = arr.max\n\
    \        val min = arr.min\n        val maxIndex = arr.indexOf(max)\n        val\
    \ minIndex = arr.indexOf(min)\n        if (maxIndex == n - 1) {\n            if\
    \ (minIndex == 0) {\n                return false\n            } else {\n    \
    \            return true\n            }\n        } else {\n            return\
    \ true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbu_pc1ud.scala:40)\n\tat Problem.main(tmpbu_pc1ud.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009179
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val sorted = arr.sorted\n        val diff = (sorted, arr).zipped.map(_\
    \ - _)\n        val max = diff.max\n        val min = diff.min\n        if (max\
    \ - min > 1) return false\n        if (max == 0) return true\n        val maxIndex\
    \ = diff.indexOf(max)\n        val minIndex = diff.indexOf(min)\n        if (maxIndex\
    \ == 0) return true\n        if (minIndex == n - 1) return true\n        if (maxIndex\
    \ == n - 1) return true\n        if (minIndex == 0) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp23z6g6_e.scala:39)\n\tat Problem.main(tmp23z6g6_e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009179
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if (arr.size == 0) return true\n      \
    \  val sorted = arr.sorted\n        var i = 0\n        while (i < arr.size) {\n\
    \            if (arr(i) != sorted(i)) {\n                val j = arr.indexOf(sorted(i))\n\
    \                val temp = arr(i)\n                arr(i) = arr(j)\n        \
    \        arr(j) = temp\n                return true\n            }\n         \
    \   i += 1\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5v21zc6l.scala:29:16 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                arr(i) = arr(j)\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5v21zc6l.scala:30:16\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                arr(j) =\
    \ temp\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009179
