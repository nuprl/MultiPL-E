name: HumanEval_129_minPath
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a grid with N rows and N columns (N >= 2) and a positive integer k,\
  \ \n    // each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n    // inclusive appears exactly once on the cells of the grid.\n    //\
  \ You have to find the minimum path of length k in the grid. You can start\n   \
  \ // from any cell, and in each step you can move to any of the neighbor cells,\n\
  \    // in other words, you can go to cells which share an edge with you current\n\
  \    // cell.\n    // Please note that a path of length k means visiting exactly\
  \ k cells (not\n    // necessarily distinct).\n    // You CANNOT go off the grid.\n\
  \    // A path A (of length k) is considered less than a path B (of length k) if\n\
  \    // after making the ordered lists of the values on the cells that A and B go\n\
  \    // through (let's call them lst_A and lst_B), lst_A is lexicographically less\n\
  \    // than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n\
  \    // such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    //\
  \ lst_A[j] = lst_B[j].\n    // It is guaranteed that the answer is unique.\n   \
  \ // Return an ordered list of the values on the cells that the minimum path go\
  \ through.\n    // Examples:\n    def minPath(grid : List[List[Long]], k : Long)\
  \ : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong,\
  \ 8l.toLong, 9l.toLong))), (3l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong),\
  \ List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong,\
  \ 2l.toLong))), (1l)).equals((List[Long](1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong, 7l.toLong,\
  \ 8l.toLong), List[Long](9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong), List[Long](13l.toLong,\
  \ 14l.toLong, 15l.toLong, 16l.toLong))), (4l)).equals((List[Long](1l.toLong, 2l.toLong,\
  \ 1l.toLong, 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong,\
  \ 4l.toLong, 13l.toLong, 10l.toLong), List[Long](5l.toLong, 7l.toLong, 12l.toLong,\
  \ 1l.toLong), List[Long](3l.toLong, 16l.toLong, 11l.toLong, 15l.toLong), List[Long](8l.toLong,\
  \ 14l.toLong, 9l.toLong, 2l.toLong))), (7l)).equals((List[Long](1l.toLong, 10l.toLong,\
  \ 1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](8l.toLong,\
  \ 14l.toLong, 9l.toLong, 2l.toLong), List[Long](6l.toLong, 4l.toLong, 13l.toLong,\
  \ 15l.toLong), List[Long](5l.toLong, 7l.toLong, 1l.toLong, 12l.toLong), List[Long](3l.toLong,\
  \ 10l.toLong, 11l.toLong, 16l.toLong))), (5l)).equals((List[Long](1l.toLong, 7l.toLong,\
  \ 1l.toLong, 7l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](11l.toLong,\
  \ 8l.toLong, 7l.toLong, 2l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong,\
  \ 4l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](12l.toLong,\
  \ 13l.toLong, 10l.toLong, 1l.toLong))), (9l)).equals((List[Long](1l.toLong, 6l.toLong,\
  \ 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](12l.toLong, 13l.toLong, 10l.toLong,\
  \ 1l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](5l.toLong,\
  \ 16l.toLong, 14l.toLong, 4l.toLong), List[Long](11l.toLong, 8l.toLong, 7l.toLong,\
  \ 2l.toLong))), (12l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong,\
  \ 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 4l.toLong),\
  \ List[Long](3l.toLong, 1l.toLong, 5l.toLong), List[Long](6l.toLong, 8l.toLong,\
  \ 9l.toLong))), (8l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong,\
  \ 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong,\
  \ 1l.toLong, 5l.toLong), List[Long](3l.toLong, 8l.toLong, 9l.toLong), List[Long](2l.toLong,\
  \ 7l.toLong, 4l.toLong))), (8l)).equals((List[Long](1l.toLong, 5l.toLong, 1l.toLong,\
  \ 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong), List[Long](3l.toLong, 4l.toLong))), (10l)).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
  \ 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 3l.toLong),\
  \ List[Long](3l.toLong, 2l.toLong))), (10l)).equals((List[Long](1l.toLong, 3l.toLong,\
  \ 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    val l = if (i > 0) dp(i - 1)(j) else List[Long]()\n \
    \                   val u = if (j > 0) dp(i)(j - 1) else List[Long]()\n      \
    \              val lu = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    val lu2 = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    val lu3 = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    val lu4 = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    val lu5 = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    val lu6 = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    val lu7 = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    val lu8 = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    val lu9 = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    val lu10 = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    val lu11 = if (i > 0 && j > 0) dp(i - 1)(j - 1) else List[Long]()\n\
    \                    val lu12", "        val n = grid.length\n        val m =\
    \ grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (i\
    \ == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else if (i == 0)\
    \ dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n                else if (j == 0) dp(i)(j)\
    \ = dp(i - 1)(j) :+ grid(i)(j)\n                else {\n                    val\
    \ up = dp(i - 1)(j) :+ grid(i)(j)\n                    val left = dp(i)(j - 1)\
    \ :+ grid(i)(j)\n                    if (up.length == left.length) {\n       \
    \                 if (up < left) dp(i)(j) = up\n                        else dp(i)(j)\
    \ = left\n                    }\n                    else if (up.length < left.length)\
    \ dp(i)(j) = up\n                    else dp(i)(j) = left\n                }\n\
    \            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (d, i, j) = pq.dequeue\n            if (dp(i)(j) > d) {\n                dp(i)(j)\
    \ = d\n                if (i > 0) pq.enqueue((d + grid(i - 1)(j), i - 1, j))\n\
    \                if (i < n - 1) pq.enqueue((d + grid(i + 1)(j), i + 1, j))\n \
    \               if (j > 0) pq.enqueue((d + grid(i)(j - 1), i, j - 1))\n      \
    \          if (j < m - 1) pq.enqueue((d + grid(i)(j + 1), i, j + 1))\n       \
    \     }\n        }\n        val path = Array.fill(k.toInt)(0)\n        var i =\
    \ 0\n        var j = 0\n        for (t <- 0 until k.toInt) {\n            path(t)\
    \ = grid(i)(j)\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n        \
    \        i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j))\
    \ {\n                i += 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i)(j))\
    \ {\n                j -= 1\n            } else {\n                j += 1\n  \
    \          }\n        }\n        path.toList", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sortWith(_ < _)\n      \
    \          else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sortWith(_\
    \ < _)\n                else {\n                    val l1 = dp(i - 1)(j) :+ grid(i)(j)\n\
    \                    val l2 = dp(i)(j - 1) :+ grid(i)(j)\n                   \
    \ if (l1.length <= k && l2.length <= k) {\n                        if (l1.length\
    \ < l2.length) dp(i)(j) = l1.sortWith(_ < _)\n                        else if\
    \ (l1.length > l2.length) dp(i)(j) = l2.sortWith(_ < _)\n                    \
    \    else {\n                            if (l1.lexicographicCompare(l2)) dp(i)(j)\
    \ = l1.sortWith(_ < _)\n                            else dp(i)(j) = l2.sortWith(_\
    \ < _)\n                        }\n                    }\n                   \
    \ else if (l1.length <= k) dp(i)(j) = l1.sortWith(_ < _)\n                   \
    \ else if (l2.length <= k) dp(i)(j) = l2.sortWith(_ < _)\n                   \
    \ else {\n                        val l3 = dp(i - 1)(j - 1) :+ grid(i)(j)\n  \
    \                      if (l3.length <= k) {\n                            if (l3.length\
    \ < l1.length) dp(i)(j) = l3.sortWith(_ < _)\n                            else\
    \ if (l3.length > l1.length) dp", "        val n = grid.length\n        val m\
    \ = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n       \
    \ val path = Array.fill(n, m)(List[Long]())\n        dp(0)(0) = grid(0)(0)\n \
    \       path(0)(0) = List(grid(0)(0))\n        for (i <- 0 until n; j <- 0 until\
    \ m) {\n            if (i > 0) {\n                if (dp(i - 1)(j) + grid(i)(j)\
    \ < dp(i)(j)) {\n                    dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n  \
    \                  path(i)(j) = path(i - 1)(j) :+ grid(i)(j)\n               \
    \ }\n            }\n            if (j > 0) {\n                if (dp(i)(j - 1)\
    \ + grid(i)(j) < dp(i)(j)) {\n                    dp(i)(j) = dp(i)(j - 1) + grid(i)(j)\n\
    \                    path(i)(j) = path(i)(j - 1) :+ grid(i)(j)\n             \
    \   }\n            }\n        }\n        val result = path(n - 1)(m - 1)\n   \
    \     if (result.length > k) result.take(k.toInt) else result", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(x\
    \ => x._1))\n        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n  \
    \          val (cost, i, j) = pq.dequeue\n            if (i < 0 || i >= n || j\
    \ < 0 || j >= m) {\n                //println(i + \" \" + j)\n               \
    \ //println(cost)\n                //println(dp(i)(j))\n                //println(dp.map(_.toList).toList)\n\
    \                //println(grid.map(_.toList).toList)\n                //println(pq.toList)\n\
    \                //println(pq.size)\n                //println(pq.head)\n    \
    \            //println(pq.tail)\n                //println(pq.tail.head)\n   \
    \             //println(pq.tail.tail.head)\n                //println(pq.tail.tail.tail.head)\n\
    \                //println(pq.tail.tail.tail.tail.head)\n                //println(pq.tail.tail.tail.tail.tail.head)\n\
    \                //println(pq.tail.tail.tail.tail.tail.tail.head)\n          \
    \      //println(pq.tail.tail.tail.tail.tail.tail.tail.head)\n               \
    \ //println(pq.tail.tail.tail.tail.tail.tail.tail.tail.head)\n               \
    \ //println(pq.tail.tail.tail.tail.tail.tail.tail.tail.tail.head)\n          \
    \      //println(pq.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head)\n\
    \                //println(pq.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head)\n\
    \                //println(pq.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head)\n\
    \                //println", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val path = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) {\n                    dp(i)(j)\
    \ = grid(i)(j)\n                    path(i)(j) = List(grid(i)(j))\n          \
    \      }\n                else {\n                    if (i > 0 && dp(i - 1)(j)\
    \ + grid(i)(j) < dp(i)(j)) {\n                        dp(i)(j) = dp(i - 1)(j)\
    \ + grid(i)(j)\n                        path(i)(j) = path(i - 1)(j) :+ grid(i)(j)\n\
    \                    }\n                    if (j > 0 && dp(i)(j - 1) + grid(i)(j)\
    \ < dp(i)(j)) {\n                        dp(i)(j) = dp(i)(j - 1) + grid(i)(j)\n\
    \                        path(i)(j) = path(i)(j - 1) :+ grid(i)(j)\n         \
    \           }\n                }\n            }\n        }\n        path(n - 1)(m\
    \ - 1).take(k.toInt)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = dp(i)(j\
    \ - 1) :+ grid(i)(j)\n                else if (j == 0) dp(i)(j) = dp(i - 1)(j)\
    \ :+ grid(i)(j)\n                else {\n                    val up = dp(i - 1)(j)\
    \ :+ grid(i)(j)\n                    val left = dp(i)(j - 1) :+ grid(i)(j)\n \
    \                   if (up.length == left.length) dp(i)(j) = if (up < left) up\
    \ else left\n                    else dp(i)(j) = if (up.length < left.length)\
    \ up else left\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1).take(k.toInt)", "        // Let's use dynamic programming.\n        //\
    \ Let's define dp(i, j, l) as the minimum path of length l that starts\n     \
    \   // from cell (i, j).\n        // dp(i, j, l) = min(dp(i - 1, j, l - 1), dp(i\
    \ + 1, j, l - 1), dp(i, j - 1, l - 1), dp(i, j + 1, l - 1))\n        // dp(i,\
    \ j, l) = min(dp(i - 1, j, l - 1), dp(i + 1, j, l - 1), dp(i, j - 1, l - 1), dp(i,\
    \ j + 1, l - 1))\n        // dp(i, j, l) = min(dp(i - 1, j, l - 1), dp(i + 1,\
    \ j, l - 1), dp(i, j - 1, l - 1), dp(i, j + 1, l - 1))\n        // dp(i, j, l)\
    \ = min(dp(i - 1, j, l - 1), dp(i + 1, j, l - 1), dp(i, j - 1, l - 1), dp(i, j\
    \ + 1, l - 1))\n        // dp(i, j, l) = min(dp(i - 1, j, l - 1), dp(i + 1, j,\
    \ l - 1), dp(i, j - 1, l - 1), dp(i, j + 1, l - 1))\n        // dp(i, j, l) =\
    \ min(dp(i - 1, j, l - 1), dp(i + 1, j, l - 1), dp(i, j - 1, l - 1), dp(i, j +\
    \ 1, l - 1))\n        // dp(i, j, l) = min(dp(i - 1, j, l - 1), dp(i + 1, j, l\
    \ - 1), dp(i, j - 1, l - 1), dp(i, j + 1, l - 1))\n        // dp(i", "       \
    \ val n = grid.length\n        val dp = Array.fill(n, n)(Long.MaxValue)\n    \
    \    val path = Array.fill(n, n)(List[Long]())\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until n) {\n                if (i == 0 && j == 0) {\n\
    \                    dp(i)(j) = grid(i)(j)\n                    path(i)(j) = List(grid(i)(j))\n\
    \                }\n                else {\n                    if (i > 0 && dp(i\
    \ - 1)(j) < dp(i)(j)) {\n                        dp(i)(j) = dp(i - 1)(j)\n   \
    \                     path(i)(j) = path(i - 1)(j)\n                    }\n   \
    \                 if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n                  \
    \      dp(i)(j) = dp(i)(j - 1)\n                        path(i)(j) = path(i)(j\
    \ - 1)\n                    }\n                    if (i > 0 && j > 0 && dp(i\
    \ - 1)(j - 1) < dp(i)(j)) {\n                        dp(i)(j) = dp(i - 1)(j -\
    \ 1)\n                        path(i)(j) = path(i - 1)(j - 1)\n              \
    \      }\n                    dp(i)(j) += grid(i)(j)\n                    path(i)(j)\
    \ = (path(i)(j) :+ grid(i)(j)).sorted\n                }\n            }\n    \
    \    }\n        val min = dp(n - 1)(n - 1)\n        val minPath = path(n - 1)(n\
    \ - 1)\n        if (minPath.length < k) {\n            val diff = k - minPath.length\n\
    \            val max = minPath.max\n            val result = minPath :+ (max +\
    \ 1 to max + diff).toList\n            result.sorted\n        }\n        else\
    \ minPath", "        val n = grid.length\n        val m = grid(0).length\n   \
    \     val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                dp(i)(j) = List(grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length == k) {\n                  \
    \  val newPath = dp(i - 1)(j) :+ grid(i)(j)\n                    if (newPath <\
    \ dp(i)(j)) dp(i)(j) = newPath\n                }\n                if (j > 0 &&\
    \ dp(i)(j - 1).length == k) {\n                    val newPath = dp(i)(j - 1)\
    \ :+ grid(i)(j)\n                    if (newPath < dp(i)(j)) dp(i)(j) = newPath\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1)", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        dp(0)(0) = 0\n        for (i <- 0 until n; j <- 0\
    \ until m) {\n            if (i > 0) dp(i)(j) = min(dp(i)(j), dp(i - 1)(j) + grid(i)(j))\n\
    \            if (j > 0) dp(i)(j) = min(dp(i)(j), dp(i)(j - 1) + grid(i)(j))\n\
    \        }\n        val result = ListBuffer[Long]()\n        var i = n - 1\n \
    \       var j = m - 1\n        while (k > 0) {\n            result += grid(i)(j)\n\
    \            k -= 1\n            if (i > 0 && dp(i - 1)(j) + grid(i)(j) == dp(i)(j))\
    \ i -= 1\n            else if (j > 0 && dp(i)(j - 1) + grid(i)(j) == dp(i)(j))\
    \ j -= 1\n        }\n        result.toList", "        val n = grid.length\n  \
    \      val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    val neighbors = List((i - 1, j), (i, j - 1), (i + 1,\
    \ j), (i, j + 1)).filter(p => p._1 >= 0 && p._1 < n && p._2 >= 0 && p._2 < m)\n\
    \                    val min = neighbors.map(p => dp(p._1)(p._2)).filter(_.length\
    \ == k - 1).map(lst => lst :+ grid(i)(j)).sortWith((lst1, lst2) => lst1.mkString\
    \ < lst2.mkString).headOption\n                    dp(i)(j) = min.getOrElse(List[Long]())\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1)", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    val l = if (i > 0) dp(i - 1)(j) else\
    \ List[Long]()\n                    val r = if (j > 0) dp(i)(j - 1) else List[Long]()\n\
    \                    if (l.length == 0 && r.length == 0) dp(i)(j) = List(grid(i)(j))\n\
    \                    else if (l.length == 0) dp(i)(j) = r :+ grid(i)(j)\n    \
    \                else if (r.length == 0) dp(i)(j) = l :+ grid(i)(j)\n        \
    \            else {\n                        if (l < r) dp(i)(j) = l :+ grid(i)(j)\n\
    \                        else dp(i)(j) = r :+ grid(i)(j)\n                   \
    \ }\n                }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val ans = ArrayBuffer[Long]()\n \
    \       var i = 0\n        var j = 0\n        while (ans.length < k) {\n     \
    \       ans += grid(i)(j)\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n\
    \                i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j))\
    \ {\n                i += 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i)(j))\
    \ {\n                j -= 1\n            } else if (j < m - 1 && dp(i)(j + 1)\
    \ < dp(i)(j)) {\n                j += 1\n            }\n        }\n        ans.toList",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                dp(i)(j) = List(grid(i)(j))\n                if (i > 0\
    \ && dp(i - 1)(j).length < k && dp(i - 1)(j) < dp(i)(j)) dp(i)(j) = dp(i - 1)(j)\n\
    \                if (j > 0 && dp(i)(j - 1).length < k && dp(i)(j - 1) < dp(i)(j))\
    \ dp(i)(j) = dp(i)(j - 1)\n            }\n        }\n        dp(n - 1)(m - 1)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    var lst = List[Long]()\n          \
    \          if (i > 0) lst = dp(i - 1)(j)\n                    if (j > 0 && (lst.isEmpty\
    \ || lst.last > dp(i)(j - 1).last)) lst = dp(i)(j - 1)\n                    dp(i)(j)\
    \ = lst :+ grid(i)(j)\n                }\n            }\n        }\n        dp(n\
    \ - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(x => x._1))\n        pq.enqueue((0, 0, 0))\n      \
    \  while (!pq.isEmpty) {\n            val (cost, i, j) = pq.dequeue\n        \
    \    if (i < 0 || i >= n || j < 0 || j >= m) throw new Exception\n           \
    \ if (dp(i)(j) <= cost) {\n                if (dp(i)(j) == cost) {\n         \
    \           if (grid(i)(j) < grid(0)(0)) {\n                        dp(0)(0) =\
    \ cost\n                        pq.enqueue((cost, 0, 0))\n                   \
    \ }\n                }\n                continue\n            }\n            dp(i)(j)\
    \ = cost\n            if (i > 0) pq.enqueue((cost + grid(i - 1)(j), i - 1, j))\n\
    \            if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j), i + 1, j))\n  \
    \          if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i, j - 1))\n        \
    \    if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i, j + 1))\n        }\n\
    \        val result = ArrayBuffer[Long]()\n        var i = 0\n        var j =\
    \ 0\n        var cost = 0L\n        while (result.length < k) {\n            result\
    \ += grid(i)(j)\n            val next = ArrayBuffer[(Long, Int, Int)]()\n    \
    \        if (i > 0) next += ((cost + grid(i - 1)(j), i - 1, j))\n            if\
    \ (i < n - 1) next += ((cost + grid(i + 1)(j), i + 1, j))\n            if (j >\
    \ 0) next += ((cost + grid(i)(j - 1), i, j - 1))\n            if (j < m - 1)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    if (i > 0) {\n                    \
    \    val lst = dp(i - 1)(j)\n                        if (lst.length < k) dp(i)(j)\
    \ = lst :+ grid(i)(j)\n                        else if (lst.length == k) {\n \
    \                           if (lst.last > grid(i)(j)) dp(i)(j) = lst.init :+\
    \ grid(i)(j)\n                        }\n                    }\n             \
    \       if (j > 0) {\n                        val lst = dp(i)(j - 1)\n       \
    \                 if (lst.length < k) {\n                            if (dp(i)(j).length\
    \ < k) dp(i)(j) = lst :+ grid(i)(j)\n                            else if (dp(i)(j).length\
    \ == k) {\n                                if (dp(i)(j).last > grid(i)(j)) dp(i)(j)\
    \ = lst :+ grid(i)(j)\n                            }\n                       \
    \ }\n                        else if (lst.length == k) {\n                   \
    \         if (lst.last > grid(i)(j)) {\n                                if (dp(i)(j).length\
    \ < k) dp(i)(j) = lst.init :+ grid(i)(j)\n                                else\
    \ if (dp(i)(j).length == k) {\n                                    if (dp(i)(j).last\
    \ > grid(i)(j)) dp(i)(j) = lst.init :+ grid(i)(j)\n                          \
    \      }\n                            }\n                        }\n         \
    \           }\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1)", "        val n = grid.length\n        val m = grid(0).length\n      \
    \  val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n \
    \           for (j <- 0 until m) {\n                if (i == 0 && j == 0) dp(i)(j)\
    \ = List(grid(i)(j))\n                else {\n                    if (i > 0) {\n\
    \                        val lst = dp(i - 1)(j)\n                        if (lst.length\
    \ < k) dp(i)(j) = lst :+ grid(i)(j)\n                        else if (lst.length\
    \ == k) {\n                            val lst2 = lst :+ grid(i)(j)\n        \
    \                    if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n                  \
    \      }\n                    }\n                    if (j > 0) {\n          \
    \              val lst = dp(i)(j - 1)\n                        if (lst.length\
    \ < k) dp(i)(j) = lst :+ grid(i)(j)\n                        else if (lst.length\
    \ == k) {\n                            val lst2 = lst :+ grid(i)(j)\n        \
    \                    if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n                  \
    \      }\n                    }\n                }\n            }\n        }\n\
    \        dp(n - 1)(m - 1)", "        val n = grid.length\n        val dp = Array.fill(n,\
    \ n)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < n - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        var j = 0\n        while (result.length < k) {\n \
    \           result += grid(i)(j)\n            if (i > 0 && dp(i - 1)(j) < dp(i\
    \ + 1)(j) && dp(i - 1)(j) < dp(i)(j - 1) && dp(i - 1)(j) < dp(i)(j + 1)) {\n \
    \               i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j) < dp(i\
    \ - 1)(j) && dp(i + 1)(j) < dp(i)(j - 1) && dp(i + 1)(j) < dp(i)(j + 1)) {\n \
    \               i += 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i -\
    \ 1)(j) && dp(i)(j - 1) < dp(i + 1)(j) && dp(i)(j - 1) < dp(i)(j + 1", "     \
    \   val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(x\
    \ => x._1))\n        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n  \
    \          val (d, i, j) = pq.dequeue\n            if (dp(i)(j) > d) {\n     \
    \           dp(i)(j) = d\n                if (i > 0) pq.enqueue((d + grid(i -\
    \ 1)(j), i - 1, j))\n                if (i < n - 1) pq.enqueue((d + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((d + grid(i)(j - 1), i, j\
    \ - 1))\n                if (j < m - 1) pq.enqueue((d + grid(i)(j + 1), i, j +\
    \ 1))\n            }\n        }\n        val pq2 = new PriorityQueue[(Long, Int,\
    \ Int)]()(Ordering.by(x => x._1))\n        pq2.enqueue((0, 0, 0))\n        val\
    \ visited = Array.fill(n, m)(false)\n        while (pq2.nonEmpty) {\n        \
    \    val (d, i, j) = pq2.dequeue\n            if (!visited(i)(j)) {\n        \
    \        visited(i)(j) = true\n                if (i > 0 && dp(i - 1)(j) == d\
    \ + grid(i - 1)(j)) pq2.enqueue((d + grid(i - 1)(j), i - 1, j))\n            \
    \    if (i < n - 1 && dp(i + 1)(j) == d + grid(i + 1)(j)) pq2.enqueue((d + grid(i\
    \ + 1)(j), i + 1, j))\n                if (j > 0 && dp(i)(j - 1) == d + grid(i)(j\
    \ - 1)) pq2.en", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted\n                else if (j == 0) dp(i)(j) = (dp(i\
    \ - 1)(j) :+ grid(i)(j)).sorted\n                else {\n                    val\
    \ lst1 = dp(i - 1)(j) :+ grid(i)(j)\n                    val lst2 = dp(i)(j -\
    \ 1) :+ grid(i)(j)\n                    dp(i)(j) = if (lst1.sorted < lst2.sorted)\
    \ lst1 else lst2\n                }\n            }\n        }\n        dp(n -\
    \ 1)(m - 1).take(k.toInt)", "        val n = grid.length\n        val dp = Array.fill(n,\
    \ n)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ n) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    val neighbors = List((i - 1, j), (i,\
    \ j - 1), (i + 1, j), (i, j + 1)).filter(p => p._1 >= 0 && p._1 < n && p._2 >=\
    \ 0 && p._2 < n)\n                    val paths = neighbors.map(p => (p, dp(p._1)(p._2)))\n\
    \                    val minPath = paths.filter(p => p._2.length < k).minBy(p\
    \ => p._2 :+ grid(i)(j))\n                    dp(i)(j) = minPath._2 :+ grid(i)(j)\n\
    \                }\n            }\n        }\n        dp(n - 1)(n - 1)", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val prev = Array.fill(n, m)(-1)\n        val queue\
    \ = new mutable.PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until m) {\n              \
    \  queue.enqueue((grid(i)(j), i, j))\n            }\n        }\n        while\
    \ (queue.nonEmpty) {\n            val (v, i, j) = queue.dequeue\n            if\
    \ (dp(i)(j) > v) {\n                dp(i)(j) = v\n                if (i > 0) {\n\
    \                    queue.enqueue((v + grid(i - 1)(j), i - 1, j))\n         \
    \       }\n                if (i < n - 1) {\n                    queue.enqueue((v\
    \ + grid(i + 1)(j), i + 1, j))\n                }\n                if (j > 0)\
    \ {\n                    queue.enqueue((v + grid(i)(j - 1), i, j - 1))\n     \
    \           }\n                if (j < m - 1) {\n                    queue.enqueue((v\
    \ + grid(i)(j + 1), i, j + 1))\n                }\n            }\n        }\n\
    \        var i = 0\n        var j = 0\n        var path = List[Long]()\n     \
    \   while (path.length < k) {\n            path = path :+ grid(i)(j)\n       \
    \     if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n                i -= 1\n      \
    \      } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j)) {\n                i +=\
    \ 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n            \
    \    j -= 1\n            } else if (j < m - 1 && dp(i)(j + 1) < dp(i)(j)) {\n\
    \                j += 1\n            }", "        val n = grid.length\n      \
    \  val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n \
    \       pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        var j = 0\n        while (result.length < k) {\n \
    \           result += grid(i)(j)\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j))\
    \ {\n                i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j)\
    \ < dp(i)(j)) {\n                i += 1\n            } else if (j > 0 && dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                j -= 1\n            } else if (j < m - 1\
    \ && dp(i)(j + 1) < dp(i)(j)) {\n                j += 1\n            }\n     \
    \   }\n        result.toList", "        val n = grid.length\n        val dp =\
    \ Array.fill(n, n)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int,\
    \ Int)]()(Ordering.by(_._1))\n        for (i <- 0 until n) {\n            dp(i)(i)\
    \ = grid(i)(i)\n            pq.enqueue((dp(i)(i), i, i))\n        }\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until n) {\n                if (i\
    \ != j) {\n                    dp(i)(j) = dp(j)(j) + grid(i)(j)\n            \
    \        pq.enqueue((dp(i)(j), i, j))\n                }\n            }\n    \
    \    }\n        val result = new ListBuffer[Long]()\n        for (i <- 0 until\
    \ k.toInt) {\n            val (cost, x, y) = pq.dequeue\n            result +=\
    \ grid(x)(y)\n            for (i <- 0 until n) {\n                if (dp(i)(y)\
    \ > cost + grid(i)(y)) {\n                    dp(i)(y) = cost + grid(i)(y)\n \
    \                   pq.enqueue((dp(i)(y), i, y))\n                }\n        \
    \    }\n            for (j <- 0 until n) {\n                if (dp(x)(j) > cost\
    \ + grid(x)(j)) {\n                    dp(x)(j) = cost + grid(x)(j)\n        \
    \            pq.enqueue((dp(x)(j), x, j))\n                }\n            }\n\
    \        }\n        result.toList", "        val n = grid.length\n        val\
    \ dp = Array.fill(n, n)(Array.fill(k.toInt + 1)(Long.MaxValue))\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until n) {\n                dp(i)(j)(1)\
    \ = grid(i)(j)\n            }\n        }\n        for (l <- 2 to k.toInt) {\n\
    \            for (i <- 0 until n) {\n                for (j <- 0 until n) {\n\
    \                    if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l\
    \ - 1) + grid(i)(j))\n                    if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i + 1)(j)(l - 1) + grid(i)(j))\n                    if (j > 0) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i)(j - 1)(l - 1) + grid(i)(j))\n                    if\
    \ (j < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j + 1)(l - 1) + grid(i)(j))\n\
    \                }\n            }\n        }\n        var min = Long.MaxValue\n\
    \        var minI = -1\n        var minJ = -1\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until n) {\n                if (dp(i)(j)(k.toInt) < min)\
    \ {\n                    min = dp(i)(j)(k.toInt)\n                    minI = i\n\
    \                    minJ = j\n                }\n            }\n        }\n \
    \       var i = minI\n        var j = minJ\n        var l = k.toInt\n        val\
    \ result = ListBuffer[Long]()\n        while (l > 0) {\n            result +=\
    \ grid(i)(j)\n            l -= 1\n            if (i > 0 && dp(i)(j)(l) == dp(i\
    \ - 1)(j", "        val n = grid.length\n        val m = grid(0).length\n    \
    \    val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (i == 0 && j == 0) dp(i)(j)\
    \ = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (dp(i)(j - 1)\
    \ :+ grid(i)(j)).sorted\n                else if (j == 0) dp(i)(j) = (dp(i - 1)(j)\
    \ :+ grid(i)(j)).sorted\n                else {\n                    val l1 =\
    \ dp(i - 1)(j) :+ grid(i)(j)\n                    val l2 = dp(i)(j - 1) :+ grid(i)(j)\n\
    \                    if (l1.length <= k && l2.length <= k) {\n               \
    \         if (l1.sorted < l2.sorted) dp(i)(j) = l1.sorted\n                  \
    \      else dp(i)(j) = l2.sorted\n                    }\n                    else\
    \ if (l1.length <= k) dp(i)(j) = l1.sorted\n                    else if (l2.length\
    \ <= k) dp(i)(j) = l2.sorted\n                    else dp(i)(j) = List[Long]()\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1)", "   \
    \     val n = grid.length\n        val dp = Array.fill(n, n)(Long.MaxValue)\n\
    \        val prev = Array.fill(n, n)(-1)\n        val q = new Queue[(Int, Int)]\n\
    \        for (i <- 0 until n) {\n            dp(i)(0) = grid(i)(0)\n         \
    \   q.enqueue((i, 0))\n        }\n        while (!q.isEmpty) {\n            val\
    \ (i, j) = q.dequeue\n            if (j == n - 1) {\n                if (dp(i)(j)\
    \ <= k) {\n                    val path = new ListBuffer[Long]\n             \
    \       var cur = i\n                    while (cur != -1) {\n               \
    \         path += grid(cur)(j)\n                        cur = prev(cur)(j)\n \
    \                   }\n                    return path.toList.reverse\n      \
    \          }\n            } else {\n                if (i > 0 && dp(i - 1)(j +\
    \ 1) > dp(i)(j) + grid(i - 1)(j + 1)) {\n                    dp(i - 1)(j + 1)\
    \ = dp(i)(j) + grid(i - 1)(j + 1)\n                    prev(i - 1)(j + 1) = i\n\
    \                    q.enqueue((i - 1, j + 1))\n                }\n          \
    \      if (i < n - 1 && dp(i + 1)(j + 1) > dp(i)(j) + grid(i + 1)(j + 1)) {\n\
    \                    dp(i + 1)(j + 1) = dp(i)(j) + grid(i + 1)(j + 1)\n      \
    \              prev(i + 1)(j + 1) = i\n                    q.enqueue((i + 1, j\
    \ + 1))\n                }\n            }\n        }\n        return List()",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                else {\n                    dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                    if (dp(i)(j - 1).length < dp(i)(j).length) dp(i)(j) = (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted\n                    else if (dp(i)(j - 1).length\
    \ == dp(i)(j).length) {\n                        for (t <- 0 until dp(i)(j).length)\
    \ {\n                            if (dp(i)(j - 1)(t) < dp(i)(j)(t)) {\n      \
    \                          dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n  \
    \                              break\n                            }\n        \
    \                }\n                    }\n                }\n            }\n\
    \        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        val dp2 = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ {\n                    dp(i)(j) = List(grid(i)(j))\n                    dp2(i)(j)\
    \ = List(grid(i)(j))\n                } else if (i == 0) {\n                 \
    \   dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n                    dp2(i)(j) = dp2(i)(j\
    \ - 1) :+ grid(i)(j)\n                } else if (j == 0) {\n                 \
    \   dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n                    dp2(i)(j) = dp2(i\
    \ - 1)(j) :+ grid(i)(j)\n                } else {\n                    val l1\
    \ = dp(i - 1)(j) :+ grid(i)(j)\n                    val l2 = dp(i)(j - 1) :+ grid(i)(j)\n\
    \                    if (l1.length == l2.length) {\n                        if\
    \ (l1 < l2) {\n                            dp(i)(j) = l1\n                   \
    \         dp2(i)(j) = l2\n                        } else {\n                 \
    \           dp(i)(j) = l2\n                            dp2(i)(j) = l1\n      \
    \                  }\n                    } else if (l1.length < l2.length) {\n\
    \                        dp(i)(j) = l1\n                        dp2(i)(j) = l2\n\
    \                    } else {\n                        dp(i)(j) = l2\n       \
    \                 dp2(i)(j) = l1\n                    }\n                }\n \
    \           }\n        }\n        if (dp(n - 1)(m - 1).length <= k) return dp(n\
    \ - 1)(", "        val n = grid.length\n        val m = grid(0).length\n     \
    \   val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                if (i == 0 && j == 0) dp(i)(j)\
    \ = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (dp(i)(j - 1)\
    \ :+ grid(i)(j)).sorted\n                else if (j == 0) dp(i)(j) = (dp(i - 1)(j)\
    \ :+ grid(i)(j)).sorted\n                else {\n                    val a = dp(i)(j\
    \ - 1) :+ grid(i)(j)\n                    val b = dp(i - 1)(j) :+ grid(i)(j)\n\
    \                    if (a.sorted < b.sorted) dp(i)(j) = a.sorted\n          \
    \          else dp(i)(j) = b.sorted\n                }\n            }\n      \
    \  }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, x, y) = pq.dequeue\n            if (dp(x)(y) > cost) {\n            \
    \    dp(x)(y) = cost\n                if (x > 0) pq.enqueue((cost + grid(x - 1)(y),\
    \ x - 1, y))\n                if (x < n - 1) pq.enqueue((cost + grid(x + 1)(y),\
    \ x + 1, y))\n                if (y > 0) pq.enqueue((cost + grid(x)(y - 1), x,\
    \ y - 1))\n                if (y < m - 1) pq.enqueue((cost + grid(x)(y + 1), x,\
    \ y + 1))\n            }\n        }\n        val result = new ListBuffer[Long]\n\
    \        var x = 0\n        var y = 0\n        for (i <- 0 until k.toInt) {\n\
    \            result += grid(x)(y)\n            if (x > 0 && dp(x - 1)(y) + grid(x)(y)\
    \ == dp(x)(y)) {\n                x -= 1\n            } else if (x < n - 1 &&\
    \ dp(x + 1)(y) + grid(x)(y) == dp(x)(y)) {\n                x += 1\n         \
    \   } else if (y > 0 && dp(x)(y - 1) + grid(x)(y) == dp(x)(y)) {\n           \
    \     y -= 1\n            } else if (y < m - 1 && dp(x)(y + 1) + grid(x)(y) ==\
    \ dp(x)(y)) {\n                y += 1\n            }\n        }\n        result.toList",
  "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    if (i > 0) {\n                        val lst = dp(i\
    \ - 1)(j)\n                        if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n\
    \                        else if (lst.length == k) dp(i)(j) = lst :+ grid(i)(j)\n\
    \                        else {\n                            val newLst = lst.tail\
    \ :+ grid(i)(j)\n                            if (newLst < dp(i)(j)) dp(i)(j) =\
    \ newLst\n                        }\n                    }\n                 \
    \   if (j > 0) {\n                        val lst = dp(i)(j - 1)\n           \
    \             if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n             \
    \           else if (lst.length == k) dp(i)(j) = lst :+ grid(i)(j)\n         \
    \               else {\n                            val newLst = lst.tail :+ grid(i)(j)\n\
    \                            if (newLst < dp(i)(j)) dp(i)(j) = newLst\n      \
    \                  }\n                    }\n                }\n            }\n\
    \        }\n        dp(n - 1)(n - 1)", "        // The idea is to use dynamic\
    \ programming.\n        // Let dp(i, j, l) be the minimum path of length l starting\
    \ from cell (i, j).\n        // dp(i, j, l) = min(dp(i - 1, j, l - 1), dp(i +\
    \ 1, j, l - 1), dp(i, j - 1, l - 1), dp(i, j + 1, l - 1))\n        // dp(i, j,\
    \ l) = min(dp(i - 1, j, l - 1), dp(i + 1, j, l - 1), dp(i, j - 1, l - 1), dp(i,\
    \ j + 1, l - 1))\n        // dp(i, j, l) = min(dp(i - 1, j, l - 1), dp(i + 1,\
    \ j, l - 1), dp(i, j - 1, l - 1), dp(i, j + 1, l - 1))\n        // dp(i, j, l)\
    \ = min(dp(i - 1, j, l - 1), dp(i + 1, j, l - 1), dp(i, j - 1, l - 1), dp(i, j\
    \ + 1, l - 1))\n        // dp(i, j, l) = min(dp(i - 1, j, l - 1), dp(i + 1, j,\
    \ l - 1), dp(i, j - 1, l - 1), dp(i, j + 1, l - 1))\n        // dp(i, j, l) =\
    \ min(dp(i - 1, j, l - 1), dp(i + 1, j, l - 1), dp(i, j - 1, l - 1), dp(i, j +\
    \ 1, l - 1))\n        // dp(i, j, l) = min(dp(i - 1, j, l - 1), dp(i + 1, j, l\
    \ - 1), dp(i, j - 1, l - 1), dp(i, j + 1, l - 1))\n        // dp(i, j, l", " \
    \       val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    if (i > 0) {\n                        val lst = dp(i\
    \ - 1)(j)\n                        if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n\
    \                        else if (lst.length == k) {\n                       \
    \     val lst2 = lst :+ grid(i)(j)\n                            if (lst2 < dp(i)(j))\
    \ dp(i)(j) = lst2\n                        }\n                    }\n        \
    \            if (j > 0) {\n                        val lst = dp(i)(j - 1)\n  \
    \                      if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n    \
    \                    else if (lst.length == k) {\n                           \
    \ val lst2 = lst :+ grid(i)(j)\n                            if (lst2 < dp(i)(j))\
    \ dp(i)(j) = lst2\n                        }\n                    }\n        \
    \        }\n            }\n        }\n        dp(n - 1)(n - 1)", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n      \
    \          else if (j == 0) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n          \
    \      else {\n                    val a = dp(i - 1)(j) :+ grid(i)(j)\n      \
    \              val b = dp(i)(j - 1) :+ grid(i)(j)\n                    if (a <\
    \ b) dp(i)(j) = a\n                    else dp(i)(j) = b\n                }\n\
    \            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        //\
    \ The idea is to use dynamic programming.\n        // Let dp(i, j, l) be the minimum\
    \ path of length l starting from cell (i, j).\n        // dp(i, j, l) = min(dp(i\
    \ - 1, j, l - 1), dp(i + 1, j, l - 1), dp(i, j - 1, l - 1), dp(i, j + 1, l - 1))\n\
    \        // dp(i, j, l) = min(dp(i - 1, j, l - 1), dp(i + 1, j, l - 1), dp(i,\
    \ j - 1, l - 1), dp(i, j + 1, l - 1))\n        // dp(i, j, l) = min(dp(i - 1,\
    \ j, l - 1), dp(i + 1, j, l - 1), dp(i, j - 1, l - 1), dp(i, j + 1, l - 1))\n\
    \        // dp(i, j, l) = min(dp(i - 1, j, l - 1), dp(i + 1, j, l - 1), dp(i,\
    \ j - 1, l - 1), dp(i, j + 1, l - 1))\n        // dp(i, j, l) = min(dp(i - 1,\
    \ j, l - 1), dp(i + 1, j, l - 1), dp(i, j - 1, l - 1), dp(i, j + 1, l - 1))\n\
    \        // dp(i, j, l) = min(dp(i - 1, j, l - 1), dp(i + 1, j, l - 1), dp(i,\
    \ j - 1, l - 1), dp(i, j + 1, l - 1))\n        // dp(i, j, l) = min(dp(i - 1,\
    \ j, l - 1), dp(i + 1, j, l - 1), dp(i, j - 1, l - 1), dp(i, j + 1, l - 1))\n\
    \        // dp(i, j, l", "        val n = grid.length\n        val dp = Array.fill(n,\
    \ n)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, x, y) = pq.dequeue\n            if (dp(x)(y) > cost) {\n            \
    \    dp(x)(y) = cost\n                if (x > 0) pq.enqueue((cost + grid(x - 1)(y),\
    \ x - 1, y))\n                if (x < n - 1) pq.enqueue((cost + grid(x + 1)(y),\
    \ x + 1, y))\n                if (y > 0) pq.enqueue((cost + grid(x)(y - 1), x,\
    \ y - 1))\n                if (y < n - 1) pq.enqueue((cost + grid(x)(y + 1), x,\
    \ y + 1))\n            }\n        }\n        val ans = ArrayBuffer[Long]()\n \
    \       var x = 0\n        var y = 0\n        var cost = 0L\n        for (i <-\
    \ 0 until k.toInt) {\n            ans += grid(x)(y)\n            if (x > 0 &&\
    \ dp(x - 1)(y) < cost + grid(x - 1)(y)) {\n                cost += grid(x - 1)(y)\n\
    \                x -= 1\n            } else if (x < n - 1 && dp(x + 1)(y) < cost\
    \ + grid(x + 1)(y)) {\n                cost += grid(x + 1)(y)\n              \
    \  x += 1\n            } else if (y > 0 && dp(x)(y - 1) < cost + grid(x)(y - 1))\
    \ {\n                cost += grid(x)(y - 1)\n                y -= 1\n        \
    \    } else if (y < n - 1 && dp(x)(y + 1) < cost + grid(x)(y + 1)) {\n       \
    \         cost += grid(x)(y + 1)\n                y += 1\n            }\n    \
    \    }\n        ans.toList\n", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (grid(i)(j)\
    \ :: dp(i)(j - 1)).sorted\n                else if (j == 0) dp(i)(j) = (grid(i)(j)\
    \ :: dp(i - 1)(j)).sorted\n                else {\n                    val a =\
    \ (grid(i)(j) :: dp(i)(j - 1)).sorted\n                    val b = (grid(i)(j)\
    \ :: dp(i - 1)(j)).sorted\n                    if (a < b) dp(i)(j) = a\n     \
    \               else dp(i)(j) = b\n                }\n            }\n        }\n\
    \        dp(n - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n     \
    \   val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, x, y) = pq.dequeue\n            if (dp(x)(y) > cost) {\n            \
    \    dp(x)(y) = cost\n                if (x > 0) pq.enqueue((cost + grid(x - 1)(y),\
    \ x - 1, y))\n                if (x < n - 1) pq.enqueue((cost + grid(x + 1)(y),\
    \ x + 1, y))\n                if (y > 0) pq.enqueue((cost + grid(x)(y - 1), x,\
    \ y - 1))\n                if (y < m - 1) pq.enqueue((cost + grid(x)(y + 1), x,\
    \ y + 1))\n            }\n        }\n        val result = new ListBuffer[Long]\n\
    \        var x = 0\n        var y = 0\n        var cost = 0L\n        for (i <-\
    \ 0 until k.toInt) {\n            result += grid(x)(y)\n            if (x > 0\
    \ && dp(x - 1)(y) < cost + grid(x - 1)(y)) {\n                cost += grid(x -\
    \ 1)(y)\n                x -= 1\n            } else if (x < n - 1 && dp(x + 1)(y)\
    \ < cost + grid(x + 1)(y)) {\n                cost += grid(x + 1)(y)\n       \
    \         x += 1\n            } else if (y > 0 && dp(x)(y - 1) < cost + grid(x)(y\
    \ - 1)) {\n                cost += grid(x)(y - 1)\n                y -= 1\n  \
    \          } else if (y < m - 1 && dp(x)(y + 1) < cost + grid(x)(y + 1)) {\n \
    \               cost += grid(x)(y + 1)\n                y += 1\n            }",
  "        val n = grid.length\n        val dp = Array.fill(n, n)(Long.MaxValue)\n\
    \        val path = Array.fill(n, n)(List[Long]())\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until n) {\n                if (i == 0 && j ==\
    \ 0) {\n                    dp(i)(j) = grid(i)(j)\n                    path(i)(j)\
    \ = List(grid(i)(j))\n                }\n                else {\n            \
    \        if (i > 0 && dp(i - 1)(j) + grid(i)(j) < dp(i)(j)) {\n              \
    \          dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n                        path(i)(j)\
    \ = path(i - 1)(j) :+ grid(i)(j)\n                    }\n                    if\
    \ (j > 0 && dp(i)(j - 1) + grid(i)(j) < dp(i)(j)) {\n                        dp(i)(j)\
    \ = dp(i)(j - 1) + grid(i)(j)\n                        path(i)(j) = path(i)(j\
    \ - 1) :+ grid(i)(j)\n                    }\n                }\n            }\n\
    \        }\n        path(n - 1)(n - 1).take(k.toInt)", "        val n = grid.length\n\
    \        val dp = Array.fill(n, n)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        pq.enqueue((0, 0, 0))\n        while\
    \ (pq.nonEmpty) {\n            val (cost, i, j) = pq.dequeue\n            if (dp(i)(j)\
    \ > cost) {\n                dp(i)(j) = cost\n                if (i + 1 < n) pq.enqueue((cost\
    \ + grid(i + 1)(j), i + 1, j))\n                if (j + 1 < n) pq.enqueue((cost\
    \ + grid(i)(j + 1), i, j + 1))\n            }\n        }\n        val path = new\
    \ ArrayBuffer[Long]()\n        var i = 0\n        var j = 0\n        while (k\
    \ > 0) {\n            path += grid(i)(j)\n            if (i + 1 < n && dp(i +\
    \ 1)(j) < dp(i)(j + 1)) {\n                i += 1\n            } else {\n    \
    \            j += 1\n            }\n            k -= 1\n        }\n        path.toList",
  "        val n = grid.length\n        val dp = Array.fill(n, n)(Long.MaxValue)\n\
    \        val prev = Array.fill(n, n)(-1)\n        val queue = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        val dx = List(-1, 0, 1, 0)\n     \
    \   val dy = List(0, -1, 0, 1)\n        for (i <- 0 until n) {\n            for\
    \ (j <- 0 until n) {\n                dp(i)(j) = grid(i)(j)\n                queue.enqueue((dp(i)(j),\
    \ i, j))\n            }\n        }\n        for (i <- 0 until n) {\n         \
    \   for (j <- 0 until n) {\n                for (d <- 0 until 4) {\n         \
    \           val x = i + dx(d)\n                    val y = j + dy(d)\n       \
    \             if (x >= 0 && x < n && y >= 0 && y < n) {\n                    \
    \    if (dp(x)(y) > dp(i)(j) + grid(x)(y)) {\n                            dp(x)(y)\
    \ = dp(i)(j) + grid(x)(y)\n                            prev(x)(y) = i * n + j\n\
    \                            queue.enqueue((dp(x)(y), x, y))\n               \
    \         }\n                    }\n                }\n            }\n       \
    \ }\n        val result = new ListBuffer[Long]()\n        var cur = queue.dequeue\n\
    \        for (i <- 0 until k - 1) {\n            result += grid(cur._2)(cur._3)\n\
    \            cur = (dp(prev(cur._2)(cur._3) / n)(prev(cur._2)(cur._3) % n) + grid(cur._2)(cur._3),\
    \ prev(cur._2)(cur._3) / n, prev(cur._2)(cur._3) % n)\n        }\n        result\
    \ += grid(cur._2)(cur._3)\n        result.toList", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sortWith(_ < _)\n      \
    \          else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sortWith(_\
    \ < _)\n                else {\n                    val a = dp(i - 1)(j) :+ grid(i)(j)\n\
    \                    val b = dp(i)(j - 1) :+ grid(i)(j)\n                    if\
    \ (a.length <= k && b.length <= k) dp(i)(j) = if (a < b) a else b\n          \
    \          else if (a.length <= k) dp(i)(j) = a\n                    else if (b.length\
    \ <= k) dp(i)(j) = b\n                    else dp(i)(j) = if (a < b) a else b\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                else {\n                    val a = dp(i)(j - 1) :+ grid(i)(j)\n\
    \                    val b = dp(i - 1)(j) :+ grid(i)(j)\n                    if\
    \ (a.sorted < b.sorted) dp(i)(j) = a.sorted\n                    else dp(i)(j)\
    \ = b.sorted\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1).take(k.toInt)", "        val n = grid.length\n        val dp = Array.fill(n,\
    \ n)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(x\
    \ => x._1))\n        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n  \
    \          val (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n\
    \                dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost\
    \ + grid(i - 1)(j), i - 1, j))\n                if (i < n - 1) pq.enqueue((cost\
    \ + grid(i + 1)(j), i + 1, j))\n                if (j > 0) pq.enqueue((cost +\
    \ grid(i)(j - 1), i, j - 1))\n                if (j < n - 1) pq.enqueue((cost\
    \ + grid(i)(j + 1), i, j + 1))\n            }\n        }\n        val path = Array.fill(k.toInt)(0)\n\
    \        var i = 0\n        var j = 0\n        for (t <- 0 until k.toInt) {\n\
    \            path(t) = grid(i)(j)\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j))\
    \ {\n                i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j)\
    \ < dp(i)(j)) {\n                i += 1\n            } else if (j > 0 && dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                j -= 1\n            } else {\n         \
    \       j += 1\n            }\n        }\n        path.toList", "        val n\
    \ = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until n) {\n                dp(i)(j)\
    \ = List(grid(i)(j))\n                if (i > 0 && dp(i - 1)(j).length < k &&\
    \ dp(i - 1)(j).last < grid(i)(j)) {\n                    val newList = dp(i -\
    \ 1)(j) :+ grid(i)(j)\n                    if (newList.length < dp(i)(j).length\
    \ || (newList.length == dp(i)(j).length && newList < dp(i)(j))) dp(i)(j) = newList\n\
    \                }\n                if (j > 0 && dp(i)(j - 1).length < k && dp(i)(j\
    \ - 1).last < grid(i)(j)) {\n                    val newList = dp(i)(j - 1) :+\
    \ grid(i)(j)\n                    if (newList.length < dp(i)(j).length || (newList.length\
    \ == dp(i)(j).length && newList < dp(i)(j))) dp(i)(j) = newList\n            \
    \    }\n            }\n        }\n        dp(n - 1)(n - 1)", "        val n =\
    \ grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    var lst = List[Long]()\n          \
    \          if (i > 0) lst = dp(i - 1)(j)\n                    if (j > 0 && (lst.isEmpty\
    \ || lst.last > dp(i)(j - 1).last)) lst = dp(i)(j - 1)\n                    dp(i)(j)\
    \ = lst :+ grid(i)(j)\n                }\n            }\n        }\n        dp(n\
    \ - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)((List[Long](), Long.MaxValue))\n        for\
    \ (i <- 0 until n; j <- 0 until m) {\n            if (i == 0 && j == 0) dp(i)(j)\
    \ = (List(grid(i)(j)), grid(i)(j))\n            else {\n                if (i\
    \ > 0) {\n                    val (lst, sum) = dp(i - 1)(j)\n                \
    \    if (sum + grid(i)(j) < dp(i)(j)._2) dp(i)(j) = (grid(i)(j) :: lst, sum +\
    \ grid(i)(j))\n                }\n                if (j > 0) {\n             \
    \       val (lst, sum) = dp(i)(j - 1)\n                    if (sum + grid(i)(j)\
    \ < dp(i)(j)._2) dp(i)(j) = (grid(i)(j) :: lst, sum + grid(i)(j))\n          \
    \      }\n            }\n        }\n        dp(n - 1)(m - 1)._1", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    val up = if (i > 0) dp(i - 1)(j) else\
    \ List[Long]()\n                    val left = if (j > 0) dp(i)(j - 1) else List[Long]()\n\
    \                    if (up.length == 0 && left.length == 0) dp(i)(j) = List(grid(i)(j))\n\
    \                    else if (up.length == 0) dp(i)(j) = left :+ grid(i)(j)\n\
    \                    else if (left.length == 0) dp(i)(j) = up :+ grid(i)(j)\n\
    \                    else {\n                        val up_sum = up.sum\n   \
    \                     val left_sum = left.sum\n                        if (up_sum\
    \ < left_sum) dp(i)(j) = up :+ grid(i)(j)\n                        else if (up_sum\
    \ > left_sum) dp(i)(j) = left :+ grid(i)(j)\n                        else {\n\
    \                            val up_min = up.min\n                           \
    \ val left_min = left.min\n                            if (up_min < left_min)\
    \ dp(i)(j) = up :+ grid(i)(j)\n                            else if (up_min > left_min)\
    \ dp(i)(j) = left :+ grid(i)(j)\n                            else {\n        \
    \                        val up_max = up.max\n                               \
    \ val left_max = left.max\n                                if (up_max < left_max)\
    \ dp(i)(j) = up :+ grid(i)(j)\n                                else if (up_max\
    \ > left_max) dp(i)(j) = left :+ grid(i)(j)\n                                else\
    \ {\n                                    val up_max_index = up.indexOf(up_max",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i + 1 < n) pq.enqueue((cost + grid(i\
    \ + 1)(j), i + 1, j))\n                if (j + 1 < m) pq.enqueue((cost + grid(i)(j\
    \ + 1), i, j + 1))\n            }\n        }\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        var j = 0\n        while (result.length < k) {\n \
    \           result += grid(i)(j)\n            if (i + 1 < n && dp(i + 1)(j) <\
    \ dp(i)(j + 1)) {\n                i += 1\n            } else {\n            \
    \    j += 1\n            }\n        }\n        result.toList", "        val n\
    \ = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until n) {\n                if (i\
    \ == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else {\n      \
    \              val lst = ListBuffer[List[Long]]()\n                    if (i >\
    \ 0) lst += dp(i - 1)(j)\n                    if (j > 0) lst += dp(i)(j - 1)\n\
    \                    if (i > 0 && j > 0) lst += dp(i - 1)(j - 1)\n           \
    \         val min = lst.minBy(x => (x :+ grid(i)(j)).mkString)\n             \
    \       dp(i)(j) = min :+ grid(i)(j)\n                }\n            }\n     \
    \   }\n        dp(n - 1)(n - 1).take(k.toInt)", "        val n = grid.length\n\
    \        val dp = Array.fill(n, n)(Long.MaxValue)\n        val prev = Array.fill(n,\
    \ n)(-1)\n        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n\
    \                if (i == 0 && j == 0) {\n                    dp(i)(j) = grid(i)(j)\n\
    \                } else if (i == 0) {\n                    dp(i)(j) = dp(i)(j\
    \ - 1) + grid(i)(j)\n                    prev(i)(j) = 1\n                } else\
    \ if (j == 0) {\n                    dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n  \
    \                  prev(i)(j) = 0\n                } else {\n                \
    \    if (dp(i - 1)(j) < dp(i)(j - 1)) {\n                        dp(i)(j) = dp(i\
    \ - 1)(j) + grid(i)(j)\n                        prev(i)(j) = 0\n             \
    \       } else {\n                        dp(i)(j) = dp(i)(j - 1) + grid(i)(j)\n\
    \                        prev(i)(j) = 1\n                    }\n             \
    \   }\n            }\n        }\n        val path = new ListBuffer[Long]\n   \
    \     var i = n - 1\n        var j = n - 1\n        while (k > 0) {\n        \
    \    path += grid(i)(j)\n            k -= 1\n            if (prev(i)(j) == 0)\
    \ i -= 1\n            else j -= 1\n        }\n        path.toList", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(x\
    \ => x._1))\n        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n  \
    \          val (cost, i, j) = pq.dequeue\n            if (i < 0 || i >= n || j\
    \ < 0 || j >= m) {\n                // out of bounds\n            } else if (dp(i)(j)\
    \ <= cost) {\n                // already visited\n            } else {\n     \
    \           dp(i)(j) = cost\n                if (cost < k) {\n               \
    \     pq.enqueue((cost + 1, i + 1, j))\n                    pq.enqueue((cost +\
    \ 1, i - 1, j))\n                    pq.enqueue((cost + 1, i, j + 1))\n      \
    \              pq.enqueue((cost + 1, i, j - 1))\n                }\n         \
    \   }\n        }\n        val result = ArrayBuffer[Long]()\n        var i = 0\n\
    \        var j = 0\n        while (result.length < k) {\n            result +=\
    \ grid(i)(j)\n            if (i + 1 < n && dp(i + 1)(j) == dp(i)(j) + 1) {\n \
    \               i += 1\n            } else if (i - 1 >= 0 && dp(i - 1)(j) == dp(i)(j)\
    \ + 1) {\n                i -= 1\n            } else if (j + 1 < m && dp(i)(j\
    \ + 1) == dp(i)(j) + 1) {\n                j += 1\n            } else if (j -\
    \ 1 >= 0 && dp(i)(j - 1) == dp(i)(j) + 1) {\n                j -= 1\n        \
    \    }\n        }\n        result.toList", "        val n = grid.length\n    \
    \    val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        val queue = new Queue[(Int, Int)]\n        for (i <- 0 until n) {\n \
    \           for (j <- 0 until m) {\n                if (grid(i)(j) == 1) {\n \
    \                   dp(i)(j) = List(1)\n                    queue.enqueue((i,\
    \ j))\n                }\n            }\n        }\n        while (!queue.isEmpty)\
    \ {\n            val (i, j) = queue.dequeue\n            val lst = dp(i)(j)\n\
    \            if (lst.length == k) return lst\n            if (i > 0 && dp(i -\
    \ 1)(j).length == 0) {\n                dp(i - 1)(j) = lst :+ grid(i - 1)(j)\n\
    \                queue.enqueue((i - 1, j))\n            }\n            if (i <\
    \ n - 1 && dp(i + 1)(j).length == 0) {\n                dp(i + 1)(j) = lst :+\
    \ grid(i + 1)(j)\n                queue.enqueue((i + 1, j))\n            }\n \
    \           if (j > 0 && dp(i)(j - 1).length == 0) {\n                dp(i)(j\
    \ - 1) = lst :+ grid(i)(j - 1)\n                queue.enqueue((i, j - 1))\n  \
    \          }\n            if (j < m - 1 && dp(i)(j + 1).length == 0) {\n     \
    \           dp(i)(j + 1) = lst :+ grid(i)(j + 1)\n                queue.enqueue((i,\
    \ j + 1))\n            }\n        }\n        return List[Long]()", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n      \
    \          else if (j == 0) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n          \
    \      else {\n                    val l1 = dp(i - 1)(j) :+ grid(i)(j)\n     \
    \               val l2 = dp(i)(j - 1) :+ grid(i)(j)\n                    if (l1\
    \ < l2) dp(i)(j) = l1\n                    else dp(i)(j) = l2\n              \
    \  }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n      \
    \          else if (j == 0) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n          \
    \      else {\n                    val up = dp(i - 1)(j) :+ grid(i)(j)\n     \
    \               val left = dp(i)(j - 1) :+ grid(i)(j)\n                    if\
    \ (up.length < left.length) dp(i)(j) = up\n                    else if (up.length\
    \ > left.length) dp(i)(j) = left\n                    else dp(i)(j) = if (up <\
    \ left) up else left\n                }\n            }\n        }\n        dp(n\
    \ - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                val lst = List(grid(i)(j))\n\
    \                if (i == 0 && j == 0) dp(i)(j) = lst\n                else if\
    \ (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n                else\
    \ if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n               \
    \ else {\n                    val lst1 = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                    val lst2 = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n        \
    \            dp(i)(j) = if (lst1 < lst2) lst1 else lst2\n                }\n \
    \           }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val path = Array.fill(n, m)(List[Long]())\n     \
    \   for (i <- 0 until n) {\n            for (j <- 0 until m) {\n             \
    \   if (i == 0 && j == 0) {\n                    dp(i)(j) = grid(i)(j)\n     \
    \               path(i)(j) = List(grid(i)(j))\n                }\n           \
    \     else {\n                    if (i > 0 && dp(i - 1)(j) + grid(i)(j) < dp(i)(j))\
    \ {\n                        dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n          \
    \              path(i)(j) = path(i - 1)(j) :+ grid(i)(j)\n                   \
    \ }\n                    if (j > 0 && dp(i)(j - 1) + grid(i)(j) < dp(i)(j)) {\n\
    \                        dp(i)(j) = dp(i)(j - 1) + grid(i)(j)\n              \
    \          path(i)(j) = path(i)(j - 1) :+ grid(i)(j)\n                    }\n\
    \                }\n            }\n        }\n        path(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    val l = if (i > 0) dp(i - 1)(j) else\
    \ List[Long]()\n                    val r = if (j > 0) dp(i)(j - 1) else List[Long]()\n\
    \                    if (l.length == 0) dp(i)(j) = r :+ grid(i)(j)\n         \
    \           else if (r.length == 0) dp(i)(j) = l :+ grid(i)(j)\n             \
    \       else {\n                        val cmp = compare(l, r)\n            \
    \            if (cmp < 0) dp(i)(j) = l :+ grid(i)(j)\n                       \
    \ else if (cmp > 0) dp(i)(j) = r :+ grid(i)(j)\n                        else dp(i)(j)\
    \ = min(l, r) :+ grid(i)(j)\n                    }\n                }\n      \
    \      }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val n =\
    \ grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n      \
    \          else if (j == 0) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n          \
    \      else {\n                    val a = dp(i - 1)(j) :+ grid(i)(j)\n      \
    \              val b = dp(i)(j - 1) :+ grid(i)(j)\n                    if (a.length\
    \ == b.length) {\n                        if (a.compare(b) < 0) dp(i)(j) = a\n\
    \                        else dp(i)(j) = b\n                    }\n          \
    \          else if (a.length < b.length) dp(i)(j) = a\n                    else\
    \ dp(i)(j) = b\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1).take(k.toInt)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                dp(i)(j) = List(grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length <= k && dp(i - 1)(j).length\
    \ < dp(i)(j).length) {\n                    dp(i)(j) = dp(i - 1)(j)\n        \
    \        }\n                if (j > 0 && dp(i)(j - 1).length <= k && dp(i)(j -\
    \ 1).length < dp(i)(j).length) {\n                    dp(i)(j) = dp(i)(j - 1)\n\
    \                }\n                if (dp(i)(j).length < k) {\n             \
    \       dp(i)(j) = dp(i)(j) :+ grid(i)(j)\n                }\n            }\n\
    \        }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n        val\
    \ dp = Array.fill(n, n)(List[Long]())\n        for (i <- 0 until n) {\n      \
    \      for (j <- 0 until n) {\n                val x = grid(i)(j)\n          \
    \      if (i == 0 && j == 0) dp(i)(j) = List(x)\n                else if (i ==\
    \ 0) {\n                    val y = grid(i)(j - 1)\n                    if (x\
    \ < y) dp(i)(j) = x :: dp(i)(j - 1)\n                    else dp(i)(j) = y ::\
    \ dp(i)(j - 1)\n                }\n                else if (j == 0) {\n      \
    \              val y = grid(i - 1)(j)\n                    if (x < y) dp(i)(j)\
    \ = x :: dp(i - 1)(j)\n                    else dp(i)(j) = y :: dp(i - 1)(j)\n\
    \                }\n                else {\n                    val y = grid(i\
    \ - 1)(j)\n                    val z = grid(i)(j - 1)\n                    val\
    \ lst = List(x :: dp(i - 1)(j), y :: dp(i)(j - 1), z :: dp(i - 1)(j - 1))\n  \
    \                  dp(i)(j) = lst.minBy(x => x.mkString(\"\"))\n             \
    \   }\n            }\n        }\n        dp(n - 1)(n - 1).take(k.toInt)", "  \
    \      val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (i < 0 || i >= n || j < 0 || j >=\
    \ m) {\n                if (cost < dp(i)(j)) {\n                    dp(i)(j) =\
    \ cost\n                    if (i - 1 >= 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                    if (i + 1 < n) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                    if (j - 1 >= 0) pq.enqueue((cost + grid(i)(j\
    \ - 1), i, j - 1))\n                    if (j + 1 < m) pq.enqueue((cost + grid(i)(j\
    \ + 1), i, j + 1))\n                }\n            }\n        }\n        val result\
    \ = new ListBuffer[Long]\n        var i = 0\n        var j = 0\n        while\
    \ (k > 0) {\n            result += grid(i)(j)\n            k -= 1\n          \
    \  if (i - 1 >= 0 && dp(i - 1)(j) < dp(i)(j)) {\n                i -= 1\n    \
    \        } else if (i + 1 < n && dp(i + 1)(j) < dp(i)(j)) {\n                i\
    \ += 1\n            } else if (j - 1 >= 0 && dp(i)(j - 1) < dp(i)(j)) {\n    \
    \            j -= 1\n            } else if (j + 1 < m && dp(i)(j + 1) < dp(i)(j))\
    \ {\n                j += 1\n            }\n        }\n        result.toList",
  "        val n = grid.length\n        val dp = Array.fill(n, n)(Long.MaxValue)\n\
    \        val parent = Array.fill(n, n)((-1, -1))\n        val queue = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        queue.enqueue((0, 0, 0))\n       \
    \ while (!queue.isEmpty) {\n            val (cost, i, j) = queue.dequeue\n   \
    \         if (dp(i)(j) > cost) {\n                dp(i)(j) = cost\n          \
    \      if (i > 0) {\n                    queue.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                    parent(i - 1)(j) = (i, j)\n                }\n\
    \                if (i < n - 1) {\n                    queue.enqueue((cost + grid(i\
    \ + 1)(j), i + 1, j))\n                    parent(i + 1)(j) = (i, j)\n       \
    \         }\n                if (j > 0) {\n                    queue.enqueue((cost\
    \ + grid(i)(j - 1), i, j - 1))\n                    parent(i)(j - 1) = (i, j)\n\
    \                }\n                if (j < n - 1) {\n                    queue.enqueue((cost\
    \ + grid(i)(j + 1), i, j + 1))\n                    parent(i)(j + 1) = (i, j)\n\
    \                }\n            }\n        }\n        val path = ListBuffer[Long]()\n\
    \        var (i, j) = (n - 1, n - 1)\n        while (k > 0) {\n            path\
    \ += grid(i)(j)\n            val (x, y) = parent(i)(j)\n            i = x\n  \
    \          j = y\n            k -= 1\n        }\n        path.toList", "     \
    \   val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val path = Array.fill(n, m)(List[Long]())\n     \
    \   for (i <- 0 until n) {\n            for (j <- 0 until m) {\n             \
    \   if (i == 0 && j == 0) {\n                    dp(i)(j) = grid(i)(j)\n     \
    \               path(i)(j) = List(grid(i)(j))\n                }\n           \
    \     else {\n                    if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n  \
    \                      dp(i)(j) = dp(i - 1)(j)\n                        path(i)(j)\
    \ = path(i - 1)(j)\n                    }\n                    if (j > 0 && dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                        dp(i)(j) = dp(i)(j - 1)\n      \
    \                  path(i)(j) = path(i)(j - 1)\n                    }\n      \
    \              dp(i)(j) += grid(i)(j)\n                    path(i)(j) = (path(i)(j)\
    \ :+ grid(i)(j)).sorted\n                }\n            }\n        }\n       \
    \ val result = path(n - 1)(m - 1)\n        if (result.length > k) result.take(k.toInt)\
    \ else result", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = dp(i)(j\
    \ - 1) :+ grid(i)(j)\n                else if (j == 0) dp(i)(j) = dp(i - 1)(j)\
    \ :+ grid(i)(j)\n                else {\n                    val l1 = dp(i - 1)(j)\
    \ :+ grid(i)(j)\n                    val l2 = dp(i)(j - 1) :+ grid(i)(j)\n   \
    \                 if (l1 < l2) dp(i)(j) = l1\n                    else dp(i)(j)\
    \ = l2\n                }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        dp(i)(j) = List(grid(i)(j))\n                if (i > 0 && dp(i - 1)(j).length\
    \ < k && dp(i - 1)(j) < dp(i)(j)) dp(i)(j) = dp(i - 1)(j)\n                if\
    \ (j > 0 && dp(i)(j - 1).length < k && dp(i)(j - 1) < dp(i)(j)) dp(i)(j) = dp(i)(j\
    \ - 1)\n            }\n        }\n        dp(n - 1)(n - 1)", "        val n =\
    \ grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sortWith(_\
    \ < _)\n                else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sortWith(_\
    \ < _)\n                else {\n                    val a = dp(i - 1)(j) :+ grid(i)(j)\n\
    \                    val b = dp(i)(j - 1) :+ grid(i)(j)\n                    if\
    \ (a.length <= k && b.length <= k) {\n                        if (a.length < b.length)\
    \ dp(i)(j) = a.sortWith(_ < _)\n                        else if (a.length > b.length)\
    \ dp(i)(j) = b.sortWith(_ < _)\n                        else dp(i)(j) = if (a\
    \ < b) a else b\n                    }\n                    else if (a.length\
    \ <= k) dp(i)(j) = a.sortWith(_ < _)\n                    else if (b.length <=\
    \ k) dp(i)(j) = b.sortWith(_ < _)\n                    else {\n              \
    \          val a1 = a.take(k.toInt).sortWith(_ < _)\n                        val\
    \ b1 = b.take(k.toInt).sortWith(_ < _)\n                        if (a1 < b1) dp(i)(j)\
    \ = a1\n                        else dp(i)(j) = b1\n                    }\n  \
    \              }\n            }\n        }\n        dp(n - 1)(m - 1)", "     \
    \   val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                dp(i)(j) = List(grid(i)(j))\n                if (i > 0\
    \ && dp(i - 1)(j).length < k) {\n                    val lst = dp(i - 1)(j) :+\
    \ grid(i)(j)\n                    if (lst.length < dp(i)(j).length || (lst.length\
    \ == dp(i)(j).length && lst < dp(i)(j))) dp(i)(j) = lst\n                }\n \
    \               if (j > 0 && dp(i)(j - 1).length < k) {\n                    val\
    \ lst = dp(i)(j - 1) :+ grid(i)(j)\n                    if (lst.length < dp(i)(j).length\
    \ || (lst.length == dp(i)(j).length && lst < dp(i)(j))) dp(i)(j) = lst\n     \
    \           }\n            }\n        }\n        dp(n - 1)(m - 1)", "        val\
    \ n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until n) {\n                if (i\
    \ == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else {\n      \
    \              if (i > 0) {\n                        val lst = dp(i - 1)(j)\n\
    \                        if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n  \
    \                      else if (lst.length == k) {\n                         \
    \   val lst2 = lst :+ grid(i)(j)\n                            if (lst2 < dp(i)(j))\
    \ dp(i)(j) = lst2\n                        }\n                    }\n        \
    \            if (j > 0) {\n                        val lst = dp(i)(j - 1)\n  \
    \                      if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n    \
    \                    else if (lst.length == k) {\n                           \
    \ val lst2 = lst :+ grid(i)(j)\n                            if (lst2 < dp(i)(j))\
    \ dp(i)(j) = lst2\n                        }\n                    }\n        \
    \        }\n            }\n        }\n        dp(n - 1)(n - 1)", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, x, y) = pq.dequeue\n            if (dp(x)(y) > cost) {\n            \
    \    dp(x)(y) = cost\n                if (x > 0) pq.enqueue((cost + grid(x - 1)(y),\
    \ x - 1, y))\n                if (x < n - 1) pq.enqueue((cost + grid(x + 1)(y),\
    \ x + 1, y))\n                if (y > 0) pq.enqueue((cost + grid(x)(y - 1), x,\
    \ y - 1))\n                if (y < m - 1) pq.enqueue((cost + grid(x)(y + 1), x,\
    \ y + 1))\n            }\n        }\n        val result = new ListBuffer[Long]\n\
    \        var x = 0\n        var y = 0\n        var cost = 0L\n        for (i <-\
    \ 0 until k.toInt) {\n            result += grid(x)(y)\n            if (x > 0\
    \ && dp(x - 1)(y) < cost + grid(x - 1)(y)) {\n                cost += grid(x -\
    \ 1)(y)\n                x -= 1\n            } else if (x < n - 1 && dp(x + 1)(y)\
    \ < cost + grid(x + 1)(y)) {\n                cost += grid(x + 1)(y)\n       \
    \         x += 1\n            } else if (y > 0 && dp(x)(y - 1) < cost + grid(x)(y\
    \ - 1)) {\n                cost += grid(x)(y - 1)\n                y -= 1\n  \
    \          } else if (y < m - 1 && dp(x)(y + 1) < cost + grid(x)(y + 1)) {\n \
    \               cost += grid(x)(y + 1)\n                y += 1\n            }",
  "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        dp(i)(j) = List(grid(i)(j))\n                if (i > 0 && dp(i - 1)(j).length\
    \ <= k && dp(i - 1)(j).length + 1 < dp(i)(j).length) {\n                    dp(i)(j)\
    \ = grid(i)(j) :: dp(i - 1)(j)\n                }\n                if (j > 0 &&\
    \ dp(i)(j - 1).length <= k && dp(i)(j - 1).length + 1 < dp(i)(j).length) {\n \
    \                   dp(i)(j) = grid(i)(j) :: dp(i)(j - 1)\n                }\n\
    \            }\n        }\n        dp(n - 1)(n - 1)", "        val n = grid.length\n\
    \        val dp = Array.fill(n, n)(Long.MaxValue)\n        val prev = Array.fill(n,\
    \ n)(-1)\n        val next = Array.fill(n, n)(-1)\n        val queue = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        for (i <- 0 until n) {\n         \
    \   for (j <- 0 until n) {\n                dp(i)(j) = grid(i)(j)\n          \
    \      queue.enqueue((dp(i)(j), i, j))\n            }\n        }\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until n) {\n                if (i\
    \ > 0) {\n                    if (dp(i - 1)(j) > dp(i)(j)) {\n               \
    \         dp(i - 1)(j) = dp(i)(j)\n                        prev(i - 1)(j) = i\
    \ * n + j\n                        next(i)(j) = (i - 1) * n + j\n            \
    \        }\n                }\n                if (i < n - 1) {\n            \
    \        if (dp(i + 1)(j) > dp(i)(j)) {\n                        dp(i + 1)(j)\
    \ = dp(i)(j)\n                        prev(i + 1)(j) = i * n + j\n           \
    \             next(i)(j) = (i + 1) * n + j\n                    }\n          \
    \      }\n                if (j > 0) {\n                    if (dp(i)(j - 1) >\
    \ dp(i)(j)) {\n                        dp(i)(j - 1) = dp(i)(j)\n             \
    \           prev(i)(j - 1) = i * n + j\n                        next(i)(j) = i\
    \ * n + j - 1\n                    }\n                }\n                if (j\
    \ < n - 1) {\n                    if (dp(i)(j + 1) > dp(i)(j)) {\n           \
    \             dp(i)(j + 1) = dp(i)(j)\n                        prev(i)(j + 1)\
    \ = i * n + j\n                        next(i)(j) =", "        // Let's use dynamic\
    \ programming.\n        // Let dp(i, j, l) be the minimum path of length l starting\
    \ from cell (i, j).\n        // Then dp(i, j, l) = min(dp(i - 1, j, l - 1), dp(i\
    \ + 1, j, l - 1), dp(i, j - 1, l - 1), dp(i, j + 1, l - 1))\n        // + grid(i)(j)\n\
    \        // We can use a 3D array to store the values of dp.\n        // Time\
    \ complexity: O(n ^ 3)\n        val n = grid.length\n        val dp = Array.ofDim[Long](n,\
    \ n, k.toInt + 1)\n        for (i <- 0 until n; j <- 0 until n) {\n          \
    \  dp(i)(j)(1) = grid(i)(j)\n        }\n        for (l <- 2 to k.toInt) {\n  \
    \          for (i <- 0 until n; j <- 0 until n) {\n                var min = Long.MaxValue\n\
    \                if (i > 0) min = min min dp(i - 1)(j)(l - 1)\n              \
    \  if (i < n - 1) min = min min dp(i + 1)(j)(l - 1)\n                if (j > 0)\
    \ min = min min dp(i)(j - 1)(l - 1)\n                if (j < n - 1) min = min\
    \ min dp(i)(j + 1)(l - 1)\n                dp(i)(j)(l) = min + grid(i)(j)\n  \
    \          }\n        }\n        var min = Long.MaxValue\n        var minI = -1\n\
    \        var minJ = -1\n        for (i <- 0 until n; j <- 0 until n) {\n     \
    \       if (dp(i)(j)(k.toInt) < min) {\n                min = dp(i)(j)(k.toInt)\n\
    \                minI = i\n                minJ = j\n            }\n        }\n\
    \        var i = minI\n        var j = minJ\n        var l = k.toInt\n       \
    \ val result = ListBuffer[Long]", "        val n = grid.length\n        val dp\
    \ = Array.fill(n, n)(List[Long]())\n        for (i <- 0 until n) {\n         \
    \   for (j <- 0 until n) {\n                val v = grid(i)(j)\n             \
    \   val l = List(v)\n                dp(i)(j) = l\n                if (i > 0)\
    \ {\n                    val u = grid(i - 1)(j)\n                    if (v < u)\
    \ {\n                        val l2 = dp(i - 1)(j)\n                        if\
    \ (l2.length < k) {\n                            val l3 = l ::: l2\n         \
    \                   if (l3.length < dp(i)(j).length) dp(i)(j) = l3\n         \
    \               }\n                    }\n                }\n                if\
    \ (j > 0) {\n                    val u = grid(i)(j - 1)\n                    if\
    \ (v < u) {\n                        val l2 = dp(i)(j - 1)\n                 \
    \       if (l2.length < k) {\n                            val l3 = l ::: l2\n\
    \                            if (l3.length < dp(i)(j).length) dp(i)(j) = l3\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n        dp(n - 1)(n - 1)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(-1L)\n    \
    \    val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n    \
    \    pq.enqueue((grid(0)(0), 0, 0))\n        dp(0)(0) = grid(0)(0)\n        while\
    \ (pq.nonEmpty) {\n            val (v, i, j) = pq.dequeue\n            if (i ==\
    \ n - 1 && j == m - 1) return List.fill(k.toInt)(v)\n            if (i + 1 < n\
    \ && dp(i + 1)(j) == -1) {\n                dp(i + 1)(j) = v + grid(i + 1)(j)\n\
    \                pq.enqueue((dp(i + 1)(j), i + 1, j))\n            }\n       \
    \     if (j + 1 < m && dp(i)(j + 1) == -1) {\n                dp(i)(j + 1) = v\
    \ + grid(i)(j + 1)\n                pq.enqueue((dp(i)(j + 1), i, j + 1))\n   \
    \         }\n        }\n        return List()", "        val n = grid.length\n\
    \        val dp = Array.fill(n, n)(Long.MaxValue)\n        val prev = Array.fill(n,\
    \ n)(List[(Int, Int)]())\n        for (i <- 0 until n) {\n            for (j <-\
    \ 0 until n) {\n                if (i == 0 && j == 0) {\n                    dp(i)(j)\
    \ = grid(i)(j)\n                    prev(i)(j) = List((i, j))\n              \
    \  }\n                else {\n                    if (i > 0 && dp(i - 1)(j) <\
    \ dp(i)(j)) {\n                        dp(i)(j) = dp(i - 1)(j)\n             \
    \           prev(i)(j) = prev(i - 1)(j)\n                    }\n             \
    \       if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n                        dp(i)(j)\
    \ = dp(i)(j - 1)\n                        prev(i)(j) = prev(i)(j - 1)\n      \
    \              }\n                    dp(i)(j) += grid(i)(j)\n               \
    \     prev(i)(j) = (i, j) :: prev(i)(j)\n                }\n            }\n  \
    \      }\n        var cur = (n - 1, n - 1)\n        var ans = List[Long]()\n \
    \       for (i <- 0 until k.toInt) {\n            ans = grid(cur._1)(cur._2) ::\
    \ ans\n            cur = prev(cur._1)(cur._2).head\n        }\n        ans", " \
    \       val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    val l = if (i > 0) dp(i - 1)(j) else List[Long]()\n \
    \                   val u = if (j > 0) dp(i)(j - 1) else List[Long]()\n      \
    \              if (l.length == 0 && u.length == 0) dp(i)(j) = List(grid(i)(j))\n\
    \                    else if (l.length == 0) dp(i)(j) = u :+ grid(i)(j)\n    \
    \                else if (u.length == 0) dp(i)(j) = l :+ grid(i)(j)\n        \
    \            else if (l.length < u.length) dp(i)(j) = l :+ grid(i)(j)\n      \
    \              else if (l.length > u.length) dp(i)(j) = u :+ grid(i)(j)\n    \
    \                else {\n                        var flag = true\n           \
    \             for (x <- 0 until l.length) {\n                            if (l(x)\
    \ < u(x)) {\n                                dp(i)(j) = l :+ grid(i)(j)\n    \
    \                            flag = false\n                                break\n\
    \                            }\n                            else if (l(x) > u(x))\
    \ {\n                                dp(i)(j) = u :+ grid(i)(j)\n            \
    \                    flag = false\n                                break\n   \
    \                         }\n                        }\n                     \
    \   if (flag) dp(i)(j) = l :+ grid(i)(j)\n                    }\n            \
    \    }\n            }\n        }\n        dp(n - 1)(n - 1).take(k.toInt)", " \
    \       val n = grid.length\n        val dp = Array.fill(n, n)(Long.MaxValue)\n\
    \        val prev = Array.fill(n, n)(-1)\n        for (i <- 0 until n) {\n   \
    \         for (j <- 0 until n) {\n                if (i == 0 && j == 0) {\n  \
    \                  dp(i)(j) = grid(i)(j)\n                } else if (i == 0) {\n\
    \                    dp(i)(j) = dp(i)(j - 1) + grid(i)(j)\n                  \
    \  prev(i)(j) = 1\n                } else if (j == 0) {\n                    dp(i)(j)\
    \ = dp(i - 1)(j) + grid(i)(j)\n                    prev(i)(j) = 0\n          \
    \      } else {\n                    if (dp(i - 1)(j) < dp(i)(j - 1)) {\n    \
    \                    dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n                  \
    \      prev(i)(j) = 0\n                    } else {\n                        dp(i)(j)\
    \ = dp(i)(j - 1) + grid(i)(j)\n                        prev(i)(j) = 1\n      \
    \              }\n                }\n            }\n        }\n        val path\
    \ = ListBuffer[Long]()\n        var i = n - 1\n        var j = n - 1\n       \
    \ while (k > 0) {\n            path += grid(i)(j)\n            if (prev(i)(j)\
    \ == 0) {\n                i -= 1\n            } else {\n                j -=\
    \ 1\n            }\n            k -= 1\n        }\n        path.toList", "   \
    \     val n = grid.length\n        val dp = Array.fill(n, n)(Long.MaxValue)\n\
    \        val prev = Array.fill(n, n)(List[Long]())\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until n) {\n                if (i == 0 && j ==\
    \ 0) {\n                    dp(i)(j) = 0\n                    prev(i)(j) = List(grid(i)(j))\n\
    \                }\n                else {\n                    if (i > 0 && dp(i\
    \ - 1)(j) + 1 < dp(i)(j)) {\n                        dp(i)(j) = dp(i - 1)(j) +\
    \ 1\n                        prev(i)(j) = prev(i - 1)(j) :+ grid(i)(j)\n     \
    \               }\n                    if (j > 0 && dp(i)(j - 1) + 1 < dp(i)(j))\
    \ {\n                        dp(i)(j) = dp(i)(j - 1) + 1\n                   \
    \     prev(i)(j) = prev(i)(j - 1) :+ grid(i)(j)\n                    }\n     \
    \           }\n            }\n        }\n        prev(n - 1)(n - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(x\
    \ => x._1))\n        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n  \
    \          val (cost, i, j) = pq.dequeue\n            if (i >= 0 && i < n && j\
    \ >= 0 && j < m && cost < dp(i)(j)) {\n                dp(i)(j) = cost\n     \
    \           if (i > 0) pq.enqueue((cost + grid(i - 1)(j), i - 1, j))\n       \
    \         if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j), i + 1, j))\n     \
    \           if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i, j - 1))\n       \
    \         if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i, j + 1))\n     \
    \       }\n        }\n        val result = new ListBuffer[Long]\n        var i\
    \ = 0\n        var j = 0\n        while (result.length < k) {\n            result\
    \ += grid(i)(j)\n            if (i > 0 && dp(i - 1)(j) < dp(i + 1)(j) && dp(i\
    \ - 1)(j) < dp(i)(j - 1) && dp(i - 1)(j) < dp(i)(j + 1)) {\n                i\
    \ -= 1\n            } else if (i < n - 1 && dp(i + 1)(j) < dp(i - 1)(j) && dp(i\
    \ + 1)(j) < dp(i)(j - 1) && dp(i + 1)(j) < dp(i)(j + 1)) {\n                i\
    \ += 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i - 1)(j) && dp(i)(j\
    \ - 1)", "        val n = grid.length\n        val m = grid(0).length\n      \
    \  val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n \
    \           for (j <- 0 until m) {\n                if (i == 0 && j == 0) dp(i)(j)\
    \ = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = dp(i)(j - 1)\
    \ :+ grid(i)(j)\n                else if (j == 0) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n\
    \                else {\n                    val l1 = dp(i - 1)(j) :+ grid(i)(j)\n\
    \                    val l2 = dp(i)(j - 1) :+ grid(i)(j)\n                   \
    \ if (l1.length < l2.length) dp(i)(j) = l1\n                    else if (l1.length\
    \ > l2.length) dp(i)(j) = l2\n                    else dp(i)(j) = if (l1 < l2)\
    \ l1 else l2\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1).take(k.toInt)", "        // The idea is to use dynamic programming.\n \
    \       // Let dp(i, j, k) be the minimum path of length k starting from cell\
    \ (i, j).\n        // We have the following recurrence:\n        // dp(i, j, k)\
    \ = min(dp(i - 1, j, k - 1), dp(i + 1, j, k - 1), dp(i, j - 1, k - 1), dp(i, j\
    \ + 1, k - 1))\n        // The base case is when k = 1, in this case, dp(i, j,\
    \ 1) = grid(i)(j).\n        // The answer is dp(i, j, k) where (i, j) is the starting\
    \ cell.\n        // The time complexity is O(N^2 * k).\n        // The space complexity\
    \ is O(N^2 * k).\n        val n = grid.length\n        val dp = Array.ofDim[List[Long]](n,\
    \ n, k.toInt + 1)\n        for (i <- 0 until n; j <- 0 until n) {\n          \
    \  dp(i)(j)(1) = List(grid(i)(j))\n        }\n        for (i <- 0 until n; j <-\
    \ 0 until n; k <- 2 to this.k.toInt) {\n            var min = List[Long]()\n \
    \           if (i > 0) {\n                if (min.isEmpty || dp(i - 1)(j)(k -\
    \ 1) < min) min = dp(i - 1)(j)(k - 1)\n            }\n            if (i < n -\
    \ 1) {\n                if (min.isEmpty || dp(i + 1)(j)(k - 1) < min) min = dp(i\
    \ + 1)(j)(k - 1)\n            }\n            if (j > 0) {\n                if\
    \ (min.isEmpty || dp(i)(j - 1)(k - 1) < min) min = dp(i)(j - 1)(k - 1)\n     \
    \       }\n            if (j < n - 1) {\n                if (min.isEmpty || dp(i)(j\
    \ + 1)(k - 1) < min) min =", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted\n                else if (j == 0) dp(i)(j) = (dp(i\
    \ - 1)(j) :+ grid(i)(j)).sorted\n                else {\n                    val\
    \ a = dp(i)(j - 1) :+ grid(i)(j)\n                    val b = dp(i - 1)(j) :+\
    \ grid(i)(j)\n                    if (a.sorted < b.sorted) dp(i)(j) = a.sorted\n\
    \                    else dp(i)(j) = b.sorted\n                }\n           \
    \ }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val prev = Array.fill(n, m)(-1)\n        val q = new Queue[(Int, Int)]\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) {\n                    dp(i)(j) = grid(i)(j)\n\
    \                    q.enqueue((i, j))\n                }\n            }\n   \
    \     }\n        while (!q.isEmpty) {\n            val (i, j) = q.dequeue\n  \
    \          if (i > 0) {\n                if (dp(i - 1)(j) > dp(i)(j) + grid(i\
    \ - 1)(j)) {\n                    dp(i - 1)(j) = dp(i)(j) + grid(i - 1)(j)\n \
    \                   prev(i - 1)(j) = 0\n                    q.enqueue((i - 1,\
    \ j))\n                }\n            }\n            if (i < n - 1) {\n      \
    \          if (dp(i + 1)(j) > dp(i)(j) + grid(i + 1)(j)) {\n                 \
    \   dp(i + 1)(j) = dp(i)(j) + grid(i + 1)(j)\n                    prev(i + 1)(j)\
    \ = 1\n                    q.enqueue((i + 1, j))\n                }\n        \
    \    }\n            if (j > 0) {\n                if (dp(i)(j - 1) > dp(i)(j)\
    \ + grid(i)(j - 1)) {\n                    dp(i)(j - 1) = dp(i)(j) + grid(i)(j\
    \ - 1)\n                    prev(i)(j - 1) = 2\n                    q.enqueue((i,\
    \ j - 1))\n                }\n            }\n            if (j < m - 1) {\n  \
    \              if (dp(i)(j + 1) > dp(i)(j) + grid(i)(j + 1)) {\n             \
    \       dp(i)(j + 1) = dp", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (grid(i)(j)\
    \ :: dp(i)(j - 1)).sorted\n                else if (j == 0) dp(i)(j) = (grid(i)(j)\
    \ :: dp(i - 1)(j)).sorted\n                else {\n                    val a =\
    \ (grid(i)(j) :: dp(i)(j - 1)).sorted\n                    val b = (grid(i)(j)\
    \ :: dp(i - 1)(j)).sorted\n                    if (a < b) dp(i)(j) = a\n     \
    \               else dp(i)(j) = b\n                }\n            }\n        }\n\
    \        dp(n - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n     \
    \   val dp = Array.fill(n, n)((Long.MaxValue, List[Long]()))\n        val visited\
    \ = Array.fill(n, n)(false)\n        val queue = new Queue[(Int, Int)]\n     \
    \   queue.enqueue((0, 0))\n        dp(0)(0) = (0, List(grid(0)(0)))\n        while\
    \ (!queue.isEmpty) {\n            val (x, y) = queue.dequeue\n            if (!visited(x)(y))\
    \ {\n                visited(x)(y) = true\n                if (x > 0 && dp(x -\
    \ 1)(y)._1 > dp(x)(y)._1 + 1) {\n                    dp(x - 1)(y) = (dp(x)(y)._1\
    \ + 1, dp(x)(y)._2 :+ grid(x - 1)(y))\n                    queue.enqueue((x -\
    \ 1, y))\n                }\n                if (x < n - 1 && dp(x + 1)(y)._1\
    \ > dp(x)(y)._1 + 1) {\n                    dp(x + 1)(y) = (dp(x)(y)._1 + 1, dp(x)(y)._2\
    \ :+ grid(x + 1)(y))\n                    queue.enqueue((x + 1, y))\n        \
    \        }\n                if (y > 0 && dp(x)(y - 1)._1 > dp(x)(y)._1 + 1) {\n\
    \                    dp(x)(y - 1) = (dp(x)(y)._1 + 1, dp(x)(y)._2 :+ grid(x)(y\
    \ - 1))\n                    queue.enqueue((x, y - 1))\n                }\n  \
    \              if (y < n - 1 && dp(x)(y + 1)._1 > dp(x)(y)._1 + 1) {\n       \
    \             dp(x)(y + 1) = (dp(x)(y)._1 + 1, dp(x)(y)._2 :+ grid(x)(y + 1))\n\
    \                    queue.enqueue((x, y + 1))\n                }", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        dp(0)(0) = grid(0)(0)\n        pq.enqueue((grid(0)(0), 0, 0))\n     \
    \   while (pq.nonEmpty) {\n            val (v, x, y) = pq.dequeue\n          \
    \  if (dp(x)(y) == v) {\n                if (x > 0 && dp(x - 1)(y) > v + grid(x\
    \ - 1)(y)) {\n                    dp(x - 1)(y) = v + grid(x - 1)(y)\n        \
    \            pq.enqueue((dp(x - 1)(y), x - 1, y))\n                }\n       \
    \         if (x < n - 1 && dp(x + 1)(y) > v + grid(x + 1)(y)) {\n            \
    \        dp(x + 1)(y) = v + grid(x + 1)(y)\n                    pq.enqueue((dp(x\
    \ + 1)(y), x + 1, y))\n                }\n                if (y > 0 && dp(x)(y\
    \ - 1) > v + grid(x)(y - 1)) {\n                    dp(x)(y - 1) = v + grid(x)(y\
    \ - 1)\n                    pq.enqueue((dp(x)(y - 1), x, y - 1))\n           \
    \     }\n                if (y < m - 1 && dp(x)(y + 1) > v + grid(x)(y + 1)) {\n\
    \                    dp(x)(y + 1) = v + grid(x)(y + 1)\n                    pq.enqueue((dp(x)(y\
    \ + 1), x, y + 1))\n                }\n            }\n        }\n        val path\
    \ = ArrayBuffer[Long]()\n        var x = n - 1\n        var y = m - 1\n      \
    \  while (k > 0) {\n            path += grid(x)(y)\n            k -= 1\n     \
    \       if (x > 0", "        val n = grid.length\n        val dp = Array.fill(n,\
    \ n)(Long.MaxValue)\n        val prev = Array.fill(n, n)((0, 0))\n        val\
    \ q = Queue[(Int, Int)]()\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until n) {\n                if (i == 0 && j == 0) {\n                 \
    \   dp(i)(j) = grid(i)(j)\n                    q.enqueue((i, j))\n           \
    \     }\n            }\n        }\n        while (!q.isEmpty) {\n            val\
    \ (i, j) = q.dequeue\n            if (i > 0) {\n                if (dp(i - 1)(j)\
    \ > dp(i)(j) + grid(i - 1)(j)) {\n                    dp(i - 1)(j) = dp(i)(j)\
    \ + grid(i - 1)(j)\n                    prev(i - 1)(j) = (i, j)\n            \
    \        q.enqueue((i - 1, j))\n                }\n            }\n           \
    \ if (i < n - 1) {\n                if (dp(i + 1)(j) > dp(i)(j) + grid(i + 1)(j))\
    \ {\n                    dp(i + 1)(j) = dp(i)(j) + grid(i + 1)(j)\n          \
    \          prev(i + 1)(j) = (i, j)\n                    q.enqueue((i + 1, j))\n\
    \                }\n            }\n            if (j > 0) {\n                if\
    \ (dp(i)(j - 1) > dp(i)(j) + grid(i)(j - 1)) {\n                    dp(i)(j -\
    \ 1) = dp(i)(j) + grid(i)(j - 1)\n                    prev(i)(j - 1) = (i, j)\n\
    \                    q.enqueue((i, j - 1))\n                }\n            }\n\
    \            if (j < n - 1) {\n                if (dp(i)(j + 1) > dp(i)(j) + grid(i)(j\
    \ + 1)) {\n                    dp(i)(j + 1", "        // The idea is to use dynamic\
    \ programming.\n        // Let's define dp(i, j, k) to be the minimum path of\
    \ length k that starts\n        // from cell (i, j).\n        // We can write\
    \ the following recurrence:\n        // dp(i, j, k) = min(dp(i - 1, j, k - 1),\
    \ dp(i + 1, j, k - 1), dp(i, j - 1, k - 1), dp(i, j + 1, k - 1))\n        // The\
    \ base case is when k = 1, then dp(i, j, 1) = grid(i)(j).\n        // The answer\
    \ is dp(i, j, k) for any (i, j).\n        // The time complexity is O(N^2 * k)\
    \ and the space complexity is O(N^2 * k).\n        val n = grid.length\n     \
    \   val dp = Array.ofDim[List[Long]](n, n, k.toInt + 1)\n        for (i <- 0 until\
    \ n; j <- 0 until n) dp(i)(j)(1) = List(grid(i)(j))\n        for (k <- 2 to k.toInt)\
    \ {\n            for (i <- 0 until n; j <- 0 until n) {\n                val neighbors\
    \ = List((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)).filter(x => x._1 >= 0\
    \ && x._1 < n && x._2 >= 0 && x._2 < n)\n                if (neighbors.isEmpty)\
    \ dp(i)(j)(k) = List()\n                else dp(i)(j)(k) = neighbors.map(x =>\
    \ dp(x._1)(x._2)(k - 1)).minBy(x => x.mkString) :+ grid(i)(j)\n            }\n\
    \        }\n        dp(0)(0)(k.toInt)", "        val n = grid.length\n       \
    \ val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n  \
    \      for (i <- 0 until n) {\n            for (j <- 0 until m) {\n          \
    \      if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    var min = List[Long]()\n                    if (i > 0)\
    \ {\n                        val lst = dp(i - 1)(j)\n                        if\
    \ (lst.length < k && (min.length == 0 || lst < min)) min = lst\n             \
    \       }\n                    if (j > 0) {\n                        val lst =\
    \ dp(i)(j - 1)\n                        if (lst.length < k && (min.length == 0\
    \ || lst < min)) min = lst\n                    }\n                    if (min.length\
    \ == 0) dp(i)(j) = List(grid(i)(j))\n                    else dp(i)(j) = min :+\
    \ grid(i)(j)\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1)", "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        dp(i)(j) = List(grid(i)(j))\n                if (i > 0 && dp(i - 1)(j).length\
    \ < k && dp(i - 1)(j).head < grid(i)(j)) dp(i)(j) = grid(i)(j) :: dp(i - 1)(j)\n\
    \                if (j > 0 && dp(i)(j - 1).length < k && dp(i)(j - 1).head < grid(i)(j))\
    \ dp(i)(j) = grid(i)(j) :: dp(i)(j - 1)\n            }\n        }\n        dp(n\
    \ - 1)(n - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(_._1))\n        pq.enqueue((0, 0, 0))\n        while\
    \ (!pq.isEmpty) {\n            val (cost, i, j) = pq.dequeue\n            if (dp(i)(j)\
    \ > cost) {\n                dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost\
    \ + grid(i - 1)(j), i - 1, j))\n                if (i < n - 1) pq.enqueue((cost\
    \ + grid(i + 1)(j), i + 1, j))\n                if (j > 0) pq.enqueue((cost +\
    \ grid(i)(j - 1), i, j - 1))\n                if (j < m - 1) pq.enqueue((cost\
    \ + grid(i)(j + 1), i, j + 1))\n            }\n        }\n        val result =\
    \ new ListBuffer[Long]\n        var i = 0\n        var j = 0\n        var cost\
    \ = 0L\n        while (result.length < k) {\n            result += grid(i)(j)\n\
    \            if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n                i -= 1\n\
    \                cost += grid(i)(j)\n            } else if (i < n - 1 && dp(i\
    \ + 1)(j) < dp(i)(j)) {\n                i += 1\n                cost += grid(i)(j)\n\
    \            } else if (j > 0 && dp(i)(j - 1) < dp(i)(j)) {\n                j\
    \ -= 1\n                cost += grid(i)(j)\n            } else if (j < m - 1 &&\
    \ dp(i)(j + 1) < dp(i)(j)) {\n                j += 1\n                cost +=\
    \ grid(i)(j)\n            }\n        }\n        result.toList", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = List(grid(i)(j))\n                pq.enqueue((grid(i)(j),\
    \ i, j))\n            }\n        }\n        for (l <- 1 until k.toInt) {\n   \
    \         val (v, i, j) = pq.dequeue\n            val nv = dp(i)(j)\n        \
    \    if (i > 0) {\n                val nnv = nv :+ grid(i - 1)(j)\n          \
    \      if (nnv < dp(i - 1)(j)) {\n                    dp(i - 1)(j) = nnv\n   \
    \                 pq.enqueue((nnv.sum, i - 1, j))\n                }\n       \
    \     }\n            if (i < n - 1) {\n                val nnv = nv :+ grid(i\
    \ + 1)(j)\n                if (nnv < dp(i + 1)(j)) {\n                    dp(i\
    \ + 1)(j) = nnv\n                    pq.enqueue((nnv.sum, i + 1, j))\n       \
    \         }\n            }\n            if (j > 0) {\n                val nnv\
    \ = nv :+ grid(i)(j - 1)\n                if (nnv < dp(i)(j - 1)) {\n        \
    \            dp(i)(j - 1) = nnv\n                    pq.enqueue((nnv.sum, i, j\
    \ - 1))\n                }\n            }\n            if (j < m - 1) {\n    \
    \            val nnv = nv :+ grid(i)(j + 1)\n                if (nnv < dp(i)(j\
    \ + 1)) {\n                    dp(i)(j + 1) = nnv\n                    pq.enqueue((nnv.sum,\
    \ i, j + 1))\n                }\n            }\n        }\n       ", "       \
    \ val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n      \
    \          else if (j == 0) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n          \
    \      else {\n                    val l1 = dp(i - 1)(j) :+ grid(i)(j)\n     \
    \               val l2 = dp(i)(j - 1) :+ grid(i)(j)\n                    if (l1.length\
    \ == l2.length) dp(i)(j) = if (l1 < l2) l1 else l2\n                    else dp(i)(j)\
    \ = if (l1.length < l2.length) l1 else l2\n                }\n            }\n\
    \        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        // Let's use dynamic\
    \ programming.\n        // Let dp(i, j, k) be the minimum path of length k starting\
    \ from cell (i, j).\n        // dp(i, j, k) = min(dp(i - 1, j, k - 1), dp(i +\
    \ 1, j, k - 1), dp(i, j - 1, k - 1), dp(i, j + 1, k - 1))\n        // dp(i, j,\
    \ 0) = grid(i)(j)\n        // dp(i, j, k) = -1 if k < 0\n        val n = grid.length\n\
    \        val dp = Array.ofDim[Long](n, n, k.toInt + 1)\n        for (i <- 0 until\
    \ n; j <- 0 until n) {\n            dp(i)(j)(0) = grid(i)(j)\n        }\n    \
    \    for (k <- 1 to k.toInt) {\n            for (i <- 0 until n; j <- 0 until\
    \ n) {\n                if (i == 0 && j == 0) {\n                    dp(i)(j)(k)\
    \ = min(dp(i + 1)(j)(k - 1), dp(i)(j + 1)(k - 1))\n                } else if (i\
    \ == 0 && j == n - 1) {\n                    dp(i)(j)(k) = min(dp(i + 1)(j)(k\
    \ - 1), dp(i)(j - 1)(k - 1))\n                } else if (i == n - 1 && j == 0)\
    \ {\n                    dp(i)(j)(k) = min(dp(i - 1)(j)(k - 1), dp(i)(j + 1)(k\
    \ - 1))\n                } else if (i == n - 1 && j == n - 1) {\n            \
    \        dp(i)(j)(k) = min(dp(i - 1)(j)(k - 1), dp(i)(j - 1)(k - 1))\n       \
    \         } else if (i == 0) {\n                    dp(i)(j)(k) = min(dp(i + 1)(j)(k\
    \ - 1), dp(i)(j - 1)(k -", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = dp(i)(j\
    \ - 1) :+ grid(i)(j)\n                else if (j == 0) dp(i)(j) = dp(i - 1)(j)\
    \ :+ grid(i)(j)\n                else {\n                    val left = dp(i)(j\
    \ - 1) :+ grid(i)(j)\n                    val up = dp(i - 1)(j) :+ grid(i)(j)\n\
    \                    if (left.length == up.length) {\n                       \
    \ if (left < up) dp(i)(j) = left\n                        else dp(i)(j) = up\n\
    \                    }\n                    else if (left.length < up.length)\
    \ dp(i)(j) = left\n                    else dp(i)(j) = up\n                }\n\
    \            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        //\
    \ Let's first find the minimum path of length k starting from the cell\n     \
    \   // (0, 0).\n        // Let's use dynamic programming.\n        // Let dp(i,\
    \ j, l) be the minimum path of length l starting from the cell\n        // (i,\
    \ j).\n        // dp(i, j, l) = min(dp(i - 1, j, l - 1), dp(i + 1, j, l - 1),\
    \ dp(i, j - 1, l - 1), dp(i, j + 1, l - 1))\n        // dp(i, j, 0) = grid(i)(j)\n\
    \        // dp(i, j, l) = -1 if dp(i, j, l - 1) = -1\n        // dp(i, j, l) =\
    \ -1 if dp(i, j, l - 1) != -1 and dp(i - 1, j, l - 1) = -1 and dp(i + 1, j, l\
    \ - 1) = -1 and dp(i, j - 1, l - 1) = -1 and dp(i, j + 1, l - 1) = -1\n      \
    \  // dp(i, j, l) = -1 if dp(i, j, l - 1) != -1 and dp(i - 1, j, l - 1) != -1\
    \ and dp(i + 1, j, l - 1) != -1 and dp(i, j - 1, l - 1) != -1 and dp(i, j + 1,\
    \ l - 1) != -1 and dp(i - 1, j, l - 1) = dp(i + 1, j, l - 1) = dp(i, j - 1, l\
    \ - 1) = dp(i, j + 1, l - 1)\n        // dp(i, j, l) = -1 if dp(i, j, l - 1) !=\
    \ -1 and dp(i - 1, j, l - 1) != -1 and dp(i + 1, j, l - 1) != -1 and dp(i, j -\
    \ 1, l - 1) !=", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        val q = Queue[(Int,\
    \ Int)]()\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                dp(i)(j) = List(grid(i)(j))\n                q.enqueue((i, j))\n\
    \            }\n        }\n        while (q.nonEmpty) {\n            val (i, j)\
    \ = q.dequeue\n            if (dp(i)(j).length < k) {\n                if (i >\
    \ 0 && dp(i - 1)(j).length == dp(i)(j).length + 1 && dp(i - 1)(j) < dp(i)(j) :+\
    \ grid(i - 1)(j)) {\n                    dp(i - 1)(j) = dp(i)(j) :+ grid(i - 1)(j)\n\
    \                    q.enqueue((i - 1, j))\n                }\n              \
    \  if (i < n - 1 && dp(i + 1)(j).length == dp(i)(j).length + 1 && dp(i + 1)(j)\
    \ < dp(i)(j) :+ grid(i + 1)(j)) {\n                    dp(i + 1)(j) = dp(i)(j)\
    \ :+ grid(i + 1)(j)\n                    q.enqueue((i + 1, j))\n             \
    \   }\n                if (j > 0 && dp(i)(j - 1).length == dp(i)(j).length + 1\
    \ && dp(i)(j - 1) < dp(i)(j) :+ grid(i)(j - 1)) {\n                    dp(i)(j\
    \ - 1) = dp(i)(j) :+ grid(i)(j - 1)\n                    q.enqueue((i, j - 1))\n\
    \                }\n                if (j < m - 1 && dp(i)(j + 1).length == dp(i)(j).length\
    \ + 1 && dp(i)(j + 1) < dp(i)(j) :+ grid(i)(", "        val n = grid.length\n\
    \        val dp = Array.fill(n, n)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until n) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    if\
    \ (i > 0) {\n                        val lst = dp(i - 1)(j)\n                \
    \        if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n                  \
    \      else if (lst.length == k) {\n                            val lst2 = lst\
    \ :+ grid(i)(j)\n                            if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n\
    \                        }\n                    }\n                    if (j >\
    \ 0) {\n                        val lst = dp(i)(j - 1)\n                     \
    \   if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n                       \
    \ else if (lst.length == k) {\n                            val lst2 = lst :+ grid(i)(j)\n\
    \                            if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }\n        dp(n - 1)(n - 1)", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n     \
    \   val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n     \
    \   pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val (cost,\
    \ i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n                dp(i)(j)\
    \ = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j), i - 1,\
    \ j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j), i + 1,\
    \ j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i, j - 1))\n\
    \                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i, j + 1))\n\
    \            }\n        }\n        val result = new ListBuffer[Long]\n       \
    \ var i = 0\n        var j = 0\n        for (k <- 1 to k.toInt) {\n          \
    \  result += grid(i)(j)\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n\
    \                i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j))\
    \ {\n                i += 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i)(j))\
    \ {\n                j -= 1\n            } else if (j < m - 1 && dp(i)(j + 1)\
    \ < dp(i)(j)) {\n                j += 1\n            }\n        }\n        result.toList",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n      \
    \          else if (j == 0) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n          \
    \      else {\n                    val left = dp(i)(j - 1) :+ grid(i)(j)\n   \
    \                 val up = dp(i - 1)(j) :+ grid(i)(j)\n                    if\
    \ (left.length < up.length) dp(i)(j) = left\n                    else if (left.length\
    \ > up.length) dp(i)(j) = up\n                    else dp(i)(j) = if (left < up)\
    \ left else up\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1).take(k.toInt)", "        val n = grid.length\n        val dp = Array.fill(n,\
    \ n)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ n) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    if (i > 0) dp(i)(j) = dp(i - 1)(j)\n\
    \                    if (j > 0 && (dp(i)(j).isEmpty || dp(i)(j).last > dp(i)(j\
    \ - 1).last)) dp(i)(j) = dp(i)(j - 1)\n                    if (i > 0 && j > 0\
    \ && (dp(i)(j).isEmpty || dp(i)(j).last > dp(i - 1)(j - 1).last)) dp(i)(j) = dp(i\
    \ - 1)(j - 1)\n                    dp(i)(j) = (dp(i)(j) :+ grid(i)(j)).take(k.toInt)\n\
    \                }\n            }\n        }\n        dp(n - 1)(n - 1)", "   \
    \     val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n \
    \       for (i <- 0 until n) {\n            for (j <- 0 until n) {\n         \
    \       dp(i)(j) = List(grid(i)(j))\n                if (i > 0 && dp(i - 1)(j).length\
    \ <= k && dp(i - 1)(j).length + 1 <= dp(i)(j).length) {\n                    if\
    \ (dp(i - 1)(j).length + 1 < dp(i)(j).length) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n\
    \                    else if (dp(i - 1)(j).last < dp(i)(j).last) dp(i)(j) = dp(i\
    \ - 1)(j) :+ grid(i)(j)\n                }\n                if (j > 0 && dp(i)(j\
    \ - 1).length <= k && dp(i)(j - 1).length + 1 <= dp(i)(j).length) {\n        \
    \            if (dp(i)(j - 1).length + 1 < dp(i)(j).length) dp(i)(j) = dp(i)(j\
    \ - 1) :+ grid(i)(j)\n                    else if (dp(i)(j - 1).last < dp(i)(j).last)\
    \ dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n                }\n            }\n  \
    \      }\n        dp(n - 1)(n - 1)", "        val n = grid.length\n        val\
    \ dp = Array.fill(n, n)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(-_._1))\n        pq.enqueue((0, 0, 0))\n        while\
    \ (pq.nonEmpty) {\n            val (cost, x, y) = pq.dequeue\n            if (dp(x)(y)\
    \ > cost) {\n                dp(x)(y) = cost\n                if (x > 0) pq.enqueue((cost\
    \ + grid(x - 1)(y), x - 1, y))\n                if (x < n - 1) pq.enqueue((cost\
    \ + grid(x + 1)(y), x + 1, y))\n                if (y > 0) pq.enqueue((cost +\
    \ grid(x)(y - 1), x, y - 1))\n                if (y < n - 1) pq.enqueue((cost\
    \ + grid(x)(y + 1), x, y + 1))\n            }\n        }\n        val result =\
    \ new ListBuffer[Long]\n        var (x, y) = (0, 0)\n        for (i <- 0 until\
    \ k.toInt) {\n            result += grid(x)(y)\n            if (x > 0 && dp(x\
    \ - 1)(y) < dp(x)(y)) {\n                x -= 1\n            } else if (x < n\
    \ - 1 && dp(x + 1)(y) < dp(x)(y)) {\n                x += 1\n            } else\
    \ if (y > 0 && dp(x)(y - 1) < dp(x)(y)) {\n                y -= 1\n          \
    \  } else if (y < n - 1 && dp(x)(y + 1) < dp(x)(y)) {\n                y += 1\n\
    \            }\n        }\n        result.toList", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n                else if (j\
    \ == 0) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n                else {\n      \
    \              val up = dp(i - 1)(j) :+ grid(i)(j)\n                    val left\
    \ = dp(i)(j - 1) :+ grid(i)(j)\n                    if (up.length == left.length)\
    \ dp(i)(j) = if (up < left) up else left\n                    else dp(i)(j) =\
    \ if (up.length < left.length) up else left\n                }\n            }\n\
    \        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        val dirs = List((0, 1), (0, -1), (1, 0), (-1, 0))\n        def isValid(x\
    \ : Int, y : Int) : Boolean = {\n            x >= 0 && x < n && y >= 0 && y <\
    \ m\n        }\n        def getNeighbors(x : Int, y : Int) : List[(Int, Int)]\
    \ = {\n            dirs.map(dir => (x + dir._1, y + dir._2)).filter(p => isValid(p._1,\
    \ p._2))\n        }\n        def getPath(x : Int, y : Int, k : Long) : List[Long]\
    \ = {\n            if (k == 0) {\n                List(grid(x)(y))\n         \
    \   } else {\n                val neighbors = getNeighbors(x, y)\n           \
    \     val paths = neighbors.map(p => getPath(p._1, p._2, k - 1))\n           \
    \     val minPath = paths.minBy(p => (p, p.head))\n                grid(x)(y)\
    \ :: minPath\n            }\n        }\n        getPath(0, 0, k)", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                val v = grid(i)(j)\n                if (i == 0 && j ==\
    \ 0) dp(i)(j) = List(v)\n                else if (i == 0) {\n                \
    \    val prev = dp(i)(j - 1)\n                    if (prev.length < k) dp(i)(j)\
    \ = prev :+ v\n                    else if (prev.length == k) {\n            \
    \            if (prev.last < v) dp(i)(j) = prev\n                        else\
    \ dp(i)(j) = prev.init :+ v\n                    }\n                }\n      \
    \          else if (j == 0) {\n                    val prev = dp(i - 1)(j)\n \
    \                   if (prev.length < k) dp(i)(j) = prev :+ v\n              \
    \      else if (prev.length == k) {\n                        if (prev.last < v)\
    \ dp(i)(j) = prev\n                        else dp(i)(j) = prev.init :+ v\n  \
    \                  }\n                }\n                else {\n            \
    \        val prev1 = dp(i - 1)(j)\n                    val prev2 = dp(i)(j - 1)\n\
    \                    if (prev1.length < k && prev2.length < k) {\n           \
    \             if (prev1.last < prev2.last) dp(i)(j) = prev1 :+ v\n           \
    \             else dp(i)(j) = prev2 :+ v\n                    }\n            \
    \        else if (prev1.length < k) dp(i)(j) = prev1 :+ v\n                  \
    \  else if (prev2.length < k) dp(i)(j) = prev2 :+ v\n                    else\
    \ if (prev1.length == k && prev2.length == k) {\n                        if (prev1.last\
    \ < prev2.last) dp(i)(j) = prev1\n                        else dp(i)(j) = prev2\n\
    \                    }\n                    else if (prev1.length", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)((Long.MaxValue, List[Long]()))\n        dp(0)(0) = (0, List(grid(0)(0)))\n\
    \        for (i <- 0 until n; j <- 0 until m) {\n            if (i > 0) {\n  \
    \              val (cost, path) = dp(i - 1)(j)\n                if (cost + 1 <\
    \ dp(i)(j)._1) dp(i)(j) = (cost + 1, path :+ grid(i)(j))\n                else\
    \ if (cost + 1 == dp(i)(j)._1) {\n                    val newPath = path :+ grid(i)(j)\n\
    \                    if (newPath < dp(i)(j)._2) dp(i)(j) = (cost + 1, newPath)\n\
    \                }\n            }\n            if (j > 0) {\n                val\
    \ (cost, path) = dp(i)(j - 1)\n                if (cost + 1 < dp(i)(j)._1) dp(i)(j)\
    \ = (cost + 1, path :+ grid(i)(j))\n                else if (cost + 1 == dp(i)(j)._1)\
    \ {\n                    val newPath = path :+ grid(i)(j)\n                  \
    \  if (newPath < dp(i)(j)._2) dp(i)(j) = (cost + 1, newPath)\n               \
    \ }\n            }\n        }\n        val (cost, path) = dp(n - 1)(m - 1)\n \
    \       if (cost == k) path\n        else {\n            val (cost1, path1) =\
    \ dp(n - 1)(m - 2)\n            val (cost2, path2) = dp(n - 2)(m - 1)\n      \
    \      if (cost1 < cost2) path1 :+ grid(n - 1)(m - 1)\n            else if (cost1\
    \ > cost2) path2 :+ grid(n - 1)(m - 1)\n            else {\n                val\
    \ newPath1 = path1 :+ grid(n -", "        val n = grid.length\n        val dp\
    \ = Array.fill(n, n)(List[Long]())\n        for (i <- 0 until n) {\n         \
    \   for (j <- 0 until n) {\n                dp(i)(j) = List(grid(i)(j))\n    \
    \            if (i > 0 && dp(i - 1)(j).length < k) {\n                    val\
    \ lst = dp(i - 1)(j) :+ grid(i)(j)\n                    if (lst.length == k) {\n\
    \                        if (lst < dp(i)(j)) dp(i)(j) = lst\n                \
    \    } else if (lst.length < k) {\n                        if (lst < dp(i)(j))\
    \ dp(i)(j) = lst\n                    }\n                }\n                if\
    \ (j > 0 && dp(i)(j - 1).length < k) {\n                    val lst = dp(i)(j\
    \ - 1) :+ grid(i)(j)\n                    if (lst.length == k) {\n           \
    \             if (lst < dp(i)(j)) dp(i)(j) = lst\n                    } else if\
    \ (lst.length < k) {\n                        if (lst < dp(i)(j)) dp(i)(j) = lst\n\
    \                    }\n                }\n            }\n        }\n        dp(n\
    \ - 1)(n - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted\n                else if (j == 0) dp(i)(j) = (dp(i\
    \ - 1)(j) :+ grid(i)(j)).sorted\n                else {\n                    val\
    \ lst1 = dp(i - 1)(j) :+ grid(i)(j)\n                    val lst2 = dp(i)(j -\
    \ 1) :+ grid(i)(j)\n                    if (lst1.sorted < lst2.sorted) dp(i)(j)\
    \ = lst1.sorted\n                    else dp(i)(j) = lst2.sorted\n           \
    \     }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", " \
    \       val n = grid.length\n        val dp = Array.fill(n, n)(Long.MaxValue)\n\
    \        val prev = Array.fill(n, n)(-1)\n        val q = new Queue[(Int, Int)]\n\
    \        for (i <- 0 until n) {\n            dp(i)(0) = grid(i)(0)\n         \
    \   q.enqueue((i, 0))\n        }\n        while (!q.isEmpty) {\n            val\
    \ (i, j) = q.dequeue\n            if (j + 1 < n) {\n                if (dp(i)(j\
    \ + 1) > dp(i)(j) + grid(i)(j + 1)) {\n                    dp(i)(j + 1) = dp(i)(j)\
    \ + grid(i)(j + 1)\n                    prev(i)(j + 1) = i\n                 \
    \   q.enqueue((i, j + 1))\n                }\n                if (i + 1 < n &&\
    \ dp(i + 1)(j + 1) > dp(i)(j) + grid(i + 1)(j + 1)) {\n                    dp(i\
    \ + 1)(j + 1) = dp(i)(j) + grid(i + 1)(j + 1)\n                    prev(i + 1)(j\
    \ + 1) = i\n                    q.enqueue((i + 1, j + 1))\n                }\n\
    \                if (i - 1 >= 0 && dp(i - 1)(j + 1) > dp(i)(j) + grid(i - 1)(j\
    \ + 1)) {\n                    dp(i - 1)(j + 1) = dp(i)(j) + grid(i - 1)(j + 1)\n\
    \                    prev(i - 1)(j + 1) = i\n                    q.enqueue((i\
    \ - 1, j + 1))\n                }\n            }\n        }\n        var min =\
    \ Long.MaxValue\n        var min_i = -1\n        for (i <- 0 until n) {\n    \
    \        if (dp(i)(n - 1) < min) {\n                min = dp(i)(n - 1)\n     \
    \           min_i = i\n            }\n        }\n        val result = new List",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                else {\n                    val a = dp(i)(j - 1) :+ grid(i)(j)\n\
    \                    val b = dp(i - 1)(j) :+ grid(i)(j)\n                    if\
    \ (a.sorted < b.sorted) dp(i)(j) = a.sorted\n                    else dp(i)(j)\
    \ = b.sorted\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1).take(k.toInt)", "        val n = grid.length\n        val dp = Array.fill(n,\
    \ n)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ n) {\n                dp(i)(j) = List(grid(i)(j))\n                if (i > 0\
    \ && dp(i - 1)(j).head < dp(i)(j).head) dp(i)(j) = dp(i - 1)(j)\n            \
    \    if (j > 0 && dp(i)(j - 1).head < dp(i)(j).head) dp(i)(j) = dp(i)(j - 1)\n\
    \            }\n        }\n        var i = n - 1; var j = n - 1\n        var path\
    \ = List[Long]()\n        while (k > 0) {\n            path = grid(i)(j) :: path\n\
    \            if (i > 0 && dp(i - 1)(j).head < dp(i)(j).head) {\n             \
    \   i -= 1\n            } else if (j > 0 && dp(i)(j - 1).head < dp(i)(j).head)\
    \ {\n                j -= 1\n            } else {\n                i -= 1; j -=\
    \ 1\n            }\n            k -= 1\n        }\n        path", "        val\
    \ n = grid.length\n        val dp = Array.fill(n, n)((Long.MaxValue, List[Long]()))\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = (0, List(grid(i)(j)))\n            \
    \    else {\n                    if (i > 0) {\n                        val (c,\
    \ l) = dp(i - 1)(j)\n                        if (c + 1 < dp(i)(j)._1) dp(i)(j)\
    \ = (c + 1, grid(i)(j) :: l)\n                        else if (c + 1 == dp(i)(j)._1)\
    \ {\n                            val l1 = grid(i)(j) :: l\n                  \
    \          if (l1 < dp(i)(j)._2) dp(i)(j) = (c + 1, l1)\n                    \
    \    }\n                    }\n                    if (j > 0) {\n            \
    \            val (c, l) = dp(i)(j - 1)\n                        if (c + 1 < dp(i)(j)._1)\
    \ dp(i)(j) = (c + 1, grid(i)(j) :: l)\n                        else if (c + 1\
    \ == dp(i)(j)._1) {\n                            val l1 = grid(i)(j) :: l\n  \
    \                          if (l1 < dp(i)(j)._2) dp(i)(j) = (c + 1, l1)\n    \
    \                    }\n                    }\n                }\n           \
    \ }\n        }\n        val (c, l) = dp(n - 1)(n - 1)\n        if (c == k) l\n\
    \        else {\n            val (c1, l1) = dp(n - 1)(n - 2)\n            val\
    \ (c2, l2) = dp(n - 2)(n - 1)\n            if (c1 == k) l1\n            else if\
    \ (c2 == k) l2\n            else {\n                val (c3, l3) = dp(n - 2)(n\
    \ - 2)\n               ", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted\n                else if (j == 0) dp(i)(j) = (dp(i\
    \ - 1)(j) :+ grid(i)(j)).sorted\n                else {\n                    val\
    \ a = dp(i)(j - 1) :+ grid(i)(j)\n                    val b = dp(i - 1)(j) :+\
    \ grid(i)(j)\n                    if (a.sorted < b.sorted) dp(i)(j) = a\n    \
    \                else dp(i)(j) = b\n                }\n            }\n       \
    \ }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n \
    \       val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n               \
    \ else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n          \
    \      else {\n                    val l1 = dp(i - 1)(j) :+ grid(i)(j)\n     \
    \               val l2 = dp(i)(j - 1) :+ grid(i)(j)\n                    dp(i)(j)\
    \ = if (l1.sorted < l2.sorted) l1 else l2\n                }\n            }\n\
    \        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = List(grid(i)(j)) ++ dp(i)(j - 1)\n                else\
    \ if (j == 0) dp(i)(j) = List(grid(i)(j)) ++ dp(i - 1)(j)\n                else\
    \ {\n                    val l1 = List(grid(i)(j)) ++ dp(i)(j - 1)\n         \
    \           val l2 = List(grid(i)(j)) ++ dp(i - 1)(j)\n                    dp(i)(j)\
    \ = if (l1 < l2) l1 else l2\n                }\n            }\n        }\n   \
    \     dp(n - 1)(m - 1).take(k.toInt)", "        // First, we will find the minimum\
    \ path of length k starting from the\n        // first cell.\n        // Let's\
    \ define a function to calculate the minimum path of length k\n        // starting\
    \ from the cell (i, j).\n        def minPath(i : Int, j : Int, k : Long) : List[Long]\
    \ = {\n            // If k = 0, then we return an empty list.\n            if\
    \ (k == 0) return List()\n            // If k = 1, then we return a list with\
    \ the value of the cell (i, j).\n            if (k == 1) return List(grid(i)(j))\n\
    \            // Otherwise, we will try to move to the neighbor cells.\n      \
    \      // First, we will try to move to the cell (i - 1, j).\n            // If\
    \ i - 1 >= 0, then we can move to the cell (i - 1, j).\n            if (i - 1\
    \ >= 0) {\n                // We will calculate the minimum path of length k -\
    \ 1 starting\n                // from the cell (i - 1, j).\n                val\
    \ path = minPath(i - 1, j, k - 1)\n                // If path is not empty, then\
    \ we can move to the cell (i - 1, j).\n                if (path != List()) {\n\
    \                    // We will return the list of the values on the cells that\n\
    \                    // the minimum path go through.\n                    return\
    \ grid(i)(j) :: path\n                }\n            }\n            // Otherwise,\
    \ we will try to move to the cell (i + 1, j).\n            // If i + 1 < grid.length,\
    \ then we can move to the cell (i + 1, j).\n            if (i + 1 < grid.length)\
    \ {\n                // We will calculate the minimum path of length k - 1 starting\n\
    \                // from the cell (i + 1, j).\n                val path = minPath(i\
    \ + 1, j, k - 1)\n                // If path is not empty, then we can move to\
    \ the cell (i + 1, j).\n                if (path != List()) {\n              \
    \      // We will return the list of the values on the cells that\n          \
    \          // the minimum path go through.\n                    return grid(i)(j)\
    \ :: path\n                }\n            }\n           ", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n \
    \       pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val min = dp.map(_.min).min\n   \
    \     val ans = new ListBuffer[Long]\n        var i = 0\n        while (i < n\
    \ && dp(i).min != min) i += 1\n        var j = 0\n        while (j < m && dp(i)(j)\
    \ != min) j += 1\n        ans += grid(i)(j)\n        while (ans.length < k) {\n\
    \            if (i > 0 && dp(i - 1)(j) == min + ans.last) {\n                i\
    \ -= 1\n                ans += grid(i)(j)\n            } else if (i < n - 1 &&\
    \ dp(i + 1)(j) == min + ans.last) {\n                i += 1\n                ans\
    \ += grid(i)(j)\n            } else if (j > 0 && dp(i)(j - 1) == min + ans.last)\
    \ {\n                j -= 1\n                ans += grid(i)(j)\n            }\
    \ else if (j < m - 1 && dp(i)(j + 1) == min + ans.last", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n               \
    \ else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n          \
    \      else {\n                    val up = dp(i - 1)(j)\n                   \
    \ val left = dp(i)(j - 1)\n                    if (up.length < left.length) dp(i)(j)\
    \ = (up :+ grid(i)(j)).sorted\n                    else if (up.length > left.length)\
    \ dp(i)(j) = (left :+ grid(i)(j)).sorted\n                    else dp(i)(j) =\
    \ (up :+ grid(i)(j)).sorted.min(left :+ grid(i)(j)).sorted\n                }\n\
    \            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val\
    \ n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until n) {\n                if (i\
    \ == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else {\n      \
    \              val lst = ListBuffer[Long]()\n                    if (i > 0) lst\
    \ ++= dp(i - 1)(j)\n                    if (j > 0) lst ++= dp(i)(j - 1)\n    \
    \                dp(i)(j) = (lst ++ List(grid(i)(j))).sorted.take(k.toInt)\n \
    \               }\n            }\n        }\n        dp(n - 1)(n - 1)", "    \
    \    val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                else {\n                    val a = dp(i)(j - 1) :+ grid(i)(j)\n\
    \                    val b = dp(i - 1)(j) :+ grid(i)(j)\n                    if\
    \ (a.sorted < b.sorted) dp(i)(j) = a.sorted\n                    else dp(i)(j)\
    \ = b.sorted\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1).take(k.toInt)", "        val n = grid.length\n        val dp = Array.fill(n,\
    \ n)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ n) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    val l = if (i > 0) dp(i - 1)(j) else\
    \ List[Long]()\n                    val u = if (j > 0) dp(i)(j - 1) else List[Long]()\n\
    \                    if (l.length == u.length) {\n                        if (l.length\
    \ == k) dp(i)(j) = if (l < u) l else u\n                        else dp(i)(j)\
    \ = if (l < u) (grid(i)(j) :: l) else (grid(i)(j) :: u)\n                    }\n\
    \                    else if (l.length < u.length) dp(i)(j) = if (l.length ==\
    \ k) l else (grid(i)(j) :: l)\n                    else dp(i)(j) = if (u.length\
    \ == k) u else (grid(i)(j) :: u)\n                }\n            }\n        }\n\
    \        dp(n - 1)(n - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    val\
    \ up = if (i == 0) List[Long]() else dp(i - 1)(j)\n                    val left\
    \ = if (j == 0) List[Long]() else dp(i)(j - 1)\n                    if (up.length\
    \ == 0) dp(i)(j) = left :+ grid(i)(j)\n                    else if (left.length\
    \ == 0) dp(i)(j) = up :+ grid(i)(j)\n                    else if (up.length +\
    \ 1 < left.length + 1) dp(i)(j) = up :+ grid(i)(j)\n                    else if\
    \ (up.length + 1 > left.length + 1) dp(i)(j) = left :+ grid(i)(j)\n          \
    \          else {\n                        val up_last = up.last\n           \
    \             val left_last = left.last\n                        if (up_last <\
    \ left_last) dp(i)(j) = up :+ grid(i)(j)\n                        else if (up_last\
    \ > left_last) dp(i)(j) = left :+ grid(i)(j)\n                        else dp(i)(j)\
    \ = (up :+ grid(i)(j)).sorted\n                    }\n                }\n    \
    \        }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n      \
    \          else if (j == 0) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n          \
    \      else {\n                    val l1 = dp(i - 1)(j) :+ grid(i)(j)\n     \
    \               val l2 = dp(i)(j - 1) :+ grid(i)(j)\n                    if (l1\
    \ < l2) dp(i)(j) = l1\n                    else dp(i)(j) = l2\n              \
    \  }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (grid(i)(j) :: dp(i)(j - 1)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (grid(i)(j) :: dp(i - 1)(j)).sorted\n\
    \                else {\n                    val l = min(dp(i - 1)(j).length,\
    \ dp(i)(j - 1).length)\n                    val l1 = dp(i - 1)(j).take(l)\n  \
    \                  val l2 = dp(i)(j - 1).take(l)\n                    val l3 =\
    \ (l1 ++ l2).sorted\n                    dp(i)(j) = (grid(i)(j) :: l3).sorted\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                dp(i)(j) = List(grid(i)(j))\n                if (i > 0\
    \ && dp(i - 1)(j).length <= k && dp(i - 1)(j).length < dp(i)(j).length) dp(i)(j)\
    \ = dp(i - 1)(j)\n                if (j > 0 && dp(i)(j - 1).length <= k && dp(i)(j\
    \ - 1).length < dp(i)(j).length) dp(i)(j) = dp(i)(j - 1)\n                if (dp(i)(j).length\
    \ < k) dp(i)(j) = dp(i)(j) :+ grid(i)(j)\n            }\n        }\n        dp(n\
    \ - 1)(m - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted\n                else if (j == 0) dp(i)(j) = (dp(i\
    \ - 1)(j) :+ grid(i)(j)).sorted\n                else {\n                    val\
    \ l1 = dp(i - 1)(j) :+ grid(i)(j)\n                    val l2 = dp(i)(j - 1) :+\
    \ grid(i)(j)\n                    if (l1.sorted < l2.sorted) dp(i)(j) = l1.sorted\n\
    \                    else dp(i)(j) = l2.sorted\n                }\n          \
    \  }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val prev = Array.fill(n, m)(-1)\n        for (i <- 0 until n) for (j\
    \ <- 0 until m) {\n            if (i == 0 && j == 0) {\n                dp(i)(j)\
    \ = grid(i)(j)\n            } else if (i == 0) {\n                dp(i)(j) = dp(i)(j\
    \ - 1) + grid(i)(j)\n                prev(i)(j) = 1\n            } else if (j\
    \ == 0) {\n                dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n            \
    \    prev(i)(j) = 0\n            } else {\n                if (dp(i - 1)(j) <\
    \ dp(i)(j - 1)) {\n                    dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n\
    \                    prev(i)(j) = 0\n                } else {\n              \
    \      dp(i)(j) = dp(i)(j - 1) + grid(i)(j)\n                    prev(i)(j) =\
    \ 1\n                }\n            }\n        }\n        var i = n - 1\n    \
    \    var j = m - 1\n        val result = new ListBuffer[Long]\n        while (k\
    \ > 0) {\n            result += grid(i)(j)\n            if (prev(i)(j) == 0) i\
    \ -= 1\n            else j -= 1\n            k -= 1\n        }\n        result.toList",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (i >= 0 && i < n && j >= 0 && j <\
    \ m && cost < dp(i)(j)) {\n                dp(i)(j) = cost\n                if\
    \ (i == n - 1 && j == m - 1) return List(grid(i)(j))\n                pq.enqueue((cost\
    \ + abs(grid(i)(j) - grid(i + 1)(j)), i + 1, j))\n                pq.enqueue((cost\
    \ + abs(grid(i)(j) - grid(i - 1)(j)), i - 1, j))\n                pq.enqueue((cost\
    \ + abs(grid(i)(j) - grid(i)(j + 1)), i, j + 1))\n                pq.enqueue((cost\
    \ + abs(grid(i)(j) - grid(i)(j - 1)), i, j - 1))\n            }\n        }\n \
    \       List()", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted\n                else if (j == 0) dp(i)(j) = (dp(i\
    \ - 1)(j) :+ grid(i)(j)).sorted\n                else {\n                    val\
    \ a = dp(i)(j - 1) :+ grid(i)(j)\n                    val b = dp(i - 1)(j) :+\
    \ grid(i)(j)\n                    if (a.sorted < b.sorted) dp(i)(j) = a.sorted\n\
    \                    else dp(i)(j) = b.sorted\n                }\n           \
    \ }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        // The idea\
    \ is to use dynamic programming.\n        // Let dp(i, j, k) be the minimum path\
    \ of length k starting from cell (i, j).\n        // dp(i, j, k) = min(dp(i -\
    \ 1, j, k - 1), dp(i + 1, j, k - 1), dp(i, j - 1, k - 1), dp(i, j + 1, k - 1))\
    \ + grid(i)(j)\n        // dp(i, j, 0) = grid(i)(j)\n        // dp(i, j, k) =\
    \ -1 if k < 0\n        val n = grid.length\n        val dp = Array.ofDim[Long](n,\
    \ n, k.toInt + 1)\n        for (i <- 0 until n; j <- 0 until n) {\n          \
    \  dp(i)(j)(0) = grid(i)(j)\n        }\n        for (k <- 1 to k.toInt) {\n  \
    \          for (i <- 0 until n; j <- 0 until n) {\n                dp(i)(j)(k)\
    \ = -1\n                if (i > 0) {\n                    if (dp(i - 1)(j)(k -\
    \ 1) != -1) {\n                        if (dp(i)(j)(k) == -1 || dp(i - 1)(j)(k\
    \ - 1) + grid(i)(j) < dp(i)(j)(k)) {\n                            dp(i)(j)(k)\
    \ = dp(i - 1)(j)(k - 1) + grid(i)(j)\n                        }\n            \
    \        }\n                }\n                if (i < n - 1) {\n            \
    \        if (dp(i + 1)(j)(k - 1) != -1) {\n                        if (dp(i)(j)(k)\
    \ == -1 || dp(i + 1)(j)(k - 1) + grid(i)(j) < dp(i)(j)(k)) {\n               \
    \             dp(i)(j)(k) = dp(i + 1)(j)(k - 1) + grid(i)(j)\n               \
    \         }\n                    }\n                }\n                if (j >\
    \ 0", "        val n = grid.length\n        val m = grid(0).length\n        val\
    \ dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n      \
    \      for (j <- 0 until m) {\n                if (i == 0 && j == 0) dp(i)(j)\
    \ = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (dp(i)(j - 1)\
    \ :+ grid(i)(j)).sortWith(_ < _)\n                else if (j == 0) dp(i)(j) =\
    \ (dp(i - 1)(j) :+ grid(i)(j)).sortWith(_ < _)\n                else {\n     \
    \               val l = dp(i - 1)(j) :+ grid(i)(j)\n                    val r\
    \ = dp(i)(j - 1) :+ grid(i)(j)\n                    if (l.length < r.length) dp(i)(j)\
    \ = l.sortWith(_ < _)\n                    else if (l.length > r.length) dp(i)(j)\
    \ = r.sortWith(_ < _)\n                    else dp(i)(j) = if (l < r) l else r\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                else {\n                    val lst1 = dp(i - 1)(j) :+ grid(i)(j)\n\
    \                    val lst2 = dp(i)(j - 1) :+ grid(i)(j)\n                 \
    \   dp(i)(j) = if (lst1.sorted < lst2.sorted) lst1 else lst2\n               \
    \ }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "    \
    \    val n = grid.length\n        val dp = Array.fill(n, n)(Long.MaxValue)\n \
    \       val prev = Array.fill(n, n)(-1)\n        for (i <- 0 until n) {\n    \
    \        for (j <- 0 until n) {\n                if (i == 0 && j == 0) {\n   \
    \                 dp(i)(j) = grid(i)(j)\n                } else if (i == 0) {\n\
    \                    dp(i)(j) = dp(i)(j - 1) + grid(i)(j)\n                  \
    \  prev(i)(j) = 1\n                } else if (j == 0) {\n                    dp(i)(j)\
    \ = dp(i - 1)(j) + grid(i)(j)\n                    prev(i)(j) = 0\n          \
    \      } else {\n                    if (dp(i - 1)(j) < dp(i)(j - 1)) {\n    \
    \                    dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n                  \
    \      prev(i)(j) = 0\n                    } else {\n                        dp(i)(j)\
    \ = dp(i)(j - 1) + grid(i)(j)\n                        prev(i)(j) = 1\n      \
    \              }\n                }\n            }\n        }\n        var i =\
    \ n - 1\n        var j = n - 1\n        var path = List[Long]()\n        while\
    \ (i != 0 || j != 0) {\n            path = grid(i)(j) :: path\n            if\
    \ (prev(i)(j) == 0) i -= 1\n            else j -= 1\n        }\n        path =\
    \ grid(0)(0) :: path\n        path", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until m) {\n              \
    \  if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else if\
    \ (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n                else\
    \ if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n               \
    \ else {\n                    val a = dp(i)(j - 1) :+ grid(i)(j)\n           \
    \         val b = dp(i - 1)(j) :+ grid(i)(j)\n                    if (a.sorted\
    \ < b.sorted) dp(i)(j) = a\n                    else dp(i)(j) = b\n          \
    \      }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", " \
    \       val n = grid.length\n        val dp = Array.fill(n, n)(Long.MaxValue)\n\
    \        val prev = Array.fill(n, n)(-1)\n        for (i <- 0 until n) {\n   \
    \         for (j <- 0 until n) {\n                if (i == 0 && j == 0) {\n  \
    \                  dp(i)(j) = grid(i)(j)\n                } else if (i == 0) {\n\
    \                    dp(i)(j) = dp(i)(j - 1) + grid(i)(j)\n                  \
    \  prev(i)(j) = 1\n                } else if (j == 0) {\n                    dp(i)(j)\
    \ = dp(i - 1)(j) + grid(i)(j)\n                    prev(i)(j) = 0\n          \
    \      } else {\n                    if (dp(i - 1)(j) < dp(i)(j - 1)) {\n    \
    \                    dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n                  \
    \      prev(i)(j) = 0\n                    } else {\n                        dp(i)(j)\
    \ = dp(i)(j - 1) + grid(i)(j)\n                        prev(i)(j) = 1\n      \
    \              }\n                }\n            }\n        }\n        val path\
    \ = ArrayBuffer[Long]()\n        var i = n - 1\n        var j = n - 1\n      \
    \  while (i >= 0 && j >= 0) {\n            path += grid(i)(j)\n            if\
    \ (prev(i)(j) == 0) i -= 1\n            else j -= 1\n        }\n        path.reverse.toList",
  "        // The idea is to use dynamic programming.\n        // Let dp(i, j, l)\
    \ be the minimum path of length l that starts from cell (i, j).\n        // dp(i,\
    \ j, l) = min(dp(i - 1, j, l - 1), dp(i + 1, j, l - 1), dp(i, j - 1, l - 1), dp(i,\
    \ j + 1, l - 1))\n        // dp(i, j, l) = grid(i)(j) + dp(i - 1, j, l - 1), dp(i\
    \ + 1, j, l - 1), dp(i, j - 1, l - 1), dp(i, j + 1, l - 1)\n        // dp(i, j,\
    \ l) = grid(i)(j) + min(dp(i - 1, j, l - 1), dp(i + 1, j, l - 1), dp(i, j - 1,\
    \ l - 1), dp(i, j + 1, l - 1))\n        // dp(i, j, l) = grid(i)(j) + min(dp(i\
    \ - 1, j, l - 1), dp(i + 1, j, l - 1), dp(i, j - 1, l - 1), dp(i, j + 1, l - 1))\n\
    \        // dp(i, j, l) = grid(i)(j) + min(dp(i - 1, j, l - 1), dp(i + 1, j, l\
    \ - 1), dp(i, j - 1, l - 1), dp(i, j + 1, l - 1))\n        // dp(i, j, l) = grid(i)(j)\
    \ + min(dp(i - 1, j, l - 1), dp(i + 1, j, l - 1), dp(i, j - 1, l - 1), dp(i, j\
    \ + 1, l - 1))\n        // dp(i, j, l) = grid(i)(j) + min(dp(i - 1, j, l - 1),\
    \ dp(i + 1, j", "        // Let's first find the minimum path of length k in the\
    \ grid.\n        // Let's use dynamic programming.\n        // Let's define dp(i,\
    \ j, l) to be the minimum path of length l starting from\n        // cell (i,\
    \ j).\n        // dp(i, j, l) = min(dp(i - 1, j, l - 1), dp(i + 1, j, l - 1),\
    \ dp(i, j - 1, l - 1), dp(i, j + 1, l - 1)) + grid(i)(j)\n        // dp(i, j,\
    \ 0) = grid(i)(j)\n        // dp(i, j, l) = -1 if l < 0\n        // dp(i, j, l)\
    \ = -1 if i < 0 || i >= N || j < 0 || j >= N\n        // dp(i, j, l) = -1 if l\
    \ > N * N\n        // dp(i, j, l) = -1 if dp(i - 1, j, l - 1) = -1 && dp(i + 1,\
    \ j, l - 1) = -1 && dp(i, j - 1, l - 1) = -1 && dp(i, j + 1, l - 1) = -1\n   \
    \     // dp(i, j, l) = -1 if dp(i - 1, j, l - 1) = -1 && dp(i + 1, j, l - 1) =\
    \ -1 && dp(i, j - 1, l - 1) = -1 && dp(i, j + 1, l - 1) = -1\n        val N =\
    \ grid.length\n        val dp = Array.fill(N, N, k.toInt + 1)(-1L)\n        for\
    \ (i <- 0 until N; j <- 0 until N) {\n            dp(i)(j)(0) = grid(i)(j)\n \
    \       }\n        for (l <- 1 to k.toInt) {\n            for (i <- 0 until N;\
    \ j <- 0 until N) {\n                if (i > 0 && dp(i - 1)(j)(l - 1)", "    \
    \    val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val prev = Array.fill(n, m)((0, 0))\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (i\
    \ == 0 && j == 0) {\n                    dp(i)(j) = grid(i)(j)\n             \
    \   } else {\n                    if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n  \
    \                      dp(i)(j) = dp(i - 1)(j)\n                        prev(i)(j)\
    \ = (i - 1, j)\n                    }\n                    if (j > 0 && dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                        dp(i)(j) = dp(i)(j - 1)\n      \
    \                  prev(i)(j) = (i, j - 1)\n                    }\n          \
    \          dp(i)(j) += grid(i)(j)\n                }\n            }\n        }\n\
    \        var x = n - 1\n        var y = m - 1\n        val ans = ListBuffer[Long]()\n\
    \        while (k > 0) {\n            ans += grid(x)(y)\n            val (nx,\
    \ ny) = prev(x)(y)\n            x = nx\n            y = ny\n            k -= 1\n\
    \        }\n        ans.toList", "        val n = grid.length\n        val m =\
    \ grid(0).length\n        val dp = Array.fill(n, m)(List(Long.MaxValue))\n   \
    \     val visited = Array.fill(n, m)(false)\n        val queue = new Queue[(Int,\
    \ Int)]\n        queue.enqueue((0, 0))\n        dp(0)(0) = List(grid(0)(0))\n\
    \        while (!queue.isEmpty) {\n            val (i, j) = queue.dequeue\n  \
    \          if (!visited(i)(j)) {\n                visited(i)(j) = true\n     \
    \           if (i > 0 && dp(i - 1)(j).length > k) {\n                    val newPath\
    \ = grid(i)(j) :: dp(i - 1)(j)\n                    if (newPath < dp(i)(j)) {\n\
    \                        dp(i)(j) = newPath\n                        queue.enqueue((i,\
    \ j))\n                    }\n                }\n                if (i < n - 1\
    \ && dp(i + 1)(j).length > k) {\n                    val newPath = grid(i)(j)\
    \ :: dp(i + 1)(j)\n                    if (newPath < dp(i)(j)) {\n           \
    \             dp(i)(j) = newPath\n                        queue.enqueue((i, j))\n\
    \                    }\n                }\n                if (j > 0 && dp(i)(j\
    \ - 1).length > k) {\n                    val newPath = grid(i)(j) :: dp(i)(j\
    \ - 1)\n                    if (newPath < dp(i)(j)) {\n                      \
    \  dp(i)(j) = newPath\n                        queue.enqueue((i, j))\n       \
    \             }\n                }\n                if (j < m - 1 && dp(i)(j +\
    \ 1).length > k) {\n                    val newPath = grid(i)(j) :: dp(i)(j +\
    \ 1)\n                    if (newPath < dp(i)(j)) {\n                        dp(i)(j)\
    \ = newPath\n                        queue.enqueue((i, j))\n                 \
    \   }\n                }\n            }\n        }\n        dp(n - 1", "     \
    \   val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    var lst = List[Long]()\n          \
    \          if (i > 0) lst = dp(i - 1)(j)\n                    if (j > 0 && (lst.isEmpty\
    \ || lst.last > dp(i)(j - 1).last)) lst = dp(i)(j - 1)\n                    if\
    \ (lst.length < k) lst = lst :+ grid(i)(j)\n                    dp(i)(j) = lst\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1)", "   \
    \     val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n \
    \       for (i <- 0 until n) {\n            for (j <- 0 until n) {\n         \
    \       if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    val up = if (i > 0) dp(i - 1)(j) else List[Long]()\n\
    \                    val left = if (j > 0) dp(i)(j - 1) else List[Long]()\n  \
    \                  if (up.length == left.length) {\n                        if\
    \ (up.length == 0) dp(i)(j) = List(grid(i)(j))\n                        else {\n\
    \                            if (up.last < left.last) dp(i)(j) = up :+ grid(i)(j)\n\
    \                            else dp(i)(j) = left :+ grid(i)(j)\n            \
    \            }\n                    }\n                    else if (up.length\
    \ < left.length) dp(i)(j) = up :+ grid(i)(j)\n                    else dp(i)(j)\
    \ = left :+ grid(i)(j)\n                }\n            }\n        }\n        dp(n\
    \ - 1)(n - 1).take(k.toInt)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long,\
    \ Int, Int)]()(Ordering.by(_._1))\n        pq.enqueue((0, 0, 0))\n        while\
    \ (!pq.isEmpty) {\n            val (cost, x, y) = pq.dequeue\n            if (dp(x)(y)\
    \ > cost) {\n                dp(x)(y) = cost\n                if (x > 0) pq.enqueue((cost\
    \ + grid(x - 1)(y), x - 1, y))\n                if (x < n - 1) pq.enqueue((cost\
    \ + grid(x + 1)(y), x + 1, y))\n                if (y > 0) pq.enqueue((cost +\
    \ grid(x)(y - 1), x, y - 1))\n                if (y < m - 1) pq.enqueue((cost\
    \ + grid(x)(y + 1), x, y + 1))\n            }\n        }\n        val pq2 = new\
    \ PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n        pq2.enqueue((0,\
    \ 0, 0))\n        val visited = Array.fill(n, m)(false)\n        var result =\
    \ List[Long]()\n        while (!pq2.isEmpty) {\n            val (cost, x, y) =\
    \ pq2.dequeue\n            if (!visited(x)(y)) {\n                visited(x)(y)\
    \ = true\n                result = result :+ grid(x)(y)\n                if (result.length\
    \ == k) return result\n                if (x > 0 && dp(x - 1)(y) == cost + grid(x)(y))\
    \ pq2.enqueue((cost + grid(x)(y), x - 1, y))\n                if (x < n - 1 &&\
    \ dp(x + 1)(y) == cost + grid(x)(y)) pq2.enqueue((cost + grid(x)(y), x + 1, y))\n\
    \                if (y > 0 && dp(x", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until m) {\n              \
    \  if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else {\n\
    \                    val lst = ListBuffer[List[Long]]()\n                    if\
    \ (i > 0) lst += (grid(i)(j) :: dp(i - 1)(j))\n                    if (j > 0)\
    \ lst += (grid(i)(j) :: dp(i)(j - 1))\n                    if (lst.length > 0)\
    \ dp(i)(j) = lst.min\n                }\n            }\n        }\n        dp(n\
    \ - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    val\
    \ lst = ListBuffer[Long]()\n                    if (i > 0) lst ++= dp(i - 1)(j)\n\
    \                    if (j > 0) lst ++= dp(i)(j - 1)\n                    val\
    \ min = lst.minBy(x => (x, x.length))\n                    dp(i)(j) = min :+ grid(i)(j)\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        val dirs = List((0, 1), (0, -1), (1, 0), (-1, 0))\n\
    \        val queue = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        for (i <- 0 until n; j <- 0 until m) {\n            dp(i)(j) = List(grid(i)(j))\n\
    \            queue.enqueue((grid(i)(j), i, j))\n        }\n        for (i <- 1\
    \ to k.toInt) {\n            val (v, x, y) = queue.dequeue\n            for ((dx,\
    \ dy) <- dirs) {\n                val nx = x + dx\n                val ny = y\
    \ + dy\n                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {\n      \
    \              val nv = v + grid(nx)(ny)\n                    if (nv < queue.head._1)\
    \ {\n                        queue.enqueue((nv, nx, ny))\n                   \
    \     dp(nx)(ny) = dp(x)(y) :+ grid(nx)(ny)\n                    }\n         \
    \       }\n            }\n        }\n        dp(queue.head._2)(queue.head._3)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    val up = if (i > 0) dp(i - 1)(j) else\
    \ List[Long]()\n                    val left = if (j > 0) dp(i)(j - 1) else List[Long]()\n\
    \                    if (up.length == left.length) {\n                       \
    \ if (up.length == 0) dp(i)(j) = List(grid(i)(j))\n                        else\
    \ {\n                            if (up.last < left.last) dp(i)(j) = up :+ grid(i)(j)\n\
    \                            else dp(i)(j) = left :+ grid(i)(j)\n            \
    \            }\n                    }\n                    else if (up.length\
    \ < left.length) dp(i)(j) = up :+ grid(i)(j)\n                    else dp(i)(j)\
    \ = left :+ grid(i)(j)\n                }\n            }\n        }\n        dp(n\
    \ - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    var\
    \ min = List[Long]()\n                    if (i > 0) {\n                     \
    \   val prev = dp(i - 1)(j)\n                        if (prev.length < k) min\
    \ = prev :+ grid(i)(j)\n                        else if (prev.length == k) min\
    \ = if (prev.last > grid(i)(j)) prev :+ grid(i)(j) else prev\n               \
    \     }\n                    if (j > 0) {\n                        val prev =\
    \ dp(i)(j - 1)\n                        if (prev.length < k) {\n             \
    \               if (min.length == 0 || min.last > prev.last) min = prev :+ grid(i)(j)\n\
    \                        }\n                        else if (prev.length == k)\
    \ {\n                            if (min.length == 0 || min.last > prev.last)\
    \ min = if (prev.last > grid(i)(j)) prev :+ grid(i)(j) else prev\n           \
    \             }\n                    }\n                    dp(i)(j) = min\n \
    \               }\n            }\n        }\n        dp(n - 1)(m - 1)", "    \
    \    val n = grid.length\n        val dp = Array.fill(n, n)(Long.MaxValue)\n \
    \       val path = Array.fill(n, n)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until n) {\n                if (i == 0 && j == 0)\
    \ {\n                    dp(i)(j) = grid(i)(j)\n                    path(i)(j)\
    \ = List(grid(i)(j))\n                }\n                else {\n            \
    \        val candidates = List((i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)).filter(p\
    \ => p._1 >= 0 && p._1 < n && p._2 >= 0 && p._2 < n)\n                    for\
    \ (candidate <- candidates) {\n                        val (x, y) = candidate\n\
    \                        if (dp(x)(y) + grid(i)(j) < dp(i)(j)) {\n           \
    \                 dp(i)(j) = dp(x)(y) + grid(i)(j)\n                         \
    \   path(i)(j) = path(x)(y) :+ grid(i)(j)\n                        }\n       \
    \                 else if (dp(x)(y) + grid(i)(j) == dp(i)(j)) {\n            \
    \                val newPath = path(x)(y) :+ grid(i)(j)\n                    \
    \        if (newPath < path(i)(j)) {\n                                path(i)(j)\
    \ = newPath\n                            }\n                        }\n      \
    \              }\n                }\n            }\n        }\n        path(n\
    \ - 1)(n - 1).take(k.toInt)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = dp(i)(j\
    \ - 1) :+ grid(i)(j)\n                else if (j == 0) dp(i)(j) = dp(i - 1)(j)\
    \ :+ grid(i)(j)\n                else {\n                    val a = dp(i - 1)(j)\
    \ :+ grid(i)(j)\n                    val b = dp(i)(j - 1) :+ grid(i)(j)\n    \
    \                if (a.length == b.length) dp(i)(j) = if (a < b) a else b\n  \
    \                  else dp(i)(j) = if (a.length < b.length) a else b\n       \
    \         }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        val v = grid(i)(j)\n                val lst = List(v)\n             \
    \   dp(i)(j) = lst\n                if (i > 0 && dp(i - 1)(j).length < k) {\n\
    \                    val lst2 = dp(i - 1)(j) :+ v\n                    if (lst2.length\
    \ == k) dp(i)(j) = lst2\n                    else if (lst2.length < k && lst2\
    \ < dp(i)(j)) dp(i)(j) = lst2\n                }\n                if (j > 0 &&\
    \ dp(i)(j - 1).length < k) {\n                    val lst2 = dp(i)(j - 1) :+ v\n\
    \                    if (lst2.length == k) dp(i)(j) = lst2\n                 \
    \   else if (lst2.length < k && lst2 < dp(i)(j)) dp(i)(j) = lst2\n           \
    \     }\n            }\n        }\n        dp(n - 1)(n - 1)", "        val n =\
    \ grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                else {\n                    val lst1 = dp(i - 1)(j) :+ grid(i)(j)\n\
    \                    val lst2 = dp(i)(j - 1) :+ grid(i)(j)\n                 \
    \   dp(i)(j) = if (lst1.sorted < lst2.sorted) lst1 else lst2\n               \
    \ }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "    \
    \    val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n      \
    \          else if (j == 0) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n          \
    \      else {\n                    val up = dp(i - 1)(j) :+ grid(i)(j)\n     \
    \               val left = dp(i)(j - 1) :+ grid(i)(j)\n                    if\
    \ (up.length == left.length) {\n                        if (up < left) dp(i)(j)\
    \ = up\n                        else dp(i)(j) = left\n                    }\n\
    \                    else if (up.length < left.length) dp(i)(j) = up\n       \
    \             else dp(i)(j) = left\n                }\n            }\n       \
    \ }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n \
    \       val dp = Array.fill(n, n)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until n) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    val\
    \ l = if (i > 0) dp(i - 1)(j) else List[Long]()\n                    val u = if\
    \ (j > 0) dp(i)(j - 1) else List[Long]()\n                    if (l.length ==\
    \ u.length) {\n                        if (l.length < k) dp(i)(j) = (l :+ grid(i)(j)).sorted\n\
    \                        else if (l.length == k) dp(i)(j) = (l :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                        else dp(i)(j) = List[Long]()\n                    }\n\
    \                    else if (l.length < u.length) {\n                       \
    \ if (l.length < k) dp(i)(j) = (l :+ grid(i)(j)).sorted\n                    \
    \    else if (l.length == k) dp(i)(j) = (l :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                        else dp(i)(j) = List[Long]()\n                    }\n\
    \                    else {\n                        if (u.length < k) dp(i)(j)\
    \ = (u :+ grid(i)(j)).sorted\n                        else if (u.length == k)\
    \ dp(i)(j) = (u :+ grid(i)(j)).sorted.take(k.toInt)\n                        else\
    \ dp(i)(j) = List[Long]()\n                    }\n                }\n        \
    \    }\n        }\n        dp(n - 1)(n - 1)", "        val n = grid.length\n \
    \       val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        val cur = grid(i)(j)\n                if (i == 0 && j == 0) dp(i)(j)\
    \ = List(cur)\n                else if (i == 0) {\n                    val prev\
    \ = dp(i)(j - 1)\n                    if (prev.length < k) dp(i)(j) = prev :+\
    \ cur\n                    else if (prev.length == k) {\n                    \
    \    if (prev.last < cur) dp(i)(j) = prev :+ cur\n                        else\
    \ dp(i)(j) = prev\n                    }\n                    else dp(i)(j) =\
    \ prev\n                }\n                else if (j == 0) {\n              \
    \      val prev = dp(i - 1)(j)\n                    if (prev.length < k) dp(i)(j)\
    \ = prev :+ cur\n                    else if (prev.length == k) {\n          \
    \              if (prev.last < cur) dp(i)(j) = prev :+ cur\n                 \
    \       else dp(i)(j) = prev\n                    }\n                    else\
    \ dp(i)(j) = prev\n                }\n                else {\n               \
    \     val prev1 = dp(i - 1)(j)\n                    val prev2 = dp(i)(j - 1)\n\
    \                    if (prev1.length < k && prev2.length < k) {\n           \
    \             if (prev1.last < prev2.last) dp(i)(j) = prev1 :+ cur\n         \
    \               else dp(i)(j) = prev2 :+ cur\n                    }\n        \
    \            else if (prev1.length < k) {\n                        if (prev1.last\
    \ < prev2.last) dp(i)(j) = prev1 :+ cur\n                        else dp(i)(j)\
    \ = prev2\n                    }\n                    else if (prev2.length <\
    \ k) {\n                        if (prev1.last < prev2.last) dp(i)(j) = prev1\n\
    \                        else dp(", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until m) {\n              \
    \  if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else {\n\
    \                    if (i > 0) {\n                        val lst = dp(i - 1)(j)\n\
    \                        if (lst.length < k) dp(i)(j) = grid(i)(j) :: lst\n  \
    \                      else if (lst.length == k) {\n                         \
    \   val lst2 = grid(i)(j) :: lst\n                            if (lst2 < dp(i)(j))\
    \ dp(i)(j) = lst2\n                        }\n                    }\n        \
    \            if (j > 0) {\n                        val lst = dp(i)(j - 1)\n  \
    \                      if (lst.length < k) dp(i)(j) = grid(i)(j) :: lst\n    \
    \                    else if (lst.length == k) {\n                           \
    \ val lst2 = grid(i)(j) :: lst\n                            if (lst2 < dp(i)(j))\
    \ dp(i)(j) = lst2\n                        }\n                    }\n        \
    \        }\n            }\n        }\n        dp(n - 1)(m - 1)", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                val cur = grid(i)(j)\n                val lst = List(cur)\n\
    \                if (i == 0 && j == 0) dp(i)(j) = lst\n                else if\
    \ (i == 0) {\n                    val prev = dp(i)(j - 1)\n                  \
    \  if (prev.length < k) dp(i)(j) = lst ::: prev\n                    else if (prev.length\
    \ == k) {\n                        if (cur < prev.head) dp(i)(j) = lst\n     \
    \                   else dp(i)(j) = prev\n                    }\n            \
    \        else dp(i)(j) = prev\n                }\n                else if (j ==\
    \ 0) {\n                    val prev = dp(i - 1)(j)\n                    if (prev.length\
    \ < k) dp(i)(j) = lst ::: prev\n                    else if (prev.length == k)\
    \ {\n                        if (cur < prev.head) dp(i)(j) = lst\n           \
    \             else dp(i)(j) = prev\n                    }\n                  \
    \  else dp(i)(j) = prev\n                }\n                else {\n         \
    \           val prev1 = dp(i - 1)(j)\n                    val prev2 = dp(i)(j\
    \ - 1)\n                    if (prev1.length < k && prev2.length < k) {\n    \
    \                    if (prev1.length < prev2.length) dp(i)(j) = lst ::: prev1\n\
    \                        else if (prev1.length > prev2.length) dp(i)(j) = lst\
    \ ::: prev2\n                        else {\n                            if (prev1.head\
    \ < prev2.head) dp(i)(j) = lst ::: prev1\n                            else dp(i)(j)\
    \ = lst ::: prev2\n                        }\n                    }\n        \
    \            else if (prev1.length < k) {\n                        if (prev2.length\
    \ == k) {", "        // The idea is to use dynamic programming.\n        // Let\
    \ dp(i, j, l) be the minimum path of length l that starts from cell (i, j).\n\
    \        // dp(i, j, l) = min(dp(i + 1, j, l - 1), dp(i - 1, j, l - 1), dp(i,\
    \ j + 1, l - 1), dp(i, j - 1, l - 1))\n        // dp(i, j, l) = grid(i)(j) + dp(i\
    \ + 1, j, l - 1), dp(i - 1, j, l - 1), dp(i, j + 1, l - 1), dp(i, j - 1, l - 1))\n\
    \        // dp(i, j, l) = grid(i)(j) + min(dp(i + 1, j, l - 1), dp(i - 1, j, l\
    \ - 1), dp(i, j + 1, l - 1), dp(i, j - 1, l - 1))\n        // dp(i, j, l) = grid(i)(j)\
    \ + min(dp(i + 1, j, l - 1), dp(i - 1, j, l - 1), dp(i, j + 1, l - 1), dp(i, j\
    \ - 1, l - 1))\n        // dp(i, j, l) = grid(i)(j) + min(dp(i + 1, j, l - 1),\
    \ dp(i - 1, j, l - 1), dp(i, j + 1, l - 1), dp(i, j - 1, l - 1))\n        // dp(i,\
    \ j, l) = grid(i)(j) + min(dp(i + 1, j, l - 1), dp(i - 1, j, l - 1), dp(i, j +\
    \ 1, l - 1), dp(i, j - 1, l - 1))\n        // dp(i, j, l) = grid(i)(j) + min(dp(i\
    \ + 1, j, l - 1), dp(i - 1, j", "        val n = grid.length\n        val m =\
    \ grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n        val\
    \ pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n        pq.enqueue((0,\
    \ 0, 0))\n        while (!pq.isEmpty) {\n            val (cost, i, j) = pq.dequeue\n\
    \            if (dp(i)(j) > cost) {\n                dp(i)(j) = cost\n       \
    \         if (i > 0) pq.enqueue((cost + grid(i - 1)(j), i - 1, j))\n         \
    \       if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j), i + 1, j))\n       \
    \         if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i, j - 1))\n         \
    \       if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i, j + 1))\n       \
    \     }\n        }\n        val result = new ListBuffer[Long]\n        var i =\
    \ 0\n        var j = 0\n        var cost = 0L\n        while (result.length <\
    \ k) {\n            result += grid(i)(j)\n            if (i > 0 && dp(i - 1)(j)\
    \ < dp(i)(j)) {\n                i -= 1\n                cost += grid(i)(j)\n\
    \            } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j)) {\n            \
    \    i += 1\n                cost += grid(i)(j)\n            } else if (j > 0\
    \ && dp(i)(j - 1) < dp(i)(j)) {\n                j -= 1\n                cost\
    \ += grid(i)(j)\n            } else if (j < m - 1 && dp(i)(j + 1) < dp(i)(j))\
    \ {\n                j += 1\n                cost += grid(i)(j)\n            }\n\
    \        }\n        result.toList", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n     \
    \   val prev = Array.fill(n, m)(-1)\n        dp(0)(0) = grid(0)(0)\n        for\
    \ (i <- 0 until n; j <- 0 until m) {\n            if (i > 0 && dp(i - 1)(j) +\
    \ grid(i)(j) < dp(i)(j)) {\n                dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n\
    \                prev(i)(j) = 0\n            }\n            if (j > 0 && dp(i)(j\
    \ - 1) + grid(i)(j) < dp(i)(j)) {\n                dp(i)(j) = dp(i)(j - 1) + grid(i)(j)\n\
    \                prev(i)(j) = 1\n            }\n            if (i < n - 1 && dp(i\
    \ + 1)(j) + grid(i)(j) < dp(i)(j)) {\n                dp(i)(j) = dp(i + 1)(j)\
    \ + grid(i)(j)\n                prev(i)(j) = 2\n            }\n            if\
    \ (j < m - 1 && dp(i)(j + 1) + grid(i)(j) < dp(i)(j)) {\n                dp(i)(j)\
    \ = dp(i)(j + 1) + grid(i)(j)\n                prev(i)(j) = 3\n            }\n\
    \        }\n        val path = ListBuffer[Long]()\n        var i = n - 1\n   \
    \     var j = m - 1\n        while (k > 0) {\n            path += grid(i)(j)\n\
    \            k -= 1\n            prev(i)(j) match {\n                case 0 =>\
    \ i -= 1\n                case 1 => j -= 1\n                case 2 => i += 1\n\
    \                case 3 => j += 1\n            }\n        }\n        path.toList",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (d, i, j) = pq.dequeue\n            if (dp(i)(j) > d) {\n                dp(i)(j)\
    \ = d\n                if (i > 0) pq.enqueue((d + grid(i - 1)(j), i - 1, j))\n\
    \                if (i < n - 1) pq.enqueue((d + grid(i + 1)(j), i + 1, j))\n \
    \               if (j > 0) pq.enqueue((d + grid(i)(j - 1), i, j - 1))\n      \
    \          if (j < m - 1) pq.enqueue((d + grid(i)(j + 1), i, j + 1))\n       \
    \     }\n        }\n        val (d, i, j) = pq.dequeue\n        val path = new\
    \ ListBuffer[Long]\n        path += grid(i)(j)\n        var x = i\n        var\
    \ y = j\n        for (l <- 1 until k.toInt) {\n            var min = Long.MaxValue\n\
    \            var minI = -1\n            var minJ = -1\n            if (x > 0 &&\
    \ dp(x - 1)(y) < min) {\n                min = dp(x - 1)(y)\n                minI\
    \ = x - 1\n                minJ = y\n            }\n            if (x < n - 1\
    \ && dp(x + 1)(y) < min) {\n                min = dp(x + 1)(y)\n             \
    \   minI = x + 1\n                minJ = y\n            }\n            if (y >\
    \ 0 && dp(x)(y - 1) < min) {\n                min = dp(x)(y - 1)\n           \
    \     minI = x\n                minJ = y - 1\n            }\n            if (y\
    \ < m - 1", "        val n = grid.length\n        val dp = Array.fill(n, n)(0L)\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        dp(i)(j) = grid(i)(j)\n                if (i > 0) dp(i)(j) = min(dp(i)(j),\
    \ dp(i - 1)(j))\n                if (j > 0) dp(i)(j) = min(dp(i)(j), dp(i)(j -\
    \ 1))\n            }\n        }\n        val result = ListBuffer[Long]()\n   \
    \     var i = n - 1\n        var j = n - 1\n        while (k > 0) {\n        \
    \    result += dp(i)(j)\n            k -= 1\n            if (i > 0 && dp(i - 1)(j)\
    \ < dp(i)(j)) {\n                i -= 1\n            } else if (j > 0 && dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                j -= 1\n            } else {\n         \
    \       i -= 1\n                j -= 1\n            }\n        }\n        result.toList",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = grid(i)(j) :: dp(i)(j - 1)\n      \
    \          else if (j == 0) dp(i)(j) = grid(i)(j) :: dp(i - 1)(j)\n          \
    \      else {\n                    val l1 = grid(i)(j) :: dp(i)(j - 1)\n     \
    \               val l2 = grid(i)(j) :: dp(i - 1)(j)\n                    if (l1\
    \ < l2) dp(i)(j) = l1\n                    else dp(i)(j) = l2\n              \
    \  }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "   \
    \     val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                val cur = grid(i)(j)\n                val lst = List(cur)\n\
    \                if (i == 0 && j == 0) dp(i)(j) = lst\n                else if\
    \ (i == 0) {\n                    val prev = dp(i)(j - 1)\n                  \
    \  if (prev.length < k) dp(i)(j) = lst ::: prev\n                    else if (prev.length\
    \ == k) dp(i)(j) = if (prev.head < cur) prev else lst ::: prev\n             \
    \       else dp(i)(j) = prev\n                }\n                else if (j ==\
    \ 0) {\n                    val prev = dp(i - 1)(j)\n                    if (prev.length\
    \ < k) dp(i)(j) = lst ::: prev\n                    else if (prev.length == k)\
    \ dp(i)(j) = if (prev.head < cur) prev else lst ::: prev\n                   \
    \ else dp(i)(j) = prev\n                }\n                else {\n          \
    \          val prev1 = dp(i - 1)(j)\n                    val prev2 = dp(i)(j -\
    \ 1)\n                    if (prev1.length < k && prev2.length < k) {\n      \
    \                  if (prev1.head < prev2.head) dp(i)(j) = lst ::: prev1\n   \
    \                     else dp(i)(j) = lst ::: prev2\n                    }\n \
    \                   else if (prev1.length < k) {\n                        if (prev1.head\
    \ < cur) dp(i)(j) = lst ::: prev1\n                        else dp(i)(j) = prev2\n\
    \                    }\n                    else if (prev2.length < k) {\n   \
    \                     if (prev2.head < cur) dp(i)(j) = lst ::: prev2\n       \
    \                 else dp(i)(j) = prev1\n                    }\n             \
    \       else {\n                        if (prev", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    if (i > 0) {\n                        val lst = dp(i\
    \ - 1)(j)\n                        if (lst.length < k && (dp(i)(j).length == 0\
    \ || lst.length < dp(i)(j).length || (lst.length == dp(i)(j).length && lst < dp(i)(j))))\
    \ dp(i)(j) = lst :+ grid(i)(j)\n                    }\n                    if\
    \ (j > 0) {\n                        val lst = dp(i)(j - 1)\n                \
    \        if (lst.length < k && (dp(i)(j).length == 0 || lst.length < dp(i)(j).length\
    \ || (lst.length == dp(i)(j).length && lst < dp(i)(j)))) dp(i)(j) = lst :+ grid(i)(j)\n\
    \                    }\n                }\n            }\n        }\n        dp(n\
    \ - 1)(m - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else {\n                    if\
    \ (i > 0) {\n                        val lst = dp(i - 1)(j)\n                \
    \        if (lst.length < k) dp(i)(j) = grid(i)(j) :: lst\n                  \
    \      else if (lst.length == k) {\n                            val lst2 = grid(i)(j)\
    \ :: lst\n                            if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n \
    \                       }\n                    }\n                    if (j >\
    \ 0) {\n                        val lst = dp(i)(j - 1)\n                     \
    \   if (lst.length < k) dp(i)(j) = grid(i)(j) :: lst\n                       \
    \ else if (lst.length == k) {\n                            val lst2 = grid(i)(j)\
    \ :: lst\n                            if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n \
    \                       }\n                    }\n                }\n        \
    \    }\n        }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n \
    \       val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val ans = ArrayBuffer[Long]()\n \
    \       var i = 0\n        var j = 0\n        while (ans.length < k) {\n     \
    \       ans += grid(i)(j)\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j)) {\n\
    \                i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j))\
    \ {\n                i += 1\n            } else if (j > 0 && dp(i)(j - 1) < dp(i)(j))\
    \ {\n                j -= 1\n            } else if (j < m - 1 && dp(i)(j + 1)\
    \ < dp(i)(j)) {\n                j += 1\n            }\n        }\n        ans.toList",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        var j = 0\n        var cost = 0L\n        while (result.length\
    \ < k) {\n            result += grid(i)(j)\n            if (i > 0 && dp(i - 1)(j)\
    \ < dp(i)(j)) {\n                i -= 1\n                cost += grid(i)(j)\n\
    \            } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j)) {\n            \
    \    i += 1\n                cost += grid(i)(j)\n            } else if (j > 0\
    \ && dp(i)(j - 1) < dp(i)(j)) {\n                j -= 1\n                cost\
    \ += grid(i)(j)\n            } else if (j < m - 1 && dp(i)(j + 1) < dp(i)(j))\
    \ {\n                j += 1\n                cost += grid(i)(j)\n            }\n\
    \        }\n        result.toList", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until m) {\n              \
    \  if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else {\n\
    \                    val l = if (i == 0) List[Long]() else dp(i - 1)(j)\n    \
    \                val u = if (j == 0) List[Long]() else dp(i)(j - 1)\n        \
    \            if (l.length == 0 && u.length == 0) dp(i)(j) = List(grid(i)(j))\n\
    \                    else if (l.length == 0) dp(i)(j) = u :+ grid(i)(j)\n    \
    \                else if (u.length == 0) dp(i)(j) = l :+ grid(i)(j)\n        \
    \            else if (l < u) dp(i)(j) = l :+ grid(i)(j)\n                    else\
    \ dp(i)(j) = u :+ grid(i)(j)\n                }\n            }\n        }\n  \
    \      dp(n - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n       \
    \ val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n  \
    \      for (i <- 0 until n) {\n            for (j <- 0 until m) {\n          \
    \      val l = List(grid(i)(j))\n                if (i == 0 && j == 0) dp(i)(j)\
    \ = l\n                else if (i == 0) dp(i)(j) = l :: dp(i)(j - 1)\n       \
    \         else if (j == 0) dp(i)(j) = l :: dp(i - 1)(j)\n                else\
    \ {\n                    val up = dp(i - 1)(j)\n                    val left =\
    \ dp(i)(j - 1)\n                    if (up.length < left.length) dp(i)(j) = l\
    \ :: up\n                    else if (up.length > left.length) dp(i)(j) = l ::\
    \ left\n                    else {\n                        var flag = false\n\
    \                        for (i <- 0 until up.length) {\n                    \
    \        if (up(i) < left(i)) {\n                                dp(i)(j) = l\
    \ :: up\n                                flag = true\n                       \
    \         break\n                            }\n                            else\
    \ if (up(i) > left(i)) {\n                                dp(i)(j) = l :: left\n\
    \                                flag = true\n                               \
    \ break\n                            }\n                        }\n          \
    \              if (!flag) dp(i)(j) = l :: up\n                    }\n        \
    \        }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val dp = Array.fill(n, n)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(x => x._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < n - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val res = new ListBuffer[Long]\n\
    \        var i = 0\n        var j = 0\n        var cost = 0L\n        while (res.length\
    \ < k) {\n            res += grid(i)(j)\n            if (i > 0 && dp(i - 1)(j)\
    \ < dp(i)(j)) {\n                i -= 1\n                cost += grid(i)(j)\n\
    \            } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j)) {\n            \
    \    i += 1\n                cost += grid(i)(j)\n            } else if (j > 0\
    \ && dp(i)(j - 1) < dp(i)(j)) {\n                j -= 1\n                cost\
    \ += grid(i)(j)\n            } else if (j < n - 1 && dp(i)(j + 1) < dp(i)(j))\
    \ {\n                j += 1\n                cost += grid(i)(j)\n            }\n\
    \        }\n        res.toList", "        val n = grid.length\n        val m =\
    \ grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                val\
    \ cur = grid(i)(j)\n                val lst = List(cur)\n                if (i\
    \ > 0) {\n                    val prev = dp(i - 1)(j)\n                    if\
    \ (prev.length + 1 == k) {\n                        if (prev < lst) dp(i)(j) =\
    \ prev\n                        else dp(i)(j) = lst\n                    }\n \
    \                   else if (prev.length + 1 < k) {\n                        if\
    \ (prev < lst) dp(i)(j) = prev :+ cur\n                        else dp(i)(j) =\
    \ lst\n                    }\n                }\n                if (j > 0) {\n\
    \                    val prev = dp(i)(j - 1)\n                    if (prev.length\
    \ + 1 == k) {\n                        if (prev < lst) dp(i)(j) = prev\n     \
    \                   else dp(i)(j) = lst\n                    }\n             \
    \       else if (prev.length + 1 < k) {\n                        if (prev < lst)\
    \ dp(i)(j) = prev :+ cur\n                        else dp(i)(j) = lst\n      \
    \              }\n                }\n            }\n        }\n        dp(n -\
    \ 1)(m - 1)", "        val n = grid.length\n        val dp = Array.fill(n, n)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < n - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val result = ArrayBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        while (result.length < k) {\n \
    \           result += grid(i)(j)\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j))\
    \ {\n                i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j)\
    \ < dp(i)(j)) {\n                i += 1\n            } else if (j > 0 && dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                j -= 1\n            } else if (j < n - 1\
    \ && dp(i)(j + 1) < dp(i)(j)) {\n                j += 1\n            }\n     \
    \   }\n        result.toList", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = dp(i)(j\
    \ - 1) :+ grid(i)(j)\n                else if (j == 0) dp(i)(j) = dp(i - 1)(j)\
    \ :+ grid(i)(j)\n                else {\n                    val up = dp(i - 1)(j)\
    \ :+ grid(i)(j)\n                    val left = dp(i)(j - 1) :+ grid(i)(j)\n \
    \                   if (up.length == left.length) dp(i)(j) = if (up < left) up\
    \ else left\n                    else dp(i)(j) = if (up.length < left.length)\
    \ up else left\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1).take(k.toInt)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted\n                else if (j == 0) dp(i)(j) = (dp(i\
    \ - 1)(j) :+ grid(i)(j)).sorted\n                else {\n                    val\
    \ a = dp(i)(j - 1) :+ grid(i)(j)\n                    val b = dp(i - 1)(j) :+\
    \ grid(i)(j)\n                    if (a.sorted < b.sorted) dp(i)(j) = a.sorted\n\
    \                    else dp(i)(j) = b.sorted\n                }\n           \
    \ }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    var min = List[Long]()\n                    if (i > 0)\
    \ {\n                        val lst = dp(i - 1)(j)\n                        if\
    \ (lst.length < k && (min.length == 0 || lst < min)) min = lst\n             \
    \       }\n                    if (j > 0) {\n                        val lst =\
    \ dp(i)(j - 1)\n                        if (lst.length < k && (min.length == 0\
    \ || lst < min)) min = lst\n                    }\n                    if (min.length\
    \ < k) dp(i)(j) = min :+ grid(i)(j)\n                }\n            }\n      \
    \  }\n        dp(n - 1)(m - 1)", "        // Let's use dynamic programming.\n\
    \        // Let's define dp(i, j, l) as the minimum path of length l starting\
    \ from\n        // cell (i, j).\n        // dp(i, j, l) = min(dp(i - 1, j, l -\
    \ 1), dp(i + 1, j, l - 1), dp(i, j - 1, l - 1), dp(i, j + 1, l - 1))\n       \
    \ // We can use a 3D array to store the values of dp.\n        // Time complexity:\
    \ O(N ^ 3)\n        // Space complexity: O(N ^ 3)\n        val n = grid.length\n\
    \        val dp = Array.ofDim[List[Long]](n, n, k.toInt + 1)\n        for (i <-\
    \ 0 until n; j <- 0 until n) {\n            dp(i)(j)(1) = List(grid(i)(j))\n \
    \       }\n        for (l <- 2 to k.toInt) {\n            for (i <- 0 until n;\
    \ j <- 0 until n) {\n                dp(i)(j)(l) = List(Long.MaxValue)\n     \
    \           if (i > 0) {\n                    val temp = dp(i - 1)(j)(l - 1) :+\
    \ grid(i)(j)\n                    if (temp < dp(i)(j)(l)) dp(i)(j)(l) = temp\n\
    \                }\n                if (i < n - 1) {\n                    val\
    \ temp = dp(i + 1)(j)(l - 1) :+ grid(i)(j)\n                    if (temp < dp(i)(j)(l))\
    \ dp(i)(j)(l) = temp\n                }\n                if (j > 0) {\n      \
    \              val temp = dp(i)(j - 1)(l - 1) :+ grid(i)(j)\n                \
    \    if (temp < dp(i)(j)(l)) dp(i)(j)(l) = temp\n                }\n         \
    \       if (j < n - 1) {\n                    val temp = dp(i)(j + 1)(l - 1) :+\
    \ grid(i)(j)\n                    if (temp <", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    if (i > 0) {\n                        val lst = dp(i\
    \ - 1)(j)\n                        if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n\
    \                        else {\n                            val lst2 = lst.tail\
    \ :+ grid(i)(j)\n                            if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n\
    \                        }\n                    }\n                    if (j >\
    \ 0) {\n                        val lst = dp(i)(j - 1)\n                     \
    \   if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n                       \
    \ else {\n                            val lst2 = lst.tail :+ grid(i)(j)\n    \
    \                        if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n              \
    \          }\n                    }\n                }\n            }\n      \
    \  }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n        val m =\
    \ grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (i\
    \ == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else {\n      \
    \              val lst = ListBuffer[List[Long]]()\n                    if (i >\
    \ 0) lst += dp(i - 1)(j)\n                    if (j > 0) lst += dp(i)(j - 1)\n\
    \                    if (i > 0 && j > 0) lst += dp(i - 1)(j - 1)\n           \
    \         if (lst.isEmpty) dp(i)(j) = List(grid(i)(j))\n                    else\
    \ {\n                        val min = lst.minBy(x => (x :+ grid(i)(j)).mkString)\n\
    \                        dp(i)(j) = min :+ grid(i)(j)\n                    }\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        val v = grid(i)(j)\n                if (i == 0 && j == 0) dp(i)(j) =\
    \ List(v)\n                else if (i == 0) {\n                    val prev =\
    \ dp(i)(j - 1)\n                    if (prev.length < k) dp(i)(j) = prev :+ v\n\
    \                    else if (prev.length == k) dp(i)(j) = if (prev.last < v)\
    \ prev else prev.init :+ v\n                }\n                else if (j == 0)\
    \ {\n                    val prev = dp(i - 1)(j)\n                    if (prev.length\
    \ < k) dp(i)(j) = prev :+ v\n                    else if (prev.length == k) dp(i)(j)\
    \ = if (prev.last < v) prev else prev.init :+ v\n                }\n         \
    \       else {\n                    val prev1 = dp(i - 1)(j)\n               \
    \     val prev2 = dp(i)(j - 1)\n                    if (prev1.length < k && prev2.length\
    \ < k) dp(i)(j) = if (prev1.last < prev2.last) prev1 :+ v else prev2 :+ v\n  \
    \                  else if (prev1.length < k) dp(i)(j) = if (prev1.last < v) prev1\
    \ :+ v else prev2.init :+ v\n                    else if (prev2.length < k) dp(i)(j)\
    \ = if (prev2.last < v) prev2 :+ v else prev1.init :+ v\n                    else\
    \ dp(i)(j) = if (prev1.last < prev2.last) prev1.init :+ v else prev2.init :+ v\n\
    \                }\n            }\n        }\n        dp(n - 1)(n - 1)", "   \
    \     val n = grid.length\n        val dp = Array.fill(n, n)(Long.MaxValue)\n\
    \        val path = Array.fill(n, n)(List[Long]())\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until n) {\n                if (i == 0 && j ==\
    \ 0) {\n                    dp(i)(j) = grid(i)(j)\n                    path(i)(j)\
    \ = List(grid(i)(j))\n                }\n                else {\n            \
    \        if (i > 0 && dp(i - 1)(j) + grid(i)(j) < dp(i)(j)) {\n              \
    \          dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n                        path(i)(j)\
    \ = path(i - 1)(j) :+ grid(i)(j)\n                    }\n                    if\
    \ (j > 0 && dp(i)(j - 1) + grid(i)(j) < dp(i)(j)) {\n                        dp(i)(j)\
    \ = dp(i)(j - 1) + grid(i)(j)\n                        path(i)(j) = path(i)(j\
    \ - 1) :+ grid(i)(j)\n                    }\n                }\n            }\n\
    \        }\n        path(n - 1)(n - 1).take(k.toInt)", "        val n = grid.length\n\
    \        val dp = Array.fill(n, n)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until n) {\n                dp(i)(j) = List(grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length <= k && dp(i - 1)(j).length\
    \ + 1 < dp(i)(j).length) {\n                    dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n\
    \                }\n                if (j > 0 && dp(i)(j - 1).length <= k && dp(i)(j\
    \ - 1).length + 1 < dp(i)(j).length) {\n                    dp(i)(j) = dp(i)(j\
    \ - 1) :+ grid(i)(j)\n                }\n            }\n        }\n        dp(n\
    \ - 1)(n - 1)", "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        val v = grid(i)(j)\n                val l = List(v)\n               \
    \ dp(i)(j) = l\n                if (i > 0) {\n                    val l2 = dp(i\
    \ - 1)(j)\n                    if (l2.length < k) {\n                        val\
    \ l3 = l2 ::: l\n                        if (l3.length <= k && (dp(i)(j).length\
    \ > l3.length || l3 < dp(i)(j))) dp(i)(j) = l3\n                    }\n      \
    \          }\n                if (j > 0) {\n                    val l2 = dp(i)(j\
    \ - 1)\n                    if (l2.length < k) {\n                        val\
    \ l3 = l2 ::: l\n                        if (l3.length <= k && (dp(i)(j).length\
    \ > l3.length || l3 < dp(i)(j))) dp(i)(j) = l3\n                    }\n      \
    \          }\n            }\n        }\n        dp(n - 1)(n - 1)", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                else {\n                    val a = dp(i)(j - 1) :+ grid(i)(j)\n\
    \                    val b = dp(i - 1)(j) :+ grid(i)(j)\n                    if\
    \ (a.sorted < b.sorted) dp(i)(j) = a.sorted\n                    else dp(i)(j)\
    \ = b.sorted\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1).take(k.toInt)", "        val n = grid.length\n        val dp = Array.fill(n,\
    \ n)(Long.MaxValue)\n        val prev = Array.fill(n, n)(-1)\n        val queue\
    \ = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n        for (i\
    \ <- 0 until n) {\n            dp(i)(0) = grid(i)(0)\n            queue.enqueue((dp(i)(0),\
    \ i, 0))\n        }\n        for (j <- 0 until n) {\n            dp(0)(j) = grid(0)(j)\n\
    \            queue.enqueue((dp(0)(j), 0, j))\n        }\n        for (i <- 1 until\
    \ n) {\n            for (j <- 1 until n) {\n                dp(i)(j) = min(dp(i\
    \ - 1)(j), dp(i)(j - 1)) + grid(i)(j)\n                queue.enqueue((dp(i)(j),\
    \ i, j))\n            }\n        }\n        var cur = (0, 0)\n        var cur_cost\
    \ = 0L\n        for (i <- 0 until k.toInt) {\n            val (cost, x, y) = queue.dequeue\n\
    \            cur = (x, y)\n            cur_cost = cost\n        }\n        val\
    \ result = new ListBuffer[Long]\n        while (cur != (-1, -1)) {\n         \
    \   result += grid(cur._1)(cur._2)\n            val (x, y) = cur\n           \
    \ cur = prev(x)(y)\n        }\n        result.toList.reverse", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                else {\n                    val a = dp(i)(j - 1) :+ grid(i)(j)\n\
    \                    val b = dp(i - 1)(j) :+ grid(i)(j)\n                    if\
    \ (a.sorted < b.sorted) dp(i)(j) = a.sorted\n                    else dp(i)(j)\
    \ = b.sorted\n                }\n            }\n        }\n        dp(n - 1)(m\
    \ - 1).take(k.toInt)", "        val n = grid.length\n        val dp = Array.fill(n,\
    \ n)(Long.MaxValue)\n        val prev = Array.fill(n, n)(-1)\n        val q =\
    \ new Queue[(Int, Int)]\n        for (i <- 0 until n) {\n            dp(i)(0)\
    \ = grid(i)(0)\n            q.enqueue((i, 0))\n        }\n        while (!q.isEmpty)\
    \ {\n            val (x, y) = q.dequeue\n            if (y + 1 < n) {\n      \
    \          if (dp(x)(y + 1) > dp(x)(y) + grid(x)(y + 1)) {\n                 \
    \   dp(x)(y + 1) = dp(x)(y) + grid(x)(y + 1)\n                    prev(x)(y +\
    \ 1) = x\n                    q.enqueue((x, y + 1))\n                }\n     \
    \           if (x - 1 >= 0 && dp(x - 1)(y + 1) > dp(x)(y) + grid(x - 1)(y + 1))\
    \ {\n                    dp(x - 1)(y + 1) = dp(x)(y) + grid(x - 1)(y + 1)\n  \
    \                  prev(x - 1)(y + 1) = x\n                    q.enqueue((x -\
    \ 1, y + 1))\n                }\n                if (x + 1 < n && dp(x + 1)(y\
    \ + 1) > dp(x)(y) + grid(x + 1)(y + 1)) {\n                    dp(x + 1)(y + 1)\
    \ = dp(x)(y) + grid(x + 1)(y + 1)\n                    prev(x + 1)(y + 1) = x\n\
    \                    q.enqueue((x + 1, y + 1))\n                }\n          \
    \  }\n        }\n        val min = dp.map(_.min).min\n        val (x, y) = dp.zipWithIndex.map(x\
    \ => (x._1.zipWithIndex.map(y => (y._1, (x._2, y._2))).minBy(_._1), x._2)).minBy(_._1._",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val prev = Array.fill(n, m)(-1)\n        val pq =\
    \ new mutable.PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n        pq.enqueue((0,\
    \ 0, 0))\n        while (!pq.isEmpty) {\n            val (cost, i, j) = pq.dequeue\n\
    \            if (dp(i)(j) > cost) {\n                dp(i)(j) = cost\n       \
    \         if (i > 0) {\n                    val newCost = cost + grid(i - 1)(j)\n\
    \                    if (newCost < dp(i - 1)(j)) {\n                        prev(i\
    \ - 1)(j) = i * m + j\n                        pq.enqueue((newCost, i - 1, j))\n\
    \                    }\n                }\n                if (i < n - 1) {\n\
    \                    val newCost = cost + grid(i + 1)(j)\n                   \
    \ if (newCost < dp(i + 1)(j)) {\n                        prev(i + 1)(j) = i *\
    \ m + j\n                        pq.enqueue((newCost, i + 1, j))\n           \
    \         }\n                }\n                if (j > 0) {\n               \
    \     val newCost = cost + grid(i)(j - 1)\n                    if (newCost < dp(i)(j\
    \ - 1)) {\n                        prev(i)(j - 1) = i * m + j\n              \
    \          pq.enqueue((newCost, i, j - 1))\n                    }\n          \
    \      }\n                if (j < m - 1) {\n                    val newCost =\
    \ cost + grid(i)(j + 1)\n                    if (newCost < dp(i)(j + 1)) {\n \
    \                       prev(i)(j + 1) = i * m + j\n                        pq.enqueue((newCost,\
    \ i, j + 1))\n                    }\n                }\n            }\n      \
    \  }\n        val result = new ListBuffer[Long]\n        var cur = 0\n       \
    \ for (i <- 0 until k)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(Long.MaxValue)\n        val prev = Array.fill(n,\
    \ m)(-1L)\n        val queue = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(-_._1))\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = grid(i)(j)\n                prev(i)(j) = -1\n            \
    \    queue.enqueue((grid(i)(j), i, j))\n            }\n        }\n        while\
    \ (!queue.isEmpty) {\n            val (cost, i, j) = queue.dequeue\n         \
    \   if (cost > dp(i)(j)) continue\n            for (d <- 0 until 4) {\n      \
    \          val (ni, nj) = (i + \"2101\".charAt(d) - '1', j + \"1210\".charAt(d)\
    \ - '1')\n                if (ni < 0 || ni >= n || nj < 0 || nj >= m) continue\n\
    \                val ncost = cost + grid(ni)(nj)\n                if (ncost <\
    \ dp(ni)(nj)) {\n                    dp(ni)(nj) = ncost\n                    prev(ni)(nj)\
    \ = grid(i)(j)\n                    queue.enqueue((ncost, ni, nj))\n         \
    \       }\n            }\n        }\n        var (i, j) = (0, 0)\n        var\
    \ path = List[Long]()\n        for (k <- 1 to k.toInt) {\n            path = grid(i)(j)\
    \ :: path\n            var (ni, nj) = (0, 0)\n            var min = Long.MaxValue\n\
    \            for (d <- 0 until 4) {\n                val (ti, tj) = (i + \"2101\"\
    .charAt(d) - '1', j + \"1210\".charAt(d) - '1')\n                if (ti < 0 ||\
    \ ti >= n || tj < 0 || tj >= m) continue\n                if (dp(ti)(tj) <", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.fill(n, m)(Long.MaxValue)\n        val prev = Array.fill(n, m)(-1)\n \
    \       dp(0)(0) = 0\n        for (i <- 0 until n; j <- 0 until m) {\n       \
    \     if (i + 1 < n && dp(i + 1)(j) > dp(i)(j) + grid(i + 1)(j)) {\n         \
    \       dp(i + 1)(j) = dp(i)(j) + grid(i + 1)(j)\n                prev(i + 1)(j)\
    \ = 0\n            }\n            if (j + 1 < m && dp(i)(j + 1) > dp(i)(j) + grid(i)(j\
    \ + 1)) {\n                dp(i)(j + 1) = dp(i)(j) + grid(i)(j + 1)\n        \
    \        prev(i)(j + 1) = 1\n            }\n            if (i - 1 >= 0 && dp(i\
    \ - 1)(j) > dp(i)(j) + grid(i - 1)(j)) {\n                dp(i - 1)(j) = dp(i)(j)\
    \ + grid(i - 1)(j)\n                prev(i - 1)(j) = 2\n            }\n      \
    \      if (j - 1 >= 0 && dp(i)(j - 1) > dp(i)(j) + grid(i)(j - 1)) {\n       \
    \         dp(i)(j - 1) = dp(i)(j) + grid(i)(j - 1)\n                prev(i)(j\
    \ - 1) = 3\n            }\n        }\n        val path = ListBuffer[Long]()\n\
    \        var i = n - 1\n        var j = m - 1\n        while (k > 0) {\n     \
    \       path += grid(i)(j)\n            k -= 1\n            prev(i)(j) match {\n\
    \                case 0 => i += 1\n                case 1 => j += 1\n        \
    \        case 2 => i -= 1\n                case 3 => j -= 1\n            }\n \
    \       }\n        path.toList\n    }", "        val n = grid.length\n       \
    \ val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n \
    \       val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(x => x._1))\n\
    \        pq.enqueue((0, 0, 0))\n        while (!pq.isEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val result = ArrayBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        while (result.length < k) {\n \
    \           result += grid(i)(j)\n            if (i > 0 && dp(i - 1)(j) < dp(i)(j))\
    \ {\n                i -= 1\n            } else if (i < n - 1 && dp(i + 1)(j)\
    \ < dp(i)(j)) {\n                i += 1\n            } else if (j > 0 && dp(i)(j\
    \ - 1) < dp(i)(j)) {\n                j -= 1\n            } else if (j < m - 1\
    \ && dp(i)(j + 1) < dp(i)(j)) {\n                j += 1\n            }\n     \
    \   }\n        result.toList", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) {\n          \
    \          val prev = dp(i)(j - 1)\n                    if (prev.length < k) dp(i)(j)\
    \ = prev :+ grid(i)(j)\n                    else if (prev.length == k) {\n   \
    \                     val lst = prev :+ grid(i)(j)\n                        if\
    \ (lst < dp(i)(j)) dp(i)(j) = lst\n                    }\n                }\n\
    \                else if (j == 0) {\n                    val prev = dp(i - 1)(j)\n\
    \                    if (prev.length < k) dp(i)(j) = prev :+ grid(i)(j)\n    \
    \                else if (prev.length == k) {\n                        val lst\
    \ = prev :+ grid(i)(j)\n                        if (lst < dp(i)(j)) dp(i)(j) =\
    \ lst\n                    }\n                }\n                else {\n    \
    \                val prev1 = dp(i - 1)(j)\n                    val prev2 = dp(i)(j\
    \ - 1)\n                    if (prev1.length < k) {\n                        if\
    \ (prev1 :+ grid(i)(j) < dp(i)(j)) dp(i)(j) = prev1 :+ grid(i)(j)\n          \
    \          }\n                    else if (prev1.length == k) {\n            \
    \            val lst = prev1 :+ grid(i)(j)\n                        if (lst <\
    \ dp(i)(j)) dp(i)(j) = lst\n                    }\n                    if (prev2.length\
    \ < k) {\n                        if (prev2 :+ grid(i)(j) < dp(i)(j)) dp(i)(j)\
    \ = prev2 :+ grid(i)(j)\n                    }\n                    else if (prev2.length",
  "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    if (i > 0) {\n                        val lst = dp(i\
    \ - 1)(j)\n                        if (lst.length < k && lst.length + 1 < dp(i)(j).length)\
    \ dp(i)(j) = lst :+ grid(i)(j)\n                        else if (lst.length ==\
    \ k && lst.length < dp(i)(j).length && lst.last < grid(i)(j)) dp(i)(j) = lst :+\
    \ grid(i)(j)\n                    }\n                    if (j > 0) {\n      \
    \                  val lst = dp(i)(j - 1)\n                        if (lst.length\
    \ < k && lst.length + 1 < dp(i)(j).length) dp(i)(j) = lst :+ grid(i)(j)\n    \
    \                    else if (lst.length == k && lst.length < dp(i)(j).length\
    \ && lst.last < grid(i)(j)) dp(i)(j) = lst :+ grid(i)(j)\n                   \
    \ }\n                }\n            }\n        }\n        dp(n - 1)(n - 1)", " \
    \       // The idea is to use a priority queue to store the paths.\n        //\
    \ The priority queue is sorted by the path length, and if two paths have the same\
    \ length,\n        // the one with smaller value is smaller.\n        // The paths\
    \ are stored as a list of tuples (x, y, value).\n        // The algorithm is as\
    \ follows:\n        // 1. Initialize the priority queue with the first path (0,\
    \ 0, grid[0][0]).\n        // 2. While the priority queue is not empty, pop the\
    \ path with the smallest length.\n        // 3. If the path length is larger than\
    \ k, then stop.\n        // 4. Otherwise, add the path to the result list.\n \
    \       // 5. Add the path to the priority queue if the path length is less than\
    \ k.\n        // 6. Add the neighbors of the last cell of the path to the priority\
    \ queue.\n        val n = grid.length\n        val pq = new PriorityQueue[(Int,\
    \ Int, Long)]()(Ordering.by(x => (x._3, x._1, x._2)))\n        pq.enqueue((0,\
    \ 0, grid(0)(0)))\n        val result = new ListBuffer[Long]()\n        while\
    \ (!pq.isEmpty) {\n            val path = pq.dequeue\n            if (path._3\
    \ > k) return result.toList\n            else {\n                result += path._3\n\
    \                if (path._3 < k) {\n                    if (path._1 > 0) pq.enqueue((path._1\
    \ - 1, path._2, path._3 + grid(path._1 - 1)(path._2)))\n                    if\
    \ (path._1 < n - 1) pq.enqueue((path._1 + 1, path._2, path._3 + grid(path._1 +\
    \ 1)(path._2)))\n                    if (path._2 > 0) pq.enqueue((path._1, path._2\
    \ - 1, path._3 + grid(path._1)(path._2 - 1)))\n                    if (path._2\
    \ < n - 1) pq.enqueue((path._1, path._2 + 1, path._3 + grid(path._1)(path._2 +\
    \ 1)))\n                }\n            }\n       ", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val pq = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(_._1))\n \
    \       pq.enqueue((0, 0, 0))\n        while (pq.nonEmpty) {\n            val\
    \ (cost, i, j) = pq.dequeue\n            if (dp(i)(j) > cost) {\n            \
    \    dp(i)(j) = cost\n                if (i > 0) pq.enqueue((cost + grid(i - 1)(j),\
    \ i - 1, j))\n                if (i < n - 1) pq.enqueue((cost + grid(i + 1)(j),\
    \ i + 1, j))\n                if (j > 0) pq.enqueue((cost + grid(i)(j - 1), i,\
    \ j - 1))\n                if (j < m - 1) pq.enqueue((cost + grid(i)(j + 1), i,\
    \ j + 1))\n            }\n        }\n        val result = new ListBuffer[Long]\n\
    \        var i = 0\n        var j = 0\n        var cost = 0L\n        while (result.length\
    \ < k) {\n            result += grid(i)(j)\n            if (i > 0 && dp(i - 1)(j)\
    \ < dp(i)(j)) {\n                i -= 1\n                cost += grid(i)(j)\n\
    \            } else if (i < n - 1 && dp(i + 1)(j) < dp(i)(j)) {\n            \
    \    i += 1\n                cost += grid(i)(j)\n            } else if (j > 0\
    \ && dp(i)(j - 1) < dp(i)(j)) {\n                j -= 1\n                cost\
    \ += grid(i)(j)\n            } else if (j < m - 1 && dp(i)(j + 1) < dp(i)(j))\
    \ {\n                j += 1\n                cost += grid(i)(j)\n            }\n\
    \        }\n        result.toList"]
stop_tokens:
- "\n    }\n"
