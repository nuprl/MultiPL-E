language: scala
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_groups = new ListBuffer[String]\n        var current_group\
    \ = new StringBuilder\n        var open_parens = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_group.append(c)\n            } else if (c == ')') {\n        \
    \        open_parens -= 1\n                current_group.append(c)\n         \
    \       if (open_parens == 0) {\n                    paren_groups += current_group.toString\n\
    \                    current_group = new StringBuilder\n                }\n  \
    \          } else {\n                current_group.append(c)\n            }\n\
    \        }\n        paren_groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = List[String]()\n        var group =\
    \ \"\"\n        var open_count = 0\n        for (c <- paren_string) {\n      \
    \      if (c == '(') {\n                open_count += 1\n                group\
    \ += c\n            } else if (c == ')') {\n                open_count -= 1\n\
    \                group += c\n                if (open_count == 0) {\n        \
    \            groups = groups :+ group\n                    group = \"\"\n    \
    \            }\n            } else if (c != ' ') {\n                group += c\n\
    \            }\n        }\n        groups\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_list = paren_string_no_spaces.toList\n\
    \        var paren_groups = List[String]()\n        var current_group = \"\"\n\
    \        var open_parens = 0\n        for (c <- paren_string_no_spaces_list) {\n\
    \            if (c == '(') {\n                open_parens += 1\n             \
    \   current_group += c\n            } else if (c == ')') {\n                open_parens\
    \ -= 1\n                current_group += c\n                if (open_parens ==\
    \ 0) {\n                    paren_groups = current_group :: paren_groups\n   \
    \                 current_group = \"\"\n                }\n            } else\
    \ {\n                current_group += c\n            }\n        }\n        paren_groups.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    paren_groups = paren_groups :+ current_group\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   paren_groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_length = paren_string_no_spaces.length\n\
    \        var paren_groups = List[String]()\n        var paren_group = \"\"\n \
    \       var paren_count = 0\n        for (i <- 0 until paren_string_no_spaces_length)\
    \ {\n            val char = paren_string_no_spaces(i)\n            if (char ==\
    \ '(') {\n                paren_count += 1\n            } else if (char == ')')\
    \ {\n                paren_count -= 1\n            }\n            paren_group\
    \ += char\n            if (paren_count == 0) {\n                paren_groups =\
    \ paren_group :: paren_groups\n                paren_group = \"\"\n          \
    \  }\n        }\n        paren_groups.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = new StringBuilder()\n        var open_parens = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_group.append(c)\n            } else if (c == ')') {\n        \
    \        open_parens -= 1\n                current_group.append(c)\n         \
    \       if (open_parens == 0) {\n                    result = result :+ current_group.toString\n\
    \                    current_group = new StringBuilder()\n                }\n\
    \            } else if (c != ' ') {\n                current_group.append(c)\n\
    \            }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]()\n        var\
    \ paren_groups = new ListBuffer[String]()\n        var paren_group = new StringBuilder()\n\
    \        for (c <- paren_string) {\n            if (c == '(') {\n            \
    \    paren_stack.push(c)\n            } else if (c == ')') {\n               \
    \ paren_stack.pop()\n                if (paren_stack.isEmpty) {\n            \
    \        paren_groups += paren_group.toString\n                    paren_group\
    \ = new StringBuilder()\n                }\n            } else if (c != ' ') {\n\
    \                paren_group += c\n            }\n        }\n        paren_groups.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps43ib2be.scala:28)\n\tat Problem.main(tmps43ib2be.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var group_start\
    \ = 0\n        var group_end = 0\n        var open_parens = 0\n        for (i\
    \ <- 0 until paren_string.length) {\n            if (paren_string(i) == '(') {\n\
    \                if (open_parens == 0) {\n                    group_start = i\n\
    \                }\n                open_parens += 1\n            } else if (paren_string(i)\
    \ == ')') {\n                open_parens -= 1\n                if (open_parens\
    \ == 0) {\n                    group_end = i\n                    paren_groups\
    \ = paren_groups :+ paren_string.substring(group_start, group_end + 1)\n     \
    \           }\n            }\n        }\n        paren_groups\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp07mar9n_.scala:33)\n\tat Problem.main(tmp07mar9n_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6im0wvmh.scala:30)\n\tat Problem.main(tmp6im0wvmh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_chars = paren_string_no_spaces.toCharArray\n\
    \        var paren_groups : List[String] = List()\n        var current_group :\
    \ String = \"\"\n        var paren_count = 0\n        for (c <- paren_string_chars)\
    \ {\n            if (c == '(') {\n                paren_count += 1\n         \
    \   } else if (c == ')') {\n                paren_count -= 1\n            }\n\
    \            current_group += c\n            if (paren_count == 0) {\n       \
    \         paren_groups = paren_groups :+ current_group\n                current_group\
    \ = \"\"\n            }\n        }\n        paren_groups\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_groups = ListBuffer[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_group += c\n            } else if (c == ')') {\n             \
    \   open_parens -= 1\n                current_group += c\n                if (open_parens\
    \ == 0) {\n                    paren_groups += current_group\n               \
    \     current_group = \"\"\n                }\n            } else {\n        \
    \        current_group += c\n            }\n        }\n        paren_groups.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        // TODO: Implement this function\n        List(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt867v1uq.scala:13)\n\tat Problem.main(tmpt867v1uq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_chars = paren_string_no_spaces.toCharArray\n\
    \        var paren_groups = List[String]()\n        var current_group = \"\"\n\
    \        var open_parens = 0\n        for (c <- paren_string_no_spaces_chars)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_group += c\n            } else if (c == ')') {\n             \
    \   open_parens -= 1\n                current_group += c\n                if (open_parens\
    \ == 0) {\n                    paren_groups = current_group :: paren_groups\n\
    \                    current_group = \"\"\n                }\n            } else\
    \ {\n                current_group += c\n            }\n        }\n        paren_groups.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    groups = groups :+ current_group\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        groups\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_groups = new ListBuffer[String]\n        var current_group\
    \ = new StringBuilder\n        var open_paren_count = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                open_paren_count += 1\n    \
    \            current_group.append(c)\n            } else if (c == ')') {\n   \
    \             open_paren_count -= 1\n                current_group.append(c)\n\
    \                if (open_paren_count == 0) {\n                    paren_groups\
    \ += current_group.toString\n                    current_group = new StringBuilder\n\
    \                }\n            } else {\n                current_group.append(c)\n\
    \            }\n        }\n        paren_groups.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = new StringBuilder()\n        var paren_count = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                paren_count += 1\n         \
    \       current_group.append(c)\n            } else if (c == ')') {\n        \
    \        paren_count -= 1\n                current_group.append(c)\n         \
    \   } else if (c == ' ') {\n                // Do nothing\n            } else\
    \ {\n                current_group.append(c)\n            }\n            if (paren_count\
    \ == 0) {\n                result = result :+ current_group.toString\n       \
    \         current_group = new StringBuilder()\n            }\n        }\n    \
    \    result\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxuztbuzq.scala:32)\n\tat Problem.main(tmpxuztbuzq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_chars = paren_string_no_spaces.toCharArray\n\
    \        var paren_groups = List[String]()\n        var group_start = -1\n   \
    \     var group_end = -1\n        var open_parens = 0\n        for (i <- 0 until\
    \ paren_string_no_spaces_chars.length) {\n            if (paren_string_no_spaces_chars(i)\
    \ == '(') {\n                if (open_parens == 0) {\n                    group_start\
    \ = i\n                }\n                open_parens += 1\n            }\n  \
    \          else if (paren_string_no_spaces_chars(i) == ')') {\n              \
    \  open_parens -= 1\n                if (open_parens == 0) {\n               \
    \     group_end = i\n                    paren_groups = paren_groups :+ paren_string_no_spaces.substring(group_start,\
    \ group_end + 1)\n                }\n            }\n        }\n        paren_groups\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    paren_groups = paren_groups :+ current_group\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   paren_groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var cur_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                cur_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                cur_group += c\n                if (open_parens == 0) {\n   \
    \                 result = result :+ cur_group\n                    cur_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    cur_group += c\n            }\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_list = paren_string_no_spaces.toList\n\
    \        //println(paren_string_no_spaces_list)\n        val paren_string_no_spaces_list_length\
    \ = paren_string_no_spaces_list.length\n        var paren_string_no_spaces_list_index\
    \ = 0\n        var paren_string_no_spaces_list_index_start = 0\n        var paren_string_no_spaces_list_index_end\
    \ = 0\n        var paren_string_no_spaces_list_index_end_previous = 0\n      \
    \  var paren_string_no_spaces_list_index_end_previous_previous = 0\n        var\
    \ paren_string_no_spaces_list_index_end_previous_previous_previous = 0\n     \
    \   var paren_string_no_spaces_list_index_end_previous_previous_previous_previous\
    \ = 0\n        var paren_string_no_spaces_list_index_end_previous_previous_previous_previous_previous\
    \ = 0\n        var paren_string_no_spaces_list_index_end_previous_previous_previous_previous_previous_previous\
    \ = 0\n        var paren_string_no_spaces_list_index_end_previous_previous_previous_previous_previous_previous_previous\
    \ = 0\n        var paren_string_no_spaces_list_index_end_previous_previous_previous_previous_previous_previous_previous_previous\
    \ = 0\n        var paren_string_no_spaces_list_index_end_previous_previous_previous_previous_previous_previous_previous_previous_previous\
    \ = 0\n        var paren_string_no_spaces_list_index_end_previous_previous_previous_previous_previous_previous_previous_previous\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbhh5unoo.scala:26:4 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpbhh5unoo.scala:26:5 ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var current_depth = 0\n        for (c <- paren_string) {\n \
    \           if (c == '(') {\n                current_depth += 1\n            \
    \    current_group += c\n            } else if (c == ')') {\n                current_depth\
    \ -= 1\n                current_group += c\n                if (current_depth\
    \ == 0) {\n                    result = current_group :: result\n            \
    \        current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   result.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_list = paren_string_no_spaces.toList\n\
    \        val paren_string_no_spaces_list_rev = paren_string_no_spaces_list.reverse\n\
    \        val paren_string_no_spaces_list_rev_stack = new Stack[Char]\n       \
    \ var paren_string_no_spaces_list_rev_stack_count = 0\n        var paren_string_no_spaces_list_rev_stack_count_max\
    \ = 0\n        var paren_string_no_spaces_list_rev_stack_count_max_index = 0\n\
    \        for (i <- 0 until paren_string_no_spaces_list_rev.length) {\n       \
    \     if (paren_string_no_spaces_list_rev(i) == ')') {\n                paren_string_no_spaces_list_rev_stack.push(paren_string_no_spaces_list_rev(i))\n\
    \                paren_string_no_spaces_list_rev_stack_count += 1\n          \
    \  }\n            else {\n                paren_string_no_spaces_list_rev_stack.pop\n\
    \                paren_string_no_spaces_list_rev_stack_count -= 1\n          \
    \  }\n            if (paren_string_no_spaces_list_rev_stack_count > paren_string_no_spaces_list_rev_stack_count_max)\
    \ {\n                paren_string_no_spaces_list_rev_stack_count_max = paren_string_no_spaces_list_rev_stack_count\n\
    \                paren_string_no_spaces_list_rev_stack_count_max_index = i\n \
    \           }\n        }\n        val paren_string_no_spaces_list_rev_stack_count_max_index_rev\
    \ = paren_string_no_spaces_list_rev.length - paren_string_no_spaces_list_rev_stack_count_max_index\
    \ - 1\n       \n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm20ykwae.scala:32:5\
    \ ---------------------\e[0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var current_depth = 0\n        for (c <- paren_string) {\n \
    \           if (c == '(') {\n                current_depth += 1\n            \
    \    current_group += c\n            } else if (c == ')') {\n                current_depth\
    \ -= 1\n                current_group += c\n                if (current_depth\
    \ == 0) {\n                    result = current_group :: result\n            \
    \        current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   result.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_groups = ListBuffer[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_group += c\n            } else if (c == ')') {\n             \
    \   open_parens -= 1\n                current_group += c\n                if (open_parens\
    \ == 0) {\n                    paren_groups += current_group\n               \
    \     current_group = \"\"\n                }\n            } else {\n        \
    \        current_group += c\n            }\n        }\n        paren_groups.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]\n        var paren_groups\
    \ = new ListBuffer[String]\n        var current_group = new StringBuilder\n  \
    \      for (c <- paren_string) {\n            if (c == '(') {\n              \
    \  paren_stack.push(c)\n            } else if (c == ')') {\n                paren_stack.pop\n\
    \                if (paren_stack.isEmpty) {\n                    paren_groups\
    \ += current_group.toString\n                    current_group = new StringBuilder\n\
    \                }\n            } else if (c != ' ') {\n                current_group\
    \ += c\n            }\n        }\n        paren_groups.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb5sg7_oi.scala:28)\n\tat Problem.main(tmpb5sg7_oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    paren_groups = current_group :: paren_groups\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   paren_groups.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var cur_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                cur_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                cur_group += c\n                if (paren_count == 0) {\n   \
    \                 paren_groups = cur_group :: paren_groups\n                 \
    \   cur_group = \"\"\n                }\n            } else if (c != ' ') {\n\
    \                cur_group += c\n            }\n        }\n        paren_groups\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpre8fadth.scala:30)\n\tat Problem.main(tmpre8fadth.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_group += c\n            } else if (c == ')') {\n             \
    \   open_parens -= 1\n                current_group += c\n                if (open_parens\
    \ == 0) {\n                    paren_groups = current_group :: paren_groups\n\
    \                    current_group = \"\"\n                }\n            } else\
    \ {\n                current_group += c\n            }\n        }\n        paren_groups.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_group += c\n            } else if (c == ')') {\n             \
    \   open_parens -= 1\n                current_group += c\n                if (open_parens\
    \ == 0) {\n                    paren_groups = current_group :: paren_groups\n\
    \                    current_group = \"\"\n                }\n            } else\
    \ {\n                current_group += c\n            }\n        }\n        paren_groups.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    groups = groups :+ current_group\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        groups\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = new ListBuffer[String]()\n        var\
    \ current_group = new StringBuilder()\n        var open_parens = 0\n        for\
    \ (c <- paren_string) {\n            if (c == '(') {\n                open_parens\
    \ += 1\n                current_group.append(c)\n            } else if (c == ')')\
    \ {\n                open_parens -= 1\n                current_group.append(c)\n\
    \                if (open_parens == 0) {\n                    groups.append(current_group.toString)\n\
    \                    current_group = new StringBuilder()\n                }\n\
    \            } else if (c != ' ') {\n                current_group.append(c)\n\
    \            }\n        }\n        groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var stack = new Stack[Char]\n        var groups\
    \ = new ListBuffer[String]\n        var current_group = new StringBuilder\n  \
    \      for (c <- paren_string) {\n            if (c == '(') {\n              \
    \  stack.push(c)\n            } else if (c == ')') {\n                stack.pop\n\
    \                if (stack.isEmpty) {\n                    groups += current_group.toString\n\
    \                    current_group = new StringBuilder\n                }\n  \
    \          } else if (c != ' ') {\n                current_group += c\n      \
    \      }\n        }\n        groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbkcftkke.scala:28)\n\tat Problem.main(tmpbkcftkke.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_groups = new ListBuffer[String]\n        var current_group\
    \ = new StringBuilder\n        var open_parens = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_group.append(c)\n            } else if (c == ')') {\n        \
    \        open_parens -= 1\n                current_group.append(c)\n         \
    \       if (open_parens == 0) {\n                    paren_groups += current_group.toString\n\
    \                    current_group = new StringBuilder\n                }\n  \
    \          } else {\n                current_group.append(c)\n            }\n\
    \        }\n        paren_groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_string\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_string\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_string += c\n                if (open_parens == 0) {\n\
    \                    result = current_string :: result\n                    current_string\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_string += c\n            }\n        }\n        result\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphm2rmm_d.scala:30)\n\tat Problem.main(tmphm2rmm_d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var stack = new Stack[Char]\n        var groups\
    \ = new ListBuffer[String]\n        var curr_group = new StringBuilder\n     \
    \   for (c <- paren_string) {\n            if (c == ' ') {\n                //\
    \ Ignore spaces\n            } else if (c == '(') {\n                stack.push(c)\n\
    \            } else if (c == ')') {\n                if (stack.isEmpty) {\n  \
    \                  throw new IllegalArgumentException(\"Mismatched parentheses\"\
    )\n                }\n                stack.pop\n                if (stack.isEmpty)\
    \ {\n                    groups += curr_group.toString\n                    curr_group\
    \ = new StringBuilder\n                }\n            } else {\n             \
    \   curr_group += c\n            }\n        }\n        if (!stack.isEmpty) {\n\
    \            throw new IllegalArgumentException(\"Mismatched parentheses\")\n\
    \        }\n        groups.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphcn26dtp.scala:36)\n\tat Problem.main(tmphcn26dtp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_list = paren_string_no_spaces.toList\n\
    \        var paren_string_no_spaces_list_index = 0\n        var paren_string_no_spaces_list_length\
    \ = paren_string_no_spaces_list.length\n        var paren_string_no_spaces_list_buffer\
    \ = new ListBuffer[Char]\n        var paren_string_no_spaces_list_buffer_list\
    \ = new ListBuffer[String]\n        while (paren_string_no_spaces_list_index <\
    \ paren_string_no_spaces_list_length) {\n            if (paren_string_no_spaces_list(paren_string_no_spaces_list_index)\
    \ == '(') {\n                paren_string_no_spaces_list_buffer += paren_string_no_spaces_list(paren_string_no_spaces_list_index)\n\
    \                paren_string_no_spaces_list_index += 1\n                while\
    \ (paren_string_no_spaces_list(paren_string_no_spaces_list_index) != ')') {\n\
    \                    paren_string_no_spaces_list_buffer += paren_string_no_spaces_list(paren_string_no_spaces_list_index)\n\
    \                    paren_string_no_spaces_list_index += 1\n                }\n\
    \                paren_string_no_spaces_list_buffer += paren_string_no_spaces_list(paren_string_no_spaces_list_index)\n\
    \                paren_string_no_spaces_list_buffer_list += paren_string_no_spaces_list_buffer.mkString\n\
    \                paren_string_no_spaces_list_buffer.clear\n            }\n   \
    \         paren_string_no_spaces_list_index += 1\n        }\n        paren_string_no_spaces_list_buffer_list.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppii0_ykd.scala:32)\n\tat Problem.main(tmppii0_ykd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]\n        var paren_groups\
    \ = new ListBuffer[String]\n        var current_group = new StringBuilder\n  \
    \      for (c <- paren_string) {\n            if (c == '(') {\n              \
    \  paren_stack.push(c)\n            } else if (c == ')') {\n                paren_stack.pop\n\
    \                if (paren_stack.isEmpty) {\n                    paren_groups\
    \ += current_group.toString\n                    current_group = new StringBuilder\n\
    \                }\n            } else if (c != ' ') {\n                current_group\
    \ += c\n            }\n        }\n        paren_groups.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb5sg7_oi.scala:28)\n\tat Problem.main(tmpb5sg7_oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_group += c\n            } else if (c == ')') {\n             \
    \   open_parens -= 1\n                current_group += c\n                if (open_parens\
    \ == 0) {\n                    paren_groups = current_group :: paren_groups\n\
    \                    current_group = \"\"\n                }\n            } else\
    \ {\n                current_group += c\n            }\n        }\n        paren_groups.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_list = paren_string_no_spaces.toList\n\
    \        var paren_groups = List[String]()\n        var current_group = \"\"\n\
    \        var open_parens = 0\n        for (paren <- paren_string_no_spaces_list)\
    \ {\n            if (paren == '(') {\n                open_parens += 1\n     \
    \           current_group += paren\n            } else if (paren == ')') {\n \
    \               open_parens -= 1\n                current_group += paren\n   \
    \             if (open_parens == 0) {\n                    paren_groups = current_group\
    \ :: paren_groups\n                    current_group = \"\"\n                }\n\
    \            }\n        }\n        paren_groups.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    groups = groups :+ current_group\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        groups\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    paren_groups = current_group :: paren_groups\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   paren_groups.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6im0wvmh.scala:30)\n\tat Problem.main(tmp6im0wvmh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    paren_groups = current_group :: paren_groups\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   paren_groups.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]\n        var paren_groups\
    \ = new ListBuffer[String]\n        var current_group = new StringBuilder\n  \
    \      for (c <- paren_string) {\n            if (c == '(') {\n              \
    \  paren_stack.push(c)\n            } else if (c == ')') {\n                paren_stack.pop\n\
    \                if (paren_stack.isEmpty) {\n                    paren_groups\
    \ += current_group.toString\n                    current_group = new StringBuilder\n\
    \                }\n            } else if (c != ' ') {\n                current_group\
    \ += c\n            }\n        }\n        paren_groups.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb5sg7_oi.scala:28)\n\tat Problem.main(tmpb5sg7_oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current\
    \ = new StringBuilder\n        var open_count = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                open_count += 1\n          \
    \      current.append(c)\n            } else if (c == ')') {\n               \
    \ open_count -= 1\n                current.append(c)\n                if (open_count\
    \ == 0) {\n                    result = result :+ current.toString\n         \
    \           current = new StringBuilder\n                }\n            } else\
    \ if (c != ' ') {\n                current.append(c)\n            }\n        }\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    paren_groups = paren_groups :+ current_group\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   paren_groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_list = paren_string_no_spaces.toList\n\
    \        var paren_groups = List[String]()\n        var current_group = \"\"\n\
    \        var paren_count = 0\n        for (c <- paren_string_no_spaces_list) {\n\
    \            if (c == '(') {\n                paren_count += 1\n            }\
    \ else if (c == ')') {\n                paren_count -= 1\n            }\n    \
    \        current_group += c\n            if (paren_count == 0) {\n           \
    \     paren_groups = paren_groups :+ current_group\n                current_group\
    \ = \"\"\n            }\n        }\n        paren_groups\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        // TODO: Implement this function\n        return\
    \ List()\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3r9uvii6.scala:13)\n\tat Problem.main(tmp3r9uvii6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        // TODO: implement this function\n        return\
    \ List()\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqykmb3nx.scala:13)\n\tat Problem.main(tmpqykmb3nx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6im0wvmh.scala:30)\n\tat Problem.main(tmp6im0wvmh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_group += c\n            } else if (c == ')') {\n             \
    \   open_parens -= 1\n                current_group += c\n                if (open_parens\
    \ == 0) {\n                    paren_groups = current_group :: paren_groups\n\
    \                    current_group = \"\"\n                }\n            } else\
    \ {\n                current_group += c\n            }\n        }\n        paren_groups.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        // TODO: Implement this function\n        return\
    \ List()\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3r9uvii6.scala:13)\n\tat Problem.main(tmp3r9uvii6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current\
    \ = \"\"\n        var open = 0\n        for (c <- paren_string) {\n          \
    \  if (c == '(') {\n                open += 1\n                current += c\n\
    \            } else if (c == ')') {\n                open -= 1\n             \
    \   current += c\n                if (open == 0) {\n                    result\
    \ = current :: result\n                    current = \"\"\n                }\n\
    \            } else if (c != ' ') {\n                current += c\n          \
    \  }\n        }\n        result.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_list = paren_string_no_spaces.toList\n\
    \        var paren_groups = List[String]()\n        var current_group = \"\"\n\
    \        var paren_count = 0\n        for (c <- paren_string_no_spaces_list) {\n\
    \            if (c == '(') {\n                paren_count += 1\n            }\
    \ else if (c == ')') {\n                paren_count -= 1\n            }\n    \
    \        current_group += c\n            if (paren_count == 0) {\n           \
    \     paren_groups = paren_groups :+ current_group\n                current_group\
    \ = \"\"\n            }\n        }\n        paren_groups\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \\\\s\", \"\")\n        val paren_string_no_spaces_list = paren_string_no_spaces.toList\n\
    \        val paren_string_no_spaces_list_length = paren_string_no_spaces_list.length\n\
    \        var paren_string_no_spaces_list_index = 0\n        var paren_string_no_spaces_list_index_end\
    \ = 0\n        var paren_string_no_spaces_list_index_start = 0\n        var paren_string_no_spaces_list_index_start_previous\
    \ = 0\n        var paren_string_no_spaces_list_index_start_previous_previous =\
    \ 0\n        var paren_string_no_spaces_list_index_start_previous_previous_previous\
    \ = 0\n        var paren_string_no_spaces_list_index_start_previous_previous_previous_previous\
    \ = 0\n        var paren_string_no_spaces_list_index_start_previous_previous_previous_previous_previous\
    \ = 0\n        var paren_string_no_spaces_list_index_start_previous_previous_previous_previous_previous_previous\
    \ = 0\n        var paren_string_no_spaces_list_index_start_previous_previous_previous_previous_previous_previous_previous\
    \ = 0\n        var paren_string_no_spaces_list_index_start_previous_previous_previous_previous_previous_previous_previous_previous\
    \ = 0\n        var paren_string_no_spaces_list_index_start_previous_previous_previous_previous_previous_previous_previous_previous_previous\
    \ = 0\n        var paren_string_no_spaces_list_index_start_previous_previous_previous_previous_previous_previous_previous_previous_previous_previous\
    \ = 0\n        var paren_\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3dmuzz13.scala:26:4 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp3dmuzz13.scala:26:5 ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    groups = groups :+ current_group\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        groups\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]\n        var paren_groups\
    \ = new ListBuffer[String]\n        var current_group = new StringBuilder\n  \
    \      for (c <- paren_string) {\n            if (c == '(') {\n              \
    \  paren_stack.push(c)\n            } else if (c == ')') {\n                paren_stack.pop\n\
    \                if (paren_stack.isEmpty) {\n                    paren_groups\
    \ += current_group.toString\n                    current_group = new StringBuilder\n\
    \                }\n            } else if (c != ' ') {\n                current_group\
    \ += c\n            }\n        }\n        paren_groups.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb5sg7_oi.scala:28)\n\tat Problem.main(tmpb5sg7_oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]\n        var group_start\
    \ = 0\n        var group_end = 0\n        var groups = new ListBuffer[String]\n\
    \        for (i <- 0 until paren_string.length) {\n            if (paren_string(i)\
    \ == '(') {\n                if (paren_stack.isEmpty) {\n                    group_start\
    \ = i\n                }\n                paren_stack.push(paren_string(i))\n\
    \            } else if (paren_string(i) == ')') {\n                paren_stack.pop\n\
    \                if (paren_stack.isEmpty) {\n                    group_end = i\n\
    \                    groups += paren_string.substring(group_start, group_end +\
    \ 1)\n                }\n            }\n        }\n        groups.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9rjxr9gf.scala:33)\n\tat Problem.main(tmp9rjxr9gf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var paren_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                paren_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                paren_group += c\n                if (open_parens == 0) {\n \
    \                   paren_groups = paren_group :: paren_groups\n             \
    \       paren_group = \"\"\n                }\n            } else if (c != ' ')\
    \ {\n                paren_group += c\n            }\n        }\n        paren_groups\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppch3uzvp.scala:30)\n\tat Problem.main(tmppch3uzvp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        // TODO: Implement this function\n        return\
    \ List[String]()\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeizvofm5.scala:13)\n\tat Problem.main(tmpeizvofm5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        var paren_groups = List[String]()\n        var group_start\
    \ = 0\n        var open_parens = 0\n        for (i <- 0 until paren_string_no_spaces.length)\
    \ {\n            if (paren_string_no_spaces(i) == '(') open_parens += 1\n    \
    \        else if (paren_string_no_spaces(i) == ')') open_parens -= 1\n       \
    \     if (open_parens == 0) {\n                paren_groups = paren_groups :+\
    \ paren_string_no_spaces.substring(group_start, i + 1)\n                group_start\
    \ = i + 1\n            }\n        }\n        paren_groups\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_list = paren_string_no_spaces.toList\n\
    \        var paren_groups = List[String]()\n        var current_group = \"\"\n\
    \        var paren_count = 0\n        for (c <- paren_string_no_spaces_list) {\n\
    \            if (c == '(') {\n                paren_count += 1\n            }\
    \ else if (c == ')') {\n                paren_count -= 1\n            }\n    \
    \        current_group += c\n            if (paren_count == 0) {\n           \
    \     paren_groups = paren_groups :+ current_group\n                current_group\
    \ = \"\"\n            }\n        }\n        paren_groups\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_group += c\n            } else if (c == ')') {\n             \
    \   open_parens -= 1\n                current_group += c\n                if (open_parens\
    \ == 0) {\n                    paren_groups = current_group :: paren_groups\n\
    \                    current_group = \"\"\n                }\n            } else\
    \ {\n                current_group += c\n            }\n        }\n        paren_groups.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6im0wvmh.scala:30)\n\tat Problem.main(tmp6im0wvmh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = new ListBuffer[String]\n        var\
    \ current_group = new StringBuilder\n        var open_parens = 0\n        for\
    \ (c <- paren_string) {\n            if (c == '(') {\n                open_parens\
    \ += 1\n                current_group += c\n            } else if (c == ')') {\n\
    \                open_parens -= 1\n                current_group += c\n      \
    \          if (open_parens == 0) {\n                    groups += current_group.toString\n\
    \                    current_group = new StringBuilder\n                }\n  \
    \          } else if (c != ' ') {\n                current_group += c\n      \
    \      }\n        }\n        groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]()\n        var\
    \ paren_groups = new ListBuffer[String]()\n        var current_group = new StringBuilder()\n\
    \        for (c <- paren_string) {\n            if (c == '(') {\n            \
    \    paren_stack.push(c)\n            } else if (c == ')') {\n               \
    \ paren_stack.pop()\n                if (paren_stack.isEmpty) {\n            \
    \        paren_groups += current_group.toString()\n                    current_group\
    \ = new StringBuilder()\n                }\n            } else if (c != ' ') {\n\
    \                current_group += c\n            }\n        }\n        paren_groups.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsbu4oao_.scala:28)\n\tat Problem.main(tmpsbu4oao_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    paren_groups = paren_groups :+ current_group\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   paren_groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        var paren_stack = new Stack[Char]\n        var paren_groups\
    \ = new ListBuffer[String]\n        var current_group = new StringBuilder\n  \
    \      for (c <- paren_string_no_spaces) {\n            if (c == '(') {\n    \
    \            paren_stack.push(c)\n            } else if (c == ')') {\n       \
    \         paren_stack.pop\n                if (paren_stack.isEmpty) {\n      \
    \              paren_groups += current_group.toString\n                    current_group\
    \ = new StringBuilder\n                }\n            }\n            current_group\
    \ += c\n        }\n        paren_groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqlb409mj.scala:28)\n\tat Problem.main(tmpqlb409mj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    groups = groups :+ current_group\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        groups\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_group += c\n            } else if (c == ')') {\n             \
    \   open_parens -= 1\n                current_group += c\n                if (open_parens\
    \ == 0) {\n                    paren_groups = current_group :: paren_groups\n\
    \                    current_group = \"\"\n                }\n            } else\
    \ {\n                current_group += c\n            }\n        }\n        paren_groups.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    groups = groups :+ current_group\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        groups\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    paren_groups = paren_groups :+ current_group\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   paren_groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var stack = new Stack[Char]\n        var groups\
    \ = new ListBuffer[String]\n        var current_group = new StringBuilder\n  \
    \      for (c <- paren_string) {\n            if (c == '(') {\n              \
    \  stack.push(c)\n            } else if (c == ')') {\n                if (stack.isEmpty)\
    \ {\n                    return List()\n                }\n                stack.pop\n\
    \                if (stack.isEmpty) {\n                    groups += current_group.toString\n\
    \                    current_group = new StringBuilder\n                }\n  \
    \          } else if (c != ' ') {\n                current_group += c\n      \
    \      }\n        }\n        if (!stack.isEmpty) {\n            return List()\n\
    \        }\n        groups.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzzu9_pvy.scala:34)\n\tat Problem.main(tmpzzu9_pvy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]()\n        var\
    \ paren_groups = new ListBuffer[String]()\n        var current_group = new StringBuilder()\n\
    \        for (c <- paren_string) {\n            if (c == '(') {\n            \
    \    paren_stack.push(c)\n            } else if (c == ')') {\n               \
    \ paren_stack.pop()\n                if (paren_stack.isEmpty) {\n            \
    \        paren_groups += current_group.toString()\n                    current_group\
    \ = new StringBuilder()\n                }\n            } else if (c != ' ') {\n\
    \                current_group += c\n            }\n        }\n        paren_groups.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsbu4oao_.scala:28)\n\tat Problem.main(tmpsbu4oao_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_group += c\n            } else if (c == ')') {\n             \
    \   open_parens -= 1\n                current_group += c\n                if (open_parens\
    \ == 0) {\n                    paren_groups = current_group :: paren_groups\n\
    \                    current_group = \"\"\n                }\n            } else\
    \ {\n                current_group += c\n            }\n        }\n        paren_groups.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    paren_groups ::= current_group\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        paren_groups\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp12d7ow8_.scala:30)\n\tat Problem.main(tmp12d7ow8_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980061
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6im0wvmh.scala:30)\n\tat Problem.main(tmp6im0wvmh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_space = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_space_list = paren_string_no_space.toList\n\
    \        var paren_string_no_space_list_index = 0\n        var paren_string_no_space_list_length\
    \ = paren_string_no_space_list.length\n        var paren_string_no_space_list_stack\
    \ = new Stack[Char]\n        var paren_string_no_space_list_stack_length = 0\n\
    \        var paren_string_no_space_list_stack_top = ' '\n        var paren_string_no_space_list_stack_top_index\
    \ = 0\n        var paren_string_no_space_list_stack_top_index_list = new ListBuffer[Int]\n\
    \        var paren_string_no_space_list_stack_top_index_list_length = 0\n    \
    \    var paren_string_no_space_list_stack_top_index_list_index = 0\n        var\
    \ paren_string_no_space_list_stack_top_index_list_index_value = 0\n        var\
    \ paren_string_no_space_list_stack_top_index_list_index_value_next = 0\n     \
    \   var paren_string_no_space_list_stack_top_index_list_index_value_next_next\
    \ = 0\n        var paren_string_no_space_list_stack_top_index_list_index_value_next_next_next\
    \ = 0\n        var paren_string_no_space_list_stack_top_index_list_index_value_next_next_next_next\
    \ = 0\n        var paren_string_no_space_list_stack_top_index_list_index_value_next_next_next_next_next\
    \ = 0\n        var paren_string_no_space_list_stack_top_index_list_index_value_next_next_next_next_next_next\
    \ = 0\n        var paren_string_no_space_list_stack_top_index_list_index_value_next_next\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqaj339df.scala:28:4 ----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpqaj339df.scala:28:5 ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659980061
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        // TODO: Implement this function\n        List()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjehes1ay.scala:13)\n\tat Problem.main(tmpjehes1ay.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980061
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var cur_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                cur_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                cur_group += c\n                if (paren_count == 0) {\n   \
    \                 paren_groups = cur_group :: paren_groups\n                 \
    \   cur_group = \"\"\n                }\n            } else if (c != ' ') {\n\
    \                cur_group += c\n            }\n        }\n        paren_groups\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpre8fadth.scala:30)\n\tat Problem.main(tmpre8fadth.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current\
    \ = new StringBuilder()\n        var open = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                open += 1\n                current.append(c)\n\
    \            } else if (c == ')') {\n                open -= 1\n             \
    \   current.append(c)\n                if (open == 0) {\n                    result\
    \ = result :+ current.toString\n                    current = new StringBuilder()\n\
    \                }\n            } else if (c != ' ') {\n                current.append(c)\n\
    \            }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = List[String]()\n        var current_group\
    \ = new StringBuilder\n        var depth = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                depth += 1\n               \
    \ current_group.append(c)\n            } else if (c == ')') {\n              \
    \  depth -= 1\n                current_group.append(c)\n                if (depth\
    \ == 0) {\n                    groups = groups :+ current_group.toString\n   \
    \                 current_group = new StringBuilder\n                }\n     \
    \       } else if (c != ' ') {\n                current_group.append(c)\n    \
    \        }\n        }\n        groups\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]()\n        var\
    \ paren_groups = new ListBuffer[String]()\n        var current_group = new StringBuilder()\n\
    \        for (c <- paren_string) {\n            if (c == '(') {\n            \
    \    paren_stack.push(c)\n            } else if (c == ')') {\n               \
    \ paren_stack.pop()\n                if (paren_stack.isEmpty) {\n            \
    \        paren_groups += current_group.toString()\n                    current_group\
    \ = new StringBuilder()\n                }\n            } else if (c != ' ') {\n\
    \                current_group += c\n            }\n        }\n        paren_groups.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsbu4oao_.scala:28)\n\tat Problem.main(tmpsbu4oao_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]()\n        var\
    \ paren_groups = new ListBuffer[String]()\n        var current_group = new StringBuilder()\n\
    \        for (c <- paren_string) {\n            if (c == '(') {\n            \
    \    paren_stack.push(c)\n            } else if (c == ')') {\n               \
    \ paren_stack.pop()\n                if (paren_stack.isEmpty) {\n            \
    \        paren_groups += current_group.toString()\n                    current_group\
    \ = new StringBuilder()\n                }\n            } else if (c != ' ') {\n\
    \                current_group += c\n            }\n        }\n        return\
    \ paren_groups.toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1n2aawv7.scala:28)\n\tat Problem.main(tmp1n2aawv7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_groups = new ListBuffer[String]\n        var current_group\
    \ = new StringBuilder\n        var current_depth = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                current_depth += 1\n       \
    \         current_group.append(c)\n            } else if (c == ')') {\n      \
    \          current_depth -= 1\n                current_group.append(c)\n     \
    \           if (current_depth == 0) {\n                    paren_groups += current_group.toString\n\
    \                    current_group = new StringBuilder\n                }\n  \
    \          } else {\n                current_group.append(c)\n            }\n\
    \        }\n        paren_groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_list = paren_string_no_spaces.toList\n        var\
    \ paren_stack = new Stack[Char]\n        var paren_groups = new ListBuffer[String]\n\
    \        var current_group = new ListBuffer[Char]\n        for (paren <- paren_list)\
    \ {\n            if (paren == '(') {\n                paren_stack.push(paren)\n\
    \            } else if (paren == ')') {\n                paren_stack.pop\n   \
    \             if (paren_stack.isEmpty) {\n                    paren_groups +=\
    \ current_group.mkString\n                    current_group = new ListBuffer[Char]\n\
    \                } else {\n                    current_group += paren\n      \
    \          }\n            } else {\n                current_group += paren\n \
    \           }\n        }\n        return paren_groups.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjzsoy9im.scala:32)\n\tat Problem.main(tmpjzsoy9im.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_list = paren_string_no_spaces.toList\n\
    \        var paren_stack = new Stack[Char]\n        var paren_group_list = new\
    \ ListBuffer[String]\n        var paren_group_string = \"\"\n        for (paren\
    \ <- paren_string_no_spaces_list) {\n            if (paren == '(') {\n       \
    \         paren_stack.push(paren)\n            } else if (paren == ')') {\n  \
    \              if (paren_stack.isEmpty) {\n                    throw new Exception(\"\
    Unbalanced parentheses\")\n                } else {\n                    paren_stack.pop\n\
    \                    if (paren_stack.isEmpty) {\n                        paren_group_list\
    \ += paren_group_string\n                        paren_group_string = \"\"\n \
    \                   }\n                }\n            } else {\n             \
    \   paren_group_string += paren\n            }\n        }\n        if (!paren_stack.isEmpty)\
    \ {\n            throw new Exception(\"Unbalanced parentheses\")\n        }\n\
    \        return paren_group_list.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3h7ofxxg.scala:37)\n\tat Problem.main(tmp3h7ofxxg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current\
    \ = new StringBuilder()\n        var open = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                open += 1\n                current.append(c)\n\
    \            } else if (c == ')') {\n                open -= 1\n             \
    \   current.append(c)\n                if (open == 0) {\n                    result\
    \ = result :+ current.toString\n                    current = new StringBuilder()\n\
    \                }\n            } else if (c != ' ') {\n                current.append(c)\n\
    \            }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                if (paren_count == 0) {\n         \
    \           current_group = \"\"\n                }\n                paren_count\
    \ += 1\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                if (paren_count == 0) {\n                    paren_groups = paren_groups\
    \ :+ current_group\n                }\n            } else if (c != ' ') {\n  \
    \              current_group += c\n            }\n        }\n        paren_groups\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnv12hkem.scala:30)\n\tat Problem.main(tmpnv12hkem.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]\n        var paren_groups\
    \ = new ListBuffer[String]\n        var current_group = new StringBuilder\n  \
    \      for (c <- paren_string) {\n            if (c == '(') {\n              \
    \  paren_stack.push(c)\n            } else if (c == ')') {\n                paren_stack.pop\n\
    \                if (paren_stack.isEmpty) {\n                    paren_groups\
    \ += current_group.toString\n                    current_group = new StringBuilder\n\
    \                }\n            } else if (c != ' ') {\n                current_group\
    \ += c\n            }\n        }\n        paren_groups.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb5sg7_oi.scala:28)\n\tat Problem.main(tmpb5sg7_oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_group += c\n            } else if (c == ')') {\n             \
    \   open_parens -= 1\n                current_group += c\n                if (open_parens\
    \ == 0) {\n                    paren_groups = current_group :: paren_groups\n\
    \                    current_group = \"\"\n                }\n            } else\
    \ {\n                current_group += c\n            }\n        }\n        paren_groups.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_list = paren_string_no_spaces.toList\n\
    \        var paren_groups = List[String]()\n        var current_group = \"\"\n\
    \        var open_parens = 0\n        for (paren <- paren_string_no_spaces_list)\
    \ {\n            if (paren == '(') {\n                open_parens += 1\n     \
    \           current_group += paren\n            } else if (paren == ')') {\n \
    \               open_parens -= 1\n                current_group += paren\n   \
    \             if (open_parens == 0) {\n                    paren_groups = current_group\
    \ :: paren_groups\n                    current_group = \"\"\n                }\n\
    \            }\n        }\n        paren_groups.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]\n        var paren_groups\
    \ = new ListBuffer[String]\n        var current_group = new StringBuilder\n  \
    \      for (c <- paren_string) {\n            if (c == '(') {\n              \
    \  paren_stack.push(c)\n            } else if (c == ')') {\n                paren_stack.pop\n\
    \                if (paren_stack.isEmpty) {\n                    paren_groups\
    \ += current_group.toString\n                    current_group = new StringBuilder\n\
    \                }\n            } else if (c != ' ') {\n                current_group\
    \ += c\n            }\n        }\n        paren_groups.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb5sg7_oi.scala:28)\n\tat Problem.main(tmpb5sg7_oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var curr =\
    \ \"\"\n        var open = 0\n        for (c <- paren_string) {\n            if\
    \ (c == '(') {\n                open += 1\n                curr += c\n       \
    \     } else if (c == ')') {\n                open -= 1\n                curr\
    \ += c\n                if (open == 0) {\n                    result = curr ::\
    \ result\n                    curr = \"\"\n                }\n            } else\
    \ if (c != ' ') {\n                curr += c\n            }\n        }\n     \
    \   result.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = new ListBuffer[String]\n        var\
    \ current_group = new StringBuilder\n        var open_parens = 0\n        for\
    \ (c <- paren_string) {\n            if (c == '(') {\n                open_parens\
    \ += 1\n                current_group.append(c)\n            } else if (c == ')')\
    \ {\n                open_parens -= 1\n                current_group.append(c)\n\
    \                if (open_parens == 0) {\n                    groups.append(current_group.toString)\n\
    \                    current_group = new StringBuilder\n                }\n  \
    \          } else if (c != ' ') {\n                current_group.append(c)\n \
    \           }\n        }\n        groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_length = paren_string_no_spaces.length\n\
    \        var paren_groups = List[String]()\n        var paren_group = \"\"\n \
    \       var paren_count = 0\n        for (i <- 0 until paren_string_no_spaces_length)\
    \ {\n            val c = paren_string_no_spaces(i)\n            if (c == '(')\
    \ {\n                paren_count += 1\n            } else if (c == ')') {\n  \
    \              paren_count -= 1\n            }\n            paren_group += c\n\
    \            if (paren_count == 0) {\n                paren_groups = paren_group\
    \ :: paren_groups\n                paren_group = \"\"\n            }\n       \
    \ }\n        paren_groups.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var stack = new Stack[Char]\n        var groups\
    \ = new ListBuffer[String]\n        var current_group = new StringBuilder\n  \
    \      for (c <- paren_string) {\n            if (c == '(') {\n              \
    \  stack.push(c)\n            } else if (c == ')') {\n                stack.pop\n\
    \                if (stack.isEmpty) {\n                    groups += current_group.toString\n\
    \                    current_group = new StringBuilder\n                }\n  \
    \          } else if (c != ' ') {\n                current_group += c\n      \
    \      }\n        }\n        groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbkcftkke.scala:28)\n\tat Problem.main(tmpbkcftkke.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        // TODO: Implement this function\n        return\
    \ List()\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3r9uvii6.scala:13)\n\tat Problem.main(tmp3r9uvii6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    paren_groups = paren_groups :+ current_group\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   paren_groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_list = List[String]()\n        var paren_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                paren_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                paren_group += c\n                if (open_parens == 0) {\n \
    \                   paren_list = paren_group :: paren_list\n                 \
    \   paren_group = \"\"\n                }\n            } else if (c != ' ') {\n\
    \                paren_group += c\n            }\n        }\n        paren_list\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvh6e8rr4.scala:30)\n\tat Problem.main(tmpvh6e8rr4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    groups = groups :+ current_group\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        groups\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    paren_groups = paren_groups :+ current_group\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   paren_groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        // Your code goes here\n        var paren_string_list\
    \ = paren_string.toList\n        var paren_string_list_new = ListBuffer[Char]()\n\
    \        var paren_string_list_new_list = ListBuffer[ListBuffer[Char]]()\n   \
    \     var paren_string_list_new_list_string = ListBuffer[String]()\n        var\
    \ paren_string_list_new_list_string_list = ListBuffer[ListBuffer[String]]()\n\
    \        var paren_string_list_new_list_string_list_final = ListBuffer[String]()\n\
    \        var paren_string_list_new_list_string_list_final_list = ListBuffer[ListBuffer[String]]()\n\
    \        var paren_string_list_new_list_string_list_final_list_final = ListBuffer[String]()\n\
    \        var paren_string_list_new_list_string_list_final_list_final_list = ListBuffer[ListBuffer[String]]()\n\
    \        var paren_string_list_new_list_string_list_final_list_final_list_final\
    \ = ListBuffer[String]()\n        var paren_string_list_new_list_string_list_final_list_final_list_final_list\
    \ = ListBuffer[ListBuffer[String]]()\n        var paren_string_list_new_list_string_list_final_list_final_list_final_list_final\
    \ = ListBuffer[String]()\n        var paren_string_list_new_list_string_list_final_list_final_list_final_list_final_list\
    \ = ListBuffer[ListBuffer[String]]()\n        var paren_string_list_new_list_string_list_final_list_final_list_final_list_final_list_final\
    \ = ListBuffer[String]()\n        var paren_string_list_new_list_string_list_final_list_final_list_final_list_final_list_final_list\
    \ = ListBuffer[ListBuffer[String]]()\n        var paren_string_list_new_list_string_list_final_list_final_list_final_list_final_list\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw_cngjab.scala:26:4 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpw_cngjab.scala:26:5 ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659980061
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    paren_groups = current_group :: paren_groups\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   return paren_groups.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    paren_groups = paren_groups :+ current_group\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   paren_groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]\n        var group_stack\
    \ = new Stack[String]\n        var current_group = \"\"\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                paren_stack.push(c)\n      \
    \      } else if (c == ')') {\n                paren_stack.pop\n             \
    \   if (paren_stack.isEmpty) {\n                    group_stack.push(current_group)\n\
    \                    current_group = \"\"\n                }\n            } else\
    \ if (c != ' ') {\n                current_group += c\n            }\n       \
    \ }\n        group_stack.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwycpc8g7.scala:28)\n\tat Problem.main(tmpwycpc8g7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_length = paren_string_no_spaces.length\n\
    \        var paren_groups = List[String]()\n        var paren_group = \"\"\n \
    \       var paren_count = 0\n        for (i <- 0 until paren_string_no_spaces_length)\
    \ {\n            val c = paren_string_no_spaces(i)\n            if (c == '(')\
    \ {\n                paren_count += 1\n            } else if (c == ')') {\n  \
    \              paren_count -= 1\n            }\n            paren_group += c\n\
    \            if (paren_count == 0) {\n                paren_groups = paren_group\
    \ :: paren_groups\n                paren_group = \"\"\n            }\n       \
    \ }\n        paren_groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4rwudy3e.scala:30)\n\tat Problem.main(tmp4rwudy3e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var paren_count\
    \ = 0\n        var paren_group = \"\"\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                paren_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                paren_group += c\n                if (paren_count == 0) {\n \
    \                   paren_groups = paren_group :: paren_groups\n             \
    \       paren_group = \"\"\n                }\n            } else if (c != ' ')\
    \ {\n                paren_group += c\n            }\n        }\n        paren_groups\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj9sge2zf.scala:30)\n\tat Problem.main(tmpj9sge2zf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        var paren_groups = List[String]()\n        var paren_count\
    \ = 0\n        var paren_group = \"\"\n        for (i <- 0 until paren_string_no_spaces.length)\
    \ {\n            if (paren_string_no_spaces(i) == '(') {\n                paren_count\
    \ += 1\n                paren_group += '('\n            } else if (paren_string_no_spaces(i)\
    \ == ')') {\n                paren_count -= 1\n                paren_group +=\
    \ ')'\n            }\n            if (paren_count == 0) {\n                paren_groups\
    \ = paren_group :: paren_groups\n                paren_group = \"\"\n        \
    \    }\n        }\n        paren_groups.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980062
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_list = paren_string_no_spaces.toList\n \
    \       val paren_string_list_length = paren_string_list.length\n        var paren_string_list_index\
    \ = 0\n        var paren_string_list_index_end = 0\n        var paren_string_list_index_start\
    \ = 0\n        var paren_string_list_index_start_prev = 0\n        var paren_string_list_index_start_prev_prev\
    \ = 0\n        var paren_string_list_index_start_prev_prev_prev = 0\n        var\
    \ paren_string_list_index_start_prev_prev_prev_prev = 0\n        var paren_string_list_index_start_prev_prev_prev_prev_prev\
    \ = 0\n        var paren_string_list_index_start_prev_prev_prev_prev_prev_prev\
    \ = 0\n        var paren_string_list_index_start_prev_prev_prev_prev_prev_prev_prev\
    \ = 0\n        var paren_string_list_index_start_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0\n        var paren_string_list_index_start_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0\n        var paren_string_list_index_start_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0\n        var paren_string_list_index_start_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0\n        var paren_string_list_index_start_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0\n        var paren_string_list_index_start_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\
    \ = 0\n        var paren_string_list_index_start_prev_prev_prev_prev_prev_prev_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4xlrxii0.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp4xlrxii0.scala:29:5 ---------------------\e[0m\e[0m\n\e[31m29 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659980061
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_list = paren_string_no_spaces.toList\n\
    \        var paren_groups = List[String]()\n        var current_group = List[Char]()\n\
    \        var paren_stack = List[Char]()\n        for (c <- paren_string_no_spaces_list)\
    \ {\n            if (c == '(') {\n                paren_stack = c :: paren_stack\n\
    \                current_group = c :: current_group\n            } else if (c\
    \ == ')') {\n                paren_stack = paren_stack.tail\n                current_group\
    \ = c :: current_group\n                if (paren_stack.isEmpty) {\n         \
    \           paren_groups = current_group.reverse.mkString :: paren_groups\n  \
    \                  current_group = List[Char]()\n                }\n         \
    \   } else {\n                current_group = c :: current_group\n           \
    \ }\n        }\n        paren_groups.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    paren_groups = current_group :: paren_groups\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   return paren_groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6ay_drh2.scala:30)\n\tat Problem.main(tmp6ay_drh2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_list = paren_string_no_spaces.toList\n\
    \        var paren_groups = List[String]()\n        var paren_group = \"\"\n \
    \       var paren_count = 0\n        for (paren <- paren_string_no_spaces_list)\
    \ {\n            if (paren == '(') {\n                paren_count += 1\n     \
    \       }\n            else if (paren == ')') {\n                paren_count -=\
    \ 1\n            }\n            paren_group += paren\n            if (paren_count\
    \ == 0) {\n                paren_groups = paren_group :: paren_groups\n      \
    \          paren_group = \"\"\n            }\n        }\n        paren_groups.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980071
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \\\\s\", \"\")\n        val paren_list = paren_string_no_spaces.toList\n     \
    \   var paren_groups = List[String]()\n        var current_paren_group = \"\"\n\
    \        var open_parens = 0\n        for (paren <- paren_list) {\n          \
    \  if (paren == '(') {\n                open_parens += 1\n                current_paren_group\
    \ += paren\n            } else if (paren == ')') {\n                open_parens\
    \ -= 1\n                current_paren_group += paren\n                if (open_parens\
    \ == 0) {\n                    paren_groups = current_paren_group :: paren_groups\n\
    \                    current_paren_group = \"\"\n                }\n         \
    \   }\n        }\n        paren_groups.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980072
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_list = paren_string_no_spaces.toList\n\
    \        var paren_groups = List[String]()\n        var current_paren_group =\
    \ \"\"\n        var open_parens = 0\n        for (c <- paren_string_no_spaces_list)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_paren_group += c\n            } else if (c == ')') {\n       \
    \         open_parens -= 1\n                current_paren_group += c\n       \
    \         if (open_parens == 0) {\n                    paren_groups = current_paren_group\
    \ :: paren_groups\n                    current_paren_group = \"\"\n          \
    \      }\n            } else {\n                current_paren_group += c\n   \
    \         }\n        }\n        paren_groups.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980072
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_groups = new ListBuffer[String]\n        var current_paren_group\
    \ = new StringBuilder\n        var open_parens = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_paren_group.append(c)\n            } else if (c == ')') {\n  \
    \              open_parens -= 1\n                current_paren_group.append(c)\n\
    \                if (open_parens == 0) {\n                    paren_groups +=\
    \ current_paren_group.toString\n                    current_paren_group = new\
    \ StringBuilder\n                }\n            } else {\n                current_paren_group.append(c)\n\
    \            }\n        }\n        paren_groups.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980072
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_list = paren_string_no_spaces.toList\n\
    \        var paren_groups = List[String]()\n        var current_group = List[Char]()\n\
    \        var current_group_open_parens = 0\n        for (c <- paren_string_no_spaces_list)\
    \ {\n            if (c == '(') {\n                current_group_open_parens +=\
    \ 1\n                current_group = current_group :+ c\n            } else if\
    \ (c == ')') {\n                current_group_open_parens -= 1\n             \
    \   current_group = current_group :+ c\n                if (current_group_open_parens\
    \ == 0) {\n                    paren_groups = paren_groups :+ current_group.mkString\n\
    \                    current_group = List[Char]()\n                }\n       \
    \     } else {\n                current_group = current_group :+ c\n         \
    \   }\n        }\n        paren_groups\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980072
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        // TODO: Implement this function\n        return\
    \ List[String]()\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeizvofm5.scala:13)\n\tat Problem.main(tmpeizvofm5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        var paren_groups = List[String]()\n        var paren_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') paren_count += 1\n            else if (c == ')')\
    \ paren_count -= 1\n            paren_group += c\n            if (paren_count\
    \ == 0) {\n                paren_groups = paren_group :: paren_groups\n      \
    \          paren_group = \"\"\n            }\n        }\n        paren_groups\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk9hnhbym.scala:25)\n\tat Problem.main(tmpk9hnhbym.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_list = paren_string_no_spaces.toList\n\
    \        var paren_groups = List[String]()\n        var current_group = List[Char]()\n\
    \        var open_parens = 0\n        for (paren <- paren_string_no_spaces_list)\
    \ {\n            if (paren == '(') {\n                open_parens += 1\n     \
    \           current_group = paren :: current_group\n            } else if (paren\
    \ == ')') {\n                open_parens -= 1\n                current_group =\
    \ paren :: current_group\n            }\n            if (open_parens == 0) {\n\
    \                paren_groups = current_group.reverse.mkString :: paren_groups\n\
    \                current_group = List[Char]()\n            }\n        }\n    \
    \    paren_groups.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    groups = groups :+ current_group\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        return groups\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val stack = new Stack[Char]\n        val groups\
    \ = new ListBuffer[String]\n        var current_group = new StringBuilder\n  \
    \      for (c <- paren_string) {\n            if (c == '(') {\n              \
    \  stack.push(c)\n            } else if (c == ')') {\n                if (stack.isEmpty)\
    \ {\n                    throw new Exception(\"Unbalanced parentheses\")\n   \
    \             }\n                stack.pop\n                if (stack.isEmpty)\
    \ {\n                    groups += current_group.toString\n                  \
    \  current_group = new StringBuilder\n                }\n            } else if\
    \ (c != ' ') {\n                current_group += c\n            }\n        }\n\
    \        if (!stack.isEmpty) {\n            throw new Exception(\"Unbalanced parentheses\"\
    )\n        }\n        groups.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvmajt2db.scala:34)\n\tat Problem.main(tmpvmajt2db.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_group += c\n            } else if (c == ')') {\n             \
    \   open_parens -= 1\n                current_group += c\n                if (open_parens\
    \ == 0) {\n                    paren_groups = current_group :: paren_groups\n\
    \                    current_group = \"\"\n                }\n            } else\
    \ {\n                current_group += c\n            }\n        }\n        paren_groups.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (i <- 0 until paren_string.length)\
    \ {\n            val c = paren_string(i)\n            if (c == '(') {\n      \
    \          open_parens += 1\n                current_group += c\n            }\
    \ else if (c == ')') {\n                open_parens -= 1\n                current_group\
    \ += c\n                if (open_parens == 0) {\n                    paren_groups\
    \ = current_group :: paren_groups\n                    current_group = \"\"\n\
    \                }\n            } else if (c != ' ') {\n                current_group\
    \ += c\n            }\n        }\n        paren_groups\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgccenrov.scala:31)\n\tat Problem.main(tmpgccenrov.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var curr_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                curr_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                curr_group += c\n                if (paren_count == 0) {\n  \
    \                  result = result :+ curr_group\n                    curr_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    curr_group += c\n            }\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_arr = paren_string_no_spaces.toCharArray\n\
    \        var paren_groups = List[String]()\n        var paren_group = \"\"\n \
    \       var open_paren_count = 0\n        for (i <- 0 until paren_string_no_spaces_arr.length)\
    \ {\n            val c = paren_string_no_spaces_arr(i)\n            if (c == '(')\
    \ {\n                open_paren_count += 1\n            } else if (c == ')') {\n\
    \                open_paren_count -= 1\n            }\n            paren_group\
    \ += c\n            if (open_paren_count == 0) {\n                paren_groups\
    \ = paren_group :: paren_groups\n                paren_group = \"\"\n        \
    \    }\n        }\n        paren_groups.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_group += c\n            } else if (c == ')') {\n             \
    \   open_parens -= 1\n                current_group += c\n                if (open_parens\
    \ == 0) {\n                    paren_groups = current_group :: paren_groups\n\
    \                    current_group = \"\"\n                }\n            } else\
    \ {\n                current_group += c\n            }\n        }\n        paren_groups.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var stack = new Stack[Char]\n        var groups\
    \ = new ListBuffer[String]\n        var group = new StringBuilder\n        for\
    \ (c <- paren_string) {\n            if (c == '(') {\n                stack.push(c)\n\
    \            } else if (c == ')') {\n                stack.pop\n             \
    \   if (stack.isEmpty) {\n                    groups += group.toString\n     \
    \               group = new StringBuilder\n                }\n            } else\
    \ if (c != ' ') {\n                group += c\n            }\n        }\n    \
    \    groups.toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa1clnos5.scala:28)\n\tat Problem.main(tmpa1clnos5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    paren_groups = paren_groups :+ current_group\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   paren_groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                if (open_parens == 0) current_group\
    \ = \"\"\n                open_parens += 1\n            }\n            else if\
    \ (c == ')') {\n                open_parens -= 1\n                if (open_parens\
    \ == 0) result = current_group :: result\n            }\n            else if (open_parens\
    \ > 0) current_group += c\n        }\n        result.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_0z5rrau.scala:26)\n\tat Problem.main(tmp_0z5rrau.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = new StringBuilder()\n        var open_parens = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_group.append(c)\n            } else if (c == ')') {\n        \
    \        open_parens -= 1\n                current_group.append(c)\n         \
    \       if (open_parens == 0) {\n                    paren_groups = current_group.toString\
    \ :: paren_groups\n                    current_group = new StringBuilder()\n \
    \               }\n            } else if (c != ' ') {\n                current_group.append(c)\n\
    \            }\n        }\n        paren_groups\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpthlbqf3m.scala:30)\n\tat Problem.main(tmpthlbqf3m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    paren_groups = current_group :: paren_groups\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   paren_groups.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    groups = groups :+ current_group\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        groups\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current\
    \ = new StringBuilder()\n        var open_count = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                open_count += 1\n          \
    \      current.append(c)\n            } else if (c == ')') {\n               \
    \ open_count -= 1\n                current.append(c)\n                if (open_count\
    \ == 0) {\n                    result = result :+ current.toString\n         \
    \           current = new StringBuilder()\n                }\n            } else\
    \ if (c != ' ') {\n                current.append(c)\n            }\n        }\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val stack = new Stack[Char]\n        val groups\
    \ = new ListBuffer[String]\n        var group = new StringBuilder\n        for\
    \ (c <- paren_string) {\n            if (c == '(') {\n                stack.push(c)\n\
    \            } else if (c == ')') {\n                if (stack.isEmpty) return\
    \ List()\n                stack.pop\n                if (stack.isEmpty) {\n  \
    \                  groups += group.toString\n                    group = new StringBuilder\n\
    \                }\n            } else if (c != ' ') {\n                group\
    \ += c\n            }\n        }\n        if (!stack.isEmpty) return List()\n\
    \        groups.toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdwtk847e.scala:30)\n\tat Problem.main(tmpdwtk847e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_list = paren_string_no_spaces.toList\n\
    \        var paren_groups = new ListBuffer[String]\n        var current_group\
    \ = new ListBuffer[Char]\n        var paren_count = 0\n        for (c <- paren_string_no_spaces_list)\
    \ {\n            if (c == '(') {\n                paren_count += 1\n         \
    \       current_group += c\n            } else if (c == ')') {\n             \
    \   paren_count -= 1\n                current_group += c\n            } else {\n\
    \                current_group += c\n            }\n            if (paren_count\
    \ == 0) {\n                paren_groups += current_group.mkString\n          \
    \      current_group = new ListBuffer[Char]\n            }\n        }\n      \
    \  paren_groups.toList\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_array = paren_string_no_spaces.toCharArray\n\
    \        var paren_groups = List[String]()\n        var current_paren_group =\
    \ \"\"\n        var open_parens = 0\n        for (i <- 0 until paren_string_no_spaces_array.length)\
    \ {\n            val current_char = paren_string_no_spaces_array(i)\n        \
    \    if (current_char == '(') {\n                open_parens += 1\n          \
    \  }\n            else if (current_char == ')') {\n                open_parens\
    \ -= 1\n            }\n            current_paren_group += current_char\n     \
    \       if (open_parens == 0) {\n                paren_groups = current_paren_group\
    \ :: paren_groups\n                current_paren_group = \"\"\n            }\n\
    \        }\n        paren_groups.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_group += c\n            } else if (c == ')') {\n             \
    \   open_parens -= 1\n                current_group += c\n                if (open_parens\
    \ == 0) {\n                    paren_groups = current_group :: paren_groups\n\
    \                    current_group = \"\"\n                }\n            } else\
    \ {\n                current_group += c\n            }\n        }\n        paren_groups.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    groups = groups :+ current_group\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        return groups\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_list = List[String]()\n        var current_paren_string\
    \ = \"\"\n        var open_paren_count = 0\n        for (c <- paren_string) {\n\
    \            if (c == '(') {\n                open_paren_count += 1\n        \
    \        current_paren_string += c\n            } else if (c == ')') {\n     \
    \           open_paren_count -= 1\n                current_paren_string += c\n\
    \                if (open_paren_count == 0) {\n                    paren_list\
    \ = current_paren_string :: paren_list\n                    current_paren_string\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_paren_string += c\n            }\n        }\n        paren_list\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg1jh4hdy.scala:30)\n\tat Problem.main(tmpg1jh4hdy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = List[String]()\n        var group =\
    \ \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n     \
    \       if (c == '(') {\n                open_parens += 1\n                group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                group += c\n                if (open_parens == 0) {\n       \
    \             groups = groups :+ group\n                    group = \"\"\n   \
    \             }\n            } else if (c != ' ') {\n                group +=\
    \ c\n            }\n        }\n        groups\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980073
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    paren_groups = paren_groups :+ current_group\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   paren_groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_list = paren_string_no_spaces.toList\n \
    \       val paren_stack = new Stack[Char]\n        val paren_groups = new ListBuffer[String]\n\
    \        var current_group = new StringBuilder\n        for (paren <- paren_string_list)\
    \ {\n            if (paren == '(') {\n                paren_stack.push(paren)\n\
    \                current_group.append(paren)\n            } else if (paren ==\
    \ ')') {\n                paren_stack.pop\n                current_group.append(paren)\n\
    \                if (paren_stack.isEmpty) {\n                    paren_groups\
    \ += current_group.toString\n                    current_group = new StringBuilder\n\
    \                }\n            } else {\n                current_group.append(paren)\n\
    \            }\n        }\n        paren_groups.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_length = paren_string_no_spaces.length\n\
    \        var paren_string_no_spaces_index = 0\n        var paren_string_no_spaces_current_char\
    \ = paren_string_no_spaces(paren_string_no_spaces_index)\n        var paren_string_no_spaces_current_char_is_open_paren\
    \ = paren_string_no_spaces_current_char == '('\n        var paren_string_no_spaces_current_char_is_close_paren\
    \ = paren_string_no_spaces_current_char == ')'\n        var paren_string_no_spaces_current_char_is_paren\
    \ = paren_string_no_spaces_current_char_is_open_paren || paren_string_no_spaces_current_char_is_close_paren\n\
    \        var paren_string_no_spaces_current_char_is_not_paren = !paren_string_no_spaces_current_char_is_paren\n\
    \        var paren_string_no_spaces_current_char_is_open_paren_count = 0\n   \
    \     var paren_string_no_spaces_current_char_is_close_paren_count = 0\n     \
    \   var paren_string_no_spaces_current_char_is_paren_count = 0\n        var paren_string_no_spaces_current_char_is_not_paren_count\
    \ = 0\n        var paren_string_no_spaces_current_char_is_open_paren_count_stack\
    \ = new Stack[Int]\n        var paren_string_no_spaces_current_char_is_close_paren_count_stack\
    \ = new Stack[Int]\n        var paren_string_no_spaces_current_char_is_paren_count_stack\
    \ = new Stack[Int]\n        var paren_string_no_spaces_current_char_is_not_paren_count_stack\
    \ = new Stack[Int]\n       \n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptrwx4ugg.scala:26:5\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980072
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]\n        var paren_groups\
    \ = new ListBuffer[String]\n        var current_group = new StringBuilder\n  \
    \      for (c <- paren_string) {\n            if (c == '(') {\n              \
    \  paren_stack.push(c)\n            } else if (c == ')') {\n                paren_stack.pop\n\
    \                if (paren_stack.isEmpty) {\n                    paren_groups\
    \ += current_group.toString\n                    current_group = new StringBuilder\n\
    \                }\n            } else if (c != ' ') {\n                current_group\
    \ += c\n            }\n        }\n        paren_groups.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb5sg7_oi.scala:28)\n\tat Problem.main(tmpb5sg7_oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    groups = groups :+ current_group\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        groups\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980078
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6im0wvmh.scala:30)\n\tat Problem.main(tmp6im0wvmh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        // TODO: Implement this function\n        return\
    \ List[String]()\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeizvofm5.scala:13)\n\tat Problem.main(tmpeizvofm5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980051
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    paren_groups = current_group :: paren_groups\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   paren_groups.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    groups = groups :+ current_group\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        groups\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    paren_groups = current_group :: paren_groups\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   paren_groups.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var paren_stack\
    \ = Stack[Char]()\n        var current_group = \"\"\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                paren_stack.push(c)\n      \
    \          current_group += c\n            } else if (c == ')') {\n          \
    \      paren_stack.pop\n                current_group += c\n                if\
    \ (paren_stack.isEmpty) {\n                    paren_groups = current_group ::\
    \ paren_groups\n                    current_group = \"\"\n                }\n\
    \            } else if (c != ' ') {\n                current_group += c\n    \
    \        }\n        }\n        paren_groups\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq4vu9wtk.scala:30)\n\tat Problem.main(tmpq4vu9wtk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980078
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        var paren_groups = List[String]()\n        var current_paren_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string_no_spaces)\
    \ {\n            if (c == '(') {\n                open_parens += 1\n         \
    \       current_paren_group += c\n            } else if (c == ')') {\n       \
    \         open_parens -= 1\n                current_paren_group += c\n       \
    \         if (open_parens == 0) {\n                    paren_groups = current_paren_group\
    \ :: paren_groups\n                    current_paren_group = \"\"\n          \
    \      }\n            } else {\n                current_paren_group += c\n   \
    \         }\n        }\n        paren_groups.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980078
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]\n        var group_start\
    \ = 0\n        var group_end = 0\n        var result = new ListBuffer[String]\n\
    \        for (i <- 0 until paren_string.length) {\n            if (paren_string(i)\
    \ == '(') {\n                if (paren_stack.isEmpty) {\n                    group_start\
    \ = i\n                }\n                paren_stack.push(paren_string(i))\n\
    \            } else if (paren_string(i) == ')') {\n                paren_stack.pop\n\
    \                if (paren_stack.isEmpty) {\n                    group_end = i\n\
    \                    result += paren_string.substring(group_start, group_end +\
    \ 1)\n                }\n            }\n        }\n        result.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_fie20ht.scala:33)\n\tat Problem.main(tmp_fie20ht.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]()\n        var\
    \ paren_groups = new ListBuffer[String]()\n        var cur_group = new StringBuilder()\n\
    \        for (c <- paren_string) {\n            if (c == '(') {\n            \
    \    paren_stack.push(c)\n            } else if (c == ')') {\n               \
    \ if (paren_stack.isEmpty) {\n                    throw new Exception(\"Unbalanced\
    \ parentheses\")\n                }\n                paren_stack.pop()\n     \
    \           if (paren_stack.isEmpty) {\n                    paren_groups += cur_group.toString\n\
    \                    cur_group = new StringBuilder()\n                }\n    \
    \        } else if (c != ' ') {\n                cur_group += c\n            }\n\
    \        }\n        if (!paren_stack.isEmpty) {\n            throw new Exception(\"\
    Unbalanced parentheses\")\n        }\n        return paren_groups.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzlooii_l.scala:34)\n\tat Problem.main(tmpzlooii_l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]\n        var paren_groups\
    \ = new ListBuffer[String]\n        var current_group = new StringBuilder\n  \
    \      for (c <- paren_string) {\n            if (c == '(') {\n              \
    \  paren_stack.push(c)\n            } else if (c == ')') {\n                paren_stack.pop\n\
    \                if (paren_stack.isEmpty) {\n                    paren_groups\
    \ += current_group.toString\n                    current_group = new StringBuilder\n\
    \                }\n            } else if (c != ' ') {\n                current_group\
    \ += c\n            }\n        }\n        paren_groups.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb5sg7_oi.scala:28)\n\tat Problem.main(tmpb5sg7_oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var cur_group\
    \ = new StringBuilder()\n        var cur_depth = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                cur_depth += 1\n           \
    \     cur_group.append(c)\n            } else if (c == ')') {\n              \
    \  cur_depth -= 1\n                cur_group.append(c)\n                if (cur_depth\
    \ == 0) {\n                    paren_groups = paren_groups :+ cur_group.toString\n\
    \                    cur_group = new StringBuilder()\n                }\n    \
    \        } else if (c != ' ') {\n                cur_group.append(c)\n       \
    \     }\n        }\n        paren_groups\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var paren_count = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n                if (paren_count == 0) {\n\
    \                    paren_groups = paren_groups :+ current_group\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   paren_groups\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_list = paren_string_no_spaces.toList\n \
    \       var paren_groups = List[String]()\n        var current_group = \"\"\n\
    \        var paren_count = 0\n        for (c <- paren_string_list) {\n       \
    \     if (c == '(') {\n                paren_count += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                paren_count -= 1\n\
    \                current_group += c\n            } else {\n                current_group\
    \ += c\n            }\n            if (paren_count == 0) {\n                paren_groups\
    \ = paren_groups :+ current_group\n                current_group = \"\"\n    \
    \        }\n        }\n        return paren_groups\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    paren_groups = current_group :: paren_groups\n          \
    \          current_group = \"\"\n                }\n            } else if (c !=\
    \ ' ') {\n                current_group += c\n            }\n        }\n     \
    \   paren_groups.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        // TODO: Implement this function\n        var result\
    \ = List[String]()\n        var temp = \"\"\n        var open = 0\n        for\
    \ (c <- paren_string) {\n            if (c == '(') {\n                open +=\
    \ 1\n                temp += c\n            } else if (c == ')') {\n         \
    \       open -= 1\n                temp += c\n                if (open == 0) {\n\
    \                    result = result :+ temp\n                    temp = \"\"\n\
    \                }\n            } else if (c != ' ') {\n                temp +=\
    \ c\n            }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var curr =\
    \ \"\"\n        var open = 0\n        for (c <- paren_string) {\n            if\
    \ (c == '(') {\n                open += 1\n                curr += c\n       \
    \     } else if (c == ')') {\n                open -= 1\n                curr\
    \ += c\n                if (open == 0) {\n                    result = curr ::\
    \ result\n                    curr = \"\"\n                }\n            } else\
    \ if (c != ' ') {\n                curr += c\n            }\n        }\n     \
    \   result.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_array = paren_string_no_spaces.toCharArray\n\
    \        var paren_groups = List[String]()\n        var current_group = \"\"\n\
    \        var paren_count = 0\n        for (i <- 0 until paren_string_no_spaces_array.length)\
    \ {\n            if (paren_string_no_spaces_array(i) == '(') {\n             \
    \   paren_count += 1\n            } else if (paren_string_no_spaces_array(i) ==\
    \ ')') {\n                paren_count -= 1\n            }\n            current_group\
    \ += paren_string_no_spaces_array(i)\n            if (paren_count == 0) {\n  \
    \              paren_groups = paren_groups :+ current_group\n                current_group\
    \ = \"\"\n            }\n        }\n        paren_groups\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\"\
    )).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"))));\n\
    \    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_groups = List[String]()\n        var paren_stack\
    \ = Stack[Char]()\n        var current_group = \"\"\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                paren_stack.push(c)\n      \
    \          current_group += c\n            } else if (c == ')') {\n          \
    \      if (paren_stack.isEmpty) {\n                    throw new IllegalArgumentException(\"\
    Invalid paren string\")\n                }\n                paren_stack.pop\n\
    \                current_group += c\n                if (paren_stack.isEmpty)\
    \ {\n                    paren_groups = current_group :: paren_groups\n      \
    \              current_group = \"\"\n                }\n            } else if\
    \ (c != ' ') {\n                current_group += c\n            }\n        }\n\
    \        if (!paren_stack.isEmpty) {\n            throw new IllegalArgumentException(\"\
    Invalid paren string\")\n        }\n        paren_groups.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = new StringBuilder()\n        var open_parens = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                if (open_parens == 0) {\n  \
    \                  current_group.clear()\n                }\n                open_parens\
    \ += 1\n                current_group += c\n            } else if (c == ')') {\n\
    \                open_parens -= 1\n                current_group += c\n      \
    \          if (open_parens == 0) {\n                    result = result :+ current_group.toString()\n\
    \                }\n            } else if (c != ' ') {\n                current_group\
    \ += c\n            }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(separateParenGroups((\"(()()) ((())) () ((())()())\")).equals((List[String](\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"))));\n    assert(separateParenGroups((\"\
    () (()) ((())) (((())))\")).equals((List[String](\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"))));\n    assert(separateParenGroups((\"(()(())((())))\")).equals((List[String](\"\
    (()(())((())))\"))));\n    assert(separateParenGroups((\"( ) (( )) (( )( ))\"\
    )).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var result = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    result = current_group :: result\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5ut42kt8.scala:30)\n\tat Problem.main(tmp5ut42kt8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    groups = groups :+ current_group\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        groups\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        val paren_string_no_spaces = paren_string.replaceAll(\"\
    \ \", \"\")\n        val paren_string_no_spaces_chars = paren_string_no_spaces.toCharArray\n\
    \        var paren_groups = List[String]()\n        var current_group = \"\"\n\
    \        var open_parens = 0\n        for (i <- 0 until paren_string_no_spaces_chars.length)\
    \ {\n            if (paren_string_no_spaces_chars(i) == '(') {\n             \
    \   open_parens += 1\n                current_group += \"(\"\n            } else\
    \ if (paren_string_no_spaces_chars(i) == ')') {\n                open_parens -=\
    \ 1\n                current_group += \")\"\n            }\n            if (open_parens\
    \ == 0) {\n                paren_groups = current_group :: paren_groups\n    \
    \            current_group = \"\"\n            }\n        }\n        paren_groups.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
    (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980079
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    groups = groups :+ current_group\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        groups\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var groups = List[String]()\n        var current_group\
    \ = \"\"\n        var open_parens = 0\n        for (c <- paren_string) {\n   \
    \         if (c == '(') {\n                open_parens += 1\n                current_group\
    \ += c\n            } else if (c == ')') {\n                open_parens -= 1\n\
    \                current_group += c\n                if (open_parens == 0) {\n\
    \                    groups = groups :+ current_group\n                    current_group\
    \ = \"\"\n                }\n            } else if (c != ' ') {\n            \
    \    current_group += c\n            }\n        }\n        groups\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()())\
    \ ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
    )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]\n        var paren_groups\
    \ = new ListBuffer[String]\n        var current_group = new StringBuilder\n  \
    \      for (c <- paren_string) {\n            if (c == '(') {\n              \
    \  paren_stack.push(c)\n            } else if (c == ')') {\n                paren_stack.pop\n\
    \                if (paren_stack.isEmpty) {\n                    paren_groups\
    \ += current_group.toString\n                    current_group = new StringBuilder\n\
    \                }\n            } else if (c != ' ') {\n                current_group\
    \ += c\n            }\n        }\n        paren_groups.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb5sg7_oi.scala:28)\n\tat Problem.main(tmpb5sg7_oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n    // separate those group into separate strings\
    \ and return the list of those.\n    // Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n    // Ignore any\
    \ spaces in the input string.\n    def separateParenGroups(paren_string : String)\
    \ : List[String] = {\n        var paren_stack = new Stack[Char]\n        var paren_groups\
    \ = new ListBuffer[String]\n        var current_group = new StringBuilder\n  \
    \      for (c <- paren_string) {\n            if (c == '(') {\n              \
    \  paren_stack.push(c)\n            } else if (c == ')') {\n                paren_stack.pop\n\
    \                if (paren_stack.isEmpty) {\n                    paren_groups\
    \ += current_group.toString\n                    current_group = new StringBuilder\n\
    \                }\n            } else if (c != ' ') {\n                current_group\
    \ += c\n            }\n        }\n        paren_groups.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(separateParenGroups((\"(()()) ((()))\
    \ () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\")).equals((List[String](\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
    (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
    ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb5sg7_oi.scala:28)\n\tat Problem.main(tmpb5sg7_oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
