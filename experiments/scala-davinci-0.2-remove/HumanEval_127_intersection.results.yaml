language: scala
name: HumanEval_127_intersection
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ <= 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        for (i\
    \ <- 2L until length) {\n            if (length % i == 0) return \"NO\"\n    \
    \    }\n        \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcoetu1lb.scala:33)\n\tat Problem.main(tmpcoetu1lb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3L to sqrt(length).toLong by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgb2s_rix.scala:33)\n\tat Problem.main(tmpgb2s_rix.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else if\
    \ (isPrime(end - start + 1)) \"YES\"\n        else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7th6mvpq.scala:22:17 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq2n1bw6c.scala:33)\n\tat Problem.main(tmpq2n1bw6c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) {\n            if (isPrime(start))\
    \ \"YES\"\n            else \"NO\"\n        }\n        else {\n            if\
    \ (isPrime(end - start + 1)) \"YES\"\n            else \"NO\"\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptr32w9yk.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (isPrime(start)) \e[31m\"YES\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmptr32w9yk.scala:26:16 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m            \e[33mif\e[0m (isPrime(end - start + \e[31m1\e[0m)) \e[31m\"YES\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3L to sqrt(length).toLong by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_31s7a7p.scala:34)\n\tat Problem.main(tmp_31s7a7p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   for (i <- 2L to sqrt(length).toLong) {\n            if (length % i == 0) return\
    \ \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcvnnlfsp.scala:31)\n\tat Problem.main(tmpcvnnlfsp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) \"YES\"\n\
    \            else if (start + 1 == end) \"YES\"\n            else if (start +\
    \ 2 == end) \"YES\"\n            else \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphp57acew.scala:31)\n\tat Problem.main(tmphp57acew.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) \"YES\"\n\
    \            else if (start + 1 == end) \"YES\"\n            else if (start +\
    \ 2 == end) \"YES\"\n            else \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphp57acew.scala:31)\n\tat Problem.main(tmphp57acew.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                val sqrt = sqrt(length).toLong\n      \
    \          val primes = ArrayBuffer[Long]()\n                for (i <- 2L to sqrt)\
    \ {\n                    if (length % i == 0) {\n                        primes\
    \ += i\n                    }\n                }\n                if (primes.isEmpty)\
    \ {\n                    \"YES\"\n                } else {\n                 \
    \   \"NO\"\n                }\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_rkqldts.scala:27:27 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        val sqrt = sqrt(length).toLong\n        for\
    \ (i <- 3L to sqrt by 2) {\n            if (length % i == 0) return \"NO\"\n \
    \       }\n        \"YES\"\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpr_kx0cn1.scala:27:19 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            val length = end - start +\
    \ 1\n            if (length == 1) \"NO\"\n            else if (length == 2) \"\
    YES\"\n            else {\n                val sqrt = sqrt(length).toLong\n  \
    \              for (i <- 2L to sqrt) {\n                    if (length % i ==\
    \ 0) return \"NO\"\n                }\n                \"YES\"\n            }\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp064mlbqm.scala:28:27 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        val start = max(start1, start2)\n\
    \        val end = min(end1, end2)\n        if (start > end) \"NO\"\n        else\
    \ if (start == end) \"YES\"\n        else if (start == end - 1) \"YES\"\n    \
    \    else if (start == end - 2) \"NO\"\n        else if (start == end - 3) \"\
    YES\"\n        else if (start == end - 4) \"NO\"\n        else if (start == end\
    \ - 5) \"YES\"\n        else if (start == end - 6) \"NO\"\n        else if (start\
    \ == end - 7) \"YES\"\n        else if (start == end - 8) \"NO\"\n        else\
    \ if (start == end - 9) \"NO\"\n        else if (start == end - 10) \"NO\"\n \
    \       else if (start == end - 11) \"YES\"\n        else if (start == end - 12)\
    \ \"NO\"\n        else if (start == end - 13) \"YES\"\n        else if (start\
    \ == end - 14) \"NO\"\n        else if (start == end - 15) \"NO\"\n        else\
    \ if (start == end - 16) \"NO\"\n        else if (start == end - 17) \"YES\"\n\
    \        else if (start == end - 18) \"NO\"\n        else if (start == end - 19)\
    \ \"YES\"\n        else if (start == end - 20) \"NO\"\n        else if (start\
    \ == end - 21) \"NO\"\n        else if (start == end - 22) \"NO\"\n        else\
    \ if (start == end - 23) \"YES\"\n        else if (start == end - 24) \"NO\"\n\
    \        else if (start == end - 25) \"NO\"\n        else if (start == end - 26)\
    \ \"NO\"\n        else if (start == end - 27) \"NO\"\n        else if (start ==\
    \ end - 28) \"NO\"\n        else if (start == end - 29) \"YES\"\n        else\
    \ if (start == end - 30) \"NO\"\n        else if (start == end - 31) \"NO\"\n\
    \        else\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmput4kmnja.scala:55:12 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m        \e[33melse\e[0m\n\e[31m\e[31m   |\e[0m      \
    \      ^\e[0m\n\e[31m   |\e[0m            expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) \"YES\"\n\
    \            else if (start + 1 == end) \"YES\"\n            else if (isPrime(end\
    \ - start)) \"YES\"\n            else \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpefo14hjw.scala:26:21 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (isPrime(end\
    \ - start)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: isPrime\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010199
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else if\
    \ (isPrime(end - start + 1)) \"YES\"\n        else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7th6mvpq.scala:22:17 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (end - start == 1) \"YES\"\n        else\
    \ if (end - start == 0) \"NO\"\n        else if (end - start == 2) \"YES\"\n \
    \       else if (end - start == 3) \"NO\"\n        else if (end - start == 4)\
    \ \"NO\"\n        else if (end - start == 5) \"YES\"\n        else if (end - start\
    \ == 6) \"NO\"\n        else if (end - start == 7) \"YES\"\n        else if (end\
    \ - start == 8) \"NO\"\n        else if (end - start == 9) \"NO\"\n        else\
    \ if (end - start == 10) \"NO\"\n        else if (end - start == 11) \"YES\"\n\
    \        else if (end - start == 12) \"NO\"\n        else if (end - start == 13)\
    \ \"YES\"\n        else if (end - start == 14) \"NO\"\n        else if (end -\
    \ start == 15) \"NO\"\n        else if (end - start == 16) \"NO\"\n        else\
    \ if (end - start == 17) \"YES\"\n        else if (end - start == 18) \"NO\"\n\
    \        else if (end - start == 19) \"YES\"\n        else if (end - start ==\
    \ 20) \"NO\"\n        else if (end - start == 21) \"NO\"\n        else if (end\
    \ - start == 22) \"NO\"\n        else if (end - start == 23) \"YES\"\n       \
    \ else if (end - start == 24) \"NO\"\n        else if (end - start == 25) \"NO\"\
    \n        else if (end - start == 26) \"NO\"\n        else if (end - start ==\
    \ 27) \"NO\"\n        else if (end - start == 28) \"NO\"\n        else if (end\
    \ - start == 29) \"YES\"\n        else if (end - start == 30) \"NO\"\n       \
    \ else if (end - start == 31) \"YES\"\n        else if (end - start == 32) \"\
    NO\"\n        else\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpo1mevj63.scala:54:12 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33melse\e[0m\n\e[31m\e[31m   |\e[0m      \
    \      ^\e[0m\n\e[31m   |\e[0m            expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else {\n\
    \            val length = end - start + 1\n            if (length == 2) \"YES\"\
    \n            else if (length % 2 == 0) \"NO\"\n            else {\n         \
    \       val sqrt = sqrt(length).toLong\n                var isPrime = true\n \
    \               for (i <- 3L to sqrt by 2) {\n                    if (length %\
    \ i == 0) {\n                        isPrime = false\n                       \
    \ i = sqrt\n                    }\n                }\n                if (isPrime)\
    \ \"YES\"\n                else \"NO\"\n            }\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmps9dyy6rt.scala:27:27 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmps9dyy6rt.scala:32:26 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                        i = sqrt\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \    Reassignment to val i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 2) return \"YES\"\n        for (i <-\
    \ 2 to sqrt(length).toInt) {\n            if (length % i == 0) return \"NO\"\n\
    \        }\n        \"YES\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj_5umpb0.scala:32)\n\tat Problem.main(tmpj_5umpb0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) {\n            \"NO\"\n        } else {\n  \
    \          val start = max(interval1._1, interval2._1)\n            val end =\
    \ min(interval1._2, interval2._2)\n            if (isPrime(end - start + 1)) \"\
    YES\" else \"NO\"\n        }\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_tvfbirh.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (isPrime(end - start + \e[31m1\e\
    [0m)) \e[31m\"YES\"\e[0m \e[33melse\e[0m \e[31m\"NO\"\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: isPrime\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 2) return \"YES\"\n        for (i <-\
    \ 2 to sqrt(length).toInt) {\n            if (length % i == 0) return \"NO\"\n\
    \        }\n        \"YES\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj_5umpb0.scala:32)\n\tat Problem.main(tmpj_5umpb0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) {\n            if (isPrime(start))\
    \ \"YES\"\n            else \"NO\"\n        }\n        else {\n            if\
    \ (isPrime(end - start + 1)) \"YES\"\n            else \"NO\"\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptr32w9yk.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (isPrime(start)) \e[31m\"YES\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmptr32w9yk.scala:26:16 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m            \e[33mif\e[0m (isPrime(end - start + \e[31m1\e[0m)) \e[31m\"YES\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else if\
    \ (end - start == 1) \"YES\"\n        else if (end - start == 2) \"YES\"\n   \
    \     else if (end - start == 3) \"YES\"\n        else if (end - start == 5) \"\
    YES\"\n        else if (end - start == 7) \"YES\"\n        else \"NO\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l,\
    \ 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq57z_evz.scala:30)\n\tat Problem.main(tmpq57z_evz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 1) return \"YES\"\n        if (length\
    \ == 2) return \"NO\"\n        val sqrt = sqrt(length).toLong\n        for (i\
    \ <- 2L to sqrt) {\n            if (length % i == 0) return \"NO\"\n        }\n\
    \        \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3ix425gj.scala:27:19 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010201
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   for (i <- 2 to sqrt(length).toInt) {\n            if (length % i == 0) return\
    \ \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcl8pr9s8.scala:31)\n\tat Problem.main(tmpcl8pr9s8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3f_0cm1l.scala:34)\n\tat Problem.main(tmp3f_0cm1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) return \"NO\"\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        val\
    \ length = end - start + 1\n        if (length == 1) return \"NO\"\n        if\
    \ (length == 2) return \"YES\"\n        if (length % 2 == 0) return \"NO\"\n \
    \       for (i <- 3L to sqrt(length).toLong by 2) {\n            if (length %\
    \ i == 0) return \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyh70w1d9.scala:32)\n\tat Problem.main(tmpyh70w1d9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq2n1bw6c.scala:33)\n\tat Problem.main(tmpq2n1bw6c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        val sqrt = sqrt(length).toLong\n        for (i <-\
    \ 2L to sqrt) {\n            if (length % i == 0) return \"NO\"\n        }\n \
    \       \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqchi6ll_.scala:25:19 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                val primes = ArrayBuffer(2L, 3L, 5L, 7L,\
    \ 11L, 13L, 17L, 19L, 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L,\
    \ 73L, 79L, 83L, 89L, 97L, 101L, 103L, 107L, 109L, 113L, 127L, 131L, 137L, 139L,\
    \ 149L, 151L, 157L, 163L, 167L, 173L, 179L, 181L, 191L, 193L, 197L, 199L, 211L,\
    \ 223L, 227L, 229L, 233L, 239L, 241L, 251L, 257L, 263L, 269L, 271L, 277L, 281L,\
    \ 283L, 293L, 307L, 311L, 313L, 317L, 331L, 337L, 347L, 349L, 353L, 359L, 367L,\
    \ 373L, 379L, 383L, 389L, 397L, 401L, 409L, 419L, 421L, 431L, 433L, 439L, 443L,\
    \ 449L, 457L, 461L, 463L, 467L, 479L, 487L, 491L, 499L, 503L, 509L, 521L, 523L,\
    \ 541L, 547L, 557L, 563L, 569L, 571L, 577L, 587L, 593L, 599L, 601L, 607L, 613L,\
    \ 617L, 619L, 631L, 641L, 643L, 647L, 653L, 659L, 661L, 673L, 677L, 683L, 691L,\
    \ 701L, 709L\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8dh99h7f.scala:28:4 ----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8dh99h7f.scala:41:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m41 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp8dh99h7f.scala:40:1 ---------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp8dh99h7f.scala:29:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m29 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            val length = end - start +\
    \ 1\n            if (length == 1) \"NO\"\n            else if (length == 2) \"\
    YES\"\n            else if (length % 2 == 0) \"NO\"\n            else {\n    \
    \            val sqrt = sqrt(length).toLong\n                for (i <- 3L to sqrt)\
    \ {\n                    if (length % i == 0) return \"NO\"\n                }\n\
    \                \"YES\"\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_x158qn8.scala:29:27 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                if (isPrime(length)) {\n              \
    \      \"YES\"\n                } else {\n                    \"NO\"\n       \
    \         }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphhv6_pcg.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                \e[33mif\e[0m (isPrime(length)) {\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010205
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else if\
    \ (start == end - 1) \"YES\"\n        else if (start == end - 2) \"NO\"\n    \
    \    else if (start == end - 3) \"YES\"\n        else if (start == end - 4) \"\
    NO\"\n        else if (start == end - 5) \"YES\"\n        else if (start == end\
    \ - 6) \"NO\"\n        else if (start == end - 7) \"YES\"\n        else if (start\
    \ == end - 8) \"NO\"\n        else if (start == end - 9) \"NO\"\n        else\
    \ \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8cbbi31d.scala:34)\n\tat Problem.main(tmp8cbbi31d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010208
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                if (length == 2) {\n                  \
    \  \"YES\"\n                } else {\n                    if (length % 2 == 0)\
    \ {\n                        \"NO\"\n                    } else {\n          \
    \              if (length % 3 == 0) {\n                            \"NO\"\n  \
    \                      } else {\n                            if (length % 5 ==\
    \ 0) {\n                                \"NO\"\n                            }\
    \ else {\n                                if (length % 7 == 0) {\n           \
    \                         \"NO\"\n                                } else {\n \
    \                                   \"YES\"\n                                }\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9gnvpsil.scala:53)\n\tat Problem.main(tmp9gnvpsil.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3f_0cm1l.scala:34)\n\tat Problem.main(tmp3f_0cm1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) \"YES\"\n\
    \            else if (start == end - 1) \"YES\"\n            else if (start ==\
    \ end - 2) \"NO\"\n            else if (start == end - 3) \"YES\"\n          \
    \  else if (start == end - 4) \"NO\"\n            else if (start == end - 5) \"\
    YES\"\n            else if (start == end - 6) \"NO\"\n            else if (start\
    \ == end - 7) \"YES\"\n            else if (start == end - 8) \"NO\"\n       \
    \     else if (start == end - 9) \"NO\"\n            else \"YES\"\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa9h1yku3.scala:38)\n\tat Problem.main(tmpa9h1yku3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) {\n            \"NO\"\n        } else {\n            val start = max(start1,\
    \ start2)\n            val end = min(end1, end2)\n            val length = end\
    \ - start + 1\n            if (length == 1) \"NO\"\n            else if (length\
    \ == 2) \"YES\"\n            else if (length % 2 == 0) \"NO\"\n            else\
    \ {\n                val sqrt = sqrt(length).toLong\n                var i = 3L\n\
    \                while (i <= sqrt) {\n                    if (length % i == 0)\
    \ return \"NO\"\n                    i += 2\n                }\n             \
    \   \"YES\"\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnxn1vec7.scala:30:27 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        val sqrt\
    \ = sqrt(length).toLong\n        for (i <- 2L to sqrt) {\n            if (length\
    \ % i == 0) return \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpl8134jz0.scala:26:19 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            val length = end - start +\
    \ 1\n            if (length == 1) \"NO\"\n            else if (length == 2) \"\
    YES\"\n            else if (length % 2 == 0) \"NO\"\n            else {\n    \
    \            val sqrt = sqrt(length).toLong\n                var isPrime = true\n\
    \                for (i <- 3L to sqrt) {\n                    if (length % i ==\
    \ 0) {\n                        isPrime = false\n                        i = sqrt\n\
    \                    }\n                }\n                if (isPrime) \"YES\"\
    \n                else \"NO\"\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx2d83l17.scala:29:27 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpx2d83l17.scala:34:26 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                        i = sqrt\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \    Reassignment to val i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010207
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        val start = max(start1, start2)\n\
    \        val end = min(end1, end2)\n        if (start > end) \"NO\"\n        else\
    \ if (start == end) \"YES\"\n        else if (isPrime(end - start + 1)) \"YES\"\
    \n        else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_qfzxhh1.scala:24:17 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        if (isPrime(end\
    \ - start + 1)) return \"YES\"\n        \"NO\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpld5yg8sd.scala:24:12 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mif\e[0m (isPrime(end - start + \e[31m1\e\
    [0m)) \e[33mreturn\e[0m \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Not found: isPrime\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else if\
    \ (isPrime(end - start + 1)) \"YES\"\n        else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7th6mvpq.scala:22:17 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   if (length % 2 == 0) return \"NO\"\n        for (i <- 3L to sqrt(length).toLong\
    \ by 2) {\n            if (length % i == 0) return \"NO\"\n        }\n       \
    \ \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6vs_l87v.scala:32)\n\tat Problem.main(tmp6vs_l87v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   if (length % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt\
    \ by 2) {\n            if (length % i == 0) return \"NO\"\n        }\n       \
    \ \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppve5zual.scala:32)\n\tat Problem.main(tmppve5zual.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) \"YES\"\n\
    \            else if (start + 1 == end) \"YES\"\n            else if (start +\
    \ 2 == end) \"YES\"\n            else \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphp57acew.scala:31)\n\tat Problem.main(tmphp57acew.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   for (i <- 2 to sqrt(length).toInt) {\n            if (length % i == 0) return\
    \ \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcl8pr9s8.scala:31)\n\tat Problem.main(tmpcl8pr9s8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            val length = end - start +\
    \ 1\n            if (length == 1) \"NO\"\n            else if (length == 2) \"\
    YES\"\n            else {\n                val sqrt = sqrt(length).toLong\n  \
    \              if (sqrt * sqrt == length) \"NO\"\n                else {\n   \
    \                 var isPrime = true\n                    for (i <- 2L to sqrt)\
    \ {\n                        if (length % i == 0) {\n                        \
    \    isPrime = false\n                            i = sqrt\n                 \
    \       }\n                    }\n                    if (isPrime) \"YES\"\n \
    \                   else \"NO\"\n                }\n            }\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkaqtjx4v.scala:28:27 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpkaqtjx4v.scala:35:30 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                            i = sqrt\n\e[31m\e[31m  \
    \ |\e[0m                            ^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                 Reassignment to val i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        val sqrtLength = sqrt(length).toLong\n        for\
    \ (i <- 2L to sqrtLength) {\n            if (length % i == 0) return \"NO\"\n\
    \        }\n        \"YES\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpskz8s22i.scala:33)\n\tat Problem.main(tmpskz8s22i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010215
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   for (i <- 2L to length / 2) {\n            if (length % i == 0) return \"\
    NO\"\n        }\n        \"YES\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd8qtdasu.scala:31)\n\tat Problem.main(tmpd8qtdasu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010214
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   for (i <- 2 to sqrt(length).toInt) {\n            if (length % i == 0) return\
    \ \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcl8pr9s8.scala:31)\n\tat Problem.main(tmpcl8pr9s8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else if\
    \ (isPrime(end - start + 1)) \"YES\"\n        else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7th6mvpq.scala:22:17 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   if (length % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt\
    \ by 2) {\n            if (length % i == 0) return \"NO\"\n        }\n       \
    \ \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppve5zual.scala:32)\n\tat Problem.main(tmppve5zual.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        val start = max(start1, start2)\n\
    \        val end = min(end1, end2)\n        if (start > end) \"NO\"\n        else\
    \ if (isPrime(end - start + 1)) \"YES\"\n        else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnkwxiam7.scala:23:17 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            val length = end - start +\
    \ 1\n            if (length == 1) \"NO\"\n            else if (length == 2) \"\
    YES\"\n            else {\n                val sqrt = sqrt(length).toLong\n  \
    \              var isPrime = true\n                for (i <- 2L to sqrt) {\n \
    \                   if (length % i == 0) {\n                        isPrime =\
    \ false\n                        i = sqrt\n                    }\n           \
    \     }\n                if (isPrime) \"YES\"\n                else \"NO\"\n \
    \           }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpr40xnct3.scala:28:27 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpr40xnct3.scala:33:26 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                        i = sqrt\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \    Reassignment to val i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010211
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            val length = end - start +\
    \ 1\n            if (length == 1) \"NO\"\n            else if (length == 2) \"\
    YES\"\n            else if (length % 2 == 0) \"NO\"\n            else {\n    \
    \            var isPrime = true\n                for (i <- 3 to sqrt(length).toInt\
    \ by 2) {\n                    if (length % i == 0) {\n                      \
    \  isPrime = false\n                        i = sqrt(length).toInt\n         \
    \           }\n                }\n                if (isPrime) \"YES\"\n     \
    \           else \"NO\"\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp31d0ksgd.scala:33:26 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                        i = sqrt(length).toInt\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Reassignment to val i\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010211
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) \"NO\"\n        else {\n            val start\
    \ = max(interval1._1, interval2._1)\n            val end = min(interval1._2, interval2._2)\n\
    \            val length = end - start + 1\n            if (length == 1) \"NO\"\
    \n            else if (length == 2) \"YES\"\n            else {\n            \
    \    val sqrt = sqrt(length).toLong\n                var isPrime = true\n    \
    \            for (i <- 2L to sqrt) {\n                    if (length % i == 0)\
    \ {\n                        isPrime = false\n                        i = sqrt\n\
    \                    }\n                }\n                if (isPrime) \"YES\"\
    \n                else \"NO\"\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa5vcygtr.scala:26:27 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpa5vcygtr.scala:31:26 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                        i = sqrt\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \    Reassignment to val i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010211
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        for (i\
    \ <- 2 to sqrt(length).toInt) {\n            if (length % i == 0) return \"NO\"\
    \n        }\n        \"YES\"\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpafzo2xk_.scala:33)\n\tat Problem.main(tmpafzo2xk_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010216
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) {\n    \
    \            if (start == 1) \"YES\"\n                else if (start == 2) \"\
    YES\"\n                else if (start % 2 == 0) \"NO\"\n                else {\n\
    \                    val sqrt = sqrt(start).toLong\n                    var flag\
    \ = true\n                    for (i <- 3 to sqrt by 2) {\n                  \
    \      if (start % i == 0) {\n                            flag = false\n     \
    \                       i = sqrt\n                        }\n                \
    \    }\n                    if (flag) \"YES\"\n                    else \"NO\"\
    \n                }\n            }\n            else {\n                if (start\
    \ == 1) \"YES\"\n                else if (start == 2) \"YES\"\n              \
    \  else if (start % 2 == 0) \"NO\"\n                else {\n                 \
    \   val sqrt = sqrt(start).toLong\n                    var flag = true\n     \
    \               for (i <- 3 to sqrt by 2) {\n                        if (start\
    \ % i == 0) {\n                            flag = false\n                    \
    \        i = sqrt\n                        }\n                    }\n        \
    \            if (flag) \"YES\"\n                    else \"NO\"\n            \
    \    }\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcyd1a1wm.scala:29:31 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    \e[33mval\e[0m \e[36msqrt\e[0m =\
    \ sqrt(start).toLong\n\e[31m\e[31m   |\e[0m                               ^\e\
    [0m\n\e[31m   |\e[0m                               Recursive \e[33mvalue\e[0m\
    \ \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpcyd1a1wm.scala:34:30 -----------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m                            i = sqrt\n\e[31m\e[31m   |\e[0m          \
    \                  ^^^^^^^^\e[0m\n\e[31m   |\e[0m                            Reassignment\
    \ to val i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcyd1a1wm.scala:46:31\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m                    \e\
    [33mval\e[0m \e[36msqrt\e[0m = sqrt(start).toLong\n\e[31m\e[31m   |\e[0m     \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \    Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpcyd1a1wm.scala:51:30 -----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m                            i = sqrt\n\e[31m\e[31m  \
    \ |\e[0m                            ^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                 Reassignment to val i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   if (length % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt\
    \ by 2) {\n            if (length % i == 0) return \"NO\"\n        }\n       \
    \ \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppve5zual.scala:32)\n\tat Problem.main(tmppve5zual.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 2) return \"YES\"\n        val sqrt\
    \ = sqrt(length).toLong\n        for (i <- 2L to sqrt) {\n            if (length\
    \ % i == 0) return \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9ergt1qd.scala:26:19 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3f_0cm1l.scala:34)\n\tat Problem.main(tmp3f_0cm1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) return \"NO\"\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        val\
    \ length = end - start + 1\n        if (length < 2) return \"NO\"\n        if\
    \ (length == 2) return \"YES\"\n        if (length % 2 == 0) return \"NO\"\n \
    \       for (i <- 3 to sqrt(length).toInt by 2) {\n            if (length % i\
    \ == 0) return \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps1zng3hi.scala:32)\n\tat Problem.main(tmps1zng3hi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010217
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   if (length % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt\
    \ by 2) {\n            if (length % i == 0) return \"NO\"\n        }\n       \
    \ \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppve5zual.scala:32)\n\tat Problem.main(tmppve5zual.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        val start = max(start1, start2)\n\
    \        val end = min(end1, end2)\n        if (start > end) \"NO\"\n        else\
    \ if (start == end) \"YES\"\n        else if (isPrime(end - start + 1)) \"YES\"\
    \n        else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_qfzxhh1.scala:24:17 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) {\n    \
    \            if (isPrime(start)) \"YES\"\n                else \"NO\"\n      \
    \      }\n            else {\n                if (isPrime(end - start + 1)) \"\
    YES\"\n                else \"NO\"\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptop7ak0z.scala:25:20 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mif\e[0m (isPrime(start)) \e[31m\"\
    YES\"\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmptop7ak0z.scala:29:20 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m                \e[33mif\e[0m (isPrime(end - start + \e[31m1\e\
    [0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                    Not found: isPrime\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) \"YES\"\n\
    \            else if (start + 1 == end) \"YES\"\n            else if (start +\
    \ 2 == end) \"YES\"\n            else if (start + 3 == end) \"YES\"\n        \
    \    else if (start + 5 == end) \"YES\"\n            else if (start + 7 == end)\
    \ \"YES\"\n            else if (start + 11 == end) \"YES\"\n            else if\
    \ (start + 13 == end) \"YES\"\n            else if (start + 17 == end) \"YES\"\
    \n            else if (start + 19 == end) \"YES\"\n            else if (start\
    \ + 23 == end) \"YES\"\n            else if (start + 29 == end) \"YES\"\n    \
    \        else if (start + 31 == end) \"YES\"\n            else if (start + 37\
    \ == end) \"YES\"\n            else if (start + 41 == end) \"YES\"\n         \
    \   else if (start + 43 == end) \"YES\"\n            else if (start + 47 == end)\
    \ \"YES\"\n            else if (start + 53 == end) \"YES\"\n            else if\
    \ (start + 59 == end) \"YES\"\n            else if (start + 61 == end) \"YES\"\
    \n            else if (start + 67 == end) \"YES\"\n            else if (start\
    \ + 71 == end) \"YES\"\n            else if (start + 73 == end) \"YES\"\n    \
    \        else if (start + 79 == end) \"YES\"\n            else if (start + 83\
    \ == end) \"YES\"\n            else if (start + 89 == end) \"YES\"\n         \
    \   else if (start + 97 == end) \"YES\"\n            else \"NO\"\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxzsxa8zl.scala:55)\n\tat Problem.main(tmpxzsxa8zl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010216
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) {\n            \"NO\"\n        } else {\n            val start = max(start1,\
    \ start2)\n            val end = min(end1, end2)\n            if (start == end)\
    \ {\n                \"YES\"\n            } else {\n                val length\
    \ = end - start + 1\n                if (length == 2) {\n                    \"\
    YES\"\n                } else {\n                    val sqrtLength = sqrt(length).toLong\n\
    \                    var isPrime = true\n                    for (i <- 2L to sqrtLength)\
    \ {\n                        if (length % i == 0) {\n                        \
    \    isPrime = false\n                        }\n                    }\n     \
    \               if (isPrime) {\n                        \"YES\"\n            \
    \        } else {\n                        \"NO\"\n                    }\n   \
    \             }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnmmn5gmd.scala:49)\n\tat Problem.main(tmpnmmn5gmd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010218
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) \"YES\"\n\
    \            else if (start + 1 == end) \"YES\"\n            else if (start +\
    \ 2 == end) \"YES\"\n            else if (start + 3 == end) \"YES\"\n        \
    \    else if (start + 5 == end) \"YES\"\n            else if (start + 7 == end)\
    \ \"YES\"\n            else if (start + 11 == end) \"YES\"\n            else if\
    \ (start + 13 == end) \"YES\"\n            else if (start + 17 == end) \"YES\"\
    \n            else if (start + 19 == end) \"YES\"\n            else if (start\
    \ + 23 == end) \"YES\"\n            else if (start + 29 == end) \"YES\"\n    \
    \        else if (start + 31 == end) \"YES\"\n            else if (start + 37\
    \ == end) \"YES\"\n            else if (start + 41 == end) \"YES\"\n         \
    \   else if (start + 43 == end) \"YES\"\n            else if (start + 47 == end)\
    \ \"YES\"\n            else if (start + 53 == end) \"YES\"\n            else if\
    \ (start + 59 == end) \"YES\"\n            else if (start + 61 == end) \"YES\"\
    \n            else if (start + 67 == end) \"YES\"\n            else if (start\
    \ + 71 == end) \"YES\"\n            else if (start + 73 == end) \"YES\"\n    \
    \        else if (start + 79 == end) \"YES\"\n            else if (start + 83\
    \ == end) \"YES\"\n            else if (start + 89 == end) \"YES\"\n         \
    \   else if (start + 97 == end) \"YES\"\n            else \"NO\"\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxzsxa8zl.scala:55)\n\tat Problem.main(tmpxzsxa8zl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010216
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else {\n\
    \            val length = end - start + 1\n            if (length == 2) \"YES\"\
    \n            else if (length % 2 == 0) \"NO\"\n            else {\n         \
    \       val sqrt = sqrt(length).toLong\n                for (i <- 3L to sqrt by\
    \ 2) {\n                    if (length % i == 0) return \"NO\"\n             \
    \   }\n                \"YES\"\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzzay7wii.scala:27:27 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010214
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            val length = end - start +\
    \ 1\n            if (length == 1) \"NO\"\n            else if (length == 2) \"\
    YES\"\n            else {\n                val sqrt = sqrt(length).toLong\n  \
    \              val isPrime = (2L to sqrt).forall(length % _ != 0)\n          \
    \      if (isPrime) \"YES\"\n                else \"NO\"\n            }\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpntdmg4tw.scala:28:27 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                val primes = ArrayBuffer(2L, 3L, 5L, 7L,\
    \ 11L, 13L, 17L, 19L, 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L,\
    \ 73L, 79L, 83L, 89L, 97L, 101L, 103L, 107L, 109L, 113L, 127L, 131L, 137L, 139L,\
    \ 149L, 151L, 157L, 163L, 167L, 173L, 179L, 181L, 191L, 193L, 197L, 199L, 211L,\
    \ 223L, 227L, 229L, 233L, 239L, 241L, 251L, 257L, 263L, 269L, 271L, 277L, 281L,\
    \ 283L, 293L, 307L, 311L, 313L, 317L, 331L, 337L, 347L, 349L, 353L, 359L, 367L,\
    \ 373L, 379L, 383L, 389L, 397L, 401L, 409L, 419L, 421L, 431L, 433L, 439L, 443L,\
    \ 449L, 457L, 461L, 463L, 467L, 479L, 487L, 491L, 499L, 503L, 509L, 521L, 523L,\
    \ 541L, 547L, 557L, 563L, 569L, 571L, 577L, 587L, 593L, 599L, 601L, 607L, 613L,\
    \ 617L, 619L, 631L, 641L, 643L, 647L, 653L, 659L, 661L, 673L, 677L, 683L, 691L,\
    \ 701L, 709L\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8dh99h7f.scala:28:4 ----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8dh99h7f.scala:41:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m41 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp8dh99h7f.scala:40:1 ---------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp8dh99h7f.scala:29:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m29 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   for (i <- 2 to sqrt(length).toInt) {\n            if (length % i == 0) return\
    \ \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcl8pr9s8.scala:31)\n\tat Problem.main(tmpcl8pr9s8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            val length = end - start +\
    \ 1\n            if (length == 1) \"NO\"\n            else if (length == 2) \"\
    YES\"\n            else {\n                val sqrt = sqrt(length).toLong\n  \
    \              var isPrime = true\n                for (i <- 2L to sqrt) {\n \
    \                   if (length % i == 0) {\n                        isPrime =\
    \ false\n                        i = sqrt\n                    }\n           \
    \     }\n                if (isPrime) \"YES\"\n                else \"NO\"\n \
    \           }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpr40xnct3.scala:28:27 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpr40xnct3.scala:33:26 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                        i = sqrt\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \    Reassignment to val i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010211
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (end1 < start2 || end2 < start1)\
    \ {\n            \"NO\"\n        } else {\n            val start = max(start1,\
    \ start2)\n            val end = min(end1, end2)\n            val length = end\
    \ - start + 1\n            if (length == 1) {\n                \"NO\"\n      \
    \      } else {\n                if (length == 2) {\n                    \"YES\"\
    \n                } else {\n                    if (length % 2 == 0) {\n     \
    \                   \"NO\"\n                    } else {\n                   \
    \     val sqrt = sqrt(length).toLong\n                        var isPrime = true\n\
    \                        for (i <- 3L to sqrt by 2) {\n                      \
    \      if (length % i == 0) {\n                                isPrime = false\n\
    \                                i = sqrt\n                            }\n   \
    \                     }\n                        if (isPrime) {\n            \
    \                \"YES\"\n                        } else {\n                 \
    \           \"NO\"\n                        }\n                    }\n       \
    \         }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpanrbge8u.scala:35:35 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                        \e[33mval\e[0m \e[36msqrt\e[0m\
    \ = sqrt(length).toLong\n\e[31m\e[31m   |\e[0m                               \
    \    ^\e[0m\n\e[31m   |\e[0m                                   Recursive \e[33mvalue\e\
    [0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpanrbge8u.scala:40:34 -----------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m                                i = sqrt\n\e[31m\e[31m   |\e[0m      \
    \                          ^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \            Reassignment to val i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010214
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        for (i\
    \ <- 2L to sqrt(length).toLong) {\n            if (length % i == 0) return \"\
    NO\"\n        }\n        \"YES\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4k86pbai.scala:33)\n\tat Problem.main(tmp4k86pbai.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010219
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   if (length % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt\
    \ by 2) {\n            if (length % i == 0) return \"NO\"\n        }\n       \
    \ \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppve5zual.scala:32)\n\tat Problem.main(tmppve5zual.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) return \"NO\"\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        val\
    \ length = end - start + 1\n        if (length == 1) return \"NO\"\n        if\
    \ (length == 2) return \"YES\"\n        for (i <- 2 to sqrt(length).toInt) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb2no7nqe.scala:31)\n\tat Problem.main(tmpb2no7nqe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010220
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) \"YES\"\n\
    \            else if (start + 1 == end) \"YES\"\n            else if (start +\
    \ 2 == end) \"YES\"\n            else if (start + 3 == end) \"YES\"\n        \
    \    else if (start + 5 == end) \"YES\"\n            else if (start + 7 == end)\
    \ \"YES\"\n            else if (start + 11 == end) \"YES\"\n            else if\
    \ (start + 13 == end) \"YES\"\n            else if (start + 17 == end) \"YES\"\
    \n            else if (start + 19 == end) \"YES\"\n            else if (start\
    \ + 23 == end) \"YES\"\n            else if (start + 29 == end) \"YES\"\n    \
    \        else if (start + 31 == end) \"YES\"\n            else if (start + 37\
    \ == end) \"YES\"\n            else if (start + 41 == end) \"YES\"\n         \
    \   else if (start + 43 == end) \"YES\"\n            else if (start + 47 == end)\
    \ \"YES\"\n            else if (start + 53 == end) \"YES\"\n            else if\
    \ (start + 59 == end) \"YES\"\n            else if (start + 61 == end) \"YES\"\
    \n            else if (start + 67 == end) \"YES\"\n            else if (start\
    \ + 71 == end) \"YES\"\n            else if (start + 73 == end) \"YES\"\n    \
    \        else if (start + 79 == end) \"YES\"\n            else if (start + 83\
    \ == end) \"YES\"\n            else if (start + 89 == end) \"YES\"\n         \
    \   else if (start + 97 == end) \"YES\"\n            else \"NO\"\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxzsxa8zl.scala:55)\n\tat Problem.main(tmpxzsxa8zl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010216
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   if (length % 2 == 0) return \"NO\"\n        for (i <- 3L to sqrt(length).toLong\
    \ by 2) {\n            if (length % i == 0) return \"NO\"\n        }\n       \
    \ \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6vs_l87v.scala:32)\n\tat Problem.main(tmp6vs_l87v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        val (start, end) = (max(start1,\
    \ start2), min(end1, end2))\n        if (start > end) \"NO\"\n        else if\
    \ (end - start == 1) \"YES\"\n        else if (end - start == 2) \"NO\"\n    \
    \    else if (end - start == 3) \"YES\"\n        else if (end - start == 4) \"\
    NO\"\n        else if (end - start == 5) \"YES\"\n        else if (end - start\
    \ == 6) \"NO\"\n        else if (end - start == 7) \"YES\"\n        else if (end\
    \ - start == 8) \"NO\"\n        else if (end - start == 9) \"NO\"\n        else\
    \ if (end - start == 10) \"NO\"\n        else if (end - start == 11) \"YES\"\n\
    \        else if (end - start == 12) \"NO\"\n        else if (end - start == 13)\
    \ \"YES\"\n        else if (end - start == 14) \"NO\"\n        else if (end -\
    \ start == 15) \"NO\"\n        else if (end - start == 16) \"NO\"\n        else\
    \ if (end - start == 17) \"YES\"\n        else if (end - start == 18) \"NO\"\n\
    \        else if (end - start == 19) \"YES\"\n        else if (end - start ==\
    \ 20) \"NO\"\n        else if (end - start == 21) \"NO\"\n        else if (end\
    \ - start == 22) \"NO\"\n        else if (end - start == 23) \"YES\"\n       \
    \ else if (end - start == 24) \"NO\"\n        else if (end - start == 25) \"NO\"\
    \n        else if (end - start == 26) \"NO\"\n        else if (end - start ==\
    \ 27) \"NO\"\n        else if (end - start == 28) \"NO\"\n        else if (end\
    \ - start == 29) \"YES\"\n        else if (end - start == 30) \"NO\"\n       \
    \ else if (end - start == 31) \"YES\"\n        else if (end - start == 32) \"\
    NO\"\n\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplttgla56.scala:53:13\
    \ --------------------\e[0m\e[0m\n\e[31m53 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (end - start == \e[31m32\e[0m) \e[31m\"NO\"\e[0m\n\e[31m\e[31m   |\e[0m  \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:\
    \    Unit\n\e[31m   |\e[0m             Required: String\n\e[31m   |\e[0m     \
    \        Maybe you are missing an else part for the conditional?\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010217
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) return \"NO\"\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        val\
    \ length = end - start + 1\n        if (length == 1) return \"NO\"\n        if\
    \ (length == 2) return \"YES\"\n        if (length % 2 == 0) return \"NO\"\n \
    \       for (i <- 3L to sqrt(length).toLong by 2) {\n            if (length %\
    \ i == 0) return \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyh70w1d9.scala:32)\n\tat Problem.main(tmpyh70w1d9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 2) return \"YES\"\n        val sqrt\
    \ = sqrt(length).toLong\n        for (i <- 2L to sqrt) {\n            if (length\
    \ % i == 0) return \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9ergt1qd.scala:26:19 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) {\n            if (start\
    \ == 1) \"YES\"\n            else \"NO\"\n        }\n        else {\n        \
    \    val length = end - start + 1\n            if (length == 2) \"YES\"\n    \
    \        else if (length % 2 == 0) \"NO\"\n            else {\n              \
    \  val sqrt = sqrt(length).toLong\n                for (i <- 3L to sqrt by 2)\
    \ {\n                    if (length % i == 0) return \"NO\"\n                }\n\
    \                \"YES\"\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzo0khlyf.scala:30:27 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010216
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        val start = max(start1, start2)\n\
    \        val end = min(end1, end2)\n        if (start > end) \"NO\"\n        else\
    \ if (isPrime(end - start + 1)) \"YES\"\n        else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnkwxiam7.scala:23:17 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3L to sqrt(length).toLong by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_31s7a7p.scala:34)\n\tat Problem.main(tmp_31s7a7p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        for (i\
    \ <- 2 to sqrt(length).toInt) {\n            if (length % i == 0) return \"NO\"\
    \n        }\n        \"YES\"\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpafzo2xk_.scala:33)\n\tat Problem.main(tmpafzo2xk_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010216
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   if (length % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt\
    \ by 2) {\n            if (length % i == 0) return \"NO\"\n        }\n       \
    \ \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppve5zual.scala:32)\n\tat Problem.main(tmppve5zual.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3L to sqrt(length).toLong by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_31s7a7p.scala:34)\n\tat Problem.main(tmp_31s7a7p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) \"YES\"\n\
    \            else {\n                val length = end - start + 1\n          \
    \      if (length == 2) \"YES\"\n                else if (length % 2 == 0) \"\
    NO\"\n                else {\n                    val sqrt = sqrt(length).toLong\n\
    \                    var isPrime = true\n                    for (i <- 3L to sqrt\
    \ by 2) {\n                        if (length % i == 0) {\n                  \
    \          isPrime = false\n                            i = sqrt\n           \
    \             }\n                    }\n                    if (isPrime) \"YES\"\
    \n                    else \"NO\"\n                }\n            }\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpebikumig.scala:30:31 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    \e[33mval\e[0m \e[36msqrt\e[0m =\
    \ sqrt(length).toLong\n\e[31m\e[31m   |\e[0m                               ^\e\
    [0m\n\e[31m   |\e[0m                               Recursive \e[33mvalue\e[0m\
    \ \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpebikumig.scala:35:30 -----------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m                            i = sqrt\n\e[31m\e[31m   |\e[0m          \
    \                  ^^^^^^^^\e[0m\n\e[31m   |\e[0m                            Reassignment\
    \ to val i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010217
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else if\
    \ (isPrime(end - start + 1)) \"YES\"\n        else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7th6mvpq.scala:22:17 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        val start = max(start1, start2)\n\
    \        val end = min(end1, end2)\n        if (start > end) \"NO\"\n        else\
    \ if (start == end) \"YES\"\n        else if (isPrime(end - start + 1)) \"YES\"\
    \n        else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_qfzxhh1.scala:24:17 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                if (length == 2) {\n                  \
    \  \"YES\"\n                } else {\n                    if (length % 2 == 0)\
    \ {\n                        \"NO\"\n                    } else {\n          \
    \              var isPrime = true\n                        for (i <- 3L to sqrt(length).toLong\
    \ by 2) {\n                            if (length % i == 0) {\n              \
    \                  isPrime = false\n                            }\n          \
    \              }\n                        if (isPrime) {\n                   \
    \         \"YES\"\n                        } else {\n                        \
    \    \"NO\"\n                        }\n                    }\n              \
    \  }\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphw1jhpq3.scala:51)\n\tat Problem.main(tmphw1jhpq3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010221
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                if (length == 2) {\n                  \
    \  \"YES\"\n                } else {\n                    if (length % 2 == 0)\
    \ {\n                        \"NO\"\n                    } else {\n          \
    \              var isPrime = true\n                        for (i <- 3 to sqrt(length).toInt\
    \ by 2) {\n                            if (length % i == 0) {\n              \
    \                  isPrime = false\n                            }\n          \
    \              }\n                        if (isPrime) {\n                   \
    \         \"YES\"\n                        } else {\n                        \
    \    \"NO\"\n                        }\n                    }\n              \
    \  }\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5cqqzi27.scala:51)\n\tat Problem.main(tmp5cqqzi27.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010221
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else if\
    \ (start == end - 1) \"YES\"\n        else if (start == end - 2) \"NO\"\n    \
    \    else if (start == end - 3) \"YES\"\n        else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfspgxlb5.scala:28)\n\tat Problem.main(tmpfspgxlb5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010220
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) {\n            \"NO\"\n        } else {\n            val start = max(start1,\
    \ start2)\n            val end = min(end1, end2)\n            if (start == end)\
    \ {\n                \"YES\"\n            } else {\n                val length\
    \ = end - start + 1\n                if (length == 2) {\n                    \"\
    YES\"\n                } else {\n                    val sqrt = sqrt(length).toLong\n\
    \                    var isPrime = true\n                    for (i <- 2L to sqrt)\
    \ {\n                        if (length % i == 0) {\n                        \
    \    isPrime = false\n                            break\n                    \
    \    }\n                    }\n                    if (isPrime) {\n          \
    \              \"YES\"\n                    } else {\n                       \
    \ \"NO\"\n                    }\n                }\n            }\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpylcudsip.scala:32:31 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    \e[33mval\e[0m \e[36msqrt\e[0m =\
    \ sqrt(length).toLong\n\e[31m\e[31m   |\e[0m                               ^\e\
    [0m\n\e[31m   |\e[0m                               Recursive \e[33mvalue\e[0m\
    \ \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpylcudsip.scala:37:28 ------------------------\e[0m\e[0m\n\e[31m37 |\e\
    [0m                            break\n\e[31m\e[31m   |\e[0m                  \
    \          ^^^^^\e[0m\n\e[31m   |\e[0m                            Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010219
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            val length = end - start +\
    \ 1\n            if (length == 1) \"NO\"\n            else if (length == 2) \"\
    YES\"\n            else if (length % 2 == 0) \"NO\"\n            else {\n    \
    \            val sqrt = sqrt(length).toLong\n                for (i <- 3L to sqrt\
    \ by 2) {\n                    if (length % i == 0) return \"NO\"\n          \
    \      }\n                \"YES\"\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpynfn3_8z.scala:29:27 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010219
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        val start = max(start1, start2)\n\
    \        val end = min(end1, end2)\n        if (start > end) {\n            \"\
    NO\"\n        } else {\n            val length = end - start + 1\n           \
    \ if (length == 1) {\n                \"NO\"\n            } else {\n         \
    \       val sqrt = sqrt(length).toLong\n                var isPrime = true\n \
    \               for (i <- 2L to sqrt) {\n                    if (length % i ==\
    \ 0) {\n                        isPrime = false\n                    }\n     \
    \           }\n                if (isPrime) {\n                    \"YES\"\n \
    \               } else {\n                    \"NO\"\n                }\n    \
    \        }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpm8gyxcx6.scala:29:27 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010218
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) \"YES\"\n\
    \            else if (start == end - 1) \"YES\"\n            else if (start ==\
    \ end - 2) \"NO\"\n            else if (start == end - 3) \"YES\"\n          \
    \  else \"NO\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpak2bw58_.scala:32)\n\tat Problem.main(tmpak2bw58_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010222
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   for (i <- 2 to sqrt(length).toInt) {\n            if (length % i == 0) return\
    \ \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcl8pr9s8.scala:31)\n\tat Problem.main(tmpcl8pr9s8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) return \"NO\"\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        val\
    \ length = end - start + 1\n        if (length == 1) return \"NO\"\n        if\
    \ (length == 2) return \"YES\"\n        if (length % 2 == 0) return \"NO\"\n \
    \       for (i <- 3 to sqrt(length).toInt by 2) {\n            if (length % i\
    \ == 0) return \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9_ji45ip.scala:32)\n\tat Problem.main(tmp9_ji45ip.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010223
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                if (length == 2) {\n                  \
    \  \"YES\"\n                } else {\n                    if (length % 2 == 0)\
    \ {\n                        \"NO\"\n                    } else {\n          \
    \              var isPrime = true\n                        for (i <- 3 to sqrt(length).toInt\
    \ by 2) {\n                            if (length % i == 0) {\n              \
    \                  isPrime = false\n                            }\n          \
    \              }\n                        if (isPrime) {\n                   \
    \         \"YES\"\n                        } else {\n                        \
    \    \"NO\"\n                        }\n                    }\n              \
    \  }\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5cqqzi27.scala:51)\n\tat Problem.main(tmp5cqqzi27.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010221
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        val start = max(start1, start2)\n\
    \        val end = min(end1, end2)\n        if (start > end) \"NO\"\n        else\
    \ if (start == end) {\n            if (isPrime(start)) \"YES\"\n            else\
    \ \"NO\"\n        }\n        else {\n            if (isPrime(end - start + 1))\
    \ \"YES\"\n            else \"NO\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2iqlhjgj.scala:24:16 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m (isPrime(start)) \e[31m\"YES\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp2iqlhjgj.scala:28:16 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m            \e[33mif\e[0m (isPrime(end - start + \e[31m1\e[0m)) \e[31m\"YES\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010220
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) \"YES\"\n\
    \            else if (isPrime(end - start)) \"YES\"\n            else \"NO\"\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj30v1a7x.scala:25:21 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (isPrime(end\
    \ - start)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: isPrime\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010220
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) \"YES\"\n\
    \            else if (start == end - 1) \"YES\"\n            else if (start ==\
    \ end - 2) \"NO\"\n            else if (start == end - 3) \"YES\"\n          \
    \  else if (start == end - 4) \"NO\"\n            else if (start == end - 5) \"\
    YES\"\n            else if (start == end - 6) \"NO\"\n            else if (start\
    \ == end - 7) \"YES\"\n            else if (start == end - 8) \"NO\"\n       \
    \     else if (start == end - 9) \"NO\"\n            else if (start == end - 10)\
    \ \"NO\"\n            else if (start == end - 11) \"YES\"\n            else if\
    \ (start == end - 12) \"NO\"\n            else if (start == end - 13) \"YES\"\n\
    \            else if (start == end - 14) \"NO\"\n            else if (start ==\
    \ end - 15) \"NO\"\n            else if (start == end - 16) \"NO\"\n         \
    \   else if (start == end - 17) \"YES\"\n            else if (start == end - 18)\
    \ \"NO\"\n            else if (start == end - 19) \"YES\"\n            else if\
    \ (start == end - 20) \"NO\"\n            else if (start == end - 21) \"NO\"\n\
    \            else if (start == end - 22) \"NO\"\n            else if (start ==\
    \ end - 23) \"YES\"\n            else if (start == end - 24) \"NO\"\n        \
    \    else if (start == end - 25) \"NO\"\n            else if (start == end - 26)\
    \ \"NO\"\n            else if (start == end - 27) \"NO\"\n            else if\
    \ (start == end - 28) \"NO\"\n            else if (start == end - 29) \"YES\"\n\
    \            else if (start == end - 30) \"NO\"\n            else if (start\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb2gw8wpd.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb2gw8wpd.scala:69:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m69 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpb2gw8wpd.scala:55:21 --------------------\e[0m\e[0m\n\
    \e[31m55 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (start\n\e[31m\e[31m\
    \   |\e[0m                     ^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Found:    (start : Long)\n\e[31m   |\e[0m                     Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb2gw8wpd.scala:68:1\
    \ ---------------------\e[0m\e[0m\n\e[31m68 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpb2gw8wpd.scala:57:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m57 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660010224
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else {\n\
    \            val length = end - start + 1\n            if (length == 2) \"YES\"\
    \n            else if (length % 2 == 0) \"NO\"\n            else {\n         \
    \       val sqrt = sqrt(length).toLong\n                for (i <- 3L to sqrt by\
    \ 2) {\n                    if (length % i == 0) return \"NO\"\n             \
    \   }\n                \"YES\"\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzzay7wii.scala:27:27 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010214
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) \"YES\"\n\
    \            else if (start + 1 == end) \"YES\"\n            else if (start +\
    \ 2 == end) \"YES\"\n            else \"NO\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphp57acew.scala:31)\n\tat Problem.main(tmphp57acew.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) {\n            \"NO\"\n        } else {\n            val start = max(start1,\
    \ start2)\n            val end = min(end1, end2)\n            val length = end\
    \ - start + 1\n            if (length == 1) {\n                \"NO\"\n      \
    \      } else {\n                if (length.isPrime) {\n                    \"\
    YES\"\n                } else {\n                    \"NO\"\n                }\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt9070re0.scala:29:27 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e[0m (length.isPrime) {\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                  value isPrime is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010224
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            val length = end - start +\
    \ 1\n            if (length == 1) \"NO\"\n            else if (length == 2) \"\
    YES\"\n            else {\n                val sqrt = sqrt(length).toLong\n  \
    \              (2L to sqrt).forall(x => length % x != 0)\n            }\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpavn2hafi.scala:28:27 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpavn2hafi.scala:29:35\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m                (\e[31m2L\e[0m\
    \ to sqrt).forall(\e[36mx\e[0m => length % x != \e[31m0\e[0m)\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                Found:    Boolean\n\e[31m   |\e[0m                Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010224
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        val sqrt = sqrt(length).toLong\n        for\
    \ (i <- 3L to sqrt by 2) {\n            if (length % i == 0) return \"NO\"\n \
    \       }\n        \"YES\"\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpr_kx0cn1.scala:27:19 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else if\
    \ (end - start == 1) \"YES\"\n        else if (end - start == 2) \"YES\"\n   \
    \     else if (end - start == 3) \"YES\"\n        else if (end - start == 5) \"\
    YES\"\n        else if (end - start == 7) \"YES\"\n        else \"NO\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l,\
    \ 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq57z_evz.scala:30)\n\tat Problem.main(tmpq57z_evz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            if (isPrime(end\
    \ - start + 1)) {\n                \"YES\"\n            } else {\n           \
    \     \"NO\"\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyf8f_e3d.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (isPrime(end - start + \e[31m1\e\
    [0m)) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \              Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010221
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   if (length % 2 == 0) return \"NO\"\n        for (i <- 3L to sqrt(length).toLong\
    \ by 2) {\n            if (length % i == 0) return \"NO\"\n        }\n       \
    \ \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6vs_l87v.scala:32)\n\tat Problem.main(tmp6vs_l87v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) {\n            if (isPrime(start))\
    \ \"YES\"\n            else \"NO\"\n        }\n        else {\n            if\
    \ (isPrime(end - start + 1)) \"YES\"\n            else \"NO\"\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptr32w9yk.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (isPrime(start)) \e[31m\"YES\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmptr32w9yk.scala:26:16 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m            \e[33mif\e[0m (isPrime(end - start + \e[31m1\e[0m)) \e[31m\"YES\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        val start = max(start1, start2)\n\
    \        val end = min(end1, end2)\n        if (start > end) \"NO\"\n        else\
    \ if (isPrime(end - start + 1)) \"YES\"\n        else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnkwxiam7.scala:23:17 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3L to sqrt(length).toLong by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_31s7a7p.scala:34)\n\tat Problem.main(tmp_31s7a7p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (end1 < start2 || end2 < start1)\
    \ \"NO\"\n        else {\n            val start = max(start1, start2)\n      \
    \      val end = min(end1, end2)\n            val length = end - start + 1\n \
    \           if (length == 1) \"NO\"\n            else if (length == 2) \"YES\"\
    \n            else if (length % 2 == 0) \"NO\"\n            else {\n         \
    \       val sqrt = sqrt(length).toLong\n                for (i <- 3L to sqrt by\
    \ 2) {\n                    if (length % i == 0) return \"NO\"\n             \
    \   }\n                \"YES\"\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_x5w7e7b.scala:29:27 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010224
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                if (length == 2) {\n                  \
    \  \"YES\"\n                } else {\n                    if (length % 2 == 0)\
    \ {\n                        \"NO\"\n                    } else {\n          \
    \              var isPrime = true\n                        for (i <- 3L to sqrt(length).toLong\
    \ by 2) {\n                            if (length % i == 0) {\n              \
    \                  isPrime = false\n                            }\n          \
    \              }\n                        if (isPrime) {\n                   \
    \         \"YES\"\n                        } else {\n                        \
    \    \"NO\"\n                        }\n                    }\n              \
    \  }\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphw1jhpq3.scala:51)\n\tat Problem.main(tmphw1jhpq3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010221
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else if\
    \ (start == end - 1) \"YES\"\n        else if (start == end - 2) \"NO\"\n    \
    \    else if (start == end - 3) \"YES\"\n        else if (start == end - 4) \"\
    NO\"\n        else if (start == end - 5) \"YES\"\n        else if (start == end\
    \ - 6) \"NO\"\n        else if (start == end - 7) \"YES\"\n        else if (start\
    \ == end - 8) \"NO\"\n        else if (start == end - 9) \"NO\"\n        else\
    \ if (start == end - 10) \"NO\"\n        else if (start == end - 11) \"YES\"\n\
    \        else if (start == end - 12) \"NO\"\n        else if (start == end - 13)\
    \ \"YES\"\n        else if (start == end - 14) \"NO\"\n        else if (start\
    \ == end - 15) \"NO\"\n        else if (start == end - 16) \"NO\"\n        else\
    \ if (start == end - 17) \"YES\"\n        else if (start == end - 18) \"NO\"\n\
    \        else if (start == end - 19) \"YES\"\n        else if (start == end -\
    \ 20) \"NO\"\n        else if (start == end - 21) \"NO\"\n        else if (start\
    \ == end - 22) \"NO\"\n        else if (start == end - 23) \"YES\"\n        else\
    \ if (start == end - 24) \"NO\"\n        else if (start == end - 25) \"NO\"\n\
    \        else if (start == end - 26) \"NO\"\n        else if (start == end - 27)\
    \ \"NO\"\n        else if (start == end - 28) \"NO\"\n        else if (start ==\
    \ end - 29) \"YES\"\n        else if (start == end - 30) \"NO\"\n        else\
    \ if (start == end - 31) \"NO\"\n        else if (start == end - 32) \"NO\"\n\
    \        else if (\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxzai9ogz.scala:54:17 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (\n\e[31m\e[31m\
    \   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010223
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3L to sqrt(length).toLong by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_31s7a7p.scala:34)\n\tat Problem.main(tmp_31s7a7p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) {\n            \"NO\"\n        } else {\n            val start = max(start1,\
    \ start2)\n            val end = min(end1, end2)\n            val length = end\
    \ - start + 1\n            if (length == 1) {\n                \"NO\"\n      \
    \      } else {\n                if (length.isPrime) {\n                    \"\
    YES\"\n                } else {\n                    \"NO\"\n                }\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt9070re0.scala:29:27 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e[0m (length.isPrime) {\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                  value isPrime is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010224
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) {\n            if (isPrime(start))\
    \ \"YES\"\n            else \"NO\"\n        }\n        else {\n            if\
    \ (isPrime(end - start + 1)) \"YES\"\n            else \"NO\"\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptr32w9yk.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (isPrime(start)) \e[31m\"YES\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmptr32w9yk.scala:26:16 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m            \e[33mif\e[0m (isPrime(end - start + \e[31m1\e[0m)) \e[31m\"YES\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   if (length % 2 == 0) return \"NO\"\n        for (i <- 3L to sqrt(length).toLong\
    \ by 2) {\n            if (length % i == 0) return \"NO\"\n        }\n       \
    \ \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6vs_l87v.scala:32)\n\tat Problem.main(tmp6vs_l87v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) return \"NO\"\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        val\
    \ length = end - start + 1\n        if (length == 1) return \"NO\"\n        if\
    \ (length == 2) return \"YES\"\n        for (i <- 2 to sqrt(length).toInt) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb2no7nqe.scala:31)\n\tat Problem.main(tmpb2no7nqe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010220
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) {\n            \"NO\"\n        } else {\n            val start = max(start1,\
    \ start2)\n            val end = min(end1, end2)\n            val length = end\
    \ - start + 1\n            if (length == 1) {\n                \"NO\"\n      \
    \      } else {\n                if (length % 2 == 0) {\n                    \"\
    NO\"\n                } else {\n                    val sqrt = sqrt(length).toLong\n\
    \                    if (sqrt * sqrt == length) {\n                        \"\
    NO\"\n                    } else {\n                        var isPrime = true\n\
    \                        for (i <- 3L to sqrt by 2) {\n                      \
    \      if (length % i == 0) {\n                                isPrime = false\n\
    \                            }\n                        }\n                  \
    \      if (isPrime) {\n                            \"YES\"\n                 \
    \       } else {\n                            \"NO\"\n                       \
    \ }\n                    }\n                }\n            }\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l,\
    \ 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgb_7fjgc.scala:32:31 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    \e[33mval\e[0m \e[36msqrt\e[0m =\
    \ sqrt(length).toLong\n\e[31m\e[31m   |\e[0m                               ^\e\
    [0m\n\e[31m   |\e[0m                               Recursive \e[33mvalue\e[0m\
    \ \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010224
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq2n1bw6c.scala:33)\n\tat Problem.main(tmpq2n1bw6c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else if\
    \ (isPrime(end - start + 1)) \"YES\"\n        else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7th6mvpq.scala:22:17 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                if (length.isPrime) {\n               \
    \     \"YES\"\n                } else {\n                    \"NO\"\n        \
    \        }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6lyoiws_.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                \e[33mif\e[0m (length.isPrime) {\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                  value isPrime is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010227
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 2) return \"YES\"\n        val sqrt\
    \ = sqrt(length).toLong\n        for (i <- 2L to sqrt) {\n            if (length\
    \ % i == 0) return \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9ergt1qd.scala:26:19 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   for (i <- 2 to sqrt(length).toInt) {\n            if (length % i == 0) return\
    \ \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcl8pr9s8.scala:31)\n\tat Problem.main(tmpcl8pr9s8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else if\
    \ (isPrime(end - start + 1)) \"YES\"\n        else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7th6mvpq.scala:22:17 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) \"YES\"\n\
    \            else if (isPrime(end - start)) \"YES\"\n            else \"NO\"\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj30v1a7x.scala:25:21 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (isPrime(end\
    \ - start)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: isPrime\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010220
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            val length = end - start +\
    \ 1\n            if (length == 1) \"NO\"\n            else if (length == 2) \"\
    YES\"\n            else {\n                val sqrt = sqrt(length).toLong\n  \
    \              if (sqrt * sqrt == length) \"NO\"\n                else {\n   \
    \                 val isPrime = (2L to sqrt).forall(length % _ != 0)\n       \
    \             if (isPrime) \"YES\"\n                    else \"NO\"\n        \
    \        }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxtl4mztr.scala:28:27 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010224
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (isPrime(end - start +\
    \ 1)) \"YES\"\n            else \"NO\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvnnn750a.scala:24:16 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m (isPrime(end - start + \e[31m1\e\
    [0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010224
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                if (length == 2) {\n                  \
    \  \"YES\"\n                } else {\n                    val sqrt = sqrt(length).toLong\n\
    \                    var isPrime = true\n                    for (i <- 2L to sqrt)\
    \ {\n                        if (length % i == 0) {\n                        \
    \    isPrime = false\n                        }\n                    }\n     \
    \               if (isPrime) {\n                        \"YES\"\n            \
    \        } else {\n                        \"NO\"\n                    }\n   \
    \             }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb8nab3o4.scala:30:31 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    \e[33mval\e[0m \e[36msqrt\e[0m =\
    \ sqrt(length).toLong\n\e[31m\e[31m   |\e[0m                               ^\e\
    [0m\n\e[31m   |\e[0m                               Recursive \e[33mvalue\e[0m\
    \ \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010225
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   for (i <- 2 to sqrt(length).toInt) {\n            if (length % i == 0) return\
    \ \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcl8pr9s8.scala:31)\n\tat Problem.main(tmpcl8pr9s8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   for (i <- 2 to sqrt(length).toInt) {\n            if (length % i == 0) return\
    \ \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcl8pr9s8.scala:31)\n\tat Problem.main(tmpcl8pr9s8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        val sqrt = sqrt(length).toLong\n        for\
    \ (i <- 3 to sqrt by 2) {\n            if (length % i == 0) return \"NO\"\n  \
    \      }\n        \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0b4ymu3f.scala:27:19 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010226
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) \"YES\"\n\
    \            else if (start == end - 1) \"YES\"\n            else if (start ==\
    \ end - 2) \"NO\"\n            else if (start == end - 3) \"YES\"\n          \
    \  else \"NO\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpak2bw58_.scala:32)\n\tat Problem.main(tmpak2bw58_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010222
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (isPrime(end - start + 1)) \"YES\"\n \
    \       else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnx_i_bo4.scala:21:17 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010225
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        val start = max(start1, start2)\n\
    \        val end = min(end1, end2)\n        if (start > end) \"NO\"\n        else\
    \ if (isPrime(end - start + 1)) \"YES\"\n        else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnkwxiam7.scala:23:17 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) {\n            \"NO\"\n        } else {\n            val start = max(start1,\
    \ start2)\n            val end = min(end1, end2)\n            if (isPrime(end\
    \ - start + 1)) \"YES\" else \"NO\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgu64t__9.scala:25:16 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mif\e[0m (isPrime(end - start + \e[31m1\e\
    [0m)) \e[31m\"YES\"\e[0m \e[33melse\e[0m \e[31m\"NO\"\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: isPrime\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010226
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3f_0cm1l.scala:34)\n\tat Problem.main(tmp3f_0cm1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                if (length == 2) {\n                  \
    \  \"YES\"\n                } else {\n                    val sqrt = sqrt(length).toLong\n\
    \                    var isPrime = true\n                    for (i <- 2L to sqrt)\
    \ {\n                        if (length % i == 0) {\n                        \
    \    isPrime = false\n                        }\n                    }\n     \
    \               if (isPrime) {\n                        \"YES\"\n            \
    \        } else {\n                        \"NO\"\n                    }\n   \
    \             }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb8nab3o4.scala:30:31 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    \e[33mval\e[0m \e[36msqrt\e[0m =\
    \ sqrt(length).toLong\n\e[31m\e[31m   |\e[0m                               ^\e\
    [0m\n\e[31m   |\e[0m                               Recursive \e[33mvalue\e[0m\
    \ \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010225
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) \"YES\"\n\
    \            else if (start == end - 1) \"YES\"\n            else if (start ==\
    \ end - 2) \"NO\"\n            else if (start == end - 3) \"YES\"\n          \
    \  else \"NO\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpak2bw58_.scala:32)\n\tat Problem.main(tmpak2bw58_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010222
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) {\n    \
    \            if (isPrime(start)) \"YES\"\n                else \"NO\"\n      \
    \      }\n            else {\n                if (isPrime(end - start + 1)) \"\
    YES\"\n                else \"NO\"\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptop7ak0z.scala:25:20 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mif\e[0m (isPrime(start)) \e[31m\"\
    YES\"\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmptop7ak0z.scala:29:20 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m                \e[33mif\e[0m (isPrime(end - start + \e[31m1\e\
    [0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                    Not found: isPrime\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3f_0cm1l.scala:34)\n\tat Problem.main(tmp3f_0cm1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                if (length == 2) {\n                  \
    \  \"YES\"\n                } else {\n                    if (length % 2 == 0)\
    \ {\n                        \"NO\"\n                    } else {\n          \
    \              if (length % 3 == 0) {\n                            \"NO\"\n  \
    \                      } else {\n                            var isPrime = true\n\
    \                            for (i <- 5 to sqrt(length).toInt by 2) {\n     \
    \                           if (length % i == 0) {\n                         \
    \           isPrime = false\n                                }\n             \
    \               }\n                            if (isPrime) {\n              \
    \                  \"YES\"\n                            } else {\n           \
    \                     \"NO\"\n                            }\n                \
    \        }\n                    }\n                }\n            }\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppa6c7d1m.scala:55)\n\tat Problem.main(tmppa6c7d1m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length <= 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   for (i <- 2L until length) {\n            if (length % i == 0) return \"NO\"\
    \n        }\n        \"YES\"\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptl0h5h29.scala:31)\n\tat Problem.main(tmptl0h5h29.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3L to sqrt(length).toLong by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_31s7a7p.scala:34)\n\tat Problem.main(tmp_31s7a7p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                var isPrime = true\n                for\
    \ (i <- 2L to sqrt(length).toLong) {\n                    if (length % i == 0)\
    \ {\n                        isPrime = false\n                    }\n        \
    \        }\n                if (isPrime) {\n                    \"YES\"\n    \
    \            } else {\n                    \"NO\"\n                }\n       \
    \     }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppkazr9v8.scala:43)\n\tat Problem.main(tmppkazr9v8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                if (length == 2) {\n                  \
    \  \"YES\"\n                } else {\n                    if (length % 2 == 0)\
    \ {\n                        \"NO\"\n                    } else {\n          \
    \              val sqrt = sqrt(length).toLong\n                        var isPrime\
    \ = true\n                        for (i <- 3 to sqrt by 2) {\n              \
    \              if (length % i == 0) {\n                                isPrime\
    \ = false\n                            }\n                        }\n        \
    \                if (isPrime) {\n                            \"YES\"\n       \
    \                 } else {\n                            \"NO\"\n             \
    \           }\n                    }\n                }\n            }\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0uxkljkh.scala:33:35 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                        \e[33mval\e[0m \e[36msqrt\e[0m\
    \ = sqrt(length).toLong\n\e[31m\e[31m   |\e[0m                               \
    \    ^\e[0m\n\e[31m   |\e[0m                                   Recursive \e[33mvalue\e\
    [0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010227
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        val start = max(start1, start2)\n\
    \        val end = min(end1, end2)\n        if (start > end) \"NO\"\n        else\
    \ if (start == end) {\n            if (isPrime(start)) \"YES\"\n            else\
    \ \"NO\"\n        }\n        else {\n            val length = end - start + 1\n\
    \            if (isPrime(length)) \"YES\"\n            else \"NO\"\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw4l1my45.scala:24:16 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m (isPrime(start)) \e[31m\"YES\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpw4l1my45.scala:29:16 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m            \e[33mif\e[0m (isPrime(length)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found:\
    \ isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010228
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else if\
    \ (isPrime(end - start + 1)) \"YES\"\n        else \"NO\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7th6mvpq.scala:22:17 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   if (length % 2 == 0) return \"NO\"\n        for (i <- 3L to sqrt(length).toLong\
    \ by 2) {\n            if (length % i == 0) return \"NO\"\n        }\n       \
    \ \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6vs_l87v.scala:32)\n\tat Problem.main(tmp6vs_l87v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3f_0cm1l.scala:34)\n\tat Problem.main(tmp3f_0cm1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                if (length.isPrime) {\n               \
    \     \"YES\"\n                } else {\n                    \"NO\"\n        \
    \        }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6lyoiws_.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                \e[33mif\e[0m (length.isPrime) {\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                  value isPrime is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010227
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else if\
    \ (start + 1 == end) \"YES\"\n        else if (start + 2 == end) \"NO\"\n    \
    \    else if (start + 3 == end) \"YES\"\n        else if (start + 4 == end) \"\
    NO\"\n        else if (start + 5 == end) \"YES\"\n        else if (start + 6 ==\
    \ end) \"NO\"\n        else if (start + 7 == end) \"YES\"\n        else if (start\
    \ + 8 == end) \"NO\"\n        else if (start + 9 == end) \"NO\"\n        else\
    \ if (start + 10 == end) \"NO\"\n        else if (start + 11 == end) \"YES\"\n\
    \        else if (start + 12 == end) \"NO\"\n        else if (start + 13 == end)\
    \ \"YES\"\n        else if (start + 14 == end) \"NO\"\n        else if (start\
    \ + 15 == end) \"NO\"\n        else if (start + 16 == end) \"NO\"\n        else\
    \ if (start + 17 == end) \"YES\"\n        else if (start + 18 == end) \"NO\"\n\
    \        else if (start + 19 == end) \"YES\"\n        else if (start + 20 == end)\
    \ \"NO\"\n        else if (start + 21 == end) \"NO\"\n        else if (start +\
    \ 22 == end) \"NO\"\n        else if (start + 23 == end) \"YES\"\n        else\
    \ if (start + 24 == end) \"NO\"\n        else if (start + 25 == end) \"NO\"\n\
    \        else if (start + 26 == end) \"NO\"\n        else if (start + 27 == end)\
    \ \"NO\"\n        else if (start + 28 == end) \"NO\"\n        else if (start +\
    \ 29 == end) \"YES\"\n        else if (start + 30 == end) \"NO\"\n        else\
    \ if (start + 31 == end) \"YES\"\n        else if (start + 32 == end) \"NO\"\n\
    \        else if (\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpi85q9t6c.scala:54:17 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (\n\e[31m\e[31m\
    \   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010228
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3L to sqrt(length).toLong by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_31s7a7p.scala:34)\n\tat Problem.main(tmp_31s7a7p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            val length = end - start +\
    \ 1\n            if (length == 1) \"NO\"\n            else if (length == 2) \"\
    YES\"\n            else {\n                val sqrt = sqrt(length).toLong\n  \
    \              val isPrime = (2L to sqrt).forall(length % _ != 0)\n          \
    \      if (isPrime) \"YES\"\n                else \"NO\"\n            }\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpntdmg4tw.scala:28:27 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length < 2) return \"NO\"\n        val sqrt =\
    \ sqrt(length).toLong\n        for (i <- 2L to sqrt) {\n            if (length\
    \ % i == 0) return \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp61npp5o5.scala:26:19 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010228
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   for (i <- 2 to sqrt(length).toInt) {\n            if (length % i == 0) return\
    \ \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcl8pr9s8.scala:31)\n\tat Problem.main(tmpcl8pr9s8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                if (length == 2) {\n                  \
    \  \"YES\"\n                } else {\n                    if (length % 2 == 0)\
    \ {\n                        \"NO\"\n                    } else {\n          \
    \              if (length % 3 == 0) {\n                            \"NO\"\n  \
    \                      } else {\n                            if (length % 5 ==\
    \ 0) {\n                                \"NO\"\n                            }\
    \ else {\n                                if (length % 7 == 0) {\n           \
    \                         \"NO\"\n                                } else {\n \
    \                                   \"YES\"\n                                }\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9gnvpsil.scala:53)\n\tat Problem.main(tmp9gnvpsil.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            val length = end - start +\
    \ 1\n            if (length == 1) \"NO\"\n            else if (length == 2) \"\
    YES\"\n            else if (length % 2 == 0) \"NO\"\n            else {\n    \
    \            val sqrt = sqrt(length).toLong\n                for (i <- 3L to sqrt\
    \ by 2) {\n                    if (length % i == 0) return \"NO\"\n          \
    \      }\n                \"YES\"\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpynfn3_8z.scala:29:27 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010219
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else if\
    \ (start == end - 1) \"YES\"\n        else if (start == end - 2) \"NO\"\n    \
    \    else if (start == end - 3) \"YES\"\n        else if (start == end - 4) \"\
    NO\"\n        else if (start == end - 5) \"YES\"\n        else if (start == end\
    \ - 6) \"NO\"\n        else if (start == end - 7) \"YES\"\n        else if (start\
    \ == end - 8) \"NO\"\n        else if (start == end - 9) \"NO\"\n        else\
    \ \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8cbbi31d.scala:34)\n\tat Problem.main(tmp8cbbi31d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010208
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        var start = max(interval1._1,\
    \ interval2._1)\n        var end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        var length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   for (i <- 2 to sqrt(length).toInt) {\n            if (length % i == 0) return\
    \ \"NO\"\n        }\n        return \"YES\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7gmmll6o.scala:31)\n\tat Problem.main(tmp7gmmll6o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010231
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) \"NO\"\n        else {\n            val start = max(start1, start2)\n\
    \            val end = min(end1, end2)\n            if (start == end) \"YES\"\n\
    \            else if (start == end - 1) \"YES\"\n            else if (start ==\
    \ end - 2) \"NO\"\n            else if (start == end - 3) \"YES\"\n          \
    \  else if (start == end - 4) \"NO\"\n            else if (start == end - 5) \"\
    YES\"\n            else if (start == end - 6) \"NO\"\n            else if (start\
    \ == end - 7) \"YES\"\n            else if (start == end - 8) \"NO\"\n       \
    \     else if (start == end - 9) \"NO\"\n            else if (start == end - 10)\
    \ \"NO\"\n            else if (start == end - 11) \"YES\"\n            else if\
    \ (start == end - 12) \"NO\"\n            else if (start == end - 13) \"YES\"\n\
    \            else if (start == end - 14) \"NO\"\n            else if (start ==\
    \ end - 15) \"NO\"\n            else if (start == end - 16) \"NO\"\n         \
    \   else if (start == end - 17) \"YES\"\n            else if (start == end - 18)\
    \ \"NO\"\n            else if (start == end - 19) \"YES\"\n            else if\
    \ (start == end - 20) \"NO\"\n            else if (start == end - 21) \"NO\"\n\
    \            else if (start == end - 22) \"NO\"\n            else if (start ==\
    \ end - 23) \"YES\"\n            else if (start == end - 24) \"NO\"\n        \
    \    else if (start == end - 25) \"NO\"\n            else if (start == end - 26)\
    \ \"NO\"\n            else if (start == end - 27) \"NO\"\n            else if\
    \ (start == end - 28) \"NO\"\n            else if (start == end - 29) \"YES\"\n\
    \            else if (start == end - 30) \"NO\"\n            else if (start\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb2gw8wpd.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb2gw8wpd.scala:69:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m69 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpb2gw8wpd.scala:55:21 --------------------\e[0m\e[0m\n\
    \e[31m55 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (start\n\e[31m\e[31m\
    \   |\e[0m                     ^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Found:    (start : Long)\n\e[31m   |\e[0m                     Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb2gw8wpd.scala:68:1\
    \ ---------------------\e[0m\e[0m\n\e[31m68 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpb2gw8wpd.scala:57:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m57 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660010224
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq2n1bw6c.scala:33)\n\tat Problem.main(tmpq2n1bw6c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                val primes = ArrayBuffer(2L, 3L, 5L, 7L,\
    \ 11L, 13L, 17L, 19L, 23L, 29L, 31L, 37L, 41L, 43L, 47L, 53L, 59L, 61L, 67L, 71L,\
    \ 73L, 79L, 83L, 89L, 97L, 101L, 103L, 107L, 109L, 113L, 127L, 131L, 137L, 139L,\
    \ 149L, 151L, 157L, 163L, 167L, 173L, 179L, 181L, 191L, 193L, 197L, 199L, 211L,\
    \ 223L, 227L, 229L, 233L, 239L, 241L, 251L, 257L, 263L, 269L, 271L, 277L, 281L,\
    \ 283L, 293L, 307L, 311L, 313L, 317L, 331L, 337L, 347L, 349L, 353L, 359L, 367L,\
    \ 373L, 379L, 383L, 389L, 397L, 401L, 409L, 419L, 421L, 431L, 433L, 439L, 443L,\
    \ 449L, 457L, 461L, 463L, 467L, 479L, 487L, 491L, 499L, 503L, 509L, 521L, 523L,\
    \ 541L, 547L, 557L, 563L, 569L, 571L, 577L, 587L, 593L, 599L, 601L, 607L, 613L,\
    \ 617L, 619L, 631L, 641L, 643L, 647L, 653L, 659L, 661L, 673L, 677L, 683L, 691L,\
    \ 701L, 709L\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8dh99h7f.scala:28:4 ----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8dh99h7f.scala:41:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m41 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp8dh99h7f.scala:40:1 ---------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp8dh99h7f.scala:29:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m29 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else if\
    \ (start == 2) \"YES\"\n        else if (start % 2 == 0) \"NO\"\n        else\
    \ {\n            var isPrime = true\n            for (i <- 3 to sqrt(start).toInt\
    \ by 2) {\n                if (start % i == 0) {\n                    isPrime\
    \ = false\n                    i = sqrt(start).toInt\n                }\n    \
    \        }\n            if (isPrime) \"YES\"\n            else \"NO\"\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmppl07chac.scala:29:22 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    i = sqrt(start).toInt\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                Reassignment to val i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        val sqrt = sqrt(length).toLong\n        for\
    \ (i <- 3L to sqrt by 2) {\n            if (length % i == 0) return \"NO\"\n \
    \       }\n        \"YES\"\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1le5lm0h.scala:27:19 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 2) return \"YES\"\n        for (i <-\
    \ 2 to sqrt(length).toInt) {\n            if (length % i == 0) return \"NO\"\n\
    \        }\n        \"YES\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj_5umpb0.scala:32)\n\tat Problem.main(tmpj_5umpb0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        val sqrt = sqrt(length).toLong\n        for (i <-\
    \ 2L to sqrt) {\n            if (length % i == 0) return \"NO\"\n        }\n \
    \       \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqchi6ll_.scala:25:19 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) \"YES\"\n        else {\n\
    \            val length = end - start + 1\n            if (length == 2) \"YES\"\
    \n            else if (length == 3) \"YES\"\n            else if (length % 2 ==\
    \ 0) \"NO\"\n            else {\n                var i = 3\n                while\
    \ (i * i <= length) {\n                    if (length % i == 0) return \"NO\"\n\
    \                    i += 2\n                }\n                \"YES\"\n    \
    \        }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp374g4vx_.scala:38)\n\tat Problem.main(tmp374g4vx_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010231
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        val start = max(start1, start2)\n\
    \        val end = min(end1, end2)\n        if (start > end) \"NO\"\n        else\
    \ if (start == end) \"YES\"\n        else if (isPrime(end - start + 1)) \"YES\"\
    \n        else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_qfzxhh1.scala:24:17 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        val start = max(start1, start2)\n\
    \        val end = min(end1, end2)\n        if (start > end) {\n            \"\
    NO\"\n        } else {\n            val length = end - start + 1\n           \
    \ if (length == 1) {\n                \"NO\"\n            } else {\n         \
    \       val isPrime = (2L to length - 1).forall(x => length % x != 0)\n      \
    \          if (isPrime) {\n                    \"YES\"\n                } else\
    \ {\n                    \"NO\"\n                }\n            }\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq1ab2rm7.scala:40)\n\tat Problem.main(tmpq1ab2rm7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010232
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3f_0cm1l.scala:34)\n\tat Problem.main(tmp3f_0cm1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) {\n            \"NO\"\n        } else {\n  \
    \          val start = max(interval1._1, interval2._1)\n            val end =\
    \ min(interval1._2, interval2._2)\n            val length = end - start + 1\n\
    \            if (length == 1) {\n                \"NO\"\n            } else {\n\
    \                val sqrt = sqrt(length).toLong\n                val isPrime =\
    \ (2L to sqrt).forall(length % _ != 0)\n                if (isPrime) \"YES\" else\
    \ \"NO\"\n            }\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnd2xts_0.scala:27:27 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        val sqrt = sqrt(length).toLong\n        for\
    \ (i <- 3L to sqrt by 2) {\n            if (length % i == 0) return \"NO\"\n \
    \       }\n        \"YES\"\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpr_kx0cn1.scala:27:19 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   if (length % 2 == 0) return \"NO\"\n        for (i <- 3L to sqrt(length).toLong\
    \ by 2) {\n            if (length % i == 0) return \"NO\"\n        }\n       \
    \ \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6vs_l87v.scala:32)\n\tat Problem.main(tmp6vs_l87v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq2n1bw6c.scala:33)\n\tat Problem.main(tmpq2n1bw6c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (end1 < start2 || end2 < start1)\
    \ return \"NO\"\n        val start = max(start1, start2)\n        val end = min(end1,\
    \ end2)\n        val length = end - start + 1\n        if (length == 1) return\
    \ \"NO\"\n        if (length == 2) return \"YES\"\n        if (length % 2 == 0)\
    \ return \"NO\"\n        for (i <- 3 to sqrt(length).toInt by 2) {\n         \
    \   if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l,\
    \ 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4we0uwn2.scala:34)\n\tat Problem.main(tmp4we0uwn2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010232
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                if (length == 2) {\n                  \
    \  \"YES\"\n                } else {\n                    if (length % 2 == 0)\
    \ {\n                        \"NO\"\n                    } else {\n          \
    \              val sqrt = sqrt(length).toLong\n                        var isPrime\
    \ = true\n                        for (i <- 3L to sqrt by 2) {\n             \
    \               if (length % i == 0) {\n                                isPrime\
    \ = false\n                            }\n                        }\n        \
    \                if (isPrime) {\n                            \"YES\"\n       \
    \                 } else {\n                            \"NO\"\n             \
    \           }\n                    }\n                }\n            }\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgr7t312f.scala:33:35 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                        \e[33mval\e[0m \e[36msqrt\e[0m\
    \ = sqrt(length).toLong\n\e[31m\e[31m   |\e[0m                               \
    \    ^\e[0m\n\e[31m   |\e[0m                                   Recursive \e[33mvalue\e\
    [0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        if (start == end) return \"YES\"\n    \
    \    val length = end - start + 1\n        if (length == 2) return \"YES\"\n \
    \       val sqrt = ceil(sqrt(length)).toLong\n        for (i <- 2L to sqrt) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5i58oxch.scala:24:24 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36msqrt\e[0m = ceil(sqrt(length)).toLong\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        if (isPrime(end - start + 1)) return \"\
    YES\"\n        return \"NO\"\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxf89ib8l.scala:21:12 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (isPrime(end - start + \e[31m1\e\
    [0m)) \e[33mreturn\e[0m \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Not found: isPrime\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010230
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) {\n            \"NO\"\n        } else {\n  \
    \          val start = max(interval1._1, interval2._1)\n            val end =\
    \ min(interval1._2, interval2._2)\n            if (isPrime(end - start + 1)) \"\
    YES\" else \"NO\"\n        }\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_tvfbirh.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (isPrime(end - start + \e[31m1\e\
    [0m)) \e[31m\"YES\"\e[0m \e[33melse\e[0m \e[31m\"NO\"\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: isPrime\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3L to sqrt(length).toLong by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgb2s_rix.scala:33)\n\tat Problem.main(tmpgb2s_rix.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) {\n            \"NO\"\n        } else {\n            val start = max(start1,\
    \ start2)\n            val end = min(end1, end2)\n            val length = end\
    \ - start + 1\n            if (length == 1) {\n                \"NO\"\n      \
    \      } else {\n                if (length == 2) {\n                    \"YES\"\
    \n                } else {\n                    val sqrt = sqrt(length).toLong\n\
    \                    val primes = ArrayBuffer[Long]()\n                    for\
    \ (i <- 2L to sqrt) {\n                        if (length % i == 0) {\n      \
    \                      primes += i\n                        }\n              \
    \      }\n                    if (primes.isEmpty) {\n                        \"\
    YES\"\n                    } else {\n                        \"NO\"\n        \
    \            }\n                }\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbw5zqfc0.scala:32:31 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    \e[33mval\e[0m \e[36msqrt\e[0m =\
    \ sqrt(length).toLong\n\e[31m\e[31m   |\e[0m                               ^\e\
    [0m\n\e[31m   |\e[0m                               Recursive \e[33mvalue\e[0m\
    \ \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010231
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3f_0cm1l.scala:34)\n\tat Problem.main(tmp3f_0cm1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 2) return \"YES\"\n        val sqrt\
    \ = sqrt(length).toLong\n        for (i <- 2L to sqrt) {\n            if (length\
    \ % i == 0) return \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9ergt1qd.scala:26:19 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (isPrime(end - start + 1)) \"YES\"\n \
    \       else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnx_i_bo4.scala:21:17 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010225
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (isPrime(end - start + 1)) \"YES\"\n \
    \       else \"NO\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnx_i_bo4.scala:21:17 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (isPrime(end -\
    \ start + \e[31m1\e[0m)) \e[31m\"YES\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: isPrime\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010225
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        if (interval1._1 > interval2._2\
    \ || interval2._1 > interval1._2) {\n            \"NO\"\n        } else {\n  \
    \          val start = max(interval1._1, interval2._1)\n            val end =\
    \ min(interval1._2, interval2._2)\n            if (isPrime(end - start + 1)) \"\
    YES\" else \"NO\"\n        }\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_tvfbirh.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (isPrime(end - start + \e[31m1\e\
    [0m)) \e[31m\"YES\"\e[0m \e[33melse\e[0m \e[31m\"NO\"\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: isPrime\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   if (length % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt\
    \ by 2) {\n            if (length % i == 0) return \"NO\"\n        }\n       \
    \ \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppve5zual.scala:32)\n\tat Problem.main(tmppve5zual.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        val length = end - start + 1\n        if (length\
    \ == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        for (i <- 3L to sqrt(length).toLong by 2) {\n\
    \            if (length % i == 0) return \"NO\"\n        }\n        \"YES\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_31s7a7p.scala:34)\n\tat Problem.main(tmp_31s7a7p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010204
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        val length = end - start + 1\n        if\
    \ (length == 1) return \"NO\"\n        if (length == 2) return \"YES\"\n     \
    \   if (length % 2 == 0) return \"NO\"\n        for (i <- 3 to sqrt(length).toInt\
    \ by 2) {\n            if (length % i == 0) return \"NO\"\n        }\n       \
    \ \"YES\"\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppve5zual.scala:32)\n\tat Problem.main(tmppve5zual.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) return \"NO\"\n        val start = max(start1, start2)\n        val end\
    \ = min(end1, end2)\n        if (start == end) return \"YES\"\n        val length\
    \ = end - start + 1\n        if (length == 2) return \"YES\"\n        if (length\
    \ % 2 == 0) return \"NO\"\n        val sqrt = sqrt(length).toLong\n        for\
    \ (i <- 3L to sqrt by 2) {\n            if (length % i == 0) return \"NO\"\n \
    \       }\n        \"YES\"\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l,\
    \ 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)),\
    \ ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l,\
    \ 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"NO\")));\n\
    \    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n    assert(intersection(((-2l,\
    \ -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpr_kx0cn1.scala:27:19 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) return \"NO\"\n        if (start == end) return \"YES\"\n    \
    \    val length = end - start + 1\n        if (length == 1) return \"NO\"\n  \
    \      if (length == 2) return \"YES\"\n        if (length % 2 == 0) return \"\
    NO\"\n        for (i <- 3L to sqrt(length).toLong by 2) {\n            if (length\
    \ % i == 0) return \"NO\"\n        }\n        \"YES\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"\
    NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n\
    \    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l,\
    \ 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)),\
    \ ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l,\
    \ 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8un_tbf_.scala:32)\n\tat Problem.main(tmp8un_tbf_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010232
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) \"NO\"\n        else if (start == end) {\n            if (isPrime(start))\
    \ \"YES\"\n            else \"NO\"\n        }\n        else {\n            if\
    \ (isPrime(end - start + 1)) \"YES\"\n            else \"NO\"\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l, 2l)),\
    \ ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"\
    NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"YES\")));\n\
    \    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l,\
    \ 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)),\
    \ ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"\
    NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptr32w9yk.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (isPrime(start)) \e[31m\"YES\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmptr32w9yk.scala:26:16 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m            \e[33mif\e[0m (isPrime(end - start + \e[31m1\e[0m)) \e[31m\"YES\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val start = max(interval1._1,\
    \ interval2._1)\n        val end = min(interval1._2, interval2._2)\n        if\
    \ (start > end) {\n            \"NO\"\n        } else {\n            val length\
    \ = end - start + 1\n            if (length == 1) {\n                \"NO\"\n\
    \            } else {\n                val sqrt = sqrt(length).toLong\n      \
    \          var isPrime = true\n                for (i <- 2L to sqrt) {\n     \
    \               if (length % i == 0) {\n                        isPrime = false\n\
    \                    }\n                }\n                if (isPrime) {\n  \
    \                  \"YES\"\n                } else {\n                    \"NO\"\
    \n                }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intersection(((1l, 2l)), ((2l, 3l))).equals((\"NO\")));\n  \
    \  assert(intersection(((-1l, 1l)), ((0l, 4l))).equals((\"NO\")));\n    assert(intersection(((-3l,\
    \ -1l)), ((-5l, 5l))).equals((\"YES\")));\n    assert(intersection(((-2l, 2l)),\
    \ ((-4l, 0l))).equals((\"YES\")));\n    assert(intersection(((-11l, 2l)), ((-1l,\
    \ -1l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((3l, 5l))).equals((\"\
    NO\")));\n    assert(intersection(((1l, 2l)), ((1l, 2l))).equals((\"NO\")));\n\
    \    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"NO\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpredz1928.scala:27:27 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                \e[33mval\e[0m \e[36msqrt\e[0m = sqrt(length).toLong\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35msqrt\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010231
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) {\n            \"NO\"\n        } else {\n            val start = max(start1,\
    \ start2)\n            val end = min(end1, end2)\n            val length = end\
    \ - start + 1\n            if (length == 1) {\n                \"NO\"\n      \
    \      } else {\n                if (length.isPrime) {\n                    \"\
    YES\"\n                } else {\n                    \"NO\"\n                }\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt9070re0.scala:29:27 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e[0m (length.isPrime) {\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                  value isPrime is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010224
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given two intervals,\n    // where each interval is a pair\
    \ of integers. For example, interval = (start, end) = (1, 2).\n    // The given\
    \ intervals are closed which means that the interval (start, end)\n    // includes\
    \ both start and end.\n    // For each given interval, it is assumed that its\
    \ start is less or equal its end.\n    // Your task is to determine whether the\
    \ length of intersection of these two \n    // intervals is a prime number.\n\
    \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n\
    \    // which its length is 1, which not a prime number.\n    // If the length\
    \ of the intersection is a prime number, return \"YES\",\n    // otherwise, return\
    \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    //\
    \ [input/output] samples:\n    def intersection(interval1 : Tuple2[Long, Long],\
    \ interval2 : Tuple2[Long, Long]) : String = {\n        val (start1, end1) = interval1\n\
    \        val (start2, end2) = interval2\n        if (start1 > end2 || start2 >\
    \ end1) {\n            \"NO\"\n        } else {\n            val start = max(start1,\
    \ start2)\n            val end = min(end1, end2)\n            val length = end\
    \ - start + 1\n            if (length == 1) {\n                \"NO\"\n      \
    \      } else {\n                if (length.isPrime) {\n                    \"\
    YES\"\n                } else {\n                    \"NO\"\n                }\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(intersection(((1l,\
    \ 2l)), ((2l, 3l))).equals((\"NO\")));\n    assert(intersection(((-1l, 1l)), ((0l,\
    \ 4l))).equals((\"NO\")));\n    assert(intersection(((-3l, -1l)), ((-5l, 5l))).equals((\"\
    YES\")));\n    assert(intersection(((-2l, 2l)), ((-4l, 0l))).equals((\"YES\")));\n\
    \    assert(intersection(((-11l, 2l)), ((-1l, -1l))).equals((\"NO\")));\n    assert(intersection(((1l,\
    \ 2l)), ((3l, 5l))).equals((\"NO\")));\n    assert(intersection(((1l, 2l)), ((1l,\
    \ 2l))).equals((\"NO\")));\n    assert(intersection(((-2l, -2l)), ((-3l, -2l))).equals((\"\
    NO\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt9070re0.scala:29:27 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e[0m (length.isPrime) {\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                  value isPrime is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010224
