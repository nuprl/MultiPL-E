name: HumanEval_10_make_palindrome
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Find the shortest palindrome that begins with a supplied string.\n    //\
  \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
  \ that is a palindrome.\n    // - Append to the end of the string reverse of a string\
  \ prefix that comes before the palindromic suffix.\n    def makePalindrome(string\
  \ : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
  \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
  \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
  xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\"\
  )));\n    }\n\n}\n"
completions: ["        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n\
    \        suffix(0) = 0\n        for (i <- 1 until n) {\n            var j = suffix(i\
    \ - 1)\n            while (j > 0 && string(i) != string(j)) j = suffix(j - 1)\n\
    \            if (string(i) == string(j)) suffix(i) = j + 1\n            else suffix(i)\
    \ = 0\n        }\n        val prefix = string.substring(0, n - suffix(n - 1))\n\
    \        prefix.reverse + string", "        val s = string + \"*\" + string.reverse\n\
    \        val n = s.length\n        val p = Array.fill(n)(0)\n        for (i <-\
    \ 1 until n) {\n            var j = p(i - 1)\n            while (j > 0 && s(i)\
    \ != s(j)) j = p(j - 1)\n            if (s(i) == s(j)) j += 1\n            p(i)\
    \ = j\n        }\n        string.substring(p(n - 1)) + string", "        val n\
    \ = string.length\n        val suffix = Array.ofDim[Int](n)\n        var i = 0\n\
    \        var j = 1\n        while (j < n) {\n            if (string(i) == string(j))\
    \ {\n                suffix(j) = i + 1\n                i += 1\n             \
    \   j += 1\n            } else {\n                if (i == 0) {\n            \
    \        suffix(j) = 0\n                    j += 1\n                } else {\n\
    \                    i = suffix(i - 1)\n                }\n            }\n   \
    \     }\n        val prefix = string.substring(0, n - suffix(n - 1))\n       \
    \ string + prefix.reverse", "        val s = string + \"#\" + string.reverse\n\
    \        val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string", "        val prefix = string.substring(0,\
    \ string.length - longestPalindromeSuffix(string).length)\n        string + prefix.reverse",
  "        val reversed = string.reverse\n        val s = string + \"#\" + reversed\n\
    \        val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      reversed.substring(0, string.length - lps.last) + string", "        val\
    \ n = string.length\n        val suffix = Array.ofDim[Int](n + 1)\n        val\
    \ prefix = Array.ofDim[Int](n + 1)\n        for (i <- 0 to n) {\n            suffix(i)\
    \ = 0\n            prefix(i) = 0\n        }\n        for (i <- 1 to n) {\n   \
    \         var j = suffix(i - 1)\n            while (j > 0 && string(i - 1) !=\
    \ string(j - 1)) j = suffix(j - 1)\n            if (string(i - 1) == string(j\
    \ - 1)) suffix(i) = j + 1\n            else suffix(i) = 0\n        }\n       \
    \ for (i <- n - 1 to 0 by -1) {\n            var j = prefix(i + 1)\n         \
    \   while (j > 0 && string(i) != string(n - j)) j = prefix(j)\n            if\
    \ (string(i) == string(n - j)) prefix(i) = j + 1\n            else prefix(i) =\
    \ 0\n        }\n        var result = string\n        for (i <- 0 to n) {\n   \
    \         if (suffix(i) == i) {\n                val prefixLength = n - i\n  \
    \              result = string.substring(0, prefixLength) + result\n         \
    \   }\n        }\n        result", "        val n = string.length\n        val\
    \ suffix = Array.ofDim[Int](n)\n        val reverse = string.reverse\n       \
    \ for (i <- 0 until n) {\n            var j = 0\n            while (i + j < n\
    \ && j < n && string(i + j) == reverse(j)) j += 1\n            suffix(i) = j\n\
    \        }\n        val prefix = string.substring(0, n - suffix(n - 1))\n    \
    \    prefix + reverse", "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n\
    \        var i = 0\n        var j = 1\n        while (j < n) {\n            if\
    \ (string(i) == string(j)) {\n                suffix(j) = i + 1\n            \
    \    i += 1\n                j += 1\n            } else {\n                if\
    \ (i == 0) {\n                    suffix(j) = 0\n                    j += 1\n\
    \                } else {\n                    i = suffix(i - 1)\n           \
    \     }\n            }\n        }\n        val prefix = string.substring(0, n\
    \ - suffix(n - 1))\n        prefix.reverse + string", "        val n = string.length\n\
    \        val dp = Array.ofDim[Int](n, n)\n        for (i <- 0 until n) dp(i)(i)\
    \ = 1\n        for (i <- 0 until n - 1) dp(i)(i + 1) = if (string(i) == string(i\
    \ + 1)) 2 else 1\n        for (k <- 3 to n) {\n            for (i <- 0 to n -\
    \ k) {\n                val j = i + k - 1\n                dp(i)(j) = if (string(i)\
    \ == string(j)) dp(i + 1)(j - 1) + 2 else max(dp(i + 1)(j), dp(i)(j - 1))\n  \
    \          }\n        }\n        val prefix = string.substring(0, n - dp(0)(n\
    \ - 1))\n        prefix.reverse + string", "        val s = string + \"#\" + string.reverse\n\
    \        val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string", "        val reversed =\
    \ string.reverse\n        val suffix = string.zip(reversed).takeWhile(x => x._1\
    \ == x._2).map(_._1).mkString\n        val prefix = string.substring(0, string.length\
    \ - suffix.length)\n        val result = prefix.reverse + string\n        result",
  "        val n = string.length\n        val s = string + \"#\" + string.reverse\n\
    \        val z = Array.fill(s.length)(0)\n        var l = 0; var r = 0\n     \
    \   for (i <- 1 until s.length) {\n            if (i <= r) z(i) = min(z(i - l),\
    \ r - i + 1)\n            while (i + z(i) < s.length && s(z(i)) == s(i + z(i)))\
    \ z(i) += 1\n            if (i + z(i) - 1 > r) {\n                l = i; r = i\
    \ + z(i) - 1\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - z(s.length - 1))\n        string + prefix.reverse", "        var s = string\n\
    \        var l = s.length\n        var i = 0\n        var j = l - 1\n        while\
    \ (i < j) {\n            if (s(i) != s(j)) {\n                s = s.substring(0,\
    \ j) + s.substring(i)\n                l = s.length\n                i = 0\n \
    \               j = l - 1\n            } else {\n                i += 1\n    \
    \            j -= 1\n            }\n        }\n        s + s.reverse.substring(l\
    \ - i)", "        val reversed = string.reverse\n        val s = string + \"#\"\
    \ + reversed\n        val lps = Array.fill(s.length)(0)\n        for (i <- 1 until\
    \ s.length) {\n            var j = lps(i - 1)\n            while (j > 0 && s(i)\
    \ != s(j)) j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n    \
    \    }\n        val prefix = string.substring(0, string.length - lps.last)\n \
    \       prefix.reverse + string", "        val s = string + \"#\" + string.reverse\n\
    \        val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string", "        val n = string.length\n\
    \        val suffix = Array.ofDim[Int](n)\n        suffix(0) = 0\n        var\
    \ i = 1\n        var j = 0\n        while (i < n) {\n            if (string(i)\
    \ == string(j)) {\n                suffix(i) = j + 1\n                i += 1\n\
    \                j += 1\n            } else {\n                if (j == 0) {\n\
    \                    suffix(i) = 0\n                    i += 1\n             \
    \   } else {\n                    j = suffix(j - 1)\n                }\n     \
    \       }\n        }\n        val prefix = string.substring(0, n - suffix(n -\
    \ 1))\n        prefix.reverse + string", "        val s = string + \"#\" + string.reverse\n\
    \        val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      val prefix = string.substring(0, string.length - lps.last)\n        prefix.reverse\
    \ + string", "        val n = string.length\n        val prefix = string.substring(0,\
    \ n - 1)\n        val suffix = string.substring(n - 1, n)\n        val reversedPrefix\
    \ = prefix.reverse\n        suffix + reversedPrefix", "        val n = string.length\n\
    \        val s = string + \"#\" + string.reverse\n        val z = Array.fill(s.length)(0)\n\
    \        var l = 0; var r = 0\n        for (i <- 1 until s.length) {\n       \
    \     if (i > r) {\n                l = i; r = i\n                while (r < s.length\
    \ && s(r - l) == s(r)) r += 1\n                z(i) = r - l; r -= 1\n        \
    \    } else {\n                val k = i - l\n                if (z(k) < r - i\
    \ + 1) z(i) = z(k)\n                else {\n                    l = i\n      \
    \              while (r < s.length && s(r - l) == s(r)) r += 1\n             \
    \       z(i) = r - l; r -= 1\n                }\n            }\n        }\n  \
    \      val longestPalindrome = z(n + 1)\n        string.substring(longestPalindrome)\
    \ + string", "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n\
    \        var i = 0\n        var j = 1\n        while (j < n) {\n            if\
    \ (string(i) == string(j)) {\n                suffix(j) = i + 1\n            \
    \    i += 1\n                j += 1\n            } else {\n                if\
    \ (i == 0) {\n                    suffix(j) = 0\n                    j += 1\n\
    \                } else {\n                    i = suffix(i - 1)\n           \
    \     }\n            }\n        }\n        val prefix = string.substring(0, n\
    \ - suffix(n - 1))\n        string + prefix.reverse", "        val n = string.length\n\
    \        val s = string + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n\
    \        for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n     \
    \       while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) ==\
    \ s(j)) lps(i) = j + 1\n        }\n        string + string.substring(n - lps(s.length\
    \ - 1)).reverse", "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n\
    \        suffix(0) = 0\n        var i = 1\n        var j = 0\n        while (i\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(i)\
    \ = j + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (j == 0) {\n                    suffix(i) = 0\n      \
    \              i += 1\n                } else {\n                    j = suffix(j\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse", "        val n = string.length\n\
    \        val reverse = string.reverse\n        val lps = Array.ofDim[Int](n)\n\
    \        var len = 0\n        for (i <- 1 until n) {\n            if (string(i)\
    \ == string(len)) {\n                len += 1\n                lps(i) = len\n\
    \            } else {\n                if (len != 0) {\n                    len\
    \ = lps(len - 1)\n                    i -= 1\n                }\n            }\n\
    \        }\n        string + reverse.substring(n - lps(n - 1))", "        val\
    \ n = string.length\n        val suffix = Array.ofDim[Int](n)\n        for (i\
    \ <- 0 until n) {\n            var j = 0\n            while (i - j >= 0 && i +\
    \ j < n && string(i - j) == string(i + j)) j += 1\n            suffix(i) = j\n\
    \        }\n        var max = 0\n        var maxIndex = 0\n        for (i <- 0\
    \ until n) {\n            if (suffix(i) > max) {\n                max = suffix(i)\n\
    \                maxIndex = i\n            }\n        }\n        val prefix =\
    \ string.substring(0, maxIndex - max + 1)\n        string + prefix.reverse", " \
    \       val n = string.length\n        val dp = Array.ofDim[Int](n + 1, n + 1)\n\
    \        for (i <- 0 to n) dp(i)(0) = 0\n        for (j <- 0 to n) dp(0)(j) =\
    \ 0\n        for (i <- 1 to n; j <- 1 to n) {\n            if (string(i - 1) ==\
    \ string(n - j)) dp(i)(j) = dp(i - 1)(j - 1) + 1\n            else dp(i)(j) =\
    \ max(dp(i - 1)(j), dp(i)(j - 1))\n        }\n        val prefix = string.substring(0,\
    \ n - dp(n)(n))\n        prefix.reverse + string", "        val n = string.length\n\
    \        val suffix = Array.ofDim[Int](n)\n        suffix(0) = 0\n        for\
    \ (i <- 1 until n) {\n            var j = suffix(i - 1)\n            while (j\
    \ > 0 && string(i) != string(j)) j = suffix(j - 1)\n            if (string(i)\
    \ == string(j)) j += 1\n            suffix(i) = j\n        }\n        val prefix\
    \ = string.substring(0, n - suffix(n - 1))\n        string + prefix.reverse",
  "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n     \
    \   var i = 0\n        var j = 1\n        while (j < n) {\n            if (string(i)\
    \ == string(j)) {\n                suffix(j) = i + 1\n                i += 1\n\
    \                j += 1\n            } else {\n                if (i == 0) {\n\
    \                    suffix(j) = 0\n                    j += 1\n             \
    \   } else {\n                    i = suffix(i - 1)\n                }\n     \
    \       }\n        }\n        val prefix = string.substring(0, n - suffix(n -\
    \ 1))\n        string + prefix.reverse", "        val n = string.length\n    \
    \    val suffix = Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i =\
    \ 1\n        var j = 0\n        while (i < n) {\n            if (string(i) ==\
    \ string(j)) {\n                suffix(i) = j + 1\n                i += 1\n  \
    \              j += 1\n            } else {\n                if (j == 0) {\n \
    \                   suffix(i) = 0\n                    i += 1\n              \
    \  } else {\n                    j = suffix(j - 1)\n                }\n      \
    \      }\n        }\n        val prefix = string.substring(0, n - suffix(n - 1))\n\
    \        string + prefix.reverse", "        val n = string.length\n        val\
    \ suffix = Array.ofDim[Int](n)\n        val reverse = string.reverse\n       \
    \ for (i <- 0 until n) {\n            var j = 0\n            while (i + j < n\
    \ && string(j) == reverse(i + j)) j += 1\n            suffix(i) = j\n        }\n\
    \        var prefix = n - suffix(n - 1)\n        if (prefix == n) prefix = 0\n\
    \        string.substring(prefix) + reverse.substring(0, n - prefix)", "     \
    \   val n = string.length\n        val suffix = Array.ofDim[Int](n)\n        var\
    \ i = 0\n        var j = 1\n        while (j < n) {\n            if (string(i)\
    \ == string(j)) {\n                suffix(j) = i + 1\n                i += 1\n\
    \                j += 1\n            } else {\n                if (i == 0) {\n\
    \                    suffix(j) = 0\n                    j += 1\n             \
    \   } else {\n                    i = suffix(i - 1)\n                }\n     \
    \       }\n        }\n        val prefix = string.substring(0, n - suffix(n -\
    \ 1))\n        string + prefix.reverse", "        val s = string + \"#\" + string.reverse\n\
    \        val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string", "        val n = string.length\n\
    \        val suffix = new Array[Int](n)\n        suffix(0) = 0\n        var i\
    \ = 1\n        var j = 0\n        while (i < n) {\n            if (string(i) ==\
    \ string(j)) {\n                suffix(i) = j + 1\n                i += 1\n  \
    \              j += 1\n            } else {\n                if (j == 0) {\n \
    \                   suffix(i) = 0\n                    i += 1\n              \
    \  } else {\n                    j = suffix(j - 1)\n                }\n      \
    \      }\n        }\n        val prefix = string.substring(0, n - suffix(n - 1))\n\
    \        prefix.reverse + string", "        val s = string + \"#\" + string.reverse\n\
    \        val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string", "        val suffix = string.substring(string.length\
    \ / 2)\n        val prefix = string.substring(0, string.length / 2)\n        val\
    \ palindromeSuffix = findPalindromeSuffix(suffix)\n        val prefixToAppend\
    \ = prefix.substring(0, prefix.length - palindromeSuffix.length)\n        return\
    \ prefixToAppend + string + prefixToAppend.reverse", "        val n = string.length\n\
    \        val suffix = Array.ofDim[Int](n)\n        var i = 0\n        var j =\
    \ 1\n        while (j < n) {\n            if (string(i) == string(j)) {\n    \
    \            suffix(j) = i + 1\n                i += 1\n                j += 1\n\
    \            } else {\n                if (i == 0) {\n                    suffix(j)\
    \ = 0\n                    j += 1\n                } else {\n                \
    \    i = suffix(i - 1)\n                }\n            }\n        }\n        val\
    \ prefix = string.substring(0, n - suffix(n - 1))\n        val suffixString =\
    \ string.substring(n - suffix(n - 1))\n        val reversePrefix = prefix.reverse\n\
    \        suffixString + reversePrefix", "        val reversed = string.reverse\n\
    \        val s = string + \"#\" + reversed\n        val lps = Array.fill(s.length)(0)\n\
    \        for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n     \
    \       while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) ==\
    \ s(j)) j += 1\n            lps(i) = j\n        }\n        val prefix = string.substring(lps.last)\n\
    \        prefix.reverse + string", "        var suffix = string\n        var prefix\
    \ = \"\"\n        while (suffix.length > 0) {\n            if (suffix.isPalindrome)\
    \ {\n                return prefix + string\n            }\n            prefix\
    \ = suffix.head + prefix\n            suffix = suffix.tail\n        }\n      \
    \  return prefix + string", "        val n = string.length\n        val suffix\
    \ = Array.ofDim[Int](n)\n        var i = 1\n        var j = 0\n        while (i\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(i)\
    \ = j + 1\n                i += 1\n                j += 1\n            } else\
    \ if (j > 0) {\n                j = suffix(j - 1)\n            } else {\n    \
    \            suffix(i) = 0\n                i += 1\n            }\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        prefix.reverse\
    \ + string", "        val palindromeSuffix = findPalindromeSuffix(string)\n  \
    \      val prefix = string.substring(0, string.length - palindromeSuffix.length)\n\
    \        prefix.reverse + string", "        val s = string + \"#\" + string.reverse\n\
    \        val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string", "        val n = string.length\n\
    \        val suffix = Array.ofDim[Int](n)\n        suffix(0) = 0\n        for\
    \ (i <- 1 until n) {\n            var j = suffix(i - 1)\n            while (j\
    \ > 0 && string(i) != string(j)) j = suffix(j - 1)\n            if (string(i)\
    \ == string(j)) suffix(i) = j + 1\n            else suffix(i) = 0\n        }\n\
    \        val prefix = string.substring(0, n - suffix(n - 1))\n        string +\
    \ prefix.reverse", "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n\
    \        var i = 0\n        var j = 1\n        while (j < n) {\n            if\
    \ (string(i) == string(j)) {\n                suffix(j) = i + 1\n            \
    \    i += 1\n                j += 1\n            } else {\n                if\
    \ (i == 0) {\n                    suffix(j) = 0\n                    j += 1\n\
    \                } else {\n                    i = suffix(i - 1)\n           \
    \     }\n            }\n        }\n        val prefix = string.substring(0, n\
    \ - suffix(n - 1))\n        string + prefix.reverse", "        def isPalindrome(string\
    \ : String) : Boolean = {\n            val length = string.length\n          \
    \  for (i <- 0 until length / 2) {\n                if (string(i) != string(length\
    \ - 1 - i)) return false\n            }\n            return true\n        }\n\
    \        val length = string.length\n        for (i <- length to 0 by -1) {\n\
    \            if (isPalindrome(string.substring(length - i))) {\n             \
    \   return string + string.substring(0, length - i).reverse\n            }\n \
    \       }\n        return string + string.reverse", "        val n = string.length\n\
    \        val m = Array.ofDim[Int](n, n)\n        for (i <- 0 until n) {\n    \
    \        m(i)(i) = 1\n            if (i + 1 < n) {\n                m(i)(i + 1)\
    \ = if (string(i) == string(i + 1)) 2 else 0\n            }\n        }\n     \
    \   for (k <- 3 to n) {\n            for (i <- 0 until n - k + 1) {\n        \
    \        val j = i + k - 1\n                m(i)(j) = if (string(i) == string(j)\
    \ && m(i + 1)(j - 1) > 0) m(i + 1)(j - 1) + 2 else 0\n            }\n        }\n\
    \        var max = 0\n        var maxIndex = 0\n        for (i <- 0 until n) {\n\
    \            if (m(0)(i) > max) {\n                max = m(0)(i)\n           \
    \     maxIndex = i\n            }\n        }\n        val prefix = string.substring(0,\
    \ maxIndex + 1)\n        val suffix = string.substring(maxIndex + 1)\n       \
    \ prefix + suffix.reverse", "        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val z = Array.fill(s.length)(0)\n        var\
    \ l = 0; var r = 0\n        for (i <- 1 until s.length) {\n            if (i >\
    \ r) {\n                l = i; r = i\n                while (r < s.length && s(r\
    \ - l) == s(r)) r += 1\n                z(i) = r - l; r -= 1\n            } else\
    \ {\n                val k = i - l\n                if (z(k) < r - i + 1) z(i)\
    \ = z(k)\n                else {\n                    l = i\n                \
    \    while (r < s.length && s(r - l) == s(r)) r += 1\n                    z(i)\
    \ = r - l; r -= 1\n                }\n            }\n        }\n        val longestPalindromeSuffix\
    \ = z(s.length - 1)\n        string + string.substring(longestPalindromeSuffix,\
    \ n).reverse", "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n\
    \        var i = 0\n        var j = 1\n        while (j < n) {\n            if\
    \ (string(i) == string(j)) {\n                suffix(j) = i + 1\n            \
    \    i += 1\n                j += 1\n            } else {\n                if\
    \ (i == 0) {\n                    suffix(j) = 0\n                    j += 1\n\
    \                } else {\n                    i = suffix(i - 1)\n           \
    \     }\n            }\n        }\n        val prefix = string.substring(0, n\
    \ - suffix(n - 1))\n        prefix.reverse + string", "        val reversed =\
    \ string.reverse\n        val longestPalindrome = (0 to string.length).map(i =>\
    \ string.substring(i) + reversed.substring(0, string.length - i)).maxBy(s => s.length\
    \ - s.reverse.indexOf(s))\n        longestPalindrome + reversed.substring(longestPalindrome.length)",
  "        val n = string.length\n        val s = string + \"#\" + string.reverse\n\
    \        val z = Array.fill(s.length)(0)\n        var l = 0; var r = 0\n     \
    \   for (i <- 1 until s.length) {\n            if (i > r) {\n                l\
    \ = i; r = i\n                while (r < s.length && s(r - l) == s(r)) r += 1\n\
    \                z(i) = r - l; r -= 1\n            } else {\n                val\
    \ k = i - l\n                if (z(k) < r - i + 1) z(i) = z(k)\n             \
    \   else {\n                    l = i\n                    while (r < s.length\
    \ && s(r - l) == s(r)) r += 1\n                    z(i) = r - l; r -= 1\n    \
    \            }\n            }\n        }\n        val longestPalindrome = z.max\n\
    \        string.substring(longestPalindrome) + string", "        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  var i = 1\n        while (i < s.length) {\n            if (s(i) == s(lps(i\
    \ - 1))) lps(i) = lps(i - 1) + 1\n            else {\n                var j =\
    \ lps(i - 1)\n                while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n \
    \               if (s(i) == s(j)) lps(i) = j + 1\n            }\n            i\
    \ += 1\n        }\n        string.substring(lps(s.length - 1)) + string", "  \
    \      val s = string + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n\
    \        var i = 1\n        while (i < s.length) {\n            if (s(i) == s(lps(i\
    \ - 1))) lps(i) = lps(i - 1) + 1\n            else {\n                var j =\
    \ lps(i - 1)\n                while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n \
    \               if (s(i) == s(j)) lps(i) = j + 1\n            }\n            i\
    \ += 1\n        }\n        string.substring(lps(s.length - 1)) + string", "  \
    \      val suffix = string.substring(string.length / 2)\n        val prefix =\
    \ string.substring(0, string.length / 2)\n        val palindromeSuffix = findPalindromeSuffix(suffix)\n\
    \        val palindromePrefix = prefix.substring(0, prefix.length - palindromeSuffix.length)\n\
    \        palindromePrefix + suffix + palindromePrefix.reverse", "        val reversed\
    \ = string.reverse\n        val length = string.length\n        val palindromeSuffix\
    \ = (0 until length).find(i => string.substring(i) == reversed.substring(0, length\
    \ - i)).get\n        val prefix = string.substring(0, length - palindromeSuffix)\n\
    \        string + prefix.reverse", "        def isPalindrome(string : String)\
    \ : Boolean = {\n            for (i <- 0 until string.length / 2) {\n        \
    \        if (string(i) != string(string.length - 1 - i)) return false\n      \
    \      }\n            return true\n        }\n        var longestPalindrome =\
    \ \"\"\n        for (i <- 0 until string.length) {\n            val substring\
    \ = string.substring(i)\n            if (isPalindrome(substring) && substring.length\
    \ > longestPalindrome.length) longestPalindrome = substring\n        }\n     \
    \   return string + string.substring(0, string.length - longestPalindrome.length).reverse",
  "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n     \
    \   suffix(0) = 0\n        for (i <- 1 until n) {\n            var j = suffix(i\
    \ - 1)\n            while (j > 0 && string(i) != string(j)) j = suffix(j - 1)\n\
    \            if (string(i) == string(j)) j += 1\n            suffix(i) = j\n \
    \       }\n        val prefix = string.substring(0, n - suffix(n - 1))\n     \
    \   prefix.reverse + string", "        val suffix = string.reverse.takeWhile(c\
    \ => string.startsWith(c.toString))\n        string + suffix.reverse", "     \
    \   val n = string.length\n        val dp = Array.ofDim[Int](n, n)\n        for\
    \ (i <- 0 until n) dp(i)(i) = 1\n        for (i <- 0 until n - 1) dp(i)(i + 1)\
    \ = if (string(i) == string(i + 1)) 2 else 1\n        for (k <- 3 to n) {\n  \
    \          for (i <- 0 to n - k) {\n                dp(i)(i + k - 1) = if (string(i)\
    \ == string(i + k - 1)) dp(i + 1)(i + k - 2) + 2 else max(dp(i + 1)(i + k - 1),\
    \ dp(i)(i + k - 2))\n            }\n        }\n        val palindromeLength =\
    \ dp(0)(n - 1)\n        val prefix = string.substring(0, n - palindromeLength)\n\
    \        val suffix = string.substring(n - palindromeLength, n)\n        prefix.reverse\
    \ + string", "        val n = string.length\n        val dp = Array.ofDim[Int](n,\
    \ n)\n        for (i <- 0 until n) dp(i)(i) = 1\n        for (i <- 0 until n -\
    \ 1) dp(i)(i + 1) = if (string(i) == string(i + 1)) 2 else 1\n        for (k <-\
    \ 3 to n) {\n            for (i <- 0 to n - k) {\n                val j = i +\
    \ k - 1\n                dp(i)(j) = if (string(i) == string(j)) dp(i + 1)(j -\
    \ 1) + 2 else max(dp(i + 1)(j), dp(i)(j - 1))\n            }\n        }\n    \
    \    val longestPalindrome = dp(0)(n - 1)\n        val prefix = string.substring(0,\
    \ n - longestPalindrome)\n        string + prefix.reverse", "        val suffix\
    \ = string.substring(string.length / 2)\n        val prefix = string.substring(0,\
    \ string.length / 2)\n        val palindromeSuffix = longestPalindromeSuffix(suffix)\n\
    \        val prefixToAppend = prefix.substring(0, prefix.length - palindromeSuffix.length)\n\
    \        prefixToAppend + suffix + prefixToAppend.reverse", "        val n = string.length\n\
    \        val suffix = Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n  \
    \          var j = 0\n            while (i - j >= 0 && i + j < n && string(i -\
    \ j) == string(i + j)) j += 1\n            suffix(i) = j\n        }\n        var\
    \ max = 0\n        var maxIndex = 0\n        for (i <- 0 until n) {\n        \
    \    if (suffix(i) > max) {\n                max = suffix(i)\n               \
    \ maxIndex = i\n            }\n        }\n        string.substring(maxIndex +\
    \ 1, n) + string", "        val n = string.length\n        val s = string + \"\
    #\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n        for (i\
    \ <- 1 until s.length) {\n            var j = lps(i - 1)\n            while (j\
    \ > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) =\
    \ j + 1\n        }\n        string + string.reverse.substring(lps(s.length - 1))",
  "        val n = string.length\n        val dp = Array.ofDim[Int](n, n)\n      \
    \  for (i <- 0 until n) {\n            dp(i)(i) = 1\n            if (i < n - 1)\
    \ {\n                if (string(i) == string(i + 1)) dp(i)(i + 1) = 2\n      \
    \          else dp(i)(i + 1) = 1\n            }\n        }\n        for (k <-\
    \ 3 to n) {\n            for (i <- 0 to n - k) {\n                val j = i +\
    \ k - 1\n                if (string(i) == string(j)) dp(i)(j) = dp(i + 1)(j -\
    \ 1) + 2\n                else dp(i)(j) = max(dp(i + 1)(j), dp(i)(j - 1))\n  \
    \          }\n        }\n        val longestPalindrome = dp(0)(n - 1)\n      \
    \  val prefix = string.substring(0, n - longestPalindrome)\n        val reversePrefix\
    \ = prefix.reverse\n        string + reversePrefix", "        val n = string.length\n\
    \        val suffix = Array.ofDim[Int](n)\n        var i = 0\n        var j =\
    \ 1\n        while (j < n) {\n            if (string(i) == string(j)) {\n    \
    \            suffix(j) = i + 1\n                i += 1\n                j += 1\n\
    \            } else {\n                if (i == 0) {\n                    suffix(j)\
    \ = 0\n                    j += 1\n                } else {\n                \
    \    i = suffix(i - 1)\n                }\n            }\n        }\n        val\
    \ prefix = string.substring(0, n - suffix(n - 1))\n        prefix.reverse + string",
  "        val palindromeSuffix = string.substring(0, string.length - longestPalindromeSuffix(string))\n\
    \        string + palindromeSuffix.reverse", "        val n = string.length\n\
    \        val dp = Array.ofDim[Int](n, n)\n        for (i <- 0 until n) {\n   \
    \         dp(i)(i) = 1\n            if (i + 1 < n) {\n                dp(i)(i\
    \ + 1) = if (string(i) == string(i + 1)) 2 else 1\n            }\n        }\n\
    \        for (k <- 3 to n) {\n            for (i <- 0 to n - k) {\n          \
    \      val j = i + k - 1\n                dp(i)(j) = if (string(i) == string(j))\
    \ dp(i + 1)(j - 1) + 2 else max(dp(i + 1)(j), dp(i)(j - 1))\n            }\n \
    \       }\n        val longestPalindrome = dp(0)(n - 1)\n        val prefix =\
    \ string.substring(0, n - longestPalindrome)\n        val suffix = string.substring(n\
    \ - longestPalindrome)\n        prefix.reverse + string", "        val n = string.length\n\
    \        val suffix = Array.ofDim[Int](n)\n        val reverse = string.reverse\n\
    \        for (i <- 0 until n) {\n            suffix(i) = if (string.substring(i)\
    \ == reverse.substring(0, n - i)) n - i else 0\n        }\n        string + reverse.substring(suffix(n\
    \ - 1))", "        val n = string.length\n        val suffix = new Array[Int](n)\n\
    \        var i = 0\n        var j = 1\n        while (j < n) {\n            if\
    \ (string(i) == string(j)) {\n                suffix(j) = i + 1\n            \
    \    i += 1\n                j += 1\n            } else {\n                if\
    \ (i == 0) {\n                    suffix(j) = 0\n                    j += 1\n\
    \                } else {\n                    i = suffix(i - 1)\n           \
    \     }\n            }\n        }\n        val prefix = string.substring(0, n\
    \ - suffix(n - 1))\n        prefix.reverse + string", "        val s = string\
    \ + \"#\" + string.reverse\n        val n = s.length\n        val pi = Array.fill(n)(0)\n\
    \        for (i <- 1 until n) {\n            var j = pi(i - 1)\n            while\
    \ (j > 0 && s(i) != s(j)) j = pi(j - 1)\n            if (s(i) == s(j)) pi(i) =\
    \ j + 1\n        }\n        string.substring(pi(n - 1)) + string", "        val\
    \ suffix = string.substring(string.length / 2)\n        val prefix = string.substring(0,\
    \ string.length / 2)\n        val reversedPrefix = prefix.reverse\n        val\
    \ palindromeSuffix = suffix.substring(0, suffix.length - suffix.reverse.indexOf(suffix))\n\
    \        val palindrome = palindromeSuffix + reversedPrefix\n        palindrome",
  "        val n = string.length\n        val s = string + \"#\" + string.reverse\n\
    \        val p = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = p(i - 1)\n            while (j > 0 && s(i) != s(j)) j\
    \ = p(j - 1)\n            if (s(i) == s(j)) j += 1\n            p(i) = j\n   \
    \     }\n        string.substring(p(s.length - 1)) + string", "        val reversed\
    \ = string.reverse\n        val s = string + \"#\" + reversed\n        val lps\
    \ = Array.fill(s.length)(0)\n        var i = 1\n        var len = 0\n        while\
    \ (i < s.length) {\n            if (s(i) == s(len)) {\n                len +=\
    \ 1\n                lps(i) = len\n                i += 1\n            } else\
    \ {\n                if (len != 0) {\n                    len = lps(len - 1)\n\
    \                } else {\n                    lps(i) = 0\n                  \
    \  i += 1\n                }\n            }\n        }\n        string + reversed.substring(lps(s.length\
    \ - 1))", "        val n = string.length\n        val s = string + \"#\" + string.reverse\n\
    \        val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string + string.substring(lps(s.length - 1)).reverse", "        val suffix\
    \ = longestPalindromicSuffix(string)\n        val prefix = string.substring(0,\
    \ string.length - suffix.length)\n        val reversePrefix = prefix.reverse\n\
    \        reversePrefix + string", "        val n = string.length\n        val\
    \ s = string + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n\
    \        for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n     \
    \       while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) ==\
    \ s(j)) lps(i) = j + 1\n        }\n        string + string.substring(lps(s.length\
    \ - 1)).reverse", "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n\
    \        var i = 0\n        var j = 1\n        while (j < n) {\n            if\
    \ (string(i) == string(j)) {\n                suffix(j) = i + 1\n            \
    \    i += 1\n                j += 1\n            } else {\n                if\
    \ (i == 0) {\n                    suffix(j) = 0\n                    j += 1\n\
    \                } else {\n                    i = suffix(i - 1)\n           \
    \     }\n            }\n        }\n        val prefix = string.substring(0, n\
    \ - suffix(n - 1))\n        string + prefix.reverse", "        val n = string.length\n\
    \        val suffix = Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n  \
    \          var j = i\n            while (j >= 0 && string(j) == string(n - 1 -\
    \ i + j)) j -= 1\n            suffix(i) = i - j\n        }\n        var i = 0\n\
    \        while (i < n && suffix(i) < i + 1) i += 1\n        val prefix = string.substring(0,\
    \ i)\n        prefix + prefix.reverse", "        val n = string.length\n     \
    \   val s = string + \"#\" + string.reverse\n        val z = Array.fill(s.length)(0)\n\
    \        var l = 0; var r = 0\n        for (i <- 1 until s.length) {\n       \
    \     if (i > r) {\n                l = i; r = i\n                while (r < s.length\
    \ && s(r - l) == s(r)) r += 1\n                z(i) = r - l; r -= 1\n        \
    \    } else {\n                val k = i - l\n                if (z(k) < r - i\
    \ + 1) z(i) = z(k)\n                else {\n                    l = i\n      \
    \              while (r < s.length && s(r - l) == s(r)) r += 1\n             \
    \       z(i) = r - l; r -= 1\n                }\n            }\n        }\n  \
    \      val longestPalindromeSuffix = z(s.length - 1)\n        string + string.substring(longestPalindromeSuffix,\
    \ n).reverse", "        val s = string + \"#\" + string.reverse\n        val lps\
    \ = Array.fill(s.length)(0)\n        for (i <- 1 until s.length) {\n         \
    \   var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j)) j = lps(j -\
    \ 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n        string.substring(lps(s.length\
    \ - 1)) + string", "        val suffix = string.substring(string.length / 2)\n\
    \        val prefix = string.substring(0, string.length / 2)\n        val reversedPrefix\
    \ = prefix.reverse\n        val palindromeSuffix = longestPalindromeSuffix(suffix)\n\
    \        suffix + reversedPrefix + palindromeSuffix", "        val n = string.length\n\
    \        val s = string + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n\
    \        for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n     \
    \       while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) ==\
    \ s(j)) lps(i) = j + 1\n        }\n        string + string.substring(lps(s.length\
    \ - 1)).reverse", "        val s = string + \"#\" + string.reverse\n        val\
    \ lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length) {\n     \
    \       var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j)) j = lps(j\
    \ - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n        string.substring(lps(s.length\
    \ - 1)) + string", "        def isPalindrome(string : String) : Boolean = {\n\
    \            for (i <- 0 until string.length / 2) {\n                if (string(i)\
    \ != string(string.length - 1 - i)) return false\n            }\n            return\
    \ true\n        }\n        var longestPalindrome = \"\"\n        for (i <- 0 until\
    \ string.length) {\n            if (isPalindrome(string.substring(i))) {\n   \
    \             longestPalindrome = string.substring(i)\n            }\n       \
    \ }\n        return string + string.substring(0, string.length - longestPalindrome.length).reverse",
  "        val s = string + \"#\" + string.reverse\n        val n = s.length\n   \
    \     val p = Array.fill(n)(0)\n        for (i <- 1 until n) {\n            var\
    \ j = p(i - 1)\n            while (j > 0 && s(i) != s(j)) j = p(j - 1)\n     \
    \       if (s(i) == s(j)) j += 1\n            p(i) = j\n        }\n        string.substring(p(n\
    \ - 1)) + string", "        def isPalindrome(string : String) : Boolean = {\n\
    \            for (i <- 0 until string.length / 2) {\n                if (string(i)\
    \ != string(string.length - 1 - i)) return false\n            }\n            return\
    \ true\n        }\n        for (i <- string.length to 0 by -1) {\n           \
    \ if (isPalindrome(string.substring(i))) {\n                return string + string.substring(0,\
    \ i).reverse\n            }\n        }\n        return string", "        val stringLength\
    \ = string.length\n        val longestPalindrome = Array.fill(stringLength, stringLength)(0)\n\
    \        for (i <- 0 until stringLength) longestPalindrome(i)(i) = 1\n       \
    \ for (i <- 0 until stringLength - 1) {\n            if (string(i) == string(i\
    \ + 1)) longestPalindrome(i)(i + 1) = 2\n        }\n        for (k <- 3 to stringLength)\
    \ {\n            for (i <- 0 until stringLength - k + 1) {\n                val\
    \ j = i + k - 1\n                if (string(i) == string(j) && longestPalindrome(i\
    \ + 1)(j - 1) > 0) longestPalindrome(i)(j) = k\n            }\n        }\n   \
    \     var maxLength = 0\n        var maxIndex = 0\n        for (i <- 0 until stringLength)\
    \ {\n            if (longestPalindrome(0)(i) > maxLength) {\n                maxLength\
    \ = longestPalindrome(0)(i)\n                maxIndex = i\n            }\n   \
    \     }\n        string.substring(maxIndex + 1) + string.substring(0, maxIndex\
    \ + 1).reverse", "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n\
    \        suffix(0) = 0\n        var i = 1\n        var j = 0\n        while (i\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(i)\
    \ = j + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (j == 0) {\n                    suffix(i) = 0\n      \
    \              i += 1\n                } else {\n                    j = suffix(j\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse", "        val n = string.length\n\
    \        val s = string + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n\
    \        for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n     \
    \       while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) ==\
    \ s(j)) lps(i) = j + 1\n        }\n        string + string.substring(lps(s.length\
    \ - 1)).reverse", "        val suffix = string.substring(string.length / 2)\n\
    \        val prefix = string.substring(0, string.length / 2)\n        val palindrome\
    \ = prefix + suffix\n        val reverse = prefix.reverse\n        palindrome\
    \ + reverse", "        val n = string.length\n        val suffix = new Array[Int](n)\n\
    \        suffix(0) = 0\n        for (i <- 1 until n) {\n            var j = suffix(i\
    \ - 1)\n            while (j > 0 && string(i) != string(j)) {\n              \
    \  j = suffix(j - 1)\n            }\n            if (string(i) == string(j)) {\n\
    \                suffix(i) = j + 1\n            } else {\n                suffix(i)\
    \ = 0\n            }\n        }\n        val prefix = string.substring(0, n -\
    \ suffix(n - 1))\n        prefix.reverse + string", "        val suffix = string.substring(0,\
    \ string.length - 1)\n        val prefix = string.substring(string.length - 1,\
    \ string.length)\n        val longestPalindrome = suffix.reverse.zip(suffix).takeWhile(p\
    \ => p._1 == p._2).map(_._1).mkString\n        prefix + longestPalindrome + suffix",
  "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n     \
    \   var i = 0\n        var j = 1\n        while (j < n) {\n            if (string(i)\
    \ == string(j)) {\n                suffix(j) = i + 1\n                i += 1\n\
    \                j += 1\n            } else {\n                if (i == 0) {\n\
    \                    suffix(j) = 0\n                    j += 1\n             \
    \   } else {\n                    i = suffix(i - 1)\n                }\n     \
    \       }\n        }\n        val prefix = string.substring(0, n - suffix(n -\
    \ 1))\n        prefix.reverse + string", "        val n = string.length\n    \
    \    val suffix = Array.ofDim[Int](n)\n        var i = 1\n        var j = 0\n\
    \        while (i < n) {\n            if (string(i) == string(j)) {\n        \
    \        suffix(i) = j + 1\n                i += 1\n                j += 1\n \
    \           } else if (j > 0) {\n                j = suffix(j - 1)\n         \
    \   } else {\n                suffix(i) = 0\n                i += 1\n        \
    \    }\n        }\n        val prefix = string.substring(0, n - suffix(n - 1))\n\
    \        prefix.reverse + string", "        def isPalindrome(string : String)\
    \ : Boolean = {\n            val n = string.length\n            for (i <- 0 until\
    \ n / 2) if (string(i) != string(n - 1 - i)) return false\n            return\
    \ true\n        }\n        val n = string.length\n        for (i <- n to 0 by\
    \ -1) {\n            val suffix = string.substring(n - i, n)\n            if (isPalindrome(suffix))\
    \ {\n                val prefix = string.substring(0, n - i)\n               \
    \ return string + prefix.reverse\n            }\n        }\n        return string",
  "        val n = string.length\n        val palindrome = Array.ofDim[Int](n)\n \
    \       var center = 0\n        var right = 0\n        for (i <- 0 until n) {\n\
    \            val mirror = 2 * center - i\n            if (i < right) palindrome(i)\
    \ = min(right - i, palindrome(mirror))\n            var a = i - (1 + palindrome(i))\n\
    \            var b = i + (1 + palindrome(i))\n            while (a >= 0 && b <\
    \ n && string(a) == string(b)) {\n                palindrome(i) += 1\n       \
    \         a -= 1\n                b += 1\n            }\n            if (i + palindrome(i)\
    \ > right) {\n                center = i\n                right = i + palindrome(i)\n\
    \            }\n        }\n        val maxPalindrome = palindrome.max\n      \
    \  val prefix = string.substring(0, n - maxPalindrome)\n        val suffix = string.substring(n\
    \ - maxPalindrome)\n        prefix.reverse + string", "        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string.substring(lps(s.length - 1)) + string",
  "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n     \
    \   suffix(0) = 0\n        var i = 1\n        var j = 0\n        while (i < n)\
    \ {\n            if (string(i) == string(j)) {\n                suffix(i) = j\
    \ + 1\n                i += 1\n                j += 1\n            } else {\n\
    \                if (j == 0) {\n                    suffix(i) = 0\n          \
    \          i += 1\n                } else {\n                    j = suffix(j\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse", "        val n = string.length\n\
    \        val dp = Array.ofDim[Int](n, n)\n        for (i <- 0 until n) dp(i)(i)\
    \ = 1\n        for (i <- 0 until n - 1) dp(i)(i + 1) = if (string(i) == string(i\
    \ + 1)) 2 else 1\n        for (k <- 3 to n) {\n            for (i <- 0 to n -\
    \ k) {\n                val j = i + k - 1\n                dp(i)(j) = if (string(i)\
    \ == string(j)) dp(i + 1)(j - 1) + 2 else max(dp(i + 1)(j), dp(i)(j - 1))\n  \
    \          }\n        }\n        val i = 0\n        val j = n - 1\n        val\
    \ k = dp(i)(j)\n        val sb = new StringBuilder\n        if (k == n) return\
    \ string\n        else {\n            var l = i\n            var r = j\n     \
    \       while (l < r) {\n                if (string(l) == string(r)) {\n     \
    \               l += 1\n                    r -= 1\n                }\n      \
    \          else if (dp(l + 1)(r) > dp(l)(r - 1)) l += 1\n                else\
    \ r -= 1\n            }\n            sb.append(string.substring(0, l))\n     \
    \       sb.append(string.substring(l, n).reverse)\n        }\n        sb.toString",
  "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n     \
    \   suffix(0) = 0\n        var i = 1\n        var j = 0\n        while (i < n)\
    \ {\n            if (string(i) == string(j)) {\n                suffix(i) = j\
    \ + 1\n                i += 1\n                j += 1\n            } else {\n\
    \                if (j == 0) {\n                    suffix(i) = 0\n          \
    \          i += 1\n                } else {\n                    j = suffix(j\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        prefix.reverse + string", "        val reversed\
    \ = string.reverse\n        val s = string + \"#\" + reversed\n        val lps\
    \ = Array.fill(s.length)(0)\n        for (i <- 1 until s.length) {\n         \
    \   var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j)) j = lps(j -\
    \ 1)\n            if (s(i) == s(j)) j += 1\n            lps(i) = j\n        }\n\
    \        reversed.substring(0, string.length - lps.last) + string", "        val\
    \ s = string + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n\
    \        for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n     \
    \       while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) ==\
    \ s(j)) lps(i) = j + 1\n        }\n        string.substring(lps(s.length - 1))\
    \ + string", "        val s = string + \"#\" + string.reverse\n        val lps\
    \ = Array.fill(s.length)(0)\n        for (i <- 1 until s.length) {\n         \
    \   var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j)) j = lps(j -\
    \ 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n        val prefix\
    \ = string.substring(0, string.length - lps.last)\n        prefix.reverse + string",
  "        val n = string.length\n        val suffix = Array.ofDim[Int](n + 1)\n \
    \       suffix(n) = n\n        var i = n - 1\n        while (i >= 0) {\n     \
    \       var j = i\n            while (j >= 0 && string(j) == string(n - 1 - i\
    \ + j)) j -= 1\n            suffix(i) = i - j\n            i -= 1\n        }\n\
    \        val prefix = Array.ofDim[Int](n + 1)\n        prefix(0) = 0\n       \
    \ i = 1\n        while (i <= n) {\n            var j = i\n            while (j\
    \ <= n && string(j - 1) == string(n - i)) j += 1\n            prefix(i) = j -\
    \ i\n            i += 1\n        }\n        var min = n\n        var minIndex\
    \ = 0\n        i = 0\n        while (i <= n) {\n            if (suffix(i) + prefix(n\
    \ - i) < min) {\n                min = suffix(i) + prefix(n - i)\n           \
    \     minIndex = i\n            }\n            i += 1\n        }\n        val\
    \ prefixString = string.substring(0, minIndex)\n        val suffixString = string.substring(minIndex,\
    \ minIndex + suffix(minIndex))\n        val reversePrefixString = prefixString.reverse\n\
    \        suffixString + reversePrefixString + string", "        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        val prefix = string.substring(0, string.length\
    \ - lps.last)\n        prefix.reverse + string", "        val s = string + \"\
    #\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n        for (i\
    \ <- 1 until s.length) {\n            var j = lps(i - 1)\n            while (j\
    \ > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) =\
    \ j + 1\n        }\n        string.substring(lps(s.length - 1)) + string", " \
    \       val n = string.length\n        val s = string + \"#\" + string.reverse\n\
    \        val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string + string.reverse.substring(lps(s.length - 1))", "        val n =\
    \ string.length\n        val suffix = Array.ofDim[Int](n)\n        suffix(0) =\
    \ 0\n        var i = 1\n        var j = 0\n        while (i < n) {\n         \
    \   if (string(i) == string(j)) {\n                suffix(i) = j + 1\n       \
    \         i += 1\n                j += 1\n            } else {\n             \
    \   if (j == 0) {\n                    suffix(i) = 0\n                    i +=\
    \ 1\n                } else {\n                    j = suffix(j - 1)\n       \
    \         }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        prefix.reverse + string", "        def isPalindrome(string\
    \ : String) : Boolean = {\n            for (i <- 0 until string.length / 2) {\n\
    \                if (string(i) != string(string.length - 1 - i)) return false\n\
    \            }\n            return true\n        }\n        var longestPalindrome\
    \ = \"\"\n        for (i <- 0 until string.length) {\n            val candidate\
    \ = string.substring(i)\n            if (isPalindrome(candidate) && candidate.length\
    \ > longestPalindrome.length) longestPalindrome = candidate\n        }\n     \
    \   if (longestPalindrome.length == string.length) return string\n        else\
    \ return string + string.substring(0, string.length - longestPalindrome.length).reverse",
  "        val n = string.length\n        val dp = Array.ofDim[Int](n, n)\n      \
    \  for (i <- 0 until n) dp(i)(i) = 1\n        for (i <- 0 until n - 1) dp(i)(i\
    \ + 1) = if (string(i) == string(i + 1)) 2 else 1\n        for (k <- 3 to n) {\n\
    \            for (i <- 0 to n - k) {\n                val j = i + k - 1\n    \
    \            dp(i)(j) = if (string(i) == string(j)) dp(i + 1)(j - 1) + 2 else\
    \ max(dp(i + 1)(j), dp(i)(j - 1))\n            }\n        }\n        val palindromeSuffix\
    \ = string.substring(n - dp(0)(n - 1), n)\n        val palindromePrefix = string.substring(0,\
    \ n - dp(0)(n - 1)).reverse\n        palindromeSuffix + palindromePrefix", " \
    \       val n = string.length\n        val suffix = new Array[Int](n)\n      \
    \  suffix(0) = 0\n        var i = 1\n        var j = 0\n        while (i < n)\
    \ {\n            if (string(i) == string(j)) {\n                suffix(i) = j\
    \ + 1\n                i += 1\n                j += 1\n            } else {\n\
    \                if (j == 0) {\n                    suffix(i) = 0\n          \
    \          i += 1\n                } else {\n                    j = suffix(j\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        prefix.reverse + string", "        val n = string.length\n\
    \        val s = string + \"#\" + string.reverse\n        val z = Array.fill(s.length)(0)\n\
    \        var l = 0; var r = 0\n        for (i <- 1 until s.length) {\n       \
    \     if (i <= r) z(i) = min(z(i - l), r - i + 1)\n            while (i + z(i)\
    \ < s.length && s(z(i)) == s(i + z(i))) z(i) += 1\n            if (i + z(i) -\
    \ 1 > r) {\n                l = i; r = i + z(i) - 1\n            }\n        }\n\
    \        string + string.reverse.substring(0, n - z(s.length - 1))", "       \
    \ val longestPalindrome = longestPalindromeSuffix(string)\n        val prefix\
    \ = string.substring(0, string.length - longestPalindrome.length)\n        prefix\
    \ + longestPalindrome + prefix.reverse", "        val s = string + \"#\" + string.reverse\n\
    \        val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string", "        val n = string.length\n\
    \        val s = string + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n\
    \        for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n     \
    \       while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) ==\
    \ s(j)) lps(i) = j + 1\n        }\n        string + string.substring(lps(s.length\
    \ - 1)).reverse", "        val n = string.length\n        val suffix = new Array[Int](n)\n\
    \        // suffix[i] is the length of the longest palindromic suffix of string[0..i]\n\
    \        // suffix[i] = 0 if string[0..i] is not a palindrome\n        // suffix[i]\
    \ = 1 if string[0..i] is a palindrome\n        suffix(0) = 1\n        for (i <-\
    \ 1 until n) {\n            var j = i\n            while (j > 0 && string(j) !=\
    \ string(n - i + j - 1)) j -= 1\n            suffix(i) = i - j + 1\n        }\n\
    \        // Find the longest palindromic suffix\n        var i = n - 1\n     \
    \   while (i > 0 && suffix(i) != i + 1) i -= 1\n        // Append reverse of string[0..i]\
    \ to the end of string\n        val prefix = string.substring(0, i).reverse\n\
    \        string + prefix", "        val s = string + \"#\" + string.reverse\n\
    \        val n = s.length\n        val z = new Array[Int](n)\n        var l =\
    \ 0; var r = 0\n        for (i <- 1 until n) {\n            if (i > r) {\n   \
    \             l = r = i\n                while (r < n && s(r - l) == s(r)) r +=\
    \ 1\n                z(i) = r - l; r -= 1\n            } else {\n            \
    \    val k = i - l\n                if (z(k) < r - i + 1) z(i) = z(k)\n      \
    \          else {\n                    l = i\n                    while (r < n\
    \ && s(r - l) == s(r)) r += 1\n                    z(i) = r - l; r -= 1\n    \
    \            }\n            }\n        }\n        string.substring(z(n - 1)) +\
    \ string", "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n\
    \        for (i <- 0 until n) {\n            var j = 0\n            while (i -\
    \ j >= 0 && i + j < n && string(i - j) == string(i + j)) j += 1\n            suffix(i)\
    \ = j\n        }\n        var max = 0\n        var maxIndex = 0\n        for (i\
    \ <- 0 until n) {\n            if (suffix(i) > max) {\n                max = suffix(i)\n\
    \                maxIndex = i\n            }\n        }\n        val prefix =\
    \ string.substring(0, maxIndex - max + 1)\n        string + prefix.reverse", " \
    \       val n = string.length\n        val suffix = Array.ofDim[Int](n)\n    \
    \    for (i <- 0 until n) {\n            var j = 0\n            while (i - j >=\
    \ 0 && i + j < n && string(i - j) == string(i + j)) j += 1\n            suffix(i)\
    \ = j\n        }\n        var max = 0\n        var maxIndex = 0\n        for (i\
    \ <- 0 until n) {\n            if (suffix(i) > max) {\n                max = suffix(i)\n\
    \                maxIndex = i\n            }\n        }\n        val prefix =\
    \ string.substring(0, maxIndex - max + 1)\n        val palindrome = string + prefix.reverse\n\
    \        palindrome", "        val n = string.length\n        val suffix = new\
    \ Array[Int](n)\n        suffix(0) = 0\n        var i = 1\n        var j = 0\n\
    \        while (i < n) {\n            if (string(i) == string(j)) {\n        \
    \        suffix(i) = j + 1\n                i += 1\n                j += 1\n \
    \           } else {\n                if (j == 0) {\n                    suffix(i)\
    \ = 0\n                    i += 1\n                } else {\n                \
    \    j = suffix(j - 1)\n                }\n            }\n        }\n        val\
    \ prefix = string.substring(0, n - suffix(n - 1))\n        string + prefix.reverse",
  "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n     \
    \   for (i <- 0 until n) {\n            var j = 0\n            while (i - j >=\
    \ 0 && i + j < n && string(i - j) == string(i + j)) j += 1\n            suffix(i)\
    \ = j\n        }\n        var max = 0\n        var maxIndex = 0\n        for (i\
    \ <- 0 until n) {\n            if (suffix(i) > max) {\n                max = suffix(i)\n\
    \                maxIndex = i\n            }\n        }\n        val prefix =\
    \ string.substring(0, maxIndex - max + 1)\n        prefix + string", "       \
    \ val suffix = string.substring(string.length / 2)\n        val prefix = string.substring(0,\
    \ string.length / 2)\n        val reversedPrefix = prefix.reverse\n        val\
    \ palindromeSuffix = findPalindromeSuffix(suffix)\n        val palindromePrefix\
    \ = reversedPrefix.substring(reversedPrefix.length - (suffix.length - palindromeSuffix.length))\n\
    \        palindromePrefix + suffix", "        val n = string.length\n        val\
    \ suffix = Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n       \
    \ while (j < n) {\n            if (string(i) == string(j)) {\n               \
    \ suffix(j) = i + 1\n                i += 1\n                j += 1\n        \
    \    } else {\n                if (i == 0) {\n                    suffix(j) =\
    \ 0\n                    j += 1\n                } else {\n                  \
    \  i = suffix(i - 1)\n                }\n            }\n        }\n        val\
    \ prefix = string.substring(0, n - suffix(n - 1))\n        prefix.reverse + string",
  "        val reversed = string.reverse\n        val s = string + \"#\" + reversed\n\
    \        val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      val prefix = string.substring(0, string.length - lps.last)\n        prefix.reverse\
    \ + string", "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n\
    \        suffix(0) = 0\n        var i = 1\n        var j = 0\n        while (i\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(i)\
    \ = j + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (j == 0) {\n                    suffix(i) = 0\n      \
    \              i += 1\n                } else {\n                    j = suffix(j\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse", "        val reversed\
    \ = string.reverse\n        val suffix = string.substring(0, string.length - reversed.indexOf(string))\n\
    \        val prefix = string.substring(suffix.length)\n        prefix + suffix\
    \ + reversed.substring(prefix.length)", "        val n = string.length\n     \
    \   val suffix = Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i = 1\n\
    \        var j = 0\n        while (i < n) {\n            if (string(i) == string(j))\
    \ {\n                suffix(i) = j + 1\n                i += 1\n             \
    \   j += 1\n            } else {\n                if (j == 0) {\n            \
    \        suffix(i) = 0\n                    i += 1\n                } else {\n\
    \                    j = suffix(j - 1)\n                }\n            }\n   \
    \     }\n        val prefix = string.substring(0, n - suffix(n - 1))\n       \
    \ string + prefix.reverse", "        val s = string + \"*\" + string.reverse\n\
    \        val lps = Array.fill(s.length)(0)\n        var i = 1\n        while (i\
    \ < s.length) {\n            if (s(i) == s(lps(i - 1))) {\n                lps(i)\
    \ = lps(i - 1) + 1\n            } else {\n                var j = lps(i - 1)\n\
    \                while (j > 0 && s(i) != s(j)) {\n                    j = lps(j\
    \ - 1)\n                }\n                if (s(i) == s(j)) {\n             \
    \       lps(i) = j + 1\n                }\n            }\n            i += 1\n\
    \        }\n        string.substring(lps(s.length - 1)) + string", "        val\
    \ suffix = string.reverse\n        val prefix = string.substring(0, string.length\
    \ - suffix.length)\n        suffix + prefix", "        val suffix = string.substring(string.length\
    \ / 2)\n        val prefix = string.substring(0, string.length / 2)\n        val\
    \ reversedPrefix = prefix.reverse\n        val palindromeSuffix = findPalindromeSuffix(suffix)\n\
    \        val palindrome = suffix + reversedPrefix + palindromeSuffix\n       \
    \ palindrome", "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n\
    \        suffix(0) = 0\n        var i = 1\n        var j = 0\n        while (i\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(i)\
    \ = j + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (j == 0) {\n                    suffix(i) = 0\n      \
    \              i += 1\n                } else {\n                    j = suffix(j\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse", "        val n = string.length\n\
    \        val p = Array.ofDim[Int](n)\n        var c = 0\n        var r = 0\n \
    \       for (i <- 1 until n) {\n            val mirror = 2 * c - i\n         \
    \   if (i < r) p(i) = min(r - i, p(mirror))\n            while (i + 1 + p(i) <\
    \ n && i - 1 - p(i) >= 0 && string(i + 1 + p(i)) == string(i - 1 - p(i))) p(i)\
    \ += 1\n            if (i + p(i) > r) {\n                c = i\n             \
    \   r = i + p(i)\n            }\n        }\n        var max = 0\n        var maxIndex\
    \ = 0\n        for (i <- 0 until n) {\n            if (p(i) > max) {\n       \
    \         max = p(i)\n                maxIndex = i\n            }\n        }\n\
    \        val prefix = string.substring(0, maxIndex - max)\n        val suffix\
    \ = string.substring(maxIndex + max)\n        prefix.reverse + string + suffix",
  "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n     \
    \   suffix(0) = 0\n        var i = 1\n        var j = 0\n        while (i < n)\
    \ {\n            if (string(i) == string(j)) {\n                suffix(i) = j\
    \ + 1\n                i += 1\n                j += 1\n            } else {\n\
    \                if (j == 0) {\n                    suffix(i) = 0\n          \
    \          i += 1\n                } else {\n                    j = suffix(j\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse", "        val n = string.length\n\
    \        val suffix = Array.ofDim[Int](n)\n        var i = 1\n        var j =\
    \ 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n    \
    \            suffix(i) = j + 1\n                i += 1\n                j += 1\n\
    \            } else if (j > 0) {\n                j = suffix(j - 1)\n        \
    \    } else {\n                suffix(i) = 0\n                i += 1\n       \
    \     }\n        }\n        val prefix = string.substring(0, n - suffix(n - 1))\n\
    \        prefix.reverse + string", "        val n = string.length\n        val\
    \ suffix = Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i = 1\n   \
    \     var j = 0\n        while (i < n) {\n            if (string(i) == string(j))\
    \ {\n                suffix(i) = j + 1\n                i += 1\n             \
    \   j += 1\n            } else {\n                if (j == 0) {\n            \
    \        suffix(i) = 0\n                    i += 1\n                } else {\n\
    \                    j = suffix(j - 1)\n                }\n            }\n   \
    \     }\n        val prefix = string.substring(0, n - suffix(n - 1))\n       \
    \ prefix.reverse + string", "        val n = string.length\n        val suffix\
    \ = Array.ofDim[Int](n + 1)\n        suffix(n) = n\n        var i = n - 1\n  \
    \      while (i >= 0) {\n            var j = i\n            while (j >= 0 && string(j)\
    \ == string(n - 1 - i + j)) j -= 1\n            suffix(i) = i - j\n          \
    \  i -= 1\n        }\n        var best = 0\n        var bestLength = 0\n     \
    \   i = 0\n        while (i < n) {\n            if (suffix(i) > bestLength) {\n\
    \                best = i\n                bestLength = suffix(i)\n          \
    \  }\n            i += 1\n        }\n        string + string.substring(0, n -\
    \ bestLength).reverse", "        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  var i = 1\n        var j = 0\n        while (i < s.length) {\n            if\
    \ (s(i) == s(j)) {\n                lps(i) = j + 1\n                i += 1\n \
    \               j += 1\n            } else {\n                if (j == 0) {\n\
    \                    lps(i) = 0\n                    i += 1\n                }\
    \ else {\n                    j = lps(j - 1)\n                }\n            }\n\
    \        }\n        val prefix = string.substring(0, n - lps(s.length - 1))\n\
    \        prefix.reverse + string", "        val n = string.length\n        val\
    \ s = string + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n\
    \        for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n     \
    \       while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) ==\
    \ s(j)) lps(i) = j + 1\n        }\n        string + string.reverse.substring(lps(s.length\
    \ - 1))", "        val reversed = string.reverse\n        val s = string + \"\
    #\" + reversed\n        val lps = Array.fill(s.length)(0)\n        var i = 1\n\
    \        var len = 0\n        while (i < s.length) {\n            if (s(i) ==\
    \ s(len)) {\n                len += 1\n                lps(i) = len\n        \
    \        i += 1\n            } else {\n                if (len != 0) {\n     \
    \               len = lps(len - 1)\n                } else {\n               \
    \     lps(i) = 0\n                    i += 1\n                }\n            }\n\
    \        }\n        string + reversed.substring(lps(s.length - 1))", "       \
    \ val suffix = string.substring(string.length / 2)\n        val prefix = string.substring(0,\
    \ string.length / 2)\n        val reversedPrefix = prefix.reverse\n        val\
    \ palindromeSuffix = findPalindromeSuffix(suffix)\n        val palindrome = suffix\
    \ + reversedPrefix + palindromeSuffix\n        palindrome", "        val n = string.length\n\
    \        val suffix = Array.ofDim[Int](n)\n        var i = 1\n        var j =\
    \ 0\n        while (i < n) {\n            if (string(i) == string(j)) {\n    \
    \            suffix(i) = j + 1\n                i += 1\n                j += 1\n\
    \            } else if (j > 0) {\n                j = suffix(j - 1)\n        \
    \    } else {\n                suffix(i) = 0\n                i += 1\n       \
    \     }\n        }\n        val prefix = string.substring(0, n - suffix(n - 1))\n\
    \        prefix.reverse + string", "        val suffix = string.substring(string.length\
    \ / 2)\n        val prefix = string.substring(0, string.length / 2)\n        val\
    \ reversedPrefix = prefix.reverse\n        val palindromeSuffix = suffix.substring(suffix.indexOf(reversedPrefix))\n\
    \        val palindromePrefix = reversedPrefix.substring(0, reversedPrefix.length\
    \ - palindromeSuffix.length)\n        palindromePrefix + string + palindromeSuffix",
  "        val n = string.length\n        val s = string + \"#\" + string.reverse\n\
    \        val z = new Array[Int](s.length)\n        z(0) = s.length\n        var\
    \ l = 0; var r = 0\n        for (i <- 1 until s.length) {\n            if (i >\
    \ r) {\n                l = r = i\n                while (r < s.length && s(r\
    \ - l) == s(r)) r += 1\n                z(i) = r - l\n                r -= 1\n\
    \            } else {\n                val k = i - l\n                if (z(k)\
    \ < r - i + 1) z(i) = z(k)\n                else {\n                    l = i\n\
    \                    while (r < s.length && s(r - l) == s(r)) r += 1\n       \
    \             z(i) = r - l\n                    r -= 1\n                }\n  \
    \          }\n        }\n        string + string.substring(z(n + 1)).reverse",
  "        val n = string.length\n        val dp = Array.ofDim[Int](n, n)\n      \
    \  for (i <- 0 until n) dp(i)(i) = 1\n        for (i <- n - 1 to 0 by -1) {\n\
    \            for (j <- i + 1 until n) {\n                if (string(i) == string(j))\
    \ dp(i)(j) = dp(i + 1)(j - 1) + 2\n                else dp(i)(j) = max(dp(i +\
    \ 1)(j), dp(i)(j - 1))\n            }\n        }\n        val suffix = string.substring(n\
    \ - dp(0)(n - 1), n)\n        val prefix = string.substring(0, n - dp(0)(n - 1))\n\
    \        suffix + prefix.reverse", "        val reversed = string.reverse\n  \
    \      val longestPalindrome = (0 to string.length).map(i => string.substring(0,\
    \ i) + reversed).maxBy(s => s.length - s.reverse.indexOf(s))\n        longestPalindrome.substring(longestPalindrome.length\
    \ - string.length) + string", "        val suffix = string.substring(string.length\
    \ / 2)\n        val prefix = string.substring(0, string.length / 2)\n        val\
    \ reversedPrefix = prefix.reverse\n        val palindromeSuffix = findPalindromeSuffix(suffix)\n\
    \        suffix + reversedPrefix + palindromeSuffix", "        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string.substring(lps(s.length - 1)) + string",
  "        val n = string.length\n        val s = string + \"#\" + string.reverse\n\
    \        val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string + string.substring(lps(s.length - 1)).reverse", "        val s =\
    \ string + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n\
    \        var len = 0\n        var i = 1\n        while (i < s.length) {\n    \
    \        if (s(i) == s(len)) {\n                len += 1\n                lps(i)\
    \ = len\n                i += 1\n            } else {\n                if (len\
    \ != 0) len = lps(len - 1)\n                else {\n                    lps(i)\
    \ = 0\n                    i += 1\n                }\n            }\n        }\n\
    \        val prefix = string.substring(lps(s.length - 1))\n        prefix.reverse\
    \ + string", "        val suffix = string.substring(string.length / 2)\n     \
    \   val prefix = string.substring(0, string.length / 2)\n        val reversedPrefix\
    \ = prefix.reverse\n        val palindromeSuffix = suffix.findPalindromeSuffix\n\
    \        val palindromePrefix = reversedPrefix.findPalindromePrefix\n        val\
    \ palindrome = palindromeSuffix + palindromePrefix\n        val result = palindrome\
    \ + string\n        result", "        val n = string.length\n        val dp =\
    \ Array.ofDim[Int](n, n)\n        for (i <- 0 until n) dp(i)(i) = 1\n        for\
    \ (i <- 0 until n - 1) dp(i)(i + 1) = if (string(i) == string(i + 1)) 2 else 1\n\
    \        for (k <- 3 to n) {\n            for (i <- 0 to n - k) {\n          \
    \      val j = i + k - 1\n                dp(i)(j) = if (string(i) == string(j))\
    \ dp(i + 1)(j - 1) + 2 else max(dp(i + 1)(j), dp(i)(j - 1))\n            }\n \
    \       }\n        val longestPalindrome = dp(0)(n - 1)\n        val prefix =\
    \ string.substring(0, n - longestPalindrome)\n        val suffix = string.substring(n\
    \ - longestPalindrome, n)\n        prefix.reverse + string", "        val n =\
    \ string.length\n        val rev = string.reverse\n        val s = string + \"\
    #\" + rev\n        val z = new Array[Int](s.length)\n        var l = 0; var r\
    \ = 0\n        for (i <- 1 until s.length) {\n            if (i > r) {\n     \
    \           l = r = i\n                while (r < s.length && s(r - l) == s(r))\
    \ r += 1\n                z(i) = r - l; r -= 1\n            } else {\n       \
    \         val k = i - l\n                if (z(k) < r - i + 1) z(i) = z(k)\n \
    \               else {\n                    l = i\n                    while (r\
    \ < s.length && s(r - l) == s(r)) r += 1\n                    z(i) = r - l; r\
    \ -= 1\n                }\n            }\n        }\n        val longestPalindromeSuffix\
    \ = z(s.length - 1)\n        string + rev.substring(0, n - longestPalindromeSuffix)",
  "        val n = string.length\n        val s = string + '$' + string.reverse\n\
    \        val z = new Array[Int](s.length)\n        var l = 0; var r = 0\n    \
    \    for (i <- 1 until s.length) {\n            if (i > r) {\n               \
    \ l = r = i\n                while (r < s.length && s(r - l) == s(r)) r += 1\n\
    \                z(i) = r - l; r -= 1\n            } else {\n                val\
    \ k = i - l\n                if (z(k) < r - i + 1) z(i) = z(k)\n             \
    \   else {\n                    l = i\n                    while (r < s.length\
    \ && s(r - l) == s(r)) r += 1\n                    z(i) = r - l; r -= 1\n    \
    \            }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - z(n + 1))\n        prefix.reverse + string", "        val n = string.length\n\
    \        val suffix = Array.ofDim[Int](n)\n        var i = 0\n        var j =\
    \ 1\n        while (j < n) {\n            if (string(i) == string(j)) {\n    \
    \            suffix(j) = i + 1\n                i += 1\n                j += 1\n\
    \            } else {\n                if (i == 0) {\n                    suffix(j)\
    \ = 0\n                    j += 1\n                } else {\n                \
    \    i = suffix(i - 1)\n                }\n            }\n        }\n        val\
    \ prefix = string.substring(0, n - suffix(n - 1))\n        prefix.reverse + string",
  "        val n = string.length\n        val p = Array.ofDim[Int](n)\n        var\
    \ c = 0\n        var r = 0\n        for (i <- 1 until n) {\n            if (i\
    \ > r) {\n                p(i) = 0\n                c = i\n                r =\
    \ i\n            } else {\n                val i2 = 2 * c - i\n              \
    \  if (p(i2) < (r - i)) {\n                    p(i) = p(i2)\n                }\
    \ else {\n                    p(i) = r - i\n                    c = i\n      \
    \              r = i + p(i)\n                }\n            }\n            while\
    \ (i - p(i) - 1 >= 0 && i + p(i) + 1 < n && string(i - p(i) - 1) == string(i +\
    \ p(i) + 1)) {\n                p(i) += 1\n                c = i\n           \
    \     r = i + p(i)\n            }\n        }\n        val max = p.max\n      \
    \  val prefix = string.substring(0, n - max)\n        val suffix = string.substring(n\
    \ - max)\n        prefix + suffix.reverse + suffix", "        val n = string.length\n\
    \        val suffix = Array.ofDim[Int](n)\n        var i = 0\n        var j =\
    \ 1\n        while (j < n) {\n            if (string(i) == string(j)) {\n    \
    \            suffix(j) = i + 1\n                i += 1\n                j += 1\n\
    \            } else {\n                if (i == 0) {\n                    suffix(j)\
    \ = 0\n                    j += 1\n                } else {\n                \
    \    i = suffix(i - 1)\n                }\n            }\n        }\n        val\
    \ prefix = string.substring(0, n - suffix(n - 1))\n        string + prefix.reverse",
  "        val reversed = string.reverse\n        val (prefix, suffix) = string.zip(reversed).span(x\
    \ => x._1 == x._2)\n        prefix.map(_._1).mkString + string + suffix.map(_._2).mkString",
  "        val suffix = longestPalindromicSuffix(string)\n        val prefix = string.substring(0,\
    \ string.length - suffix.length)\n        prefix.reverse + string", "        val\
    \ n = string.length\n        val suffix = new Array[Int](n)\n        suffix(0)\
    \ = 0\n        var i = 1\n        var j = 0\n        while (i < n) {\n       \
    \     if (string(i) == string(j)) {\n                suffix(i) = j + 1\n     \
    \           i += 1\n                j += 1\n            } else {\n           \
    \     if (j == 0) {\n                    suffix(i) = 0\n                    i\
    \ += 1\n                } else {\n                    j = suffix(j - 1)\n    \
    \            }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        prefix.reverse + string", "        val n = string.length\n\
    \        val suffix = Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n  \
    \          var j = 0\n            while (i - j >= 0 && i + j < n && string(i -\
    \ j) == string(i + j)) j += 1\n            suffix(i) = j\n        }\n        var\
    \ max = 0\n        var maxIndex = 0\n        for (i <- 0 until n) {\n        \
    \    if (suffix(i) > max) {\n                max = suffix(i)\n               \
    \ maxIndex = i\n            }\n        }\n        val prefix = string.substring(0,\
    \ maxIndex - max + 1)\n        prefix + string", "        val n = string.length\n\
    \        val suffix = Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n  \
    \          suffix(i) = 0\n            var j = i\n            while (j >= 0 &&\
    \ string(j) == string(n - 1 - i + j)) {\n                suffix(i) += 1\n    \
    \            j -= 1\n            }\n        }\n        var max = 0\n        var\
    \ maxIndex = 0\n        for (i <- 0 until n) {\n            if (suffix(i) > max)\
    \ {\n                max = suffix(i)\n                maxIndex = i\n         \
    \   }\n        }\n        val prefix = string.substring(0, n - maxIndex - max)\n\
    \        prefix + string", "        val s = string + \"#\" + string.reverse\n\
    \        val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string.substring(lps(s.length - 1)) + string", "        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  var i = 1\n        while (i < s.length) {\n            if (s(i) == s(lps(i\
    \ - 1))) lps(i) = lps(i - 1) + 1\n            else {\n                var j =\
    \ lps(i - 1)\n                while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n \
    \               if (s(i) == s(j)) lps(i) = j + 1\n            }\n            i\
    \ += 1\n        }\n        string.substring(lps(s.length - 1)) + string", "  \
    \      val s = string + \"#\" + string.reverse\n        val pi = Array.fill(s.length)(0)\n\
    \        for (i <- 1 until s.length) {\n            var j = pi(i - 1)\n      \
    \      while (j > 0 && s(i) != s(j)) j = pi(j - 1)\n            if (s(i) == s(j))\
    \ pi(i) = j + 1\n        }\n        string.substring(pi(s.length - 1)) + string",
  "        val stringLength = string.length\n        val stringReverse = string.reverse\n\
    \        val suffixLength = (0 until stringLength).find(i => string.substring(i)\
    \ == stringReverse.substring(0, stringLength - i)).get\n        string + stringReverse.substring(suffixLength)",
  "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n     \
    \   suffix(0) = 0\n        for (i <- 1 until n) {\n            var j = suffix(i\
    \ - 1)\n            while (j > 0 && string(i) != string(j)) j = suffix(j - 1)\n\
    \            if (string(i) == string(j)) suffix(i) = j + 1\n            else suffix(i)\
    \ = 0\n        }\n        val prefix = string.substring(0, n - suffix(n - 1))\n\
    \        prefix.reverse + string", "        val n = string.length\n        val\
    \ suffix = Array.ofDim[Int](n)\n        suffix(0) = 0\n        var i = 1\n   \
    \     var j = 0\n        while (i < n) {\n            if (string(i) == string(j))\
    \ {\n                suffix(i) = j + 1\n                i += 1\n             \
    \   j += 1\n            } else {\n                if (j == 0) {\n            \
    \        suffix(i) = 0\n                    i += 1\n                } else {\n\
    \                    j = suffix(j - 1)\n                }\n            }\n   \
    \     }\n        val prefix = string.substring(0, n - suffix(n - 1))\n       \
    \ string + prefix.reverse", "        val n = string.length\n        val suffix\
    \ = Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n            var j = 0\n\
    \            while (i - j >= 0 && i + j < n && string(i - j) == string(i + j))\
    \ j += 1\n            suffix(i) = j\n        }\n        var max = 0\n        var\
    \ maxIndex = 0\n        for (i <- 0 until n) {\n            if (suffix(i) > max)\
    \ {\n                max = suffix(i)\n                maxIndex = i\n         \
    \   }\n        }\n        val prefix = string.substring(0, maxIndex - max + 1)\n\
    \        string + prefix.reverse", "        val n = string.length\n        val\
    \ suffix = Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n       \
    \ while (j < n) {\n            if (string(i) == string(j)) {\n               \
    \ suffix(j) = i + 1\n                i += 1\n                j += 1\n        \
    \    } else {\n                if (i == 0) {\n                    suffix(j) =\
    \ 0\n                    j += 1\n                } else {\n                  \
    \  i = suffix(i - 1)\n                }\n            }\n        }\n        val\
    \ prefix = string.substring(0, n - suffix(n - 1))\n        string + prefix.reverse",
  "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n     \
    \   suffix(0) = 0\n        var i = 1\n        var j = 0\n        while (i < n)\
    \ {\n            if (string(i) == string(j)) {\n                suffix(i) = j\
    \ + 1\n                i += 1\n                j += 1\n            } else {\n\
    \                if (j == 0) {\n                    suffix(i) = 0\n          \
    \          i += 1\n                } else {\n                    j = suffix(j\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse", "        val suffix =\
    \ string.substring(string.length / 2)\n        val prefix = string.substring(0,\
    \ string.length / 2)\n        val palindrome = suffix + prefix.reverse\n     \
    \   palindrome", "        var longestPalindrome = \"\"\n        var longestPalindromeLength\
    \ = 0\n        for (i <- 0 to string.length) {\n            val substring = string.substring(i)\n\
    \            if (substring.length > longestPalindromeLength && substring.reverse\
    \ == substring) {\n                longestPalindrome = substring\n           \
    \     longestPalindromeLength = substring.length\n            }\n        }\n \
    \       string + string.substring(0, string.length - longestPalindromeLength).reverse",
  "        val suffix = string.substring(string.length / 2)\n        val prefix =\
    \ string.substring(0, string.length / 2)\n        val palindromeSuffix = findPalindromeSuffix(suffix)\n\
    \        val palindromePrefix = prefix.substring(0, prefix.length - palindromeSuffix.length)\n\
    \        palindromePrefix + suffix + palindromePrefix.reverse", "        var longestPalindrome\
    \ = \"\"\n        for (i <- 0 to string.length) {\n            val prefix = string.substring(0,\
    \ i)\n            val suffix = string.substring(i)\n            if (isPalindrome(suffix))\
    \ {\n                longestPalindrome = suffix\n                break\n     \
    \       }\n        }\n        string + reverse(string.substring(0, string.length\
    \ - longestPalindrome.length))", "        val n = string.length\n        val dp\
    \ = Array.ofDim[Int](n, n)\n        for (i <- 0 until n) dp(i)(i) = 1\n      \
    \  for (i <- 0 until n - 1) dp(i)(i + 1) = if (string(i) == string(i + 1)) 2 else\
    \ 1\n        for (k <- 3 to n) {\n            for (i <- 0 until n - k + 1) {\n\
    \                val j = i + k - 1\n                dp(i)(j) = if (string(i) ==\
    \ string(j)) dp(i + 1)(j - 1) + 2 else max(dp(i + 1)(j), dp(i)(j - 1))\n     \
    \       }\n        }\n        val longestPalindrome = dp(0)(n - 1)\n        val\
    \ prefix = string.substring(0, n - longestPalindrome)\n        val suffix = string.substring(n\
    \ - longestPalindrome, n)\n        prefix.reverse + suffix", "        val n =\
    \ string.length\n        val s = string + \"#\" + string.reverse\n        val\
    \ z = new Array[Int](s.length)\n        z(0) = s.length\n        var l = 0; var\
    \ r = 0\n        for (i <- 1 until s.length) {\n            if (i > r) {\n   \
    \             l = r = i\n                while (r < s.length && s(r - l) == s(r))\
    \ r += 1\n                z(i) = r - l\n                r -= 1\n            }\
    \ else {\n                val k = i - l\n                if (z(k) < r - i + 1)\
    \ z(i) = z(k)\n                else {\n                    l = i\n           \
    \         while (r < s.length && s(r - l) == s(r)) r += 1\n                  \
    \  z(i) = r - l\n                    r -= 1\n                }\n            }\n\
    \        }\n        val prefix = string.substring(0, n - z(n + 1))\n        string\
    \ + prefix.reverse", "        val n = string.length\n        val s = string +\
    \ \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n        for\
    \ (i <- 1 until s.length) {\n            var j = lps(i - 1)\n            while\
    \ (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j)) lps(i)\
    \ = j + 1\n        }\n        string + string.substring(lps(s.length - 1)).reverse",
  "        val n = string.length\n        val suffix = string.substring(n / 2, n)\n\
    \        val prefix = string.substring(0, n / 2)\n        val reversedPrefix =\
    \ prefix.reverse\n        val palindromeSuffix = findLongestPalindrome(suffix)\n\
    \        val palindrome = suffix + reversedPrefix + palindromeSuffix\n       \
    \ palindrome", "        val s = string + \"#\" + string.reverse\n        val lps\
    \ = Array.fill(s.length)(0)\n        for (i <- 1 until s.length) {\n         \
    \   var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j)) j = lps(j -\
    \ 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n        string.substring(lps(s.length\
    \ - 1)) + string", "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n\
    \        var i = 0\n        var j = 1\n        while (j < n) {\n            if\
    \ (string(i) == string(j)) {\n                suffix(j) = i + 1\n            \
    \    i += 1\n                j += 1\n            } else {\n                if\
    \ (i == 0) {\n                    suffix(j) = 0\n                    j += 1\n\
    \                } else {\n                    i = suffix(i - 1)\n           \
    \     }\n            }\n        }\n        val prefix = string.substring(0, n\
    \ - suffix(n - 1))\n        prefix.reverse + string", "        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string.substring(lps(s.length - 1)) + string",
  "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n     \
    \   var i = 0\n        while (i < n) {\n            var j = 0\n            while\
    \ (i - j >= 0 && i + j < n && string(i - j) == string(i + j)) j += 1\n       \
    \     suffix(i) = j\n            var k = 1\n            while (i - k >= 0 && i\
    \ + k < n && k + suffix(i - k) < j) {\n                suffix(i + k) = suffix(i\
    \ - k)\n                k += 1\n            }\n            i += k\n        }\n\
    \        val prefix = Array.ofDim[Int](n)\n        i = 0\n        while (i < n)\
    \ {\n            var j = 0\n            while (i - j >= 0 && i + j + 1 < n &&\
    \ string(i - j) == string(i + j + 1)) j += 1\n            prefix(i) = j\n    \
    \        var k = 1\n            while (i - k >= 0 && i + k < n && k + prefix(i\
    \ - k) < j) {\n                prefix(i + k) = prefix(i - k)\n               \
    \ k += 1\n            }\n            i += k\n        }\n        var max = 0\n\
    \        var maxIndex = 0\n        for (i <- 0 until n) {\n            if (suffix(i)\
    \ > max) {\n                max = suffix(i)\n                maxIndex = i\n  \
    \          }\n            if (prefix(i) > max) {\n                max = prefix(i)\n\
    \                maxIndex = i\n            }\n        }\n        val prefixString\
    \ = string.substring(0, maxIndex - max + 1)\n        val suffixString = string.substring(maxIndex\
    \ + max)\n        prefixString + suffixString.reverse + string", "        val\
    \ n = string.length\n        val dp = Array.ofDim[Int](n, n)\n        for (i <-\
    \ 0 until n) {\n            dp(i)(i) = 1\n            if (i + 1 < n) {\n     \
    \           dp(i)(i + 1) = if (string(i) == string(i + 1)) 2 else 1\n        \
    \    }\n        }\n        for (k <- 3 to n) {\n            for (i <- 0 to n -\
    \ k) {\n                val j = i + k - 1\n                dp(i)(j) = if (string(i)\
    \ == string(j)) dp(i + 1)(j - 1) + 2 else max(dp(i + 1)(j), dp(i)(j - 1))\n  \
    \          }\n        }\n        val prefix = string.substring(0, n - dp(0)(n\
    \ - 1))\n        val suffix = prefix.reverse\n        string + suffix", "    \
    \    val n = string.length\n        val suffix = new Array[Int](n)\n        suffix(0)\
    \ = 0\n        for (i <- 1 until n) {\n            var j = suffix(i - 1)\n   \
    \         while (j > 0 && string(i) != string(j)) j = suffix(j - 1)\n        \
    \    if (string(i) == string(j)) suffix(i) = j + 1\n            else suffix(i)\
    \ = 0\n        }\n        val prefix = string.substring(0, n - suffix(n - 1))\n\
    \        string + prefix.reverse", "        val n = string.length\n        val\
    \ suffix = Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n            var\
    \ j = 0\n            while (i - j >= 0 && i + j < n && string(i - j) == string(i\
    \ + j)) j += 1\n            suffix(i) = j\n        }\n        var max = 0\n  \
    \      var maxIndex = 0\n        for (i <- 0 until n) {\n            if (suffix(i)\
    \ > max) {\n                max = suffix(i)\n                maxIndex = i\n  \
    \          }\n        }\n        val prefix = string.substring(0, maxIndex - max\
    \ + 1)\n        prefix + string", "        val n = string.length\n        val\
    \ suffix = new Array[Int](n)\n        suffix(0) = 0\n        var i = 1\n     \
    \   var j = 0\n        while (i < n) {\n            if (string(i) == string(j))\
    \ {\n                suffix(i) = j + 1\n                i += 1\n             \
    \   j += 1\n            } else {\n                if (j == 0) {\n            \
    \        suffix(i) = 0\n                    i += 1\n                } else {\n\
    \                    j = suffix(j - 1)\n                }\n            }\n   \
    \     }\n        val prefix = string.substring(0, n - suffix(n - 1))\n       \
    \ prefix.reverse + string", "        val n = string.length\n        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string + string.reverse.substring(lps(s.length\
    \ - 1))", "        val n = string.length\n        val s = string + \"#\" + string.reverse\n\
    \        val lps = Array.fill(s.length)(0)\n        for (i <- 1 until s.length)\
    \ {\n            var j = lps(i - 1)\n            while (j > 0 && s(i) != s(j))\
    \ j = lps(j - 1)\n            if (s(i) == s(j)) lps(i) = j + 1\n        }\n  \
    \      string + string.substring(lps(s.length - 1)).reverse", "        val s =\
    \ string + \"*\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n\
    \        for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n     \
    \       while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) ==\
    \ s(j)) lps(i) = j + 1\n        }\n        string.substring(lps(s.length - 1))\
    \ + string", "        val longestPalindrome = longestPalindromeSuffix(string)\n\
    \        val prefix = string.substring(0, string.length - longestPalindrome.length)\n\
    \        prefix + longestPalindrome + prefix.reverse", "        val n = string.length\n\
    \        val suffix = Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n  \
    \          var j = i\n            while (j >= 0 && string(j) == string(n - 1 -\
    \ i + j)) j -= 1\n            suffix(i) = i - j\n        }\n        var i = 0\n\
    \        while (i < n && suffix(i) != i + 1) i += 1\n        val prefix = string.substring(0,\
    \ n - i)\n        prefix.reverse + string", "        val n = string.length\n \
    \       val suffix = Array.ofDim[Int](n)\n        var i = 0\n        var j = 1\n\
    \        while (j < n) {\n            if (string(i) == string(j)) {\n        \
    \        suffix(j) = i + 1\n                i += 1\n                j += 1\n \
    \           } else {\n                if (i == 0) {\n                    suffix(j)\
    \ = 0\n                    j += 1\n                } else {\n                \
    \    i = suffix(i - 1)\n                }\n            }\n        }\n        val\
    \ prefix = string.substring(0, n - suffix(n - 1))\n        string + prefix.reverse",
  "        val n = string.length\n        val s = string + \"#\" + string.reverse\n\
    \        val z = Array.fill(s.length)(0)\n        var l = 0; var r = 0\n     \
    \   for (i <- 1 until s.length) {\n            if (i > r) {\n                l\
    \ = i; r = i\n                while (r < s.length && s(r - l) == s(r)) r += 1\n\
    \                z(i) = r - l; r -= 1\n            } else {\n                val\
    \ k = i - l\n                if (z(k) < r - i + 1) z(i) = z(k)\n             \
    \   else {\n                    l = i\n                    while (r < s.length\
    \ && s(r - l) == s(r)) r += 1\n                    z(i) = r - l; r -= 1\n    \
    \            }\n            }\n        }\n        val longestPalindrome = z.max\n\
    \        string.substring(longestPalindrome) + string", "        val n = string.length\n\
    \        val suffix = Array.ofDim[Int](n)\n        for (i <- 0 until n) {\n  \
    \          var j = 0\n            while (i - j >= 0 && i + j < n && string(i -\
    \ j) == string(i + j)) j += 1\n            suffix(i) = j\n        }\n        var\
    \ max = 0\n        var maxIndex = 0\n        for (i <- 0 until n) {\n        \
    \    if (suffix(i) > max) {\n                max = suffix(i)\n               \
    \ maxIndex = i\n            }\n        }\n        string.substring(maxIndex +\
    \ 1, n) + string", "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n\
    \        suffix(0) = 0\n        var i = 1\n        var j = 0\n        while (i\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(i)\
    \ = j + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (j == 0) {\n                    suffix(i) = 0\n      \
    \              i += 1\n                } else {\n                    j = suffix(j\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        string + prefix.reverse", "        val reversed\
    \ = string.reverse\n        val longestPalindrome = (0 to string.length).map(i\
    \ => string.substring(i)).find(s => s == reversed.substring(0, s.length)).get\n\
    \        val prefix = string.substring(0, string.length - longestPalindrome.length)\n\
    \        prefix.reverse + string", "        val n = string.length\n        val\
    \ s = string + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n\
    \        for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n     \
    \       while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) ==\
    \ s(j)) lps(i) = j + 1\n        }\n        string + string.reverse.substring(lps(s.length\
    \ - 1))", "        val n = string.length\n        val suffix = new Array[Int](n)\n\
    \        suffix(0) = 0\n        var i = 1\n        var j = 0\n        while (i\
    \ < n) {\n            if (string(i) == string(j)) {\n                suffix(i)\
    \ = j + 1\n                i += 1\n                j += 1\n            } else\
    \ {\n                if (j == 0) {\n                    suffix(i) = 0\n      \
    \              i += 1\n                } else {\n                    j = suffix(j\
    \ - 1)\n                }\n            }\n        }\n        val prefix = string.substring(0,\
    \ n - suffix(n - 1))\n        prefix.reverse + string", "        val s = string\
    \ + \"#\" + string.reverse\n        val lps = Array.fill(s.length)(0)\n      \
    \  for (i <- 1 until s.length) {\n            var j = lps(i - 1)\n           \
    \ while (j > 0 && s(i) != s(j)) j = lps(j - 1)\n            if (s(i) == s(j))\
    \ lps(i) = j + 1\n        }\n        string.substring(lps(s.length - 1)) + string",
  "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n     \
    \   // suffix[i] is the length of the longest palindromic suffix of string[0..i]\n\
    \        // suffix[i] is also the length of the longest palindromic prefix of\
    \ string[i..n-1]\n        for (i <- 0 until n) {\n            var j = 0\n    \
    \        while (i - j >= 0 && i + j < n && string(i - j) == string(i + j)) j +=\
    \ 1\n            suffix(i) = j\n        }\n        var max = 0\n        var maxIndex\
    \ = 0\n        for (i <- 0 until n) {\n            if (suffix(i) > max) {\n  \
    \              max = suffix(i)\n                maxIndex = i\n            }\n\
    \        }\n        val prefix = string.substring(0, maxIndex - max + 1)\n   \
    \     prefix + string", "        var prefix = string\n        var suffix = \"\"\
    \n        var palindrome = \"\"\n        while (prefix.length > 0) {\n       \
    \     if (isPalindrome(prefix)) {\n                palindrome = prefix + suffix\n\
    \                break\n            }\n            suffix = prefix.charAt(0) +\
    \ suffix\n            prefix = prefix.substring(1)\n        }\n        palindrome",
  "        val n = string.length\n        val suffix = Array.ofDim[Int](n)\n     \
    \   for (i <- 0 until n) {\n            var j = 0\n            while (i - j >=\
    \ 0 && i + j < n && string(i - j) == string(i + j)) j += 1\n            suffix(i)\
    \ = j\n        }\n        var longest = 0\n        var longestIndex = 0\n    \
    \    for (i <- 0 until n) {\n            if (suffix(i) > longest) {\n        \
    \        longest = suffix(i)\n                longestIndex = i\n            }\n\
    \        }\n        val prefix = string.substring(0, longestIndex - longest +\
    \ 1)\n        string + prefix.reverse"]
stop_tokens:
- "\n    }\n"
